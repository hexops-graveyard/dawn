{"emscripten-bits/webgpu.h": "// BSD 3-Clause License\n//\n// Copyright (c) 2019, \"WebGPU native\" developers\n// All rights reserved.\n//\n// Redistribution and use in source and binary forms, with or without\n// modification, are permitted provided that the following conditions are met:\n//\n// 1. Redistributions of source code must retain the above copyright notice, this\n//    list of conditions and the following disclaimer.\n//\n// 2. Redistributions in binary form must reproduce the above copyright notice,\n//    this list of conditions and the following disclaimer in the documentation\n//    and/or other materials provided with the distribution.\n//\n// 3. Neither the name of the copyright holder nor the names of its\n//    contributors may be used to endorse or promote products derived from\n//    this software without specific prior written permission.\n//\n// THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS \"AS IS\"\n// AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE\n// IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE\n// DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE LIABLE\n// FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL\n// DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR\n// SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER\n// CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY,\n// OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE\n// OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.\n#ifndef WEBGPU_H_\n#define WEBGPU_H_\n\n#if defined(WGPU_SHARED_LIBRARY)\n#    if defined(_WIN32)\n#        if defined(WGPU_IMPLEMENTATION)\n#            define WGPU_EXPORT __declspec(dllexport)\n#        else\n#            define WGPU_EXPORT __declspec(dllimport)\n#        endif\n#    else  // defined(_WIN32)\n#        if defined(WGPU_IMPLEMENTATION)\n#            define WGPU_EXPORT __attribute__((visibility(\"default\")))\n#        else\n#            define WGPU_EXPORT\n#        endif\n#    endif  // defined(_WIN32)\n#else       // defined(WGPU_SHARED_LIBRARY)\n#    define WGPU_EXPORT\n#endif  // defined(WGPU_SHARED_LIBRARY)\n\n#if !defined(WGPU_OBJECT_ATTRIBUTE)\n#define WGPU_OBJECT_ATTRIBUTE\n#endif\n#if !defined(WGPU_ENUM_ATTRIBUTE)\n#define WGPU_ENUM_ATTRIBUTE\n#endif\n#if !defined(WGPU_STRUCTURE_ATTRIBUTE)\n#define WGPU_STRUCTURE_ATTRIBUTE\n#endif\n#if !defined(WGPU_FUNCTION_ATTRIBUTE)\n#define WGPU_FUNCTION_ATTRIBUTE\n#endif\n#if !defined(WGPU_NULLABLE)\n#define WGPU_NULLABLE\n#endif\n\n#include <stdint.h>\n#include <stddef.h>\n#include <stdbool.h>\n\n#define WGPU_ARRAY_LAYER_COUNT_UNDEFINED (0xffffffffUL)\n#define WGPU_COPY_STRIDE_UNDEFINED (0xffffffffUL)\n#define WGPU_LIMIT_U32_UNDEFINED (0xffffffffUL)\n#define WGPU_LIMIT_U64_UNDEFINED (0xffffffffffffffffULL)\n#define WGPU_MIP_LEVEL_COUNT_UNDEFINED (0xffffffffUL)\n#define WGPU_WHOLE_MAP_SIZE SIZE_MAX\n#define WGPU_WHOLE_SIZE (0xffffffffffffffffULL)\n\ntypedef uint32_t WGPUFlags;\n\ntypedef struct WGPUAdapterImpl* WGPUAdapter WGPU_OBJECT_ATTRIBUTE;\ntypedef struct WGPUBindGroupImpl* WGPUBindGroup WGPU_OBJECT_ATTRIBUTE;\ntypedef struct WGPUBindGroupLayoutImpl* WGPUBindGroupLayout WGPU_OBJECT_ATTRIBUTE;\ntypedef struct WGPUBufferImpl* WGPUBuffer WGPU_OBJECT_ATTRIBUTE;\ntypedef struct WGPUCommandBufferImpl* WGPUCommandBuffer WGPU_OBJECT_ATTRIBUTE;\ntypedef struct WGPUCommandEncoderImpl* WGPUCommandEncoder WGPU_OBJECT_ATTRIBUTE;\ntypedef struct WGPUComputePassEncoderImpl* WGPUComputePassEncoder WGPU_OBJECT_ATTRIBUTE;\ntypedef struct WGPUComputePipelineImpl* WGPUComputePipeline WGPU_OBJECT_ATTRIBUTE;\ntypedef struct WGPUDeviceImpl* WGPUDevice WGPU_OBJECT_ATTRIBUTE;\ntypedef struct WGPUInstanceImpl* WGPUInstance WGPU_OBJECT_ATTRIBUTE;\ntypedef struct WGPUPipelineLayoutImpl* WGPUPipelineLayout WGPU_OBJECT_ATTRIBUTE;\ntypedef struct WGPUQuerySetImpl* WGPUQuerySet WGPU_OBJECT_ATTRIBUTE;\ntypedef struct WGPUQueueImpl* WGPUQueue WGPU_OBJECT_ATTRIBUTE;\ntypedef struct WGPURenderBundleImpl* WGPURenderBundle WGPU_OBJECT_ATTRIBUTE;\ntypedef struct WGPURenderBundleEncoderImpl* WGPURenderBundleEncoder WGPU_OBJECT_ATTRIBUTE;\ntypedef struct WGPURenderPassEncoderImpl* WGPURenderPassEncoder WGPU_OBJECT_ATTRIBUTE;\ntypedef struct WGPURenderPipelineImpl* WGPURenderPipeline WGPU_OBJECT_ATTRIBUTE;\ntypedef struct WGPUSamplerImpl* WGPUSampler WGPU_OBJECT_ATTRIBUTE;\ntypedef struct WGPUShaderModuleImpl* WGPUShaderModule WGPU_OBJECT_ATTRIBUTE;\ntypedef struct WGPUSurfaceImpl* WGPUSurface WGPU_OBJECT_ATTRIBUTE;\ntypedef struct WGPUSwapChainImpl* WGPUSwapChain WGPU_OBJECT_ATTRIBUTE;\ntypedef struct WGPUTextureImpl* WGPUTexture WGPU_OBJECT_ATTRIBUTE;\ntypedef struct WGPUTextureViewImpl* WGPUTextureView WGPU_OBJECT_ATTRIBUTE;\n\n// Structure forward declarations\nstruct WGPUAdapterProperties;\nstruct WGPUBindGroupEntry;\nstruct WGPUBlendComponent;\nstruct WGPUBufferBindingLayout;\nstruct WGPUBufferDescriptor;\nstruct WGPUColor;\nstruct WGPUCommandBufferDescriptor;\nstruct WGPUCommandEncoderDescriptor;\nstruct WGPUCompilationMessage;\nstruct WGPUComputePassTimestampWrite;\nstruct WGPUConstantEntry;\nstruct WGPUExtent3D;\nstruct WGPUInstanceDescriptor;\nstruct WGPULimits;\nstruct WGPUMultisampleState;\nstruct WGPUOrigin3D;\nstruct WGPUPipelineLayoutDescriptor;\nstruct WGPUPrimitiveDepthClipControl;\nstruct WGPUPrimitiveState;\nstruct WGPUQuerySetDescriptor;\nstruct WGPUQueueDescriptor;\nstruct WGPURenderBundleDescriptor;\nstruct WGPURenderBundleEncoderDescriptor;\nstruct WGPURenderPassDepthStencilAttachment;\nstruct WGPURenderPassDescriptorMaxDrawCount;\nstruct WGPURenderPassTimestampWrite;\nstruct WGPURequestAdapterOptions;\nstruct WGPUSamplerBindingLayout;\nstruct WGPUSamplerDescriptor;\nstruct WGPUShaderModuleDescriptor;\nstruct WGPUShaderModuleSPIRVDescriptor;\nstruct WGPUShaderModuleWGSLDescriptor;\nstruct WGPUStencilFaceState;\nstruct WGPUStorageTextureBindingLayout;\nstruct WGPUSurfaceDescriptor;\nstruct WGPUSurfaceDescriptorFromCanvasHTMLSelector;\nstruct WGPUSwapChainDescriptor;\nstruct WGPUTextureBindingLayout;\nstruct WGPUTextureDataLayout;\nstruct WGPUTextureViewDescriptor;\nstruct WGPUVertexAttribute;\nstruct WGPUBindGroupDescriptor;\nstruct WGPUBindGroupLayoutEntry;\nstruct WGPUBlendState;\nstruct WGPUCompilationInfo;\nstruct WGPUComputePassDescriptor;\nstruct WGPUDepthStencilState;\nstruct WGPUImageCopyBuffer;\nstruct WGPUImageCopyTexture;\nstruct WGPUProgrammableStageDescriptor;\nstruct WGPURenderPassColorAttachment;\nstruct WGPURequiredLimits;\nstruct WGPUSupportedLimits;\nstruct WGPUTextureDescriptor;\nstruct WGPUVertexBufferLayout;\nstruct WGPUBindGroupLayoutDescriptor;\nstruct WGPUColorTargetState;\nstruct WGPUComputePipelineDescriptor;\nstruct WGPUDeviceDescriptor;\nstruct WGPURenderPassDescriptor;\nstruct WGPUVertexState;\nstruct WGPUFragmentState;\nstruct WGPURenderPipelineDescriptor;\n\ntypedef enum WGPUAdapterType {\n    WGPUAdapterType_DiscreteGPU = 0x00000000,\n    WGPUAdapterType_IntegratedGPU = 0x00000001,\n    WGPUAdapterType_CPU = 0x00000002,\n    WGPUAdapterType_Unknown = 0x00000003,\n    WGPUAdapterType_Force32 = 0x7FFFFFFF\n} WGPUAdapterType WGPU_ENUM_ATTRIBUTE;\n\ntypedef enum WGPUAddressMode {\n    WGPUAddressMode_Repeat = 0x00000000,\n    WGPUAddressMode_MirrorRepeat = 0x00000001,\n    WGPUAddressMode_ClampToEdge = 0x00000002,\n    WGPUAddressMode_Force32 = 0x7FFFFFFF\n} WGPUAddressMode WGPU_ENUM_ATTRIBUTE;\n\ntypedef enum WGPUBackendType {\n    WGPUBackendType_Undefined = 0x00000000,\n    WGPUBackendType_Null = 0x00000001,\n    WGPUBackendType_WebGPU = 0x00000002,\n    WGPUBackendType_D3D11 = 0x00000003,\n    WGPUBackendType_D3D12 = 0x00000004,\n    WGPUBackendType_Metal = 0x00000005,\n    WGPUBackendType_Vulkan = 0x00000006,\n    WGPUBackendType_OpenGL = 0x00000007,\n    WGPUBackendType_OpenGLES = 0x00000008,\n    WGPUBackendType_Force32 = 0x7FFFFFFF\n} WGPUBackendType WGPU_ENUM_ATTRIBUTE;\n\ntypedef enum WGPUBlendFactor {\n    WGPUBlendFactor_Zero = 0x00000000,\n    WGPUBlendFactor_One = 0x00000001,\n    WGPUBlendFactor_Src = 0x00000002,\n    WGPUBlendFactor_OneMinusSrc = 0x00000003,\n    WGPUBlendFactor_SrcAlpha = 0x00000004,\n    WGPUBlendFactor_OneMinusSrcAlpha = 0x00000005,\n    WGPUBlendFactor_Dst = 0x00000006,\n    WGPUBlendFactor_OneMinusDst = 0x00000007,\n    WGPUBlendFactor_DstAlpha = 0x00000008,\n    WGPUBlendFactor_OneMinusDstAlpha = 0x00000009,\n    WGPUBlendFactor_SrcAlphaSaturated = 0x0000000A,\n    WGPUBlendFactor_Constant = 0x0000000B,\n    WGPUBlendFactor_OneMinusConstant = 0x0000000C,\n    WGPUBlendFactor_Force32 = 0x7FFFFFFF\n} WGPUBlendFactor WGPU_ENUM_ATTRIBUTE;\n\ntypedef enum WGPUBlendOperation {\n    WGPUBlendOperation_Add = 0x00000000,\n    WGPUBlendOperation_Subtract = 0x00000001,\n    WGPUBlendOperation_ReverseSubtract = 0x00000002,\n    WGPUBlendOperation_Min = 0x00000003,\n    WGPUBlendOperation_Max = 0x00000004,\n    WGPUBlendOperation_Force32 = 0x7FFFFFFF\n} WGPUBlendOperation WGPU_ENUM_ATTRIBUTE;\n\ntypedef enum WGPUBufferBindingType {\n    WGPUBufferBindingType_Undefined = 0x00000000,\n    WGPUBufferBindingType_Uniform = 0x00000001,\n    WGPUBufferBindingType_Storage = 0x00000002,\n    WGPUBufferBindingType_ReadOnlyStorage = 0x00000003,\n    WGPUBufferBindingType_Force32 = 0x7FFFFFFF\n} WGPUBufferBindingType WGPU_ENUM_ATTRIBUTE;\n\ntypedef enum WGPUBufferMapAsyncStatus {\n    WGPUBufferMapAsyncStatus_Success = 0x00000000,\n    WGPUBufferMapAsyncStatus_ValidationError = 0x00000001,\n    WGPUBufferMapAsyncStatus_Unknown = 0x00000002,\n    WGPUBufferMapAsyncStatus_DeviceLost = 0x00000003,\n    WGPUBufferMapAsyncStatus_DestroyedBeforeCallback = 0x00000004,\n    WGPUBufferMapAsyncStatus_UnmappedBeforeCallback = 0x00000005,\n    WGPUBufferMapAsyncStatus_MappingAlreadyPending = 0x00000006,\n    WGPUBufferMapAsyncStatus_OffsetOutOfRange = 0x00000007,\n    WGPUBufferMapAsyncStatus_SizeOutOfRange = 0x00000008,\n    WGPUBufferMapAsyncStatus_Force32 = 0x7FFFFFFF\n} WGPUBufferMapAsyncStatus WGPU_ENUM_ATTRIBUTE;\n\ntypedef enum WGPUBufferMapState {\n    WGPUBufferMapState_Unmapped = 0x00000000,\n    WGPUBufferMapState_Pending = 0x00000001,\n    WGPUBufferMapState_Mapped = 0x00000002,\n    WGPUBufferMapState_Force32 = 0x7FFFFFFF\n} WGPUBufferMapState WGPU_ENUM_ATTRIBUTE;\n\ntypedef enum WGPUCompareFunction {\n    WGPUCompareFunction_Undefined = 0x00000000,\n    WGPUCompareFunction_Never = 0x00000001,\n    WGPUCompareFunction_Less = 0x00000002,\n    WGPUCompareFunction_LessEqual = 0x00000003,\n    WGPUCompareFunction_Greater = 0x00000004,\n    WGPUCompareFunction_GreaterEqual = 0x00000005,\n    WGPUCompareFunction_Equal = 0x00000006,\n    WGPUCompareFunction_NotEqual = 0x00000007,\n    WGPUCompareFunction_Always = 0x00000008,\n    WGPUCompareFunction_Force32 = 0x7FFFFFFF\n} WGPUCompareFunction WGPU_ENUM_ATTRIBUTE;\n\ntypedef enum WGPUCompilationInfoRequestStatus {\n    WGPUCompilationInfoRequestStatus_Success = 0x00000000,\n    WGPUCompilationInfoRequestStatus_Error = 0x00000001,\n    WGPUCompilationInfoRequestStatus_DeviceLost = 0x00000002,\n    WGPUCompilationInfoRequestStatus_Unknown = 0x00000003,\n    WGPUCompilationInfoRequestStatus_Force32 = 0x7FFFFFFF\n} WGPUCompilationInfoRequestStatus WGPU_ENUM_ATTRIBUTE;\n\ntypedef enum WGPUCompilationMessageType {\n    WGPUCompilationMessageType_Error = 0x00000000,\n    WGPUCompilationMessageType_Warning = 0x00000001,\n    WGPUCompilationMessageType_Info = 0x00000002,\n    WGPUCompilationMessageType_Force32 = 0x7FFFFFFF\n} WGPUCompilationMessageType WGPU_ENUM_ATTRIBUTE;\n\ntypedef enum WGPUComputePassTimestampLocation {\n    WGPUComputePassTimestampLocation_Beginning = 0x00000000,\n    WGPUComputePassTimestampLocation_End = 0x00000001,\n    WGPUComputePassTimestampLocation_Force32 = 0x7FFFFFFF\n} WGPUComputePassTimestampLocation WGPU_ENUM_ATTRIBUTE;\n\ntypedef enum WGPUCreatePipelineAsyncStatus {\n    WGPUCreatePipelineAsyncStatus_Success = 0x00000000,\n    WGPUCreatePipelineAsyncStatus_ValidationError = 0x00000001,\n    WGPUCreatePipelineAsyncStatus_InternalError = 0x00000002,\n    WGPUCreatePipelineAsyncStatus_DeviceLost = 0x00000003,\n    WGPUCreatePipelineAsyncStatus_DeviceDestroyed = 0x00000004,\n    WGPUCreatePipelineAsyncStatus_Unknown = 0x00000005,\n    WGPUCreatePipelineAsyncStatus_Force32 = 0x7FFFFFFF\n} WGPUCreatePipelineAsyncStatus WGPU_ENUM_ATTRIBUTE;\n\ntypedef enum WGPUCullMode {\n    WGPUCullMode_None = 0x00000000,\n    WGPUCullMode_Front = 0x00000001,\n    WGPUCullMode_Back = 0x00000002,\n    WGPUCullMode_Force32 = 0x7FFFFFFF\n} WGPUCullMode WGPU_ENUM_ATTRIBUTE;\n\ntypedef enum WGPUDeviceLostReason {\n    WGPUDeviceLostReason_Undefined = 0x00000000,\n    WGPUDeviceLostReason_Destroyed = 0x00000001,\n    WGPUDeviceLostReason_Force32 = 0x7FFFFFFF\n} WGPUDeviceLostReason WGPU_ENUM_ATTRIBUTE;\n\ntypedef enum WGPUErrorFilter {\n    WGPUErrorFilter_Validation = 0x00000000,\n    WGPUErrorFilter_OutOfMemory = 0x00000001,\n    WGPUErrorFilter_Internal = 0x00000002,\n    WGPUErrorFilter_Force32 = 0x7FFFFFFF\n} WGPUErrorFilter WGPU_ENUM_ATTRIBUTE;\n\ntypedef enum WGPUErrorType {\n    WGPUErrorType_NoError = 0x00000000,\n    WGPUErrorType_Validation = 0x00000001,\n    WGPUErrorType_OutOfMemory = 0x00000002,\n    WGPUErrorType_Internal = 0x00000003,\n    WGPUErrorType_Unknown = 0x00000004,\n    WGPUErrorType_DeviceLost = 0x00000005,\n    WGPUErrorType_Force32 = 0x7FFFFFFF\n} WGPUErrorType WGPU_ENUM_ATTRIBUTE;\n\ntypedef enum WGPUFeatureName {\n    WGPUFeatureName_Undefined = 0x00000000,\n    WGPUFeatureName_DepthClipControl = 0x00000001,\n    WGPUFeatureName_Depth32FloatStencil8 = 0x00000002,\n    WGPUFeatureName_TimestampQuery = 0x00000003,\n    WGPUFeatureName_PipelineStatisticsQuery = 0x00000004,\n    WGPUFeatureName_TextureCompressionBC = 0x00000005,\n    WGPUFeatureName_TextureCompressionETC2 = 0x00000006,\n    WGPUFeatureName_TextureCompressionASTC = 0x00000007,\n    WGPUFeatureName_IndirectFirstInstance = 0x00000008,\n    WGPUFeatureName_ShaderF16 = 0x00000009,\n    WGPUFeatureName_RG11B10UfloatRenderable = 0x0000000A,\n    WGPUFeatureName_BGRA8UnormStorage = 0x0000000B,\n    WGPUFeatureName_Float32Filterable = 0x0000000C,\n    WGPUFeatureName_Force32 = 0x7FFFFFFF\n} WGPUFeatureName WGPU_ENUM_ATTRIBUTE;\n\ntypedef enum WGPUFilterMode {\n    WGPUFilterMode_Nearest = 0x00000000,\n    WGPUFilterMode_Linear = 0x00000001,\n    WGPUFilterMode_Force32 = 0x7FFFFFFF\n} WGPUFilterMode WGPU_ENUM_ATTRIBUTE;\n\ntypedef enum WGPUFrontFace {\n    WGPUFrontFace_CCW = 0x00000000,\n    WGPUFrontFace_CW = 0x00000001,\n    WGPUFrontFace_Force32 = 0x7FFFFFFF\n} WGPUFrontFace WGPU_ENUM_ATTRIBUTE;\n\ntypedef enum WGPUIndexFormat {\n    WGPUIndexFormat_Undefined = 0x00000000,\n    WGPUIndexFormat_Uint16 = 0x00000001,\n    WGPUIndexFormat_Uint32 = 0x00000002,\n    WGPUIndexFormat_Force32 = 0x7FFFFFFF\n} WGPUIndexFormat WGPU_ENUM_ATTRIBUTE;\n\ntypedef enum WGPULoadOp {\n    WGPULoadOp_Undefined = 0x00000000,\n    WGPULoadOp_Clear = 0x00000001,\n    WGPULoadOp_Load = 0x00000002,\n    WGPULoadOp_Force32 = 0x7FFFFFFF\n} WGPULoadOp WGPU_ENUM_ATTRIBUTE;\n\ntypedef enum WGPUMipmapFilterMode {\n    WGPUMipmapFilterMode_Nearest = 0x00000000,\n    WGPUMipmapFilterMode_Linear = 0x00000001,\n    WGPUMipmapFilterMode_Force32 = 0x7FFFFFFF\n} WGPUMipmapFilterMode WGPU_ENUM_ATTRIBUTE;\n\ntypedef enum WGPUPipelineStatisticName {\n    WGPUPipelineStatisticName_VertexShaderInvocations = 0x00000000,\n    WGPUPipelineStatisticName_ClipperInvocations = 0x00000001,\n    WGPUPipelineStatisticName_ClipperPrimitivesOut = 0x00000002,\n    WGPUPipelineStatisticName_FragmentShaderInvocations = 0x00000003,\n    WGPUPipelineStatisticName_ComputeShaderInvocations = 0x00000004,\n    WGPUPipelineStatisticName_Force32 = 0x7FFFFFFF\n} WGPUPipelineStatisticName WGPU_ENUM_ATTRIBUTE;\n\ntypedef enum WGPUPowerPreference {\n    WGPUPowerPreference_Undefined = 0x00000000,\n    WGPUPowerPreference_LowPower = 0x00000001,\n    WGPUPowerPreference_HighPerformance = 0x00000002,\n    WGPUPowerPreference_Force32 = 0x7FFFFFFF\n} WGPUPowerPreference WGPU_ENUM_ATTRIBUTE;\n\ntypedef enum WGPUPresentMode {\n    WGPUPresentMode_Immediate = 0x00000000,\n    WGPUPresentMode_Mailbox = 0x00000001,\n    WGPUPresentMode_Fifo = 0x00000002,\n    WGPUPresentMode_Force32 = 0x7FFFFFFF\n} WGPUPresentMode WGPU_ENUM_ATTRIBUTE;\n\ntypedef enum WGPUPrimitiveTopology {\n    WGPUPrimitiveTopology_PointList = 0x00000000,\n    WGPUPrimitiveTopology_LineList = 0x00000001,\n    WGPUPrimitiveTopology_LineStrip = 0x00000002,\n    WGPUPrimitiveTopology_TriangleList = 0x00000003,\n    WGPUPrimitiveTopology_TriangleStrip = 0x00000004,\n    WGPUPrimitiveTopology_Force32 = 0x7FFFFFFF\n} WGPUPrimitiveTopology WGPU_ENUM_ATTRIBUTE;\n\ntypedef enum WGPUQueryType {\n    WGPUQueryType_Occlusion = 0x00000000,\n    WGPUQueryType_PipelineStatistics = 0x00000001,\n    WGPUQueryType_Timestamp = 0x00000002,\n    WGPUQueryType_Force32 = 0x7FFFFFFF\n} WGPUQueryType WGPU_ENUM_ATTRIBUTE;\n\ntypedef enum WGPUQueueWorkDoneStatus {\n    WGPUQueueWorkDoneStatus_Success = 0x00000000,\n    WGPUQueueWorkDoneStatus_Error = 0x00000001,\n    WGPUQueueWorkDoneStatus_Unknown = 0x00000002,\n    WGPUQueueWorkDoneStatus_DeviceLost = 0x00000003,\n    WGPUQueueWorkDoneStatus_Force32 = 0x7FFFFFFF\n} WGPUQueueWorkDoneStatus WGPU_ENUM_ATTRIBUTE;\n\ntypedef enum WGPURenderPassTimestampLocation {\n    WGPURenderPassTimestampLocation_Beginning = 0x00000000,\n    WGPURenderPassTimestampLocation_End = 0x00000001,\n    WGPURenderPassTimestampLocation_Force32 = 0x7FFFFFFF\n} WGPURenderPassTimestampLocation WGPU_ENUM_ATTRIBUTE;\n\ntypedef enum WGPURequestAdapterStatus {\n    WGPURequestAdapterStatus_Success = 0x00000000,\n    WGPURequestAdapterStatus_Unavailable = 0x00000001,\n    WGPURequestAdapterStatus_Error = 0x00000002,\n    WGPURequestAdapterStatus_Unknown = 0x00000003,\n    WGPURequestAdapterStatus_Force32 = 0x7FFFFFFF\n} WGPURequestAdapterStatus WGPU_ENUM_ATTRIBUTE;\n\ntypedef enum WGPURequestDeviceStatus {\n    WGPURequestDeviceStatus_Success = 0x00000000,\n    WGPURequestDeviceStatus_Error = 0x00000001,\n    WGPURequestDeviceStatus_Unknown = 0x00000002,\n    WGPURequestDeviceStatus_Force32 = 0x7FFFFFFF\n} WGPURequestDeviceStatus WGPU_ENUM_ATTRIBUTE;\n\ntypedef enum WGPUSType {\n    WGPUSType_Invalid = 0x00000000,\n    WGPUSType_SurfaceDescriptorFromCanvasHTMLSelector = 0x00000004,\n    WGPUSType_ShaderModuleSPIRVDescriptor = 0x00000005,\n    WGPUSType_ShaderModuleWGSLDescriptor = 0x00000006,\n    WGPUSType_PrimitiveDepthClipControl = 0x00000007,\n    WGPUSType_RenderPassDescriptorMaxDrawCount = 0x0000000F,\n    WGPUSType_Force32 = 0x7FFFFFFF\n} WGPUSType WGPU_ENUM_ATTRIBUTE;\n\ntypedef enum WGPUSamplerBindingType {\n    WGPUSamplerBindingType_Undefined = 0x00000000,\n    WGPUSamplerBindingType_Filtering = 0x00000001,\n    WGPUSamplerBindingType_NonFiltering = 0x00000002,\n    WGPUSamplerBindingType_Comparison = 0x00000003,\n    WGPUSamplerBindingType_Force32 = 0x7FFFFFFF\n} WGPUSamplerBindingType WGPU_ENUM_ATTRIBUTE;\n\ntypedef enum WGPUStencilOperation {\n    WGPUStencilOperation_Keep = 0x00000000,\n    WGPUStencilOperation_Zero = 0x00000001,\n    WGPUStencilOperation_Replace = 0x00000002,\n    WGPUStencilOperation_Invert = 0x00000003,\n    WGPUStencilOperation_IncrementClamp = 0x00000004,\n    WGPUStencilOperation_DecrementClamp = 0x00000005,\n    WGPUStencilOperation_IncrementWrap = 0x00000006,\n    WGPUStencilOperation_DecrementWrap = 0x00000007,\n    WGPUStencilOperation_Force32 = 0x7FFFFFFF\n} WGPUStencilOperation WGPU_ENUM_ATTRIBUTE;\n\ntypedef enum WGPUStorageTextureAccess {\n    WGPUStorageTextureAccess_Undefined = 0x00000000,\n    WGPUStorageTextureAccess_WriteOnly = 0x00000001,\n    WGPUStorageTextureAccess_Force32 = 0x7FFFFFFF\n} WGPUStorageTextureAccess WGPU_ENUM_ATTRIBUTE;\n\ntypedef enum WGPUStoreOp {\n    WGPUStoreOp_Undefined = 0x00000000,\n    WGPUStoreOp_Store = 0x00000001,\n    WGPUStoreOp_Discard = 0x00000002,\n    WGPUStoreOp_Force32 = 0x7FFFFFFF\n} WGPUStoreOp WGPU_ENUM_ATTRIBUTE;\n\ntypedef enum WGPUTextureAspect {\n    WGPUTextureAspect_All = 0x00000000,\n    WGPUTextureAspect_StencilOnly = 0x00000001,\n    WGPUTextureAspect_DepthOnly = 0x00000002,\n    WGPUTextureAspect_Force32 = 0x7FFFFFFF\n} WGPUTextureAspect WGPU_ENUM_ATTRIBUTE;\n\ntypedef enum WGPUTextureDimension {\n    WGPUTextureDimension_1D = 0x00000000,\n    WGPUTextureDimension_2D = 0x00000001,\n    WGPUTextureDimension_3D = 0x00000002,\n    WGPUTextureDimension_Force32 = 0x7FFFFFFF\n} WGPUTextureDimension WGPU_ENUM_ATTRIBUTE;\n\ntypedef enum WGPUTextureFormat {\n    WGPUTextureFormat_Undefined = 0x00000000,\n    WGPUTextureFormat_R8Unorm = 0x00000001,\n    WGPUTextureFormat_R8Snorm = 0x00000002,\n    WGPUTextureFormat_R8Uint = 0x00000003,\n    WGPUTextureFormat_R8Sint = 0x00000004,\n    WGPUTextureFormat_R16Uint = 0x00000005,\n    WGPUTextureFormat_R16Sint = 0x00000006,\n    WGPUTextureFormat_R16Float = 0x00000007,\n    WGPUTextureFormat_RG8Unorm = 0x00000008,\n    WGPUTextureFormat_RG8Snorm = 0x00000009,\n    WGPUTextureFormat_RG8Uint = 0x0000000A,\n    WGPUTextureFormat_RG8Sint = 0x0000000B,\n    WGPUTextureFormat_R32Float = 0x0000000C,\n    WGPUTextureFormat_R32Uint = 0x0000000D,\n    WGPUTextureFormat_R32Sint = 0x0000000E,\n    WGPUTextureFormat_RG16Uint = 0x0000000F,\n    WGPUTextureFormat_RG16Sint = 0x00000010,\n    WGPUTextureFormat_RG16Float = 0x00000011,\n    WGPUTextureFormat_RGBA8Unorm = 0x00000012,\n    WGPUTextureFormat_RGBA8UnormSrgb = 0x00000013,\n    WGPUTextureFormat_RGBA8Snorm = 0x00000014,\n    WGPUTextureFormat_RGBA8Uint = 0x00000015,\n    WGPUTextureFormat_RGBA8Sint = 0x00000016,\n    WGPUTextureFormat_BGRA8Unorm = 0x00000017,\n    WGPUTextureFormat_BGRA8UnormSrgb = 0x00000018,\n    WGPUTextureFormat_RGB10A2Unorm = 0x00000019,\n    WGPUTextureFormat_RG11B10Ufloat = 0x0000001A,\n    WGPUTextureFormat_RGB9E5Ufloat = 0x0000001B,\n    WGPUTextureFormat_RG32Float = 0x0000001C,\n    WGPUTextureFormat_RG32Uint = 0x0000001D,\n    WGPUTextureFormat_RG32Sint = 0x0000001E,\n    WGPUTextureFormat_RGBA16Uint = 0x0000001F,\n    WGPUTextureFormat_RGBA16Sint = 0x00000020,\n    WGPUTextureFormat_RGBA16Float = 0x00000021,\n    WGPUTextureFormat_RGBA32Float = 0x00000022,\n    WGPUTextureFormat_RGBA32Uint = 0x00000023,\n    WGPUTextureFormat_RGBA32Sint = 0x00000024,\n    WGPUTextureFormat_Stencil8 = 0x00000025,\n    WGPUTextureFormat_Depth16Unorm = 0x00000026,\n    WGPUTextureFormat_Depth24Plus = 0x00000027,\n    WGPUTextureFormat_Depth24PlusStencil8 = 0x00000028,\n    WGPUTextureFormat_Depth32Float = 0x00000029,\n    WGPUTextureFormat_Depth32FloatStencil8 = 0x0000002A,\n    WGPUTextureFormat_BC1RGBAUnorm = 0x0000002B,\n    WGPUTextureFormat_BC1RGBAUnormSrgb = 0x0000002C,\n    WGPUTextureFormat_BC2RGBAUnorm = 0x0000002D,\n    WGPUTextureFormat_BC2RGBAUnormSrgb = 0x0000002E,\n    WGPUTextureFormat_BC3RGBAUnorm = 0x0000002F,\n    WGPUTextureFormat_BC3RGBAUnormSrgb = 0x00000030,\n    WGPUTextureFormat_BC4RUnorm = 0x00000031,\n    WGPUTextureFormat_BC4RSnorm = 0x00000032,\n    WGPUTextureFormat_BC5RGUnorm = 0x00000033,\n    WGPUTextureFormat_BC5RGSnorm = 0x00000034,\n    WGPUTextureFormat_BC6HRGBUfloat = 0x00000035,\n    WGPUTextureFormat_BC6HRGBFloat = 0x00000036,\n    WGPUTextureFormat_BC7RGBAUnorm = 0x00000037,\n    WGPUTextureFormat_BC7RGBAUnormSrgb = 0x00000038,\n    WGPUTextureFormat_ETC2RGB8Unorm = 0x00000039,\n    WGPUTextureFormat_ETC2RGB8UnormSrgb = 0x0000003A,\n    WGPUTextureFormat_ETC2RGB8A1Unorm = 0x0000003B,\n    WGPUTextureFormat_ETC2RGB8A1UnormSrgb = 0x0000003C,\n    WGPUTextureFormat_ETC2RGBA8Unorm = 0x0000003D,\n    WGPUTextureFormat_ETC2RGBA8UnormSrgb = 0x0000003E,\n    WGPUTextureFormat_EACR11Unorm = 0x0000003F,\n    WGPUTextureFormat_EACR11Snorm = 0x00000040,\n    WGPUTextureFormat_EACRG11Unorm = 0x00000041,\n    WGPUTextureFormat_EACRG11Snorm = 0x00000042,\n    WGPUTextureFormat_ASTC4x4Unorm = 0x00000043,\n    WGPUTextureFormat_ASTC4x4UnormSrgb = 0x00000044,\n    WGPUTextureFormat_ASTC5x4Unorm = 0x00000045,\n    WGPUTextureFormat_ASTC5x4UnormSrgb = 0x00000046,\n    WGPUTextureFormat_ASTC5x5Unorm = 0x00000047,\n    WGPUTextureFormat_ASTC5x5UnormSrgb = 0x00000048,\n    WGPUTextureFormat_ASTC6x5Unorm = 0x00000049,\n    WGPUTextureFormat_ASTC6x5UnormSrgb = 0x0000004A,\n    WGPUTextureFormat_ASTC6x6Unorm = 0x0000004B,\n    WGPUTextureFormat_ASTC6x6UnormSrgb = 0x0000004C,\n    WGPUTextureFormat_ASTC8x5Unorm = 0x0000004D,\n    WGPUTextureFormat_ASTC8x5UnormSrgb = 0x0000004E,\n    WGPUTextureFormat_ASTC8x6Unorm = 0x0000004F,\n    WGPUTextureFormat_ASTC8x6UnormSrgb = 0x00000050,\n    WGPUTextureFormat_ASTC8x8Unorm = 0x00000051,\n    WGPUTextureFormat_ASTC8x8UnormSrgb = 0x00000052,\n    WGPUTextureFormat_ASTC10x5Unorm = 0x00000053,\n    WGPUTextureFormat_ASTC10x5UnormSrgb = 0x00000054,\n    WGPUTextureFormat_ASTC10x6Unorm = 0x00000055,\n    WGPUTextureFormat_ASTC10x6UnormSrgb = 0x00000056,\n    WGPUTextureFormat_ASTC10x8Unorm = 0x00000057,\n    WGPUTextureFormat_ASTC10x8UnormSrgb = 0x00000058,\n    WGPUTextureFormat_ASTC10x10Unorm = 0x00000059,\n    WGPUTextureFormat_ASTC10x10UnormSrgb = 0x0000005A,\n    WGPUTextureFormat_ASTC12x10Unorm = 0x0000005B,\n    WGPUTextureFormat_ASTC12x10UnormSrgb = 0x0000005C,\n    WGPUTextureFormat_ASTC12x12Unorm = 0x0000005D,\n    WGPUTextureFormat_ASTC12x12UnormSrgb = 0x0000005E,\n    WGPUTextureFormat_Force32 = 0x7FFFFFFF\n} WGPUTextureFormat WGPU_ENUM_ATTRIBUTE;\n\ntypedef enum WGPUTextureSampleType {\n    WGPUTextureSampleType_Undefined = 0x00000000,\n    WGPUTextureSampleType_Float = 0x00000001,\n    WGPUTextureSampleType_UnfilterableFloat = 0x00000002,\n    WGPUTextureSampleType_Depth = 0x00000003,\n    WGPUTextureSampleType_Sint = 0x00000004,\n    WGPUTextureSampleType_Uint = 0x00000005,\n    WGPUTextureSampleType_Force32 = 0x7FFFFFFF\n} WGPUTextureSampleType WGPU_ENUM_ATTRIBUTE;\n\ntypedef enum WGPUTextureViewDimension {\n    WGPUTextureViewDimension_Undefined = 0x00000000,\n    WGPUTextureViewDimension_1D = 0x00000001,\n    WGPUTextureViewDimension_2D = 0x00000002,\n    WGPUTextureViewDimension_2DArray = 0x00000003,\n    WGPUTextureViewDimension_Cube = 0x00000004,\n    WGPUTextureViewDimension_CubeArray = 0x00000005,\n    WGPUTextureViewDimension_3D = 0x00000006,\n    WGPUTextureViewDimension_Force32 = 0x7FFFFFFF\n} WGPUTextureViewDimension WGPU_ENUM_ATTRIBUTE;\n\ntypedef enum WGPUVertexFormat {\n    WGPUVertexFormat_Undefined = 0x00000000,\n    WGPUVertexFormat_Uint8x2 = 0x00000001,\n    WGPUVertexFormat_Uint8x4 = 0x00000002,\n    WGPUVertexFormat_Sint8x2 = 0x00000003,\n    WGPUVertexFormat_Sint8x4 = 0x00000004,\n    WGPUVertexFormat_Unorm8x2 = 0x00000005,\n    WGPUVertexFormat_Unorm8x4 = 0x00000006,\n    WGPUVertexFormat_Snorm8x2 = 0x00000007,\n    WGPUVertexFormat_Snorm8x4 = 0x00000008,\n    WGPUVertexFormat_Uint16x2 = 0x00000009,\n    WGPUVertexFormat_Uint16x4 = 0x0000000A,\n    WGPUVertexFormat_Sint16x2 = 0x0000000B,\n    WGPUVertexFormat_Sint16x4 = 0x0000000C,\n    WGPUVertexFormat_Unorm16x2 = 0x0000000D,\n    WGPUVertexFormat_Unorm16x4 = 0x0000000E,\n    WGPUVertexFormat_Snorm16x2 = 0x0000000F,\n    WGPUVertexFormat_Snorm16x4 = 0x00000010,\n    WGPUVertexFormat_Float16x2 = 0x00000011,\n    WGPUVertexFormat_Float16x4 = 0x00000012,\n    WGPUVertexFormat_Float32 = 0x00000013,\n    WGPUVertexFormat_Float32x2 = 0x00000014,\n    WGPUVertexFormat_Float32x3 = 0x00000015,\n    WGPUVertexFormat_Float32x4 = 0x00000016,\n    WGPUVertexFormat_Uint32 = 0x00000017,\n    WGPUVertexFormat_Uint32x2 = 0x00000018,\n    WGPUVertexFormat_Uint32x3 = 0x00000019,\n    WGPUVertexFormat_Uint32x4 = 0x0000001A,\n    WGPUVertexFormat_Sint32 = 0x0000001B,\n    WGPUVertexFormat_Sint32x2 = 0x0000001C,\n    WGPUVertexFormat_Sint32x3 = 0x0000001D,\n    WGPUVertexFormat_Sint32x4 = 0x0000001E,\n    WGPUVertexFormat_Force32 = 0x7FFFFFFF\n} WGPUVertexFormat WGPU_ENUM_ATTRIBUTE;\n\ntypedef enum WGPUVertexStepMode {\n    WGPUVertexStepMode_Vertex = 0x00000000,\n    WGPUVertexStepMode_Instance = 0x00000001,\n    WGPUVertexStepMode_VertexBufferNotUsed = 0x00000002,\n    WGPUVertexStepMode_Force32 = 0x7FFFFFFF\n} WGPUVertexStepMode WGPU_ENUM_ATTRIBUTE;\n\ntypedef enum WGPUBufferUsage {\n    WGPUBufferUsage_None = 0x00000000,\n    WGPUBufferUsage_MapRead = 0x00000001,\n    WGPUBufferUsage_MapWrite = 0x00000002,\n    WGPUBufferUsage_CopySrc = 0x00000004,\n    WGPUBufferUsage_CopyDst = 0x00000008,\n    WGPUBufferUsage_Index = 0x00000010,\n    WGPUBufferUsage_Vertex = 0x00000020,\n    WGPUBufferUsage_Uniform = 0x00000040,\n    WGPUBufferUsage_Storage = 0x00000080,\n    WGPUBufferUsage_Indirect = 0x00000100,\n    WGPUBufferUsage_QueryResolve = 0x00000200,\n    WGPUBufferUsage_Force32 = 0x7FFFFFFF\n} WGPUBufferUsage WGPU_ENUM_ATTRIBUTE;\ntypedef WGPUFlags WGPUBufferUsageFlags WGPU_ENUM_ATTRIBUTE;\n\ntypedef enum WGPUColorWriteMask {\n    WGPUColorWriteMask_None = 0x00000000,\n    WGPUColorWriteMask_Red = 0x00000001,\n    WGPUColorWriteMask_Green = 0x00000002,\n    WGPUColorWriteMask_Blue = 0x00000004,\n    WGPUColorWriteMask_Alpha = 0x00000008,\n    WGPUColorWriteMask_All = 0x0000000F,\n    WGPUColorWriteMask_Force32 = 0x7FFFFFFF\n} WGPUColorWriteMask WGPU_ENUM_ATTRIBUTE;\ntypedef WGPUFlags WGPUColorWriteMaskFlags WGPU_ENUM_ATTRIBUTE;\n\ntypedef enum WGPUMapMode {\n    WGPUMapMode_None = 0x00000000,\n    WGPUMapMode_Read = 0x00000001,\n    WGPUMapMode_Write = 0x00000002,\n    WGPUMapMode_Force32 = 0x7FFFFFFF\n} WGPUMapMode WGPU_ENUM_ATTRIBUTE;\ntypedef WGPUFlags WGPUMapModeFlags WGPU_ENUM_ATTRIBUTE;\n\ntypedef enum WGPUShaderStage {\n    WGPUShaderStage_None = 0x00000000,\n    WGPUShaderStage_Vertex = 0x00000001,\n    WGPUShaderStage_Fragment = 0x00000002,\n    WGPUShaderStage_Compute = 0x00000004,\n    WGPUShaderStage_Force32 = 0x7FFFFFFF\n} WGPUShaderStage WGPU_ENUM_ATTRIBUTE;\ntypedef WGPUFlags WGPUShaderStageFlags WGPU_ENUM_ATTRIBUTE;\n\ntypedef enum WGPUTextureUsage {\n    WGPUTextureUsage_None = 0x00000000,\n    WGPUTextureUsage_CopySrc = 0x00000001,\n    WGPUTextureUsage_CopyDst = 0x00000002,\n    WGPUTextureUsage_TextureBinding = 0x00000004,\n    WGPUTextureUsage_StorageBinding = 0x00000008,\n    WGPUTextureUsage_RenderAttachment = 0x00000010,\n    WGPUTextureUsage_Force32 = 0x7FFFFFFF\n} WGPUTextureUsage WGPU_ENUM_ATTRIBUTE;\ntypedef WGPUFlags WGPUTextureUsageFlags WGPU_ENUM_ATTRIBUTE;\n\ntypedef void (*WGPUBufferMapCallback)(WGPUBufferMapAsyncStatus status, void * userdata) WGPU_FUNCTION_ATTRIBUTE;\ntypedef void (*WGPUCompilationInfoCallback)(WGPUCompilationInfoRequestStatus status, struct WGPUCompilationInfo const * compilationInfo, void * userdata) WGPU_FUNCTION_ATTRIBUTE;\ntypedef void (*WGPUCreateComputePipelineAsyncCallback)(WGPUCreatePipelineAsyncStatus status, WGPUComputePipeline pipeline, char const * message, void * userdata) WGPU_FUNCTION_ATTRIBUTE;\ntypedef void (*WGPUCreateRenderPipelineAsyncCallback)(WGPUCreatePipelineAsyncStatus status, WGPURenderPipeline pipeline, char const * message, void * userdata) WGPU_FUNCTION_ATTRIBUTE;\ntypedef void (*WGPUDeviceLostCallback)(WGPUDeviceLostReason reason, char const * message, void * userdata) WGPU_FUNCTION_ATTRIBUTE;\ntypedef void (*WGPUErrorCallback)(WGPUErrorType type, char const * message, void * userdata) WGPU_FUNCTION_ATTRIBUTE;\ntypedef void (*WGPUProc)(void) WGPU_FUNCTION_ATTRIBUTE;\ntypedef void (*WGPUQueueWorkDoneCallback)(WGPUQueueWorkDoneStatus status, void * userdata) WGPU_FUNCTION_ATTRIBUTE;\ntypedef void (*WGPURequestAdapterCallback)(WGPURequestAdapterStatus status, WGPUAdapter adapter, char const * message, void * userdata) WGPU_FUNCTION_ATTRIBUTE;\ntypedef void (*WGPURequestDeviceCallback)(WGPURequestDeviceStatus status, WGPUDevice device, char const * message, void * userdata) WGPU_FUNCTION_ATTRIBUTE;\n\ntypedef struct WGPUChainedStruct {\n    struct WGPUChainedStruct const * next;\n    WGPUSType sType;\n} WGPUChainedStruct WGPU_STRUCTURE_ATTRIBUTE;\n\ntypedef struct WGPUChainedStructOut {\n    struct WGPUChainedStructOut * next;\n    WGPUSType sType;\n} WGPUChainedStructOut WGPU_STRUCTURE_ATTRIBUTE;\n\ntypedef struct WGPUAdapterProperties {\n    WGPUChainedStructOut * nextInChain;\n    uint32_t vendorID;\n    char const * vendorName;\n    char const * architecture;\n    uint32_t deviceID;\n    char const * name;\n    char const * driverDescription;\n    WGPUAdapterType adapterType;\n    WGPUBackendType backendType;\n    bool compatibilityMode;\n} WGPUAdapterProperties WGPU_STRUCTURE_ATTRIBUTE;\n\ntypedef struct WGPUBindGroupEntry {\n    WGPUChainedStruct const * nextInChain;\n    uint32_t binding;\n    WGPU_NULLABLE WGPUBuffer buffer;\n    uint64_t offset;\n    uint64_t size;\n    WGPU_NULLABLE WGPUSampler sampler;\n    WGPU_NULLABLE WGPUTextureView textureView;\n} WGPUBindGroupEntry WGPU_STRUCTURE_ATTRIBUTE;\n\ntypedef struct WGPUBlendComponent {\n    WGPUBlendOperation operation;\n    WGPUBlendFactor srcFactor;\n    WGPUBlendFactor dstFactor;\n} WGPUBlendComponent WGPU_STRUCTURE_ATTRIBUTE;\n\ntypedef struct WGPUBufferBindingLayout {\n    WGPUChainedStruct const * nextInChain;\n    WGPUBufferBindingType type;\n    bool hasDynamicOffset;\n    uint64_t minBindingSize;\n} WGPUBufferBindingLayout WGPU_STRUCTURE_ATTRIBUTE;\n\ntypedef struct WGPUBufferDescriptor {\n    WGPUChainedStruct const * nextInChain;\n    WGPU_NULLABLE char const * label;\n    WGPUBufferUsageFlags usage;\n    uint64_t size;\n    bool mappedAtCreation;\n} WGPUBufferDescriptor WGPU_STRUCTURE_ATTRIBUTE;\n\ntypedef struct WGPUColor {\n    double r;\n    double g;\n    double b;\n    double a;\n} WGPUColor WGPU_STRUCTURE_ATTRIBUTE;\n\ntypedef struct WGPUCommandBufferDescriptor {\n    WGPUChainedStruct const * nextInChain;\n    WGPU_NULLABLE char const * label;\n} WGPUCommandBufferDescriptor WGPU_STRUCTURE_ATTRIBUTE;\n\ntypedef struct WGPUCommandEncoderDescriptor {\n    WGPUChainedStruct const * nextInChain;\n    WGPU_NULLABLE char const * label;\n} WGPUCommandEncoderDescriptor WGPU_STRUCTURE_ATTRIBUTE;\n\ntypedef struct WGPUCompilationMessage {\n    WGPUChainedStruct const * nextInChain;\n    WGPU_NULLABLE char const * message;\n    WGPUCompilationMessageType type;\n    uint64_t lineNum;\n    uint64_t linePos;\n    uint64_t offset;\n    uint64_t length;\n    uint64_t utf16LinePos;\n    uint64_t utf16Offset;\n    uint64_t utf16Length;\n} WGPUCompilationMessage WGPU_STRUCTURE_ATTRIBUTE;\n\ntypedef struct WGPUComputePassTimestampWrite {\n    WGPUQuerySet querySet;\n    uint32_t queryIndex;\n    WGPUComputePassTimestampLocation location;\n} WGPUComputePassTimestampWrite WGPU_STRUCTURE_ATTRIBUTE;\n\ntypedef struct WGPUConstantEntry {\n    WGPUChainedStruct const * nextInChain;\n    char const * key;\n    double value;\n} WGPUConstantEntry WGPU_STRUCTURE_ATTRIBUTE;\n\ntypedef struct WGPUExtent3D {\n    uint32_t width;\n    uint32_t height;\n    uint32_t depthOrArrayLayers;\n} WGPUExtent3D WGPU_STRUCTURE_ATTRIBUTE;\n\ntypedef struct WGPUInstanceDescriptor {\n    WGPUChainedStruct const * nextInChain;\n} WGPUInstanceDescriptor WGPU_STRUCTURE_ATTRIBUTE;\n\ntypedef struct WGPULimits {\n    uint32_t maxTextureDimension1D;\n    uint32_t maxTextureDimension2D;\n    uint32_t maxTextureDimension3D;\n    uint32_t maxTextureArrayLayers;\n    uint32_t maxBindGroups;\n    uint32_t maxBindGroupsPlusVertexBuffers;\n    uint32_t maxBindingsPerBindGroup;\n    uint32_t maxDynamicUniformBuffersPerPipelineLayout;\n    uint32_t maxDynamicStorageBuffersPerPipelineLayout;\n    uint32_t maxSampledTexturesPerShaderStage;\n    uint32_t maxSamplersPerShaderStage;\n    uint32_t maxStorageBuffersPerShaderStage;\n    uint32_t maxStorageTexturesPerShaderStage;\n    uint32_t maxUniformBuffersPerShaderStage;\n    uint64_t maxUniformBufferBindingSize;\n    uint64_t maxStorageBufferBindingSize;\n    uint32_t minUniformBufferOffsetAlignment;\n    uint32_t minStorageBufferOffsetAlignment;\n    uint32_t maxVertexBuffers;\n    uint64_t maxBufferSize;\n    uint32_t maxVertexAttributes;\n    uint32_t maxVertexBufferArrayStride;\n    uint32_t maxInterStageShaderComponents;\n    uint32_t maxInterStageShaderVariables;\n    uint32_t maxColorAttachments;\n    uint32_t maxColorAttachmentBytesPerSample;\n    uint32_t maxComputeWorkgroupStorageSize;\n    uint32_t maxComputeInvocationsPerWorkgroup;\n    uint32_t maxComputeWorkgroupSizeX;\n    uint32_t maxComputeWorkgroupSizeY;\n    uint32_t maxComputeWorkgroupSizeZ;\n    uint32_t maxComputeWorkgroupsPerDimension;\n} WGPULimits WGPU_STRUCTURE_ATTRIBUTE;\n\ntypedef struct WGPUMultisampleState {\n    WGPUChainedStruct const * nextInChain;\n    uint32_t count;\n    uint32_t mask;\n    bool alphaToCoverageEnabled;\n} WGPUMultisampleState WGPU_STRUCTURE_ATTRIBUTE;\n\ntypedef struct WGPUOrigin3D {\n    uint32_t x;\n    uint32_t y;\n    uint32_t z;\n} WGPUOrigin3D WGPU_STRUCTURE_ATTRIBUTE;\n\ntypedef struct WGPUPipelineLayoutDescriptor {\n    WGPUChainedStruct const * nextInChain;\n    WGPU_NULLABLE char const * label;\n    size_t bindGroupLayoutCount;\n    WGPUBindGroupLayout const * bindGroupLayouts;\n} WGPUPipelineLayoutDescriptor WGPU_STRUCTURE_ATTRIBUTE;\n\n// Can be chained in WGPUPrimitiveState\ntypedef struct WGPUPrimitiveDepthClipControl {\n    WGPUChainedStruct chain;\n    bool unclippedDepth;\n} WGPUPrimitiveDepthClipControl WGPU_STRUCTURE_ATTRIBUTE;\n\ntypedef struct WGPUPrimitiveState {\n    WGPUChainedStruct const * nextInChain;\n    WGPUPrimitiveTopology topology;\n    WGPUIndexFormat stripIndexFormat;\n    WGPUFrontFace frontFace;\n    WGPUCullMode cullMode;\n} WGPUPrimitiveState WGPU_STRUCTURE_ATTRIBUTE;\n\ntypedef struct WGPUQuerySetDescriptor {\n    WGPUChainedStruct const * nextInChain;\n    WGPU_NULLABLE char const * label;\n    WGPUQueryType type;\n    uint32_t count;\n    WGPUPipelineStatisticName const * pipelineStatistics;\n    size_t pipelineStatisticsCount;\n} WGPUQuerySetDescriptor WGPU_STRUCTURE_ATTRIBUTE;\n\ntypedef struct WGPUQueueDescriptor {\n    WGPUChainedStruct const * nextInChain;\n    WGPU_NULLABLE char const * label;\n} WGPUQueueDescriptor WGPU_STRUCTURE_ATTRIBUTE;\n\ntypedef struct WGPURenderBundleDescriptor {\n    WGPUChainedStruct const * nextInChain;\n    WGPU_NULLABLE char const * label;\n} WGPURenderBundleDescriptor WGPU_STRUCTURE_ATTRIBUTE;\n\ntypedef struct WGPURenderBundleEncoderDescriptor {\n    WGPUChainedStruct const * nextInChain;\n    WGPU_NULLABLE char const * label;\n    size_t colorFormatsCount;\n    WGPUTextureFormat const * colorFormats;\n    WGPUTextureFormat depthStencilFormat;\n    uint32_t sampleCount;\n    bool depthReadOnly;\n    bool stencilReadOnly;\n} WGPURenderBundleEncoderDescriptor WGPU_STRUCTURE_ATTRIBUTE;\n\ntypedef struct WGPURenderPassDepthStencilAttachment {\n    WGPUTextureView view;\n    WGPULoadOp depthLoadOp;\n    WGPUStoreOp depthStoreOp;\n    float depthClearValue;\n    bool depthReadOnly;\n    WGPULoadOp stencilLoadOp;\n    WGPUStoreOp stencilStoreOp;\n    uint32_t stencilClearValue;\n    bool stencilReadOnly;\n} WGPURenderPassDepthStencilAttachment WGPU_STRUCTURE_ATTRIBUTE;\n\n// Can be chained in WGPURenderPassDescriptor\ntypedef struct WGPURenderPassDescriptorMaxDrawCount {\n    WGPUChainedStruct chain;\n    uint64_t maxDrawCount;\n} WGPURenderPassDescriptorMaxDrawCount WGPU_STRUCTURE_ATTRIBUTE;\n\ntypedef struct WGPURenderPassTimestampWrite {\n    WGPUQuerySet querySet;\n    uint32_t queryIndex;\n    WGPURenderPassTimestampLocation location;\n} WGPURenderPassTimestampWrite WGPU_STRUCTURE_ATTRIBUTE;\n\ntypedef struct WGPURequestAdapterOptions {\n    WGPUChainedStruct const * nextInChain;\n    WGPU_NULLABLE WGPUSurface compatibleSurface;\n    WGPUPowerPreference powerPreference;\n    WGPUBackendType backendType;\n    bool forceFallbackAdapter;\n    bool compatibilityMode;\n} WGPURequestAdapterOptions WGPU_STRUCTURE_ATTRIBUTE;\n\ntypedef struct WGPUSamplerBindingLayout {\n    WGPUChainedStruct const * nextInChain;\n    WGPUSamplerBindingType type;\n} WGPUSamplerBindingLayout WGPU_STRUCTURE_ATTRIBUTE;\n\ntypedef struct WGPUSamplerDescriptor {\n    WGPUChainedStruct const * nextInChain;\n    WGPU_NULLABLE char const * label;\n    WGPUAddressMode addressModeU;\n    WGPUAddressMode addressModeV;\n    WGPUAddressMode addressModeW;\n    WGPUFilterMode magFilter;\n    WGPUFilterMode minFilter;\n    WGPUMipmapFilterMode mipmapFilter;\n    float lodMinClamp;\n    float lodMaxClamp;\n    WGPUCompareFunction compare;\n    uint16_t maxAnisotropy;\n} WGPUSamplerDescriptor WGPU_STRUCTURE_ATTRIBUTE;\n\ntypedef struct WGPUShaderModuleDescriptor {\n    WGPUChainedStruct const * nextInChain;\n    WGPU_NULLABLE char const * label;\n} WGPUShaderModuleDescriptor WGPU_STRUCTURE_ATTRIBUTE;\n\n// Can be chained in WGPUShaderModuleDescriptor\ntypedef struct WGPUShaderModuleSPIRVDescriptor {\n    WGPUChainedStruct chain;\n    uint32_t codeSize;\n    uint32_t const * code;\n} WGPUShaderModuleSPIRVDescriptor WGPU_STRUCTURE_ATTRIBUTE;\n\n// Can be chained in WGPUShaderModuleDescriptor\ntypedef struct WGPUShaderModuleWGSLDescriptor {\n    WGPUChainedStruct chain;\n    char const * code;\n} WGPUShaderModuleWGSLDescriptor WGPU_STRUCTURE_ATTRIBUTE;\n\ntypedef struct WGPUStencilFaceState {\n    WGPUCompareFunction compare;\n    WGPUStencilOperation failOp;\n    WGPUStencilOperation depthFailOp;\n    WGPUStencilOperation passOp;\n} WGPUStencilFaceState WGPU_STRUCTURE_ATTRIBUTE;\n\ntypedef struct WGPUStorageTextureBindingLayout {\n    WGPUChainedStruct const * nextInChain;\n    WGPUStorageTextureAccess access;\n    WGPUTextureFormat format;\n    WGPUTextureViewDimension viewDimension;\n} WGPUStorageTextureBindingLayout WGPU_STRUCTURE_ATTRIBUTE;\n\ntypedef struct WGPUSurfaceDescriptor {\n    WGPUChainedStruct const * nextInChain;\n    WGPU_NULLABLE char const * label;\n} WGPUSurfaceDescriptor WGPU_STRUCTURE_ATTRIBUTE;\n\n// Can be chained in WGPUSurfaceDescriptor\ntypedef struct WGPUSurfaceDescriptorFromCanvasHTMLSelector {\n    WGPUChainedStruct chain;\n    char const * selector;\n} WGPUSurfaceDescriptorFromCanvasHTMLSelector WGPU_STRUCTURE_ATTRIBUTE;\n\ntypedef struct WGPUSwapChainDescriptor {\n    WGPUChainedStruct const * nextInChain;\n    WGPU_NULLABLE char const * label;\n    WGPUTextureUsageFlags usage;\n    WGPUTextureFormat format;\n    uint32_t width;\n    uint32_t height;\n    WGPUPresentMode presentMode;\n} WGPUSwapChainDescriptor WGPU_STRUCTURE_ATTRIBUTE;\n\ntypedef struct WGPUTextureBindingLayout {\n    WGPUChainedStruct const * nextInChain;\n    WGPUTextureSampleType sampleType;\n    WGPUTextureViewDimension viewDimension;\n    bool multisampled;\n} WGPUTextureBindingLayout WGPU_STRUCTURE_ATTRIBUTE;\n\ntypedef struct WGPUTextureDataLayout {\n    WGPUChainedStruct const * nextInChain;\n    uint64_t offset;\n    uint32_t bytesPerRow;\n    uint32_t rowsPerImage;\n} WGPUTextureDataLayout WGPU_STRUCTURE_ATTRIBUTE;\n\ntypedef struct WGPUTextureViewDescriptor {\n    WGPUChainedStruct const * nextInChain;\n    WGPU_NULLABLE char const * label;\n    WGPUTextureFormat format;\n    WGPUTextureViewDimension dimension;\n    uint32_t baseMipLevel;\n    uint32_t mipLevelCount;\n    uint32_t baseArrayLayer;\n    uint32_t arrayLayerCount;\n    WGPUTextureAspect aspect;\n} WGPUTextureViewDescriptor WGPU_STRUCTURE_ATTRIBUTE;\n\ntypedef struct WGPUVertexAttribute {\n    WGPUVertexFormat format;\n    uint64_t offset;\n    uint32_t shaderLocation;\n} WGPUVertexAttribute WGPU_STRUCTURE_ATTRIBUTE;\n\ntypedef struct WGPUBindGroupDescriptor {\n    WGPUChainedStruct const * nextInChain;\n    WGPU_NULLABLE char const * label;\n    WGPUBindGroupLayout layout;\n    size_t entryCount;\n    WGPUBindGroupEntry const * entries;\n} WGPUBindGroupDescriptor WGPU_STRUCTURE_ATTRIBUTE;\n\ntypedef struct WGPUBindGroupLayoutEntry {\n    WGPUChainedStruct const * nextInChain;\n    uint32_t binding;\n    WGPUShaderStageFlags visibility;\n    WGPUBufferBindingLayout buffer;\n    WGPUSamplerBindingLayout sampler;\n    WGPUTextureBindingLayout texture;\n    WGPUStorageTextureBindingLayout storageTexture;\n} WGPUBindGroupLayoutEntry WGPU_STRUCTURE_ATTRIBUTE;\n\ntypedef struct WGPUBlendState {\n    WGPUBlendComponent color;\n    WGPUBlendComponent alpha;\n} WGPUBlendState WGPU_STRUCTURE_ATTRIBUTE;\n\ntypedef struct WGPUCompilationInfo {\n    WGPUChainedStruct const * nextInChain;\n    size_t messageCount;\n    WGPUCompilationMessage const * messages;\n} WGPUCompilationInfo WGPU_STRUCTURE_ATTRIBUTE;\n\ntypedef struct WGPUComputePassDescriptor {\n    WGPUChainedStruct const * nextInChain;\n    WGPU_NULLABLE char const * label;\n    size_t timestampWriteCount;\n    WGPUComputePassTimestampWrite const * timestampWrites;\n} WGPUComputePassDescriptor WGPU_STRUCTURE_ATTRIBUTE;\n\ntypedef struct WGPUDepthStencilState {\n    WGPUChainedStruct const * nextInChain;\n    WGPUTextureFormat format;\n    bool depthWriteEnabled;\n    WGPUCompareFunction depthCompare;\n    WGPUStencilFaceState stencilFront;\n    WGPUStencilFaceState stencilBack;\n    uint32_t stencilReadMask;\n    uint32_t stencilWriteMask;\n    int32_t depthBias;\n    float depthBiasSlopeScale;\n    float depthBiasClamp;\n} WGPUDepthStencilState WGPU_STRUCTURE_ATTRIBUTE;\n\ntypedef struct WGPUImageCopyBuffer {\n    WGPUChainedStruct const * nextInChain;\n    WGPUTextureDataLayout layout;\n    WGPUBuffer buffer;\n} WGPUImageCopyBuffer WGPU_STRUCTURE_ATTRIBUTE;\n\ntypedef struct WGPUImageCopyTexture {\n    WGPUChainedStruct const * nextInChain;\n    WGPUTexture texture;\n    uint32_t mipLevel;\n    WGPUOrigin3D origin;\n    WGPUTextureAspect aspect;\n} WGPUImageCopyTexture WGPU_STRUCTURE_ATTRIBUTE;\n\ntypedef struct WGPUProgrammableStageDescriptor {\n    WGPUChainedStruct const * nextInChain;\n    WGPUShaderModule module;\n    char const * entryPoint;\n    size_t constantCount;\n    WGPUConstantEntry const * constants;\n} WGPUProgrammableStageDescriptor WGPU_STRUCTURE_ATTRIBUTE;\n\ntypedef struct WGPURenderPassColorAttachment {\n    WGPUChainedStruct const * nextInChain;\n    WGPU_NULLABLE WGPUTextureView view;\n    WGPU_NULLABLE WGPUTextureView resolveTarget;\n    WGPULoadOp loadOp;\n    WGPUStoreOp storeOp;\n    WGPUColor clearValue;\n} WGPURenderPassColorAttachment WGPU_STRUCTURE_ATTRIBUTE;\n\ntypedef struct WGPURequiredLimits {\n    WGPUChainedStruct const * nextInChain;\n    WGPULimits limits;\n} WGPURequiredLimits WGPU_STRUCTURE_ATTRIBUTE;\n\ntypedef struct WGPUSupportedLimits {\n    WGPUChainedStructOut * nextInChain;\n    WGPULimits limits;\n} WGPUSupportedLimits WGPU_STRUCTURE_ATTRIBUTE;\n\ntypedef struct WGPUTextureDescriptor {\n    WGPUChainedStruct const * nextInChain;\n    WGPU_NULLABLE char const * label;\n    WGPUTextureUsageFlags usage;\n    WGPUTextureDimension dimension;\n    WGPUExtent3D size;\n    WGPUTextureFormat format;\n    uint32_t mipLevelCount;\n    uint32_t sampleCount;\n    size_t viewFormatCount;\n    WGPUTextureFormat const * viewFormats;\n} WGPUTextureDescriptor WGPU_STRUCTURE_ATTRIBUTE;\n\ntypedef struct WGPUVertexBufferLayout {\n    uint64_t arrayStride;\n    WGPUVertexStepMode stepMode;\n    size_t attributeCount;\n    WGPUVertexAttribute const * attributes;\n} WGPUVertexBufferLayout WGPU_STRUCTURE_ATTRIBUTE;\n\ntypedef struct WGPUBindGroupLayoutDescriptor {\n    WGPUChainedStruct const * nextInChain;\n    WGPU_NULLABLE char const * label;\n    size_t entryCount;\n    WGPUBindGroupLayoutEntry const * entries;\n} WGPUBindGroupLayoutDescriptor WGPU_STRUCTURE_ATTRIBUTE;\n\ntypedef struct WGPUColorTargetState {\n    WGPUChainedStruct const * nextInChain;\n    WGPUTextureFormat format;\n    WGPU_NULLABLE WGPUBlendState const * blend;\n    WGPUColorWriteMaskFlags writeMask;\n} WGPUColorTargetState WGPU_STRUCTURE_ATTRIBUTE;\n\ntypedef struct WGPUComputePipelineDescriptor {\n    WGPUChainedStruct const * nextInChain;\n    WGPU_NULLABLE char const * label;\n    WGPU_NULLABLE WGPUPipelineLayout layout;\n    WGPUProgrammableStageDescriptor compute;\n} WGPUComputePipelineDescriptor WGPU_STRUCTURE_ATTRIBUTE;\n\ntypedef struct WGPUDeviceDescriptor {\n    WGPUChainedStruct const * nextInChain;\n    WGPU_NULLABLE char const * label;\n    size_t requiredFeaturesCount;\n    WGPUFeatureName const * requiredFeatures;\n    WGPU_NULLABLE WGPURequiredLimits const * requiredLimits;\n    WGPUQueueDescriptor defaultQueue;\n    WGPUDeviceLostCallback deviceLostCallback;\n    void * deviceLostUserdata;\n} WGPUDeviceDescriptor WGPU_STRUCTURE_ATTRIBUTE;\n\ntypedef struct WGPURenderPassDescriptor {\n    WGPUChainedStruct const * nextInChain;\n    WGPU_NULLABLE char const * label;\n    size_t colorAttachmentCount;\n    WGPURenderPassColorAttachment const * colorAttachments;\n    WGPU_NULLABLE WGPURenderPassDepthStencilAttachment const * depthStencilAttachment;\n    WGPU_NULLABLE WGPUQuerySet occlusionQuerySet;\n    size_t timestampWriteCount;\n    WGPURenderPassTimestampWrite const * timestampWrites;\n} WGPURenderPassDescriptor WGPU_STRUCTURE_ATTRIBUTE;\n\ntypedef struct WGPUVertexState {\n    WGPUChainedStruct const * nextInChain;\n    WGPUShaderModule module;\n    char const * entryPoint;\n    size_t constantCount;\n    WGPUConstantEntry const * constants;\n    size_t bufferCount;\n    WGPUVertexBufferLayout const * buffers;\n} WGPUVertexState WGPU_STRUCTURE_ATTRIBUTE;\n\ntypedef struct WGPUFragmentState {\n    WGPUChainedStruct const * nextInChain;\n    WGPUShaderModule module;\n    char const * entryPoint;\n    size_t constantCount;\n    WGPUConstantEntry const * constants;\n    size_t targetCount;\n    WGPUColorTargetState const * targets;\n} WGPUFragmentState WGPU_STRUCTURE_ATTRIBUTE;\n\ntypedef struct WGPURenderPipelineDescriptor {\n    WGPUChainedStruct const * nextInChain;\n    WGPU_NULLABLE char const * label;\n    WGPU_NULLABLE WGPUPipelineLayout layout;\n    WGPUVertexState vertex;\n    WGPUPrimitiveState primitive;\n    WGPU_NULLABLE WGPUDepthStencilState const * depthStencil;\n    WGPUMultisampleState multisample;\n    WGPU_NULLABLE WGPUFragmentState const * fragment;\n} WGPURenderPipelineDescriptor WGPU_STRUCTURE_ATTRIBUTE;\n\n#ifdef __cplusplus\nextern \"C\" {\n#endif\n\n#if !defined(WGPU_SKIP_PROCS)\n\ntypedef WGPUInstance (*WGPUProcCreateInstance)(WGPUInstanceDescriptor const * descriptor) WGPU_FUNCTION_ATTRIBUTE;\ntypedef WGPUProc (*WGPUProcGetProcAddress)(WGPUDevice device, char const * procName) WGPU_FUNCTION_ATTRIBUTE;\n\n// Procs of Adapter\ntypedef size_t (*WGPUProcAdapterEnumerateFeatures)(WGPUAdapter adapter, WGPUFeatureName * features) WGPU_FUNCTION_ATTRIBUTE;\ntypedef bool (*WGPUProcAdapterGetLimits)(WGPUAdapter adapter, WGPUSupportedLimits * limits) WGPU_FUNCTION_ATTRIBUTE;\ntypedef void (*WGPUProcAdapterGetProperties)(WGPUAdapter adapter, WGPUAdapterProperties * properties) WGPU_FUNCTION_ATTRIBUTE;\ntypedef bool (*WGPUProcAdapterHasFeature)(WGPUAdapter adapter, WGPUFeatureName feature) WGPU_FUNCTION_ATTRIBUTE;\ntypedef void (*WGPUProcAdapterRequestDevice)(WGPUAdapter adapter, WGPU_NULLABLE WGPUDeviceDescriptor const * descriptor, WGPURequestDeviceCallback callback, void * userdata) WGPU_FUNCTION_ATTRIBUTE;\ntypedef void (*WGPUProcAdapterReference)(WGPUAdapter adapter) WGPU_FUNCTION_ATTRIBUTE;\ntypedef void (*WGPUProcAdapterRelease)(WGPUAdapter adapter) WGPU_FUNCTION_ATTRIBUTE;\n\n// Procs of BindGroup\ntypedef void (*WGPUProcBindGroupSetLabel)(WGPUBindGroup bindGroup, char const * label) WGPU_FUNCTION_ATTRIBUTE;\ntypedef void (*WGPUProcBindGroupReference)(WGPUBindGroup bindGroup) WGPU_FUNCTION_ATTRIBUTE;\ntypedef void (*WGPUProcBindGroupRelease)(WGPUBindGroup bindGroup) WGPU_FUNCTION_ATTRIBUTE;\n\n// Procs of BindGroupLayout\ntypedef void (*WGPUProcBindGroupLayoutSetLabel)(WGPUBindGroupLayout bindGroupLayout, char const * label) WGPU_FUNCTION_ATTRIBUTE;\ntypedef void (*WGPUProcBindGroupLayoutReference)(WGPUBindGroupLayout bindGroupLayout) WGPU_FUNCTION_ATTRIBUTE;\ntypedef void (*WGPUProcBindGroupLayoutRelease)(WGPUBindGroupLayout bindGroupLayout) WGPU_FUNCTION_ATTRIBUTE;\n\n// Procs of Buffer\ntypedef void (*WGPUProcBufferDestroy)(WGPUBuffer buffer) WGPU_FUNCTION_ATTRIBUTE;\ntypedef void const * (*WGPUProcBufferGetConstMappedRange)(WGPUBuffer buffer, size_t offset, size_t size) WGPU_FUNCTION_ATTRIBUTE;\ntypedef WGPUBufferMapState (*WGPUProcBufferGetMapState)(WGPUBuffer buffer) WGPU_FUNCTION_ATTRIBUTE;\ntypedef void * (*WGPUProcBufferGetMappedRange)(WGPUBuffer buffer, size_t offset, size_t size) WGPU_FUNCTION_ATTRIBUTE;\ntypedef uint64_t (*WGPUProcBufferGetSize)(WGPUBuffer buffer) WGPU_FUNCTION_ATTRIBUTE;\ntypedef WGPUBufferUsageFlags (*WGPUProcBufferGetUsage)(WGPUBuffer buffer) WGPU_FUNCTION_ATTRIBUTE;\ntypedef void (*WGPUProcBufferMapAsync)(WGPUBuffer buffer, WGPUMapModeFlags mode, size_t offset, size_t size, WGPUBufferMapCallback callback, void * userdata) WGPU_FUNCTION_ATTRIBUTE;\ntypedef void (*WGPUProcBufferSetLabel)(WGPUBuffer buffer, char const * label) WGPU_FUNCTION_ATTRIBUTE;\ntypedef void (*WGPUProcBufferUnmap)(WGPUBuffer buffer) WGPU_FUNCTION_ATTRIBUTE;\ntypedef void (*WGPUProcBufferReference)(WGPUBuffer buffer) WGPU_FUNCTION_ATTRIBUTE;\ntypedef void (*WGPUProcBufferRelease)(WGPUBuffer buffer) WGPU_FUNCTION_ATTRIBUTE;\n\n// Procs of CommandBuffer\ntypedef void (*WGPUProcCommandBufferSetLabel)(WGPUCommandBuffer commandBuffer, char const * label) WGPU_FUNCTION_ATTRIBUTE;\ntypedef void (*WGPUProcCommandBufferReference)(WGPUCommandBuffer commandBuffer) WGPU_FUNCTION_ATTRIBUTE;\ntypedef void (*WGPUProcCommandBufferRelease)(WGPUCommandBuffer commandBuffer) WGPU_FUNCTION_ATTRIBUTE;\n\n// Procs of CommandEncoder\ntypedef WGPUComputePassEncoder (*WGPUProcCommandEncoderBeginComputePass)(WGPUCommandEncoder commandEncoder, WGPU_NULLABLE WGPUComputePassDescriptor const * descriptor) WGPU_FUNCTION_ATTRIBUTE;\ntypedef WGPURenderPassEncoder (*WGPUProcCommandEncoderBeginRenderPass)(WGPUCommandEncoder commandEncoder, WGPURenderPassDescriptor const * descriptor) WGPU_FUNCTION_ATTRIBUTE;\ntypedef void (*WGPUProcCommandEncoderClearBuffer)(WGPUCommandEncoder commandEncoder, WGPUBuffer buffer, uint64_t offset, uint64_t size) WGPU_FUNCTION_ATTRIBUTE;\ntypedef void (*WGPUProcCommandEncoderCopyBufferToBuffer)(WGPUCommandEncoder commandEncoder, WGPUBuffer source, uint64_t sourceOffset, WGPUBuffer destination, uint64_t destinationOffset, uint64_t size) WGPU_FUNCTION_ATTRIBUTE;\ntypedef void (*WGPUProcCommandEncoderCopyBufferToTexture)(WGPUCommandEncoder commandEncoder, WGPUImageCopyBuffer const * source, WGPUImageCopyTexture const * destination, WGPUExtent3D const * copySize) WGPU_FUNCTION_ATTRIBUTE;\ntypedef void (*WGPUProcCommandEncoderCopyTextureToBuffer)(WGPUCommandEncoder commandEncoder, WGPUImageCopyTexture const * source, WGPUImageCopyBuffer const * destination, WGPUExtent3D const * copySize) WGPU_FUNCTION_ATTRIBUTE;\ntypedef void (*WGPUProcCommandEncoderCopyTextureToTexture)(WGPUCommandEncoder commandEncoder, WGPUImageCopyTexture const * source, WGPUImageCopyTexture const * destination, WGPUExtent3D const * copySize) WGPU_FUNCTION_ATTRIBUTE;\ntypedef WGPUCommandBuffer (*WGPUProcCommandEncoderFinish)(WGPUCommandEncoder commandEncoder, WGPU_NULLABLE WGPUCommandBufferDescriptor const * descriptor) WGPU_FUNCTION_ATTRIBUTE;\ntypedef void (*WGPUProcCommandEncoderInsertDebugMarker)(WGPUCommandEncoder commandEncoder, char const * markerLabel) WGPU_FUNCTION_ATTRIBUTE;\ntypedef void (*WGPUProcCommandEncoderPopDebugGroup)(WGPUCommandEncoder commandEncoder) WGPU_FUNCTION_ATTRIBUTE;\ntypedef void (*WGPUProcCommandEncoderPushDebugGroup)(WGPUCommandEncoder commandEncoder, char const * groupLabel) WGPU_FUNCTION_ATTRIBUTE;\ntypedef void (*WGPUProcCommandEncoderResolveQuerySet)(WGPUCommandEncoder commandEncoder, WGPUQuerySet querySet, uint32_t firstQuery, uint32_t queryCount, WGPUBuffer destination, uint64_t destinationOffset) WGPU_FUNCTION_ATTRIBUTE;\ntypedef void (*WGPUProcCommandEncoderSetLabel)(WGPUCommandEncoder commandEncoder, char const * label) WGPU_FUNCTION_ATTRIBUTE;\ntypedef void (*WGPUProcCommandEncoderWriteTimestamp)(WGPUCommandEncoder commandEncoder, WGPUQuerySet querySet, uint32_t queryIndex) WGPU_FUNCTION_ATTRIBUTE;\ntypedef void (*WGPUProcCommandEncoderReference)(WGPUCommandEncoder commandEncoder) WGPU_FUNCTION_ATTRIBUTE;\ntypedef void (*WGPUProcCommandEncoderRelease)(WGPUCommandEncoder commandEncoder) WGPU_FUNCTION_ATTRIBUTE;\n\n// Procs of ComputePassEncoder\ntypedef void (*WGPUProcComputePassEncoderBeginPipelineStatisticsQuery)(WGPUComputePassEncoder computePassEncoder, WGPUQuerySet querySet, uint32_t queryIndex) WGPU_FUNCTION_ATTRIBUTE;\ntypedef void (*WGPUProcComputePassEncoderDispatchWorkgroups)(WGPUComputePassEncoder computePassEncoder, uint32_t workgroupCountX, uint32_t workgroupCountY, uint32_t workgroupCountZ) WGPU_FUNCTION_ATTRIBUTE;\ntypedef void (*WGPUProcComputePassEncoderDispatchWorkgroupsIndirect)(WGPUComputePassEncoder computePassEncoder, WGPUBuffer indirectBuffer, uint64_t indirectOffset) WGPU_FUNCTION_ATTRIBUTE;\ntypedef void (*WGPUProcComputePassEncoderEnd)(WGPUComputePassEncoder computePassEncoder) WGPU_FUNCTION_ATTRIBUTE;\ntypedef void (*WGPUProcComputePassEncoderEndPipelineStatisticsQuery)(WGPUComputePassEncoder computePassEncoder) WGPU_FUNCTION_ATTRIBUTE;\ntypedef void (*WGPUProcComputePassEncoderInsertDebugMarker)(WGPUComputePassEncoder computePassEncoder, char const * markerLabel) WGPU_FUNCTION_ATTRIBUTE;\ntypedef void (*WGPUProcComputePassEncoderPopDebugGroup)(WGPUComputePassEncoder computePassEncoder) WGPU_FUNCTION_ATTRIBUTE;\ntypedef void (*WGPUProcComputePassEncoderPushDebugGroup)(WGPUComputePassEncoder computePassEncoder, char const * groupLabel) WGPU_FUNCTION_ATTRIBUTE;\ntypedef void (*WGPUProcComputePassEncoderSetBindGroup)(WGPUComputePassEncoder computePassEncoder, uint32_t groupIndex, WGPU_NULLABLE WGPUBindGroup group, size_t dynamicOffsetCount, uint32_t const * dynamicOffsets) WGPU_FUNCTION_ATTRIBUTE;\ntypedef void (*WGPUProcComputePassEncoderSetLabel)(WGPUComputePassEncoder computePassEncoder, char const * label) WGPU_FUNCTION_ATTRIBUTE;\ntypedef void (*WGPUProcComputePassEncoderSetPipeline)(WGPUComputePassEncoder computePassEncoder, WGPUComputePipeline pipeline) WGPU_FUNCTION_ATTRIBUTE;\ntypedef void (*WGPUProcComputePassEncoderWriteTimestamp)(WGPUComputePassEncoder computePassEncoder, WGPUQuerySet querySet, uint32_t queryIndex) WGPU_FUNCTION_ATTRIBUTE;\ntypedef void (*WGPUProcComputePassEncoderReference)(WGPUComputePassEncoder computePassEncoder) WGPU_FUNCTION_ATTRIBUTE;\ntypedef void (*WGPUProcComputePassEncoderRelease)(WGPUComputePassEncoder computePassEncoder) WGPU_FUNCTION_ATTRIBUTE;\n\n// Procs of ComputePipeline\ntypedef WGPUBindGroupLayout (*WGPUProcComputePipelineGetBindGroupLayout)(WGPUComputePipeline computePipeline, uint32_t groupIndex) WGPU_FUNCTION_ATTRIBUTE;\ntypedef void (*WGPUProcComputePipelineSetLabel)(WGPUComputePipeline computePipeline, char const * label) WGPU_FUNCTION_ATTRIBUTE;\ntypedef void (*WGPUProcComputePipelineReference)(WGPUComputePipeline computePipeline) WGPU_FUNCTION_ATTRIBUTE;\ntypedef void (*WGPUProcComputePipelineRelease)(WGPUComputePipeline computePipeline) WGPU_FUNCTION_ATTRIBUTE;\n\n// Procs of Device\ntypedef WGPUBindGroup (*WGPUProcDeviceCreateBindGroup)(WGPUDevice device, WGPUBindGroupDescriptor const * descriptor) WGPU_FUNCTION_ATTRIBUTE;\ntypedef WGPUBindGroupLayout (*WGPUProcDeviceCreateBindGroupLayout)(WGPUDevice device, WGPUBindGroupLayoutDescriptor const * descriptor) WGPU_FUNCTION_ATTRIBUTE;\ntypedef WGPUBuffer (*WGPUProcDeviceCreateBuffer)(WGPUDevice device, WGPUBufferDescriptor const * descriptor) WGPU_FUNCTION_ATTRIBUTE;\ntypedef WGPUCommandEncoder (*WGPUProcDeviceCreateCommandEncoder)(WGPUDevice device, WGPU_NULLABLE WGPUCommandEncoderDescriptor const * descriptor) WGPU_FUNCTION_ATTRIBUTE;\ntypedef WGPUComputePipeline (*WGPUProcDeviceCreateComputePipeline)(WGPUDevice device, WGPUComputePipelineDescriptor const * descriptor) WGPU_FUNCTION_ATTRIBUTE;\ntypedef void (*WGPUProcDeviceCreateComputePipelineAsync)(WGPUDevice device, WGPUComputePipelineDescriptor const * descriptor, WGPUCreateComputePipelineAsyncCallback callback, void * userdata) WGPU_FUNCTION_ATTRIBUTE;\ntypedef WGPUPipelineLayout (*WGPUProcDeviceCreatePipelineLayout)(WGPUDevice device, WGPUPipelineLayoutDescriptor const * descriptor) WGPU_FUNCTION_ATTRIBUTE;\ntypedef WGPUQuerySet (*WGPUProcDeviceCreateQuerySet)(WGPUDevice device, WGPUQuerySetDescriptor const * descriptor) WGPU_FUNCTION_ATTRIBUTE;\ntypedef WGPURenderBundleEncoder (*WGPUProcDeviceCreateRenderBundleEncoder)(WGPUDevice device, WGPURenderBundleEncoderDescriptor const * descriptor) WGPU_FUNCTION_ATTRIBUTE;\ntypedef WGPURenderPipeline (*WGPUProcDeviceCreateRenderPipeline)(WGPUDevice device, WGPURenderPipelineDescriptor const * descriptor) WGPU_FUNCTION_ATTRIBUTE;\ntypedef void (*WGPUProcDeviceCreateRenderPipelineAsync)(WGPUDevice device, WGPURenderPipelineDescriptor const * descriptor, WGPUCreateRenderPipelineAsyncCallback callback, void * userdata) WGPU_FUNCTION_ATTRIBUTE;\ntypedef WGPUSampler (*WGPUProcDeviceCreateSampler)(WGPUDevice device, WGPU_NULLABLE WGPUSamplerDescriptor const * descriptor) WGPU_FUNCTION_ATTRIBUTE;\ntypedef WGPUShaderModule (*WGPUProcDeviceCreateShaderModule)(WGPUDevice device, WGPUShaderModuleDescriptor const * descriptor) WGPU_FUNCTION_ATTRIBUTE;\ntypedef WGPUSwapChain (*WGPUProcDeviceCreateSwapChain)(WGPUDevice device, WGPUSurface surface, WGPUSwapChainDescriptor const * descriptor) WGPU_FUNCTION_ATTRIBUTE;\ntypedef WGPUTexture (*WGPUProcDeviceCreateTexture)(WGPUDevice device, WGPUTextureDescriptor const * descriptor) WGPU_FUNCTION_ATTRIBUTE;\ntypedef void (*WGPUProcDeviceDestroy)(WGPUDevice device) WGPU_FUNCTION_ATTRIBUTE;\ntypedef size_t (*WGPUProcDeviceEnumerateFeatures)(WGPUDevice device, WGPUFeatureName * features) WGPU_FUNCTION_ATTRIBUTE;\ntypedef bool (*WGPUProcDeviceGetLimits)(WGPUDevice device, WGPUSupportedLimits * limits) WGPU_FUNCTION_ATTRIBUTE;\ntypedef WGPUQueue (*WGPUProcDeviceGetQueue)(WGPUDevice device) WGPU_FUNCTION_ATTRIBUTE;\ntypedef bool (*WGPUProcDeviceHasFeature)(WGPUDevice device, WGPUFeatureName feature) WGPU_FUNCTION_ATTRIBUTE;\ntypedef void (*WGPUProcDevicePopErrorScope)(WGPUDevice device, WGPUErrorCallback callback, void * userdata) WGPU_FUNCTION_ATTRIBUTE;\ntypedef void (*WGPUProcDevicePushErrorScope)(WGPUDevice device, WGPUErrorFilter filter) WGPU_FUNCTION_ATTRIBUTE;\ntypedef void (*WGPUProcDeviceSetLabel)(WGPUDevice device, char const * label) WGPU_FUNCTION_ATTRIBUTE;\ntypedef void (*WGPUProcDeviceSetUncapturedErrorCallback)(WGPUDevice device, WGPUErrorCallback callback, void * userdata) WGPU_FUNCTION_ATTRIBUTE;\ntypedef void (*WGPUProcDeviceReference)(WGPUDevice device) WGPU_FUNCTION_ATTRIBUTE;\ntypedef void (*WGPUProcDeviceRelease)(WGPUDevice device) WGPU_FUNCTION_ATTRIBUTE;\n\n// Procs of Instance\ntypedef WGPUSurface (*WGPUProcInstanceCreateSurface)(WGPUInstance instance, WGPUSurfaceDescriptor const * descriptor) WGPU_FUNCTION_ATTRIBUTE;\ntypedef void (*WGPUProcInstanceProcessEvents)(WGPUInstance instance) WGPU_FUNCTION_ATTRIBUTE;\ntypedef void (*WGPUProcInstanceRequestAdapter)(WGPUInstance instance, WGPU_NULLABLE WGPURequestAdapterOptions const * options, WGPURequestAdapterCallback callback, void * userdata) WGPU_FUNCTION_ATTRIBUTE;\ntypedef void (*WGPUProcInstanceReference)(WGPUInstance instance) WGPU_FUNCTION_ATTRIBUTE;\ntypedef void (*WGPUProcInstanceRelease)(WGPUInstance instance) WGPU_FUNCTION_ATTRIBUTE;\n\n// Procs of PipelineLayout\ntypedef void (*WGPUProcPipelineLayoutSetLabel)(WGPUPipelineLayout pipelineLayout, char const * label) WGPU_FUNCTION_ATTRIBUTE;\ntypedef void (*WGPUProcPipelineLayoutReference)(WGPUPipelineLayout pipelineLayout) WGPU_FUNCTION_ATTRIBUTE;\ntypedef void (*WGPUProcPipelineLayoutRelease)(WGPUPipelineLayout pipelineLayout) WGPU_FUNCTION_ATTRIBUTE;\n\n// Procs of QuerySet\ntypedef void (*WGPUProcQuerySetDestroy)(WGPUQuerySet querySet) WGPU_FUNCTION_ATTRIBUTE;\ntypedef uint32_t (*WGPUProcQuerySetGetCount)(WGPUQuerySet querySet) WGPU_FUNCTION_ATTRIBUTE;\ntypedef WGPUQueryType (*WGPUProcQuerySetGetType)(WGPUQuerySet querySet) WGPU_FUNCTION_ATTRIBUTE;\ntypedef void (*WGPUProcQuerySetSetLabel)(WGPUQuerySet querySet, char const * label) WGPU_FUNCTION_ATTRIBUTE;\ntypedef void (*WGPUProcQuerySetReference)(WGPUQuerySet querySet) WGPU_FUNCTION_ATTRIBUTE;\ntypedef void (*WGPUProcQuerySetRelease)(WGPUQuerySet querySet) WGPU_FUNCTION_ATTRIBUTE;\n\n// Procs of Queue\ntypedef void (*WGPUProcQueueOnSubmittedWorkDone)(WGPUQueue queue, uint64_t signalValue, WGPUQueueWorkDoneCallback callback, void * userdata) WGPU_FUNCTION_ATTRIBUTE;\ntypedef void (*WGPUProcQueueSetLabel)(WGPUQueue queue, char const * label) WGPU_FUNCTION_ATTRIBUTE;\ntypedef void (*WGPUProcQueueSubmit)(WGPUQueue queue, size_t commandCount, WGPUCommandBuffer const * commands) WGPU_FUNCTION_ATTRIBUTE;\ntypedef void (*WGPUProcQueueWriteBuffer)(WGPUQueue queue, WGPUBuffer buffer, uint64_t bufferOffset, void const * data, size_t size) WGPU_FUNCTION_ATTRIBUTE;\ntypedef void (*WGPUProcQueueWriteTexture)(WGPUQueue queue, WGPUImageCopyTexture const * destination, void const * data, size_t dataSize, WGPUTextureDataLayout const * dataLayout, WGPUExtent3D const * writeSize) WGPU_FUNCTION_ATTRIBUTE;\ntypedef void (*WGPUProcQueueReference)(WGPUQueue queue) WGPU_FUNCTION_ATTRIBUTE;\ntypedef void (*WGPUProcQueueRelease)(WGPUQueue queue) WGPU_FUNCTION_ATTRIBUTE;\n\n// Procs of RenderBundle\ntypedef void (*WGPUProcRenderBundleSetLabel)(WGPURenderBundle renderBundle, char const * label) WGPU_FUNCTION_ATTRIBUTE;\ntypedef void (*WGPUProcRenderBundleReference)(WGPURenderBundle renderBundle) WGPU_FUNCTION_ATTRIBUTE;\ntypedef void (*WGPUProcRenderBundleRelease)(WGPURenderBundle renderBundle) WGPU_FUNCTION_ATTRIBUTE;\n\n// Procs of RenderBundleEncoder\ntypedef void (*WGPUProcRenderBundleEncoderDraw)(WGPURenderBundleEncoder renderBundleEncoder, uint32_t vertexCount, uint32_t instanceCount, uint32_t firstVertex, uint32_t firstInstance) WGPU_FUNCTION_ATTRIBUTE;\ntypedef void (*WGPUProcRenderBundleEncoderDrawIndexed)(WGPURenderBundleEncoder renderBundleEncoder, uint32_t indexCount, uint32_t instanceCount, uint32_t firstIndex, int32_t baseVertex, uint32_t firstInstance) WGPU_FUNCTION_ATTRIBUTE;\ntypedef void (*WGPUProcRenderBundleEncoderDrawIndexedIndirect)(WGPURenderBundleEncoder renderBundleEncoder, WGPUBuffer indirectBuffer, uint64_t indirectOffset) WGPU_FUNCTION_ATTRIBUTE;\ntypedef void (*WGPUProcRenderBundleEncoderDrawIndirect)(WGPURenderBundleEncoder renderBundleEncoder, WGPUBuffer indirectBuffer, uint64_t indirectOffset) WGPU_FUNCTION_ATTRIBUTE;\ntypedef WGPURenderBundle (*WGPUProcRenderBundleEncoderFinish)(WGPURenderBundleEncoder renderBundleEncoder, WGPU_NULLABLE WGPURenderBundleDescriptor const * descriptor) WGPU_FUNCTION_ATTRIBUTE;\ntypedef void (*WGPUProcRenderBundleEncoderInsertDebugMarker)(WGPURenderBundleEncoder renderBundleEncoder, char const * markerLabel) WGPU_FUNCTION_ATTRIBUTE;\ntypedef void (*WGPUProcRenderBundleEncoderPopDebugGroup)(WGPURenderBundleEncoder renderBundleEncoder) WGPU_FUNCTION_ATTRIBUTE;\ntypedef void (*WGPUProcRenderBundleEncoderPushDebugGroup)(WGPURenderBundleEncoder renderBundleEncoder, char const * groupLabel) WGPU_FUNCTION_ATTRIBUTE;\ntypedef void (*WGPUProcRenderBundleEncoderSetBindGroup)(WGPURenderBundleEncoder renderBundleEncoder, uint32_t groupIndex, WGPU_NULLABLE WGPUBindGroup group, size_t dynamicOffsetCount, uint32_t const * dynamicOffsets) WGPU_FUNCTION_ATTRIBUTE;\ntypedef void (*WGPUProcRenderBundleEncoderSetIndexBuffer)(WGPURenderBundleEncoder renderBundleEncoder, WGPUBuffer buffer, WGPUIndexFormat format, uint64_t offset, uint64_t size) WGPU_FUNCTION_ATTRIBUTE;\ntypedef void (*WGPUProcRenderBundleEncoderSetLabel)(WGPURenderBundleEncoder renderBundleEncoder, char const * label) WGPU_FUNCTION_ATTRIBUTE;\ntypedef void (*WGPUProcRenderBundleEncoderSetPipeline)(WGPURenderBundleEncoder renderBundleEncoder, WGPURenderPipeline pipeline) WGPU_FUNCTION_ATTRIBUTE;\ntypedef void (*WGPUProcRenderBundleEncoderSetVertexBuffer)(WGPURenderBundleEncoder renderBundleEncoder, uint32_t slot, WGPU_NULLABLE WGPUBuffer buffer, uint64_t offset, uint64_t size) WGPU_FUNCTION_ATTRIBUTE;\ntypedef void (*WGPUProcRenderBundleEncoderReference)(WGPURenderBundleEncoder renderBundleEncoder) WGPU_FUNCTION_ATTRIBUTE;\ntypedef void (*WGPUProcRenderBundleEncoderRelease)(WGPURenderBundleEncoder renderBundleEncoder) WGPU_FUNCTION_ATTRIBUTE;\n\n// Procs of RenderPassEncoder\ntypedef void (*WGPUProcRenderPassEncoderBeginOcclusionQuery)(WGPURenderPassEncoder renderPassEncoder, uint32_t queryIndex) WGPU_FUNCTION_ATTRIBUTE;\ntypedef void (*WGPUProcRenderPassEncoderBeginPipelineStatisticsQuery)(WGPURenderPassEncoder renderPassEncoder, WGPUQuerySet querySet, uint32_t queryIndex) WGPU_FUNCTION_ATTRIBUTE;\ntypedef void (*WGPUProcRenderPassEncoderDraw)(WGPURenderPassEncoder renderPassEncoder, uint32_t vertexCount, uint32_t instanceCount, uint32_t firstVertex, uint32_t firstInstance) WGPU_FUNCTION_ATTRIBUTE;\ntypedef void (*WGPUProcRenderPassEncoderDrawIndexed)(WGPURenderPassEncoder renderPassEncoder, uint32_t indexCount, uint32_t instanceCount, uint32_t firstIndex, int32_t baseVertex, uint32_t firstInstance) WGPU_FUNCTION_ATTRIBUTE;\ntypedef void (*WGPUProcRenderPassEncoderDrawIndexedIndirect)(WGPURenderPassEncoder renderPassEncoder, WGPUBuffer indirectBuffer, uint64_t indirectOffset) WGPU_FUNCTION_ATTRIBUTE;\ntypedef void (*WGPUProcRenderPassEncoderDrawIndirect)(WGPURenderPassEncoder renderPassEncoder, WGPUBuffer indirectBuffer, uint64_t indirectOffset) WGPU_FUNCTION_ATTRIBUTE;\ntypedef void (*WGPUProcRenderPassEncoderEnd)(WGPURenderPassEncoder renderPassEncoder) WGPU_FUNCTION_ATTRIBUTE;\ntypedef void (*WGPUProcRenderPassEncoderEndOcclusionQuery)(WGPURenderPassEncoder renderPassEncoder) WGPU_FUNCTION_ATTRIBUTE;\ntypedef void (*WGPUProcRenderPassEncoderEndPipelineStatisticsQuery)(WGPURenderPassEncoder renderPassEncoder) WGPU_FUNCTION_ATTRIBUTE;\ntypedef void (*WGPUProcRenderPassEncoderExecuteBundles)(WGPURenderPassEncoder renderPassEncoder, size_t bundleCount, WGPURenderBundle const * bundles) WGPU_FUNCTION_ATTRIBUTE;\ntypedef void (*WGPUProcRenderPassEncoderInsertDebugMarker)(WGPURenderPassEncoder renderPassEncoder, char const * markerLabel) WGPU_FUNCTION_ATTRIBUTE;\ntypedef void (*WGPUProcRenderPassEncoderPopDebugGroup)(WGPURenderPassEncoder renderPassEncoder) WGPU_FUNCTION_ATTRIBUTE;\ntypedef void (*WGPUProcRenderPassEncoderPushDebugGroup)(WGPURenderPassEncoder renderPassEncoder, char const * groupLabel) WGPU_FUNCTION_ATTRIBUTE;\ntypedef void (*WGPUProcRenderPassEncoderSetBindGroup)(WGPURenderPassEncoder renderPassEncoder, uint32_t groupIndex, WGPU_NULLABLE WGPUBindGroup group, size_t dynamicOffsetCount, uint32_t const * dynamicOffsets) WGPU_FUNCTION_ATTRIBUTE;\ntypedef void (*WGPUProcRenderPassEncoderSetBlendConstant)(WGPURenderPassEncoder renderPassEncoder, WGPUColor const * color) WGPU_FUNCTION_ATTRIBUTE;\ntypedef void (*WGPUProcRenderPassEncoderSetIndexBuffer)(WGPURenderPassEncoder renderPassEncoder, WGPUBuffer buffer, WGPUIndexFormat format, uint64_t offset, uint64_t size) WGPU_FUNCTION_ATTRIBUTE;\ntypedef void (*WGPUProcRenderPassEncoderSetLabel)(WGPURenderPassEncoder renderPassEncoder, char const * label) WGPU_FUNCTION_ATTRIBUTE;\ntypedef void (*WGPUProcRenderPassEncoderSetPipeline)(WGPURenderPassEncoder renderPassEncoder, WGPURenderPipeline pipeline) WGPU_FUNCTION_ATTRIBUTE;\ntypedef void (*WGPUProcRenderPassEncoderSetScissorRect)(WGPURenderPassEncoder renderPassEncoder, uint32_t x, uint32_t y, uint32_t width, uint32_t height) WGPU_FUNCTION_ATTRIBUTE;\ntypedef void (*WGPUProcRenderPassEncoderSetStencilReference)(WGPURenderPassEncoder renderPassEncoder, uint32_t reference) WGPU_FUNCTION_ATTRIBUTE;\ntypedef void (*WGPUProcRenderPassEncoderSetVertexBuffer)(WGPURenderPassEncoder renderPassEncoder, uint32_t slot, WGPU_NULLABLE WGPUBuffer buffer, uint64_t offset, uint64_t size) WGPU_FUNCTION_ATTRIBUTE;\ntypedef void (*WGPUProcRenderPassEncoderSetViewport)(WGPURenderPassEncoder renderPassEncoder, float x, float y, float width, float height, float minDepth, float maxDepth) WGPU_FUNCTION_ATTRIBUTE;\ntypedef void (*WGPUProcRenderPassEncoderWriteTimestamp)(WGPURenderPassEncoder renderPassEncoder, WGPUQuerySet querySet, uint32_t queryIndex) WGPU_FUNCTION_ATTRIBUTE;\ntypedef void (*WGPUProcRenderPassEncoderReference)(WGPURenderPassEncoder renderPassEncoder) WGPU_FUNCTION_ATTRIBUTE;\ntypedef void (*WGPUProcRenderPassEncoderRelease)(WGPURenderPassEncoder renderPassEncoder) WGPU_FUNCTION_ATTRIBUTE;\n\n// Procs of RenderPipeline\ntypedef WGPUBindGroupLayout (*WGPUProcRenderPipelineGetBindGroupLayout)(WGPURenderPipeline renderPipeline, uint32_t groupIndex) WGPU_FUNCTION_ATTRIBUTE;\ntypedef void (*WGPUProcRenderPipelineSetLabel)(WGPURenderPipeline renderPipeline, char const * label) WGPU_FUNCTION_ATTRIBUTE;\ntypedef void (*WGPUProcRenderPipelineReference)(WGPURenderPipeline renderPipeline) WGPU_FUNCTION_ATTRIBUTE;\ntypedef void (*WGPUProcRenderPipelineRelease)(WGPURenderPipeline renderPipeline) WGPU_FUNCTION_ATTRIBUTE;\n\n// Procs of Sampler\ntypedef void (*WGPUProcSamplerSetLabel)(WGPUSampler sampler, char const * label) WGPU_FUNCTION_ATTRIBUTE;\ntypedef void (*WGPUProcSamplerReference)(WGPUSampler sampler) WGPU_FUNCTION_ATTRIBUTE;\ntypedef void (*WGPUProcSamplerRelease)(WGPUSampler sampler) WGPU_FUNCTION_ATTRIBUTE;\n\n// Procs of ShaderModule\ntypedef void (*WGPUProcShaderModuleGetCompilationInfo)(WGPUShaderModule shaderModule, WGPUCompilationInfoCallback callback, void * userdata) WGPU_FUNCTION_ATTRIBUTE;\ntypedef void (*WGPUProcShaderModuleSetLabel)(WGPUShaderModule shaderModule, char const * label) WGPU_FUNCTION_ATTRIBUTE;\ntypedef void (*WGPUProcShaderModuleReference)(WGPUShaderModule shaderModule) WGPU_FUNCTION_ATTRIBUTE;\ntypedef void (*WGPUProcShaderModuleRelease)(WGPUShaderModule shaderModule) WGPU_FUNCTION_ATTRIBUTE;\n\n// Procs of Surface\ntypedef WGPUTextureFormat (*WGPUProcSurfaceGetPreferredFormat)(WGPUSurface surface, WGPUAdapter adapter) WGPU_FUNCTION_ATTRIBUTE;\ntypedef void (*WGPUProcSurfaceReference)(WGPUSurface surface) WGPU_FUNCTION_ATTRIBUTE;\ntypedef void (*WGPUProcSurfaceRelease)(WGPUSurface surface) WGPU_FUNCTION_ATTRIBUTE;\n\n// Procs of SwapChain\ntypedef WGPUTextureView (*WGPUProcSwapChainGetCurrentTextureView)(WGPUSwapChain swapChain) WGPU_FUNCTION_ATTRIBUTE;\ntypedef void (*WGPUProcSwapChainPresent)(WGPUSwapChain swapChain) WGPU_FUNCTION_ATTRIBUTE;\ntypedef void (*WGPUProcSwapChainReference)(WGPUSwapChain swapChain) WGPU_FUNCTION_ATTRIBUTE;\ntypedef void (*WGPUProcSwapChainRelease)(WGPUSwapChain swapChain) WGPU_FUNCTION_ATTRIBUTE;\n\n// Procs of Texture\ntypedef WGPUTextureView (*WGPUProcTextureCreateView)(WGPUTexture texture, WGPU_NULLABLE WGPUTextureViewDescriptor const * descriptor) WGPU_FUNCTION_ATTRIBUTE;\ntypedef void (*WGPUProcTextureDestroy)(WGPUTexture texture) WGPU_FUNCTION_ATTRIBUTE;\ntypedef uint32_t (*WGPUProcTextureGetDepthOrArrayLayers)(WGPUTexture texture) WGPU_FUNCTION_ATTRIBUTE;\ntypedef WGPUTextureDimension (*WGPUProcTextureGetDimension)(WGPUTexture texture) WGPU_FUNCTION_ATTRIBUTE;\ntypedef WGPUTextureFormat (*WGPUProcTextureGetFormat)(WGPUTexture texture) WGPU_FUNCTION_ATTRIBUTE;\ntypedef uint32_t (*WGPUProcTextureGetHeight)(WGPUTexture texture) WGPU_FUNCTION_ATTRIBUTE;\ntypedef uint32_t (*WGPUProcTextureGetMipLevelCount)(WGPUTexture texture) WGPU_FUNCTION_ATTRIBUTE;\ntypedef uint32_t (*WGPUProcTextureGetSampleCount)(WGPUTexture texture) WGPU_FUNCTION_ATTRIBUTE;\ntypedef WGPUTextureUsageFlags (*WGPUProcTextureGetUsage)(WGPUTexture texture) WGPU_FUNCTION_ATTRIBUTE;\ntypedef uint32_t (*WGPUProcTextureGetWidth)(WGPUTexture texture) WGPU_FUNCTION_ATTRIBUTE;\ntypedef void (*WGPUProcTextureSetLabel)(WGPUTexture texture, char const * label) WGPU_FUNCTION_ATTRIBUTE;\ntypedef void (*WGPUProcTextureReference)(WGPUTexture texture) WGPU_FUNCTION_ATTRIBUTE;\ntypedef void (*WGPUProcTextureRelease)(WGPUTexture texture) WGPU_FUNCTION_ATTRIBUTE;\n\n// Procs of TextureView\ntypedef void (*WGPUProcTextureViewSetLabel)(WGPUTextureView textureView, char const * label) WGPU_FUNCTION_ATTRIBUTE;\ntypedef void (*WGPUProcTextureViewReference)(WGPUTextureView textureView) WGPU_FUNCTION_ATTRIBUTE;\ntypedef void (*WGPUProcTextureViewRelease)(WGPUTextureView textureView) WGPU_FUNCTION_ATTRIBUTE;\n\n#endif  // !defined(WGPU_SKIP_PROCS)\n\n#if !defined(WGPU_SKIP_DECLARATIONS)\n\nWGPU_EXPORT WGPUInstance wgpuCreateInstance(WGPUInstanceDescriptor const * descriptor) WGPU_FUNCTION_ATTRIBUTE;\nWGPU_EXPORT WGPUProc wgpuGetProcAddress(WGPUDevice device, char const * procName) WGPU_FUNCTION_ATTRIBUTE;\n\n// Methods of Adapter\nWGPU_EXPORT size_t wgpuAdapterEnumerateFeatures(WGPUAdapter adapter, WGPUFeatureName * features) WGPU_FUNCTION_ATTRIBUTE;\nWGPU_EXPORT bool wgpuAdapterGetLimits(WGPUAdapter adapter, WGPUSupportedLimits * limits) WGPU_FUNCTION_ATTRIBUTE;\nWGPU_EXPORT void wgpuAdapterGetProperties(WGPUAdapter adapter, WGPUAdapterProperties * properties) WGPU_FUNCTION_ATTRIBUTE;\nWGPU_EXPORT bool wgpuAdapterHasFeature(WGPUAdapter adapter, WGPUFeatureName feature) WGPU_FUNCTION_ATTRIBUTE;\nWGPU_EXPORT void wgpuAdapterRequestDevice(WGPUAdapter adapter, WGPU_NULLABLE WGPUDeviceDescriptor const * descriptor, WGPURequestDeviceCallback callback, void * userdata) WGPU_FUNCTION_ATTRIBUTE;\nWGPU_EXPORT void wgpuAdapterReference(WGPUAdapter adapter) WGPU_FUNCTION_ATTRIBUTE;\nWGPU_EXPORT void wgpuAdapterRelease(WGPUAdapter adapter) WGPU_FUNCTION_ATTRIBUTE;\n\n// Methods of BindGroup\nWGPU_EXPORT void wgpuBindGroupSetLabel(WGPUBindGroup bindGroup, char const * label) WGPU_FUNCTION_ATTRIBUTE;\nWGPU_EXPORT void wgpuBindGroupReference(WGPUBindGroup bindGroup) WGPU_FUNCTION_ATTRIBUTE;\nWGPU_EXPORT void wgpuBindGroupRelease(WGPUBindGroup bindGroup) WGPU_FUNCTION_ATTRIBUTE;\n\n// Methods of BindGroupLayout\nWGPU_EXPORT void wgpuBindGroupLayoutSetLabel(WGPUBindGroupLayout bindGroupLayout, char const * label) WGPU_FUNCTION_ATTRIBUTE;\nWGPU_EXPORT void wgpuBindGroupLayoutReference(WGPUBindGroupLayout bindGroupLayout) WGPU_FUNCTION_ATTRIBUTE;\nWGPU_EXPORT void wgpuBindGroupLayoutRelease(WGPUBindGroupLayout bindGroupLayout) WGPU_FUNCTION_ATTRIBUTE;\n\n// Methods of Buffer\nWGPU_EXPORT void wgpuBufferDestroy(WGPUBuffer buffer) WGPU_FUNCTION_ATTRIBUTE;\nWGPU_EXPORT void const * wgpuBufferGetConstMappedRange(WGPUBuffer buffer, size_t offset, size_t size) WGPU_FUNCTION_ATTRIBUTE;\nWGPU_EXPORT WGPUBufferMapState wgpuBufferGetMapState(WGPUBuffer buffer) WGPU_FUNCTION_ATTRIBUTE;\nWGPU_EXPORT void * wgpuBufferGetMappedRange(WGPUBuffer buffer, size_t offset, size_t size) WGPU_FUNCTION_ATTRIBUTE;\nWGPU_EXPORT uint64_t wgpuBufferGetSize(WGPUBuffer buffer) WGPU_FUNCTION_ATTRIBUTE;\nWGPU_EXPORT WGPUBufferUsageFlags wgpuBufferGetUsage(WGPUBuffer buffer) WGPU_FUNCTION_ATTRIBUTE;\nWGPU_EXPORT void wgpuBufferMapAsync(WGPUBuffer buffer, WGPUMapModeFlags mode, size_t offset, size_t size, WGPUBufferMapCallback callback, void * userdata) WGPU_FUNCTION_ATTRIBUTE;\nWGPU_EXPORT void wgpuBufferSetLabel(WGPUBuffer buffer, char const * label) WGPU_FUNCTION_ATTRIBUTE;\nWGPU_EXPORT void wgpuBufferUnmap(WGPUBuffer buffer) WGPU_FUNCTION_ATTRIBUTE;\nWGPU_EXPORT void wgpuBufferReference(WGPUBuffer buffer) WGPU_FUNCTION_ATTRIBUTE;\nWGPU_EXPORT void wgpuBufferRelease(WGPUBuffer buffer) WGPU_FUNCTION_ATTRIBUTE;\n\n// Methods of CommandBuffer\nWGPU_EXPORT void wgpuCommandBufferSetLabel(WGPUCommandBuffer commandBuffer, char const * label) WGPU_FUNCTION_ATTRIBUTE;\nWGPU_EXPORT void wgpuCommandBufferReference(WGPUCommandBuffer commandBuffer) WGPU_FUNCTION_ATTRIBUTE;\nWGPU_EXPORT void wgpuCommandBufferRelease(WGPUCommandBuffer commandBuffer) WGPU_FUNCTION_ATTRIBUTE;\n\n// Methods of CommandEncoder\nWGPU_EXPORT WGPUComputePassEncoder wgpuCommandEncoderBeginComputePass(WGPUCommandEncoder commandEncoder, WGPU_NULLABLE WGPUComputePassDescriptor const * descriptor) WGPU_FUNCTION_ATTRIBUTE;\nWGPU_EXPORT WGPURenderPassEncoder wgpuCommandEncoderBeginRenderPass(WGPUCommandEncoder commandEncoder, WGPURenderPassDescriptor const * descriptor) WGPU_FUNCTION_ATTRIBUTE;\nWGPU_EXPORT void wgpuCommandEncoderClearBuffer(WGPUCommandEncoder commandEncoder, WGPUBuffer buffer, uint64_t offset, uint64_t size) WGPU_FUNCTION_ATTRIBUTE;\nWGPU_EXPORT void wgpuCommandEncoderCopyBufferToBuffer(WGPUCommandEncoder commandEncoder, WGPUBuffer source, uint64_t sourceOffset, WGPUBuffer destination, uint64_t destinationOffset, uint64_t size) WGPU_FUNCTION_ATTRIBUTE;\nWGPU_EXPORT void wgpuCommandEncoderCopyBufferToTexture(WGPUCommandEncoder commandEncoder, WGPUImageCopyBuffer const * source, WGPUImageCopyTexture const * destination, WGPUExtent3D const * copySize) WGPU_FUNCTION_ATTRIBUTE;\nWGPU_EXPORT void wgpuCommandEncoderCopyTextureToBuffer(WGPUCommandEncoder commandEncoder, WGPUImageCopyTexture const * source, WGPUImageCopyBuffer const * destination, WGPUExtent3D const * copySize) WGPU_FUNCTION_ATTRIBUTE;\nWGPU_EXPORT void wgpuCommandEncoderCopyTextureToTexture(WGPUCommandEncoder commandEncoder, WGPUImageCopyTexture const * source, WGPUImageCopyTexture const * destination, WGPUExtent3D const * copySize) WGPU_FUNCTION_ATTRIBUTE;\nWGPU_EXPORT WGPUCommandBuffer wgpuCommandEncoderFinish(WGPUCommandEncoder commandEncoder, WGPU_NULLABLE WGPUCommandBufferDescriptor const * descriptor) WGPU_FUNCTION_ATTRIBUTE;\nWGPU_EXPORT void wgpuCommandEncoderInsertDebugMarker(WGPUCommandEncoder commandEncoder, char const * markerLabel) WGPU_FUNCTION_ATTRIBUTE;\nWGPU_EXPORT void wgpuCommandEncoderPopDebugGroup(WGPUCommandEncoder commandEncoder) WGPU_FUNCTION_ATTRIBUTE;\nWGPU_EXPORT void wgpuCommandEncoderPushDebugGroup(WGPUCommandEncoder commandEncoder, char const * groupLabel) WGPU_FUNCTION_ATTRIBUTE;\nWGPU_EXPORT void wgpuCommandEncoderResolveQuerySet(WGPUCommandEncoder commandEncoder, WGPUQuerySet querySet, uint32_t firstQuery, uint32_t queryCount, WGPUBuffer destination, uint64_t destinationOffset) WGPU_FUNCTION_ATTRIBUTE;\nWGPU_EXPORT void wgpuCommandEncoderSetLabel(WGPUCommandEncoder commandEncoder, char const * label) WGPU_FUNCTION_ATTRIBUTE;\nWGPU_EXPORT void wgpuCommandEncoderWriteTimestamp(WGPUCommandEncoder commandEncoder, WGPUQuerySet querySet, uint32_t queryIndex) WGPU_FUNCTION_ATTRIBUTE;\nWGPU_EXPORT void wgpuCommandEncoderReference(WGPUCommandEncoder commandEncoder) WGPU_FUNCTION_ATTRIBUTE;\nWGPU_EXPORT void wgpuCommandEncoderRelease(WGPUCommandEncoder commandEncoder) WGPU_FUNCTION_ATTRIBUTE;\n\n// Methods of ComputePassEncoder\nWGPU_EXPORT void wgpuComputePassEncoderBeginPipelineStatisticsQuery(WGPUComputePassEncoder computePassEncoder, WGPUQuerySet querySet, uint32_t queryIndex) WGPU_FUNCTION_ATTRIBUTE;\nWGPU_EXPORT void wgpuComputePassEncoderDispatchWorkgroups(WGPUComputePassEncoder computePassEncoder, uint32_t workgroupCountX, uint32_t workgroupCountY, uint32_t workgroupCountZ) WGPU_FUNCTION_ATTRIBUTE;\nWGPU_EXPORT void wgpuComputePassEncoderDispatchWorkgroupsIndirect(WGPUComputePassEncoder computePassEncoder, WGPUBuffer indirectBuffer, uint64_t indirectOffset) WGPU_FUNCTION_ATTRIBUTE;\nWGPU_EXPORT void wgpuComputePassEncoderEnd(WGPUComputePassEncoder computePassEncoder) WGPU_FUNCTION_ATTRIBUTE;\nWGPU_EXPORT void wgpuComputePassEncoderEndPipelineStatisticsQuery(WGPUComputePassEncoder computePassEncoder) WGPU_FUNCTION_ATTRIBUTE;\nWGPU_EXPORT void wgpuComputePassEncoderInsertDebugMarker(WGPUComputePassEncoder computePassEncoder, char const * markerLabel) WGPU_FUNCTION_ATTRIBUTE;\nWGPU_EXPORT void wgpuComputePassEncoderPopDebugGroup(WGPUComputePassEncoder computePassEncoder) WGPU_FUNCTION_ATTRIBUTE;\nWGPU_EXPORT void wgpuComputePassEncoderPushDebugGroup(WGPUComputePassEncoder computePassEncoder, char const * groupLabel) WGPU_FUNCTION_ATTRIBUTE;\nWGPU_EXPORT void wgpuComputePassEncoderSetBindGroup(WGPUComputePassEncoder computePassEncoder, uint32_t groupIndex, WGPU_NULLABLE WGPUBindGroup group, size_t dynamicOffsetCount, uint32_t const * dynamicOffsets) WGPU_FUNCTION_ATTRIBUTE;\nWGPU_EXPORT void wgpuComputePassEncoderSetLabel(WGPUComputePassEncoder computePassEncoder, char const * label) WGPU_FUNCTION_ATTRIBUTE;\nWGPU_EXPORT void wgpuComputePassEncoderSetPipeline(WGPUComputePassEncoder computePassEncoder, WGPUComputePipeline pipeline) WGPU_FUNCTION_ATTRIBUTE;\nWGPU_EXPORT void wgpuComputePassEncoderWriteTimestamp(WGPUComputePassEncoder computePassEncoder, WGPUQuerySet querySet, uint32_t queryIndex) WGPU_FUNCTION_ATTRIBUTE;\nWGPU_EXPORT void wgpuComputePassEncoderReference(WGPUComputePassEncoder computePassEncoder) WGPU_FUNCTION_ATTRIBUTE;\nWGPU_EXPORT void wgpuComputePassEncoderRelease(WGPUComputePassEncoder computePassEncoder) WGPU_FUNCTION_ATTRIBUTE;\n\n// Methods of ComputePipeline\nWGPU_EXPORT WGPUBindGroupLayout wgpuComputePipelineGetBindGroupLayout(WGPUComputePipeline computePipeline, uint32_t groupIndex) WGPU_FUNCTION_ATTRIBUTE;\nWGPU_EXPORT void wgpuComputePipelineSetLabel(WGPUComputePipeline computePipeline, char const * label) WGPU_FUNCTION_ATTRIBUTE;\nWGPU_EXPORT void wgpuComputePipelineReference(WGPUComputePipeline computePipeline) WGPU_FUNCTION_ATTRIBUTE;\nWGPU_EXPORT void wgpuComputePipelineRelease(WGPUComputePipeline computePipeline) WGPU_FUNCTION_ATTRIBUTE;\n\n// Methods of Device\nWGPU_EXPORT WGPUBindGroup wgpuDeviceCreateBindGroup(WGPUDevice device, WGPUBindGroupDescriptor const * descriptor) WGPU_FUNCTION_ATTRIBUTE;\nWGPU_EXPORT WGPUBindGroupLayout wgpuDeviceCreateBindGroupLayout(WGPUDevice device, WGPUBindGroupLayoutDescriptor const * descriptor) WGPU_FUNCTION_ATTRIBUTE;\nWGPU_EXPORT WGPUBuffer wgpuDeviceCreateBuffer(WGPUDevice device, WGPUBufferDescriptor const * descriptor) WGPU_FUNCTION_ATTRIBUTE;\nWGPU_EXPORT WGPUCommandEncoder wgpuDeviceCreateCommandEncoder(WGPUDevice device, WGPU_NULLABLE WGPUCommandEncoderDescriptor const * descriptor) WGPU_FUNCTION_ATTRIBUTE;\nWGPU_EXPORT WGPUComputePipeline wgpuDeviceCreateComputePipeline(WGPUDevice device, WGPUComputePipelineDescriptor const * descriptor) WGPU_FUNCTION_ATTRIBUTE;\nWGPU_EXPORT void wgpuDeviceCreateComputePipelineAsync(WGPUDevice device, WGPUComputePipelineDescriptor const * descriptor, WGPUCreateComputePipelineAsyncCallback callback, void * userdata) WGPU_FUNCTION_ATTRIBUTE;\nWGPU_EXPORT WGPUPipelineLayout wgpuDeviceCreatePipelineLayout(WGPUDevice device, WGPUPipelineLayoutDescriptor const * descriptor) WGPU_FUNCTION_ATTRIBUTE;\nWGPU_EXPORT WGPUQuerySet wgpuDeviceCreateQuerySet(WGPUDevice device, WGPUQuerySetDescriptor const * descriptor) WGPU_FUNCTION_ATTRIBUTE;\nWGPU_EXPORT WGPURenderBundleEncoder wgpuDeviceCreateRenderBundleEncoder(WGPUDevice device, WGPURenderBundleEncoderDescriptor const * descriptor) WGPU_FUNCTION_ATTRIBUTE;\nWGPU_EXPORT WGPURenderPipeline wgpuDeviceCreateRenderPipeline(WGPUDevice device, WGPURenderPipelineDescriptor const * descriptor) WGPU_FUNCTION_ATTRIBUTE;\nWGPU_EXPORT void wgpuDeviceCreateRenderPipelineAsync(WGPUDevice device, WGPURenderPipelineDescriptor const * descriptor, WGPUCreateRenderPipelineAsyncCallback callback, void * userdata) WGPU_FUNCTION_ATTRIBUTE;\nWGPU_EXPORT WGPUSampler wgpuDeviceCreateSampler(WGPUDevice device, WGPU_NULLABLE WGPUSamplerDescriptor const * descriptor) WGPU_FUNCTION_ATTRIBUTE;\nWGPU_EXPORT WGPUShaderModule wgpuDeviceCreateShaderModule(WGPUDevice device, WGPUShaderModuleDescriptor const * descriptor) WGPU_FUNCTION_ATTRIBUTE;\nWGPU_EXPORT WGPUSwapChain wgpuDeviceCreateSwapChain(WGPUDevice device, WGPUSurface surface, WGPUSwapChainDescriptor const * descriptor) WGPU_FUNCTION_ATTRIBUTE;\nWGPU_EXPORT WGPUTexture wgpuDeviceCreateTexture(WGPUDevice device, WGPUTextureDescriptor const * descriptor) WGPU_FUNCTION_ATTRIBUTE;\nWGPU_EXPORT void wgpuDeviceDestroy(WGPUDevice device) WGPU_FUNCTION_ATTRIBUTE;\nWGPU_EXPORT size_t wgpuDeviceEnumerateFeatures(WGPUDevice device, WGPUFeatureName * features) WGPU_FUNCTION_ATTRIBUTE;\nWGPU_EXPORT bool wgpuDeviceGetLimits(WGPUDevice device, WGPUSupportedLimits * limits) WGPU_FUNCTION_ATTRIBUTE;\nWGPU_EXPORT WGPUQueue wgpuDeviceGetQueue(WGPUDevice device) WGPU_FUNCTION_ATTRIBUTE;\nWGPU_EXPORT bool wgpuDeviceHasFeature(WGPUDevice device, WGPUFeatureName feature) WGPU_FUNCTION_ATTRIBUTE;\nWGPU_EXPORT void wgpuDevicePopErrorScope(WGPUDevice device, WGPUErrorCallback callback, void * userdata) WGPU_FUNCTION_ATTRIBUTE;\nWGPU_EXPORT void wgpuDevicePushErrorScope(WGPUDevice device, WGPUErrorFilter filter) WGPU_FUNCTION_ATTRIBUTE;\nWGPU_EXPORT void wgpuDeviceSetLabel(WGPUDevice device, char const * label) WGPU_FUNCTION_ATTRIBUTE;\nWGPU_EXPORT void wgpuDeviceSetUncapturedErrorCallback(WGPUDevice device, WGPUErrorCallback callback, void * userdata) WGPU_FUNCTION_ATTRIBUTE;\nWGPU_EXPORT void wgpuDeviceReference(WGPUDevice device) WGPU_FUNCTION_ATTRIBUTE;\nWGPU_EXPORT void wgpuDeviceRelease(WGPUDevice device) WGPU_FUNCTION_ATTRIBUTE;\n\n// Methods of Instance\nWGPU_EXPORT WGPUSurface wgpuInstanceCreateSurface(WGPUInstance instance, WGPUSurfaceDescriptor const * descriptor) WGPU_FUNCTION_ATTRIBUTE;\nWGPU_EXPORT void wgpuInstanceProcessEvents(WGPUInstance instance) WGPU_FUNCTION_ATTRIBUTE;\nWGPU_EXPORT void wgpuInstanceRequestAdapter(WGPUInstance instance, WGPU_NULLABLE WGPURequestAdapterOptions const * options, WGPURequestAdapterCallback callback, void * userdata) WGPU_FUNCTION_ATTRIBUTE;\nWGPU_EXPORT void wgpuInstanceReference(WGPUInstance instance) WGPU_FUNCTION_ATTRIBUTE;\nWGPU_EXPORT void wgpuInstanceRelease(WGPUInstance instance) WGPU_FUNCTION_ATTRIBUTE;\n\n// Methods of PipelineLayout\nWGPU_EXPORT void wgpuPipelineLayoutSetLabel(WGPUPipelineLayout pipelineLayout, char const * label) WGPU_FUNCTION_ATTRIBUTE;\nWGPU_EXPORT void wgpuPipelineLayoutReference(WGPUPipelineLayout pipelineLayout) WGPU_FUNCTION_ATTRIBUTE;\nWGPU_EXPORT void wgpuPipelineLayoutRelease(WGPUPipelineLayout pipelineLayout) WGPU_FUNCTION_ATTRIBUTE;\n\n// Methods of QuerySet\nWGPU_EXPORT void wgpuQuerySetDestroy(WGPUQuerySet querySet) WGPU_FUNCTION_ATTRIBUTE;\nWGPU_EXPORT uint32_t wgpuQuerySetGetCount(WGPUQuerySet querySet) WGPU_FUNCTION_ATTRIBUTE;\nWGPU_EXPORT WGPUQueryType wgpuQuerySetGetType(WGPUQuerySet querySet) WGPU_FUNCTION_ATTRIBUTE;\nWGPU_EXPORT void wgpuQuerySetSetLabel(WGPUQuerySet querySet, char const * label) WGPU_FUNCTION_ATTRIBUTE;\nWGPU_EXPORT void wgpuQuerySetReference(WGPUQuerySet querySet) WGPU_FUNCTION_ATTRIBUTE;\nWGPU_EXPORT void wgpuQuerySetRelease(WGPUQuerySet querySet) WGPU_FUNCTION_ATTRIBUTE;\n\n// Methods of Queue\nWGPU_EXPORT void wgpuQueueOnSubmittedWorkDone(WGPUQueue queue, uint64_t signalValue, WGPUQueueWorkDoneCallback callback, void * userdata) WGPU_FUNCTION_ATTRIBUTE;\nWGPU_EXPORT void wgpuQueueSetLabel(WGPUQueue queue, char const * label) WGPU_FUNCTION_ATTRIBUTE;\nWGPU_EXPORT void wgpuQueueSubmit(WGPUQueue queue, size_t commandCount, WGPUCommandBuffer const * commands) WGPU_FUNCTION_ATTRIBUTE;\nWGPU_EXPORT void wgpuQueueWriteBuffer(WGPUQueue queue, WGPUBuffer buffer, uint64_t bufferOffset, void const * data, size_t size) WGPU_FUNCTION_ATTRIBUTE;\nWGPU_EXPORT void wgpuQueueWriteTexture(WGPUQueue queue, WGPUImageCopyTexture const * destination, void const * data, size_t dataSize, WGPUTextureDataLayout const * dataLayout, WGPUExtent3D const * writeSize) WGPU_FUNCTION_ATTRIBUTE;\nWGPU_EXPORT void wgpuQueueReference(WGPUQueue queue) WGPU_FUNCTION_ATTRIBUTE;\nWGPU_EXPORT void wgpuQueueRelease(WGPUQueue queue) WGPU_FUNCTION_ATTRIBUTE;\n\n// Methods of RenderBundle\nWGPU_EXPORT void wgpuRenderBundleSetLabel(WGPURenderBundle renderBundle, char const * label) WGPU_FUNCTION_ATTRIBUTE;\nWGPU_EXPORT void wgpuRenderBundleReference(WGPURenderBundle renderBundle) WGPU_FUNCTION_ATTRIBUTE;\nWGPU_EXPORT void wgpuRenderBundleRelease(WGPURenderBundle renderBundle) WGPU_FUNCTION_ATTRIBUTE;\n\n// Methods of RenderBundleEncoder\nWGPU_EXPORT void wgpuRenderBundleEncoderDraw(WGPURenderBundleEncoder renderBundleEncoder, uint32_t vertexCount, uint32_t instanceCount, uint32_t firstVertex, uint32_t firstInstance) WGPU_FUNCTION_ATTRIBUTE;\nWGPU_EXPORT void wgpuRenderBundleEncoderDrawIndexed(WGPURenderBundleEncoder renderBundleEncoder, uint32_t indexCount, uint32_t instanceCount, uint32_t firstIndex, int32_t baseVertex, uint32_t firstInstance) WGPU_FUNCTION_ATTRIBUTE;\nWGPU_EXPORT void wgpuRenderBundleEncoderDrawIndexedIndirect(WGPURenderBundleEncoder renderBundleEncoder, WGPUBuffer indirectBuffer, uint64_t indirectOffset) WGPU_FUNCTION_ATTRIBUTE;\nWGPU_EXPORT void wgpuRenderBundleEncoderDrawIndirect(WGPURenderBundleEncoder renderBundleEncoder, WGPUBuffer indirectBuffer, uint64_t indirectOffset) WGPU_FUNCTION_ATTRIBUTE;\nWGPU_EXPORT WGPURenderBundle wgpuRenderBundleEncoderFinish(WGPURenderBundleEncoder renderBundleEncoder, WGPU_NULLABLE WGPURenderBundleDescriptor const * descriptor) WGPU_FUNCTION_ATTRIBUTE;\nWGPU_EXPORT void wgpuRenderBundleEncoderInsertDebugMarker(WGPURenderBundleEncoder renderBundleEncoder, char const * markerLabel) WGPU_FUNCTION_ATTRIBUTE;\nWGPU_EXPORT void wgpuRenderBundleEncoderPopDebugGroup(WGPURenderBundleEncoder renderBundleEncoder) WGPU_FUNCTION_ATTRIBUTE;\nWGPU_EXPORT void wgpuRenderBundleEncoderPushDebugGroup(WGPURenderBundleEncoder renderBundleEncoder, char const * groupLabel) WGPU_FUNCTION_ATTRIBUTE;\nWGPU_EXPORT void wgpuRenderBundleEncoderSetBindGroup(WGPURenderBundleEncoder renderBundleEncoder, uint32_t groupIndex, WGPU_NULLABLE WGPUBindGroup group, size_t dynamicOffsetCount, uint32_t const * dynamicOffsets) WGPU_FUNCTION_ATTRIBUTE;\nWGPU_EXPORT void wgpuRenderBundleEncoderSetIndexBuffer(WGPURenderBundleEncoder renderBundleEncoder, WGPUBuffer buffer, WGPUIndexFormat format, uint64_t offset, uint64_t size) WGPU_FUNCTION_ATTRIBUTE;\nWGPU_EXPORT void wgpuRenderBundleEncoderSetLabel(WGPURenderBundleEncoder renderBundleEncoder, char const * label) WGPU_FUNCTION_ATTRIBUTE;\nWGPU_EXPORT void wgpuRenderBundleEncoderSetPipeline(WGPURenderBundleEncoder renderBundleEncoder, WGPURenderPipeline pipeline) WGPU_FUNCTION_ATTRIBUTE;\nWGPU_EXPORT void wgpuRenderBundleEncoderSetVertexBuffer(WGPURenderBundleEncoder renderBundleEncoder, uint32_t slot, WGPU_NULLABLE WGPUBuffer buffer, uint64_t offset, uint64_t size) WGPU_FUNCTION_ATTRIBUTE;\nWGPU_EXPORT void wgpuRenderBundleEncoderReference(WGPURenderBundleEncoder renderBundleEncoder) WGPU_FUNCTION_ATTRIBUTE;\nWGPU_EXPORT void wgpuRenderBundleEncoderRelease(WGPURenderBundleEncoder renderBundleEncoder) WGPU_FUNCTION_ATTRIBUTE;\n\n// Methods of RenderPassEncoder\nWGPU_EXPORT void wgpuRenderPassEncoderBeginOcclusionQuery(WGPURenderPassEncoder renderPassEncoder, uint32_t queryIndex) WGPU_FUNCTION_ATTRIBUTE;\nWGPU_EXPORT void wgpuRenderPassEncoderBeginPipelineStatisticsQuery(WGPURenderPassEncoder renderPassEncoder, WGPUQuerySet querySet, uint32_t queryIndex) WGPU_FUNCTION_ATTRIBUTE;\nWGPU_EXPORT void wgpuRenderPassEncoderDraw(WGPURenderPassEncoder renderPassEncoder, uint32_t vertexCount, uint32_t instanceCount, uint32_t firstVertex, uint32_t firstInstance) WGPU_FUNCTION_ATTRIBUTE;\nWGPU_EXPORT void wgpuRenderPassEncoderDrawIndexed(WGPURenderPassEncoder renderPassEncoder, uint32_t indexCount, uint32_t instanceCount, uint32_t firstIndex, int32_t baseVertex, uint32_t firstInstance) WGPU_FUNCTION_ATTRIBUTE;\nWGPU_EXPORT void wgpuRenderPassEncoderDrawIndexedIndirect(WGPURenderPassEncoder renderPassEncoder, WGPUBuffer indirectBuffer, uint64_t indirectOffset) WGPU_FUNCTION_ATTRIBUTE;\nWGPU_EXPORT void wgpuRenderPassEncoderDrawIndirect(WGPURenderPassEncoder renderPassEncoder, WGPUBuffer indirectBuffer, uint64_t indirectOffset) WGPU_FUNCTION_ATTRIBUTE;\nWGPU_EXPORT void wgpuRenderPassEncoderEnd(WGPURenderPassEncoder renderPassEncoder) WGPU_FUNCTION_ATTRIBUTE;\nWGPU_EXPORT void wgpuRenderPassEncoderEndOcclusionQuery(WGPURenderPassEncoder renderPassEncoder) WGPU_FUNCTION_ATTRIBUTE;\nWGPU_EXPORT void wgpuRenderPassEncoderEndPipelineStatisticsQuery(WGPURenderPassEncoder renderPassEncoder) WGPU_FUNCTION_ATTRIBUTE;\nWGPU_EXPORT void wgpuRenderPassEncoderExecuteBundles(WGPURenderPassEncoder renderPassEncoder, size_t bundleCount, WGPURenderBundle const * bundles) WGPU_FUNCTION_ATTRIBUTE;\nWGPU_EXPORT void wgpuRenderPassEncoderInsertDebugMarker(WGPURenderPassEncoder renderPassEncoder, char const * markerLabel) WGPU_FUNCTION_ATTRIBUTE;\nWGPU_EXPORT void wgpuRenderPassEncoderPopDebugGroup(WGPURenderPassEncoder renderPassEncoder) WGPU_FUNCTION_ATTRIBUTE;\nWGPU_EXPORT void wgpuRenderPassEncoderPushDebugGroup(WGPURenderPassEncoder renderPassEncoder, char const * groupLabel) WGPU_FUNCTION_ATTRIBUTE;\nWGPU_EXPORT void wgpuRenderPassEncoderSetBindGroup(WGPURenderPassEncoder renderPassEncoder, uint32_t groupIndex, WGPU_NULLABLE WGPUBindGroup group, size_t dynamicOffsetCount, uint32_t const * dynamicOffsets) WGPU_FUNCTION_ATTRIBUTE;\nWGPU_EXPORT void wgpuRenderPassEncoderSetBlendConstant(WGPURenderPassEncoder renderPassEncoder, WGPUColor const * color) WGPU_FUNCTION_ATTRIBUTE;\nWGPU_EXPORT void wgpuRenderPassEncoderSetIndexBuffer(WGPURenderPassEncoder renderPassEncoder, WGPUBuffer buffer, WGPUIndexFormat format, uint64_t offset, uint64_t size) WGPU_FUNCTION_ATTRIBUTE;\nWGPU_EXPORT void wgpuRenderPassEncoderSetLabel(WGPURenderPassEncoder renderPassEncoder, char const * label) WGPU_FUNCTION_ATTRIBUTE;\nWGPU_EXPORT void wgpuRenderPassEncoderSetPipeline(WGPURenderPassEncoder renderPassEncoder, WGPURenderPipeline pipeline) WGPU_FUNCTION_ATTRIBUTE;\nWGPU_EXPORT void wgpuRenderPassEncoderSetScissorRect(WGPURenderPassEncoder renderPassEncoder, uint32_t x, uint32_t y, uint32_t width, uint32_t height) WGPU_FUNCTION_ATTRIBUTE;\nWGPU_EXPORT void wgpuRenderPassEncoderSetStencilReference(WGPURenderPassEncoder renderPassEncoder, uint32_t reference) WGPU_FUNCTION_ATTRIBUTE;\nWGPU_EXPORT void wgpuRenderPassEncoderSetVertexBuffer(WGPURenderPassEncoder renderPassEncoder, uint32_t slot, WGPU_NULLABLE WGPUBuffer buffer, uint64_t offset, uint64_t size) WGPU_FUNCTION_ATTRIBUTE;\nWGPU_EXPORT void wgpuRenderPassEncoderSetViewport(WGPURenderPassEncoder renderPassEncoder, float x, float y, float width, float height, float minDepth, float maxDepth) WGPU_FUNCTION_ATTRIBUTE;\nWGPU_EXPORT void wgpuRenderPassEncoderWriteTimestamp(WGPURenderPassEncoder renderPassEncoder, WGPUQuerySet querySet, uint32_t queryIndex) WGPU_FUNCTION_ATTRIBUTE;\nWGPU_EXPORT void wgpuRenderPassEncoderReference(WGPURenderPassEncoder renderPassEncoder) WGPU_FUNCTION_ATTRIBUTE;\nWGPU_EXPORT void wgpuRenderPassEncoderRelease(WGPURenderPassEncoder renderPassEncoder) WGPU_FUNCTION_ATTRIBUTE;\n\n// Methods of RenderPipeline\nWGPU_EXPORT WGPUBindGroupLayout wgpuRenderPipelineGetBindGroupLayout(WGPURenderPipeline renderPipeline, uint32_t groupIndex) WGPU_FUNCTION_ATTRIBUTE;\nWGPU_EXPORT void wgpuRenderPipelineSetLabel(WGPURenderPipeline renderPipeline, char const * label) WGPU_FUNCTION_ATTRIBUTE;\nWGPU_EXPORT void wgpuRenderPipelineReference(WGPURenderPipeline renderPipeline) WGPU_FUNCTION_ATTRIBUTE;\nWGPU_EXPORT void wgpuRenderPipelineRelease(WGPURenderPipeline renderPipeline) WGPU_FUNCTION_ATTRIBUTE;\n\n// Methods of Sampler\nWGPU_EXPORT void wgpuSamplerSetLabel(WGPUSampler sampler, char const * label) WGPU_FUNCTION_ATTRIBUTE;\nWGPU_EXPORT void wgpuSamplerReference(WGPUSampler sampler) WGPU_FUNCTION_ATTRIBUTE;\nWGPU_EXPORT void wgpuSamplerRelease(WGPUSampler sampler) WGPU_FUNCTION_ATTRIBUTE;\n\n// Methods of ShaderModule\nWGPU_EXPORT void wgpuShaderModuleGetCompilationInfo(WGPUShaderModule shaderModule, WGPUCompilationInfoCallback callback, void * userdata) WGPU_FUNCTION_ATTRIBUTE;\nWGPU_EXPORT void wgpuShaderModuleSetLabel(WGPUShaderModule shaderModule, char const * label) WGPU_FUNCTION_ATTRIBUTE;\nWGPU_EXPORT void wgpuShaderModuleReference(WGPUShaderModule shaderModule) WGPU_FUNCTION_ATTRIBUTE;\nWGPU_EXPORT void wgpuShaderModuleRelease(WGPUShaderModule shaderModule) WGPU_FUNCTION_ATTRIBUTE;\n\n// Methods of Surface\nWGPU_EXPORT WGPUTextureFormat wgpuSurfaceGetPreferredFormat(WGPUSurface surface, WGPUAdapter adapter) WGPU_FUNCTION_ATTRIBUTE;\nWGPU_EXPORT void wgpuSurfaceReference(WGPUSurface surface) WGPU_FUNCTION_ATTRIBUTE;\nWGPU_EXPORT void wgpuSurfaceRelease(WGPUSurface surface) WGPU_FUNCTION_ATTRIBUTE;\n\n// Methods of SwapChain\nWGPU_EXPORT WGPUTextureView wgpuSwapChainGetCurrentTextureView(WGPUSwapChain swapChain) WGPU_FUNCTION_ATTRIBUTE;\nWGPU_EXPORT void wgpuSwapChainPresent(WGPUSwapChain swapChain) WGPU_FUNCTION_ATTRIBUTE;\nWGPU_EXPORT void wgpuSwapChainReference(WGPUSwapChain swapChain) WGPU_FUNCTION_ATTRIBUTE;\nWGPU_EXPORT void wgpuSwapChainRelease(WGPUSwapChain swapChain) WGPU_FUNCTION_ATTRIBUTE;\n\n// Methods of Texture\nWGPU_EXPORT WGPUTextureView wgpuTextureCreateView(WGPUTexture texture, WGPU_NULLABLE WGPUTextureViewDescriptor const * descriptor) WGPU_FUNCTION_ATTRIBUTE;\nWGPU_EXPORT void wgpuTextureDestroy(WGPUTexture texture) WGPU_FUNCTION_ATTRIBUTE;\nWGPU_EXPORT uint32_t wgpuTextureGetDepthOrArrayLayers(WGPUTexture texture) WGPU_FUNCTION_ATTRIBUTE;\nWGPU_EXPORT WGPUTextureDimension wgpuTextureGetDimension(WGPUTexture texture) WGPU_FUNCTION_ATTRIBUTE;\nWGPU_EXPORT WGPUTextureFormat wgpuTextureGetFormat(WGPUTexture texture) WGPU_FUNCTION_ATTRIBUTE;\nWGPU_EXPORT uint32_t wgpuTextureGetHeight(WGPUTexture texture) WGPU_FUNCTION_ATTRIBUTE;\nWGPU_EXPORT uint32_t wgpuTextureGetMipLevelCount(WGPUTexture texture) WGPU_FUNCTION_ATTRIBUTE;\nWGPU_EXPORT uint32_t wgpuTextureGetSampleCount(WGPUTexture texture) WGPU_FUNCTION_ATTRIBUTE;\nWGPU_EXPORT WGPUTextureUsageFlags wgpuTextureGetUsage(WGPUTexture texture) WGPU_FUNCTION_ATTRIBUTE;\nWGPU_EXPORT uint32_t wgpuTextureGetWidth(WGPUTexture texture) WGPU_FUNCTION_ATTRIBUTE;\nWGPU_EXPORT void wgpuTextureSetLabel(WGPUTexture texture, char const * label) WGPU_FUNCTION_ATTRIBUTE;\nWGPU_EXPORT void wgpuTextureReference(WGPUTexture texture) WGPU_FUNCTION_ATTRIBUTE;\nWGPU_EXPORT void wgpuTextureRelease(WGPUTexture texture) WGPU_FUNCTION_ATTRIBUTE;\n\n// Methods of TextureView\nWGPU_EXPORT void wgpuTextureViewSetLabel(WGPUTextureView textureView, char const * label) WGPU_FUNCTION_ATTRIBUTE;\nWGPU_EXPORT void wgpuTextureViewReference(WGPUTextureView textureView) WGPU_FUNCTION_ATTRIBUTE;\nWGPU_EXPORT void wgpuTextureViewRelease(WGPUTextureView textureView) WGPU_FUNCTION_ATTRIBUTE;\n\n#endif  // !defined(WGPU_SKIP_DECLARATIONS)\n\n#ifdef __cplusplus\n} // extern \"C\"\n#endif\n\n#endif // WEBGPU_H_\n", "emscripten-bits/webgpu_cpp.h": "#ifndef WEBGPU_CPP_H_\n#define WEBGPU_CPP_H_\n\n#include \"dawn/webgpu.h\"\n#include \"dawn/webgpu_cpp_chained_struct.h\"\n#include \"dawn/EnumClassBitmasks.h\"\n#include <cmath>\n#include <cstddef>\n#include <cstdint>\n\nnamespace wgpu {\n\n    static constexpr uint32_t kArrayLayerCountUndefined = WGPU_ARRAY_LAYER_COUNT_UNDEFINED;\n    static constexpr uint32_t kCopyStrideUndefined = WGPU_COPY_STRIDE_UNDEFINED;\n    static constexpr uint32_t kLimitU32Undefined = WGPU_LIMIT_U32_UNDEFINED;\n    static constexpr uint64_t kLimitU64Undefined = WGPU_LIMIT_U64_UNDEFINED;\n    static constexpr uint32_t kMipLevelCountUndefined = WGPU_MIP_LEVEL_COUNT_UNDEFINED;\n    static constexpr size_t kWholeMapSize = WGPU_WHOLE_MAP_SIZE;\n    static constexpr uint64_t kWholeSize = WGPU_WHOLE_SIZE;\n\n    enum class AdapterType : uint32_t {\n        DiscreteGPU = 0x00000000,\n        IntegratedGPU = 0x00000001,\n        CPU = 0x00000002,\n        Unknown = 0x00000003,\n    };\n\n    enum class AddressMode : uint32_t {\n        Repeat = 0x00000000,\n        MirrorRepeat = 0x00000001,\n        ClampToEdge = 0x00000002,\n    };\n\n    enum class BackendType : uint32_t {\n        Undefined = 0x00000000,\n        Null = 0x00000001,\n        WebGPU = 0x00000002,\n        D3D11 = 0x00000003,\n        D3D12 = 0x00000004,\n        Metal = 0x00000005,\n        Vulkan = 0x00000006,\n        OpenGL = 0x00000007,\n        OpenGLES = 0x00000008,\n    };\n\n    enum class BlendFactor : uint32_t {\n        Zero = 0x00000000,\n        One = 0x00000001,\n        Src = 0x00000002,\n        OneMinusSrc = 0x00000003,\n        SrcAlpha = 0x00000004,\n        OneMinusSrcAlpha = 0x00000005,\n        Dst = 0x00000006,\n        OneMinusDst = 0x00000007,\n        DstAlpha = 0x00000008,\n        OneMinusDstAlpha = 0x00000009,\n        SrcAlphaSaturated = 0x0000000A,\n        Constant = 0x0000000B,\n        OneMinusConstant = 0x0000000C,\n    };\n\n    enum class BlendOperation : uint32_t {\n        Add = 0x00000000,\n        Subtract = 0x00000001,\n        ReverseSubtract = 0x00000002,\n        Min = 0x00000003,\n        Max = 0x00000004,\n    };\n\n    enum class BufferBindingType : uint32_t {\n        Undefined = 0x00000000,\n        Uniform = 0x00000001,\n        Storage = 0x00000002,\n        ReadOnlyStorage = 0x00000003,\n    };\n\n    enum class BufferMapAsyncStatus : uint32_t {\n        Success = 0x00000000,\n        ValidationError = 0x00000001,\n        Unknown = 0x00000002,\n        DeviceLost = 0x00000003,\n        DestroyedBeforeCallback = 0x00000004,\n        UnmappedBeforeCallback = 0x00000005,\n        MappingAlreadyPending = 0x00000006,\n        OffsetOutOfRange = 0x00000007,\n        SizeOutOfRange = 0x00000008,\n    };\n\n    enum class BufferMapState : uint32_t {\n        Unmapped = 0x00000000,\n        Pending = 0x00000001,\n        Mapped = 0x00000002,\n    };\n\n    enum class CompareFunction : uint32_t {\n        Undefined = 0x00000000,\n        Never = 0x00000001,\n        Less = 0x00000002,\n        LessEqual = 0x00000003,\n        Greater = 0x00000004,\n        GreaterEqual = 0x00000005,\n        Equal = 0x00000006,\n        NotEqual = 0x00000007,\n        Always = 0x00000008,\n    };\n\n    enum class CompilationInfoRequestStatus : uint32_t {\n        Success = 0x00000000,\n        Error = 0x00000001,\n        DeviceLost = 0x00000002,\n        Unknown = 0x00000003,\n    };\n\n    enum class CompilationMessageType : uint32_t {\n        Error = 0x00000000,\n        Warning = 0x00000001,\n        Info = 0x00000002,\n    };\n\n    enum class ComputePassTimestampLocation : uint32_t {\n        Beginning = 0x00000000,\n        End = 0x00000001,\n    };\n\n    enum class CreatePipelineAsyncStatus : uint32_t {\n        Success = 0x00000000,\n        ValidationError = 0x00000001,\n        InternalError = 0x00000002,\n        DeviceLost = 0x00000003,\n        DeviceDestroyed = 0x00000004,\n        Unknown = 0x00000005,\n    };\n\n    enum class CullMode : uint32_t {\n        None = 0x00000000,\n        Front = 0x00000001,\n        Back = 0x00000002,\n    };\n\n    enum class DeviceLostReason : uint32_t {\n        Undefined = 0x00000000,\n        Destroyed = 0x00000001,\n    };\n\n    enum class ErrorFilter : uint32_t {\n        Validation = 0x00000000,\n        OutOfMemory = 0x00000001,\n        Internal = 0x00000002,\n    };\n\n    enum class ErrorType : uint32_t {\n        NoError = 0x00000000,\n        Validation = 0x00000001,\n        OutOfMemory = 0x00000002,\n        Internal = 0x00000003,\n        Unknown = 0x00000004,\n        DeviceLost = 0x00000005,\n    };\n\n    enum class FeatureName : uint32_t {\n        Undefined = 0x00000000,\n        DepthClipControl = 0x00000001,\n        Depth32FloatStencil8 = 0x00000002,\n        TimestampQuery = 0x00000003,\n        PipelineStatisticsQuery = 0x00000004,\n        TextureCompressionBC = 0x00000005,\n        TextureCompressionETC2 = 0x00000006,\n        TextureCompressionASTC = 0x00000007,\n        IndirectFirstInstance = 0x00000008,\n        ShaderF16 = 0x00000009,\n        RG11B10UfloatRenderable = 0x0000000A,\n        BGRA8UnormStorage = 0x0000000B,\n        Float32Filterable = 0x0000000C,\n    };\n\n    enum class FilterMode : uint32_t {\n        Nearest = 0x00000000,\n        Linear = 0x00000001,\n    };\n\n    enum class FrontFace : uint32_t {\n        CCW = 0x00000000,\n        CW = 0x00000001,\n    };\n\n    enum class IndexFormat : uint32_t {\n        Undefined = 0x00000000,\n        Uint16 = 0x00000001,\n        Uint32 = 0x00000002,\n    };\n\n    enum class LoadOp : uint32_t {\n        Undefined = 0x00000000,\n        Clear = 0x00000001,\n        Load = 0x00000002,\n    };\n\n    enum class MipmapFilterMode : uint32_t {\n        Nearest = 0x00000000,\n        Linear = 0x00000001,\n    };\n\n    enum class PipelineStatisticName : uint32_t {\n        VertexShaderInvocations = 0x00000000,\n        ClipperInvocations = 0x00000001,\n        ClipperPrimitivesOut = 0x00000002,\n        FragmentShaderInvocations = 0x00000003,\n        ComputeShaderInvocations = 0x00000004,\n    };\n\n    enum class PowerPreference : uint32_t {\n        Undefined = 0x00000000,\n        LowPower = 0x00000001,\n        HighPerformance = 0x00000002,\n    };\n\n    enum class PresentMode : uint32_t {\n        Immediate = 0x00000000,\n        Mailbox = 0x00000001,\n        Fifo = 0x00000002,\n    };\n\n    enum class PrimitiveTopology : uint32_t {\n        PointList = 0x00000000,\n        LineList = 0x00000001,\n        LineStrip = 0x00000002,\n        TriangleList = 0x00000003,\n        TriangleStrip = 0x00000004,\n    };\n\n    enum class QueryType : uint32_t {\n        Occlusion = 0x00000000,\n        PipelineStatistics = 0x00000001,\n        Timestamp = 0x00000002,\n    };\n\n    enum class QueueWorkDoneStatus : uint32_t {\n        Success = 0x00000000,\n        Error = 0x00000001,\n        Unknown = 0x00000002,\n        DeviceLost = 0x00000003,\n    };\n\n    enum class RenderPassTimestampLocation : uint32_t {\n        Beginning = 0x00000000,\n        End = 0x00000001,\n    };\n\n    enum class RequestAdapterStatus : uint32_t {\n        Success = 0x00000000,\n        Unavailable = 0x00000001,\n        Error = 0x00000002,\n        Unknown = 0x00000003,\n    };\n\n    enum class RequestDeviceStatus : uint32_t {\n        Success = 0x00000000,\n        Error = 0x00000001,\n        Unknown = 0x00000002,\n    };\n\n    enum class SType : uint32_t {\n        Invalid = 0x00000000,\n        SurfaceDescriptorFromCanvasHTMLSelector = 0x00000004,\n        ShaderModuleSPIRVDescriptor = 0x00000005,\n        ShaderModuleWGSLDescriptor = 0x00000006,\n        PrimitiveDepthClipControl = 0x00000007,\n        RenderPassDescriptorMaxDrawCount = 0x0000000F,\n    };\n\n    enum class SamplerBindingType : uint32_t {\n        Undefined = 0x00000000,\n        Filtering = 0x00000001,\n        NonFiltering = 0x00000002,\n        Comparison = 0x00000003,\n    };\n\n    enum class StencilOperation : uint32_t {\n        Keep = 0x00000000,\n        Zero = 0x00000001,\n        Replace = 0x00000002,\n        Invert = 0x00000003,\n        IncrementClamp = 0x00000004,\n        DecrementClamp = 0x00000005,\n        IncrementWrap = 0x00000006,\n        DecrementWrap = 0x00000007,\n    };\n\n    enum class StorageTextureAccess : uint32_t {\n        Undefined = 0x00000000,\n        WriteOnly = 0x00000001,\n    };\n\n    enum class StoreOp : uint32_t {\n        Undefined = 0x00000000,\n        Store = 0x00000001,\n        Discard = 0x00000002,\n    };\n\n    enum class TextureAspect : uint32_t {\n        All = 0x00000000,\n        StencilOnly = 0x00000001,\n        DepthOnly = 0x00000002,\n    };\n\n    enum class TextureDimension : uint32_t {\n        e1D = 0x00000000,\n        e2D = 0x00000001,\n        e3D = 0x00000002,\n    };\n\n    enum class TextureFormat : uint32_t {\n        Undefined = 0x00000000,\n        R8Unorm = 0x00000001,\n        R8Snorm = 0x00000002,\n        R8Uint = 0x00000003,\n        R8Sint = 0x00000004,\n        R16Uint = 0x00000005,\n        R16Sint = 0x00000006,\n        R16Float = 0x00000007,\n        RG8Unorm = 0x00000008,\n        RG8Snorm = 0x00000009,\n        RG8Uint = 0x0000000A,\n        RG8Sint = 0x0000000B,\n        R32Float = 0x0000000C,\n        R32Uint = 0x0000000D,\n        R32Sint = 0x0000000E,\n        RG16Uint = 0x0000000F,\n        RG16Sint = 0x00000010,\n        RG16Float = 0x00000011,\n        RGBA8Unorm = 0x00000012,\n        RGBA8UnormSrgb = 0x00000013,\n        RGBA8Snorm = 0x00000014,\n        RGBA8Uint = 0x00000015,\n        RGBA8Sint = 0x00000016,\n        BGRA8Unorm = 0x00000017,\n        BGRA8UnormSrgb = 0x00000018,\n        RGB10A2Unorm = 0x00000019,\n        RG11B10Ufloat = 0x0000001A,\n        RGB9E5Ufloat = 0x0000001B,\n        RG32Float = 0x0000001C,\n        RG32Uint = 0x0000001D,\n        RG32Sint = 0x0000001E,\n        RGBA16Uint = 0x0000001F,\n        RGBA16Sint = 0x00000020,\n        RGBA16Float = 0x00000021,\n        RGBA32Float = 0x00000022,\n        RGBA32Uint = 0x00000023,\n        RGBA32Sint = 0x00000024,\n        Stencil8 = 0x00000025,\n        Depth16Unorm = 0x00000026,\n        Depth24Plus = 0x00000027,\n        Depth24PlusStencil8 = 0x00000028,\n        Depth32Float = 0x00000029,\n        Depth32FloatStencil8 = 0x0000002A,\n        BC1RGBAUnorm = 0x0000002B,\n        BC1RGBAUnormSrgb = 0x0000002C,\n        BC2RGBAUnorm = 0x0000002D,\n        BC2RGBAUnormSrgb = 0x0000002E,\n        BC3RGBAUnorm = 0x0000002F,\n        BC3RGBAUnormSrgb = 0x00000030,\n        BC4RUnorm = 0x00000031,\n        BC4RSnorm = 0x00000032,\n        BC5RGUnorm = 0x00000033,\n        BC5RGSnorm = 0x00000034,\n        BC6HRGBUfloat = 0x00000035,\n        BC6HRGBFloat = 0x00000036,\n        BC7RGBAUnorm = 0x00000037,\n        BC7RGBAUnormSrgb = 0x00000038,\n        ETC2RGB8Unorm = 0x00000039,\n        ETC2RGB8UnormSrgb = 0x0000003A,\n        ETC2RGB8A1Unorm = 0x0000003B,\n        ETC2RGB8A1UnormSrgb = 0x0000003C,\n        ETC2RGBA8Unorm = 0x0000003D,\n        ETC2RGBA8UnormSrgb = 0x0000003E,\n        EACR11Unorm = 0x0000003F,\n        EACR11Snorm = 0x00000040,\n        EACRG11Unorm = 0x00000041,\n        EACRG11Snorm = 0x00000042,\n        ASTC4x4Unorm = 0x00000043,\n        ASTC4x4UnormSrgb = 0x00000044,\n        ASTC5x4Unorm = 0x00000045,\n        ASTC5x4UnormSrgb = 0x00000046,\n        ASTC5x5Unorm = 0x00000047,\n        ASTC5x5UnormSrgb = 0x00000048,\n        ASTC6x5Unorm = 0x00000049,\n        ASTC6x5UnormSrgb = 0x0000004A,\n        ASTC6x6Unorm = 0x0000004B,\n        ASTC6x6UnormSrgb = 0x0000004C,\n        ASTC8x5Unorm = 0x0000004D,\n        ASTC8x5UnormSrgb = 0x0000004E,\n        ASTC8x6Unorm = 0x0000004F,\n        ASTC8x6UnormSrgb = 0x00000050,\n        ASTC8x8Unorm = 0x00000051,\n        ASTC8x8UnormSrgb = 0x00000052,\n        ASTC10x5Unorm = 0x00000053,\n        ASTC10x5UnormSrgb = 0x00000054,\n        ASTC10x6Unorm = 0x00000055,\n        ASTC10x6UnormSrgb = 0x00000056,\n        ASTC10x8Unorm = 0x00000057,\n        ASTC10x8UnormSrgb = 0x00000058,\n        ASTC10x10Unorm = 0x00000059,\n        ASTC10x10UnormSrgb = 0x0000005A,\n        ASTC12x10Unorm = 0x0000005B,\n        ASTC12x10UnormSrgb = 0x0000005C,\n        ASTC12x12Unorm = 0x0000005D,\n        ASTC12x12UnormSrgb = 0x0000005E,\n    };\n\n    enum class TextureSampleType : uint32_t {\n        Undefined = 0x00000000,\n        Float = 0x00000001,\n        UnfilterableFloat = 0x00000002,\n        Depth = 0x00000003,\n        Sint = 0x00000004,\n        Uint = 0x00000005,\n    };\n\n    enum class TextureViewDimension : uint32_t {\n        Undefined = 0x00000000,\n        e1D = 0x00000001,\n        e2D = 0x00000002,\n        e2DArray = 0x00000003,\n        Cube = 0x00000004,\n        CubeArray = 0x00000005,\n        e3D = 0x00000006,\n    };\n\n    enum class VertexFormat : uint32_t {\n        Undefined = 0x00000000,\n        Uint8x2 = 0x00000001,\n        Uint8x4 = 0x00000002,\n        Sint8x2 = 0x00000003,\n        Sint8x4 = 0x00000004,\n        Unorm8x2 = 0x00000005,\n        Unorm8x4 = 0x00000006,\n        Snorm8x2 = 0x00000007,\n        Snorm8x4 = 0x00000008,\n        Uint16x2 = 0x00000009,\n        Uint16x4 = 0x0000000A,\n        Sint16x2 = 0x0000000B,\n        Sint16x4 = 0x0000000C,\n        Unorm16x2 = 0x0000000D,\n        Unorm16x4 = 0x0000000E,\n        Snorm16x2 = 0x0000000F,\n        Snorm16x4 = 0x00000010,\n        Float16x2 = 0x00000011,\n        Float16x4 = 0x00000012,\n        Float32 = 0x00000013,\n        Float32x2 = 0x00000014,\n        Float32x3 = 0x00000015,\n        Float32x4 = 0x00000016,\n        Uint32 = 0x00000017,\n        Uint32x2 = 0x00000018,\n        Uint32x3 = 0x00000019,\n        Uint32x4 = 0x0000001A,\n        Sint32 = 0x0000001B,\n        Sint32x2 = 0x0000001C,\n        Sint32x3 = 0x0000001D,\n        Sint32x4 = 0x0000001E,\n    };\n\n    enum class VertexStepMode : uint32_t {\n        Vertex = 0x00000000,\n        Instance = 0x00000001,\n        VertexBufferNotUsed = 0x00000002,\n    };\n\n\n    enum class BufferUsage : uint32_t {\n        None = 0x00000000,\n        MapRead = 0x00000001,\n        MapWrite = 0x00000002,\n        CopySrc = 0x00000004,\n        CopyDst = 0x00000008,\n        Index = 0x00000010,\n        Vertex = 0x00000020,\n        Uniform = 0x00000040,\n        Storage = 0x00000080,\n        Indirect = 0x00000100,\n        QueryResolve = 0x00000200,\n    };\n\n    enum class ColorWriteMask : uint32_t {\n        None = 0x00000000,\n        Red = 0x00000001,\n        Green = 0x00000002,\n        Blue = 0x00000004,\n        Alpha = 0x00000008,\n        All = 0x0000000F,\n    };\n\n    enum class MapMode : uint32_t {\n        None = 0x00000000,\n        Read = 0x00000001,\n        Write = 0x00000002,\n    };\n\n    enum class ShaderStage : uint32_t {\n        None = 0x00000000,\n        Vertex = 0x00000001,\n        Fragment = 0x00000002,\n        Compute = 0x00000004,\n    };\n\n    enum class TextureUsage : uint32_t {\n        None = 0x00000000,\n        CopySrc = 0x00000001,\n        CopyDst = 0x00000002,\n        TextureBinding = 0x00000004,\n        StorageBinding = 0x00000008,\n        RenderAttachment = 0x00000010,\n    };\n\n\n    using BufferMapCallback = WGPUBufferMapCallback;\n    using CompilationInfoCallback = WGPUCompilationInfoCallback;\n    using CreateComputePipelineAsyncCallback = WGPUCreateComputePipelineAsyncCallback;\n    using CreateRenderPipelineAsyncCallback = WGPUCreateRenderPipelineAsyncCallback;\n    using DeviceLostCallback = WGPUDeviceLostCallback;\n    using ErrorCallback = WGPUErrorCallback;\n    using Proc = WGPUProc;\n    using QueueWorkDoneCallback = WGPUQueueWorkDoneCallback;\n    using RequestAdapterCallback = WGPURequestAdapterCallback;\n    using RequestDeviceCallback = WGPURequestDeviceCallback;\n\n    class Adapter;\n    class BindGroup;\n    class BindGroupLayout;\n    class Buffer;\n    class CommandBuffer;\n    class CommandEncoder;\n    class ComputePassEncoder;\n    class ComputePipeline;\n    class Device;\n    class Instance;\n    class PipelineLayout;\n    class QuerySet;\n    class Queue;\n    class RenderBundle;\n    class RenderBundleEncoder;\n    class RenderPassEncoder;\n    class RenderPipeline;\n    class Sampler;\n    class ShaderModule;\n    class Surface;\n    class SwapChain;\n    class Texture;\n    class TextureView;\n\n    struct AdapterProperties;\n    struct BindGroupEntry;\n    struct BlendComponent;\n    struct BufferBindingLayout;\n    struct BufferDescriptor;\n    struct Color;\n    struct CommandBufferDescriptor;\n    struct CommandEncoderDescriptor;\n    struct CompilationMessage;\n    struct ComputePassTimestampWrite;\n    struct ConstantEntry;\n    struct Extent3D;\n    struct InstanceDescriptor;\n    struct Limits;\n    struct MultisampleState;\n    struct Origin3D;\n    struct PipelineLayoutDescriptor;\n    struct PrimitiveDepthClipControl;\n    struct PrimitiveState;\n    struct QuerySetDescriptor;\n    struct QueueDescriptor;\n    struct RenderBundleDescriptor;\n    struct RenderBundleEncoderDescriptor;\n    struct RenderPassDepthStencilAttachment;\n    struct RenderPassDescriptorMaxDrawCount;\n    struct RenderPassTimestampWrite;\n    struct RequestAdapterOptions;\n    struct SamplerBindingLayout;\n    struct SamplerDescriptor;\n    struct ShaderModuleDescriptor;\n    struct ShaderModuleSPIRVDescriptor;\n    struct ShaderModuleWGSLDescriptor;\n    struct StencilFaceState;\n    struct StorageTextureBindingLayout;\n    struct SurfaceDescriptor;\n    struct SurfaceDescriptorFromCanvasHTMLSelector;\n    struct SwapChainDescriptor;\n    struct TextureBindingLayout;\n    struct TextureDataLayout;\n    struct TextureViewDescriptor;\n    struct VertexAttribute;\n    struct BindGroupDescriptor;\n    struct BindGroupLayoutEntry;\n    struct BlendState;\n    struct CompilationInfo;\n    struct ComputePassDescriptor;\n    struct DepthStencilState;\n    struct ImageCopyBuffer;\n    struct ImageCopyTexture;\n    struct ProgrammableStageDescriptor;\n    struct RenderPassColorAttachment;\n    struct RequiredLimits;\n    struct SupportedLimits;\n    struct TextureDescriptor;\n    struct VertexBufferLayout;\n    struct BindGroupLayoutDescriptor;\n    struct ColorTargetState;\n    struct ComputePipelineDescriptor;\n    struct DeviceDescriptor;\n    struct RenderPassDescriptor;\n    struct VertexState;\n    struct FragmentState;\n    struct RenderPipelineDescriptor;\n\n    template<typename Derived, typename CType>\n    class ObjectBase {\n      public:\n        ObjectBase() = default;\n        ObjectBase(CType handle): mHandle(handle) {\n            if (mHandle) Derived::WGPUReference(mHandle);\n        }\n        ~ObjectBase() {\n            if (mHandle) Derived::WGPURelease(mHandle);\n        }\n\n        ObjectBase(ObjectBase const& other)\n            : ObjectBase(other.Get()) {\n        }\n        Derived& operator=(ObjectBase const& other) {\n            if (&other != this) {\n                if (mHandle) Derived::WGPURelease(mHandle);\n                mHandle = other.mHandle;\n                if (mHandle) Derived::WGPUReference(mHandle);\n            }\n\n            return static_cast<Derived&>(*this);\n        }\n\n        ObjectBase(ObjectBase&& other) {\n            mHandle = other.mHandle;\n            other.mHandle = 0;\n        }\n        Derived& operator=(ObjectBase&& other) {\n            if (&other != this) {\n                if (mHandle) Derived::WGPURelease(mHandle);\n                mHandle = other.mHandle;\n                other.mHandle = 0;\n            }\n\n            return static_cast<Derived&>(*this);\n        }\n\n        ObjectBase(std::nullptr_t) {}\n        Derived& operator=(std::nullptr_t) {\n            if (mHandle != nullptr) {\n                Derived::WGPURelease(mHandle);\n                mHandle = nullptr;\n            }\n            return static_cast<Derived&>(*this);\n        }\n\n        bool operator==(std::nullptr_t) const {\n            return mHandle == nullptr;\n        }\n        bool operator!=(std::nullptr_t) const {\n            return mHandle != nullptr;\n        }\n\n        explicit operator bool() const {\n            return mHandle != nullptr;\n        }\n        CType Get() const {\n            return mHandle;\n        }\n        // TODO(dawn:1639) Deprecate Release after uses have been removed.\n        CType Release() {\n            CType result = mHandle;\n            mHandle = 0;\n            return result;\n        }\n        CType MoveToCHandle() {\n            CType result = mHandle;\n            mHandle = 0;\n            return result;\n        }\n        static Derived Acquire(CType handle) {\n            Derived result;\n            result.mHandle = handle;\n            return result;\n        }\n\n      protected:\n        CType mHandle = nullptr;\n    };\n\n\n\n    class Adapter : public ObjectBase<Adapter, WGPUAdapter> {\n      public:\n        using ObjectBase::ObjectBase;\n        using ObjectBase::operator=;\n\n        size_t EnumerateFeatures(FeatureName * features) const;\n        bool GetLimits(SupportedLimits * limits) const;\n        void GetProperties(AdapterProperties * properties) const;\n        bool HasFeature(FeatureName feature) const;\n        void RequestDevice(DeviceDescriptor const * descriptor, RequestDeviceCallback callback, void * userdata) const;\n\n      private:\n        friend ObjectBase<Adapter, WGPUAdapter>;\n        static void WGPUReference(WGPUAdapter handle);\n        static void WGPURelease(WGPUAdapter handle);\n    };\n\n    class BindGroup : public ObjectBase<BindGroup, WGPUBindGroup> {\n      public:\n        using ObjectBase::ObjectBase;\n        using ObjectBase::operator=;\n\n        void SetLabel(char const * label) const;\n\n      private:\n        friend ObjectBase<BindGroup, WGPUBindGroup>;\n        static void WGPUReference(WGPUBindGroup handle);\n        static void WGPURelease(WGPUBindGroup handle);\n    };\n\n    class BindGroupLayout : public ObjectBase<BindGroupLayout, WGPUBindGroupLayout> {\n      public:\n        using ObjectBase::ObjectBase;\n        using ObjectBase::operator=;\n\n        void SetLabel(char const * label) const;\n\n      private:\n        friend ObjectBase<BindGroupLayout, WGPUBindGroupLayout>;\n        static void WGPUReference(WGPUBindGroupLayout handle);\n        static void WGPURelease(WGPUBindGroupLayout handle);\n    };\n\n    class Buffer : public ObjectBase<Buffer, WGPUBuffer> {\n      public:\n        using ObjectBase::ObjectBase;\n        using ObjectBase::operator=;\n\n        void Destroy() const;\n        void const * GetConstMappedRange(size_t offset = 0, size_t size = WGPU_WHOLE_MAP_SIZE) const;\n        BufferMapState GetMapState() const;\n        void * GetMappedRange(size_t offset = 0, size_t size = WGPU_WHOLE_MAP_SIZE) const;\n        uint64_t GetSize() const;\n        BufferUsage GetUsage() const;\n        void MapAsync(MapMode mode, size_t offset, size_t size, BufferMapCallback callback, void * userdata) const;\n        void SetLabel(char const * label) const;\n        void Unmap() const;\n\n      private:\n        friend ObjectBase<Buffer, WGPUBuffer>;\n        static void WGPUReference(WGPUBuffer handle);\n        static void WGPURelease(WGPUBuffer handle);\n    };\n\n    class CommandBuffer : public ObjectBase<CommandBuffer, WGPUCommandBuffer> {\n      public:\n        using ObjectBase::ObjectBase;\n        using ObjectBase::operator=;\n\n        void SetLabel(char const * label) const;\n\n      private:\n        friend ObjectBase<CommandBuffer, WGPUCommandBuffer>;\n        static void WGPUReference(WGPUCommandBuffer handle);\n        static void WGPURelease(WGPUCommandBuffer handle);\n    };\n\n    class CommandEncoder : public ObjectBase<CommandEncoder, WGPUCommandEncoder> {\n      public:\n        using ObjectBase::ObjectBase;\n        using ObjectBase::operator=;\n\n        ComputePassEncoder BeginComputePass(ComputePassDescriptor const * descriptor = nullptr) const;\n        RenderPassEncoder BeginRenderPass(RenderPassDescriptor const * descriptor) const;\n        void ClearBuffer(Buffer const& buffer, uint64_t offset = 0, uint64_t size = WGPU_WHOLE_SIZE) const;\n        void CopyBufferToBuffer(Buffer const& source, uint64_t sourceOffset, Buffer const& destination, uint64_t destinationOffset, uint64_t size) const;\n        void CopyBufferToTexture(ImageCopyBuffer const * source, ImageCopyTexture const * destination, Extent3D const * copySize) const;\n        void CopyTextureToBuffer(ImageCopyTexture const * source, ImageCopyBuffer const * destination, Extent3D const * copySize) const;\n        void CopyTextureToTexture(ImageCopyTexture const * source, ImageCopyTexture const * destination, Extent3D const * copySize) const;\n        CommandBuffer Finish(CommandBufferDescriptor const * descriptor = nullptr) const;\n        void InsertDebugMarker(char const * markerLabel) const;\n        void PopDebugGroup() const;\n        void PushDebugGroup(char const * groupLabel) const;\n        void ResolveQuerySet(QuerySet const& querySet, uint32_t firstQuery, uint32_t queryCount, Buffer const& destination, uint64_t destinationOffset) const;\n        void SetLabel(char const * label) const;\n        void WriteTimestamp(QuerySet const& querySet, uint32_t queryIndex) const;\n\n      private:\n        friend ObjectBase<CommandEncoder, WGPUCommandEncoder>;\n        static void WGPUReference(WGPUCommandEncoder handle);\n        static void WGPURelease(WGPUCommandEncoder handle);\n    };\n\n    class ComputePassEncoder : public ObjectBase<ComputePassEncoder, WGPUComputePassEncoder> {\n      public:\n        using ObjectBase::ObjectBase;\n        using ObjectBase::operator=;\n\n        void BeginPipelineStatisticsQuery(QuerySet const& querySet, uint32_t queryIndex) const;\n        void DispatchWorkgroups(uint32_t workgroupCountX, uint32_t workgroupCountY = 1, uint32_t workgroupCountZ = 1) const;\n        void DispatchWorkgroupsIndirect(Buffer const& indirectBuffer, uint64_t indirectOffset) const;\n        void End() const;\n        void EndPipelineStatisticsQuery() const;\n        void InsertDebugMarker(char const * markerLabel) const;\n        void PopDebugGroup() const;\n        void PushDebugGroup(char const * groupLabel) const;\n        void SetBindGroup(uint32_t groupIndex, BindGroup const& group, size_t dynamicOffsetCount = 0, uint32_t const * dynamicOffsets = nullptr) const;\n        void SetLabel(char const * label) const;\n        void SetPipeline(ComputePipeline const& pipeline) const;\n        void WriteTimestamp(QuerySet const& querySet, uint32_t queryIndex) const;\n\n      private:\n        friend ObjectBase<ComputePassEncoder, WGPUComputePassEncoder>;\n        static void WGPUReference(WGPUComputePassEncoder handle);\n        static void WGPURelease(WGPUComputePassEncoder handle);\n    };\n\n    class ComputePipeline : public ObjectBase<ComputePipeline, WGPUComputePipeline> {\n      public:\n        using ObjectBase::ObjectBase;\n        using ObjectBase::operator=;\n\n        BindGroupLayout GetBindGroupLayout(uint32_t groupIndex) const;\n        void SetLabel(char const * label) const;\n\n      private:\n        friend ObjectBase<ComputePipeline, WGPUComputePipeline>;\n        static void WGPUReference(WGPUComputePipeline handle);\n        static void WGPURelease(WGPUComputePipeline handle);\n    };\n\n    class Device : public ObjectBase<Device, WGPUDevice> {\n      public:\n        using ObjectBase::ObjectBase;\n        using ObjectBase::operator=;\n\n        BindGroup CreateBindGroup(BindGroupDescriptor const * descriptor) const;\n        BindGroupLayout CreateBindGroupLayout(BindGroupLayoutDescriptor const * descriptor) const;\n        Buffer CreateBuffer(BufferDescriptor const * descriptor) const;\n        CommandEncoder CreateCommandEncoder(CommandEncoderDescriptor const * descriptor = nullptr) const;\n        ComputePipeline CreateComputePipeline(ComputePipelineDescriptor const * descriptor) const;\n        void CreateComputePipelineAsync(ComputePipelineDescriptor const * descriptor, CreateComputePipelineAsyncCallback callback, void * userdata) const;\n        PipelineLayout CreatePipelineLayout(PipelineLayoutDescriptor const * descriptor) const;\n        QuerySet CreateQuerySet(QuerySetDescriptor const * descriptor) const;\n        RenderBundleEncoder CreateRenderBundleEncoder(RenderBundleEncoderDescriptor const * descriptor) const;\n        RenderPipeline CreateRenderPipeline(RenderPipelineDescriptor const * descriptor) const;\n        void CreateRenderPipelineAsync(RenderPipelineDescriptor const * descriptor, CreateRenderPipelineAsyncCallback callback, void * userdata) const;\n        Sampler CreateSampler(SamplerDescriptor const * descriptor = nullptr) const;\n        ShaderModule CreateShaderModule(ShaderModuleDescriptor const * descriptor) const;\n        SwapChain CreateSwapChain(Surface const& surface, SwapChainDescriptor const * descriptor) const;\n        Texture CreateTexture(TextureDescriptor const * descriptor) const;\n        void Destroy() const;\n        size_t EnumerateFeatures(FeatureName * features) const;\n        bool GetLimits(SupportedLimits * limits) const;\n        Queue GetQueue() const;\n        bool HasFeature(FeatureName feature) const;\n        void PopErrorScope(ErrorCallback callback, void * userdata) const;\n        void PushErrorScope(ErrorFilter filter) const;\n        void SetLabel(char const * label) const;\n        void SetUncapturedErrorCallback(ErrorCallback callback, void * userdata) const;\n\n      private:\n        friend ObjectBase<Device, WGPUDevice>;\n        static void WGPUReference(WGPUDevice handle);\n        static void WGPURelease(WGPUDevice handle);\n    };\n\n    class Instance : public ObjectBase<Instance, WGPUInstance> {\n      public:\n        using ObjectBase::ObjectBase;\n        using ObjectBase::operator=;\n\n        Surface CreateSurface(SurfaceDescriptor const * descriptor) const;\n        void ProcessEvents() const;\n        void RequestAdapter(RequestAdapterOptions const * options, RequestAdapterCallback callback, void * userdata) const;\n\n      private:\n        friend ObjectBase<Instance, WGPUInstance>;\n        static void WGPUReference(WGPUInstance handle);\n        static void WGPURelease(WGPUInstance handle);\n    };\n\n    class PipelineLayout : public ObjectBase<PipelineLayout, WGPUPipelineLayout> {\n      public:\n        using ObjectBase::ObjectBase;\n        using ObjectBase::operator=;\n\n        void SetLabel(char const * label) const;\n\n      private:\n        friend ObjectBase<PipelineLayout, WGPUPipelineLayout>;\n        static void WGPUReference(WGPUPipelineLayout handle);\n        static void WGPURelease(WGPUPipelineLayout handle);\n    };\n\n    class QuerySet : public ObjectBase<QuerySet, WGPUQuerySet> {\n      public:\n        using ObjectBase::ObjectBase;\n        using ObjectBase::operator=;\n\n        void Destroy() const;\n        uint32_t GetCount() const;\n        QueryType GetType() const;\n        void SetLabel(char const * label) const;\n\n      private:\n        friend ObjectBase<QuerySet, WGPUQuerySet>;\n        static void WGPUReference(WGPUQuerySet handle);\n        static void WGPURelease(WGPUQuerySet handle);\n    };\n\n    class Queue : public ObjectBase<Queue, WGPUQueue> {\n      public:\n        using ObjectBase::ObjectBase;\n        using ObjectBase::operator=;\n\n        void OnSubmittedWorkDone(uint64_t signalValue, QueueWorkDoneCallback callback, void * userdata) const;\n        void SetLabel(char const * label) const;\n        void Submit(size_t commandCount, CommandBuffer const * commands) const;\n        void WriteBuffer(Buffer const& buffer, uint64_t bufferOffset, void const * data, size_t size) const;\n        void WriteTexture(ImageCopyTexture const * destination, void const * data, size_t dataSize, TextureDataLayout const * dataLayout, Extent3D const * writeSize) const;\n\n      private:\n        friend ObjectBase<Queue, WGPUQueue>;\n        static void WGPUReference(WGPUQueue handle);\n        static void WGPURelease(WGPUQueue handle);\n    };\n\n    class RenderBundle : public ObjectBase<RenderBundle, WGPURenderBundle> {\n      public:\n        using ObjectBase::ObjectBase;\n        using ObjectBase::operator=;\n\n        void SetLabel(char const * label) const;\n\n      private:\n        friend ObjectBase<RenderBundle, WGPURenderBundle>;\n        static void WGPUReference(WGPURenderBundle handle);\n        static void WGPURelease(WGPURenderBundle handle);\n    };\n\n    class RenderBundleEncoder : public ObjectBase<RenderBundleEncoder, WGPURenderBundleEncoder> {\n      public:\n        using ObjectBase::ObjectBase;\n        using ObjectBase::operator=;\n\n        void Draw(uint32_t vertexCount, uint32_t instanceCount = 1, uint32_t firstVertex = 0, uint32_t firstInstance = 0) const;\n        void DrawIndexed(uint32_t indexCount, uint32_t instanceCount = 1, uint32_t firstIndex = 0, int32_t baseVertex = 0, uint32_t firstInstance = 0) const;\n        void DrawIndexedIndirect(Buffer const& indirectBuffer, uint64_t indirectOffset) const;\n        void DrawIndirect(Buffer const& indirectBuffer, uint64_t indirectOffset) const;\n        RenderBundle Finish(RenderBundleDescriptor const * descriptor = nullptr) const;\n        void InsertDebugMarker(char const * markerLabel) const;\n        void PopDebugGroup() const;\n        void PushDebugGroup(char const * groupLabel) const;\n        void SetBindGroup(uint32_t groupIndex, BindGroup const& group, size_t dynamicOffsetCount = 0, uint32_t const * dynamicOffsets = nullptr) const;\n        void SetIndexBuffer(Buffer const& buffer, IndexFormat format, uint64_t offset = 0, uint64_t size = WGPU_WHOLE_SIZE) const;\n        void SetLabel(char const * label) const;\n        void SetPipeline(RenderPipeline const& pipeline) const;\n        void SetVertexBuffer(uint32_t slot, Buffer const& buffer, uint64_t offset = 0, uint64_t size = WGPU_WHOLE_SIZE) const;\n\n      private:\n        friend ObjectBase<RenderBundleEncoder, WGPURenderBundleEncoder>;\n        static void WGPUReference(WGPURenderBundleEncoder handle);\n        static void WGPURelease(WGPURenderBundleEncoder handle);\n    };\n\n    class RenderPassEncoder : public ObjectBase<RenderPassEncoder, WGPURenderPassEncoder> {\n      public:\n        using ObjectBase::ObjectBase;\n        using ObjectBase::operator=;\n\n        void BeginOcclusionQuery(uint32_t queryIndex) const;\n        void BeginPipelineStatisticsQuery(QuerySet const& querySet, uint32_t queryIndex) const;\n        void Draw(uint32_t vertexCount, uint32_t instanceCount = 1, uint32_t firstVertex = 0, uint32_t firstInstance = 0) const;\n        void DrawIndexed(uint32_t indexCount, uint32_t instanceCount = 1, uint32_t firstIndex = 0, int32_t baseVertex = 0, uint32_t firstInstance = 0) const;\n        void DrawIndexedIndirect(Buffer const& indirectBuffer, uint64_t indirectOffset) const;\n        void DrawIndirect(Buffer const& indirectBuffer, uint64_t indirectOffset) const;\n        void End() const;\n        void EndOcclusionQuery() const;\n        void EndPipelineStatisticsQuery() const;\n        void ExecuteBundles(size_t bundleCount, RenderBundle const * bundles) const;\n        void InsertDebugMarker(char const * markerLabel) const;\n        void PopDebugGroup() const;\n        void PushDebugGroup(char const * groupLabel) const;\n        void SetBindGroup(uint32_t groupIndex, BindGroup const& group, size_t dynamicOffsetCount = 0, uint32_t const * dynamicOffsets = nullptr) const;\n        void SetBlendConstant(Color const * color) const;\n        void SetIndexBuffer(Buffer const& buffer, IndexFormat format, uint64_t offset = 0, uint64_t size = WGPU_WHOLE_SIZE) const;\n        void SetLabel(char const * label) const;\n        void SetPipeline(RenderPipeline const& pipeline) const;\n        void SetScissorRect(uint32_t x, uint32_t y, uint32_t width, uint32_t height) const;\n        void SetStencilReference(uint32_t reference) const;\n        void SetVertexBuffer(uint32_t slot, Buffer const& buffer, uint64_t offset = 0, uint64_t size = WGPU_WHOLE_SIZE) const;\n        void SetViewport(float x, float y, float width, float height, float minDepth, float maxDepth) const;\n        void WriteTimestamp(QuerySet const& querySet, uint32_t queryIndex) const;\n\n      private:\n        friend ObjectBase<RenderPassEncoder, WGPURenderPassEncoder>;\n        static void WGPUReference(WGPURenderPassEncoder handle);\n        static void WGPURelease(WGPURenderPassEncoder handle);\n    };\n\n    class RenderPipeline : public ObjectBase<RenderPipeline, WGPURenderPipeline> {\n      public:\n        using ObjectBase::ObjectBase;\n        using ObjectBase::operator=;\n\n        BindGroupLayout GetBindGroupLayout(uint32_t groupIndex) const;\n        void SetLabel(char const * label) const;\n\n      private:\n        friend ObjectBase<RenderPipeline, WGPURenderPipeline>;\n        static void WGPUReference(WGPURenderPipeline handle);\n        static void WGPURelease(WGPURenderPipeline handle);\n    };\n\n    class Sampler : public ObjectBase<Sampler, WGPUSampler> {\n      public:\n        using ObjectBase::ObjectBase;\n        using ObjectBase::operator=;\n\n        void SetLabel(char const * label) const;\n\n      private:\n        friend ObjectBase<Sampler, WGPUSampler>;\n        static void WGPUReference(WGPUSampler handle);\n        static void WGPURelease(WGPUSampler handle);\n    };\n\n    class ShaderModule : public ObjectBase<ShaderModule, WGPUShaderModule> {\n      public:\n        using ObjectBase::ObjectBase;\n        using ObjectBase::operator=;\n\n        void GetCompilationInfo(CompilationInfoCallback callback, void * userdata) const;\n        void SetLabel(char const * label) const;\n\n      private:\n        friend ObjectBase<ShaderModule, WGPUShaderModule>;\n        static void WGPUReference(WGPUShaderModule handle);\n        static void WGPURelease(WGPUShaderModule handle);\n    };\n\n    class Surface : public ObjectBase<Surface, WGPUSurface> {\n      public:\n        using ObjectBase::ObjectBase;\n        using ObjectBase::operator=;\n\n        TextureFormat GetPreferredFormat(Adapter const& adapter) const;\n\n      private:\n        friend ObjectBase<Surface, WGPUSurface>;\n        static void WGPUReference(WGPUSurface handle);\n        static void WGPURelease(WGPUSurface handle);\n    };\n\n    class SwapChain : public ObjectBase<SwapChain, WGPUSwapChain> {\n      public:\n        using ObjectBase::ObjectBase;\n        using ObjectBase::operator=;\n\n        TextureView GetCurrentTextureView() const;\n        void Present() const;\n\n      private:\n        friend ObjectBase<SwapChain, WGPUSwapChain>;\n        static void WGPUReference(WGPUSwapChain handle);\n        static void WGPURelease(WGPUSwapChain handle);\n    };\n\n    class Texture : public ObjectBase<Texture, WGPUTexture> {\n      public:\n        using ObjectBase::ObjectBase;\n        using ObjectBase::operator=;\n\n        TextureView CreateView(TextureViewDescriptor const * descriptor = nullptr) const;\n        void Destroy() const;\n        uint32_t GetDepthOrArrayLayers() const;\n        TextureDimension GetDimension() const;\n        TextureFormat GetFormat() const;\n        uint32_t GetHeight() const;\n        uint32_t GetMipLevelCount() const;\n        uint32_t GetSampleCount() const;\n        TextureUsage GetUsage() const;\n        uint32_t GetWidth() const;\n        void SetLabel(char const * label) const;\n\n      private:\n        friend ObjectBase<Texture, WGPUTexture>;\n        static void WGPUReference(WGPUTexture handle);\n        static void WGPURelease(WGPUTexture handle);\n    };\n\n    class TextureView : public ObjectBase<TextureView, WGPUTextureView> {\n      public:\n        using ObjectBase::ObjectBase;\n        using ObjectBase::operator=;\n\n        void SetLabel(char const * label) const;\n\n      private:\n        friend ObjectBase<TextureView, WGPUTextureView>;\n        static void WGPUReference(WGPUTextureView handle);\n        static void WGPURelease(WGPUTextureView handle);\n    };\n\n\n    Instance CreateInstance(InstanceDescriptor const * descriptor = nullptr);\n    Proc GetProcAddress(Device device, char const * procName);\n\n    struct AdapterProperties {\n        ChainedStructOut  * nextInChain = nullptr;\n        uint32_t vendorID;\n        char const * vendorName;\n        char const * architecture;\n        uint32_t deviceID;\n        char const * name;\n        char const * driverDescription;\n        AdapterType adapterType;\n        BackendType backendType;\n        bool compatibilityMode = false;\n    };\n\n    struct BindGroupEntry {\n        ChainedStruct const * nextInChain = nullptr;\n        uint32_t binding;\n        Buffer buffer = nullptr;\n        uint64_t offset = 0;\n        uint64_t size = WGPU_WHOLE_SIZE;\n        Sampler sampler = nullptr;\n        TextureView textureView = nullptr;\n    };\n\n    struct BlendComponent {\n        BlendOperation operation = BlendOperation::Add;\n        BlendFactor srcFactor = BlendFactor::One;\n        BlendFactor dstFactor = BlendFactor::Zero;\n    };\n\n    struct BufferBindingLayout {\n        ChainedStruct const * nextInChain = nullptr;\n        BufferBindingType type = BufferBindingType::Undefined;\n        bool hasDynamicOffset = false;\n        uint64_t minBindingSize = 0;\n    };\n\n    struct BufferDescriptor {\n        ChainedStruct const * nextInChain = nullptr;\n        char const * label = nullptr;\n        BufferUsage usage;\n        uint64_t size;\n        bool mappedAtCreation = false;\n    };\n\n    struct Color {\n        double r;\n        double g;\n        double b;\n        double a;\n    };\n\n    struct CommandBufferDescriptor {\n        ChainedStruct const * nextInChain = nullptr;\n        char const * label = nullptr;\n    };\n\n    struct CommandEncoderDescriptor {\n        ChainedStruct const * nextInChain = nullptr;\n        char const * label = nullptr;\n    };\n\n    struct CompilationMessage {\n        ChainedStruct const * nextInChain = nullptr;\n        char const * message = nullptr;\n        CompilationMessageType type;\n        uint64_t lineNum;\n        uint64_t linePos;\n        uint64_t offset;\n        uint64_t length;\n        uint64_t utf16LinePos;\n        uint64_t utf16Offset;\n        uint64_t utf16Length;\n    };\n\n    struct ComputePassTimestampWrite {\n        QuerySet querySet;\n        uint32_t queryIndex;\n        ComputePassTimestampLocation location;\n    };\n\n    struct ConstantEntry {\n        ChainedStruct const * nextInChain = nullptr;\n        char const * key;\n        double value;\n    };\n\n    struct Extent3D {\n        uint32_t width;\n        uint32_t height = 1;\n        uint32_t depthOrArrayLayers = 1;\n    };\n\n    struct InstanceDescriptor {\n        ChainedStruct const * nextInChain = nullptr;\n    };\n\n    struct Limits {\n        uint32_t maxTextureDimension1D = WGPU_LIMIT_U32_UNDEFINED;\n        uint32_t maxTextureDimension2D = WGPU_LIMIT_U32_UNDEFINED;\n        uint32_t maxTextureDimension3D = WGPU_LIMIT_U32_UNDEFINED;\n        uint32_t maxTextureArrayLayers = WGPU_LIMIT_U32_UNDEFINED;\n        uint32_t maxBindGroups = WGPU_LIMIT_U32_UNDEFINED;\n        uint32_t maxBindGroupsPlusVertexBuffers = WGPU_LIMIT_U32_UNDEFINED;\n        uint32_t maxBindingsPerBindGroup = WGPU_LIMIT_U32_UNDEFINED;\n        uint32_t maxDynamicUniformBuffersPerPipelineLayout = WGPU_LIMIT_U32_UNDEFINED;\n        uint32_t maxDynamicStorageBuffersPerPipelineLayout = WGPU_LIMIT_U32_UNDEFINED;\n        uint32_t maxSampledTexturesPerShaderStage = WGPU_LIMIT_U32_UNDEFINED;\n        uint32_t maxSamplersPerShaderStage = WGPU_LIMIT_U32_UNDEFINED;\n        uint32_t maxStorageBuffersPerShaderStage = WGPU_LIMIT_U32_UNDEFINED;\n        uint32_t maxStorageTexturesPerShaderStage = WGPU_LIMIT_U32_UNDEFINED;\n        uint32_t maxUniformBuffersPerShaderStage = WGPU_LIMIT_U32_UNDEFINED;\n        uint64_t maxUniformBufferBindingSize = WGPU_LIMIT_U64_UNDEFINED;\n        uint64_t maxStorageBufferBindingSize = WGPU_LIMIT_U64_UNDEFINED;\n        uint32_t minUniformBufferOffsetAlignment = WGPU_LIMIT_U32_UNDEFINED;\n        uint32_t minStorageBufferOffsetAlignment = WGPU_LIMIT_U32_UNDEFINED;\n        uint32_t maxVertexBuffers = WGPU_LIMIT_U32_UNDEFINED;\n        uint64_t maxBufferSize = WGPU_LIMIT_U64_UNDEFINED;\n        uint32_t maxVertexAttributes = WGPU_LIMIT_U32_UNDEFINED;\n        uint32_t maxVertexBufferArrayStride = WGPU_LIMIT_U32_UNDEFINED;\n        uint32_t maxInterStageShaderComponents = WGPU_LIMIT_U32_UNDEFINED;\n        uint32_t maxInterStageShaderVariables = WGPU_LIMIT_U32_UNDEFINED;\n        uint32_t maxColorAttachments = WGPU_LIMIT_U32_UNDEFINED;\n        uint32_t maxColorAttachmentBytesPerSample = WGPU_LIMIT_U32_UNDEFINED;\n        uint32_t maxComputeWorkgroupStorageSize = WGPU_LIMIT_U32_UNDEFINED;\n        uint32_t maxComputeInvocationsPerWorkgroup = WGPU_LIMIT_U32_UNDEFINED;\n        uint32_t maxComputeWorkgroupSizeX = WGPU_LIMIT_U32_UNDEFINED;\n        uint32_t maxComputeWorkgroupSizeY = WGPU_LIMIT_U32_UNDEFINED;\n        uint32_t maxComputeWorkgroupSizeZ = WGPU_LIMIT_U32_UNDEFINED;\n        uint32_t maxComputeWorkgroupsPerDimension = WGPU_LIMIT_U32_UNDEFINED;\n    };\n\n    struct MultisampleState {\n        ChainedStruct const * nextInChain = nullptr;\n        uint32_t count = 1;\n        uint32_t mask = 0xFFFFFFFF;\n        bool alphaToCoverageEnabled = false;\n    };\n\n    struct Origin3D {\n        uint32_t x = 0;\n        uint32_t y = 0;\n        uint32_t z = 0;\n    };\n\n    struct PipelineLayoutDescriptor {\n        ChainedStruct const * nextInChain = nullptr;\n        char const * label = nullptr;\n        size_t bindGroupLayoutCount;\n        BindGroupLayout const * bindGroupLayouts;\n    };\n\n    // Can be chained in PrimitiveState\n    struct PrimitiveDepthClipControl : ChainedStruct {\n        PrimitiveDepthClipControl() {\n            sType = SType::PrimitiveDepthClipControl;\n        }\n        static constexpr size_t kFirstMemberAlignment = detail::ConstexprMax(alignof(ChainedStruct), alignof(bool ));\n        alignas(kFirstMemberAlignment) bool unclippedDepth = false;\n    };\n\n    struct PrimitiveState {\n        ChainedStruct const * nextInChain = nullptr;\n        PrimitiveTopology topology = PrimitiveTopology::TriangleList;\n        IndexFormat stripIndexFormat = IndexFormat::Undefined;\n        FrontFace frontFace = FrontFace::CCW;\n        CullMode cullMode = CullMode::None;\n    };\n\n    struct QuerySetDescriptor {\n        ChainedStruct const * nextInChain = nullptr;\n        char const * label = nullptr;\n        QueryType type;\n        uint32_t count;\n        PipelineStatisticName const * pipelineStatistics;\n        size_t pipelineStatisticsCount = 0;\n    };\n\n    struct QueueDescriptor {\n        ChainedStruct const * nextInChain = nullptr;\n        char const * label = nullptr;\n    };\n\n    struct RenderBundleDescriptor {\n        ChainedStruct const * nextInChain = nullptr;\n        char const * label = nullptr;\n    };\n\n    struct RenderBundleEncoderDescriptor {\n        ChainedStruct const * nextInChain = nullptr;\n        char const * label = nullptr;\n        size_t colorFormatsCount;\n        TextureFormat const * colorFormats;\n        TextureFormat depthStencilFormat = TextureFormat::Undefined;\n        uint32_t sampleCount = 1;\n        bool depthReadOnly = false;\n        bool stencilReadOnly = false;\n    };\n\n    struct RenderPassDepthStencilAttachment {\n        TextureView view;\n        LoadOp depthLoadOp = LoadOp::Undefined;\n        StoreOp depthStoreOp = StoreOp::Undefined;\n        float depthClearValue = NAN;\n        bool depthReadOnly = false;\n        LoadOp stencilLoadOp = LoadOp::Undefined;\n        StoreOp stencilStoreOp = StoreOp::Undefined;\n        uint32_t stencilClearValue = 0;\n        bool stencilReadOnly = false;\n    };\n\n    // Can be chained in RenderPassDescriptor\n    struct RenderPassDescriptorMaxDrawCount : ChainedStruct {\n        RenderPassDescriptorMaxDrawCount() {\n            sType = SType::RenderPassDescriptorMaxDrawCount;\n        }\n        static constexpr size_t kFirstMemberAlignment = detail::ConstexprMax(alignof(ChainedStruct), alignof(uint64_t ));\n        alignas(kFirstMemberAlignment) uint64_t maxDrawCount = 50000000;\n    };\n\n    struct RenderPassTimestampWrite {\n        QuerySet querySet;\n        uint32_t queryIndex;\n        RenderPassTimestampLocation location;\n    };\n\n    struct RequestAdapterOptions {\n        ChainedStruct const * nextInChain = nullptr;\n        Surface compatibleSurface = nullptr;\n        PowerPreference powerPreference = PowerPreference::Undefined;\n        BackendType backendType = BackendType::Undefined;\n        bool forceFallbackAdapter = false;\n        bool compatibilityMode = false;\n    };\n\n    struct SamplerBindingLayout {\n        ChainedStruct const * nextInChain = nullptr;\n        SamplerBindingType type = SamplerBindingType::Undefined;\n    };\n\n    struct SamplerDescriptor {\n        ChainedStruct const * nextInChain = nullptr;\n        char const * label = nullptr;\n        AddressMode addressModeU = AddressMode::ClampToEdge;\n        AddressMode addressModeV = AddressMode::ClampToEdge;\n        AddressMode addressModeW = AddressMode::ClampToEdge;\n        FilterMode magFilter = FilterMode::Nearest;\n        FilterMode minFilter = FilterMode::Nearest;\n        MipmapFilterMode mipmapFilter = MipmapFilterMode::Nearest;\n        float lodMinClamp = 0.0f;\n        float lodMaxClamp = 32.0f;\n        CompareFunction compare = CompareFunction::Undefined;\n        uint16_t maxAnisotropy = 1;\n    };\n\n    struct ShaderModuleDescriptor {\n        ChainedStruct const * nextInChain = nullptr;\n        char const * label = nullptr;\n    };\n\n    // Can be chained in ShaderModuleDescriptor\n    struct ShaderModuleSPIRVDescriptor : ChainedStruct {\n        ShaderModuleSPIRVDescriptor() {\n            sType = SType::ShaderModuleSPIRVDescriptor;\n        }\n        static constexpr size_t kFirstMemberAlignment = detail::ConstexprMax(alignof(ChainedStruct), alignof(uint32_t ));\n        alignas(kFirstMemberAlignment) uint32_t codeSize;\n        uint32_t const * code;\n    };\n\n    // Can be chained in ShaderModuleDescriptor\n    struct ShaderModuleWGSLDescriptor : ChainedStruct {\n        ShaderModuleWGSLDescriptor() {\n            sType = SType::ShaderModuleWGSLDescriptor;\n        }\n        static constexpr size_t kFirstMemberAlignment = detail::ConstexprMax(alignof(ChainedStruct), alignof(char const * ));\n        alignas(kFirstMemberAlignment) char const * code;\n    };\n\n    struct StencilFaceState {\n        CompareFunction compare = CompareFunction::Always;\n        StencilOperation failOp = StencilOperation::Keep;\n        StencilOperation depthFailOp = StencilOperation::Keep;\n        StencilOperation passOp = StencilOperation::Keep;\n    };\n\n    struct StorageTextureBindingLayout {\n        ChainedStruct const * nextInChain = nullptr;\n        StorageTextureAccess access = StorageTextureAccess::Undefined;\n        TextureFormat format = TextureFormat::Undefined;\n        TextureViewDimension viewDimension = TextureViewDimension::Undefined;\n    };\n\n    struct SurfaceDescriptor {\n        ChainedStruct const * nextInChain = nullptr;\n        char const * label = nullptr;\n    };\n\n    // Can be chained in SurfaceDescriptor\n    struct SurfaceDescriptorFromCanvasHTMLSelector : ChainedStruct {\n        SurfaceDescriptorFromCanvasHTMLSelector() {\n            sType = SType::SurfaceDescriptorFromCanvasHTMLSelector;\n        }\n        static constexpr size_t kFirstMemberAlignment = detail::ConstexprMax(alignof(ChainedStruct), alignof(char const * ));\n        alignas(kFirstMemberAlignment) char const * selector;\n    };\n\n    struct SwapChainDescriptor {\n        ChainedStruct const * nextInChain = nullptr;\n        char const * label = nullptr;\n        TextureUsage usage;\n        TextureFormat format;\n        uint32_t width;\n        uint32_t height;\n        PresentMode presentMode;\n    };\n\n    struct TextureBindingLayout {\n        ChainedStruct const * nextInChain = nullptr;\n        TextureSampleType sampleType = TextureSampleType::Undefined;\n        TextureViewDimension viewDimension = TextureViewDimension::Undefined;\n        bool multisampled = false;\n    };\n\n    struct TextureDataLayout {\n        ChainedStruct const * nextInChain = nullptr;\n        uint64_t offset = 0;\n        uint32_t bytesPerRow = WGPU_COPY_STRIDE_UNDEFINED;\n        uint32_t rowsPerImage = WGPU_COPY_STRIDE_UNDEFINED;\n    };\n\n    struct TextureViewDescriptor {\n        ChainedStruct const * nextInChain = nullptr;\n        char const * label = nullptr;\n        TextureFormat format = TextureFormat::Undefined;\n        TextureViewDimension dimension = TextureViewDimension::Undefined;\n        uint32_t baseMipLevel = 0;\n        uint32_t mipLevelCount = WGPU_MIP_LEVEL_COUNT_UNDEFINED;\n        uint32_t baseArrayLayer = 0;\n        uint32_t arrayLayerCount = WGPU_ARRAY_LAYER_COUNT_UNDEFINED;\n        TextureAspect aspect = TextureAspect::All;\n    };\n\n    struct VertexAttribute {\n        VertexFormat format;\n        uint64_t offset;\n        uint32_t shaderLocation;\n    };\n\n    struct BindGroupDescriptor {\n        ChainedStruct const * nextInChain = nullptr;\n        char const * label = nullptr;\n        BindGroupLayout layout;\n        size_t entryCount;\n        BindGroupEntry const * entries;\n    };\n\n    struct BindGroupLayoutEntry {\n        ChainedStruct const * nextInChain = nullptr;\n        uint32_t binding;\n        ShaderStage visibility;\n        BufferBindingLayout buffer;\n        SamplerBindingLayout sampler;\n        TextureBindingLayout texture;\n        StorageTextureBindingLayout storageTexture;\n    };\n\n    struct BlendState {\n        BlendComponent color;\n        BlendComponent alpha;\n    };\n\n    struct CompilationInfo {\n        ChainedStruct const * nextInChain = nullptr;\n        size_t messageCount;\n        CompilationMessage const * messages;\n    };\n\n    struct ComputePassDescriptor {\n        ChainedStruct const * nextInChain = nullptr;\n        char const * label = nullptr;\n        size_t timestampWriteCount = 0;\n        ComputePassTimestampWrite const * timestampWrites;\n    };\n\n    struct DepthStencilState {\n        ChainedStruct const * nextInChain = nullptr;\n        TextureFormat format;\n        bool depthWriteEnabled;\n        CompareFunction depthCompare;\n        StencilFaceState stencilFront;\n        StencilFaceState stencilBack;\n        uint32_t stencilReadMask = 0xFFFFFFFF;\n        uint32_t stencilWriteMask = 0xFFFFFFFF;\n        int32_t depthBias = 0;\n        float depthBiasSlopeScale = 0.0f;\n        float depthBiasClamp = 0.0f;\n    };\n\n    struct ImageCopyBuffer {\n        ChainedStruct const * nextInChain = nullptr;\n        TextureDataLayout layout;\n        Buffer buffer;\n    };\n\n    struct ImageCopyTexture {\n        ChainedStruct const * nextInChain = nullptr;\n        Texture texture;\n        uint32_t mipLevel = 0;\n        Origin3D origin;\n        TextureAspect aspect = TextureAspect::All;\n    };\n\n    struct ProgrammableStageDescriptor {\n        ChainedStruct const * nextInChain = nullptr;\n        ShaderModule module;\n        char const * entryPoint;\n        size_t constantCount = 0;\n        ConstantEntry const * constants;\n    };\n\n    struct RenderPassColorAttachment {\n        ChainedStruct const * nextInChain = nullptr;\n        TextureView view = nullptr;\n        TextureView resolveTarget = nullptr;\n        LoadOp loadOp;\n        StoreOp storeOp;\n        Color clearValue;\n    };\n\n    struct RequiredLimits {\n        ChainedStruct const * nextInChain = nullptr;\n        Limits limits;\n    };\n\n    struct SupportedLimits {\n        ChainedStructOut  * nextInChain = nullptr;\n        Limits limits;\n    };\n\n    struct TextureDescriptor {\n        ChainedStruct const * nextInChain = nullptr;\n        char const * label = nullptr;\n        TextureUsage usage;\n        TextureDimension dimension = TextureDimension::e2D;\n        Extent3D size;\n        TextureFormat format;\n        uint32_t mipLevelCount = 1;\n        uint32_t sampleCount = 1;\n        size_t viewFormatCount = 0;\n        TextureFormat const * viewFormats;\n    };\n\n    struct VertexBufferLayout {\n        uint64_t arrayStride;\n        VertexStepMode stepMode = VertexStepMode::Vertex;\n        size_t attributeCount;\n        VertexAttribute const * attributes;\n    };\n\n    struct BindGroupLayoutDescriptor {\n        ChainedStruct const * nextInChain = nullptr;\n        char const * label = nullptr;\n        size_t entryCount;\n        BindGroupLayoutEntry const * entries;\n    };\n\n    struct ColorTargetState {\n        ChainedStruct const * nextInChain = nullptr;\n        TextureFormat format;\n        BlendState const * blend = nullptr;\n        ColorWriteMask writeMask = ColorWriteMask::All;\n    };\n\n    struct ComputePipelineDescriptor {\n        ChainedStruct const * nextInChain = nullptr;\n        char const * label = nullptr;\n        PipelineLayout layout = nullptr;\n        ProgrammableStageDescriptor compute;\n    };\n\n    struct DeviceDescriptor {\n        ChainedStruct const * nextInChain = nullptr;\n        char const * label = nullptr;\n        size_t requiredFeaturesCount = 0;\n        FeatureName const * requiredFeatures = nullptr;\n        RequiredLimits const * requiredLimits = nullptr;\n        QueueDescriptor defaultQueue;\n        DeviceLostCallback deviceLostCallback = nullptr;\n        void * deviceLostUserdata = nullptr;\n    };\n\n    struct RenderPassDescriptor {\n        ChainedStruct const * nextInChain = nullptr;\n        char const * label = nullptr;\n        size_t colorAttachmentCount;\n        RenderPassColorAttachment const * colorAttachments;\n        RenderPassDepthStencilAttachment const * depthStencilAttachment = nullptr;\n        QuerySet occlusionQuerySet = nullptr;\n        size_t timestampWriteCount = 0;\n        RenderPassTimestampWrite const * timestampWrites;\n    };\n\n    struct VertexState {\n        ChainedStruct const * nextInChain = nullptr;\n        ShaderModule module;\n        char const * entryPoint;\n        size_t constantCount = 0;\n        ConstantEntry const * constants;\n        size_t bufferCount = 0;\n        VertexBufferLayout const * buffers;\n    };\n\n    struct FragmentState {\n        ChainedStruct const * nextInChain = nullptr;\n        ShaderModule module;\n        char const * entryPoint;\n        size_t constantCount = 0;\n        ConstantEntry const * constants;\n        size_t targetCount;\n        ColorTargetState const * targets;\n    };\n\n    struct RenderPipelineDescriptor {\n        ChainedStruct const * nextInChain = nullptr;\n        char const * label = nullptr;\n        PipelineLayout layout = nullptr;\n        VertexState vertex;\n        PrimitiveState primitive;\n        DepthStencilState const * depthStencil = nullptr;\n        MultisampleState multisample;\n        FragmentState const * fragment = nullptr;\n    };\n\n\n    // The operators of EnumClassBitmmasks in the dawn:: namespace need to be imported\n    // in the wgpu namespace for Argument Dependent Lookup.\n    DAWN_IMPORT_BITMASK_OPERATORS\n}  // namespace wgpu\n\nnamespace dawn {\n    template<>\n    struct IsDawnBitmask<wgpu::BufferUsage> {\n        static constexpr bool enable = true;\n    };\n\n    template<>\n    struct IsDawnBitmask<wgpu::ColorWriteMask> {\n        static constexpr bool enable = true;\n    };\n\n    template<>\n    struct IsDawnBitmask<wgpu::MapMode> {\n        static constexpr bool enable = true;\n    };\n\n    template<>\n    struct IsDawnBitmask<wgpu::ShaderStage> {\n        static constexpr bool enable = true;\n    };\n\n    template<>\n    struct IsDawnBitmask<wgpu::TextureUsage> {\n        static constexpr bool enable = true;\n    };\n\n} // namespace dawn\n\n#endif // WEBGPU_CPP_H_\n", "emscripten-bits/webgpu_cpp.cpp": "#include \"webgpu/webgpu_cpp.h\"\n\n#ifdef __GNUC__\n// error: 'offsetof' within non-standard-layout type 'wgpu::XXX' is conditionally-supported\n#pragma GCC diagnostic ignored \"-Winvalid-offsetof\"\n#endif\n\nnamespace wgpu {\n\n    // AdapterType\n\n    static_assert(sizeof(AdapterType) == sizeof(WGPUAdapterType), \"sizeof mismatch for AdapterType\");\n    static_assert(alignof(AdapterType) == alignof(WGPUAdapterType), \"alignof mismatch for AdapterType\");\n\n    static_assert(static_cast<uint32_t>(AdapterType::DiscreteGPU) == WGPUAdapterType_DiscreteGPU, \"value mismatch for AdapterType::DiscreteGPU\");\n    static_assert(static_cast<uint32_t>(AdapterType::IntegratedGPU) == WGPUAdapterType_IntegratedGPU, \"value mismatch for AdapterType::IntegratedGPU\");\n    static_assert(static_cast<uint32_t>(AdapterType::CPU) == WGPUAdapterType_CPU, \"value mismatch for AdapterType::CPU\");\n    static_assert(static_cast<uint32_t>(AdapterType::Unknown) == WGPUAdapterType_Unknown, \"value mismatch for AdapterType::Unknown\");\n\n    // AddressMode\n\n    static_assert(sizeof(AddressMode) == sizeof(WGPUAddressMode), \"sizeof mismatch for AddressMode\");\n    static_assert(alignof(AddressMode) == alignof(WGPUAddressMode), \"alignof mismatch for AddressMode\");\n\n    static_assert(static_cast<uint32_t>(AddressMode::Repeat) == WGPUAddressMode_Repeat, \"value mismatch for AddressMode::Repeat\");\n    static_assert(static_cast<uint32_t>(AddressMode::MirrorRepeat) == WGPUAddressMode_MirrorRepeat, \"value mismatch for AddressMode::MirrorRepeat\");\n    static_assert(static_cast<uint32_t>(AddressMode::ClampToEdge) == WGPUAddressMode_ClampToEdge, \"value mismatch for AddressMode::ClampToEdge\");\n\n    // BackendType\n\n    static_assert(sizeof(BackendType) == sizeof(WGPUBackendType), \"sizeof mismatch for BackendType\");\n    static_assert(alignof(BackendType) == alignof(WGPUBackendType), \"alignof mismatch for BackendType\");\n\n    static_assert(static_cast<uint32_t>(BackendType::Undefined) == WGPUBackendType_Undefined, \"value mismatch for BackendType::Undefined\");\n    static_assert(static_cast<uint32_t>(BackendType::Null) == WGPUBackendType_Null, \"value mismatch for BackendType::Null\");\n    static_assert(static_cast<uint32_t>(BackendType::WebGPU) == WGPUBackendType_WebGPU, \"value mismatch for BackendType::WebGPU\");\n    static_assert(static_cast<uint32_t>(BackendType::D3D11) == WGPUBackendType_D3D11, \"value mismatch for BackendType::D3D11\");\n    static_assert(static_cast<uint32_t>(BackendType::D3D12) == WGPUBackendType_D3D12, \"value mismatch for BackendType::D3D12\");\n    static_assert(static_cast<uint32_t>(BackendType::Metal) == WGPUBackendType_Metal, \"value mismatch for BackendType::Metal\");\n    static_assert(static_cast<uint32_t>(BackendType::Vulkan) == WGPUBackendType_Vulkan, \"value mismatch for BackendType::Vulkan\");\n    static_assert(static_cast<uint32_t>(BackendType::OpenGL) == WGPUBackendType_OpenGL, \"value mismatch for BackendType::OpenGL\");\n    static_assert(static_cast<uint32_t>(BackendType::OpenGLES) == WGPUBackendType_OpenGLES, \"value mismatch for BackendType::OpenGLES\");\n\n    // BlendFactor\n\n    static_assert(sizeof(BlendFactor) == sizeof(WGPUBlendFactor), \"sizeof mismatch for BlendFactor\");\n    static_assert(alignof(BlendFactor) == alignof(WGPUBlendFactor), \"alignof mismatch for BlendFactor\");\n\n    static_assert(static_cast<uint32_t>(BlendFactor::Zero) == WGPUBlendFactor_Zero, \"value mismatch for BlendFactor::Zero\");\n    static_assert(static_cast<uint32_t>(BlendFactor::One) == WGPUBlendFactor_One, \"value mismatch for BlendFactor::One\");\n    static_assert(static_cast<uint32_t>(BlendFactor::Src) == WGPUBlendFactor_Src, \"value mismatch for BlendFactor::Src\");\n    static_assert(static_cast<uint32_t>(BlendFactor::OneMinusSrc) == WGPUBlendFactor_OneMinusSrc, \"value mismatch for BlendFactor::OneMinusSrc\");\n    static_assert(static_cast<uint32_t>(BlendFactor::SrcAlpha) == WGPUBlendFactor_SrcAlpha, \"value mismatch for BlendFactor::SrcAlpha\");\n    static_assert(static_cast<uint32_t>(BlendFactor::OneMinusSrcAlpha) == WGPUBlendFactor_OneMinusSrcAlpha, \"value mismatch for BlendFactor::OneMinusSrcAlpha\");\n    static_assert(static_cast<uint32_t>(BlendFactor::Dst) == WGPUBlendFactor_Dst, \"value mismatch for BlendFactor::Dst\");\n    static_assert(static_cast<uint32_t>(BlendFactor::OneMinusDst) == WGPUBlendFactor_OneMinusDst, \"value mismatch for BlendFactor::OneMinusDst\");\n    static_assert(static_cast<uint32_t>(BlendFactor::DstAlpha) == WGPUBlendFactor_DstAlpha, \"value mismatch for BlendFactor::DstAlpha\");\n    static_assert(static_cast<uint32_t>(BlendFactor::OneMinusDstAlpha) == WGPUBlendFactor_OneMinusDstAlpha, \"value mismatch for BlendFactor::OneMinusDstAlpha\");\n    static_assert(static_cast<uint32_t>(BlendFactor::SrcAlphaSaturated) == WGPUBlendFactor_SrcAlphaSaturated, \"value mismatch for BlendFactor::SrcAlphaSaturated\");\n    static_assert(static_cast<uint32_t>(BlendFactor::Constant) == WGPUBlendFactor_Constant, \"value mismatch for BlendFactor::Constant\");\n    static_assert(static_cast<uint32_t>(BlendFactor::OneMinusConstant) == WGPUBlendFactor_OneMinusConstant, \"value mismatch for BlendFactor::OneMinusConstant\");\n\n    // BlendOperation\n\n    static_assert(sizeof(BlendOperation) == sizeof(WGPUBlendOperation), \"sizeof mismatch for BlendOperation\");\n    static_assert(alignof(BlendOperation) == alignof(WGPUBlendOperation), \"alignof mismatch for BlendOperation\");\n\n    static_assert(static_cast<uint32_t>(BlendOperation::Add) == WGPUBlendOperation_Add, \"value mismatch for BlendOperation::Add\");\n    static_assert(static_cast<uint32_t>(BlendOperation::Subtract) == WGPUBlendOperation_Subtract, \"value mismatch for BlendOperation::Subtract\");\n    static_assert(static_cast<uint32_t>(BlendOperation::ReverseSubtract) == WGPUBlendOperation_ReverseSubtract, \"value mismatch for BlendOperation::ReverseSubtract\");\n    static_assert(static_cast<uint32_t>(BlendOperation::Min) == WGPUBlendOperation_Min, \"value mismatch for BlendOperation::Min\");\n    static_assert(static_cast<uint32_t>(BlendOperation::Max) == WGPUBlendOperation_Max, \"value mismatch for BlendOperation::Max\");\n\n    // BufferBindingType\n\n    static_assert(sizeof(BufferBindingType) == sizeof(WGPUBufferBindingType), \"sizeof mismatch for BufferBindingType\");\n    static_assert(alignof(BufferBindingType) == alignof(WGPUBufferBindingType), \"alignof mismatch for BufferBindingType\");\n\n    static_assert(static_cast<uint32_t>(BufferBindingType::Undefined) == WGPUBufferBindingType_Undefined, \"value mismatch for BufferBindingType::Undefined\");\n    static_assert(static_cast<uint32_t>(BufferBindingType::Uniform) == WGPUBufferBindingType_Uniform, \"value mismatch for BufferBindingType::Uniform\");\n    static_assert(static_cast<uint32_t>(BufferBindingType::Storage) == WGPUBufferBindingType_Storage, \"value mismatch for BufferBindingType::Storage\");\n    static_assert(static_cast<uint32_t>(BufferBindingType::ReadOnlyStorage) == WGPUBufferBindingType_ReadOnlyStorage, \"value mismatch for BufferBindingType::ReadOnlyStorage\");\n\n    // BufferMapAsyncStatus\n\n    static_assert(sizeof(BufferMapAsyncStatus) == sizeof(WGPUBufferMapAsyncStatus), \"sizeof mismatch for BufferMapAsyncStatus\");\n    static_assert(alignof(BufferMapAsyncStatus) == alignof(WGPUBufferMapAsyncStatus), \"alignof mismatch for BufferMapAsyncStatus\");\n\n    static_assert(static_cast<uint32_t>(BufferMapAsyncStatus::Success) == WGPUBufferMapAsyncStatus_Success, \"value mismatch for BufferMapAsyncStatus::Success\");\n    static_assert(static_cast<uint32_t>(BufferMapAsyncStatus::ValidationError) == WGPUBufferMapAsyncStatus_ValidationError, \"value mismatch for BufferMapAsyncStatus::ValidationError\");\n    static_assert(static_cast<uint32_t>(BufferMapAsyncStatus::Unknown) == WGPUBufferMapAsyncStatus_Unknown, \"value mismatch for BufferMapAsyncStatus::Unknown\");\n    static_assert(static_cast<uint32_t>(BufferMapAsyncStatus::DeviceLost) == WGPUBufferMapAsyncStatus_DeviceLost, \"value mismatch for BufferMapAsyncStatus::DeviceLost\");\n    static_assert(static_cast<uint32_t>(BufferMapAsyncStatus::DestroyedBeforeCallback) == WGPUBufferMapAsyncStatus_DestroyedBeforeCallback, \"value mismatch for BufferMapAsyncStatus::DestroyedBeforeCallback\");\n    static_assert(static_cast<uint32_t>(BufferMapAsyncStatus::UnmappedBeforeCallback) == WGPUBufferMapAsyncStatus_UnmappedBeforeCallback, \"value mismatch for BufferMapAsyncStatus::UnmappedBeforeCallback\");\n    static_assert(static_cast<uint32_t>(BufferMapAsyncStatus::MappingAlreadyPending) == WGPUBufferMapAsyncStatus_MappingAlreadyPending, \"value mismatch for BufferMapAsyncStatus::MappingAlreadyPending\");\n    static_assert(static_cast<uint32_t>(BufferMapAsyncStatus::OffsetOutOfRange) == WGPUBufferMapAsyncStatus_OffsetOutOfRange, \"value mismatch for BufferMapAsyncStatus::OffsetOutOfRange\");\n    static_assert(static_cast<uint32_t>(BufferMapAsyncStatus::SizeOutOfRange) == WGPUBufferMapAsyncStatus_SizeOutOfRange, \"value mismatch for BufferMapAsyncStatus::SizeOutOfRange\");\n\n    // BufferMapState\n\n    static_assert(sizeof(BufferMapState) == sizeof(WGPUBufferMapState), \"sizeof mismatch for BufferMapState\");\n    static_assert(alignof(BufferMapState) == alignof(WGPUBufferMapState), \"alignof mismatch for BufferMapState\");\n\n    static_assert(static_cast<uint32_t>(BufferMapState::Unmapped) == WGPUBufferMapState_Unmapped, \"value mismatch for BufferMapState::Unmapped\");\n    static_assert(static_cast<uint32_t>(BufferMapState::Pending) == WGPUBufferMapState_Pending, \"value mismatch for BufferMapState::Pending\");\n    static_assert(static_cast<uint32_t>(BufferMapState::Mapped) == WGPUBufferMapState_Mapped, \"value mismatch for BufferMapState::Mapped\");\n\n    // CompareFunction\n\n    static_assert(sizeof(CompareFunction) == sizeof(WGPUCompareFunction), \"sizeof mismatch for CompareFunction\");\n    static_assert(alignof(CompareFunction) == alignof(WGPUCompareFunction), \"alignof mismatch for CompareFunction\");\n\n    static_assert(static_cast<uint32_t>(CompareFunction::Undefined) == WGPUCompareFunction_Undefined, \"value mismatch for CompareFunction::Undefined\");\n    static_assert(static_cast<uint32_t>(CompareFunction::Never) == WGPUCompareFunction_Never, \"value mismatch for CompareFunction::Never\");\n    static_assert(static_cast<uint32_t>(CompareFunction::Less) == WGPUCompareFunction_Less, \"value mismatch for CompareFunction::Less\");\n    static_assert(static_cast<uint32_t>(CompareFunction::LessEqual) == WGPUCompareFunction_LessEqual, \"value mismatch for CompareFunction::LessEqual\");\n    static_assert(static_cast<uint32_t>(CompareFunction::Greater) == WGPUCompareFunction_Greater, \"value mismatch for CompareFunction::Greater\");\n    static_assert(static_cast<uint32_t>(CompareFunction::GreaterEqual) == WGPUCompareFunction_GreaterEqual, \"value mismatch for CompareFunction::GreaterEqual\");\n    static_assert(static_cast<uint32_t>(CompareFunction::Equal) == WGPUCompareFunction_Equal, \"value mismatch for CompareFunction::Equal\");\n    static_assert(static_cast<uint32_t>(CompareFunction::NotEqual) == WGPUCompareFunction_NotEqual, \"value mismatch for CompareFunction::NotEqual\");\n    static_assert(static_cast<uint32_t>(CompareFunction::Always) == WGPUCompareFunction_Always, \"value mismatch for CompareFunction::Always\");\n\n    // CompilationInfoRequestStatus\n\n    static_assert(sizeof(CompilationInfoRequestStatus) == sizeof(WGPUCompilationInfoRequestStatus), \"sizeof mismatch for CompilationInfoRequestStatus\");\n    static_assert(alignof(CompilationInfoRequestStatus) == alignof(WGPUCompilationInfoRequestStatus), \"alignof mismatch for CompilationInfoRequestStatus\");\n\n    static_assert(static_cast<uint32_t>(CompilationInfoRequestStatus::Success) == WGPUCompilationInfoRequestStatus_Success, \"value mismatch for CompilationInfoRequestStatus::Success\");\n    static_assert(static_cast<uint32_t>(CompilationInfoRequestStatus::Error) == WGPUCompilationInfoRequestStatus_Error, \"value mismatch for CompilationInfoRequestStatus::Error\");\n    static_assert(static_cast<uint32_t>(CompilationInfoRequestStatus::DeviceLost) == WGPUCompilationInfoRequestStatus_DeviceLost, \"value mismatch for CompilationInfoRequestStatus::DeviceLost\");\n    static_assert(static_cast<uint32_t>(CompilationInfoRequestStatus::Unknown) == WGPUCompilationInfoRequestStatus_Unknown, \"value mismatch for CompilationInfoRequestStatus::Unknown\");\n\n    // CompilationMessageType\n\n    static_assert(sizeof(CompilationMessageType) == sizeof(WGPUCompilationMessageType), \"sizeof mismatch for CompilationMessageType\");\n    static_assert(alignof(CompilationMessageType) == alignof(WGPUCompilationMessageType), \"alignof mismatch for CompilationMessageType\");\n\n    static_assert(static_cast<uint32_t>(CompilationMessageType::Error) == WGPUCompilationMessageType_Error, \"value mismatch for CompilationMessageType::Error\");\n    static_assert(static_cast<uint32_t>(CompilationMessageType::Warning) == WGPUCompilationMessageType_Warning, \"value mismatch for CompilationMessageType::Warning\");\n    static_assert(static_cast<uint32_t>(CompilationMessageType::Info) == WGPUCompilationMessageType_Info, \"value mismatch for CompilationMessageType::Info\");\n\n    // ComputePassTimestampLocation\n\n    static_assert(sizeof(ComputePassTimestampLocation) == sizeof(WGPUComputePassTimestampLocation), \"sizeof mismatch for ComputePassTimestampLocation\");\n    static_assert(alignof(ComputePassTimestampLocation) == alignof(WGPUComputePassTimestampLocation), \"alignof mismatch for ComputePassTimestampLocation\");\n\n    static_assert(static_cast<uint32_t>(ComputePassTimestampLocation::Beginning) == WGPUComputePassTimestampLocation_Beginning, \"value mismatch for ComputePassTimestampLocation::Beginning\");\n    static_assert(static_cast<uint32_t>(ComputePassTimestampLocation::End) == WGPUComputePassTimestampLocation_End, \"value mismatch for ComputePassTimestampLocation::End\");\n\n    // CreatePipelineAsyncStatus\n\n    static_assert(sizeof(CreatePipelineAsyncStatus) == sizeof(WGPUCreatePipelineAsyncStatus), \"sizeof mismatch for CreatePipelineAsyncStatus\");\n    static_assert(alignof(CreatePipelineAsyncStatus) == alignof(WGPUCreatePipelineAsyncStatus), \"alignof mismatch for CreatePipelineAsyncStatus\");\n\n    static_assert(static_cast<uint32_t>(CreatePipelineAsyncStatus::Success) == WGPUCreatePipelineAsyncStatus_Success, \"value mismatch for CreatePipelineAsyncStatus::Success\");\n    static_assert(static_cast<uint32_t>(CreatePipelineAsyncStatus::ValidationError) == WGPUCreatePipelineAsyncStatus_ValidationError, \"value mismatch for CreatePipelineAsyncStatus::ValidationError\");\n    static_assert(static_cast<uint32_t>(CreatePipelineAsyncStatus::InternalError) == WGPUCreatePipelineAsyncStatus_InternalError, \"value mismatch for CreatePipelineAsyncStatus::InternalError\");\n    static_assert(static_cast<uint32_t>(CreatePipelineAsyncStatus::DeviceLost) == WGPUCreatePipelineAsyncStatus_DeviceLost, \"value mismatch for CreatePipelineAsyncStatus::DeviceLost\");\n    static_assert(static_cast<uint32_t>(CreatePipelineAsyncStatus::DeviceDestroyed) == WGPUCreatePipelineAsyncStatus_DeviceDestroyed, \"value mismatch for CreatePipelineAsyncStatus::DeviceDestroyed\");\n    static_assert(static_cast<uint32_t>(CreatePipelineAsyncStatus::Unknown) == WGPUCreatePipelineAsyncStatus_Unknown, \"value mismatch for CreatePipelineAsyncStatus::Unknown\");\n\n    // CullMode\n\n    static_assert(sizeof(CullMode) == sizeof(WGPUCullMode), \"sizeof mismatch for CullMode\");\n    static_assert(alignof(CullMode) == alignof(WGPUCullMode), \"alignof mismatch for CullMode\");\n\n    static_assert(static_cast<uint32_t>(CullMode::None) == WGPUCullMode_None, \"value mismatch for CullMode::None\");\n    static_assert(static_cast<uint32_t>(CullMode::Front) == WGPUCullMode_Front, \"value mismatch for CullMode::Front\");\n    static_assert(static_cast<uint32_t>(CullMode::Back) == WGPUCullMode_Back, \"value mismatch for CullMode::Back\");\n\n    // DeviceLostReason\n\n    static_assert(sizeof(DeviceLostReason) == sizeof(WGPUDeviceLostReason), \"sizeof mismatch for DeviceLostReason\");\n    static_assert(alignof(DeviceLostReason) == alignof(WGPUDeviceLostReason), \"alignof mismatch for DeviceLostReason\");\n\n    static_assert(static_cast<uint32_t>(DeviceLostReason::Undefined) == WGPUDeviceLostReason_Undefined, \"value mismatch for DeviceLostReason::Undefined\");\n    static_assert(static_cast<uint32_t>(DeviceLostReason::Destroyed) == WGPUDeviceLostReason_Destroyed, \"value mismatch for DeviceLostReason::Destroyed\");\n\n    // ErrorFilter\n\n    static_assert(sizeof(ErrorFilter) == sizeof(WGPUErrorFilter), \"sizeof mismatch for ErrorFilter\");\n    static_assert(alignof(ErrorFilter) == alignof(WGPUErrorFilter), \"alignof mismatch for ErrorFilter\");\n\n    static_assert(static_cast<uint32_t>(ErrorFilter::Validation) == WGPUErrorFilter_Validation, \"value mismatch for ErrorFilter::Validation\");\n    static_assert(static_cast<uint32_t>(ErrorFilter::OutOfMemory) == WGPUErrorFilter_OutOfMemory, \"value mismatch for ErrorFilter::OutOfMemory\");\n    static_assert(static_cast<uint32_t>(ErrorFilter::Internal) == WGPUErrorFilter_Internal, \"value mismatch for ErrorFilter::Internal\");\n\n    // ErrorType\n\n    static_assert(sizeof(ErrorType) == sizeof(WGPUErrorType), \"sizeof mismatch for ErrorType\");\n    static_assert(alignof(ErrorType) == alignof(WGPUErrorType), \"alignof mismatch for ErrorType\");\n\n    static_assert(static_cast<uint32_t>(ErrorType::NoError) == WGPUErrorType_NoError, \"value mismatch for ErrorType::NoError\");\n    static_assert(static_cast<uint32_t>(ErrorType::Validation) == WGPUErrorType_Validation, \"value mismatch for ErrorType::Validation\");\n    static_assert(static_cast<uint32_t>(ErrorType::OutOfMemory) == WGPUErrorType_OutOfMemory, \"value mismatch for ErrorType::OutOfMemory\");\n    static_assert(static_cast<uint32_t>(ErrorType::Internal) == WGPUErrorType_Internal, \"value mismatch for ErrorType::Internal\");\n    static_assert(static_cast<uint32_t>(ErrorType::Unknown) == WGPUErrorType_Unknown, \"value mismatch for ErrorType::Unknown\");\n    static_assert(static_cast<uint32_t>(ErrorType::DeviceLost) == WGPUErrorType_DeviceLost, \"value mismatch for ErrorType::DeviceLost\");\n\n    // FeatureName\n\n    static_assert(sizeof(FeatureName) == sizeof(WGPUFeatureName), \"sizeof mismatch for FeatureName\");\n    static_assert(alignof(FeatureName) == alignof(WGPUFeatureName), \"alignof mismatch for FeatureName\");\n\n    static_assert(static_cast<uint32_t>(FeatureName::Undefined) == WGPUFeatureName_Undefined, \"value mismatch for FeatureName::Undefined\");\n    static_assert(static_cast<uint32_t>(FeatureName::DepthClipControl) == WGPUFeatureName_DepthClipControl, \"value mismatch for FeatureName::DepthClipControl\");\n    static_assert(static_cast<uint32_t>(FeatureName::Depth32FloatStencil8) == WGPUFeatureName_Depth32FloatStencil8, \"value mismatch for FeatureName::Depth32FloatStencil8\");\n    static_assert(static_cast<uint32_t>(FeatureName::TimestampQuery) == WGPUFeatureName_TimestampQuery, \"value mismatch for FeatureName::TimestampQuery\");\n    static_assert(static_cast<uint32_t>(FeatureName::PipelineStatisticsQuery) == WGPUFeatureName_PipelineStatisticsQuery, \"value mismatch for FeatureName::PipelineStatisticsQuery\");\n    static_assert(static_cast<uint32_t>(FeatureName::TextureCompressionBC) == WGPUFeatureName_TextureCompressionBC, \"value mismatch for FeatureName::TextureCompressionBC\");\n    static_assert(static_cast<uint32_t>(FeatureName::TextureCompressionETC2) == WGPUFeatureName_TextureCompressionETC2, \"value mismatch for FeatureName::TextureCompressionETC2\");\n    static_assert(static_cast<uint32_t>(FeatureName::TextureCompressionASTC) == WGPUFeatureName_TextureCompressionASTC, \"value mismatch for FeatureName::TextureCompressionASTC\");\n    static_assert(static_cast<uint32_t>(FeatureName::IndirectFirstInstance) == WGPUFeatureName_IndirectFirstInstance, \"value mismatch for FeatureName::IndirectFirstInstance\");\n    static_assert(static_cast<uint32_t>(FeatureName::ShaderF16) == WGPUFeatureName_ShaderF16, \"value mismatch for FeatureName::ShaderF16\");\n    static_assert(static_cast<uint32_t>(FeatureName::RG11B10UfloatRenderable) == WGPUFeatureName_RG11B10UfloatRenderable, \"value mismatch for FeatureName::RG11B10UfloatRenderable\");\n    static_assert(static_cast<uint32_t>(FeatureName::BGRA8UnormStorage) == WGPUFeatureName_BGRA8UnormStorage, \"value mismatch for FeatureName::BGRA8UnormStorage\");\n    static_assert(static_cast<uint32_t>(FeatureName::Float32Filterable) == WGPUFeatureName_Float32Filterable, \"value mismatch for FeatureName::Float32Filterable\");\n\n    // FilterMode\n\n    static_assert(sizeof(FilterMode) == sizeof(WGPUFilterMode), \"sizeof mismatch for FilterMode\");\n    static_assert(alignof(FilterMode) == alignof(WGPUFilterMode), \"alignof mismatch for FilterMode\");\n\n    static_assert(static_cast<uint32_t>(FilterMode::Nearest) == WGPUFilterMode_Nearest, \"value mismatch for FilterMode::Nearest\");\n    static_assert(static_cast<uint32_t>(FilterMode::Linear) == WGPUFilterMode_Linear, \"value mismatch for FilterMode::Linear\");\n\n    // FrontFace\n\n    static_assert(sizeof(FrontFace) == sizeof(WGPUFrontFace), \"sizeof mismatch for FrontFace\");\n    static_assert(alignof(FrontFace) == alignof(WGPUFrontFace), \"alignof mismatch for FrontFace\");\n\n    static_assert(static_cast<uint32_t>(FrontFace::CCW) == WGPUFrontFace_CCW, \"value mismatch for FrontFace::CCW\");\n    static_assert(static_cast<uint32_t>(FrontFace::CW) == WGPUFrontFace_CW, \"value mismatch for FrontFace::CW\");\n\n    // IndexFormat\n\n    static_assert(sizeof(IndexFormat) == sizeof(WGPUIndexFormat), \"sizeof mismatch for IndexFormat\");\n    static_assert(alignof(IndexFormat) == alignof(WGPUIndexFormat), \"alignof mismatch for IndexFormat\");\n\n    static_assert(static_cast<uint32_t>(IndexFormat::Undefined) == WGPUIndexFormat_Undefined, \"value mismatch for IndexFormat::Undefined\");\n    static_assert(static_cast<uint32_t>(IndexFormat::Uint16) == WGPUIndexFormat_Uint16, \"value mismatch for IndexFormat::Uint16\");\n    static_assert(static_cast<uint32_t>(IndexFormat::Uint32) == WGPUIndexFormat_Uint32, \"value mismatch for IndexFormat::Uint32\");\n\n    // LoadOp\n\n    static_assert(sizeof(LoadOp) == sizeof(WGPULoadOp), \"sizeof mismatch for LoadOp\");\n    static_assert(alignof(LoadOp) == alignof(WGPULoadOp), \"alignof mismatch for LoadOp\");\n\n    static_assert(static_cast<uint32_t>(LoadOp::Undefined) == WGPULoadOp_Undefined, \"value mismatch for LoadOp::Undefined\");\n    static_assert(static_cast<uint32_t>(LoadOp::Clear) == WGPULoadOp_Clear, \"value mismatch for LoadOp::Clear\");\n    static_assert(static_cast<uint32_t>(LoadOp::Load) == WGPULoadOp_Load, \"value mismatch for LoadOp::Load\");\n\n    // MipmapFilterMode\n\n    static_assert(sizeof(MipmapFilterMode) == sizeof(WGPUMipmapFilterMode), \"sizeof mismatch for MipmapFilterMode\");\n    static_assert(alignof(MipmapFilterMode) == alignof(WGPUMipmapFilterMode), \"alignof mismatch for MipmapFilterMode\");\n\n    static_assert(static_cast<uint32_t>(MipmapFilterMode::Nearest) == WGPUMipmapFilterMode_Nearest, \"value mismatch for MipmapFilterMode::Nearest\");\n    static_assert(static_cast<uint32_t>(MipmapFilterMode::Linear) == WGPUMipmapFilterMode_Linear, \"value mismatch for MipmapFilterMode::Linear\");\n\n    // PipelineStatisticName\n\n    static_assert(sizeof(PipelineStatisticName) == sizeof(WGPUPipelineStatisticName), \"sizeof mismatch for PipelineStatisticName\");\n    static_assert(alignof(PipelineStatisticName) == alignof(WGPUPipelineStatisticName), \"alignof mismatch for PipelineStatisticName\");\n\n    static_assert(static_cast<uint32_t>(PipelineStatisticName::VertexShaderInvocations) == WGPUPipelineStatisticName_VertexShaderInvocations, \"value mismatch for PipelineStatisticName::VertexShaderInvocations\");\n    static_assert(static_cast<uint32_t>(PipelineStatisticName::ClipperInvocations) == WGPUPipelineStatisticName_ClipperInvocations, \"value mismatch for PipelineStatisticName::ClipperInvocations\");\n    static_assert(static_cast<uint32_t>(PipelineStatisticName::ClipperPrimitivesOut) == WGPUPipelineStatisticName_ClipperPrimitivesOut, \"value mismatch for PipelineStatisticName::ClipperPrimitivesOut\");\n    static_assert(static_cast<uint32_t>(PipelineStatisticName::FragmentShaderInvocations) == WGPUPipelineStatisticName_FragmentShaderInvocations, \"value mismatch for PipelineStatisticName::FragmentShaderInvocations\");\n    static_assert(static_cast<uint32_t>(PipelineStatisticName::ComputeShaderInvocations) == WGPUPipelineStatisticName_ComputeShaderInvocations, \"value mismatch for PipelineStatisticName::ComputeShaderInvocations\");\n\n    // PowerPreference\n\n    static_assert(sizeof(PowerPreference) == sizeof(WGPUPowerPreference), \"sizeof mismatch for PowerPreference\");\n    static_assert(alignof(PowerPreference) == alignof(WGPUPowerPreference), \"alignof mismatch for PowerPreference\");\n\n    static_assert(static_cast<uint32_t>(PowerPreference::Undefined) == WGPUPowerPreference_Undefined, \"value mismatch for PowerPreference::Undefined\");\n    static_assert(static_cast<uint32_t>(PowerPreference::LowPower) == WGPUPowerPreference_LowPower, \"value mismatch for PowerPreference::LowPower\");\n    static_assert(static_cast<uint32_t>(PowerPreference::HighPerformance) == WGPUPowerPreference_HighPerformance, \"value mismatch for PowerPreference::HighPerformance\");\n\n    // PresentMode\n\n    static_assert(sizeof(PresentMode) == sizeof(WGPUPresentMode), \"sizeof mismatch for PresentMode\");\n    static_assert(alignof(PresentMode) == alignof(WGPUPresentMode), \"alignof mismatch for PresentMode\");\n\n    static_assert(static_cast<uint32_t>(PresentMode::Immediate) == WGPUPresentMode_Immediate, \"value mismatch for PresentMode::Immediate\");\n    static_assert(static_cast<uint32_t>(PresentMode::Mailbox) == WGPUPresentMode_Mailbox, \"value mismatch for PresentMode::Mailbox\");\n    static_assert(static_cast<uint32_t>(PresentMode::Fifo) == WGPUPresentMode_Fifo, \"value mismatch for PresentMode::Fifo\");\n\n    // PrimitiveTopology\n\n    static_assert(sizeof(PrimitiveTopology) == sizeof(WGPUPrimitiveTopology), \"sizeof mismatch for PrimitiveTopology\");\n    static_assert(alignof(PrimitiveTopology) == alignof(WGPUPrimitiveTopology), \"alignof mismatch for PrimitiveTopology\");\n\n    static_assert(static_cast<uint32_t>(PrimitiveTopology::PointList) == WGPUPrimitiveTopology_PointList, \"value mismatch for PrimitiveTopology::PointList\");\n    static_assert(static_cast<uint32_t>(PrimitiveTopology::LineList) == WGPUPrimitiveTopology_LineList, \"value mismatch for PrimitiveTopology::LineList\");\n    static_assert(static_cast<uint32_t>(PrimitiveTopology::LineStrip) == WGPUPrimitiveTopology_LineStrip, \"value mismatch for PrimitiveTopology::LineStrip\");\n    static_assert(static_cast<uint32_t>(PrimitiveTopology::TriangleList) == WGPUPrimitiveTopology_TriangleList, \"value mismatch for PrimitiveTopology::TriangleList\");\n    static_assert(static_cast<uint32_t>(PrimitiveTopology::TriangleStrip) == WGPUPrimitiveTopology_TriangleStrip, \"value mismatch for PrimitiveTopology::TriangleStrip\");\n\n    // QueryType\n\n    static_assert(sizeof(QueryType) == sizeof(WGPUQueryType), \"sizeof mismatch for QueryType\");\n    static_assert(alignof(QueryType) == alignof(WGPUQueryType), \"alignof mismatch for QueryType\");\n\n    static_assert(static_cast<uint32_t>(QueryType::Occlusion) == WGPUQueryType_Occlusion, \"value mismatch for QueryType::Occlusion\");\n    static_assert(static_cast<uint32_t>(QueryType::PipelineStatistics) == WGPUQueryType_PipelineStatistics, \"value mismatch for QueryType::PipelineStatistics\");\n    static_assert(static_cast<uint32_t>(QueryType::Timestamp) == WGPUQueryType_Timestamp, \"value mismatch for QueryType::Timestamp\");\n\n    // QueueWorkDoneStatus\n\n    static_assert(sizeof(QueueWorkDoneStatus) == sizeof(WGPUQueueWorkDoneStatus), \"sizeof mismatch for QueueWorkDoneStatus\");\n    static_assert(alignof(QueueWorkDoneStatus) == alignof(WGPUQueueWorkDoneStatus), \"alignof mismatch for QueueWorkDoneStatus\");\n\n    static_assert(static_cast<uint32_t>(QueueWorkDoneStatus::Success) == WGPUQueueWorkDoneStatus_Success, \"value mismatch for QueueWorkDoneStatus::Success\");\n    static_assert(static_cast<uint32_t>(QueueWorkDoneStatus::Error) == WGPUQueueWorkDoneStatus_Error, \"value mismatch for QueueWorkDoneStatus::Error\");\n    static_assert(static_cast<uint32_t>(QueueWorkDoneStatus::Unknown) == WGPUQueueWorkDoneStatus_Unknown, \"value mismatch for QueueWorkDoneStatus::Unknown\");\n    static_assert(static_cast<uint32_t>(QueueWorkDoneStatus::DeviceLost) == WGPUQueueWorkDoneStatus_DeviceLost, \"value mismatch for QueueWorkDoneStatus::DeviceLost\");\n\n    // RenderPassTimestampLocation\n\n    static_assert(sizeof(RenderPassTimestampLocation) == sizeof(WGPURenderPassTimestampLocation), \"sizeof mismatch for RenderPassTimestampLocation\");\n    static_assert(alignof(RenderPassTimestampLocation) == alignof(WGPURenderPassTimestampLocation), \"alignof mismatch for RenderPassTimestampLocation\");\n\n    static_assert(static_cast<uint32_t>(RenderPassTimestampLocation::Beginning) == WGPURenderPassTimestampLocation_Beginning, \"value mismatch for RenderPassTimestampLocation::Beginning\");\n    static_assert(static_cast<uint32_t>(RenderPassTimestampLocation::End) == WGPURenderPassTimestampLocation_End, \"value mismatch for RenderPassTimestampLocation::End\");\n\n    // RequestAdapterStatus\n\n    static_assert(sizeof(RequestAdapterStatus) == sizeof(WGPURequestAdapterStatus), \"sizeof mismatch for RequestAdapterStatus\");\n    static_assert(alignof(RequestAdapterStatus) == alignof(WGPURequestAdapterStatus), \"alignof mismatch for RequestAdapterStatus\");\n\n    static_assert(static_cast<uint32_t>(RequestAdapterStatus::Success) == WGPURequestAdapterStatus_Success, \"value mismatch for RequestAdapterStatus::Success\");\n    static_assert(static_cast<uint32_t>(RequestAdapterStatus::Unavailable) == WGPURequestAdapterStatus_Unavailable, \"value mismatch for RequestAdapterStatus::Unavailable\");\n    static_assert(static_cast<uint32_t>(RequestAdapterStatus::Error) == WGPURequestAdapterStatus_Error, \"value mismatch for RequestAdapterStatus::Error\");\n    static_assert(static_cast<uint32_t>(RequestAdapterStatus::Unknown) == WGPURequestAdapterStatus_Unknown, \"value mismatch for RequestAdapterStatus::Unknown\");\n\n    // RequestDeviceStatus\n\n    static_assert(sizeof(RequestDeviceStatus) == sizeof(WGPURequestDeviceStatus), \"sizeof mismatch for RequestDeviceStatus\");\n    static_assert(alignof(RequestDeviceStatus) == alignof(WGPURequestDeviceStatus), \"alignof mismatch for RequestDeviceStatus\");\n\n    static_assert(static_cast<uint32_t>(RequestDeviceStatus::Success) == WGPURequestDeviceStatus_Success, \"value mismatch for RequestDeviceStatus::Success\");\n    static_assert(static_cast<uint32_t>(RequestDeviceStatus::Error) == WGPURequestDeviceStatus_Error, \"value mismatch for RequestDeviceStatus::Error\");\n    static_assert(static_cast<uint32_t>(RequestDeviceStatus::Unknown) == WGPURequestDeviceStatus_Unknown, \"value mismatch for RequestDeviceStatus::Unknown\");\n\n    // SType\n\n    static_assert(sizeof(SType) == sizeof(WGPUSType), \"sizeof mismatch for SType\");\n    static_assert(alignof(SType) == alignof(WGPUSType), \"alignof mismatch for SType\");\n\n    static_assert(static_cast<uint32_t>(SType::Invalid) == WGPUSType_Invalid, \"value mismatch for SType::Invalid\");\n    static_assert(static_cast<uint32_t>(SType::SurfaceDescriptorFromCanvasHTMLSelector) == WGPUSType_SurfaceDescriptorFromCanvasHTMLSelector, \"value mismatch for SType::SurfaceDescriptorFromCanvasHTMLSelector\");\n    static_assert(static_cast<uint32_t>(SType::ShaderModuleSPIRVDescriptor) == WGPUSType_ShaderModuleSPIRVDescriptor, \"value mismatch for SType::ShaderModuleSPIRVDescriptor\");\n    static_assert(static_cast<uint32_t>(SType::ShaderModuleWGSLDescriptor) == WGPUSType_ShaderModuleWGSLDescriptor, \"value mismatch for SType::ShaderModuleWGSLDescriptor\");\n    static_assert(static_cast<uint32_t>(SType::PrimitiveDepthClipControl) == WGPUSType_PrimitiveDepthClipControl, \"value mismatch for SType::PrimitiveDepthClipControl\");\n    static_assert(static_cast<uint32_t>(SType::RenderPassDescriptorMaxDrawCount) == WGPUSType_RenderPassDescriptorMaxDrawCount, \"value mismatch for SType::RenderPassDescriptorMaxDrawCount\");\n\n    // SamplerBindingType\n\n    static_assert(sizeof(SamplerBindingType) == sizeof(WGPUSamplerBindingType), \"sizeof mismatch for SamplerBindingType\");\n    static_assert(alignof(SamplerBindingType) == alignof(WGPUSamplerBindingType), \"alignof mismatch for SamplerBindingType\");\n\n    static_assert(static_cast<uint32_t>(SamplerBindingType::Undefined) == WGPUSamplerBindingType_Undefined, \"value mismatch for SamplerBindingType::Undefined\");\n    static_assert(static_cast<uint32_t>(SamplerBindingType::Filtering) == WGPUSamplerBindingType_Filtering, \"value mismatch for SamplerBindingType::Filtering\");\n    static_assert(static_cast<uint32_t>(SamplerBindingType::NonFiltering) == WGPUSamplerBindingType_NonFiltering, \"value mismatch for SamplerBindingType::NonFiltering\");\n    static_assert(static_cast<uint32_t>(SamplerBindingType::Comparison) == WGPUSamplerBindingType_Comparison, \"value mismatch for SamplerBindingType::Comparison\");\n\n    // StencilOperation\n\n    static_assert(sizeof(StencilOperation) == sizeof(WGPUStencilOperation), \"sizeof mismatch for StencilOperation\");\n    static_assert(alignof(StencilOperation) == alignof(WGPUStencilOperation), \"alignof mismatch for StencilOperation\");\n\n    static_assert(static_cast<uint32_t>(StencilOperation::Keep) == WGPUStencilOperation_Keep, \"value mismatch for StencilOperation::Keep\");\n    static_assert(static_cast<uint32_t>(StencilOperation::Zero) == WGPUStencilOperation_Zero, \"value mismatch for StencilOperation::Zero\");\n    static_assert(static_cast<uint32_t>(StencilOperation::Replace) == WGPUStencilOperation_Replace, \"value mismatch for StencilOperation::Replace\");\n    static_assert(static_cast<uint32_t>(StencilOperation::Invert) == WGPUStencilOperation_Invert, \"value mismatch for StencilOperation::Invert\");\n    static_assert(static_cast<uint32_t>(StencilOperation::IncrementClamp) == WGPUStencilOperation_IncrementClamp, \"value mismatch for StencilOperation::IncrementClamp\");\n    static_assert(static_cast<uint32_t>(StencilOperation::DecrementClamp) == WGPUStencilOperation_DecrementClamp, \"value mismatch for StencilOperation::DecrementClamp\");\n    static_assert(static_cast<uint32_t>(StencilOperation::IncrementWrap) == WGPUStencilOperation_IncrementWrap, \"value mismatch for StencilOperation::IncrementWrap\");\n    static_assert(static_cast<uint32_t>(StencilOperation::DecrementWrap) == WGPUStencilOperation_DecrementWrap, \"value mismatch for StencilOperation::DecrementWrap\");\n\n    // StorageTextureAccess\n\n    static_assert(sizeof(StorageTextureAccess) == sizeof(WGPUStorageTextureAccess), \"sizeof mismatch for StorageTextureAccess\");\n    static_assert(alignof(StorageTextureAccess) == alignof(WGPUStorageTextureAccess), \"alignof mismatch for StorageTextureAccess\");\n\n    static_assert(static_cast<uint32_t>(StorageTextureAccess::Undefined) == WGPUStorageTextureAccess_Undefined, \"value mismatch for StorageTextureAccess::Undefined\");\n    static_assert(static_cast<uint32_t>(StorageTextureAccess::WriteOnly) == WGPUStorageTextureAccess_WriteOnly, \"value mismatch for StorageTextureAccess::WriteOnly\");\n\n    // StoreOp\n\n    static_assert(sizeof(StoreOp) == sizeof(WGPUStoreOp), \"sizeof mismatch for StoreOp\");\n    static_assert(alignof(StoreOp) == alignof(WGPUStoreOp), \"alignof mismatch for StoreOp\");\n\n    static_assert(static_cast<uint32_t>(StoreOp::Undefined) == WGPUStoreOp_Undefined, \"value mismatch for StoreOp::Undefined\");\n    static_assert(static_cast<uint32_t>(StoreOp::Store) == WGPUStoreOp_Store, \"value mismatch for StoreOp::Store\");\n    static_assert(static_cast<uint32_t>(StoreOp::Discard) == WGPUStoreOp_Discard, \"value mismatch for StoreOp::Discard\");\n\n    // TextureAspect\n\n    static_assert(sizeof(TextureAspect) == sizeof(WGPUTextureAspect), \"sizeof mismatch for TextureAspect\");\n    static_assert(alignof(TextureAspect) == alignof(WGPUTextureAspect), \"alignof mismatch for TextureAspect\");\n\n    static_assert(static_cast<uint32_t>(TextureAspect::All) == WGPUTextureAspect_All, \"value mismatch for TextureAspect::All\");\n    static_assert(static_cast<uint32_t>(TextureAspect::StencilOnly) == WGPUTextureAspect_StencilOnly, \"value mismatch for TextureAspect::StencilOnly\");\n    static_assert(static_cast<uint32_t>(TextureAspect::DepthOnly) == WGPUTextureAspect_DepthOnly, \"value mismatch for TextureAspect::DepthOnly\");\n\n    // TextureDimension\n\n    static_assert(sizeof(TextureDimension) == sizeof(WGPUTextureDimension), \"sizeof mismatch for TextureDimension\");\n    static_assert(alignof(TextureDimension) == alignof(WGPUTextureDimension), \"alignof mismatch for TextureDimension\");\n\n    static_assert(static_cast<uint32_t>(TextureDimension::e1D) == WGPUTextureDimension_1D, \"value mismatch for TextureDimension::e1D\");\n    static_assert(static_cast<uint32_t>(TextureDimension::e2D) == WGPUTextureDimension_2D, \"value mismatch for TextureDimension::e2D\");\n    static_assert(static_cast<uint32_t>(TextureDimension::e3D) == WGPUTextureDimension_3D, \"value mismatch for TextureDimension::e3D\");\n\n    // TextureFormat\n\n    static_assert(sizeof(TextureFormat) == sizeof(WGPUTextureFormat), \"sizeof mismatch for TextureFormat\");\n    static_assert(alignof(TextureFormat) == alignof(WGPUTextureFormat), \"alignof mismatch for TextureFormat\");\n\n    static_assert(static_cast<uint32_t>(TextureFormat::Undefined) == WGPUTextureFormat_Undefined, \"value mismatch for TextureFormat::Undefined\");\n    static_assert(static_cast<uint32_t>(TextureFormat::R8Unorm) == WGPUTextureFormat_R8Unorm, \"value mismatch for TextureFormat::R8Unorm\");\n    static_assert(static_cast<uint32_t>(TextureFormat::R8Snorm) == WGPUTextureFormat_R8Snorm, \"value mismatch for TextureFormat::R8Snorm\");\n    static_assert(static_cast<uint32_t>(TextureFormat::R8Uint) == WGPUTextureFormat_R8Uint, \"value mismatch for TextureFormat::R8Uint\");\n    static_assert(static_cast<uint32_t>(TextureFormat::R8Sint) == WGPUTextureFormat_R8Sint, \"value mismatch for TextureFormat::R8Sint\");\n    static_assert(static_cast<uint32_t>(TextureFormat::R16Uint) == WGPUTextureFormat_R16Uint, \"value mismatch for TextureFormat::R16Uint\");\n    static_assert(static_cast<uint32_t>(TextureFormat::R16Sint) == WGPUTextureFormat_R16Sint, \"value mismatch for TextureFormat::R16Sint\");\n    static_assert(static_cast<uint32_t>(TextureFormat::R16Float) == WGPUTextureFormat_R16Float, \"value mismatch for TextureFormat::R16Float\");\n    static_assert(static_cast<uint32_t>(TextureFormat::RG8Unorm) == WGPUTextureFormat_RG8Unorm, \"value mismatch for TextureFormat::RG8Unorm\");\n    static_assert(static_cast<uint32_t>(TextureFormat::RG8Snorm) == WGPUTextureFormat_RG8Snorm, \"value mismatch for TextureFormat::RG8Snorm\");\n    static_assert(static_cast<uint32_t>(TextureFormat::RG8Uint) == WGPUTextureFormat_RG8Uint, \"value mismatch for TextureFormat::RG8Uint\");\n    static_assert(static_cast<uint32_t>(TextureFormat::RG8Sint) == WGPUTextureFormat_RG8Sint, \"value mismatch for TextureFormat::RG8Sint\");\n    static_assert(static_cast<uint32_t>(TextureFormat::R32Float) == WGPUTextureFormat_R32Float, \"value mismatch for TextureFormat::R32Float\");\n    static_assert(static_cast<uint32_t>(TextureFormat::R32Uint) == WGPUTextureFormat_R32Uint, \"value mismatch for TextureFormat::R32Uint\");\n    static_assert(static_cast<uint32_t>(TextureFormat::R32Sint) == WGPUTextureFormat_R32Sint, \"value mismatch for TextureFormat::R32Sint\");\n    static_assert(static_cast<uint32_t>(TextureFormat::RG16Uint) == WGPUTextureFormat_RG16Uint, \"value mismatch for TextureFormat::RG16Uint\");\n    static_assert(static_cast<uint32_t>(TextureFormat::RG16Sint) == WGPUTextureFormat_RG16Sint, \"value mismatch for TextureFormat::RG16Sint\");\n    static_assert(static_cast<uint32_t>(TextureFormat::RG16Float) == WGPUTextureFormat_RG16Float, \"value mismatch for TextureFormat::RG16Float\");\n    static_assert(static_cast<uint32_t>(TextureFormat::RGBA8Unorm) == WGPUTextureFormat_RGBA8Unorm, \"value mismatch for TextureFormat::RGBA8Unorm\");\n    static_assert(static_cast<uint32_t>(TextureFormat::RGBA8UnormSrgb) == WGPUTextureFormat_RGBA8UnormSrgb, \"value mismatch for TextureFormat::RGBA8UnormSrgb\");\n    static_assert(static_cast<uint32_t>(TextureFormat::RGBA8Snorm) == WGPUTextureFormat_RGBA8Snorm, \"value mismatch for TextureFormat::RGBA8Snorm\");\n    static_assert(static_cast<uint32_t>(TextureFormat::RGBA8Uint) == WGPUTextureFormat_RGBA8Uint, \"value mismatch for TextureFormat::RGBA8Uint\");\n    static_assert(static_cast<uint32_t>(TextureFormat::RGBA8Sint) == WGPUTextureFormat_RGBA8Sint, \"value mismatch for TextureFormat::RGBA8Sint\");\n    static_assert(static_cast<uint32_t>(TextureFormat::BGRA8Unorm) == WGPUTextureFormat_BGRA8Unorm, \"value mismatch for TextureFormat::BGRA8Unorm\");\n    static_assert(static_cast<uint32_t>(TextureFormat::BGRA8UnormSrgb) == WGPUTextureFormat_BGRA8UnormSrgb, \"value mismatch for TextureFormat::BGRA8UnormSrgb\");\n    static_assert(static_cast<uint32_t>(TextureFormat::RGB10A2Unorm) == WGPUTextureFormat_RGB10A2Unorm, \"value mismatch for TextureFormat::RGB10A2Unorm\");\n    static_assert(static_cast<uint32_t>(TextureFormat::RG11B10Ufloat) == WGPUTextureFormat_RG11B10Ufloat, \"value mismatch for TextureFormat::RG11B10Ufloat\");\n    static_assert(static_cast<uint32_t>(TextureFormat::RGB9E5Ufloat) == WGPUTextureFormat_RGB9E5Ufloat, \"value mismatch for TextureFormat::RGB9E5Ufloat\");\n    static_assert(static_cast<uint32_t>(TextureFormat::RG32Float) == WGPUTextureFormat_RG32Float, \"value mismatch for TextureFormat::RG32Float\");\n    static_assert(static_cast<uint32_t>(TextureFormat::RG32Uint) == WGPUTextureFormat_RG32Uint, \"value mismatch for TextureFormat::RG32Uint\");\n    static_assert(static_cast<uint32_t>(TextureFormat::RG32Sint) == WGPUTextureFormat_RG32Sint, \"value mismatch for TextureFormat::RG32Sint\");\n    static_assert(static_cast<uint32_t>(TextureFormat::RGBA16Uint) == WGPUTextureFormat_RGBA16Uint, \"value mismatch for TextureFormat::RGBA16Uint\");\n    static_assert(static_cast<uint32_t>(TextureFormat::RGBA16Sint) == WGPUTextureFormat_RGBA16Sint, \"value mismatch for TextureFormat::RGBA16Sint\");\n    static_assert(static_cast<uint32_t>(TextureFormat::RGBA16Float) == WGPUTextureFormat_RGBA16Float, \"value mismatch for TextureFormat::RGBA16Float\");\n    static_assert(static_cast<uint32_t>(TextureFormat::RGBA32Float) == WGPUTextureFormat_RGBA32Float, \"value mismatch for TextureFormat::RGBA32Float\");\n    static_assert(static_cast<uint32_t>(TextureFormat::RGBA32Uint) == WGPUTextureFormat_RGBA32Uint, \"value mismatch for TextureFormat::RGBA32Uint\");\n    static_assert(static_cast<uint32_t>(TextureFormat::RGBA32Sint) == WGPUTextureFormat_RGBA32Sint, \"value mismatch for TextureFormat::RGBA32Sint\");\n    static_assert(static_cast<uint32_t>(TextureFormat::Stencil8) == WGPUTextureFormat_Stencil8, \"value mismatch for TextureFormat::Stencil8\");\n    static_assert(static_cast<uint32_t>(TextureFormat::Depth16Unorm) == WGPUTextureFormat_Depth16Unorm, \"value mismatch for TextureFormat::Depth16Unorm\");\n    static_assert(static_cast<uint32_t>(TextureFormat::Depth24Plus) == WGPUTextureFormat_Depth24Plus, \"value mismatch for TextureFormat::Depth24Plus\");\n    static_assert(static_cast<uint32_t>(TextureFormat::Depth24PlusStencil8) == WGPUTextureFormat_Depth24PlusStencil8, \"value mismatch for TextureFormat::Depth24PlusStencil8\");\n    static_assert(static_cast<uint32_t>(TextureFormat::Depth32Float) == WGPUTextureFormat_Depth32Float, \"value mismatch for TextureFormat::Depth32Float\");\n    static_assert(static_cast<uint32_t>(TextureFormat::Depth32FloatStencil8) == WGPUTextureFormat_Depth32FloatStencil8, \"value mismatch for TextureFormat::Depth32FloatStencil8\");\n    static_assert(static_cast<uint32_t>(TextureFormat::BC1RGBAUnorm) == WGPUTextureFormat_BC1RGBAUnorm, \"value mismatch for TextureFormat::BC1RGBAUnorm\");\n    static_assert(static_cast<uint32_t>(TextureFormat::BC1RGBAUnormSrgb) == WGPUTextureFormat_BC1RGBAUnormSrgb, \"value mismatch for TextureFormat::BC1RGBAUnormSrgb\");\n    static_assert(static_cast<uint32_t>(TextureFormat::BC2RGBAUnorm) == WGPUTextureFormat_BC2RGBAUnorm, \"value mismatch for TextureFormat::BC2RGBAUnorm\");\n    static_assert(static_cast<uint32_t>(TextureFormat::BC2RGBAUnormSrgb) == WGPUTextureFormat_BC2RGBAUnormSrgb, \"value mismatch for TextureFormat::BC2RGBAUnormSrgb\");\n    static_assert(static_cast<uint32_t>(TextureFormat::BC3RGBAUnorm) == WGPUTextureFormat_BC3RGBAUnorm, \"value mismatch for TextureFormat::BC3RGBAUnorm\");\n    static_assert(static_cast<uint32_t>(TextureFormat::BC3RGBAUnormSrgb) == WGPUTextureFormat_BC3RGBAUnormSrgb, \"value mismatch for TextureFormat::BC3RGBAUnormSrgb\");\n    static_assert(static_cast<uint32_t>(TextureFormat::BC4RUnorm) == WGPUTextureFormat_BC4RUnorm, \"value mismatch for TextureFormat::BC4RUnorm\");\n    static_assert(static_cast<uint32_t>(TextureFormat::BC4RSnorm) == WGPUTextureFormat_BC4RSnorm, \"value mismatch for TextureFormat::BC4RSnorm\");\n    static_assert(static_cast<uint32_t>(TextureFormat::BC5RGUnorm) == WGPUTextureFormat_BC5RGUnorm, \"value mismatch for TextureFormat::BC5RGUnorm\");\n    static_assert(static_cast<uint32_t>(TextureFormat::BC5RGSnorm) == WGPUTextureFormat_BC5RGSnorm, \"value mismatch for TextureFormat::BC5RGSnorm\");\n    static_assert(static_cast<uint32_t>(TextureFormat::BC6HRGBUfloat) == WGPUTextureFormat_BC6HRGBUfloat, \"value mismatch for TextureFormat::BC6HRGBUfloat\");\n    static_assert(static_cast<uint32_t>(TextureFormat::BC6HRGBFloat) == WGPUTextureFormat_BC6HRGBFloat, \"value mismatch for TextureFormat::BC6HRGBFloat\");\n    static_assert(static_cast<uint32_t>(TextureFormat::BC7RGBAUnorm) == WGPUTextureFormat_BC7RGBAUnorm, \"value mismatch for TextureFormat::BC7RGBAUnorm\");\n    static_assert(static_cast<uint32_t>(TextureFormat::BC7RGBAUnormSrgb) == WGPUTextureFormat_BC7RGBAUnormSrgb, \"value mismatch for TextureFormat::BC7RGBAUnormSrgb\");\n    static_assert(static_cast<uint32_t>(TextureFormat::ETC2RGB8Unorm) == WGPUTextureFormat_ETC2RGB8Unorm, \"value mismatch for TextureFormat::ETC2RGB8Unorm\");\n    static_assert(static_cast<uint32_t>(TextureFormat::ETC2RGB8UnormSrgb) == WGPUTextureFormat_ETC2RGB8UnormSrgb, \"value mismatch for TextureFormat::ETC2RGB8UnormSrgb\");\n    static_assert(static_cast<uint32_t>(TextureFormat::ETC2RGB8A1Unorm) == WGPUTextureFormat_ETC2RGB8A1Unorm, \"value mismatch for TextureFormat::ETC2RGB8A1Unorm\");\n    static_assert(static_cast<uint32_t>(TextureFormat::ETC2RGB8A1UnormSrgb) == WGPUTextureFormat_ETC2RGB8A1UnormSrgb, \"value mismatch for TextureFormat::ETC2RGB8A1UnormSrgb\");\n    static_assert(static_cast<uint32_t>(TextureFormat::ETC2RGBA8Unorm) == WGPUTextureFormat_ETC2RGBA8Unorm, \"value mismatch for TextureFormat::ETC2RGBA8Unorm\");\n    static_assert(static_cast<uint32_t>(TextureFormat::ETC2RGBA8UnormSrgb) == WGPUTextureFormat_ETC2RGBA8UnormSrgb, \"value mismatch for TextureFormat::ETC2RGBA8UnormSrgb\");\n    static_assert(static_cast<uint32_t>(TextureFormat::EACR11Unorm) == WGPUTextureFormat_EACR11Unorm, \"value mismatch for TextureFormat::EACR11Unorm\");\n    static_assert(static_cast<uint32_t>(TextureFormat::EACR11Snorm) == WGPUTextureFormat_EACR11Snorm, \"value mismatch for TextureFormat::EACR11Snorm\");\n    static_assert(static_cast<uint32_t>(TextureFormat::EACRG11Unorm) == WGPUTextureFormat_EACRG11Unorm, \"value mismatch for TextureFormat::EACRG11Unorm\");\n    static_assert(static_cast<uint32_t>(TextureFormat::EACRG11Snorm) == WGPUTextureFormat_EACRG11Snorm, \"value mismatch for TextureFormat::EACRG11Snorm\");\n    static_assert(static_cast<uint32_t>(TextureFormat::ASTC4x4Unorm) == WGPUTextureFormat_ASTC4x4Unorm, \"value mismatch for TextureFormat::ASTC4x4Unorm\");\n    static_assert(static_cast<uint32_t>(TextureFormat::ASTC4x4UnormSrgb) == WGPUTextureFormat_ASTC4x4UnormSrgb, \"value mismatch for TextureFormat::ASTC4x4UnormSrgb\");\n    static_assert(static_cast<uint32_t>(TextureFormat::ASTC5x4Unorm) == WGPUTextureFormat_ASTC5x4Unorm, \"value mismatch for TextureFormat::ASTC5x4Unorm\");\n    static_assert(static_cast<uint32_t>(TextureFormat::ASTC5x4UnormSrgb) == WGPUTextureFormat_ASTC5x4UnormSrgb, \"value mismatch for TextureFormat::ASTC5x4UnormSrgb\");\n    static_assert(static_cast<uint32_t>(TextureFormat::ASTC5x5Unorm) == WGPUTextureFormat_ASTC5x5Unorm, \"value mismatch for TextureFormat::ASTC5x5Unorm\");\n    static_assert(static_cast<uint32_t>(TextureFormat::ASTC5x5UnormSrgb) == WGPUTextureFormat_ASTC5x5UnormSrgb, \"value mismatch for TextureFormat::ASTC5x5UnormSrgb\");\n    static_assert(static_cast<uint32_t>(TextureFormat::ASTC6x5Unorm) == WGPUTextureFormat_ASTC6x5Unorm, \"value mismatch for TextureFormat::ASTC6x5Unorm\");\n    static_assert(static_cast<uint32_t>(TextureFormat::ASTC6x5UnormSrgb) == WGPUTextureFormat_ASTC6x5UnormSrgb, \"value mismatch for TextureFormat::ASTC6x5UnormSrgb\");\n    static_assert(static_cast<uint32_t>(TextureFormat::ASTC6x6Unorm) == WGPUTextureFormat_ASTC6x6Unorm, \"value mismatch for TextureFormat::ASTC6x6Unorm\");\n    static_assert(static_cast<uint32_t>(TextureFormat::ASTC6x6UnormSrgb) == WGPUTextureFormat_ASTC6x6UnormSrgb, \"value mismatch for TextureFormat::ASTC6x6UnormSrgb\");\n    static_assert(static_cast<uint32_t>(TextureFormat::ASTC8x5Unorm) == WGPUTextureFormat_ASTC8x5Unorm, \"value mismatch for TextureFormat::ASTC8x5Unorm\");\n    static_assert(static_cast<uint32_t>(TextureFormat::ASTC8x5UnormSrgb) == WGPUTextureFormat_ASTC8x5UnormSrgb, \"value mismatch for TextureFormat::ASTC8x5UnormSrgb\");\n    static_assert(static_cast<uint32_t>(TextureFormat::ASTC8x6Unorm) == WGPUTextureFormat_ASTC8x6Unorm, \"value mismatch for TextureFormat::ASTC8x6Unorm\");\n    static_assert(static_cast<uint32_t>(TextureFormat::ASTC8x6UnormSrgb) == WGPUTextureFormat_ASTC8x6UnormSrgb, \"value mismatch for TextureFormat::ASTC8x6UnormSrgb\");\n    static_assert(static_cast<uint32_t>(TextureFormat::ASTC8x8Unorm) == WGPUTextureFormat_ASTC8x8Unorm, \"value mismatch for TextureFormat::ASTC8x8Unorm\");\n    static_assert(static_cast<uint32_t>(TextureFormat::ASTC8x8UnormSrgb) == WGPUTextureFormat_ASTC8x8UnormSrgb, \"value mismatch for TextureFormat::ASTC8x8UnormSrgb\");\n    static_assert(static_cast<uint32_t>(TextureFormat::ASTC10x5Unorm) == WGPUTextureFormat_ASTC10x5Unorm, \"value mismatch for TextureFormat::ASTC10x5Unorm\");\n    static_assert(static_cast<uint32_t>(TextureFormat::ASTC10x5UnormSrgb) == WGPUTextureFormat_ASTC10x5UnormSrgb, \"value mismatch for TextureFormat::ASTC10x5UnormSrgb\");\n    static_assert(static_cast<uint32_t>(TextureFormat::ASTC10x6Unorm) == WGPUTextureFormat_ASTC10x6Unorm, \"value mismatch for TextureFormat::ASTC10x6Unorm\");\n    static_assert(static_cast<uint32_t>(TextureFormat::ASTC10x6UnormSrgb) == WGPUTextureFormat_ASTC10x6UnormSrgb, \"value mismatch for TextureFormat::ASTC10x6UnormSrgb\");\n    static_assert(static_cast<uint32_t>(TextureFormat::ASTC10x8Unorm) == WGPUTextureFormat_ASTC10x8Unorm, \"value mismatch for TextureFormat::ASTC10x8Unorm\");\n    static_assert(static_cast<uint32_t>(TextureFormat::ASTC10x8UnormSrgb) == WGPUTextureFormat_ASTC10x8UnormSrgb, \"value mismatch for TextureFormat::ASTC10x8UnormSrgb\");\n    static_assert(static_cast<uint32_t>(TextureFormat::ASTC10x10Unorm) == WGPUTextureFormat_ASTC10x10Unorm, \"value mismatch for TextureFormat::ASTC10x10Unorm\");\n    static_assert(static_cast<uint32_t>(TextureFormat::ASTC10x10UnormSrgb) == WGPUTextureFormat_ASTC10x10UnormSrgb, \"value mismatch for TextureFormat::ASTC10x10UnormSrgb\");\n    static_assert(static_cast<uint32_t>(TextureFormat::ASTC12x10Unorm) == WGPUTextureFormat_ASTC12x10Unorm, \"value mismatch for TextureFormat::ASTC12x10Unorm\");\n    static_assert(static_cast<uint32_t>(TextureFormat::ASTC12x10UnormSrgb) == WGPUTextureFormat_ASTC12x10UnormSrgb, \"value mismatch for TextureFormat::ASTC12x10UnormSrgb\");\n    static_assert(static_cast<uint32_t>(TextureFormat::ASTC12x12Unorm) == WGPUTextureFormat_ASTC12x12Unorm, \"value mismatch for TextureFormat::ASTC12x12Unorm\");\n    static_assert(static_cast<uint32_t>(TextureFormat::ASTC12x12UnormSrgb) == WGPUTextureFormat_ASTC12x12UnormSrgb, \"value mismatch for TextureFormat::ASTC12x12UnormSrgb\");\n\n    // TextureSampleType\n\n    static_assert(sizeof(TextureSampleType) == sizeof(WGPUTextureSampleType), \"sizeof mismatch for TextureSampleType\");\n    static_assert(alignof(TextureSampleType) == alignof(WGPUTextureSampleType), \"alignof mismatch for TextureSampleType\");\n\n    static_assert(static_cast<uint32_t>(TextureSampleType::Undefined) == WGPUTextureSampleType_Undefined, \"value mismatch for TextureSampleType::Undefined\");\n    static_assert(static_cast<uint32_t>(TextureSampleType::Float) == WGPUTextureSampleType_Float, \"value mismatch for TextureSampleType::Float\");\n    static_assert(static_cast<uint32_t>(TextureSampleType::UnfilterableFloat) == WGPUTextureSampleType_UnfilterableFloat, \"value mismatch for TextureSampleType::UnfilterableFloat\");\n    static_assert(static_cast<uint32_t>(TextureSampleType::Depth) == WGPUTextureSampleType_Depth, \"value mismatch for TextureSampleType::Depth\");\n    static_assert(static_cast<uint32_t>(TextureSampleType::Sint) == WGPUTextureSampleType_Sint, \"value mismatch for TextureSampleType::Sint\");\n    static_assert(static_cast<uint32_t>(TextureSampleType::Uint) == WGPUTextureSampleType_Uint, \"value mismatch for TextureSampleType::Uint\");\n\n    // TextureViewDimension\n\n    static_assert(sizeof(TextureViewDimension) == sizeof(WGPUTextureViewDimension), \"sizeof mismatch for TextureViewDimension\");\n    static_assert(alignof(TextureViewDimension) == alignof(WGPUTextureViewDimension), \"alignof mismatch for TextureViewDimension\");\n\n    static_assert(static_cast<uint32_t>(TextureViewDimension::Undefined) == WGPUTextureViewDimension_Undefined, \"value mismatch for TextureViewDimension::Undefined\");\n    static_assert(static_cast<uint32_t>(TextureViewDimension::e1D) == WGPUTextureViewDimension_1D, \"value mismatch for TextureViewDimension::e1D\");\n    static_assert(static_cast<uint32_t>(TextureViewDimension::e2D) == WGPUTextureViewDimension_2D, \"value mismatch for TextureViewDimension::e2D\");\n    static_assert(static_cast<uint32_t>(TextureViewDimension::e2DArray) == WGPUTextureViewDimension_2DArray, \"value mismatch for TextureViewDimension::e2DArray\");\n    static_assert(static_cast<uint32_t>(TextureViewDimension::Cube) == WGPUTextureViewDimension_Cube, \"value mismatch for TextureViewDimension::Cube\");\n    static_assert(static_cast<uint32_t>(TextureViewDimension::CubeArray) == WGPUTextureViewDimension_CubeArray, \"value mismatch for TextureViewDimension::CubeArray\");\n    static_assert(static_cast<uint32_t>(TextureViewDimension::e3D) == WGPUTextureViewDimension_3D, \"value mismatch for TextureViewDimension::e3D\");\n\n    // VertexFormat\n\n    static_assert(sizeof(VertexFormat) == sizeof(WGPUVertexFormat), \"sizeof mismatch for VertexFormat\");\n    static_assert(alignof(VertexFormat) == alignof(WGPUVertexFormat), \"alignof mismatch for VertexFormat\");\n\n    static_assert(static_cast<uint32_t>(VertexFormat::Undefined) == WGPUVertexFormat_Undefined, \"value mismatch for VertexFormat::Undefined\");\n    static_assert(static_cast<uint32_t>(VertexFormat::Uint8x2) == WGPUVertexFormat_Uint8x2, \"value mismatch for VertexFormat::Uint8x2\");\n    static_assert(static_cast<uint32_t>(VertexFormat::Uint8x4) == WGPUVertexFormat_Uint8x4, \"value mismatch for VertexFormat::Uint8x4\");\n    static_assert(static_cast<uint32_t>(VertexFormat::Sint8x2) == WGPUVertexFormat_Sint8x2, \"value mismatch for VertexFormat::Sint8x2\");\n    static_assert(static_cast<uint32_t>(VertexFormat::Sint8x4) == WGPUVertexFormat_Sint8x4, \"value mismatch for VertexFormat::Sint8x4\");\n    static_assert(static_cast<uint32_t>(VertexFormat::Unorm8x2) == WGPUVertexFormat_Unorm8x2, \"value mismatch for VertexFormat::Unorm8x2\");\n    static_assert(static_cast<uint32_t>(VertexFormat::Unorm8x4) == WGPUVertexFormat_Unorm8x4, \"value mismatch for VertexFormat::Unorm8x4\");\n    static_assert(static_cast<uint32_t>(VertexFormat::Snorm8x2) == WGPUVertexFormat_Snorm8x2, \"value mismatch for VertexFormat::Snorm8x2\");\n    static_assert(static_cast<uint32_t>(VertexFormat::Snorm8x4) == WGPUVertexFormat_Snorm8x4, \"value mismatch for VertexFormat::Snorm8x4\");\n    static_assert(static_cast<uint32_t>(VertexFormat::Uint16x2) == WGPUVertexFormat_Uint16x2, \"value mismatch for VertexFormat::Uint16x2\");\n    static_assert(static_cast<uint32_t>(VertexFormat::Uint16x4) == WGPUVertexFormat_Uint16x4, \"value mismatch for VertexFormat::Uint16x4\");\n    static_assert(static_cast<uint32_t>(VertexFormat::Sint16x2) == WGPUVertexFormat_Sint16x2, \"value mismatch for VertexFormat::Sint16x2\");\n    static_assert(static_cast<uint32_t>(VertexFormat::Sint16x4) == WGPUVertexFormat_Sint16x4, \"value mismatch for VertexFormat::Sint16x4\");\n    static_assert(static_cast<uint32_t>(VertexFormat::Unorm16x2) == WGPUVertexFormat_Unorm16x2, \"value mismatch for VertexFormat::Unorm16x2\");\n    static_assert(static_cast<uint32_t>(VertexFormat::Unorm16x4) == WGPUVertexFormat_Unorm16x4, \"value mismatch for VertexFormat::Unorm16x4\");\n    static_assert(static_cast<uint32_t>(VertexFormat::Snorm16x2) == WGPUVertexFormat_Snorm16x2, \"value mismatch for VertexFormat::Snorm16x2\");\n    static_assert(static_cast<uint32_t>(VertexFormat::Snorm16x4) == WGPUVertexFormat_Snorm16x4, \"value mismatch for VertexFormat::Snorm16x4\");\n    static_assert(static_cast<uint32_t>(VertexFormat::Float16x2) == WGPUVertexFormat_Float16x2, \"value mismatch for VertexFormat::Float16x2\");\n    static_assert(static_cast<uint32_t>(VertexFormat::Float16x4) == WGPUVertexFormat_Float16x4, \"value mismatch for VertexFormat::Float16x4\");\n    static_assert(static_cast<uint32_t>(VertexFormat::Float32) == WGPUVertexFormat_Float32, \"value mismatch for VertexFormat::Float32\");\n    static_assert(static_cast<uint32_t>(VertexFormat::Float32x2) == WGPUVertexFormat_Float32x2, \"value mismatch for VertexFormat::Float32x2\");\n    static_assert(static_cast<uint32_t>(VertexFormat::Float32x3) == WGPUVertexFormat_Float32x3, \"value mismatch for VertexFormat::Float32x3\");\n    static_assert(static_cast<uint32_t>(VertexFormat::Float32x4) == WGPUVertexFormat_Float32x4, \"value mismatch for VertexFormat::Float32x4\");\n    static_assert(static_cast<uint32_t>(VertexFormat::Uint32) == WGPUVertexFormat_Uint32, \"value mismatch for VertexFormat::Uint32\");\n    static_assert(static_cast<uint32_t>(VertexFormat::Uint32x2) == WGPUVertexFormat_Uint32x2, \"value mismatch for VertexFormat::Uint32x2\");\n    static_assert(static_cast<uint32_t>(VertexFormat::Uint32x3) == WGPUVertexFormat_Uint32x3, \"value mismatch for VertexFormat::Uint32x3\");\n    static_assert(static_cast<uint32_t>(VertexFormat::Uint32x4) == WGPUVertexFormat_Uint32x4, \"value mismatch for VertexFormat::Uint32x4\");\n    static_assert(static_cast<uint32_t>(VertexFormat::Sint32) == WGPUVertexFormat_Sint32, \"value mismatch for VertexFormat::Sint32\");\n    static_assert(static_cast<uint32_t>(VertexFormat::Sint32x2) == WGPUVertexFormat_Sint32x2, \"value mismatch for VertexFormat::Sint32x2\");\n    static_assert(static_cast<uint32_t>(VertexFormat::Sint32x3) == WGPUVertexFormat_Sint32x3, \"value mismatch for VertexFormat::Sint32x3\");\n    static_assert(static_cast<uint32_t>(VertexFormat::Sint32x4) == WGPUVertexFormat_Sint32x4, \"value mismatch for VertexFormat::Sint32x4\");\n\n    // VertexStepMode\n\n    static_assert(sizeof(VertexStepMode) == sizeof(WGPUVertexStepMode), \"sizeof mismatch for VertexStepMode\");\n    static_assert(alignof(VertexStepMode) == alignof(WGPUVertexStepMode), \"alignof mismatch for VertexStepMode\");\n\n    static_assert(static_cast<uint32_t>(VertexStepMode::Vertex) == WGPUVertexStepMode_Vertex, \"value mismatch for VertexStepMode::Vertex\");\n    static_assert(static_cast<uint32_t>(VertexStepMode::Instance) == WGPUVertexStepMode_Instance, \"value mismatch for VertexStepMode::Instance\");\n    static_assert(static_cast<uint32_t>(VertexStepMode::VertexBufferNotUsed) == WGPUVertexStepMode_VertexBufferNotUsed, \"value mismatch for VertexStepMode::VertexBufferNotUsed\");\n\n    // BufferUsage\n\n    static_assert(sizeof(BufferUsage) == sizeof(WGPUBufferUsageFlags), \"sizeof mismatch for BufferUsage\");\n    static_assert(alignof(BufferUsage) == alignof(WGPUBufferUsageFlags), \"alignof mismatch for BufferUsage\");\n\n    static_assert(static_cast<uint32_t>(BufferUsage::None) == WGPUBufferUsage_None, \"value mismatch for BufferUsage::None\");\n    static_assert(static_cast<uint32_t>(BufferUsage::MapRead) == WGPUBufferUsage_MapRead, \"value mismatch for BufferUsage::MapRead\");\n    static_assert(static_cast<uint32_t>(BufferUsage::MapWrite) == WGPUBufferUsage_MapWrite, \"value mismatch for BufferUsage::MapWrite\");\n    static_assert(static_cast<uint32_t>(BufferUsage::CopySrc) == WGPUBufferUsage_CopySrc, \"value mismatch for BufferUsage::CopySrc\");\n    static_assert(static_cast<uint32_t>(BufferUsage::CopyDst) == WGPUBufferUsage_CopyDst, \"value mismatch for BufferUsage::CopyDst\");\n    static_assert(static_cast<uint32_t>(BufferUsage::Index) == WGPUBufferUsage_Index, \"value mismatch for BufferUsage::Index\");\n    static_assert(static_cast<uint32_t>(BufferUsage::Vertex) == WGPUBufferUsage_Vertex, \"value mismatch for BufferUsage::Vertex\");\n    static_assert(static_cast<uint32_t>(BufferUsage::Uniform) == WGPUBufferUsage_Uniform, \"value mismatch for BufferUsage::Uniform\");\n    static_assert(static_cast<uint32_t>(BufferUsage::Storage) == WGPUBufferUsage_Storage, \"value mismatch for BufferUsage::Storage\");\n    static_assert(static_cast<uint32_t>(BufferUsage::Indirect) == WGPUBufferUsage_Indirect, \"value mismatch for BufferUsage::Indirect\");\n    static_assert(static_cast<uint32_t>(BufferUsage::QueryResolve) == WGPUBufferUsage_QueryResolve, \"value mismatch for BufferUsage::QueryResolve\");\n\n    // ColorWriteMask\n\n    static_assert(sizeof(ColorWriteMask) == sizeof(WGPUColorWriteMaskFlags), \"sizeof mismatch for ColorWriteMask\");\n    static_assert(alignof(ColorWriteMask) == alignof(WGPUColorWriteMaskFlags), \"alignof mismatch for ColorWriteMask\");\n\n    static_assert(static_cast<uint32_t>(ColorWriteMask::None) == WGPUColorWriteMask_None, \"value mismatch for ColorWriteMask::None\");\n    static_assert(static_cast<uint32_t>(ColorWriteMask::Red) == WGPUColorWriteMask_Red, \"value mismatch for ColorWriteMask::Red\");\n    static_assert(static_cast<uint32_t>(ColorWriteMask::Green) == WGPUColorWriteMask_Green, \"value mismatch for ColorWriteMask::Green\");\n    static_assert(static_cast<uint32_t>(ColorWriteMask::Blue) == WGPUColorWriteMask_Blue, \"value mismatch for ColorWriteMask::Blue\");\n    static_assert(static_cast<uint32_t>(ColorWriteMask::Alpha) == WGPUColorWriteMask_Alpha, \"value mismatch for ColorWriteMask::Alpha\");\n    static_assert(static_cast<uint32_t>(ColorWriteMask::All) == WGPUColorWriteMask_All, \"value mismatch for ColorWriteMask::All\");\n\n    // MapMode\n\n    static_assert(sizeof(MapMode) == sizeof(WGPUMapModeFlags), \"sizeof mismatch for MapMode\");\n    static_assert(alignof(MapMode) == alignof(WGPUMapModeFlags), \"alignof mismatch for MapMode\");\n\n    static_assert(static_cast<uint32_t>(MapMode::None) == WGPUMapMode_None, \"value mismatch for MapMode::None\");\n    static_assert(static_cast<uint32_t>(MapMode::Read) == WGPUMapMode_Read, \"value mismatch for MapMode::Read\");\n    static_assert(static_cast<uint32_t>(MapMode::Write) == WGPUMapMode_Write, \"value mismatch for MapMode::Write\");\n\n    // ShaderStage\n\n    static_assert(sizeof(ShaderStage) == sizeof(WGPUShaderStageFlags), \"sizeof mismatch for ShaderStage\");\n    static_assert(alignof(ShaderStage) == alignof(WGPUShaderStageFlags), \"alignof mismatch for ShaderStage\");\n\n    static_assert(static_cast<uint32_t>(ShaderStage::None) == WGPUShaderStage_None, \"value mismatch for ShaderStage::None\");\n    static_assert(static_cast<uint32_t>(ShaderStage::Vertex) == WGPUShaderStage_Vertex, \"value mismatch for ShaderStage::Vertex\");\n    static_assert(static_cast<uint32_t>(ShaderStage::Fragment) == WGPUShaderStage_Fragment, \"value mismatch for ShaderStage::Fragment\");\n    static_assert(static_cast<uint32_t>(ShaderStage::Compute) == WGPUShaderStage_Compute, \"value mismatch for ShaderStage::Compute\");\n\n    // TextureUsage\n\n    static_assert(sizeof(TextureUsage) == sizeof(WGPUTextureUsageFlags), \"sizeof mismatch for TextureUsage\");\n    static_assert(alignof(TextureUsage) == alignof(WGPUTextureUsageFlags), \"alignof mismatch for TextureUsage\");\n\n    static_assert(static_cast<uint32_t>(TextureUsage::None) == WGPUTextureUsage_None, \"value mismatch for TextureUsage::None\");\n    static_assert(static_cast<uint32_t>(TextureUsage::CopySrc) == WGPUTextureUsage_CopySrc, \"value mismatch for TextureUsage::CopySrc\");\n    static_assert(static_cast<uint32_t>(TextureUsage::CopyDst) == WGPUTextureUsage_CopyDst, \"value mismatch for TextureUsage::CopyDst\");\n    static_assert(static_cast<uint32_t>(TextureUsage::TextureBinding) == WGPUTextureUsage_TextureBinding, \"value mismatch for TextureUsage::TextureBinding\");\n    static_assert(static_cast<uint32_t>(TextureUsage::StorageBinding) == WGPUTextureUsage_StorageBinding, \"value mismatch for TextureUsage::StorageBinding\");\n    static_assert(static_cast<uint32_t>(TextureUsage::RenderAttachment) == WGPUTextureUsage_RenderAttachment, \"value mismatch for TextureUsage::RenderAttachment\");\n\n    // ChainedStruct\n\n    static_assert(sizeof(ChainedStruct) == sizeof(WGPUChainedStruct),\n            \"sizeof mismatch for ChainedStruct\");\n    static_assert(alignof(ChainedStruct) == alignof(WGPUChainedStruct),\n            \"alignof mismatch for ChainedStruct\");\n    static_assert(offsetof(ChainedStruct, nextInChain) == offsetof(WGPUChainedStruct, next),\n            \"offsetof mismatch for ChainedStruct::nextInChain\");\n    static_assert(offsetof(ChainedStruct, sType) == offsetof(WGPUChainedStruct, sType),\n            \"offsetof mismatch for ChainedStruct::sType\");\n\n    // AdapterProperties\n\n    static_assert(sizeof(AdapterProperties) == sizeof(WGPUAdapterProperties), \"sizeof mismatch for AdapterProperties\");\n    static_assert(alignof(AdapterProperties) == alignof(WGPUAdapterProperties), \"alignof mismatch for AdapterProperties\");\n\n    static_assert(offsetof(AdapterProperties, nextInChain) == offsetof(WGPUAdapterProperties, nextInChain),\n            \"offsetof mismatch for AdapterProperties::nextInChain\");\n    static_assert(offsetof(AdapterProperties, vendorID) == offsetof(WGPUAdapterProperties, vendorID),\n            \"offsetof mismatch for AdapterProperties::vendorID\");\n    static_assert(offsetof(AdapterProperties, vendorName) == offsetof(WGPUAdapterProperties, vendorName),\n            \"offsetof mismatch for AdapterProperties::vendorName\");\n    static_assert(offsetof(AdapterProperties, architecture) == offsetof(WGPUAdapterProperties, architecture),\n            \"offsetof mismatch for AdapterProperties::architecture\");\n    static_assert(offsetof(AdapterProperties, deviceID) == offsetof(WGPUAdapterProperties, deviceID),\n            \"offsetof mismatch for AdapterProperties::deviceID\");\n    static_assert(offsetof(AdapterProperties, name) == offsetof(WGPUAdapterProperties, name),\n            \"offsetof mismatch for AdapterProperties::name\");\n    static_assert(offsetof(AdapterProperties, driverDescription) == offsetof(WGPUAdapterProperties, driverDescription),\n            \"offsetof mismatch for AdapterProperties::driverDescription\");\n    static_assert(offsetof(AdapterProperties, adapterType) == offsetof(WGPUAdapterProperties, adapterType),\n            \"offsetof mismatch for AdapterProperties::adapterType\");\n    static_assert(offsetof(AdapterProperties, backendType) == offsetof(WGPUAdapterProperties, backendType),\n            \"offsetof mismatch for AdapterProperties::backendType\");\n    static_assert(offsetof(AdapterProperties, compatibilityMode) == offsetof(WGPUAdapterProperties, compatibilityMode),\n            \"offsetof mismatch for AdapterProperties::compatibilityMode\");\n\n    // BindGroupEntry\n\n    static_assert(sizeof(BindGroupEntry) == sizeof(WGPUBindGroupEntry), \"sizeof mismatch for BindGroupEntry\");\n    static_assert(alignof(BindGroupEntry) == alignof(WGPUBindGroupEntry), \"alignof mismatch for BindGroupEntry\");\n\n    static_assert(offsetof(BindGroupEntry, nextInChain) == offsetof(WGPUBindGroupEntry, nextInChain),\n            \"offsetof mismatch for BindGroupEntry::nextInChain\");\n    static_assert(offsetof(BindGroupEntry, binding) == offsetof(WGPUBindGroupEntry, binding),\n            \"offsetof mismatch for BindGroupEntry::binding\");\n    static_assert(offsetof(BindGroupEntry, buffer) == offsetof(WGPUBindGroupEntry, buffer),\n            \"offsetof mismatch for BindGroupEntry::buffer\");\n    static_assert(offsetof(BindGroupEntry, offset) == offsetof(WGPUBindGroupEntry, offset),\n            \"offsetof mismatch for BindGroupEntry::offset\");\n    static_assert(offsetof(BindGroupEntry, size) == offsetof(WGPUBindGroupEntry, size),\n            \"offsetof mismatch for BindGroupEntry::size\");\n    static_assert(offsetof(BindGroupEntry, sampler) == offsetof(WGPUBindGroupEntry, sampler),\n            \"offsetof mismatch for BindGroupEntry::sampler\");\n    static_assert(offsetof(BindGroupEntry, textureView) == offsetof(WGPUBindGroupEntry, textureView),\n            \"offsetof mismatch for BindGroupEntry::textureView\");\n\n    // BlendComponent\n\n    static_assert(sizeof(BlendComponent) == sizeof(WGPUBlendComponent), \"sizeof mismatch for BlendComponent\");\n    static_assert(alignof(BlendComponent) == alignof(WGPUBlendComponent), \"alignof mismatch for BlendComponent\");\n\n    static_assert(offsetof(BlendComponent, operation) == offsetof(WGPUBlendComponent, operation),\n            \"offsetof mismatch for BlendComponent::operation\");\n    static_assert(offsetof(BlendComponent, srcFactor) == offsetof(WGPUBlendComponent, srcFactor),\n            \"offsetof mismatch for BlendComponent::srcFactor\");\n    static_assert(offsetof(BlendComponent, dstFactor) == offsetof(WGPUBlendComponent, dstFactor),\n            \"offsetof mismatch for BlendComponent::dstFactor\");\n\n    // BufferBindingLayout\n\n    static_assert(sizeof(BufferBindingLayout) == sizeof(WGPUBufferBindingLayout), \"sizeof mismatch for BufferBindingLayout\");\n    static_assert(alignof(BufferBindingLayout) == alignof(WGPUBufferBindingLayout), \"alignof mismatch for BufferBindingLayout\");\n\n    static_assert(offsetof(BufferBindingLayout, nextInChain) == offsetof(WGPUBufferBindingLayout, nextInChain),\n            \"offsetof mismatch for BufferBindingLayout::nextInChain\");\n    static_assert(offsetof(BufferBindingLayout, type) == offsetof(WGPUBufferBindingLayout, type),\n            \"offsetof mismatch for BufferBindingLayout::type\");\n    static_assert(offsetof(BufferBindingLayout, hasDynamicOffset) == offsetof(WGPUBufferBindingLayout, hasDynamicOffset),\n            \"offsetof mismatch for BufferBindingLayout::hasDynamicOffset\");\n    static_assert(offsetof(BufferBindingLayout, minBindingSize) == offsetof(WGPUBufferBindingLayout, minBindingSize),\n            \"offsetof mismatch for BufferBindingLayout::minBindingSize\");\n\n    // BufferDescriptor\n\n    static_assert(sizeof(BufferDescriptor) == sizeof(WGPUBufferDescriptor), \"sizeof mismatch for BufferDescriptor\");\n    static_assert(alignof(BufferDescriptor) == alignof(WGPUBufferDescriptor), \"alignof mismatch for BufferDescriptor\");\n\n    static_assert(offsetof(BufferDescriptor, nextInChain) == offsetof(WGPUBufferDescriptor, nextInChain),\n            \"offsetof mismatch for BufferDescriptor::nextInChain\");\n    static_assert(offsetof(BufferDescriptor, label) == offsetof(WGPUBufferDescriptor, label),\n            \"offsetof mismatch for BufferDescriptor::label\");\n    static_assert(offsetof(BufferDescriptor, usage) == offsetof(WGPUBufferDescriptor, usage),\n            \"offsetof mismatch for BufferDescriptor::usage\");\n    static_assert(offsetof(BufferDescriptor, size) == offsetof(WGPUBufferDescriptor, size),\n            \"offsetof mismatch for BufferDescriptor::size\");\n    static_assert(offsetof(BufferDescriptor, mappedAtCreation) == offsetof(WGPUBufferDescriptor, mappedAtCreation),\n            \"offsetof mismatch for BufferDescriptor::mappedAtCreation\");\n\n    // Color\n\n    static_assert(sizeof(Color) == sizeof(WGPUColor), \"sizeof mismatch for Color\");\n    static_assert(alignof(Color) == alignof(WGPUColor), \"alignof mismatch for Color\");\n\n    static_assert(offsetof(Color, r) == offsetof(WGPUColor, r),\n            \"offsetof mismatch for Color::r\");\n    static_assert(offsetof(Color, g) == offsetof(WGPUColor, g),\n            \"offsetof mismatch for Color::g\");\n    static_assert(offsetof(Color, b) == offsetof(WGPUColor, b),\n            \"offsetof mismatch for Color::b\");\n    static_assert(offsetof(Color, a) == offsetof(WGPUColor, a),\n            \"offsetof mismatch for Color::a\");\n\n    // CommandBufferDescriptor\n\n    static_assert(sizeof(CommandBufferDescriptor) == sizeof(WGPUCommandBufferDescriptor), \"sizeof mismatch for CommandBufferDescriptor\");\n    static_assert(alignof(CommandBufferDescriptor) == alignof(WGPUCommandBufferDescriptor), \"alignof mismatch for CommandBufferDescriptor\");\n\n    static_assert(offsetof(CommandBufferDescriptor, nextInChain) == offsetof(WGPUCommandBufferDescriptor, nextInChain),\n            \"offsetof mismatch for CommandBufferDescriptor::nextInChain\");\n    static_assert(offsetof(CommandBufferDescriptor, label) == offsetof(WGPUCommandBufferDescriptor, label),\n            \"offsetof mismatch for CommandBufferDescriptor::label\");\n\n    // CommandEncoderDescriptor\n\n    static_assert(sizeof(CommandEncoderDescriptor) == sizeof(WGPUCommandEncoderDescriptor), \"sizeof mismatch for CommandEncoderDescriptor\");\n    static_assert(alignof(CommandEncoderDescriptor) == alignof(WGPUCommandEncoderDescriptor), \"alignof mismatch for CommandEncoderDescriptor\");\n\n    static_assert(offsetof(CommandEncoderDescriptor, nextInChain) == offsetof(WGPUCommandEncoderDescriptor, nextInChain),\n            \"offsetof mismatch for CommandEncoderDescriptor::nextInChain\");\n    static_assert(offsetof(CommandEncoderDescriptor, label) == offsetof(WGPUCommandEncoderDescriptor, label),\n            \"offsetof mismatch for CommandEncoderDescriptor::label\");\n\n    // CompilationMessage\n\n    static_assert(sizeof(CompilationMessage) == sizeof(WGPUCompilationMessage), \"sizeof mismatch for CompilationMessage\");\n    static_assert(alignof(CompilationMessage) == alignof(WGPUCompilationMessage), \"alignof mismatch for CompilationMessage\");\n\n    static_assert(offsetof(CompilationMessage, nextInChain) == offsetof(WGPUCompilationMessage, nextInChain),\n            \"offsetof mismatch for CompilationMessage::nextInChain\");\n    static_assert(offsetof(CompilationMessage, message) == offsetof(WGPUCompilationMessage, message),\n            \"offsetof mismatch for CompilationMessage::message\");\n    static_assert(offsetof(CompilationMessage, type) == offsetof(WGPUCompilationMessage, type),\n            \"offsetof mismatch for CompilationMessage::type\");\n    static_assert(offsetof(CompilationMessage, lineNum) == offsetof(WGPUCompilationMessage, lineNum),\n            \"offsetof mismatch for CompilationMessage::lineNum\");\n    static_assert(offsetof(CompilationMessage, linePos) == offsetof(WGPUCompilationMessage, linePos),\n            \"offsetof mismatch for CompilationMessage::linePos\");\n    static_assert(offsetof(CompilationMessage, offset) == offsetof(WGPUCompilationMessage, offset),\n            \"offsetof mismatch for CompilationMessage::offset\");\n    static_assert(offsetof(CompilationMessage, length) == offsetof(WGPUCompilationMessage, length),\n            \"offsetof mismatch for CompilationMessage::length\");\n    static_assert(offsetof(CompilationMessage, utf16LinePos) == offsetof(WGPUCompilationMessage, utf16LinePos),\n            \"offsetof mismatch for CompilationMessage::utf16LinePos\");\n    static_assert(offsetof(CompilationMessage, utf16Offset) == offsetof(WGPUCompilationMessage, utf16Offset),\n            \"offsetof mismatch for CompilationMessage::utf16Offset\");\n    static_assert(offsetof(CompilationMessage, utf16Length) == offsetof(WGPUCompilationMessage, utf16Length),\n            \"offsetof mismatch for CompilationMessage::utf16Length\");\n\n    // ComputePassTimestampWrite\n\n    static_assert(sizeof(ComputePassTimestampWrite) == sizeof(WGPUComputePassTimestampWrite), \"sizeof mismatch for ComputePassTimestampWrite\");\n    static_assert(alignof(ComputePassTimestampWrite) == alignof(WGPUComputePassTimestampWrite), \"alignof mismatch for ComputePassTimestampWrite\");\n\n    static_assert(offsetof(ComputePassTimestampWrite, querySet) == offsetof(WGPUComputePassTimestampWrite, querySet),\n            \"offsetof mismatch for ComputePassTimestampWrite::querySet\");\n    static_assert(offsetof(ComputePassTimestampWrite, queryIndex) == offsetof(WGPUComputePassTimestampWrite, queryIndex),\n            \"offsetof mismatch for ComputePassTimestampWrite::queryIndex\");\n    static_assert(offsetof(ComputePassTimestampWrite, location) == offsetof(WGPUComputePassTimestampWrite, location),\n            \"offsetof mismatch for ComputePassTimestampWrite::location\");\n\n    // ConstantEntry\n\n    static_assert(sizeof(ConstantEntry) == sizeof(WGPUConstantEntry), \"sizeof mismatch for ConstantEntry\");\n    static_assert(alignof(ConstantEntry) == alignof(WGPUConstantEntry), \"alignof mismatch for ConstantEntry\");\n\n    static_assert(offsetof(ConstantEntry, nextInChain) == offsetof(WGPUConstantEntry, nextInChain),\n            \"offsetof mismatch for ConstantEntry::nextInChain\");\n    static_assert(offsetof(ConstantEntry, key) == offsetof(WGPUConstantEntry, key),\n            \"offsetof mismatch for ConstantEntry::key\");\n    static_assert(offsetof(ConstantEntry, value) == offsetof(WGPUConstantEntry, value),\n            \"offsetof mismatch for ConstantEntry::value\");\n\n    // Extent3D\n\n    static_assert(sizeof(Extent3D) == sizeof(WGPUExtent3D), \"sizeof mismatch for Extent3D\");\n    static_assert(alignof(Extent3D) == alignof(WGPUExtent3D), \"alignof mismatch for Extent3D\");\n\n    static_assert(offsetof(Extent3D, width) == offsetof(WGPUExtent3D, width),\n            \"offsetof mismatch for Extent3D::width\");\n    static_assert(offsetof(Extent3D, height) == offsetof(WGPUExtent3D, height),\n            \"offsetof mismatch for Extent3D::height\");\n    static_assert(offsetof(Extent3D, depthOrArrayLayers) == offsetof(WGPUExtent3D, depthOrArrayLayers),\n            \"offsetof mismatch for Extent3D::depthOrArrayLayers\");\n\n    // InstanceDescriptor\n\n    static_assert(sizeof(InstanceDescriptor) == sizeof(WGPUInstanceDescriptor), \"sizeof mismatch for InstanceDescriptor\");\n    static_assert(alignof(InstanceDescriptor) == alignof(WGPUInstanceDescriptor), \"alignof mismatch for InstanceDescriptor\");\n\n    static_assert(offsetof(InstanceDescriptor, nextInChain) == offsetof(WGPUInstanceDescriptor, nextInChain),\n            \"offsetof mismatch for InstanceDescriptor::nextInChain\");\n\n    // Limits\n\n    static_assert(sizeof(Limits) == sizeof(WGPULimits), \"sizeof mismatch for Limits\");\n    static_assert(alignof(Limits) == alignof(WGPULimits), \"alignof mismatch for Limits\");\n\n    static_assert(offsetof(Limits, maxTextureDimension1D) == offsetof(WGPULimits, maxTextureDimension1D),\n            \"offsetof mismatch for Limits::maxTextureDimension1D\");\n    static_assert(offsetof(Limits, maxTextureDimension2D) == offsetof(WGPULimits, maxTextureDimension2D),\n            \"offsetof mismatch for Limits::maxTextureDimension2D\");\n    static_assert(offsetof(Limits, maxTextureDimension3D) == offsetof(WGPULimits, maxTextureDimension3D),\n            \"offsetof mismatch for Limits::maxTextureDimension3D\");\n    static_assert(offsetof(Limits, maxTextureArrayLayers) == offsetof(WGPULimits, maxTextureArrayLayers),\n            \"offsetof mismatch for Limits::maxTextureArrayLayers\");\n    static_assert(offsetof(Limits, maxBindGroups) == offsetof(WGPULimits, maxBindGroups),\n            \"offsetof mismatch for Limits::maxBindGroups\");\n    static_assert(offsetof(Limits, maxBindGroupsPlusVertexBuffers) == offsetof(WGPULimits, maxBindGroupsPlusVertexBuffers),\n            \"offsetof mismatch for Limits::maxBindGroupsPlusVertexBuffers\");\n    static_assert(offsetof(Limits, maxBindingsPerBindGroup) == offsetof(WGPULimits, maxBindingsPerBindGroup),\n            \"offsetof mismatch for Limits::maxBindingsPerBindGroup\");\n    static_assert(offsetof(Limits, maxDynamicUniformBuffersPerPipelineLayout) == offsetof(WGPULimits, maxDynamicUniformBuffersPerPipelineLayout),\n            \"offsetof mismatch for Limits::maxDynamicUniformBuffersPerPipelineLayout\");\n    static_assert(offsetof(Limits, maxDynamicStorageBuffersPerPipelineLayout) == offsetof(WGPULimits, maxDynamicStorageBuffersPerPipelineLayout),\n            \"offsetof mismatch for Limits::maxDynamicStorageBuffersPerPipelineLayout\");\n    static_assert(offsetof(Limits, maxSampledTexturesPerShaderStage) == offsetof(WGPULimits, maxSampledTexturesPerShaderStage),\n            \"offsetof mismatch for Limits::maxSampledTexturesPerShaderStage\");\n    static_assert(offsetof(Limits, maxSamplersPerShaderStage) == offsetof(WGPULimits, maxSamplersPerShaderStage),\n            \"offsetof mismatch for Limits::maxSamplersPerShaderStage\");\n    static_assert(offsetof(Limits, maxStorageBuffersPerShaderStage) == offsetof(WGPULimits, maxStorageBuffersPerShaderStage),\n            \"offsetof mismatch for Limits::maxStorageBuffersPerShaderStage\");\n    static_assert(offsetof(Limits, maxStorageTexturesPerShaderStage) == offsetof(WGPULimits, maxStorageTexturesPerShaderStage),\n            \"offsetof mismatch for Limits::maxStorageTexturesPerShaderStage\");\n    static_assert(offsetof(Limits, maxUniformBuffersPerShaderStage) == offsetof(WGPULimits, maxUniformBuffersPerShaderStage),\n            \"offsetof mismatch for Limits::maxUniformBuffersPerShaderStage\");\n    static_assert(offsetof(Limits, maxUniformBufferBindingSize) == offsetof(WGPULimits, maxUniformBufferBindingSize),\n            \"offsetof mismatch for Limits::maxUniformBufferBindingSize\");\n    static_assert(offsetof(Limits, maxStorageBufferBindingSize) == offsetof(WGPULimits, maxStorageBufferBindingSize),\n            \"offsetof mismatch for Limits::maxStorageBufferBindingSize\");\n    static_assert(offsetof(Limits, minUniformBufferOffsetAlignment) == offsetof(WGPULimits, minUniformBufferOffsetAlignment),\n            \"offsetof mismatch for Limits::minUniformBufferOffsetAlignment\");\n    static_assert(offsetof(Limits, minStorageBufferOffsetAlignment) == offsetof(WGPULimits, minStorageBufferOffsetAlignment),\n            \"offsetof mismatch for Limits::minStorageBufferOffsetAlignment\");\n    static_assert(offsetof(Limits, maxVertexBuffers) == offsetof(WGPULimits, maxVertexBuffers),\n            \"offsetof mismatch for Limits::maxVertexBuffers\");\n    static_assert(offsetof(Limits, maxBufferSize) == offsetof(WGPULimits, maxBufferSize),\n            \"offsetof mismatch for Limits::maxBufferSize\");\n    static_assert(offsetof(Limits, maxVertexAttributes) == offsetof(WGPULimits, maxVertexAttributes),\n            \"offsetof mismatch for Limits::maxVertexAttributes\");\n    static_assert(offsetof(Limits, maxVertexBufferArrayStride) == offsetof(WGPULimits, maxVertexBufferArrayStride),\n            \"offsetof mismatch for Limits::maxVertexBufferArrayStride\");\n    static_assert(offsetof(Limits, maxInterStageShaderComponents) == offsetof(WGPULimits, maxInterStageShaderComponents),\n            \"offsetof mismatch for Limits::maxInterStageShaderComponents\");\n    static_assert(offsetof(Limits, maxInterStageShaderVariables) == offsetof(WGPULimits, maxInterStageShaderVariables),\n            \"offsetof mismatch for Limits::maxInterStageShaderVariables\");\n    static_assert(offsetof(Limits, maxColorAttachments) == offsetof(WGPULimits, maxColorAttachments),\n            \"offsetof mismatch for Limits::maxColorAttachments\");\n    static_assert(offsetof(Limits, maxColorAttachmentBytesPerSample) == offsetof(WGPULimits, maxColorAttachmentBytesPerSample),\n            \"offsetof mismatch for Limits::maxColorAttachmentBytesPerSample\");\n    static_assert(offsetof(Limits, maxComputeWorkgroupStorageSize) == offsetof(WGPULimits, maxComputeWorkgroupStorageSize),\n            \"offsetof mismatch for Limits::maxComputeWorkgroupStorageSize\");\n    static_assert(offsetof(Limits, maxComputeInvocationsPerWorkgroup) == offsetof(WGPULimits, maxComputeInvocationsPerWorkgroup),\n            \"offsetof mismatch for Limits::maxComputeInvocationsPerWorkgroup\");\n    static_assert(offsetof(Limits, maxComputeWorkgroupSizeX) == offsetof(WGPULimits, maxComputeWorkgroupSizeX),\n            \"offsetof mismatch for Limits::maxComputeWorkgroupSizeX\");\n    static_assert(offsetof(Limits, maxComputeWorkgroupSizeY) == offsetof(WGPULimits, maxComputeWorkgroupSizeY),\n            \"offsetof mismatch for Limits::maxComputeWorkgroupSizeY\");\n    static_assert(offsetof(Limits, maxComputeWorkgroupSizeZ) == offsetof(WGPULimits, maxComputeWorkgroupSizeZ),\n            \"offsetof mismatch for Limits::maxComputeWorkgroupSizeZ\");\n    static_assert(offsetof(Limits, maxComputeWorkgroupsPerDimension) == offsetof(WGPULimits, maxComputeWorkgroupsPerDimension),\n            \"offsetof mismatch for Limits::maxComputeWorkgroupsPerDimension\");\n\n    // MultisampleState\n\n    static_assert(sizeof(MultisampleState) == sizeof(WGPUMultisampleState), \"sizeof mismatch for MultisampleState\");\n    static_assert(alignof(MultisampleState) == alignof(WGPUMultisampleState), \"alignof mismatch for MultisampleState\");\n\n    static_assert(offsetof(MultisampleState, nextInChain) == offsetof(WGPUMultisampleState, nextInChain),\n            \"offsetof mismatch for MultisampleState::nextInChain\");\n    static_assert(offsetof(MultisampleState, count) == offsetof(WGPUMultisampleState, count),\n            \"offsetof mismatch for MultisampleState::count\");\n    static_assert(offsetof(MultisampleState, mask) == offsetof(WGPUMultisampleState, mask),\n            \"offsetof mismatch for MultisampleState::mask\");\n    static_assert(offsetof(MultisampleState, alphaToCoverageEnabled) == offsetof(WGPUMultisampleState, alphaToCoverageEnabled),\n            \"offsetof mismatch for MultisampleState::alphaToCoverageEnabled\");\n\n    // Origin3D\n\n    static_assert(sizeof(Origin3D) == sizeof(WGPUOrigin3D), \"sizeof mismatch for Origin3D\");\n    static_assert(alignof(Origin3D) == alignof(WGPUOrigin3D), \"alignof mismatch for Origin3D\");\n\n    static_assert(offsetof(Origin3D, x) == offsetof(WGPUOrigin3D, x),\n            \"offsetof mismatch for Origin3D::x\");\n    static_assert(offsetof(Origin3D, y) == offsetof(WGPUOrigin3D, y),\n            \"offsetof mismatch for Origin3D::y\");\n    static_assert(offsetof(Origin3D, z) == offsetof(WGPUOrigin3D, z),\n            \"offsetof mismatch for Origin3D::z\");\n\n    // PipelineLayoutDescriptor\n\n    static_assert(sizeof(PipelineLayoutDescriptor) == sizeof(WGPUPipelineLayoutDescriptor), \"sizeof mismatch for PipelineLayoutDescriptor\");\n    static_assert(alignof(PipelineLayoutDescriptor) == alignof(WGPUPipelineLayoutDescriptor), \"alignof mismatch for PipelineLayoutDescriptor\");\n\n    static_assert(offsetof(PipelineLayoutDescriptor, nextInChain) == offsetof(WGPUPipelineLayoutDescriptor, nextInChain),\n            \"offsetof mismatch for PipelineLayoutDescriptor::nextInChain\");\n    static_assert(offsetof(PipelineLayoutDescriptor, label) == offsetof(WGPUPipelineLayoutDescriptor, label),\n            \"offsetof mismatch for PipelineLayoutDescriptor::label\");\n    static_assert(offsetof(PipelineLayoutDescriptor, bindGroupLayoutCount) == offsetof(WGPUPipelineLayoutDescriptor, bindGroupLayoutCount),\n            \"offsetof mismatch for PipelineLayoutDescriptor::bindGroupLayoutCount\");\n    static_assert(offsetof(PipelineLayoutDescriptor, bindGroupLayouts) == offsetof(WGPUPipelineLayoutDescriptor, bindGroupLayouts),\n            \"offsetof mismatch for PipelineLayoutDescriptor::bindGroupLayouts\");\n\n    // PrimitiveDepthClipControl\n\n    static_assert(sizeof(PrimitiveDepthClipControl) == sizeof(WGPUPrimitiveDepthClipControl), \"sizeof mismatch for PrimitiveDepthClipControl\");\n    static_assert(alignof(PrimitiveDepthClipControl) == alignof(WGPUPrimitiveDepthClipControl), \"alignof mismatch for PrimitiveDepthClipControl\");\n\n    static_assert(offsetof(PrimitiveDepthClipControl, unclippedDepth) == offsetof(WGPUPrimitiveDepthClipControl, unclippedDepth),\n            \"offsetof mismatch for PrimitiveDepthClipControl::unclippedDepth\");\n\n    // PrimitiveState\n\n    static_assert(sizeof(PrimitiveState) == sizeof(WGPUPrimitiveState), \"sizeof mismatch for PrimitiveState\");\n    static_assert(alignof(PrimitiveState) == alignof(WGPUPrimitiveState), \"alignof mismatch for PrimitiveState\");\n\n    static_assert(offsetof(PrimitiveState, nextInChain) == offsetof(WGPUPrimitiveState, nextInChain),\n            \"offsetof mismatch for PrimitiveState::nextInChain\");\n    static_assert(offsetof(PrimitiveState, topology) == offsetof(WGPUPrimitiveState, topology),\n            \"offsetof mismatch for PrimitiveState::topology\");\n    static_assert(offsetof(PrimitiveState, stripIndexFormat) == offsetof(WGPUPrimitiveState, stripIndexFormat),\n            \"offsetof mismatch for PrimitiveState::stripIndexFormat\");\n    static_assert(offsetof(PrimitiveState, frontFace) == offsetof(WGPUPrimitiveState, frontFace),\n            \"offsetof mismatch for PrimitiveState::frontFace\");\n    static_assert(offsetof(PrimitiveState, cullMode) == offsetof(WGPUPrimitiveState, cullMode),\n            \"offsetof mismatch for PrimitiveState::cullMode\");\n\n    // QuerySetDescriptor\n\n    static_assert(sizeof(QuerySetDescriptor) == sizeof(WGPUQuerySetDescriptor), \"sizeof mismatch for QuerySetDescriptor\");\n    static_assert(alignof(QuerySetDescriptor) == alignof(WGPUQuerySetDescriptor), \"alignof mismatch for QuerySetDescriptor\");\n\n    static_assert(offsetof(QuerySetDescriptor, nextInChain) == offsetof(WGPUQuerySetDescriptor, nextInChain),\n            \"offsetof mismatch for QuerySetDescriptor::nextInChain\");\n    static_assert(offsetof(QuerySetDescriptor, label) == offsetof(WGPUQuerySetDescriptor, label),\n            \"offsetof mismatch for QuerySetDescriptor::label\");\n    static_assert(offsetof(QuerySetDescriptor, type) == offsetof(WGPUQuerySetDescriptor, type),\n            \"offsetof mismatch for QuerySetDescriptor::type\");\n    static_assert(offsetof(QuerySetDescriptor, count) == offsetof(WGPUQuerySetDescriptor, count),\n            \"offsetof mismatch for QuerySetDescriptor::count\");\n    static_assert(offsetof(QuerySetDescriptor, pipelineStatistics) == offsetof(WGPUQuerySetDescriptor, pipelineStatistics),\n            \"offsetof mismatch for QuerySetDescriptor::pipelineStatistics\");\n    static_assert(offsetof(QuerySetDescriptor, pipelineStatisticsCount) == offsetof(WGPUQuerySetDescriptor, pipelineStatisticsCount),\n            \"offsetof mismatch for QuerySetDescriptor::pipelineStatisticsCount\");\n\n    // QueueDescriptor\n\n    static_assert(sizeof(QueueDescriptor) == sizeof(WGPUQueueDescriptor), \"sizeof mismatch for QueueDescriptor\");\n    static_assert(alignof(QueueDescriptor) == alignof(WGPUQueueDescriptor), \"alignof mismatch for QueueDescriptor\");\n\n    static_assert(offsetof(QueueDescriptor, nextInChain) == offsetof(WGPUQueueDescriptor, nextInChain),\n            \"offsetof mismatch for QueueDescriptor::nextInChain\");\n    static_assert(offsetof(QueueDescriptor, label) == offsetof(WGPUQueueDescriptor, label),\n            \"offsetof mismatch for QueueDescriptor::label\");\n\n    // RenderBundleDescriptor\n\n    static_assert(sizeof(RenderBundleDescriptor) == sizeof(WGPURenderBundleDescriptor), \"sizeof mismatch for RenderBundleDescriptor\");\n    static_assert(alignof(RenderBundleDescriptor) == alignof(WGPURenderBundleDescriptor), \"alignof mismatch for RenderBundleDescriptor\");\n\n    static_assert(offsetof(RenderBundleDescriptor, nextInChain) == offsetof(WGPURenderBundleDescriptor, nextInChain),\n            \"offsetof mismatch for RenderBundleDescriptor::nextInChain\");\n    static_assert(offsetof(RenderBundleDescriptor, label) == offsetof(WGPURenderBundleDescriptor, label),\n            \"offsetof mismatch for RenderBundleDescriptor::label\");\n\n    // RenderBundleEncoderDescriptor\n\n    static_assert(sizeof(RenderBundleEncoderDescriptor) == sizeof(WGPURenderBundleEncoderDescriptor), \"sizeof mismatch for RenderBundleEncoderDescriptor\");\n    static_assert(alignof(RenderBundleEncoderDescriptor) == alignof(WGPURenderBundleEncoderDescriptor), \"alignof mismatch for RenderBundleEncoderDescriptor\");\n\n    static_assert(offsetof(RenderBundleEncoderDescriptor, nextInChain) == offsetof(WGPURenderBundleEncoderDescriptor, nextInChain),\n            \"offsetof mismatch for RenderBundleEncoderDescriptor::nextInChain\");\n    static_assert(offsetof(RenderBundleEncoderDescriptor, label) == offsetof(WGPURenderBundleEncoderDescriptor, label),\n            \"offsetof mismatch for RenderBundleEncoderDescriptor::label\");\n    static_assert(offsetof(RenderBundleEncoderDescriptor, colorFormatsCount) == offsetof(WGPURenderBundleEncoderDescriptor, colorFormatsCount),\n            \"offsetof mismatch for RenderBundleEncoderDescriptor::colorFormatsCount\");\n    static_assert(offsetof(RenderBundleEncoderDescriptor, colorFormats) == offsetof(WGPURenderBundleEncoderDescriptor, colorFormats),\n            \"offsetof mismatch for RenderBundleEncoderDescriptor::colorFormats\");\n    static_assert(offsetof(RenderBundleEncoderDescriptor, depthStencilFormat) == offsetof(WGPURenderBundleEncoderDescriptor, depthStencilFormat),\n            \"offsetof mismatch for RenderBundleEncoderDescriptor::depthStencilFormat\");\n    static_assert(offsetof(RenderBundleEncoderDescriptor, sampleCount) == offsetof(WGPURenderBundleEncoderDescriptor, sampleCount),\n            \"offsetof mismatch for RenderBundleEncoderDescriptor::sampleCount\");\n    static_assert(offsetof(RenderBundleEncoderDescriptor, depthReadOnly) == offsetof(WGPURenderBundleEncoderDescriptor, depthReadOnly),\n            \"offsetof mismatch for RenderBundleEncoderDescriptor::depthReadOnly\");\n    static_assert(offsetof(RenderBundleEncoderDescriptor, stencilReadOnly) == offsetof(WGPURenderBundleEncoderDescriptor, stencilReadOnly),\n            \"offsetof mismatch for RenderBundleEncoderDescriptor::stencilReadOnly\");\n\n    // RenderPassDepthStencilAttachment\n\n    static_assert(sizeof(RenderPassDepthStencilAttachment) == sizeof(WGPURenderPassDepthStencilAttachment), \"sizeof mismatch for RenderPassDepthStencilAttachment\");\n    static_assert(alignof(RenderPassDepthStencilAttachment) == alignof(WGPURenderPassDepthStencilAttachment), \"alignof mismatch for RenderPassDepthStencilAttachment\");\n\n    static_assert(offsetof(RenderPassDepthStencilAttachment, view) == offsetof(WGPURenderPassDepthStencilAttachment, view),\n            \"offsetof mismatch for RenderPassDepthStencilAttachment::view\");\n    static_assert(offsetof(RenderPassDepthStencilAttachment, depthLoadOp) == offsetof(WGPURenderPassDepthStencilAttachment, depthLoadOp),\n            \"offsetof mismatch for RenderPassDepthStencilAttachment::depthLoadOp\");\n    static_assert(offsetof(RenderPassDepthStencilAttachment, depthStoreOp) == offsetof(WGPURenderPassDepthStencilAttachment, depthStoreOp),\n            \"offsetof mismatch for RenderPassDepthStencilAttachment::depthStoreOp\");\n    static_assert(offsetof(RenderPassDepthStencilAttachment, depthClearValue) == offsetof(WGPURenderPassDepthStencilAttachment, depthClearValue),\n            \"offsetof mismatch for RenderPassDepthStencilAttachment::depthClearValue\");\n    static_assert(offsetof(RenderPassDepthStencilAttachment, depthReadOnly) == offsetof(WGPURenderPassDepthStencilAttachment, depthReadOnly),\n            \"offsetof mismatch for RenderPassDepthStencilAttachment::depthReadOnly\");\n    static_assert(offsetof(RenderPassDepthStencilAttachment, stencilLoadOp) == offsetof(WGPURenderPassDepthStencilAttachment, stencilLoadOp),\n            \"offsetof mismatch for RenderPassDepthStencilAttachment::stencilLoadOp\");\n    static_assert(offsetof(RenderPassDepthStencilAttachment, stencilStoreOp) == offsetof(WGPURenderPassDepthStencilAttachment, stencilStoreOp),\n            \"offsetof mismatch for RenderPassDepthStencilAttachment::stencilStoreOp\");\n    static_assert(offsetof(RenderPassDepthStencilAttachment, stencilClearValue) == offsetof(WGPURenderPassDepthStencilAttachment, stencilClearValue),\n            \"offsetof mismatch for RenderPassDepthStencilAttachment::stencilClearValue\");\n    static_assert(offsetof(RenderPassDepthStencilAttachment, stencilReadOnly) == offsetof(WGPURenderPassDepthStencilAttachment, stencilReadOnly),\n            \"offsetof mismatch for RenderPassDepthStencilAttachment::stencilReadOnly\");\n\n    // RenderPassDescriptorMaxDrawCount\n\n    static_assert(sizeof(RenderPassDescriptorMaxDrawCount) == sizeof(WGPURenderPassDescriptorMaxDrawCount), \"sizeof mismatch for RenderPassDescriptorMaxDrawCount\");\n    static_assert(alignof(RenderPassDescriptorMaxDrawCount) == alignof(WGPURenderPassDescriptorMaxDrawCount), \"alignof mismatch for RenderPassDescriptorMaxDrawCount\");\n\n    static_assert(offsetof(RenderPassDescriptorMaxDrawCount, maxDrawCount) == offsetof(WGPURenderPassDescriptorMaxDrawCount, maxDrawCount),\n            \"offsetof mismatch for RenderPassDescriptorMaxDrawCount::maxDrawCount\");\n\n    // RenderPassTimestampWrite\n\n    static_assert(sizeof(RenderPassTimestampWrite) == sizeof(WGPURenderPassTimestampWrite), \"sizeof mismatch for RenderPassTimestampWrite\");\n    static_assert(alignof(RenderPassTimestampWrite) == alignof(WGPURenderPassTimestampWrite), \"alignof mismatch for RenderPassTimestampWrite\");\n\n    static_assert(offsetof(RenderPassTimestampWrite, querySet) == offsetof(WGPURenderPassTimestampWrite, querySet),\n            \"offsetof mismatch for RenderPassTimestampWrite::querySet\");\n    static_assert(offsetof(RenderPassTimestampWrite, queryIndex) == offsetof(WGPURenderPassTimestampWrite, queryIndex),\n            \"offsetof mismatch for RenderPassTimestampWrite::queryIndex\");\n    static_assert(offsetof(RenderPassTimestampWrite, location) == offsetof(WGPURenderPassTimestampWrite, location),\n            \"offsetof mismatch for RenderPassTimestampWrite::location\");\n\n    // RequestAdapterOptions\n\n    static_assert(sizeof(RequestAdapterOptions) == sizeof(WGPURequestAdapterOptions), \"sizeof mismatch for RequestAdapterOptions\");\n    static_assert(alignof(RequestAdapterOptions) == alignof(WGPURequestAdapterOptions), \"alignof mismatch for RequestAdapterOptions\");\n\n    static_assert(offsetof(RequestAdapterOptions, nextInChain) == offsetof(WGPURequestAdapterOptions, nextInChain),\n            \"offsetof mismatch for RequestAdapterOptions::nextInChain\");\n    static_assert(offsetof(RequestAdapterOptions, compatibleSurface) == offsetof(WGPURequestAdapterOptions, compatibleSurface),\n            \"offsetof mismatch for RequestAdapterOptions::compatibleSurface\");\n    static_assert(offsetof(RequestAdapterOptions, powerPreference) == offsetof(WGPURequestAdapterOptions, powerPreference),\n            \"offsetof mismatch for RequestAdapterOptions::powerPreference\");\n    static_assert(offsetof(RequestAdapterOptions, backendType) == offsetof(WGPURequestAdapterOptions, backendType),\n            \"offsetof mismatch for RequestAdapterOptions::backendType\");\n    static_assert(offsetof(RequestAdapterOptions, forceFallbackAdapter) == offsetof(WGPURequestAdapterOptions, forceFallbackAdapter),\n            \"offsetof mismatch for RequestAdapterOptions::forceFallbackAdapter\");\n    static_assert(offsetof(RequestAdapterOptions, compatibilityMode) == offsetof(WGPURequestAdapterOptions, compatibilityMode),\n            \"offsetof mismatch for RequestAdapterOptions::compatibilityMode\");\n\n    // SamplerBindingLayout\n\n    static_assert(sizeof(SamplerBindingLayout) == sizeof(WGPUSamplerBindingLayout), \"sizeof mismatch for SamplerBindingLayout\");\n    static_assert(alignof(SamplerBindingLayout) == alignof(WGPUSamplerBindingLayout), \"alignof mismatch for SamplerBindingLayout\");\n\n    static_assert(offsetof(SamplerBindingLayout, nextInChain) == offsetof(WGPUSamplerBindingLayout, nextInChain),\n            \"offsetof mismatch for SamplerBindingLayout::nextInChain\");\n    static_assert(offsetof(SamplerBindingLayout, type) == offsetof(WGPUSamplerBindingLayout, type),\n            \"offsetof mismatch for SamplerBindingLayout::type\");\n\n    // SamplerDescriptor\n\n    static_assert(sizeof(SamplerDescriptor) == sizeof(WGPUSamplerDescriptor), \"sizeof mismatch for SamplerDescriptor\");\n    static_assert(alignof(SamplerDescriptor) == alignof(WGPUSamplerDescriptor), \"alignof mismatch for SamplerDescriptor\");\n\n    static_assert(offsetof(SamplerDescriptor, nextInChain) == offsetof(WGPUSamplerDescriptor, nextInChain),\n            \"offsetof mismatch for SamplerDescriptor::nextInChain\");\n    static_assert(offsetof(SamplerDescriptor, label) == offsetof(WGPUSamplerDescriptor, label),\n            \"offsetof mismatch for SamplerDescriptor::label\");\n    static_assert(offsetof(SamplerDescriptor, addressModeU) == offsetof(WGPUSamplerDescriptor, addressModeU),\n            \"offsetof mismatch for SamplerDescriptor::addressModeU\");\n    static_assert(offsetof(SamplerDescriptor, addressModeV) == offsetof(WGPUSamplerDescriptor, addressModeV),\n            \"offsetof mismatch for SamplerDescriptor::addressModeV\");\n    static_assert(offsetof(SamplerDescriptor, addressModeW) == offsetof(WGPUSamplerDescriptor, addressModeW),\n            \"offsetof mismatch for SamplerDescriptor::addressModeW\");\n    static_assert(offsetof(SamplerDescriptor, magFilter) == offsetof(WGPUSamplerDescriptor, magFilter),\n            \"offsetof mismatch for SamplerDescriptor::magFilter\");\n    static_assert(offsetof(SamplerDescriptor, minFilter) == offsetof(WGPUSamplerDescriptor, minFilter),\n            \"offsetof mismatch for SamplerDescriptor::minFilter\");\n    static_assert(offsetof(SamplerDescriptor, mipmapFilter) == offsetof(WGPUSamplerDescriptor, mipmapFilter),\n            \"offsetof mismatch for SamplerDescriptor::mipmapFilter\");\n    static_assert(offsetof(SamplerDescriptor, lodMinClamp) == offsetof(WGPUSamplerDescriptor, lodMinClamp),\n            \"offsetof mismatch for SamplerDescriptor::lodMinClamp\");\n    static_assert(offsetof(SamplerDescriptor, lodMaxClamp) == offsetof(WGPUSamplerDescriptor, lodMaxClamp),\n            \"offsetof mismatch for SamplerDescriptor::lodMaxClamp\");\n    static_assert(offsetof(SamplerDescriptor, compare) == offsetof(WGPUSamplerDescriptor, compare),\n            \"offsetof mismatch for SamplerDescriptor::compare\");\n    static_assert(offsetof(SamplerDescriptor, maxAnisotropy) == offsetof(WGPUSamplerDescriptor, maxAnisotropy),\n            \"offsetof mismatch for SamplerDescriptor::maxAnisotropy\");\n\n    // ShaderModuleDescriptor\n\n    static_assert(sizeof(ShaderModuleDescriptor) == sizeof(WGPUShaderModuleDescriptor), \"sizeof mismatch for ShaderModuleDescriptor\");\n    static_assert(alignof(ShaderModuleDescriptor) == alignof(WGPUShaderModuleDescriptor), \"alignof mismatch for ShaderModuleDescriptor\");\n\n    static_assert(offsetof(ShaderModuleDescriptor, nextInChain) == offsetof(WGPUShaderModuleDescriptor, nextInChain),\n            \"offsetof mismatch for ShaderModuleDescriptor::nextInChain\");\n    static_assert(offsetof(ShaderModuleDescriptor, label) == offsetof(WGPUShaderModuleDescriptor, label),\n            \"offsetof mismatch for ShaderModuleDescriptor::label\");\n\n    // ShaderModuleSPIRVDescriptor\n\n    static_assert(sizeof(ShaderModuleSPIRVDescriptor) == sizeof(WGPUShaderModuleSPIRVDescriptor), \"sizeof mismatch for ShaderModuleSPIRVDescriptor\");\n    static_assert(alignof(ShaderModuleSPIRVDescriptor) == alignof(WGPUShaderModuleSPIRVDescriptor), \"alignof mismatch for ShaderModuleSPIRVDescriptor\");\n\n    static_assert(offsetof(ShaderModuleSPIRVDescriptor, codeSize) == offsetof(WGPUShaderModuleSPIRVDescriptor, codeSize),\n            \"offsetof mismatch for ShaderModuleSPIRVDescriptor::codeSize\");\n    static_assert(offsetof(ShaderModuleSPIRVDescriptor, code) == offsetof(WGPUShaderModuleSPIRVDescriptor, code),\n            \"offsetof mismatch for ShaderModuleSPIRVDescriptor::code\");\n\n    // ShaderModuleWGSLDescriptor\n\n    static_assert(sizeof(ShaderModuleWGSLDescriptor) == sizeof(WGPUShaderModuleWGSLDescriptor), \"sizeof mismatch for ShaderModuleWGSLDescriptor\");\n    static_assert(alignof(ShaderModuleWGSLDescriptor) == alignof(WGPUShaderModuleWGSLDescriptor), \"alignof mismatch for ShaderModuleWGSLDescriptor\");\n\n    static_assert(offsetof(ShaderModuleWGSLDescriptor, code) == offsetof(WGPUShaderModuleWGSLDescriptor, code),\n            \"offsetof mismatch for ShaderModuleWGSLDescriptor::code\");\n\n    // StencilFaceState\n\n    static_assert(sizeof(StencilFaceState) == sizeof(WGPUStencilFaceState), \"sizeof mismatch for StencilFaceState\");\n    static_assert(alignof(StencilFaceState) == alignof(WGPUStencilFaceState), \"alignof mismatch for StencilFaceState\");\n\n    static_assert(offsetof(StencilFaceState, compare) == offsetof(WGPUStencilFaceState, compare),\n            \"offsetof mismatch for StencilFaceState::compare\");\n    static_assert(offsetof(StencilFaceState, failOp) == offsetof(WGPUStencilFaceState, failOp),\n            \"offsetof mismatch for StencilFaceState::failOp\");\n    static_assert(offsetof(StencilFaceState, depthFailOp) == offsetof(WGPUStencilFaceState, depthFailOp),\n            \"offsetof mismatch for StencilFaceState::depthFailOp\");\n    static_assert(offsetof(StencilFaceState, passOp) == offsetof(WGPUStencilFaceState, passOp),\n            \"offsetof mismatch for StencilFaceState::passOp\");\n\n    // StorageTextureBindingLayout\n\n    static_assert(sizeof(StorageTextureBindingLayout) == sizeof(WGPUStorageTextureBindingLayout), \"sizeof mismatch for StorageTextureBindingLayout\");\n    static_assert(alignof(StorageTextureBindingLayout) == alignof(WGPUStorageTextureBindingLayout), \"alignof mismatch for StorageTextureBindingLayout\");\n\n    static_assert(offsetof(StorageTextureBindingLayout, nextInChain) == offsetof(WGPUStorageTextureBindingLayout, nextInChain),\n            \"offsetof mismatch for StorageTextureBindingLayout::nextInChain\");\n    static_assert(offsetof(StorageTextureBindingLayout, access) == offsetof(WGPUStorageTextureBindingLayout, access),\n            \"offsetof mismatch for StorageTextureBindingLayout::access\");\n    static_assert(offsetof(StorageTextureBindingLayout, format) == offsetof(WGPUStorageTextureBindingLayout, format),\n            \"offsetof mismatch for StorageTextureBindingLayout::format\");\n    static_assert(offsetof(StorageTextureBindingLayout, viewDimension) == offsetof(WGPUStorageTextureBindingLayout, viewDimension),\n            \"offsetof mismatch for StorageTextureBindingLayout::viewDimension\");\n\n    // SurfaceDescriptor\n\n    static_assert(sizeof(SurfaceDescriptor) == sizeof(WGPUSurfaceDescriptor), \"sizeof mismatch for SurfaceDescriptor\");\n    static_assert(alignof(SurfaceDescriptor) == alignof(WGPUSurfaceDescriptor), \"alignof mismatch for SurfaceDescriptor\");\n\n    static_assert(offsetof(SurfaceDescriptor, nextInChain) == offsetof(WGPUSurfaceDescriptor, nextInChain),\n            \"offsetof mismatch for SurfaceDescriptor::nextInChain\");\n    static_assert(offsetof(SurfaceDescriptor, label) == offsetof(WGPUSurfaceDescriptor, label),\n            \"offsetof mismatch for SurfaceDescriptor::label\");\n\n    // SurfaceDescriptorFromCanvasHTMLSelector\n\n    static_assert(sizeof(SurfaceDescriptorFromCanvasHTMLSelector) == sizeof(WGPUSurfaceDescriptorFromCanvasHTMLSelector), \"sizeof mismatch for SurfaceDescriptorFromCanvasHTMLSelector\");\n    static_assert(alignof(SurfaceDescriptorFromCanvasHTMLSelector) == alignof(WGPUSurfaceDescriptorFromCanvasHTMLSelector), \"alignof mismatch for SurfaceDescriptorFromCanvasHTMLSelector\");\n\n    static_assert(offsetof(SurfaceDescriptorFromCanvasHTMLSelector, selector) == offsetof(WGPUSurfaceDescriptorFromCanvasHTMLSelector, selector),\n            \"offsetof mismatch for SurfaceDescriptorFromCanvasHTMLSelector::selector\");\n\n    // SwapChainDescriptor\n\n    static_assert(sizeof(SwapChainDescriptor) == sizeof(WGPUSwapChainDescriptor), \"sizeof mismatch for SwapChainDescriptor\");\n    static_assert(alignof(SwapChainDescriptor) == alignof(WGPUSwapChainDescriptor), \"alignof mismatch for SwapChainDescriptor\");\n\n    static_assert(offsetof(SwapChainDescriptor, nextInChain) == offsetof(WGPUSwapChainDescriptor, nextInChain),\n            \"offsetof mismatch for SwapChainDescriptor::nextInChain\");\n    static_assert(offsetof(SwapChainDescriptor, label) == offsetof(WGPUSwapChainDescriptor, label),\n            \"offsetof mismatch for SwapChainDescriptor::label\");\n    static_assert(offsetof(SwapChainDescriptor, usage) == offsetof(WGPUSwapChainDescriptor, usage),\n            \"offsetof mismatch for SwapChainDescriptor::usage\");\n    static_assert(offsetof(SwapChainDescriptor, format) == offsetof(WGPUSwapChainDescriptor, format),\n            \"offsetof mismatch for SwapChainDescriptor::format\");\n    static_assert(offsetof(SwapChainDescriptor, width) == offsetof(WGPUSwapChainDescriptor, width),\n            \"offsetof mismatch for SwapChainDescriptor::width\");\n    static_assert(offsetof(SwapChainDescriptor, height) == offsetof(WGPUSwapChainDescriptor, height),\n            \"offsetof mismatch for SwapChainDescriptor::height\");\n    static_assert(offsetof(SwapChainDescriptor, presentMode) == offsetof(WGPUSwapChainDescriptor, presentMode),\n            \"offsetof mismatch for SwapChainDescriptor::presentMode\");\n\n    // TextureBindingLayout\n\n    static_assert(sizeof(TextureBindingLayout) == sizeof(WGPUTextureBindingLayout), \"sizeof mismatch for TextureBindingLayout\");\n    static_assert(alignof(TextureBindingLayout) == alignof(WGPUTextureBindingLayout), \"alignof mismatch for TextureBindingLayout\");\n\n    static_assert(offsetof(TextureBindingLayout, nextInChain) == offsetof(WGPUTextureBindingLayout, nextInChain),\n            \"offsetof mismatch for TextureBindingLayout::nextInChain\");\n    static_assert(offsetof(TextureBindingLayout, sampleType) == offsetof(WGPUTextureBindingLayout, sampleType),\n            \"offsetof mismatch for TextureBindingLayout::sampleType\");\n    static_assert(offsetof(TextureBindingLayout, viewDimension) == offsetof(WGPUTextureBindingLayout, viewDimension),\n            \"offsetof mismatch for TextureBindingLayout::viewDimension\");\n    static_assert(offsetof(TextureBindingLayout, multisampled) == offsetof(WGPUTextureBindingLayout, multisampled),\n            \"offsetof mismatch for TextureBindingLayout::multisampled\");\n\n    // TextureDataLayout\n\n    static_assert(sizeof(TextureDataLayout) == sizeof(WGPUTextureDataLayout), \"sizeof mismatch for TextureDataLayout\");\n    static_assert(alignof(TextureDataLayout) == alignof(WGPUTextureDataLayout), \"alignof mismatch for TextureDataLayout\");\n\n    static_assert(offsetof(TextureDataLayout, nextInChain) == offsetof(WGPUTextureDataLayout, nextInChain),\n            \"offsetof mismatch for TextureDataLayout::nextInChain\");\n    static_assert(offsetof(TextureDataLayout, offset) == offsetof(WGPUTextureDataLayout, offset),\n            \"offsetof mismatch for TextureDataLayout::offset\");\n    static_assert(offsetof(TextureDataLayout, bytesPerRow) == offsetof(WGPUTextureDataLayout, bytesPerRow),\n            \"offsetof mismatch for TextureDataLayout::bytesPerRow\");\n    static_assert(offsetof(TextureDataLayout, rowsPerImage) == offsetof(WGPUTextureDataLayout, rowsPerImage),\n            \"offsetof mismatch for TextureDataLayout::rowsPerImage\");\n\n    // TextureViewDescriptor\n\n    static_assert(sizeof(TextureViewDescriptor) == sizeof(WGPUTextureViewDescriptor), \"sizeof mismatch for TextureViewDescriptor\");\n    static_assert(alignof(TextureViewDescriptor) == alignof(WGPUTextureViewDescriptor), \"alignof mismatch for TextureViewDescriptor\");\n\n    static_assert(offsetof(TextureViewDescriptor, nextInChain) == offsetof(WGPUTextureViewDescriptor, nextInChain),\n            \"offsetof mismatch for TextureViewDescriptor::nextInChain\");\n    static_assert(offsetof(TextureViewDescriptor, label) == offsetof(WGPUTextureViewDescriptor, label),\n            \"offsetof mismatch for TextureViewDescriptor::label\");\n    static_assert(offsetof(TextureViewDescriptor, format) == offsetof(WGPUTextureViewDescriptor, format),\n            \"offsetof mismatch for TextureViewDescriptor::format\");\n    static_assert(offsetof(TextureViewDescriptor, dimension) == offsetof(WGPUTextureViewDescriptor, dimension),\n            \"offsetof mismatch for TextureViewDescriptor::dimension\");\n    static_assert(offsetof(TextureViewDescriptor, baseMipLevel) == offsetof(WGPUTextureViewDescriptor, baseMipLevel),\n            \"offsetof mismatch for TextureViewDescriptor::baseMipLevel\");\n    static_assert(offsetof(TextureViewDescriptor, mipLevelCount) == offsetof(WGPUTextureViewDescriptor, mipLevelCount),\n            \"offsetof mismatch for TextureViewDescriptor::mipLevelCount\");\n    static_assert(offsetof(TextureViewDescriptor, baseArrayLayer) == offsetof(WGPUTextureViewDescriptor, baseArrayLayer),\n            \"offsetof mismatch for TextureViewDescriptor::baseArrayLayer\");\n    static_assert(offsetof(TextureViewDescriptor, arrayLayerCount) == offsetof(WGPUTextureViewDescriptor, arrayLayerCount),\n            \"offsetof mismatch for TextureViewDescriptor::arrayLayerCount\");\n    static_assert(offsetof(TextureViewDescriptor, aspect) == offsetof(WGPUTextureViewDescriptor, aspect),\n            \"offsetof mismatch for TextureViewDescriptor::aspect\");\n\n    // VertexAttribute\n\n    static_assert(sizeof(VertexAttribute) == sizeof(WGPUVertexAttribute), \"sizeof mismatch for VertexAttribute\");\n    static_assert(alignof(VertexAttribute) == alignof(WGPUVertexAttribute), \"alignof mismatch for VertexAttribute\");\n\n    static_assert(offsetof(VertexAttribute, format) == offsetof(WGPUVertexAttribute, format),\n            \"offsetof mismatch for VertexAttribute::format\");\n    static_assert(offsetof(VertexAttribute, offset) == offsetof(WGPUVertexAttribute, offset),\n            \"offsetof mismatch for VertexAttribute::offset\");\n    static_assert(offsetof(VertexAttribute, shaderLocation) == offsetof(WGPUVertexAttribute, shaderLocation),\n            \"offsetof mismatch for VertexAttribute::shaderLocation\");\n\n    // BindGroupDescriptor\n\n    static_assert(sizeof(BindGroupDescriptor) == sizeof(WGPUBindGroupDescriptor), \"sizeof mismatch for BindGroupDescriptor\");\n    static_assert(alignof(BindGroupDescriptor) == alignof(WGPUBindGroupDescriptor), \"alignof mismatch for BindGroupDescriptor\");\n\n    static_assert(offsetof(BindGroupDescriptor, nextInChain) == offsetof(WGPUBindGroupDescriptor, nextInChain),\n            \"offsetof mismatch for BindGroupDescriptor::nextInChain\");\n    static_assert(offsetof(BindGroupDescriptor, label) == offsetof(WGPUBindGroupDescriptor, label),\n            \"offsetof mismatch for BindGroupDescriptor::label\");\n    static_assert(offsetof(BindGroupDescriptor, layout) == offsetof(WGPUBindGroupDescriptor, layout),\n            \"offsetof mismatch for BindGroupDescriptor::layout\");\n    static_assert(offsetof(BindGroupDescriptor, entryCount) == offsetof(WGPUBindGroupDescriptor, entryCount),\n            \"offsetof mismatch for BindGroupDescriptor::entryCount\");\n    static_assert(offsetof(BindGroupDescriptor, entries) == offsetof(WGPUBindGroupDescriptor, entries),\n            \"offsetof mismatch for BindGroupDescriptor::entries\");\n\n    // BindGroupLayoutEntry\n\n    static_assert(sizeof(BindGroupLayoutEntry) == sizeof(WGPUBindGroupLayoutEntry), \"sizeof mismatch for BindGroupLayoutEntry\");\n    static_assert(alignof(BindGroupLayoutEntry) == alignof(WGPUBindGroupLayoutEntry), \"alignof mismatch for BindGroupLayoutEntry\");\n\n    static_assert(offsetof(BindGroupLayoutEntry, nextInChain) == offsetof(WGPUBindGroupLayoutEntry, nextInChain),\n            \"offsetof mismatch for BindGroupLayoutEntry::nextInChain\");\n    static_assert(offsetof(BindGroupLayoutEntry, binding) == offsetof(WGPUBindGroupLayoutEntry, binding),\n            \"offsetof mismatch for BindGroupLayoutEntry::binding\");\n    static_assert(offsetof(BindGroupLayoutEntry, visibility) == offsetof(WGPUBindGroupLayoutEntry, visibility),\n            \"offsetof mismatch for BindGroupLayoutEntry::visibility\");\n    static_assert(offsetof(BindGroupLayoutEntry, buffer) == offsetof(WGPUBindGroupLayoutEntry, buffer),\n            \"offsetof mismatch for BindGroupLayoutEntry::buffer\");\n    static_assert(offsetof(BindGroupLayoutEntry, sampler) == offsetof(WGPUBindGroupLayoutEntry, sampler),\n            \"offsetof mismatch for BindGroupLayoutEntry::sampler\");\n    static_assert(offsetof(BindGroupLayoutEntry, texture) == offsetof(WGPUBindGroupLayoutEntry, texture),\n            \"offsetof mismatch for BindGroupLayoutEntry::texture\");\n    static_assert(offsetof(BindGroupLayoutEntry, storageTexture) == offsetof(WGPUBindGroupLayoutEntry, storageTexture),\n            \"offsetof mismatch for BindGroupLayoutEntry::storageTexture\");\n\n    // BlendState\n\n    static_assert(sizeof(BlendState) == sizeof(WGPUBlendState), \"sizeof mismatch for BlendState\");\n    static_assert(alignof(BlendState) == alignof(WGPUBlendState), \"alignof mismatch for BlendState\");\n\n    static_assert(offsetof(BlendState, color) == offsetof(WGPUBlendState, color),\n            \"offsetof mismatch for BlendState::color\");\n    static_assert(offsetof(BlendState, alpha) == offsetof(WGPUBlendState, alpha),\n            \"offsetof mismatch for BlendState::alpha\");\n\n    // CompilationInfo\n\n    static_assert(sizeof(CompilationInfo) == sizeof(WGPUCompilationInfo), \"sizeof mismatch for CompilationInfo\");\n    static_assert(alignof(CompilationInfo) == alignof(WGPUCompilationInfo), \"alignof mismatch for CompilationInfo\");\n\n    static_assert(offsetof(CompilationInfo, nextInChain) == offsetof(WGPUCompilationInfo, nextInChain),\n            \"offsetof mismatch for CompilationInfo::nextInChain\");\n    static_assert(offsetof(CompilationInfo, messageCount) == offsetof(WGPUCompilationInfo, messageCount),\n            \"offsetof mismatch for CompilationInfo::messageCount\");\n    static_assert(offsetof(CompilationInfo, messages) == offsetof(WGPUCompilationInfo, messages),\n            \"offsetof mismatch for CompilationInfo::messages\");\n\n    // ComputePassDescriptor\n\n    static_assert(sizeof(ComputePassDescriptor) == sizeof(WGPUComputePassDescriptor), \"sizeof mismatch for ComputePassDescriptor\");\n    static_assert(alignof(ComputePassDescriptor) == alignof(WGPUComputePassDescriptor), \"alignof mismatch for ComputePassDescriptor\");\n\n    static_assert(offsetof(ComputePassDescriptor, nextInChain) == offsetof(WGPUComputePassDescriptor, nextInChain),\n            \"offsetof mismatch for ComputePassDescriptor::nextInChain\");\n    static_assert(offsetof(ComputePassDescriptor, label) == offsetof(WGPUComputePassDescriptor, label),\n            \"offsetof mismatch for ComputePassDescriptor::label\");\n    static_assert(offsetof(ComputePassDescriptor, timestampWriteCount) == offsetof(WGPUComputePassDescriptor, timestampWriteCount),\n            \"offsetof mismatch for ComputePassDescriptor::timestampWriteCount\");\n    static_assert(offsetof(ComputePassDescriptor, timestampWrites) == offsetof(WGPUComputePassDescriptor, timestampWrites),\n            \"offsetof mismatch for ComputePassDescriptor::timestampWrites\");\n\n    // DepthStencilState\n\n    static_assert(sizeof(DepthStencilState) == sizeof(WGPUDepthStencilState), \"sizeof mismatch for DepthStencilState\");\n    static_assert(alignof(DepthStencilState) == alignof(WGPUDepthStencilState), \"alignof mismatch for DepthStencilState\");\n\n    static_assert(offsetof(DepthStencilState, nextInChain) == offsetof(WGPUDepthStencilState, nextInChain),\n            \"offsetof mismatch for DepthStencilState::nextInChain\");\n    static_assert(offsetof(DepthStencilState, format) == offsetof(WGPUDepthStencilState, format),\n            \"offsetof mismatch for DepthStencilState::format\");\n    static_assert(offsetof(DepthStencilState, depthWriteEnabled) == offsetof(WGPUDepthStencilState, depthWriteEnabled),\n            \"offsetof mismatch for DepthStencilState::depthWriteEnabled\");\n    static_assert(offsetof(DepthStencilState, depthCompare) == offsetof(WGPUDepthStencilState, depthCompare),\n            \"offsetof mismatch for DepthStencilState::depthCompare\");\n    static_assert(offsetof(DepthStencilState, stencilFront) == offsetof(WGPUDepthStencilState, stencilFront),\n            \"offsetof mismatch for DepthStencilState::stencilFront\");\n    static_assert(offsetof(DepthStencilState, stencilBack) == offsetof(WGPUDepthStencilState, stencilBack),\n            \"offsetof mismatch for DepthStencilState::stencilBack\");\n    static_assert(offsetof(DepthStencilState, stencilReadMask) == offsetof(WGPUDepthStencilState, stencilReadMask),\n            \"offsetof mismatch for DepthStencilState::stencilReadMask\");\n    static_assert(offsetof(DepthStencilState, stencilWriteMask) == offsetof(WGPUDepthStencilState, stencilWriteMask),\n            \"offsetof mismatch for DepthStencilState::stencilWriteMask\");\n    static_assert(offsetof(DepthStencilState, depthBias) == offsetof(WGPUDepthStencilState, depthBias),\n            \"offsetof mismatch for DepthStencilState::depthBias\");\n    static_assert(offsetof(DepthStencilState, depthBiasSlopeScale) == offsetof(WGPUDepthStencilState, depthBiasSlopeScale),\n            \"offsetof mismatch for DepthStencilState::depthBiasSlopeScale\");\n    static_assert(offsetof(DepthStencilState, depthBiasClamp) == offsetof(WGPUDepthStencilState, depthBiasClamp),\n            \"offsetof mismatch for DepthStencilState::depthBiasClamp\");\n\n    // ImageCopyBuffer\n\n    static_assert(sizeof(ImageCopyBuffer) == sizeof(WGPUImageCopyBuffer), \"sizeof mismatch for ImageCopyBuffer\");\n    static_assert(alignof(ImageCopyBuffer) == alignof(WGPUImageCopyBuffer), \"alignof mismatch for ImageCopyBuffer\");\n\n    static_assert(offsetof(ImageCopyBuffer, nextInChain) == offsetof(WGPUImageCopyBuffer, nextInChain),\n            \"offsetof mismatch for ImageCopyBuffer::nextInChain\");\n    static_assert(offsetof(ImageCopyBuffer, layout) == offsetof(WGPUImageCopyBuffer, layout),\n            \"offsetof mismatch for ImageCopyBuffer::layout\");\n    static_assert(offsetof(ImageCopyBuffer, buffer) == offsetof(WGPUImageCopyBuffer, buffer),\n            \"offsetof mismatch for ImageCopyBuffer::buffer\");\n\n    // ImageCopyTexture\n\n    static_assert(sizeof(ImageCopyTexture) == sizeof(WGPUImageCopyTexture), \"sizeof mismatch for ImageCopyTexture\");\n    static_assert(alignof(ImageCopyTexture) == alignof(WGPUImageCopyTexture), \"alignof mismatch for ImageCopyTexture\");\n\n    static_assert(offsetof(ImageCopyTexture, nextInChain) == offsetof(WGPUImageCopyTexture, nextInChain),\n            \"offsetof mismatch for ImageCopyTexture::nextInChain\");\n    static_assert(offsetof(ImageCopyTexture, texture) == offsetof(WGPUImageCopyTexture, texture),\n            \"offsetof mismatch for ImageCopyTexture::texture\");\n    static_assert(offsetof(ImageCopyTexture, mipLevel) == offsetof(WGPUImageCopyTexture, mipLevel),\n            \"offsetof mismatch for ImageCopyTexture::mipLevel\");\n    static_assert(offsetof(ImageCopyTexture, origin) == offsetof(WGPUImageCopyTexture, origin),\n            \"offsetof mismatch for ImageCopyTexture::origin\");\n    static_assert(offsetof(ImageCopyTexture, aspect) == offsetof(WGPUImageCopyTexture, aspect),\n            \"offsetof mismatch for ImageCopyTexture::aspect\");\n\n    // ProgrammableStageDescriptor\n\n    static_assert(sizeof(ProgrammableStageDescriptor) == sizeof(WGPUProgrammableStageDescriptor), \"sizeof mismatch for ProgrammableStageDescriptor\");\n    static_assert(alignof(ProgrammableStageDescriptor) == alignof(WGPUProgrammableStageDescriptor), \"alignof mismatch for ProgrammableStageDescriptor\");\n\n    static_assert(offsetof(ProgrammableStageDescriptor, nextInChain) == offsetof(WGPUProgrammableStageDescriptor, nextInChain),\n            \"offsetof mismatch for ProgrammableStageDescriptor::nextInChain\");\n    static_assert(offsetof(ProgrammableStageDescriptor, module) == offsetof(WGPUProgrammableStageDescriptor, module),\n            \"offsetof mismatch for ProgrammableStageDescriptor::module\");\n    static_assert(offsetof(ProgrammableStageDescriptor, entryPoint) == offsetof(WGPUProgrammableStageDescriptor, entryPoint),\n            \"offsetof mismatch for ProgrammableStageDescriptor::entryPoint\");\n    static_assert(offsetof(ProgrammableStageDescriptor, constantCount) == offsetof(WGPUProgrammableStageDescriptor, constantCount),\n            \"offsetof mismatch for ProgrammableStageDescriptor::constantCount\");\n    static_assert(offsetof(ProgrammableStageDescriptor, constants) == offsetof(WGPUProgrammableStageDescriptor, constants),\n            \"offsetof mismatch for ProgrammableStageDescriptor::constants\");\n\n    // RenderPassColorAttachment\n\n    static_assert(sizeof(RenderPassColorAttachment) == sizeof(WGPURenderPassColorAttachment), \"sizeof mismatch for RenderPassColorAttachment\");\n    static_assert(alignof(RenderPassColorAttachment) == alignof(WGPURenderPassColorAttachment), \"alignof mismatch for RenderPassColorAttachment\");\n\n    static_assert(offsetof(RenderPassColorAttachment, nextInChain) == offsetof(WGPURenderPassColorAttachment, nextInChain),\n            \"offsetof mismatch for RenderPassColorAttachment::nextInChain\");\n    static_assert(offsetof(RenderPassColorAttachment, view) == offsetof(WGPURenderPassColorAttachment, view),\n            \"offsetof mismatch for RenderPassColorAttachment::view\");\n    static_assert(offsetof(RenderPassColorAttachment, resolveTarget) == offsetof(WGPURenderPassColorAttachment, resolveTarget),\n            \"offsetof mismatch for RenderPassColorAttachment::resolveTarget\");\n    static_assert(offsetof(RenderPassColorAttachment, loadOp) == offsetof(WGPURenderPassColorAttachment, loadOp),\n            \"offsetof mismatch for RenderPassColorAttachment::loadOp\");\n    static_assert(offsetof(RenderPassColorAttachment, storeOp) == offsetof(WGPURenderPassColorAttachment, storeOp),\n            \"offsetof mismatch for RenderPassColorAttachment::storeOp\");\n    static_assert(offsetof(RenderPassColorAttachment, clearValue) == offsetof(WGPURenderPassColorAttachment, clearValue),\n            \"offsetof mismatch for RenderPassColorAttachment::clearValue\");\n\n    // RequiredLimits\n\n    static_assert(sizeof(RequiredLimits) == sizeof(WGPURequiredLimits), \"sizeof mismatch for RequiredLimits\");\n    static_assert(alignof(RequiredLimits) == alignof(WGPURequiredLimits), \"alignof mismatch for RequiredLimits\");\n\n    static_assert(offsetof(RequiredLimits, nextInChain) == offsetof(WGPURequiredLimits, nextInChain),\n            \"offsetof mismatch for RequiredLimits::nextInChain\");\n    static_assert(offsetof(RequiredLimits, limits) == offsetof(WGPURequiredLimits, limits),\n            \"offsetof mismatch for RequiredLimits::limits\");\n\n    // SupportedLimits\n\n    static_assert(sizeof(SupportedLimits) == sizeof(WGPUSupportedLimits), \"sizeof mismatch for SupportedLimits\");\n    static_assert(alignof(SupportedLimits) == alignof(WGPUSupportedLimits), \"alignof mismatch for SupportedLimits\");\n\n    static_assert(offsetof(SupportedLimits, nextInChain) == offsetof(WGPUSupportedLimits, nextInChain),\n            \"offsetof mismatch for SupportedLimits::nextInChain\");\n    static_assert(offsetof(SupportedLimits, limits) == offsetof(WGPUSupportedLimits, limits),\n            \"offsetof mismatch for SupportedLimits::limits\");\n\n    // TextureDescriptor\n\n    static_assert(sizeof(TextureDescriptor) == sizeof(WGPUTextureDescriptor), \"sizeof mismatch for TextureDescriptor\");\n    static_assert(alignof(TextureDescriptor) == alignof(WGPUTextureDescriptor), \"alignof mismatch for TextureDescriptor\");\n\n    static_assert(offsetof(TextureDescriptor, nextInChain) == offsetof(WGPUTextureDescriptor, nextInChain),\n            \"offsetof mismatch for TextureDescriptor::nextInChain\");\n    static_assert(offsetof(TextureDescriptor, label) == offsetof(WGPUTextureDescriptor, label),\n            \"offsetof mismatch for TextureDescriptor::label\");\n    static_assert(offsetof(TextureDescriptor, usage) == offsetof(WGPUTextureDescriptor, usage),\n            \"offsetof mismatch for TextureDescriptor::usage\");\n    static_assert(offsetof(TextureDescriptor, dimension) == offsetof(WGPUTextureDescriptor, dimension),\n            \"offsetof mismatch for TextureDescriptor::dimension\");\n    static_assert(offsetof(TextureDescriptor, size) == offsetof(WGPUTextureDescriptor, size),\n            \"offsetof mismatch for TextureDescriptor::size\");\n    static_assert(offsetof(TextureDescriptor, format) == offsetof(WGPUTextureDescriptor, format),\n            \"offsetof mismatch for TextureDescriptor::format\");\n    static_assert(offsetof(TextureDescriptor, mipLevelCount) == offsetof(WGPUTextureDescriptor, mipLevelCount),\n            \"offsetof mismatch for TextureDescriptor::mipLevelCount\");\n    static_assert(offsetof(TextureDescriptor, sampleCount) == offsetof(WGPUTextureDescriptor, sampleCount),\n            \"offsetof mismatch for TextureDescriptor::sampleCount\");\n    static_assert(offsetof(TextureDescriptor, viewFormatCount) == offsetof(WGPUTextureDescriptor, viewFormatCount),\n            \"offsetof mismatch for TextureDescriptor::viewFormatCount\");\n    static_assert(offsetof(TextureDescriptor, viewFormats) == offsetof(WGPUTextureDescriptor, viewFormats),\n            \"offsetof mismatch for TextureDescriptor::viewFormats\");\n\n    // VertexBufferLayout\n\n    static_assert(sizeof(VertexBufferLayout) == sizeof(WGPUVertexBufferLayout), \"sizeof mismatch for VertexBufferLayout\");\n    static_assert(alignof(VertexBufferLayout) == alignof(WGPUVertexBufferLayout), \"alignof mismatch for VertexBufferLayout\");\n\n    static_assert(offsetof(VertexBufferLayout, arrayStride) == offsetof(WGPUVertexBufferLayout, arrayStride),\n            \"offsetof mismatch for VertexBufferLayout::arrayStride\");\n    static_assert(offsetof(VertexBufferLayout, stepMode) == offsetof(WGPUVertexBufferLayout, stepMode),\n            \"offsetof mismatch for VertexBufferLayout::stepMode\");\n    static_assert(offsetof(VertexBufferLayout, attributeCount) == offsetof(WGPUVertexBufferLayout, attributeCount),\n            \"offsetof mismatch for VertexBufferLayout::attributeCount\");\n    static_assert(offsetof(VertexBufferLayout, attributes) == offsetof(WGPUVertexBufferLayout, attributes),\n            \"offsetof mismatch for VertexBufferLayout::attributes\");\n\n    // BindGroupLayoutDescriptor\n\n    static_assert(sizeof(BindGroupLayoutDescriptor) == sizeof(WGPUBindGroupLayoutDescriptor), \"sizeof mismatch for BindGroupLayoutDescriptor\");\n    static_assert(alignof(BindGroupLayoutDescriptor) == alignof(WGPUBindGroupLayoutDescriptor), \"alignof mismatch for BindGroupLayoutDescriptor\");\n\n    static_assert(offsetof(BindGroupLayoutDescriptor, nextInChain) == offsetof(WGPUBindGroupLayoutDescriptor, nextInChain),\n            \"offsetof mismatch for BindGroupLayoutDescriptor::nextInChain\");\n    static_assert(offsetof(BindGroupLayoutDescriptor, label) == offsetof(WGPUBindGroupLayoutDescriptor, label),\n            \"offsetof mismatch for BindGroupLayoutDescriptor::label\");\n    static_assert(offsetof(BindGroupLayoutDescriptor, entryCount) == offsetof(WGPUBindGroupLayoutDescriptor, entryCount),\n            \"offsetof mismatch for BindGroupLayoutDescriptor::entryCount\");\n    static_assert(offsetof(BindGroupLayoutDescriptor, entries) == offsetof(WGPUBindGroupLayoutDescriptor, entries),\n            \"offsetof mismatch for BindGroupLayoutDescriptor::entries\");\n\n    // ColorTargetState\n\n    static_assert(sizeof(ColorTargetState) == sizeof(WGPUColorTargetState), \"sizeof mismatch for ColorTargetState\");\n    static_assert(alignof(ColorTargetState) == alignof(WGPUColorTargetState), \"alignof mismatch for ColorTargetState\");\n\n    static_assert(offsetof(ColorTargetState, nextInChain) == offsetof(WGPUColorTargetState, nextInChain),\n            \"offsetof mismatch for ColorTargetState::nextInChain\");\n    static_assert(offsetof(ColorTargetState, format) == offsetof(WGPUColorTargetState, format),\n            \"offsetof mismatch for ColorTargetState::format\");\n    static_assert(offsetof(ColorTargetState, blend) == offsetof(WGPUColorTargetState, blend),\n            \"offsetof mismatch for ColorTargetState::blend\");\n    static_assert(offsetof(ColorTargetState, writeMask) == offsetof(WGPUColorTargetState, writeMask),\n            \"offsetof mismatch for ColorTargetState::writeMask\");\n\n    // ComputePipelineDescriptor\n\n    static_assert(sizeof(ComputePipelineDescriptor) == sizeof(WGPUComputePipelineDescriptor), \"sizeof mismatch for ComputePipelineDescriptor\");\n    static_assert(alignof(ComputePipelineDescriptor) == alignof(WGPUComputePipelineDescriptor), \"alignof mismatch for ComputePipelineDescriptor\");\n\n    static_assert(offsetof(ComputePipelineDescriptor, nextInChain) == offsetof(WGPUComputePipelineDescriptor, nextInChain),\n            \"offsetof mismatch for ComputePipelineDescriptor::nextInChain\");\n    static_assert(offsetof(ComputePipelineDescriptor, label) == offsetof(WGPUComputePipelineDescriptor, label),\n            \"offsetof mismatch for ComputePipelineDescriptor::label\");\n    static_assert(offsetof(ComputePipelineDescriptor, layout) == offsetof(WGPUComputePipelineDescriptor, layout),\n            \"offsetof mismatch for ComputePipelineDescriptor::layout\");\n    static_assert(offsetof(ComputePipelineDescriptor, compute) == offsetof(WGPUComputePipelineDescriptor, compute),\n            \"offsetof mismatch for ComputePipelineDescriptor::compute\");\n\n    // DeviceDescriptor\n\n    static_assert(sizeof(DeviceDescriptor) == sizeof(WGPUDeviceDescriptor), \"sizeof mismatch for DeviceDescriptor\");\n    static_assert(alignof(DeviceDescriptor) == alignof(WGPUDeviceDescriptor), \"alignof mismatch for DeviceDescriptor\");\n\n    static_assert(offsetof(DeviceDescriptor, nextInChain) == offsetof(WGPUDeviceDescriptor, nextInChain),\n            \"offsetof mismatch for DeviceDescriptor::nextInChain\");\n    static_assert(offsetof(DeviceDescriptor, label) == offsetof(WGPUDeviceDescriptor, label),\n            \"offsetof mismatch for DeviceDescriptor::label\");\n    static_assert(offsetof(DeviceDescriptor, requiredFeaturesCount) == offsetof(WGPUDeviceDescriptor, requiredFeaturesCount),\n            \"offsetof mismatch for DeviceDescriptor::requiredFeaturesCount\");\n    static_assert(offsetof(DeviceDescriptor, requiredFeatures) == offsetof(WGPUDeviceDescriptor, requiredFeatures),\n            \"offsetof mismatch for DeviceDescriptor::requiredFeatures\");\n    static_assert(offsetof(DeviceDescriptor, requiredLimits) == offsetof(WGPUDeviceDescriptor, requiredLimits),\n            \"offsetof mismatch for DeviceDescriptor::requiredLimits\");\n    static_assert(offsetof(DeviceDescriptor, defaultQueue) == offsetof(WGPUDeviceDescriptor, defaultQueue),\n            \"offsetof mismatch for DeviceDescriptor::defaultQueue\");\n    static_assert(offsetof(DeviceDescriptor, deviceLostCallback) == offsetof(WGPUDeviceDescriptor, deviceLostCallback),\n            \"offsetof mismatch for DeviceDescriptor::deviceLostCallback\");\n    static_assert(offsetof(DeviceDescriptor, deviceLostUserdata) == offsetof(WGPUDeviceDescriptor, deviceLostUserdata),\n            \"offsetof mismatch for DeviceDescriptor::deviceLostUserdata\");\n\n    // RenderPassDescriptor\n\n    static_assert(sizeof(RenderPassDescriptor) == sizeof(WGPURenderPassDescriptor), \"sizeof mismatch for RenderPassDescriptor\");\n    static_assert(alignof(RenderPassDescriptor) == alignof(WGPURenderPassDescriptor), \"alignof mismatch for RenderPassDescriptor\");\n\n    static_assert(offsetof(RenderPassDescriptor, nextInChain) == offsetof(WGPURenderPassDescriptor, nextInChain),\n            \"offsetof mismatch for RenderPassDescriptor::nextInChain\");\n    static_assert(offsetof(RenderPassDescriptor, label) == offsetof(WGPURenderPassDescriptor, label),\n            \"offsetof mismatch for RenderPassDescriptor::label\");\n    static_assert(offsetof(RenderPassDescriptor, colorAttachmentCount) == offsetof(WGPURenderPassDescriptor, colorAttachmentCount),\n            \"offsetof mismatch for RenderPassDescriptor::colorAttachmentCount\");\n    static_assert(offsetof(RenderPassDescriptor, colorAttachments) == offsetof(WGPURenderPassDescriptor, colorAttachments),\n            \"offsetof mismatch for RenderPassDescriptor::colorAttachments\");\n    static_assert(offsetof(RenderPassDescriptor, depthStencilAttachment) == offsetof(WGPURenderPassDescriptor, depthStencilAttachment),\n            \"offsetof mismatch for RenderPassDescriptor::depthStencilAttachment\");\n    static_assert(offsetof(RenderPassDescriptor, occlusionQuerySet) == offsetof(WGPURenderPassDescriptor, occlusionQuerySet),\n            \"offsetof mismatch for RenderPassDescriptor::occlusionQuerySet\");\n    static_assert(offsetof(RenderPassDescriptor, timestampWriteCount) == offsetof(WGPURenderPassDescriptor, timestampWriteCount),\n            \"offsetof mismatch for RenderPassDescriptor::timestampWriteCount\");\n    static_assert(offsetof(RenderPassDescriptor, timestampWrites) == offsetof(WGPURenderPassDescriptor, timestampWrites),\n            \"offsetof mismatch for RenderPassDescriptor::timestampWrites\");\n\n    // VertexState\n\n    static_assert(sizeof(VertexState) == sizeof(WGPUVertexState), \"sizeof mismatch for VertexState\");\n    static_assert(alignof(VertexState) == alignof(WGPUVertexState), \"alignof mismatch for VertexState\");\n\n    static_assert(offsetof(VertexState, nextInChain) == offsetof(WGPUVertexState, nextInChain),\n            \"offsetof mismatch for VertexState::nextInChain\");\n    static_assert(offsetof(VertexState, module) == offsetof(WGPUVertexState, module),\n            \"offsetof mismatch for VertexState::module\");\n    static_assert(offsetof(VertexState, entryPoint) == offsetof(WGPUVertexState, entryPoint),\n            \"offsetof mismatch for VertexState::entryPoint\");\n    static_assert(offsetof(VertexState, constantCount) == offsetof(WGPUVertexState, constantCount),\n            \"offsetof mismatch for VertexState::constantCount\");\n    static_assert(offsetof(VertexState, constants) == offsetof(WGPUVertexState, constants),\n            \"offsetof mismatch for VertexState::constants\");\n    static_assert(offsetof(VertexState, bufferCount) == offsetof(WGPUVertexState, bufferCount),\n            \"offsetof mismatch for VertexState::bufferCount\");\n    static_assert(offsetof(VertexState, buffers) == offsetof(WGPUVertexState, buffers),\n            \"offsetof mismatch for VertexState::buffers\");\n\n    // FragmentState\n\n    static_assert(sizeof(FragmentState) == sizeof(WGPUFragmentState), \"sizeof mismatch for FragmentState\");\n    static_assert(alignof(FragmentState) == alignof(WGPUFragmentState), \"alignof mismatch for FragmentState\");\n\n    static_assert(offsetof(FragmentState, nextInChain) == offsetof(WGPUFragmentState, nextInChain),\n            \"offsetof mismatch for FragmentState::nextInChain\");\n    static_assert(offsetof(FragmentState, module) == offsetof(WGPUFragmentState, module),\n            \"offsetof mismatch for FragmentState::module\");\n    static_assert(offsetof(FragmentState, entryPoint) == offsetof(WGPUFragmentState, entryPoint),\n            \"offsetof mismatch for FragmentState::entryPoint\");\n    static_assert(offsetof(FragmentState, constantCount) == offsetof(WGPUFragmentState, constantCount),\n            \"offsetof mismatch for FragmentState::constantCount\");\n    static_assert(offsetof(FragmentState, constants) == offsetof(WGPUFragmentState, constants),\n            \"offsetof mismatch for FragmentState::constants\");\n    static_assert(offsetof(FragmentState, targetCount) == offsetof(WGPUFragmentState, targetCount),\n            \"offsetof mismatch for FragmentState::targetCount\");\n    static_assert(offsetof(FragmentState, targets) == offsetof(WGPUFragmentState, targets),\n            \"offsetof mismatch for FragmentState::targets\");\n\n    // RenderPipelineDescriptor\n\n    static_assert(sizeof(RenderPipelineDescriptor) == sizeof(WGPURenderPipelineDescriptor), \"sizeof mismatch for RenderPipelineDescriptor\");\n    static_assert(alignof(RenderPipelineDescriptor) == alignof(WGPURenderPipelineDescriptor), \"alignof mismatch for RenderPipelineDescriptor\");\n\n    static_assert(offsetof(RenderPipelineDescriptor, nextInChain) == offsetof(WGPURenderPipelineDescriptor, nextInChain),\n            \"offsetof mismatch for RenderPipelineDescriptor::nextInChain\");\n    static_assert(offsetof(RenderPipelineDescriptor, label) == offsetof(WGPURenderPipelineDescriptor, label),\n            \"offsetof mismatch for RenderPipelineDescriptor::label\");\n    static_assert(offsetof(RenderPipelineDescriptor, layout) == offsetof(WGPURenderPipelineDescriptor, layout),\n            \"offsetof mismatch for RenderPipelineDescriptor::layout\");\n    static_assert(offsetof(RenderPipelineDescriptor, vertex) == offsetof(WGPURenderPipelineDescriptor, vertex),\n            \"offsetof mismatch for RenderPipelineDescriptor::vertex\");\n    static_assert(offsetof(RenderPipelineDescriptor, primitive) == offsetof(WGPURenderPipelineDescriptor, primitive),\n            \"offsetof mismatch for RenderPipelineDescriptor::primitive\");\n    static_assert(offsetof(RenderPipelineDescriptor, depthStencil) == offsetof(WGPURenderPipelineDescriptor, depthStencil),\n            \"offsetof mismatch for RenderPipelineDescriptor::depthStencil\");\n    static_assert(offsetof(RenderPipelineDescriptor, multisample) == offsetof(WGPURenderPipelineDescriptor, multisample),\n            \"offsetof mismatch for RenderPipelineDescriptor::multisample\");\n    static_assert(offsetof(RenderPipelineDescriptor, fragment) == offsetof(WGPURenderPipelineDescriptor, fragment),\n            \"offsetof mismatch for RenderPipelineDescriptor::fragment\");\n\n    // Adapter\n\n    static_assert(sizeof(Adapter) == sizeof(WGPUAdapter), \"sizeof mismatch for Adapter\");\n    static_assert(alignof(Adapter) == alignof(WGPUAdapter), \"alignof mismatch for Adapter\");\n\n    size_t Adapter::EnumerateFeatures(FeatureName * features) const {\n        auto result = wgpuAdapterEnumerateFeatures(Get(), reinterpret_cast<WGPUFeatureName * >(features));\n        return result;\n    }\n    bool Adapter::GetLimits(SupportedLimits * limits) const {\n        auto result = wgpuAdapterGetLimits(Get(), reinterpret_cast<WGPUSupportedLimits * >(limits));\n        return result;\n    }\n    void Adapter::GetProperties(AdapterProperties * properties) const {\n        wgpuAdapterGetProperties(Get(), reinterpret_cast<WGPUAdapterProperties * >(properties));\n    }\n    bool Adapter::HasFeature(FeatureName feature) const {\n        auto result = wgpuAdapterHasFeature(Get(), static_cast<WGPUFeatureName>(feature));\n        return result;\n    }\n    void Adapter::RequestDevice(DeviceDescriptor const * descriptor, RequestDeviceCallback callback, void * userdata) const {\n        wgpuAdapterRequestDevice(Get(), reinterpret_cast<WGPUDeviceDescriptor const * >(descriptor), callback, userdata);\n    }\n    void Adapter::WGPUReference(WGPUAdapter handle) {\n        if (handle != nullptr) {\n            wgpuAdapterReference(handle);\n        }\n    }\n    void Adapter::WGPURelease(WGPUAdapter handle) {\n        if (handle != nullptr) {\n            wgpuAdapterRelease(handle);\n        }\n    }\n\n    // BindGroup\n\n    static_assert(sizeof(BindGroup) == sizeof(WGPUBindGroup), \"sizeof mismatch for BindGroup\");\n    static_assert(alignof(BindGroup) == alignof(WGPUBindGroup), \"alignof mismatch for BindGroup\");\n\n    void BindGroup::SetLabel(char const * label) const {\n        wgpuBindGroupSetLabel(Get(), reinterpret_cast<char const * >(label));\n    }\n    void BindGroup::WGPUReference(WGPUBindGroup handle) {\n        if (handle != nullptr) {\n            wgpuBindGroupReference(handle);\n        }\n    }\n    void BindGroup::WGPURelease(WGPUBindGroup handle) {\n        if (handle != nullptr) {\n            wgpuBindGroupRelease(handle);\n        }\n    }\n\n    // BindGroupLayout\n\n    static_assert(sizeof(BindGroupLayout) == sizeof(WGPUBindGroupLayout), \"sizeof mismatch for BindGroupLayout\");\n    static_assert(alignof(BindGroupLayout) == alignof(WGPUBindGroupLayout), \"alignof mismatch for BindGroupLayout\");\n\n    void BindGroupLayout::SetLabel(char const * label) const {\n        wgpuBindGroupLayoutSetLabel(Get(), reinterpret_cast<char const * >(label));\n    }\n    void BindGroupLayout::WGPUReference(WGPUBindGroupLayout handle) {\n        if (handle != nullptr) {\n            wgpuBindGroupLayoutReference(handle);\n        }\n    }\n    void BindGroupLayout::WGPURelease(WGPUBindGroupLayout handle) {\n        if (handle != nullptr) {\n            wgpuBindGroupLayoutRelease(handle);\n        }\n    }\n\n    // Buffer\n\n    static_assert(sizeof(Buffer) == sizeof(WGPUBuffer), \"sizeof mismatch for Buffer\");\n    static_assert(alignof(Buffer) == alignof(WGPUBuffer), \"alignof mismatch for Buffer\");\n\n    void Buffer::Destroy() const {\n        wgpuBufferDestroy(Get());\n    }\n    void const * Buffer::GetConstMappedRange(size_t offset, size_t size) const {\n        auto result = wgpuBufferGetConstMappedRange(Get(), offset, size);\n        return result;\n    }\n    BufferMapState Buffer::GetMapState() const {\n        auto result = wgpuBufferGetMapState(Get());\n        return static_cast<BufferMapState>(result);\n    }\n    void * Buffer::GetMappedRange(size_t offset, size_t size) const {\n        auto result = wgpuBufferGetMappedRange(Get(), offset, size);\n        return result;\n    }\n    uint64_t Buffer::GetSize() const {\n        auto result = wgpuBufferGetSize(Get());\n        return result;\n    }\n    BufferUsage Buffer::GetUsage() const {\n        auto result = wgpuBufferGetUsage(Get());\n        return static_cast<BufferUsage>(result);\n    }\n    void Buffer::MapAsync(MapMode mode, size_t offset, size_t size, BufferMapCallback callback, void * userdata) const {\n        wgpuBufferMapAsync(Get(), static_cast<WGPUMapMode>(mode), offset, size, callback, userdata);\n    }\n    void Buffer::SetLabel(char const * label) const {\n        wgpuBufferSetLabel(Get(), reinterpret_cast<char const * >(label));\n    }\n    void Buffer::Unmap() const {\n        wgpuBufferUnmap(Get());\n    }\n    void Buffer::WGPUReference(WGPUBuffer handle) {\n        if (handle != nullptr) {\n            wgpuBufferReference(handle);\n        }\n    }\n    void Buffer::WGPURelease(WGPUBuffer handle) {\n        if (handle != nullptr) {\n            wgpuBufferRelease(handle);\n        }\n    }\n\n    // CommandBuffer\n\n    static_assert(sizeof(CommandBuffer) == sizeof(WGPUCommandBuffer), \"sizeof mismatch for CommandBuffer\");\n    static_assert(alignof(CommandBuffer) == alignof(WGPUCommandBuffer), \"alignof mismatch for CommandBuffer\");\n\n    void CommandBuffer::SetLabel(char const * label) const {\n        wgpuCommandBufferSetLabel(Get(), reinterpret_cast<char const * >(label));\n    }\n    void CommandBuffer::WGPUReference(WGPUCommandBuffer handle) {\n        if (handle != nullptr) {\n            wgpuCommandBufferReference(handle);\n        }\n    }\n    void CommandBuffer::WGPURelease(WGPUCommandBuffer handle) {\n        if (handle != nullptr) {\n            wgpuCommandBufferRelease(handle);\n        }\n    }\n\n    // CommandEncoder\n\n    static_assert(sizeof(CommandEncoder) == sizeof(WGPUCommandEncoder), \"sizeof mismatch for CommandEncoder\");\n    static_assert(alignof(CommandEncoder) == alignof(WGPUCommandEncoder), \"alignof mismatch for CommandEncoder\");\n\n    ComputePassEncoder CommandEncoder::BeginComputePass(ComputePassDescriptor const * descriptor) const {\n        auto result = wgpuCommandEncoderBeginComputePass(Get(), reinterpret_cast<WGPUComputePassDescriptor const * >(descriptor));\n        return ComputePassEncoder::Acquire(result);\n    }\n    RenderPassEncoder CommandEncoder::BeginRenderPass(RenderPassDescriptor const * descriptor) const {\n        auto result = wgpuCommandEncoderBeginRenderPass(Get(), reinterpret_cast<WGPURenderPassDescriptor const * >(descriptor));\n        return RenderPassEncoder::Acquire(result);\n    }\n    void CommandEncoder::ClearBuffer(Buffer const& buffer, uint64_t offset, uint64_t size) const {\n        wgpuCommandEncoderClearBuffer(Get(), buffer.Get(), offset, size);\n    }\n    void CommandEncoder::CopyBufferToBuffer(Buffer const& source, uint64_t sourceOffset, Buffer const& destination, uint64_t destinationOffset, uint64_t size) const {\n        wgpuCommandEncoderCopyBufferToBuffer(Get(), source.Get(), sourceOffset, destination.Get(), destinationOffset, size);\n    }\n    void CommandEncoder::CopyBufferToTexture(ImageCopyBuffer const * source, ImageCopyTexture const * destination, Extent3D const * copySize) const {\n        wgpuCommandEncoderCopyBufferToTexture(Get(), reinterpret_cast<WGPUImageCopyBuffer const * >(source), reinterpret_cast<WGPUImageCopyTexture const * >(destination), reinterpret_cast<WGPUExtent3D const * >(copySize));\n    }\n    void CommandEncoder::CopyTextureToBuffer(ImageCopyTexture const * source, ImageCopyBuffer const * destination, Extent3D const * copySize) const {\n        wgpuCommandEncoderCopyTextureToBuffer(Get(), reinterpret_cast<WGPUImageCopyTexture const * >(source), reinterpret_cast<WGPUImageCopyBuffer const * >(destination), reinterpret_cast<WGPUExtent3D const * >(copySize));\n    }\n    void CommandEncoder::CopyTextureToTexture(ImageCopyTexture const * source, ImageCopyTexture const * destination, Extent3D const * copySize) const {\n        wgpuCommandEncoderCopyTextureToTexture(Get(), reinterpret_cast<WGPUImageCopyTexture const * >(source), reinterpret_cast<WGPUImageCopyTexture const * >(destination), reinterpret_cast<WGPUExtent3D const * >(copySize));\n    }\n    CommandBuffer CommandEncoder::Finish(CommandBufferDescriptor const * descriptor) const {\n        auto result = wgpuCommandEncoderFinish(Get(), reinterpret_cast<WGPUCommandBufferDescriptor const * >(descriptor));\n        return CommandBuffer::Acquire(result);\n    }\n    void CommandEncoder::InsertDebugMarker(char const * markerLabel) const {\n        wgpuCommandEncoderInsertDebugMarker(Get(), reinterpret_cast<char const * >(markerLabel));\n    }\n    void CommandEncoder::PopDebugGroup() const {\n        wgpuCommandEncoderPopDebugGroup(Get());\n    }\n    void CommandEncoder::PushDebugGroup(char const * groupLabel) const {\n        wgpuCommandEncoderPushDebugGroup(Get(), reinterpret_cast<char const * >(groupLabel));\n    }\n    void CommandEncoder::ResolveQuerySet(QuerySet const& querySet, uint32_t firstQuery, uint32_t queryCount, Buffer const& destination, uint64_t destinationOffset) const {\n        wgpuCommandEncoderResolveQuerySet(Get(), querySet.Get(), firstQuery, queryCount, destination.Get(), destinationOffset);\n    }\n    void CommandEncoder::SetLabel(char const * label) const {\n        wgpuCommandEncoderSetLabel(Get(), reinterpret_cast<char const * >(label));\n    }\n    void CommandEncoder::WriteTimestamp(QuerySet const& querySet, uint32_t queryIndex) const {\n        wgpuCommandEncoderWriteTimestamp(Get(), querySet.Get(), queryIndex);\n    }\n    void CommandEncoder::WGPUReference(WGPUCommandEncoder handle) {\n        if (handle != nullptr) {\n            wgpuCommandEncoderReference(handle);\n        }\n    }\n    void CommandEncoder::WGPURelease(WGPUCommandEncoder handle) {\n        if (handle != nullptr) {\n            wgpuCommandEncoderRelease(handle);\n        }\n    }\n\n    // ComputePassEncoder\n\n    static_assert(sizeof(ComputePassEncoder) == sizeof(WGPUComputePassEncoder), \"sizeof mismatch for ComputePassEncoder\");\n    static_assert(alignof(ComputePassEncoder) == alignof(WGPUComputePassEncoder), \"alignof mismatch for ComputePassEncoder\");\n\n    void ComputePassEncoder::BeginPipelineStatisticsQuery(QuerySet const& querySet, uint32_t queryIndex) const {\n        wgpuComputePassEncoderBeginPipelineStatisticsQuery(Get(), querySet.Get(), queryIndex);\n    }\n    void ComputePassEncoder::DispatchWorkgroups(uint32_t workgroupCountX, uint32_t workgroupCountY, uint32_t workgroupCountZ) const {\n        wgpuComputePassEncoderDispatchWorkgroups(Get(), workgroupCountX, workgroupCountY, workgroupCountZ);\n    }\n    void ComputePassEncoder::DispatchWorkgroupsIndirect(Buffer const& indirectBuffer, uint64_t indirectOffset) const {\n        wgpuComputePassEncoderDispatchWorkgroupsIndirect(Get(), indirectBuffer.Get(), indirectOffset);\n    }\n    void ComputePassEncoder::End() const {\n        wgpuComputePassEncoderEnd(Get());\n    }\n    void ComputePassEncoder::EndPipelineStatisticsQuery() const {\n        wgpuComputePassEncoderEndPipelineStatisticsQuery(Get());\n    }\n    void ComputePassEncoder::InsertDebugMarker(char const * markerLabel) const {\n        wgpuComputePassEncoderInsertDebugMarker(Get(), reinterpret_cast<char const * >(markerLabel));\n    }\n    void ComputePassEncoder::PopDebugGroup() const {\n        wgpuComputePassEncoderPopDebugGroup(Get());\n    }\n    void ComputePassEncoder::PushDebugGroup(char const * groupLabel) const {\n        wgpuComputePassEncoderPushDebugGroup(Get(), reinterpret_cast<char const * >(groupLabel));\n    }\n    void ComputePassEncoder::SetBindGroup(uint32_t groupIndex, BindGroup const& group, size_t dynamicOffsetCount, uint32_t const * dynamicOffsets) const {\n        wgpuComputePassEncoderSetBindGroup(Get(), groupIndex, group.Get(), dynamicOffsetCount, reinterpret_cast<uint32_t const * >(dynamicOffsets));\n    }\n    void ComputePassEncoder::SetLabel(char const * label) const {\n        wgpuComputePassEncoderSetLabel(Get(), reinterpret_cast<char const * >(label));\n    }\n    void ComputePassEncoder::SetPipeline(ComputePipeline const& pipeline) const {\n        wgpuComputePassEncoderSetPipeline(Get(), pipeline.Get());\n    }\n    void ComputePassEncoder::WriteTimestamp(QuerySet const& querySet, uint32_t queryIndex) const {\n        wgpuComputePassEncoderWriteTimestamp(Get(), querySet.Get(), queryIndex);\n    }\n    void ComputePassEncoder::WGPUReference(WGPUComputePassEncoder handle) {\n        if (handle != nullptr) {\n            wgpuComputePassEncoderReference(handle);\n        }\n    }\n    void ComputePassEncoder::WGPURelease(WGPUComputePassEncoder handle) {\n        if (handle != nullptr) {\n            wgpuComputePassEncoderRelease(handle);\n        }\n    }\n\n    // ComputePipeline\n\n    static_assert(sizeof(ComputePipeline) == sizeof(WGPUComputePipeline), \"sizeof mismatch for ComputePipeline\");\n    static_assert(alignof(ComputePipeline) == alignof(WGPUComputePipeline), \"alignof mismatch for ComputePipeline\");\n\n    BindGroupLayout ComputePipeline::GetBindGroupLayout(uint32_t groupIndex) const {\n        auto result = wgpuComputePipelineGetBindGroupLayout(Get(), groupIndex);\n        return BindGroupLayout::Acquire(result);\n    }\n    void ComputePipeline::SetLabel(char const * label) const {\n        wgpuComputePipelineSetLabel(Get(), reinterpret_cast<char const * >(label));\n    }\n    void ComputePipeline::WGPUReference(WGPUComputePipeline handle) {\n        if (handle != nullptr) {\n            wgpuComputePipelineReference(handle);\n        }\n    }\n    void ComputePipeline::WGPURelease(WGPUComputePipeline handle) {\n        if (handle != nullptr) {\n            wgpuComputePipelineRelease(handle);\n        }\n    }\n\n    // Device\n\n    static_assert(sizeof(Device) == sizeof(WGPUDevice), \"sizeof mismatch for Device\");\n    static_assert(alignof(Device) == alignof(WGPUDevice), \"alignof mismatch for Device\");\n\n    BindGroup Device::CreateBindGroup(BindGroupDescriptor const * descriptor) const {\n        auto result = wgpuDeviceCreateBindGroup(Get(), reinterpret_cast<WGPUBindGroupDescriptor const * >(descriptor));\n        return BindGroup::Acquire(result);\n    }\n    BindGroupLayout Device::CreateBindGroupLayout(BindGroupLayoutDescriptor const * descriptor) const {\n        auto result = wgpuDeviceCreateBindGroupLayout(Get(), reinterpret_cast<WGPUBindGroupLayoutDescriptor const * >(descriptor));\n        return BindGroupLayout::Acquire(result);\n    }\n    Buffer Device::CreateBuffer(BufferDescriptor const * descriptor) const {\n        auto result = wgpuDeviceCreateBuffer(Get(), reinterpret_cast<WGPUBufferDescriptor const * >(descriptor));\n        return Buffer::Acquire(result);\n    }\n    CommandEncoder Device::CreateCommandEncoder(CommandEncoderDescriptor const * descriptor) const {\n        auto result = wgpuDeviceCreateCommandEncoder(Get(), reinterpret_cast<WGPUCommandEncoderDescriptor const * >(descriptor));\n        return CommandEncoder::Acquire(result);\n    }\n    ComputePipeline Device::CreateComputePipeline(ComputePipelineDescriptor const * descriptor) const {\n        auto result = wgpuDeviceCreateComputePipeline(Get(), reinterpret_cast<WGPUComputePipelineDescriptor const * >(descriptor));\n        return ComputePipeline::Acquire(result);\n    }\n    void Device::CreateComputePipelineAsync(ComputePipelineDescriptor const * descriptor, CreateComputePipelineAsyncCallback callback, void * userdata) const {\n        wgpuDeviceCreateComputePipelineAsync(Get(), reinterpret_cast<WGPUComputePipelineDescriptor const * >(descriptor), callback, userdata);\n    }\n    PipelineLayout Device::CreatePipelineLayout(PipelineLayoutDescriptor const * descriptor) const {\n        auto result = wgpuDeviceCreatePipelineLayout(Get(), reinterpret_cast<WGPUPipelineLayoutDescriptor const * >(descriptor));\n        return PipelineLayout::Acquire(result);\n    }\n    QuerySet Device::CreateQuerySet(QuerySetDescriptor const * descriptor) const {\n        auto result = wgpuDeviceCreateQuerySet(Get(), reinterpret_cast<WGPUQuerySetDescriptor const * >(descriptor));\n        return QuerySet::Acquire(result);\n    }\n    RenderBundleEncoder Device::CreateRenderBundleEncoder(RenderBundleEncoderDescriptor const * descriptor) const {\n        auto result = wgpuDeviceCreateRenderBundleEncoder(Get(), reinterpret_cast<WGPURenderBundleEncoderDescriptor const * >(descriptor));\n        return RenderBundleEncoder::Acquire(result);\n    }\n    RenderPipeline Device::CreateRenderPipeline(RenderPipelineDescriptor const * descriptor) const {\n        auto result = wgpuDeviceCreateRenderPipeline(Get(), reinterpret_cast<WGPURenderPipelineDescriptor const * >(descriptor));\n        return RenderPipeline::Acquire(result);\n    }\n    void Device::CreateRenderPipelineAsync(RenderPipelineDescriptor const * descriptor, CreateRenderPipelineAsyncCallback callback, void * userdata) const {\n        wgpuDeviceCreateRenderPipelineAsync(Get(), reinterpret_cast<WGPURenderPipelineDescriptor const * >(descriptor), callback, userdata);\n    }\n    Sampler Device::CreateSampler(SamplerDescriptor const * descriptor) const {\n        auto result = wgpuDeviceCreateSampler(Get(), reinterpret_cast<WGPUSamplerDescriptor const * >(descriptor));\n        return Sampler::Acquire(result);\n    }\n    ShaderModule Device::CreateShaderModule(ShaderModuleDescriptor const * descriptor) const {\n        auto result = wgpuDeviceCreateShaderModule(Get(), reinterpret_cast<WGPUShaderModuleDescriptor const * >(descriptor));\n        return ShaderModule::Acquire(result);\n    }\n    SwapChain Device::CreateSwapChain(Surface const& surface, SwapChainDescriptor const * descriptor) const {\n        auto result = wgpuDeviceCreateSwapChain(Get(), surface.Get(), reinterpret_cast<WGPUSwapChainDescriptor const * >(descriptor));\n        return SwapChain::Acquire(result);\n    }\n    Texture Device::CreateTexture(TextureDescriptor const * descriptor) const {\n        auto result = wgpuDeviceCreateTexture(Get(), reinterpret_cast<WGPUTextureDescriptor const * >(descriptor));\n        return Texture::Acquire(result);\n    }\n    void Device::Destroy() const {\n        wgpuDeviceDestroy(Get());\n    }\n    size_t Device::EnumerateFeatures(FeatureName * features) const {\n        auto result = wgpuDeviceEnumerateFeatures(Get(), reinterpret_cast<WGPUFeatureName * >(features));\n        return result;\n    }\n    bool Device::GetLimits(SupportedLimits * limits) const {\n        auto result = wgpuDeviceGetLimits(Get(), reinterpret_cast<WGPUSupportedLimits * >(limits));\n        return result;\n    }\n    Queue Device::GetQueue() const {\n        auto result = wgpuDeviceGetQueue(Get());\n        return Queue::Acquire(result);\n    }\n    bool Device::HasFeature(FeatureName feature) const {\n        auto result = wgpuDeviceHasFeature(Get(), static_cast<WGPUFeatureName>(feature));\n        return result;\n    }\n    void Device::PopErrorScope(ErrorCallback callback, void * userdata) const {\n        wgpuDevicePopErrorScope(Get(), callback, userdata);\n    }\n    void Device::PushErrorScope(ErrorFilter filter) const {\n        wgpuDevicePushErrorScope(Get(), static_cast<WGPUErrorFilter>(filter));\n    }\n    void Device::SetLabel(char const * label) const {\n        wgpuDeviceSetLabel(Get(), reinterpret_cast<char const * >(label));\n    }\n    void Device::SetUncapturedErrorCallback(ErrorCallback callback, void * userdata) const {\n        wgpuDeviceSetUncapturedErrorCallback(Get(), callback, userdata);\n    }\n    void Device::WGPUReference(WGPUDevice handle) {\n        if (handle != nullptr) {\n            wgpuDeviceReference(handle);\n        }\n    }\n    void Device::WGPURelease(WGPUDevice handle) {\n        if (handle != nullptr) {\n            wgpuDeviceRelease(handle);\n        }\n    }\n\n    // Instance\n\n    static_assert(sizeof(Instance) == sizeof(WGPUInstance), \"sizeof mismatch for Instance\");\n    static_assert(alignof(Instance) == alignof(WGPUInstance), \"alignof mismatch for Instance\");\n\n    Surface Instance::CreateSurface(SurfaceDescriptor const * descriptor) const {\n        auto result = wgpuInstanceCreateSurface(Get(), reinterpret_cast<WGPUSurfaceDescriptor const * >(descriptor));\n        return Surface::Acquire(result);\n    }\n    void Instance::ProcessEvents() const {\n        wgpuInstanceProcessEvents(Get());\n    }\n    void Instance::RequestAdapter(RequestAdapterOptions const * options, RequestAdapterCallback callback, void * userdata) const {\n        wgpuInstanceRequestAdapter(Get(), reinterpret_cast<WGPURequestAdapterOptions const * >(options), callback, userdata);\n    }\n    void Instance::WGPUReference(WGPUInstance handle) {\n        if (handle != nullptr) {\n            wgpuInstanceReference(handle);\n        }\n    }\n    void Instance::WGPURelease(WGPUInstance handle) {\n        if (handle != nullptr) {\n            wgpuInstanceRelease(handle);\n        }\n    }\n\n    // PipelineLayout\n\n    static_assert(sizeof(PipelineLayout) == sizeof(WGPUPipelineLayout), \"sizeof mismatch for PipelineLayout\");\n    static_assert(alignof(PipelineLayout) == alignof(WGPUPipelineLayout), \"alignof mismatch for PipelineLayout\");\n\n    void PipelineLayout::SetLabel(char const * label) const {\n        wgpuPipelineLayoutSetLabel(Get(), reinterpret_cast<char const * >(label));\n    }\n    void PipelineLayout::WGPUReference(WGPUPipelineLayout handle) {\n        if (handle != nullptr) {\n            wgpuPipelineLayoutReference(handle);\n        }\n    }\n    void PipelineLayout::WGPURelease(WGPUPipelineLayout handle) {\n        if (handle != nullptr) {\n            wgpuPipelineLayoutRelease(handle);\n        }\n    }\n\n    // QuerySet\n\n    static_assert(sizeof(QuerySet) == sizeof(WGPUQuerySet), \"sizeof mismatch for QuerySet\");\n    static_assert(alignof(QuerySet) == alignof(WGPUQuerySet), \"alignof mismatch for QuerySet\");\n\n    void QuerySet::Destroy() const {\n        wgpuQuerySetDestroy(Get());\n    }\n    uint32_t QuerySet::GetCount() const {\n        auto result = wgpuQuerySetGetCount(Get());\n        return result;\n    }\n    QueryType QuerySet::GetType() const {\n        auto result = wgpuQuerySetGetType(Get());\n        return static_cast<QueryType>(result);\n    }\n    void QuerySet::SetLabel(char const * label) const {\n        wgpuQuerySetSetLabel(Get(), reinterpret_cast<char const * >(label));\n    }\n    void QuerySet::WGPUReference(WGPUQuerySet handle) {\n        if (handle != nullptr) {\n            wgpuQuerySetReference(handle);\n        }\n    }\n    void QuerySet::WGPURelease(WGPUQuerySet handle) {\n        if (handle != nullptr) {\n            wgpuQuerySetRelease(handle);\n        }\n    }\n\n    // Queue\n\n    static_assert(sizeof(Queue) == sizeof(WGPUQueue), \"sizeof mismatch for Queue\");\n    static_assert(alignof(Queue) == alignof(WGPUQueue), \"alignof mismatch for Queue\");\n\n    void Queue::OnSubmittedWorkDone(uint64_t signalValue, QueueWorkDoneCallback callback, void * userdata) const {\n        wgpuQueueOnSubmittedWorkDone(Get(), signalValue, callback, userdata);\n    }\n    void Queue::SetLabel(char const * label) const {\n        wgpuQueueSetLabel(Get(), reinterpret_cast<char const * >(label));\n    }\n    void Queue::Submit(size_t commandCount, CommandBuffer const * commands) const {\n        wgpuQueueSubmit(Get(), commandCount, reinterpret_cast<WGPUCommandBuffer const * >(commands));\n    }\n    void Queue::WriteBuffer(Buffer const& buffer, uint64_t bufferOffset, void const * data, size_t size) const {\n        wgpuQueueWriteBuffer(Get(), buffer.Get(), bufferOffset, reinterpret_cast<void const * >(data), size);\n    }\n    void Queue::WriteTexture(ImageCopyTexture const * destination, void const * data, size_t dataSize, TextureDataLayout const * dataLayout, Extent3D const * writeSize) const {\n        wgpuQueueWriteTexture(Get(), reinterpret_cast<WGPUImageCopyTexture const * >(destination), reinterpret_cast<void const * >(data), dataSize, reinterpret_cast<WGPUTextureDataLayout const * >(dataLayout), reinterpret_cast<WGPUExtent3D const * >(writeSize));\n    }\n    void Queue::WGPUReference(WGPUQueue handle) {\n        if (handle != nullptr) {\n            wgpuQueueReference(handle);\n        }\n    }\n    void Queue::WGPURelease(WGPUQueue handle) {\n        if (handle != nullptr) {\n            wgpuQueueRelease(handle);\n        }\n    }\n\n    // RenderBundle\n\n    static_assert(sizeof(RenderBundle) == sizeof(WGPURenderBundle), \"sizeof mismatch for RenderBundle\");\n    static_assert(alignof(RenderBundle) == alignof(WGPURenderBundle), \"alignof mismatch for RenderBundle\");\n\n    void RenderBundle::SetLabel(char const * label) const {\n        wgpuRenderBundleSetLabel(Get(), reinterpret_cast<char const * >(label));\n    }\n    void RenderBundle::WGPUReference(WGPURenderBundle handle) {\n        if (handle != nullptr) {\n            wgpuRenderBundleReference(handle);\n        }\n    }\n    void RenderBundle::WGPURelease(WGPURenderBundle handle) {\n        if (handle != nullptr) {\n            wgpuRenderBundleRelease(handle);\n        }\n    }\n\n    // RenderBundleEncoder\n\n    static_assert(sizeof(RenderBundleEncoder) == sizeof(WGPURenderBundleEncoder), \"sizeof mismatch for RenderBundleEncoder\");\n    static_assert(alignof(RenderBundleEncoder) == alignof(WGPURenderBundleEncoder), \"alignof mismatch for RenderBundleEncoder\");\n\n    void RenderBundleEncoder::Draw(uint32_t vertexCount, uint32_t instanceCount, uint32_t firstVertex, uint32_t firstInstance) const {\n        wgpuRenderBundleEncoderDraw(Get(), vertexCount, instanceCount, firstVertex, firstInstance);\n    }\n    void RenderBundleEncoder::DrawIndexed(uint32_t indexCount, uint32_t instanceCount, uint32_t firstIndex, int32_t baseVertex, uint32_t firstInstance) const {\n        wgpuRenderBundleEncoderDrawIndexed(Get(), indexCount, instanceCount, firstIndex, baseVertex, firstInstance);\n    }\n    void RenderBundleEncoder::DrawIndexedIndirect(Buffer const& indirectBuffer, uint64_t indirectOffset) const {\n        wgpuRenderBundleEncoderDrawIndexedIndirect(Get(), indirectBuffer.Get(), indirectOffset);\n    }\n    void RenderBundleEncoder::DrawIndirect(Buffer const& indirectBuffer, uint64_t indirectOffset) const {\n        wgpuRenderBundleEncoderDrawIndirect(Get(), indirectBuffer.Get(), indirectOffset);\n    }\n    RenderBundle RenderBundleEncoder::Finish(RenderBundleDescriptor const * descriptor) const {\n        auto result = wgpuRenderBundleEncoderFinish(Get(), reinterpret_cast<WGPURenderBundleDescriptor const * >(descriptor));\n        return RenderBundle::Acquire(result);\n    }\n    void RenderBundleEncoder::InsertDebugMarker(char const * markerLabel) const {\n        wgpuRenderBundleEncoderInsertDebugMarker(Get(), reinterpret_cast<char const * >(markerLabel));\n    }\n    void RenderBundleEncoder::PopDebugGroup() const {\n        wgpuRenderBundleEncoderPopDebugGroup(Get());\n    }\n    void RenderBundleEncoder::PushDebugGroup(char const * groupLabel) const {\n        wgpuRenderBundleEncoderPushDebugGroup(Get(), reinterpret_cast<char const * >(groupLabel));\n    }\n    void RenderBundleEncoder::SetBindGroup(uint32_t groupIndex, BindGroup const& group, size_t dynamicOffsetCount, uint32_t const * dynamicOffsets) const {\n        wgpuRenderBundleEncoderSetBindGroup(Get(), groupIndex, group.Get(), dynamicOffsetCount, reinterpret_cast<uint32_t const * >(dynamicOffsets));\n    }\n    void RenderBundleEncoder::SetIndexBuffer(Buffer const& buffer, IndexFormat format, uint64_t offset, uint64_t size) const {\n        wgpuRenderBundleEncoderSetIndexBuffer(Get(), buffer.Get(), static_cast<WGPUIndexFormat>(format), offset, size);\n    }\n    void RenderBundleEncoder::SetLabel(char const * label) const {\n        wgpuRenderBundleEncoderSetLabel(Get(), reinterpret_cast<char const * >(label));\n    }\n    void RenderBundleEncoder::SetPipeline(RenderPipeline const& pipeline) const {\n        wgpuRenderBundleEncoderSetPipeline(Get(), pipeline.Get());\n    }\n    void RenderBundleEncoder::SetVertexBuffer(uint32_t slot, Buffer const& buffer, uint64_t offset, uint64_t size) const {\n        wgpuRenderBundleEncoderSetVertexBuffer(Get(), slot, buffer.Get(), offset, size);\n    }\n    void RenderBundleEncoder::WGPUReference(WGPURenderBundleEncoder handle) {\n        if (handle != nullptr) {\n            wgpuRenderBundleEncoderReference(handle);\n        }\n    }\n    void RenderBundleEncoder::WGPURelease(WGPURenderBundleEncoder handle) {\n        if (handle != nullptr) {\n            wgpuRenderBundleEncoderRelease(handle);\n        }\n    }\n\n    // RenderPassEncoder\n\n    static_assert(sizeof(RenderPassEncoder) == sizeof(WGPURenderPassEncoder), \"sizeof mismatch for RenderPassEncoder\");\n    static_assert(alignof(RenderPassEncoder) == alignof(WGPURenderPassEncoder), \"alignof mismatch for RenderPassEncoder\");\n\n    void RenderPassEncoder::BeginOcclusionQuery(uint32_t queryIndex) const {\n        wgpuRenderPassEncoderBeginOcclusionQuery(Get(), queryIndex);\n    }\n    void RenderPassEncoder::BeginPipelineStatisticsQuery(QuerySet const& querySet, uint32_t queryIndex) const {\n        wgpuRenderPassEncoderBeginPipelineStatisticsQuery(Get(), querySet.Get(), queryIndex);\n    }\n    void RenderPassEncoder::Draw(uint32_t vertexCount, uint32_t instanceCount, uint32_t firstVertex, uint32_t firstInstance) const {\n        wgpuRenderPassEncoderDraw(Get(), vertexCount, instanceCount, firstVertex, firstInstance);\n    }\n    void RenderPassEncoder::DrawIndexed(uint32_t indexCount, uint32_t instanceCount, uint32_t firstIndex, int32_t baseVertex, uint32_t firstInstance) const {\n        wgpuRenderPassEncoderDrawIndexed(Get(), indexCount, instanceCount, firstIndex, baseVertex, firstInstance);\n    }\n    void RenderPassEncoder::DrawIndexedIndirect(Buffer const& indirectBuffer, uint64_t indirectOffset) const {\n        wgpuRenderPassEncoderDrawIndexedIndirect(Get(), indirectBuffer.Get(), indirectOffset);\n    }\n    void RenderPassEncoder::DrawIndirect(Buffer const& indirectBuffer, uint64_t indirectOffset) const {\n        wgpuRenderPassEncoderDrawIndirect(Get(), indirectBuffer.Get(), indirectOffset);\n    }\n    void RenderPassEncoder::End() const {\n        wgpuRenderPassEncoderEnd(Get());\n    }\n    void RenderPassEncoder::EndOcclusionQuery() const {\n        wgpuRenderPassEncoderEndOcclusionQuery(Get());\n    }\n    void RenderPassEncoder::EndPipelineStatisticsQuery() const {\n        wgpuRenderPassEncoderEndPipelineStatisticsQuery(Get());\n    }\n    void RenderPassEncoder::ExecuteBundles(size_t bundleCount, RenderBundle const * bundles) const {\n        wgpuRenderPassEncoderExecuteBundles(Get(), bundleCount, reinterpret_cast<WGPURenderBundle const * >(bundles));\n    }\n    void RenderPassEncoder::InsertDebugMarker(char const * markerLabel) const {\n        wgpuRenderPassEncoderInsertDebugMarker(Get(), reinterpret_cast<char const * >(markerLabel));\n    }\n    void RenderPassEncoder::PopDebugGroup() const {\n        wgpuRenderPassEncoderPopDebugGroup(Get());\n    }\n    void RenderPassEncoder::PushDebugGroup(char const * groupLabel) const {\n        wgpuRenderPassEncoderPushDebugGroup(Get(), reinterpret_cast<char const * >(groupLabel));\n    }\n    void RenderPassEncoder::SetBindGroup(uint32_t groupIndex, BindGroup const& group, size_t dynamicOffsetCount, uint32_t const * dynamicOffsets) const {\n        wgpuRenderPassEncoderSetBindGroup(Get(), groupIndex, group.Get(), dynamicOffsetCount, reinterpret_cast<uint32_t const * >(dynamicOffsets));\n    }\n    void RenderPassEncoder::SetBlendConstant(Color const * color) const {\n        wgpuRenderPassEncoderSetBlendConstant(Get(), reinterpret_cast<WGPUColor const * >(color));\n    }\n    void RenderPassEncoder::SetIndexBuffer(Buffer const& buffer, IndexFormat format, uint64_t offset, uint64_t size) const {\n        wgpuRenderPassEncoderSetIndexBuffer(Get(), buffer.Get(), static_cast<WGPUIndexFormat>(format), offset, size);\n    }\n    void RenderPassEncoder::SetLabel(char const * label) const {\n        wgpuRenderPassEncoderSetLabel(Get(), reinterpret_cast<char const * >(label));\n    }\n    void RenderPassEncoder::SetPipeline(RenderPipeline const& pipeline) const {\n        wgpuRenderPassEncoderSetPipeline(Get(), pipeline.Get());\n    }\n    void RenderPassEncoder::SetScissorRect(uint32_t x, uint32_t y, uint32_t width, uint32_t height) const {\n        wgpuRenderPassEncoderSetScissorRect(Get(), x, y, width, height);\n    }\n    void RenderPassEncoder::SetStencilReference(uint32_t reference) const {\n        wgpuRenderPassEncoderSetStencilReference(Get(), reference);\n    }\n    void RenderPassEncoder::SetVertexBuffer(uint32_t slot, Buffer const& buffer, uint64_t offset, uint64_t size) const {\n        wgpuRenderPassEncoderSetVertexBuffer(Get(), slot, buffer.Get(), offset, size);\n    }\n    void RenderPassEncoder::SetViewport(float x, float y, float width, float height, float minDepth, float maxDepth) const {\n        wgpuRenderPassEncoderSetViewport(Get(), x, y, width, height, minDepth, maxDepth);\n    }\n    void RenderPassEncoder::WriteTimestamp(QuerySet const& querySet, uint32_t queryIndex) const {\n        wgpuRenderPassEncoderWriteTimestamp(Get(), querySet.Get(), queryIndex);\n    }\n    void RenderPassEncoder::WGPUReference(WGPURenderPassEncoder handle) {\n        if (handle != nullptr) {\n            wgpuRenderPassEncoderReference(handle);\n        }\n    }\n    void RenderPassEncoder::WGPURelease(WGPURenderPassEncoder handle) {\n        if (handle != nullptr) {\n            wgpuRenderPassEncoderRelease(handle);\n        }\n    }\n\n    // RenderPipeline\n\n    static_assert(sizeof(RenderPipeline) == sizeof(WGPURenderPipeline), \"sizeof mismatch for RenderPipeline\");\n    static_assert(alignof(RenderPipeline) == alignof(WGPURenderPipeline), \"alignof mismatch for RenderPipeline\");\n\n    BindGroupLayout RenderPipeline::GetBindGroupLayout(uint32_t groupIndex) const {\n        auto result = wgpuRenderPipelineGetBindGroupLayout(Get(), groupIndex);\n        return BindGroupLayout::Acquire(result);\n    }\n    void RenderPipeline::SetLabel(char const * label) const {\n        wgpuRenderPipelineSetLabel(Get(), reinterpret_cast<char const * >(label));\n    }\n    void RenderPipeline::WGPUReference(WGPURenderPipeline handle) {\n        if (handle != nullptr) {\n            wgpuRenderPipelineReference(handle);\n        }\n    }\n    void RenderPipeline::WGPURelease(WGPURenderPipeline handle) {\n        if (handle != nullptr) {\n            wgpuRenderPipelineRelease(handle);\n        }\n    }\n\n    // Sampler\n\n    static_assert(sizeof(Sampler) == sizeof(WGPUSampler), \"sizeof mismatch for Sampler\");\n    static_assert(alignof(Sampler) == alignof(WGPUSampler), \"alignof mismatch for Sampler\");\n\n    void Sampler::SetLabel(char const * label) const {\n        wgpuSamplerSetLabel(Get(), reinterpret_cast<char const * >(label));\n    }\n    void Sampler::WGPUReference(WGPUSampler handle) {\n        if (handle != nullptr) {\n            wgpuSamplerReference(handle);\n        }\n    }\n    void Sampler::WGPURelease(WGPUSampler handle) {\n        if (handle != nullptr) {\n            wgpuSamplerRelease(handle);\n        }\n    }\n\n    // ShaderModule\n\n    static_assert(sizeof(ShaderModule) == sizeof(WGPUShaderModule), \"sizeof mismatch for ShaderModule\");\n    static_assert(alignof(ShaderModule) == alignof(WGPUShaderModule), \"alignof mismatch for ShaderModule\");\n\n    void ShaderModule::GetCompilationInfo(CompilationInfoCallback callback, void * userdata) const {\n        wgpuShaderModuleGetCompilationInfo(Get(), callback, userdata);\n    }\n    void ShaderModule::SetLabel(char const * label) const {\n        wgpuShaderModuleSetLabel(Get(), reinterpret_cast<char const * >(label));\n    }\n    void ShaderModule::WGPUReference(WGPUShaderModule handle) {\n        if (handle != nullptr) {\n            wgpuShaderModuleReference(handle);\n        }\n    }\n    void ShaderModule::WGPURelease(WGPUShaderModule handle) {\n        if (handle != nullptr) {\n            wgpuShaderModuleRelease(handle);\n        }\n    }\n\n    // Surface\n\n    static_assert(sizeof(Surface) == sizeof(WGPUSurface), \"sizeof mismatch for Surface\");\n    static_assert(alignof(Surface) == alignof(WGPUSurface), \"alignof mismatch for Surface\");\n\n    TextureFormat Surface::GetPreferredFormat(Adapter const& adapter) const {\n        auto result = wgpuSurfaceGetPreferredFormat(Get(), adapter.Get());\n        return static_cast<TextureFormat>(result);\n    }\n    void Surface::WGPUReference(WGPUSurface handle) {\n        if (handle != nullptr) {\n            wgpuSurfaceReference(handle);\n        }\n    }\n    void Surface::WGPURelease(WGPUSurface handle) {\n        if (handle != nullptr) {\n            wgpuSurfaceRelease(handle);\n        }\n    }\n\n    // SwapChain\n\n    static_assert(sizeof(SwapChain) == sizeof(WGPUSwapChain), \"sizeof mismatch for SwapChain\");\n    static_assert(alignof(SwapChain) == alignof(WGPUSwapChain), \"alignof mismatch for SwapChain\");\n\n    TextureView SwapChain::GetCurrentTextureView() const {\n        auto result = wgpuSwapChainGetCurrentTextureView(Get());\n        return TextureView::Acquire(result);\n    }\n    void SwapChain::Present() const {\n        wgpuSwapChainPresent(Get());\n    }\n    void SwapChain::WGPUReference(WGPUSwapChain handle) {\n        if (handle != nullptr) {\n            wgpuSwapChainReference(handle);\n        }\n    }\n    void SwapChain::WGPURelease(WGPUSwapChain handle) {\n        if (handle != nullptr) {\n            wgpuSwapChainRelease(handle);\n        }\n    }\n\n    // Texture\n\n    static_assert(sizeof(Texture) == sizeof(WGPUTexture), \"sizeof mismatch for Texture\");\n    static_assert(alignof(Texture) == alignof(WGPUTexture), \"alignof mismatch for Texture\");\n\n    TextureView Texture::CreateView(TextureViewDescriptor const * descriptor) const {\n        auto result = wgpuTextureCreateView(Get(), reinterpret_cast<WGPUTextureViewDescriptor const * >(descriptor));\n        return TextureView::Acquire(result);\n    }\n    void Texture::Destroy() const {\n        wgpuTextureDestroy(Get());\n    }\n    uint32_t Texture::GetDepthOrArrayLayers() const {\n        auto result = wgpuTextureGetDepthOrArrayLayers(Get());\n        return result;\n    }\n    TextureDimension Texture::GetDimension() const {\n        auto result = wgpuTextureGetDimension(Get());\n        return static_cast<TextureDimension>(result);\n    }\n    TextureFormat Texture::GetFormat() const {\n        auto result = wgpuTextureGetFormat(Get());\n        return static_cast<TextureFormat>(result);\n    }\n    uint32_t Texture::GetHeight() const {\n        auto result = wgpuTextureGetHeight(Get());\n        return result;\n    }\n    uint32_t Texture::GetMipLevelCount() const {\n        auto result = wgpuTextureGetMipLevelCount(Get());\n        return result;\n    }\n    uint32_t Texture::GetSampleCount() const {\n        auto result = wgpuTextureGetSampleCount(Get());\n        return result;\n    }\n    TextureUsage Texture::GetUsage() const {\n        auto result = wgpuTextureGetUsage(Get());\n        return static_cast<TextureUsage>(result);\n    }\n    uint32_t Texture::GetWidth() const {\n        auto result = wgpuTextureGetWidth(Get());\n        return result;\n    }\n    void Texture::SetLabel(char const * label) const {\n        wgpuTextureSetLabel(Get(), reinterpret_cast<char const * >(label));\n    }\n    void Texture::WGPUReference(WGPUTexture handle) {\n        if (handle != nullptr) {\n            wgpuTextureReference(handle);\n        }\n    }\n    void Texture::WGPURelease(WGPUTexture handle) {\n        if (handle != nullptr) {\n            wgpuTextureRelease(handle);\n        }\n    }\n\n    // TextureView\n\n    static_assert(sizeof(TextureView) == sizeof(WGPUTextureView), \"sizeof mismatch for TextureView\");\n    static_assert(alignof(TextureView) == alignof(WGPUTextureView), \"alignof mismatch for TextureView\");\n\n    void TextureView::SetLabel(char const * label) const {\n        wgpuTextureViewSetLabel(Get(), reinterpret_cast<char const * >(label));\n    }\n    void TextureView::WGPUReference(WGPUTextureView handle) {\n        if (handle != nullptr) {\n            wgpuTextureViewReference(handle);\n        }\n    }\n    void TextureView::WGPURelease(WGPUTextureView handle) {\n        if (handle != nullptr) {\n            wgpuTextureViewRelease(handle);\n        }\n    }\n\n    // Function\n\n    Instance CreateInstance(InstanceDescriptor const * descriptor) {\n        auto result = wgpuCreateInstance(reinterpret_cast<WGPUInstanceDescriptor const * >(descriptor));\n        return Instance::Acquire(result);\n    }\n    Proc GetProcAddress(Device device, char const * procName) {\n        auto result = wgpuGetProcAddress(device.Get(), reinterpret_cast<char const * >(procName));\n        return reinterpret_cast<Proc>(result);\n    }\n\n}\n", "emscripten-bits/webgpu_struct_info.json": "    {\n        \"file\": \"{api}/{api}.h\",\n        \"defines\": [],\n        \"structs\": {\n            \"WGPUChainedStruct\": [\n                \"next\",\n                \"sType\"\n            ],\n            \"WGPUAdapterProperties\": [\n                \"nextInChain\",\n                \"vendorID\",\n                \"vendorName\",\n                \"architecture\",\n                \"deviceID\",\n                \"name\",\n                \"driverDescription\",\n                \"adapterType\",\n                \"backendType\",\n                \"compatibilityMode\"\n            ],\n            \"WGPUBindGroupEntry\": [\n                \"nextInChain\",\n                \"binding\",\n                \"buffer\",\n                \"offset\",\n                \"size\",\n                \"sampler\",\n                \"textureView\"\n            ],\n            \"WGPUBlendComponent\": [\n                \"operation\",\n                \"srcFactor\",\n                \"dstFactor\"\n            ],\n            \"WGPUBufferBindingLayout\": [\n                \"nextInChain\",\n                \"type\",\n                \"hasDynamicOffset\",\n                \"minBindingSize\"\n            ],\n            \"WGPUBufferDescriptor\": [\n                \"nextInChain\",\n                \"label\",\n                \"usage\",\n                \"size\",\n                \"mappedAtCreation\"\n            ],\n            \"WGPUColor\": [\n                \"r\",\n                \"g\",\n                \"b\",\n                \"a\"\n            ],\n            \"WGPUCommandBufferDescriptor\": [\n                \"nextInChain\",\n                \"label\"\n            ],\n            \"WGPUCommandEncoderDescriptor\": [\n                \"nextInChain\",\n                \"label\"\n            ],\n            \"WGPUCompilationMessage\": [\n                \"nextInChain\",\n                \"message\",\n                \"type\",\n                \"lineNum\",\n                \"linePos\",\n                \"offset\",\n                \"length\",\n                \"utf16LinePos\",\n                \"utf16Offset\",\n                \"utf16Length\"\n            ],\n            \"WGPUComputePassTimestampWrite\": [\n                \"querySet\",\n                \"queryIndex\",\n                \"location\"\n            ],\n            \"WGPUConstantEntry\": [\n                \"nextInChain\",\n                \"key\",\n                \"value\"\n            ],\n            \"WGPUExtent3D\": [\n                \"width\",\n                \"height\",\n                \"depthOrArrayLayers\"\n            ],\n            \"WGPUInstanceDescriptor\": [\n                \"nextInChain\"\n            ],\n            \"WGPULimits\": [\n                \"maxTextureDimension1D\",\n                \"maxTextureDimension2D\",\n                \"maxTextureDimension3D\",\n                \"maxTextureArrayLayers\",\n                \"maxBindGroups\",\n                \"maxBindGroupsPlusVertexBuffers\",\n                \"maxBindingsPerBindGroup\",\n                \"maxDynamicUniformBuffersPerPipelineLayout\",\n                \"maxDynamicStorageBuffersPerPipelineLayout\",\n                \"maxSampledTexturesPerShaderStage\",\n                \"maxSamplersPerShaderStage\",\n                \"maxStorageBuffersPerShaderStage\",\n                \"maxStorageTexturesPerShaderStage\",\n                \"maxUniformBuffersPerShaderStage\",\n                \"maxUniformBufferBindingSize\",\n                \"maxStorageBufferBindingSize\",\n                \"minUniformBufferOffsetAlignment\",\n                \"minStorageBufferOffsetAlignment\",\n                \"maxVertexBuffers\",\n                \"maxBufferSize\",\n                \"maxVertexAttributes\",\n                \"maxVertexBufferArrayStride\",\n                \"maxInterStageShaderComponents\",\n                \"maxInterStageShaderVariables\",\n                \"maxColorAttachments\",\n                \"maxColorAttachmentBytesPerSample\",\n                \"maxComputeWorkgroupStorageSize\",\n                \"maxComputeInvocationsPerWorkgroup\",\n                \"maxComputeWorkgroupSizeX\",\n                \"maxComputeWorkgroupSizeY\",\n                \"maxComputeWorkgroupSizeZ\",\n                \"maxComputeWorkgroupsPerDimension\"\n            ],\n            \"WGPUMultisampleState\": [\n                \"nextInChain\",\n                \"count\",\n                \"mask\",\n                \"alphaToCoverageEnabled\"\n            ],\n            \"WGPUOrigin3D\": [\n                \"x\",\n                \"y\",\n                \"z\"\n            ],\n            \"WGPUPipelineLayoutDescriptor\": [\n                \"nextInChain\",\n                \"label\",\n                \"bindGroupLayoutCount\",\n                \"bindGroupLayouts\"\n            ],\n            \"WGPUPrimitiveDepthClipControl\": [\n                \"chain\",\n                \"unclippedDepth\"\n            ],\n            \"WGPUPrimitiveState\": [\n                \"nextInChain\",\n                \"topology\",\n                \"stripIndexFormat\",\n                \"frontFace\",\n                \"cullMode\"\n            ],\n            \"WGPUQuerySetDescriptor\": [\n                \"nextInChain\",\n                \"label\",\n                \"type\",\n                \"count\",\n                \"pipelineStatistics\",\n                \"pipelineStatisticsCount\"\n            ],\n            \"WGPUQueueDescriptor\": [\n                \"nextInChain\",\n                \"label\"\n            ],\n            \"WGPURenderBundleDescriptor\": [\n                \"nextInChain\",\n                \"label\"\n            ],\n            \"WGPURenderBundleEncoderDescriptor\": [\n                \"nextInChain\",\n                \"label\",\n                \"colorFormatsCount\",\n                \"colorFormats\",\n                \"depthStencilFormat\",\n                \"sampleCount\",\n                \"depthReadOnly\",\n                \"stencilReadOnly\"\n            ],\n            \"WGPURenderPassDepthStencilAttachment\": [\n                \"view\",\n                \"depthLoadOp\",\n                \"depthStoreOp\",\n                \"depthClearValue\",\n                \"depthReadOnly\",\n                \"stencilLoadOp\",\n                \"stencilStoreOp\",\n                \"stencilClearValue\",\n                \"stencilReadOnly\"\n            ],\n            \"WGPURenderPassDescriptorMaxDrawCount\": [\n                \"chain\",\n                \"maxDrawCount\"\n            ],\n            \"WGPURenderPassTimestampWrite\": [\n                \"querySet\",\n                \"queryIndex\",\n                \"location\"\n            ],\n            \"WGPURequestAdapterOptions\": [\n                \"nextInChain\",\n                \"compatibleSurface\",\n                \"powerPreference\",\n                \"backendType\",\n                \"forceFallbackAdapter\",\n                \"compatibilityMode\"\n            ],\n            \"WGPUSamplerBindingLayout\": [\n                \"nextInChain\",\n                \"type\"\n            ],\n            \"WGPUSamplerDescriptor\": [\n                \"nextInChain\",\n                \"label\",\n                \"addressModeU\",\n                \"addressModeV\",\n                \"addressModeW\",\n                \"magFilter\",\n                \"minFilter\",\n                \"mipmapFilter\",\n                \"lodMinClamp\",\n                \"lodMaxClamp\",\n                \"compare\",\n                \"maxAnisotropy\"\n            ],\n            \"WGPUShaderModuleDescriptor\": [\n                \"nextInChain\",\n                \"label\"\n            ],\n            \"WGPUShaderModuleSPIRVDescriptor\": [\n                \"chain\",\n                \"codeSize\",\n                \"code\"\n            ],\n            \"WGPUShaderModuleWGSLDescriptor\": [\n                \"chain\",\n                \"code\"\n            ],\n            \"WGPUStencilFaceState\": [\n                \"compare\",\n                \"failOp\",\n                \"depthFailOp\",\n                \"passOp\"\n            ],\n            \"WGPUStorageTextureBindingLayout\": [\n                \"nextInChain\",\n                \"access\",\n                \"format\",\n                \"viewDimension\"\n            ],\n            \"WGPUSurfaceDescriptor\": [\n                \"nextInChain\",\n                \"label\"\n            ],\n            \"WGPUSurfaceDescriptorFromCanvasHTMLSelector\": [\n                \"chain\",\n                \"selector\"\n            ],\n            \"WGPUSwapChainDescriptor\": [\n                \"nextInChain\",\n                \"label\",\n                \"usage\",\n                \"format\",\n                \"width\",\n                \"height\",\n                \"presentMode\"\n            ],\n            \"WGPUTextureBindingLayout\": [\n                \"nextInChain\",\n                \"sampleType\",\n                \"viewDimension\",\n                \"multisampled\"\n            ],\n            \"WGPUTextureDataLayout\": [\n                \"nextInChain\",\n                \"offset\",\n                \"bytesPerRow\",\n                \"rowsPerImage\"\n            ],\n            \"WGPUTextureViewDescriptor\": [\n                \"nextInChain\",\n                \"label\",\n                \"format\",\n                \"dimension\",\n                \"baseMipLevel\",\n                \"mipLevelCount\",\n                \"baseArrayLayer\",\n                \"arrayLayerCount\",\n                \"aspect\"\n            ],\n            \"WGPUVertexAttribute\": [\n                \"format\",\n                \"offset\",\n                \"shaderLocation\"\n            ],\n            \"WGPUBindGroupDescriptor\": [\n                \"nextInChain\",\n                \"label\",\n                \"layout\",\n                \"entryCount\",\n                \"entries\"\n            ],\n            \"WGPUBindGroupLayoutEntry\": [\n                \"nextInChain\",\n                \"binding\",\n                \"visibility\",\n                \"buffer\",\n                \"sampler\",\n                \"texture\",\n                \"storageTexture\"\n            ],\n            \"WGPUBlendState\": [\n                \"color\",\n                \"alpha\"\n            ],\n            \"WGPUCompilationInfo\": [\n                \"nextInChain\",\n                \"messageCount\",\n                \"messages\"\n            ],\n            \"WGPUComputePassDescriptor\": [\n                \"nextInChain\",\n                \"label\",\n                \"timestampWriteCount\",\n                \"timestampWrites\"\n            ],\n            \"WGPUDepthStencilState\": [\n                \"nextInChain\",\n                \"format\",\n                \"depthWriteEnabled\",\n                \"depthCompare\",\n                \"stencilFront\",\n                \"stencilBack\",\n                \"stencilReadMask\",\n                \"stencilWriteMask\",\n                \"depthBias\",\n                \"depthBiasSlopeScale\",\n                \"depthBiasClamp\"\n            ],\n            \"WGPUImageCopyBuffer\": [\n                \"nextInChain\",\n                \"layout\",\n                \"buffer\"\n            ],\n            \"WGPUImageCopyTexture\": [\n                \"nextInChain\",\n                \"texture\",\n                \"mipLevel\",\n                \"origin\",\n                \"aspect\"\n            ],\n            \"WGPUProgrammableStageDescriptor\": [\n                \"nextInChain\",\n                \"module\",\n                \"entryPoint\",\n                \"constantCount\",\n                \"constants\"\n            ],\n            \"WGPURenderPassColorAttachment\": [\n                \"nextInChain\",\n                \"view\",\n                \"resolveTarget\",\n                \"loadOp\",\n                \"storeOp\",\n                \"clearValue\"\n            ],\n            \"WGPURequiredLimits\": [\n                \"nextInChain\",\n                \"limits\"\n            ],\n            \"WGPUSupportedLimits\": [\n                \"nextInChain\",\n                \"limits\"\n            ],\n            \"WGPUTextureDescriptor\": [\n                \"nextInChain\",\n                \"label\",\n                \"usage\",\n                \"dimension\",\n                \"size\",\n                \"format\",\n                \"mipLevelCount\",\n                \"sampleCount\",\n                \"viewFormatCount\",\n                \"viewFormats\"\n            ],\n            \"WGPUVertexBufferLayout\": [\n                \"arrayStride\",\n                \"stepMode\",\n                \"attributeCount\",\n                \"attributes\"\n            ],\n            \"WGPUBindGroupLayoutDescriptor\": [\n                \"nextInChain\",\n                \"label\",\n                \"entryCount\",\n                \"entries\"\n            ],\n            \"WGPUColorTargetState\": [\n                \"nextInChain\",\n                \"format\",\n                \"blend\",\n                \"writeMask\"\n            ],\n            \"WGPUComputePipelineDescriptor\": [\n                \"nextInChain\",\n                \"label\",\n                \"layout\",\n                \"compute\"\n            ],\n            \"WGPUDeviceDescriptor\": [\n                \"nextInChain\",\n                \"label\",\n                \"requiredFeaturesCount\",\n                \"requiredFeatures\",\n                \"requiredLimits\",\n                \"defaultQueue\",\n                \"deviceLostCallback\",\n                \"deviceLostUserdata\"\n            ],\n            \"WGPURenderPassDescriptor\": [\n                \"nextInChain\",\n                \"label\",\n                \"colorAttachmentCount\",\n                \"colorAttachments\",\n                \"depthStencilAttachment\",\n                \"occlusionQuerySet\",\n                \"timestampWriteCount\",\n                \"timestampWrites\"\n            ],\n            \"WGPUVertexState\": [\n                \"nextInChain\",\n                \"module\",\n                \"entryPoint\",\n                \"constantCount\",\n                \"constants\",\n                \"bufferCount\",\n                \"buffers\"\n            ],\n            \"WGPUFragmentState\": [\n                \"nextInChain\",\n                \"module\",\n                \"entryPoint\",\n                \"constantCount\",\n                \"constants\",\n                \"targetCount\",\n                \"targets\"\n            ],\n            \"WGPURenderPipelineDescriptor\": [\n                \"nextInChain\",\n                \"label\",\n                \"layout\",\n                \"vertex\",\n                \"primitive\",\n                \"depthStencil\",\n                \"multisample\",\n                \"fragment\"\n            ]\n        }\n    }\n", "emscripten-bits/library_webgpu_enum_tables.js": "    AddressMode: [\n      'repeat',\n      'mirror-repeat',\n      'clamp-to-edge',\n    ],\n    BlendFactor: [\n      'zero',\n      'one',\n      'src',\n      'one-minus-src',\n      'src-alpha',\n      'one-minus-src-alpha',\n      'dst',\n      'one-minus-dst',\n      'dst-alpha',\n      'one-minus-dst-alpha',\n      'src-alpha-saturated',\n      'constant',\n      'one-minus-constant',\n    ],\n    BlendOperation: [\n      'add',\n      'subtract',\n      'reverse-subtract',\n      'min',\n      'max',\n    ],\n    BufferBindingType: [\n      undefined,\n      'uniform',\n      'storage',\n      'read-only-storage',\n    ],\n    BufferMapState: [\n      'unmapped',\n      'pending',\n      'mapped',\n    ],\n    CompareFunction: [\n      undefined,\n      'never',\n      'less',\n      'less-equal',\n      'greater',\n      'greater-equal',\n      'equal',\n      'not-equal',\n      'always',\n    ],\n    CompilationInfoRequestStatus: [\n      'success',\n      'error',\n      'device-lost',\n      'unknown',\n    ],\n    ComputePassTimestampLocation: [\n      'beginning',\n      'end',\n    ],\n    CullMode: [\n      'none',\n      'front',\n      'back',\n    ],\n    ErrorFilter: [\n      'validation',\n      'out-of-memory',\n      'internal',\n    ],\n    FeatureName: [\n      undefined,\n      'depth-clip-control',\n      'depth32float-stencil8',\n      'timestamp-query',\n      'pipeline-statistics-query',\n      'texture-compression-bc',\n      'texture-compression-etc2',\n      'texture-compression-astc',\n      'indirect-first-instance',\n      'shader-f16',\n      'rg11b10ufloat-renderable',\n      'bgra8unorm-storage',\n      'float32filterable',\n    ],\n    FilterMode: [\n      'nearest',\n      'linear',\n    ],\n    FrontFace: [\n      'ccw',\n      'cw',\n    ],\n    IndexFormat: [\n      undefined,\n      'uint16',\n      'uint32',\n    ],\n    LoadOp: [\n      undefined,\n      'clear',\n      'load',\n    ],\n    MipmapFilterMode: [\n      'nearest',\n      'linear',\n    ],\n    PipelineStatisticName: [\n      'vertex-shader-invocations',\n      'clipper-invocations',\n      'clipper-primitives-out',\n      'fragment-shader-invocations',\n      'compute-shader-invocations',\n    ],\n    PowerPreference: [\n      undefined,\n      'low-power',\n      'high-performance',\n    ],\n    PrimitiveTopology: [\n      'point-list',\n      'line-list',\n      'line-strip',\n      'triangle-list',\n      'triangle-strip',\n    ],\n    QueryType: [\n      'occlusion',\n      'pipeline-statistics',\n      'timestamp',\n    ],\n    RenderPassTimestampLocation: [\n      'beginning',\n      'end',\n    ],\n    SamplerBindingType: [\n      undefined,\n      'filtering',\n      'non-filtering',\n      'comparison',\n    ],\n    StencilOperation: [\n      'keep',\n      'zero',\n      'replace',\n      'invert',\n      'increment-clamp',\n      'decrement-clamp',\n      'increment-wrap',\n      'decrement-wrap',\n    ],\n    StorageTextureAccess: [\n      undefined,\n      'write-only',\n    ],\n    StoreOp: [\n      undefined,\n      'store',\n      'discard',\n    ],\n    TextureAspect: [\n      'all',\n      'stencil-only',\n      'depth-only',\n    ],\n    TextureDimension: [\n      '1d',\n      '2d',\n      '3d',\n    ],\n    TextureFormat: [\n      undefined,\n      'r8unorm',\n      'r8snorm',\n      'r8uint',\n      'r8sint',\n      'r16uint',\n      'r16sint',\n      'r16float',\n      'rg8unorm',\n      'rg8snorm',\n      'rg8uint',\n      'rg8sint',\n      'r32float',\n      'r32uint',\n      'r32sint',\n      'rg16uint',\n      'rg16sint',\n      'rg16float',\n      'rgba8unorm',\n      'rgba8unorm-srgb',\n      'rgba8snorm',\n      'rgba8uint',\n      'rgba8sint',\n      'bgra8unorm',\n      'bgra8unorm-srgb',\n      'rgb10a2unorm',\n      'rg11b10ufloat',\n      'rgb9e5ufloat',\n      'rg32float',\n      'rg32uint',\n      'rg32sint',\n      'rgba16uint',\n      'rgba16sint',\n      'rgba16float',\n      'rgba32float',\n      'rgba32uint',\n      'rgba32sint',\n      'stencil8',\n      'depth16unorm',\n      'depth24plus',\n      'depth24plus-stencil8',\n      'depth32float',\n      'depth32float-stencil8',\n      'bc1-rgba-unorm',\n      'bc1-rgba-unorm-srgb',\n      'bc2-rgba-unorm',\n      'bc2-rgba-unorm-srgb',\n      'bc3-rgba-unorm',\n      'bc3-rgba-unorm-srgb',\n      'bc4-r-unorm',\n      'bc4-r-snorm',\n      'bc5-rg-unorm',\n      'bc5-rg-snorm',\n      'bc6h-rgb-ufloat',\n      'bc6h-rgb-float',\n      'bc7-rgba-unorm',\n      'bc7-rgba-unorm-srgb',\n      'etc2-rgb8unorm',\n      'etc2-rgb8unorm-srgb',\n      'etc2-rgb8a1unorm',\n      'etc2-rgb8a1unorm-srgb',\n      'etc2-rgba8unorm',\n      'etc2-rgba8unorm-srgb',\n      'eac-r11unorm',\n      'eac-r11snorm',\n      'eac-rg11unorm',\n      'eac-rg11snorm',\n      'astc-4x4-unorm',\n      'astc-4x4-unorm-srgb',\n      'astc-5x4-unorm',\n      'astc-5x4-unorm-srgb',\n      'astc-5x5-unorm',\n      'astc-5x5-unorm-srgb',\n      'astc-6x5-unorm',\n      'astc-6x5-unorm-srgb',\n      'astc-6x6-unorm',\n      'astc-6x6-unorm-srgb',\n      'astc-8x5-unorm',\n      'astc-8x5-unorm-srgb',\n      'astc-8x6-unorm',\n      'astc-8x6-unorm-srgb',\n      'astc-8x8-unorm',\n      'astc-8x8-unorm-srgb',\n      'astc-10x5-unorm',\n      'astc-10x5-unorm-srgb',\n      'astc-10x6-unorm',\n      'astc-10x6-unorm-srgb',\n      'astc-10x8-unorm',\n      'astc-10x8-unorm-srgb',\n      'astc-10x10-unorm',\n      'astc-10x10-unorm-srgb',\n      'astc-12x10-unorm',\n      'astc-12x10-unorm-srgb',\n      'astc-12x12-unorm',\n      'astc-12x12-unorm-srgb',\n    ],\n    TextureSampleType: [\n      undefined,\n      'float',\n      'unfilterable-float',\n      'depth',\n      'sint',\n      'uint',\n    ],\n    TextureViewDimension: [\n      undefined,\n      '1d',\n      '2d',\n      '2d-array',\n      'cube',\n      'cube-array',\n      '3d',\n    ],\n    VertexFormat: [\n      undefined,\n      'uint8x2',\n      'uint8x4',\n      'sint8x2',\n      'sint8x4',\n      'unorm8x2',\n      'unorm8x4',\n      'snorm8x2',\n      'snorm8x4',\n      'uint16x2',\n      'uint16x4',\n      'sint16x2',\n      'sint16x4',\n      'unorm16x2',\n      'unorm16x4',\n      'snorm16x2',\n      'snorm16x4',\n      'float16x2',\n      'float16x4',\n      'float32',\n      'float32x2',\n      'float32x3',\n      'float32x4',\n      'uint32',\n      'uint32x2',\n      'uint32x3',\n      'uint32x4',\n      'sint32',\n      'sint32x2',\n      'sint32x3',\n      'sint32x4',\n    ],\n    VertexStepMode: [\n      'vertex',\n      'instance',\n      undefined,\n    ],\n"}