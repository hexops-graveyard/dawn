{"src/dawn/wire/ObjectType_autogen.h": "\n#ifndef DAWNWIRE_OBJECTTPYE_AUTOGEN_H_\n#define DAWNWIRE_OBJECTTPYE_AUTOGEN_H_\n\n#include \"dawn/common/ityp_array.h\"\n\nnamespace dawn::wire {\n\n    constexpr uint32_t kObjectTypes = 24;\n\n    enum class ObjectType : uint32_t {\n        Adapter,\n        BindGroup,\n        BindGroupLayout,\n        Buffer,\n        CommandBuffer,\n        CommandEncoder,\n        ComputePassEncoder,\n        ComputePipeline,\n        Device,\n        ExternalTexture,\n        Instance,\n        PipelineLayout,\n        QuerySet,\n        Queue,\n        RenderBundle,\n        RenderBundleEncoder,\n        RenderPassEncoder,\n        RenderPipeline,\n        Sampler,\n        ShaderModule,\n        Surface,\n        SwapChain,\n        Texture,\n        TextureView,\n    };\n\n    template <typename T>\n    using PerObjectType = ityp::array<ObjectType, T, 24>;\n\n} // namespace dawn::wire\n\n\n#endif  // DAWNWIRE_OBJECTTPYE_AUTOGEN_H_\n", "src/dawn/wire/WireCmd_autogen.h": "\n#ifndef DAWNWIRE_WIRECMD_AUTOGEN_H_\n#define DAWNWIRE_WIRECMD_AUTOGEN_H_\n\n#include \"dawn/webgpu.h\"\n\n#include \"dawn/wire/BufferConsumer.h\"\n#include \"dawn/wire/ObjectType_autogen.h\"\n#include \"dawn/wire/ObjectHandle.h\"\n#include \"dawn/wire/WireResult.h\"\n\nnamespace dawn::wire {\n\n    // Interface to allocate more space to deserialize pointed-to data.\n    // nullptr is treated as an error.\n    class DeserializeAllocator {\n        public:\n            virtual void* GetSpace(size_t size) = 0;\n    };\n\n    // Interface to convert an ID to a server object, if possible.\n    // Methods return FatalError if the ID is for a non-existent object and Success otherwise.\n    class ObjectIdResolver {\n        public:\n            virtual WireResult GetFromId(ObjectId id, WGPUAdapter* out) const = 0;\n            virtual WireResult GetOptionalFromId(ObjectId id, WGPUAdapter* out) const = 0;\n            virtual WireResult GetFromId(ObjectId id, WGPUBindGroup* out) const = 0;\n            virtual WireResult GetOptionalFromId(ObjectId id, WGPUBindGroup* out) const = 0;\n            virtual WireResult GetFromId(ObjectId id, WGPUBindGroupLayout* out) const = 0;\n            virtual WireResult GetOptionalFromId(ObjectId id, WGPUBindGroupLayout* out) const = 0;\n            virtual WireResult GetFromId(ObjectId id, WGPUBuffer* out) const = 0;\n            virtual WireResult GetOptionalFromId(ObjectId id, WGPUBuffer* out) const = 0;\n            virtual WireResult GetFromId(ObjectId id, WGPUCommandBuffer* out) const = 0;\n            virtual WireResult GetOptionalFromId(ObjectId id, WGPUCommandBuffer* out) const = 0;\n            virtual WireResult GetFromId(ObjectId id, WGPUCommandEncoder* out) const = 0;\n            virtual WireResult GetOptionalFromId(ObjectId id, WGPUCommandEncoder* out) const = 0;\n            virtual WireResult GetFromId(ObjectId id, WGPUComputePassEncoder* out) const = 0;\n            virtual WireResult GetOptionalFromId(ObjectId id, WGPUComputePassEncoder* out) const = 0;\n            virtual WireResult GetFromId(ObjectId id, WGPUComputePipeline* out) const = 0;\n            virtual WireResult GetOptionalFromId(ObjectId id, WGPUComputePipeline* out) const = 0;\n            virtual WireResult GetFromId(ObjectId id, WGPUDevice* out) const = 0;\n            virtual WireResult GetOptionalFromId(ObjectId id, WGPUDevice* out) const = 0;\n            virtual WireResult GetFromId(ObjectId id, WGPUExternalTexture* out) const = 0;\n            virtual WireResult GetOptionalFromId(ObjectId id, WGPUExternalTexture* out) const = 0;\n            virtual WireResult GetFromId(ObjectId id, WGPUInstance* out) const = 0;\n            virtual WireResult GetOptionalFromId(ObjectId id, WGPUInstance* out) const = 0;\n            virtual WireResult GetFromId(ObjectId id, WGPUPipelineLayout* out) const = 0;\n            virtual WireResult GetOptionalFromId(ObjectId id, WGPUPipelineLayout* out) const = 0;\n            virtual WireResult GetFromId(ObjectId id, WGPUQuerySet* out) const = 0;\n            virtual WireResult GetOptionalFromId(ObjectId id, WGPUQuerySet* out) const = 0;\n            virtual WireResult GetFromId(ObjectId id, WGPUQueue* out) const = 0;\n            virtual WireResult GetOptionalFromId(ObjectId id, WGPUQueue* out) const = 0;\n            virtual WireResult GetFromId(ObjectId id, WGPURenderBundle* out) const = 0;\n            virtual WireResult GetOptionalFromId(ObjectId id, WGPURenderBundle* out) const = 0;\n            virtual WireResult GetFromId(ObjectId id, WGPURenderBundleEncoder* out) const = 0;\n            virtual WireResult GetOptionalFromId(ObjectId id, WGPURenderBundleEncoder* out) const = 0;\n            virtual WireResult GetFromId(ObjectId id, WGPURenderPassEncoder* out) const = 0;\n            virtual WireResult GetOptionalFromId(ObjectId id, WGPURenderPassEncoder* out) const = 0;\n            virtual WireResult GetFromId(ObjectId id, WGPURenderPipeline* out) const = 0;\n            virtual WireResult GetOptionalFromId(ObjectId id, WGPURenderPipeline* out) const = 0;\n            virtual WireResult GetFromId(ObjectId id, WGPUSampler* out) const = 0;\n            virtual WireResult GetOptionalFromId(ObjectId id, WGPUSampler* out) const = 0;\n            virtual WireResult GetFromId(ObjectId id, WGPUShaderModule* out) const = 0;\n            virtual WireResult GetOptionalFromId(ObjectId id, WGPUShaderModule* out) const = 0;\n            virtual WireResult GetFromId(ObjectId id, WGPUSurface* out) const = 0;\n            virtual WireResult GetOptionalFromId(ObjectId id, WGPUSurface* out) const = 0;\n            virtual WireResult GetFromId(ObjectId id, WGPUSwapChain* out) const = 0;\n            virtual WireResult GetOptionalFromId(ObjectId id, WGPUSwapChain* out) const = 0;\n            virtual WireResult GetFromId(ObjectId id, WGPUTexture* out) const = 0;\n            virtual WireResult GetOptionalFromId(ObjectId id, WGPUTexture* out) const = 0;\n            virtual WireResult GetFromId(ObjectId id, WGPUTextureView* out) const = 0;\n            virtual WireResult GetOptionalFromId(ObjectId id, WGPUTextureView* out) const = 0;\n    };\n\n    // Interface to convert a client object to its ID for the wiring.\n    class ObjectIdProvider {\n        public:\n            virtual WireResult GetId(WGPUAdapter object, ObjectId* out) const = 0;\n            virtual WireResult GetOptionalId(WGPUAdapter object, ObjectId* out) const = 0;\n            virtual WireResult GetId(WGPUBindGroup object, ObjectId* out) const = 0;\n            virtual WireResult GetOptionalId(WGPUBindGroup object, ObjectId* out) const = 0;\n            virtual WireResult GetId(WGPUBindGroupLayout object, ObjectId* out) const = 0;\n            virtual WireResult GetOptionalId(WGPUBindGroupLayout object, ObjectId* out) const = 0;\n            virtual WireResult GetId(WGPUBuffer object, ObjectId* out) const = 0;\n            virtual WireResult GetOptionalId(WGPUBuffer object, ObjectId* out) const = 0;\n            virtual WireResult GetId(WGPUCommandBuffer object, ObjectId* out) const = 0;\n            virtual WireResult GetOptionalId(WGPUCommandBuffer object, ObjectId* out) const = 0;\n            virtual WireResult GetId(WGPUCommandEncoder object, ObjectId* out) const = 0;\n            virtual WireResult GetOptionalId(WGPUCommandEncoder object, ObjectId* out) const = 0;\n            virtual WireResult GetId(WGPUComputePassEncoder object, ObjectId* out) const = 0;\n            virtual WireResult GetOptionalId(WGPUComputePassEncoder object, ObjectId* out) const = 0;\n            virtual WireResult GetId(WGPUComputePipeline object, ObjectId* out) const = 0;\n            virtual WireResult GetOptionalId(WGPUComputePipeline object, ObjectId* out) const = 0;\n            virtual WireResult GetId(WGPUDevice object, ObjectId* out) const = 0;\n            virtual WireResult GetOptionalId(WGPUDevice object, ObjectId* out) const = 0;\n            virtual WireResult GetId(WGPUExternalTexture object, ObjectId* out) const = 0;\n            virtual WireResult GetOptionalId(WGPUExternalTexture object, ObjectId* out) const = 0;\n            virtual WireResult GetId(WGPUInstance object, ObjectId* out) const = 0;\n            virtual WireResult GetOptionalId(WGPUInstance object, ObjectId* out) const = 0;\n            virtual WireResult GetId(WGPUPipelineLayout object, ObjectId* out) const = 0;\n            virtual WireResult GetOptionalId(WGPUPipelineLayout object, ObjectId* out) const = 0;\n            virtual WireResult GetId(WGPUQuerySet object, ObjectId* out) const = 0;\n            virtual WireResult GetOptionalId(WGPUQuerySet object, ObjectId* out) const = 0;\n            virtual WireResult GetId(WGPUQueue object, ObjectId* out) const = 0;\n            virtual WireResult GetOptionalId(WGPUQueue object, ObjectId* out) const = 0;\n            virtual WireResult GetId(WGPURenderBundle object, ObjectId* out) const = 0;\n            virtual WireResult GetOptionalId(WGPURenderBundle object, ObjectId* out) const = 0;\n            virtual WireResult GetId(WGPURenderBundleEncoder object, ObjectId* out) const = 0;\n            virtual WireResult GetOptionalId(WGPURenderBundleEncoder object, ObjectId* out) const = 0;\n            virtual WireResult GetId(WGPURenderPassEncoder object, ObjectId* out) const = 0;\n            virtual WireResult GetOptionalId(WGPURenderPassEncoder object, ObjectId* out) const = 0;\n            virtual WireResult GetId(WGPURenderPipeline object, ObjectId* out) const = 0;\n            virtual WireResult GetOptionalId(WGPURenderPipeline object, ObjectId* out) const = 0;\n            virtual WireResult GetId(WGPUSampler object, ObjectId* out) const = 0;\n            virtual WireResult GetOptionalId(WGPUSampler object, ObjectId* out) const = 0;\n            virtual WireResult GetId(WGPUShaderModule object, ObjectId* out) const = 0;\n            virtual WireResult GetOptionalId(WGPUShaderModule object, ObjectId* out) const = 0;\n            virtual WireResult GetId(WGPUSurface object, ObjectId* out) const = 0;\n            virtual WireResult GetOptionalId(WGPUSurface object, ObjectId* out) const = 0;\n            virtual WireResult GetId(WGPUSwapChain object, ObjectId* out) const = 0;\n            virtual WireResult GetOptionalId(WGPUSwapChain object, ObjectId* out) const = 0;\n            virtual WireResult GetId(WGPUTexture object, ObjectId* out) const = 0;\n            virtual WireResult GetOptionalId(WGPUTexture object, ObjectId* out) const = 0;\n            virtual WireResult GetId(WGPUTextureView object, ObjectId* out) const = 0;\n            virtual WireResult GetOptionalId(WGPUTextureView object, ObjectId* out) const = 0;\n    };\n\n    enum class WireCmd : uint32_t {\n        AdapterGetInstance,\n        AdapterRequestDevice,\n        BindGroupLayoutSetLabel,\n        BindGroupSetLabel,\n        BufferDestroy,\n        BufferMapAsync,\n        BufferSetLabel,\n        BufferUnmap,\n        BufferUpdateMappedData,\n        CommandBufferSetLabel,\n        CommandEncoderBeginComputePass,\n        CommandEncoderBeginRenderPass,\n        CommandEncoderClearBuffer,\n        CommandEncoderCopyBufferToBuffer,\n        CommandEncoderCopyBufferToTexture,\n        CommandEncoderCopyTextureToBuffer,\n        CommandEncoderCopyTextureToTexture,\n        CommandEncoderCopyTextureToTextureInternal,\n        CommandEncoderFinish,\n        CommandEncoderInjectValidationError,\n        CommandEncoderInsertDebugMarker,\n        CommandEncoderPopDebugGroup,\n        CommandEncoderPushDebugGroup,\n        CommandEncoderResolveQuerySet,\n        CommandEncoderSetLabel,\n        CommandEncoderWriteBuffer,\n        CommandEncoderWriteTimestamp,\n        ComputePassEncoderDispatchWorkgroups,\n        ComputePassEncoderDispatchWorkgroupsIndirect,\n        ComputePassEncoderEnd,\n        ComputePassEncoderInsertDebugMarker,\n        ComputePassEncoderPopDebugGroup,\n        ComputePassEncoderPushDebugGroup,\n        ComputePassEncoderSetBindGroup,\n        ComputePassEncoderSetLabel,\n        ComputePassEncoderSetPipeline,\n        ComputePassEncoderWriteTimestamp,\n        ComputePipelineGetBindGroupLayout,\n        ComputePipelineSetLabel,\n        DestroyObject,\n        DeviceCreateBindGroup,\n        DeviceCreateBindGroupLayout,\n        DeviceCreateBuffer,\n        DeviceCreateCommandEncoder,\n        DeviceCreateComputePipeline,\n        DeviceCreateComputePipelineAsync,\n        DeviceCreateErrorBuffer,\n        DeviceCreateErrorExternalTexture,\n        DeviceCreateErrorShaderModule,\n        DeviceCreateErrorTexture,\n        DeviceCreateExternalTexture,\n        DeviceCreatePipelineLayout,\n        DeviceCreateQuerySet,\n        DeviceCreateRenderBundleEncoder,\n        DeviceCreateRenderPipeline,\n        DeviceCreateRenderPipelineAsync,\n        DeviceCreateSampler,\n        DeviceCreateShaderModule,\n        DeviceCreateSwapChain,\n        DeviceCreateTexture,\n        DeviceDestroy,\n        DeviceForceLoss,\n        DeviceGetAdapter,\n        DeviceGetQueue,\n        DeviceInjectError,\n        DevicePopErrorScope,\n        DevicePushErrorScope,\n        DeviceSetLabel,\n        DeviceTick,\n        DeviceValidateTextureDescriptor,\n        ExternalTextureDestroy,\n        ExternalTextureExpire,\n        ExternalTextureRefresh,\n        ExternalTextureSetLabel,\n        InstanceCreateSurface,\n        InstanceProcessEvents,\n        InstanceRequestAdapter,\n        PipelineLayoutSetLabel,\n        QuerySetDestroy,\n        QuerySetSetLabel,\n        QueueCopyExternalTextureForBrowser,\n        QueueCopyTextureForBrowser,\n        QueueOnSubmittedWorkDone,\n        QueueSetLabel,\n        QueueSubmit,\n        QueueWriteBuffer,\n        QueueWriteTexture,\n        RenderBundleEncoderDraw,\n        RenderBundleEncoderDrawIndexed,\n        RenderBundleEncoderDrawIndexedIndirect,\n        RenderBundleEncoderDrawIndirect,\n        RenderBundleEncoderFinish,\n        RenderBundleEncoderInsertDebugMarker,\n        RenderBundleEncoderPopDebugGroup,\n        RenderBundleEncoderPushDebugGroup,\n        RenderBundleEncoderSetBindGroup,\n        RenderBundleEncoderSetIndexBuffer,\n        RenderBundleEncoderSetLabel,\n        RenderBundleEncoderSetPipeline,\n        RenderBundleEncoderSetVertexBuffer,\n        RenderBundleSetLabel,\n        RenderPassEncoderBeginOcclusionQuery,\n        RenderPassEncoderDraw,\n        RenderPassEncoderDrawIndexed,\n        RenderPassEncoderDrawIndexedIndirect,\n        RenderPassEncoderDrawIndirect,\n        RenderPassEncoderEnd,\n        RenderPassEncoderEndOcclusionQuery,\n        RenderPassEncoderExecuteBundles,\n        RenderPassEncoderInsertDebugMarker,\n        RenderPassEncoderPopDebugGroup,\n        RenderPassEncoderPushDebugGroup,\n        RenderPassEncoderSetBindGroup,\n        RenderPassEncoderSetBlendConstant,\n        RenderPassEncoderSetIndexBuffer,\n        RenderPassEncoderSetLabel,\n        RenderPassEncoderSetPipeline,\n        RenderPassEncoderSetScissorRect,\n        RenderPassEncoderSetStencilReference,\n        RenderPassEncoderSetVertexBuffer,\n        RenderPassEncoderSetViewport,\n        RenderPassEncoderWriteTimestamp,\n        RenderPipelineGetBindGroupLayout,\n        RenderPipelineSetLabel,\n        SamplerSetLabel,\n        ShaderModuleGetCompilationInfo,\n        ShaderModuleSetLabel,\n        SwapChainGetCurrentTexture,\n        SwapChainGetCurrentTextureView,\n        SwapChainPresent,\n        TextureCreateView,\n        TextureDestroy,\n        TextureSetLabel,\n        TextureViewSetLabel,\n    };\n\n    enum class ReturnWireCmd : uint32_t {\n        AdapterRequestDeviceCallback,\n        BufferMapAsyncCallback,\n        DeviceCreateComputePipelineAsyncCallback,\n        DeviceCreateRenderPipelineAsyncCallback,\n        DeviceLoggingCallback,\n        DeviceLostCallback,\n        DevicePopErrorScopeCallback,\n        DeviceUncapturedErrorCallback,\n        InstanceRequestAdapterCallback,\n        QueueWorkDoneCallback,\n        ShaderModuleGetCompilationInfoCallback,\n    };\n\n    struct CmdHeader {\n        uint64_t commandSize;\n    };\n\n\n    struct AdapterGetInstanceCmd {\n    size_t GetRequiredSize() const;\n\n    WireResult Serialize(size_t commandSize, SerializeBuffer* serializeBuffer, const ObjectIdProvider& objectIdProvider) const;\n    // Override which produces a FatalError if any object is used.\n    WireResult Serialize(size_t commandSize, SerializeBuffer* serializeBuffer) const;\n\n    WireResult Deserialize(DeserializeBuffer* deserializeBuffer, DeserializeAllocator* allocator, const ObjectIdResolver& resolver);\n    // Override which produces a FatalError if any object is used.\n    WireResult Deserialize(DeserializeBuffer* deserializeBuffer, DeserializeAllocator* allocator);\n\n    ObjectId selfId;\n\n    WGPUAdapter self;\n    ObjectHandle result;\n};\n\n    struct AdapterRequestDeviceCmd {\n    size_t GetRequiredSize() const;\n\n    WireResult Serialize(size_t commandSize, SerializeBuffer* serializeBuffer, const ObjectIdProvider& objectIdProvider) const;\n    // Override which produces a FatalError if any object is used.\n    WireResult Serialize(size_t commandSize, SerializeBuffer* serializeBuffer) const;\n\n    WireResult Deserialize(DeserializeBuffer* deserializeBuffer, DeserializeAllocator* allocator, const ObjectIdResolver& resolver);\n    // Override which produces a FatalError if any object is used.\n    WireResult Deserialize(DeserializeBuffer* deserializeBuffer, DeserializeAllocator* allocator);\n\n\n    ObjectId adapterId;\n    uint64_t requestSerial;\n    ObjectHandle deviceObjectHandle;\n    WGPUDeviceDescriptor const * descriptor;\n};\n\n    struct BindGroupLayoutSetLabelCmd {\n    size_t GetRequiredSize() const;\n\n    WireResult Serialize(size_t commandSize, SerializeBuffer* serializeBuffer, const ObjectIdProvider& objectIdProvider) const;\n    // Override which produces a FatalError if any object is used.\n    WireResult Serialize(size_t commandSize, SerializeBuffer* serializeBuffer) const;\n\n    WireResult Deserialize(DeserializeBuffer* deserializeBuffer, DeserializeAllocator* allocator, const ObjectIdResolver& resolver);\n    // Override which produces a FatalError if any object is used.\n    WireResult Deserialize(DeserializeBuffer* deserializeBuffer, DeserializeAllocator* allocator);\n\n    ObjectId selfId;\n\n    WGPUBindGroupLayout self;\n    char const * label;\n};\n\n    struct BindGroupSetLabelCmd {\n    size_t GetRequiredSize() const;\n\n    WireResult Serialize(size_t commandSize, SerializeBuffer* serializeBuffer, const ObjectIdProvider& objectIdProvider) const;\n    // Override which produces a FatalError if any object is used.\n    WireResult Serialize(size_t commandSize, SerializeBuffer* serializeBuffer) const;\n\n    WireResult Deserialize(DeserializeBuffer* deserializeBuffer, DeserializeAllocator* allocator, const ObjectIdResolver& resolver);\n    // Override which produces a FatalError if any object is used.\n    WireResult Deserialize(DeserializeBuffer* deserializeBuffer, DeserializeAllocator* allocator);\n\n    ObjectId selfId;\n\n    WGPUBindGroup self;\n    char const * label;\n};\n\n    struct BufferDestroyCmd {\n    size_t GetRequiredSize() const;\n\n    WireResult Serialize(size_t commandSize, SerializeBuffer* serializeBuffer, const ObjectIdProvider& objectIdProvider) const;\n    // Override which produces a FatalError if any object is used.\n    WireResult Serialize(size_t commandSize, SerializeBuffer* serializeBuffer) const;\n\n    WireResult Deserialize(DeserializeBuffer* deserializeBuffer, DeserializeAllocator* allocator, const ObjectIdResolver& resolver);\n    // Override which produces a FatalError if any object is used.\n    WireResult Deserialize(DeserializeBuffer* deserializeBuffer, DeserializeAllocator* allocator);\n\n    ObjectId selfId;\n\n    WGPUBuffer self;\n};\n\n    struct BufferMapAsyncCmd {\n    size_t GetRequiredSize() const;\n\n    WireResult Serialize(size_t commandSize, SerializeBuffer* serializeBuffer, const ObjectIdProvider& objectIdProvider) const;\n    // Override which produces a FatalError if any object is used.\n    WireResult Serialize(size_t commandSize, SerializeBuffer* serializeBuffer) const;\n\n    WireResult Deserialize(DeserializeBuffer* deserializeBuffer, DeserializeAllocator* allocator, const ObjectIdResolver& resolver);\n    // Override which produces a FatalError if any object is used.\n    WireResult Deserialize(DeserializeBuffer* deserializeBuffer, DeserializeAllocator* allocator);\n\n\n    ObjectId bufferId;\n    uint64_t requestSerial;\n    WGPUMapModeFlags mode;\n    uint64_t offset;\n    uint64_t size;\n};\n\n    struct BufferSetLabelCmd {\n    size_t GetRequiredSize() const;\n\n    WireResult Serialize(size_t commandSize, SerializeBuffer* serializeBuffer, const ObjectIdProvider& objectIdProvider) const;\n    // Override which produces a FatalError if any object is used.\n    WireResult Serialize(size_t commandSize, SerializeBuffer* serializeBuffer) const;\n\n    WireResult Deserialize(DeserializeBuffer* deserializeBuffer, DeserializeAllocator* allocator, const ObjectIdResolver& resolver);\n    // Override which produces a FatalError if any object is used.\n    WireResult Deserialize(DeserializeBuffer* deserializeBuffer, DeserializeAllocator* allocator);\n\n    ObjectId selfId;\n\n    WGPUBuffer self;\n    char const * label;\n};\n\n    struct BufferUnmapCmd {\n    size_t GetRequiredSize() const;\n\n    WireResult Serialize(size_t commandSize, SerializeBuffer* serializeBuffer, const ObjectIdProvider& objectIdProvider) const;\n    // Override which produces a FatalError if any object is used.\n    WireResult Serialize(size_t commandSize, SerializeBuffer* serializeBuffer) const;\n\n    WireResult Deserialize(DeserializeBuffer* deserializeBuffer, DeserializeAllocator* allocator, const ObjectIdResolver& resolver);\n    // Override which produces a FatalError if any object is used.\n    WireResult Deserialize(DeserializeBuffer* deserializeBuffer, DeserializeAllocator* allocator);\n\n    ObjectId selfId;\n\n    WGPUBuffer self;\n};\n\n    struct BufferUpdateMappedDataCmd {\n    size_t GetRequiredSize() const;\n\n    WireResult Serialize(size_t commandSize, SerializeBuffer* serializeBuffer, const ObjectIdProvider& objectIdProvider) const;\n    // Override which produces a FatalError if any object is used.\n    WireResult Serialize(size_t commandSize, SerializeBuffer* serializeBuffer) const;\n\n    WireResult Deserialize(DeserializeBuffer* deserializeBuffer, DeserializeAllocator* allocator, const ObjectIdResolver& resolver);\n    // Override which produces a FatalError if any object is used.\n    WireResult Deserialize(DeserializeBuffer* deserializeBuffer, DeserializeAllocator* allocator);\n\n\n    ObjectId bufferId;\n    uint64_t writeDataUpdateInfoLength;\n    uint8_t const * writeDataUpdateInfo;\n    uint64_t offset;\n    uint64_t size;\n};\n\n    struct CommandBufferSetLabelCmd {\n    size_t GetRequiredSize() const;\n\n    WireResult Serialize(size_t commandSize, SerializeBuffer* serializeBuffer, const ObjectIdProvider& objectIdProvider) const;\n    // Override which produces a FatalError if any object is used.\n    WireResult Serialize(size_t commandSize, SerializeBuffer* serializeBuffer) const;\n\n    WireResult Deserialize(DeserializeBuffer* deserializeBuffer, DeserializeAllocator* allocator, const ObjectIdResolver& resolver);\n    // Override which produces a FatalError if any object is used.\n    WireResult Deserialize(DeserializeBuffer* deserializeBuffer, DeserializeAllocator* allocator);\n\n    ObjectId selfId;\n\n    WGPUCommandBuffer self;\n    char const * label;\n};\n\n    struct CommandEncoderBeginComputePassCmd {\n    size_t GetRequiredSize() const;\n\n    WireResult Serialize(size_t commandSize, SerializeBuffer* serializeBuffer, const ObjectIdProvider& objectIdProvider) const;\n    // Override which produces a FatalError if any object is used.\n    WireResult Serialize(size_t commandSize, SerializeBuffer* serializeBuffer) const;\n\n    WireResult Deserialize(DeserializeBuffer* deserializeBuffer, DeserializeAllocator* allocator, const ObjectIdResolver& resolver);\n    // Override which produces a FatalError if any object is used.\n    WireResult Deserialize(DeserializeBuffer* deserializeBuffer, DeserializeAllocator* allocator);\n\n    ObjectId selfId;\n\n    WGPUCommandEncoder self;\n    WGPUComputePassDescriptor const * descriptor;\n    ObjectHandle result;\n};\n\n    struct CommandEncoderBeginRenderPassCmd {\n    size_t GetRequiredSize() const;\n\n    WireResult Serialize(size_t commandSize, SerializeBuffer* serializeBuffer, const ObjectIdProvider& objectIdProvider) const;\n    // Override which produces a FatalError if any object is used.\n    WireResult Serialize(size_t commandSize, SerializeBuffer* serializeBuffer) const;\n\n    WireResult Deserialize(DeserializeBuffer* deserializeBuffer, DeserializeAllocator* allocator, const ObjectIdResolver& resolver);\n    // Override which produces a FatalError if any object is used.\n    WireResult Deserialize(DeserializeBuffer* deserializeBuffer, DeserializeAllocator* allocator);\n\n    ObjectId selfId;\n\n    WGPUCommandEncoder self;\n    WGPURenderPassDescriptor const * descriptor;\n    ObjectHandle result;\n};\n\n    struct CommandEncoderClearBufferCmd {\n    size_t GetRequiredSize() const;\n\n    WireResult Serialize(size_t commandSize, SerializeBuffer* serializeBuffer, const ObjectIdProvider& objectIdProvider) const;\n    // Override which produces a FatalError if any object is used.\n    WireResult Serialize(size_t commandSize, SerializeBuffer* serializeBuffer) const;\n\n    WireResult Deserialize(DeserializeBuffer* deserializeBuffer, DeserializeAllocator* allocator, const ObjectIdResolver& resolver);\n    // Override which produces a FatalError if any object is used.\n    WireResult Deserialize(DeserializeBuffer* deserializeBuffer, DeserializeAllocator* allocator);\n\n    ObjectId selfId;\n\n    WGPUCommandEncoder self;\n    WGPUBuffer buffer;\n    uint64_t offset;\n    uint64_t size;\n};\n\n    struct CommandEncoderCopyBufferToBufferCmd {\n    size_t GetRequiredSize() const;\n\n    WireResult Serialize(size_t commandSize, SerializeBuffer* serializeBuffer, const ObjectIdProvider& objectIdProvider) const;\n    // Override which produces a FatalError if any object is used.\n    WireResult Serialize(size_t commandSize, SerializeBuffer* serializeBuffer) const;\n\n    WireResult Deserialize(DeserializeBuffer* deserializeBuffer, DeserializeAllocator* allocator, const ObjectIdResolver& resolver);\n    // Override which produces a FatalError if any object is used.\n    WireResult Deserialize(DeserializeBuffer* deserializeBuffer, DeserializeAllocator* allocator);\n\n    ObjectId selfId;\n\n    WGPUCommandEncoder self;\n    WGPUBuffer source;\n    uint64_t sourceOffset;\n    WGPUBuffer destination;\n    uint64_t destinationOffset;\n    uint64_t size;\n};\n\n    struct CommandEncoderCopyBufferToTextureCmd {\n    size_t GetRequiredSize() const;\n\n    WireResult Serialize(size_t commandSize, SerializeBuffer* serializeBuffer, const ObjectIdProvider& objectIdProvider) const;\n    // Override which produces a FatalError if any object is used.\n    WireResult Serialize(size_t commandSize, SerializeBuffer* serializeBuffer) const;\n\n    WireResult Deserialize(DeserializeBuffer* deserializeBuffer, DeserializeAllocator* allocator, const ObjectIdResolver& resolver);\n    // Override which produces a FatalError if any object is used.\n    WireResult Deserialize(DeserializeBuffer* deserializeBuffer, DeserializeAllocator* allocator);\n\n    ObjectId selfId;\n\n    WGPUCommandEncoder self;\n    WGPUImageCopyBuffer const * source;\n    WGPUImageCopyTexture const * destination;\n    WGPUExtent3D const * copySize;\n};\n\n    struct CommandEncoderCopyTextureToBufferCmd {\n    size_t GetRequiredSize() const;\n\n    WireResult Serialize(size_t commandSize, SerializeBuffer* serializeBuffer, const ObjectIdProvider& objectIdProvider) const;\n    // Override which produces a FatalError if any object is used.\n    WireResult Serialize(size_t commandSize, SerializeBuffer* serializeBuffer) const;\n\n    WireResult Deserialize(DeserializeBuffer* deserializeBuffer, DeserializeAllocator* allocator, const ObjectIdResolver& resolver);\n    // Override which produces a FatalError if any object is used.\n    WireResult Deserialize(DeserializeBuffer* deserializeBuffer, DeserializeAllocator* allocator);\n\n    ObjectId selfId;\n\n    WGPUCommandEncoder self;\n    WGPUImageCopyTexture const * source;\n    WGPUImageCopyBuffer const * destination;\n    WGPUExtent3D const * copySize;\n};\n\n    struct CommandEncoderCopyTextureToTextureCmd {\n    size_t GetRequiredSize() const;\n\n    WireResult Serialize(size_t commandSize, SerializeBuffer* serializeBuffer, const ObjectIdProvider& objectIdProvider) const;\n    // Override which produces a FatalError if any object is used.\n    WireResult Serialize(size_t commandSize, SerializeBuffer* serializeBuffer) const;\n\n    WireResult Deserialize(DeserializeBuffer* deserializeBuffer, DeserializeAllocator* allocator, const ObjectIdResolver& resolver);\n    // Override which produces a FatalError if any object is used.\n    WireResult Deserialize(DeserializeBuffer* deserializeBuffer, DeserializeAllocator* allocator);\n\n    ObjectId selfId;\n\n    WGPUCommandEncoder self;\n    WGPUImageCopyTexture const * source;\n    WGPUImageCopyTexture const * destination;\n    WGPUExtent3D const * copySize;\n};\n\n    struct CommandEncoderCopyTextureToTextureInternalCmd {\n    size_t GetRequiredSize() const;\n\n    WireResult Serialize(size_t commandSize, SerializeBuffer* serializeBuffer, const ObjectIdProvider& objectIdProvider) const;\n    // Override which produces a FatalError if any object is used.\n    WireResult Serialize(size_t commandSize, SerializeBuffer* serializeBuffer) const;\n\n    WireResult Deserialize(DeserializeBuffer* deserializeBuffer, DeserializeAllocator* allocator, const ObjectIdResolver& resolver);\n    // Override which produces a FatalError if any object is used.\n    WireResult Deserialize(DeserializeBuffer* deserializeBuffer, DeserializeAllocator* allocator);\n\n    ObjectId selfId;\n\n    WGPUCommandEncoder self;\n    WGPUImageCopyTexture const * source;\n    WGPUImageCopyTexture const * destination;\n    WGPUExtent3D const * copySize;\n};\n\n    struct CommandEncoderFinishCmd {\n    size_t GetRequiredSize() const;\n\n    WireResult Serialize(size_t commandSize, SerializeBuffer* serializeBuffer, const ObjectIdProvider& objectIdProvider) const;\n    // Override which produces a FatalError if any object is used.\n    WireResult Serialize(size_t commandSize, SerializeBuffer* serializeBuffer) const;\n\n    WireResult Deserialize(DeserializeBuffer* deserializeBuffer, DeserializeAllocator* allocator, const ObjectIdResolver& resolver);\n    // Override which produces a FatalError if any object is used.\n    WireResult Deserialize(DeserializeBuffer* deserializeBuffer, DeserializeAllocator* allocator);\n\n    ObjectId selfId;\n\n    WGPUCommandEncoder self;\n    WGPUCommandBufferDescriptor const * descriptor;\n    ObjectHandle result;\n};\n\n    struct CommandEncoderInjectValidationErrorCmd {\n    size_t GetRequiredSize() const;\n\n    WireResult Serialize(size_t commandSize, SerializeBuffer* serializeBuffer, const ObjectIdProvider& objectIdProvider) const;\n    // Override which produces a FatalError if any object is used.\n    WireResult Serialize(size_t commandSize, SerializeBuffer* serializeBuffer) const;\n\n    WireResult Deserialize(DeserializeBuffer* deserializeBuffer, DeserializeAllocator* allocator, const ObjectIdResolver& resolver);\n    // Override which produces a FatalError if any object is used.\n    WireResult Deserialize(DeserializeBuffer* deserializeBuffer, DeserializeAllocator* allocator);\n\n    ObjectId selfId;\n\n    WGPUCommandEncoder self;\n    char const * message;\n};\n\n    struct CommandEncoderInsertDebugMarkerCmd {\n    size_t GetRequiredSize() const;\n\n    WireResult Serialize(size_t commandSize, SerializeBuffer* serializeBuffer, const ObjectIdProvider& objectIdProvider) const;\n    // Override which produces a FatalError if any object is used.\n    WireResult Serialize(size_t commandSize, SerializeBuffer* serializeBuffer) const;\n\n    WireResult Deserialize(DeserializeBuffer* deserializeBuffer, DeserializeAllocator* allocator, const ObjectIdResolver& resolver);\n    // Override which produces a FatalError if any object is used.\n    WireResult Deserialize(DeserializeBuffer* deserializeBuffer, DeserializeAllocator* allocator);\n\n    ObjectId selfId;\n\n    WGPUCommandEncoder self;\n    char const * markerLabel;\n};\n\n    struct CommandEncoderPopDebugGroupCmd {\n    size_t GetRequiredSize() const;\n\n    WireResult Serialize(size_t commandSize, SerializeBuffer* serializeBuffer, const ObjectIdProvider& objectIdProvider) const;\n    // Override which produces a FatalError if any object is used.\n    WireResult Serialize(size_t commandSize, SerializeBuffer* serializeBuffer) const;\n\n    WireResult Deserialize(DeserializeBuffer* deserializeBuffer, DeserializeAllocator* allocator, const ObjectIdResolver& resolver);\n    // Override which produces a FatalError if any object is used.\n    WireResult Deserialize(DeserializeBuffer* deserializeBuffer, DeserializeAllocator* allocator);\n\n    ObjectId selfId;\n\n    WGPUCommandEncoder self;\n};\n\n    struct CommandEncoderPushDebugGroupCmd {\n    size_t GetRequiredSize() const;\n\n    WireResult Serialize(size_t commandSize, SerializeBuffer* serializeBuffer, const ObjectIdProvider& objectIdProvider) const;\n    // Override which produces a FatalError if any object is used.\n    WireResult Serialize(size_t commandSize, SerializeBuffer* serializeBuffer) const;\n\n    WireResult Deserialize(DeserializeBuffer* deserializeBuffer, DeserializeAllocator* allocator, const ObjectIdResolver& resolver);\n    // Override which produces a FatalError if any object is used.\n    WireResult Deserialize(DeserializeBuffer* deserializeBuffer, DeserializeAllocator* allocator);\n\n    ObjectId selfId;\n\n    WGPUCommandEncoder self;\n    char const * groupLabel;\n};\n\n    struct CommandEncoderResolveQuerySetCmd {\n    size_t GetRequiredSize() const;\n\n    WireResult Serialize(size_t commandSize, SerializeBuffer* serializeBuffer, const ObjectIdProvider& objectIdProvider) const;\n    // Override which produces a FatalError if any object is used.\n    WireResult Serialize(size_t commandSize, SerializeBuffer* serializeBuffer) const;\n\n    WireResult Deserialize(DeserializeBuffer* deserializeBuffer, DeserializeAllocator* allocator, const ObjectIdResolver& resolver);\n    // Override which produces a FatalError if any object is used.\n    WireResult Deserialize(DeserializeBuffer* deserializeBuffer, DeserializeAllocator* allocator);\n\n    ObjectId selfId;\n\n    WGPUCommandEncoder self;\n    WGPUQuerySet querySet;\n    uint32_t firstQuery;\n    uint32_t queryCount;\n    WGPUBuffer destination;\n    uint64_t destinationOffset;\n};\n\n    struct CommandEncoderSetLabelCmd {\n    size_t GetRequiredSize() const;\n\n    WireResult Serialize(size_t commandSize, SerializeBuffer* serializeBuffer, const ObjectIdProvider& objectIdProvider) const;\n    // Override which produces a FatalError if any object is used.\n    WireResult Serialize(size_t commandSize, SerializeBuffer* serializeBuffer) const;\n\n    WireResult Deserialize(DeserializeBuffer* deserializeBuffer, DeserializeAllocator* allocator, const ObjectIdResolver& resolver);\n    // Override which produces a FatalError if any object is used.\n    WireResult Deserialize(DeserializeBuffer* deserializeBuffer, DeserializeAllocator* allocator);\n\n    ObjectId selfId;\n\n    WGPUCommandEncoder self;\n    char const * label;\n};\n\n    struct CommandEncoderWriteBufferCmd {\n    size_t GetRequiredSize() const;\n\n    WireResult Serialize(size_t commandSize, SerializeBuffer* serializeBuffer, const ObjectIdProvider& objectIdProvider) const;\n    // Override which produces a FatalError if any object is used.\n    WireResult Serialize(size_t commandSize, SerializeBuffer* serializeBuffer) const;\n\n    WireResult Deserialize(DeserializeBuffer* deserializeBuffer, DeserializeAllocator* allocator, const ObjectIdResolver& resolver);\n    // Override which produces a FatalError if any object is used.\n    WireResult Deserialize(DeserializeBuffer* deserializeBuffer, DeserializeAllocator* allocator);\n\n    ObjectId selfId;\n\n    WGPUCommandEncoder self;\n    WGPUBuffer buffer;\n    uint64_t bufferOffset;\n    uint8_t const * data;\n    uint64_t size;\n};\n\n    struct CommandEncoderWriteTimestampCmd {\n    size_t GetRequiredSize() const;\n\n    WireResult Serialize(size_t commandSize, SerializeBuffer* serializeBuffer, const ObjectIdProvider& objectIdProvider) const;\n    // Override which produces a FatalError if any object is used.\n    WireResult Serialize(size_t commandSize, SerializeBuffer* serializeBuffer) const;\n\n    WireResult Deserialize(DeserializeBuffer* deserializeBuffer, DeserializeAllocator* allocator, const ObjectIdResolver& resolver);\n    // Override which produces a FatalError if any object is used.\n    WireResult Deserialize(DeserializeBuffer* deserializeBuffer, DeserializeAllocator* allocator);\n\n    ObjectId selfId;\n\n    WGPUCommandEncoder self;\n    WGPUQuerySet querySet;\n    uint32_t queryIndex;\n};\n\n    struct ComputePassEncoderDispatchWorkgroupsCmd {\n    size_t GetRequiredSize() const;\n\n    WireResult Serialize(size_t commandSize, SerializeBuffer* serializeBuffer, const ObjectIdProvider& objectIdProvider) const;\n    // Override which produces a FatalError if any object is used.\n    WireResult Serialize(size_t commandSize, SerializeBuffer* serializeBuffer) const;\n\n    WireResult Deserialize(DeserializeBuffer* deserializeBuffer, DeserializeAllocator* allocator, const ObjectIdResolver& resolver);\n    // Override which produces a FatalError if any object is used.\n    WireResult Deserialize(DeserializeBuffer* deserializeBuffer, DeserializeAllocator* allocator);\n\n    ObjectId selfId;\n\n    WGPUComputePassEncoder self;\n    uint32_t workgroupCountX;\n    uint32_t workgroupCountY;\n    uint32_t workgroupCountZ;\n};\n\n    struct ComputePassEncoderDispatchWorkgroupsIndirectCmd {\n    size_t GetRequiredSize() const;\n\n    WireResult Serialize(size_t commandSize, SerializeBuffer* serializeBuffer, const ObjectIdProvider& objectIdProvider) const;\n    // Override which produces a FatalError if any object is used.\n    WireResult Serialize(size_t commandSize, SerializeBuffer* serializeBuffer) const;\n\n    WireResult Deserialize(DeserializeBuffer* deserializeBuffer, DeserializeAllocator* allocator, const ObjectIdResolver& resolver);\n    // Override which produces a FatalError if any object is used.\n    WireResult Deserialize(DeserializeBuffer* deserializeBuffer, DeserializeAllocator* allocator);\n\n    ObjectId selfId;\n\n    WGPUComputePassEncoder self;\n    WGPUBuffer indirectBuffer;\n    uint64_t indirectOffset;\n};\n\n    struct ComputePassEncoderEndCmd {\n    size_t GetRequiredSize() const;\n\n    WireResult Serialize(size_t commandSize, SerializeBuffer* serializeBuffer, const ObjectIdProvider& objectIdProvider) const;\n    // Override which produces a FatalError if any object is used.\n    WireResult Serialize(size_t commandSize, SerializeBuffer* serializeBuffer) const;\n\n    WireResult Deserialize(DeserializeBuffer* deserializeBuffer, DeserializeAllocator* allocator, const ObjectIdResolver& resolver);\n    // Override which produces a FatalError if any object is used.\n    WireResult Deserialize(DeserializeBuffer* deserializeBuffer, DeserializeAllocator* allocator);\n\n    ObjectId selfId;\n\n    WGPUComputePassEncoder self;\n};\n\n    struct ComputePassEncoderInsertDebugMarkerCmd {\n    size_t GetRequiredSize() const;\n\n    WireResult Serialize(size_t commandSize, SerializeBuffer* serializeBuffer, const ObjectIdProvider& objectIdProvider) const;\n    // Override which produces a FatalError if any object is used.\n    WireResult Serialize(size_t commandSize, SerializeBuffer* serializeBuffer) const;\n\n    WireResult Deserialize(DeserializeBuffer* deserializeBuffer, DeserializeAllocator* allocator, const ObjectIdResolver& resolver);\n    // Override which produces a FatalError if any object is used.\n    WireResult Deserialize(DeserializeBuffer* deserializeBuffer, DeserializeAllocator* allocator);\n\n    ObjectId selfId;\n\n    WGPUComputePassEncoder self;\n    char const * markerLabel;\n};\n\n    struct ComputePassEncoderPopDebugGroupCmd {\n    size_t GetRequiredSize() const;\n\n    WireResult Serialize(size_t commandSize, SerializeBuffer* serializeBuffer, const ObjectIdProvider& objectIdProvider) const;\n    // Override which produces a FatalError if any object is used.\n    WireResult Serialize(size_t commandSize, SerializeBuffer* serializeBuffer) const;\n\n    WireResult Deserialize(DeserializeBuffer* deserializeBuffer, DeserializeAllocator* allocator, const ObjectIdResolver& resolver);\n    // Override which produces a FatalError if any object is used.\n    WireResult Deserialize(DeserializeBuffer* deserializeBuffer, DeserializeAllocator* allocator);\n\n    ObjectId selfId;\n\n    WGPUComputePassEncoder self;\n};\n\n    struct ComputePassEncoderPushDebugGroupCmd {\n    size_t GetRequiredSize() const;\n\n    WireResult Serialize(size_t commandSize, SerializeBuffer* serializeBuffer, const ObjectIdProvider& objectIdProvider) const;\n    // Override which produces a FatalError if any object is used.\n    WireResult Serialize(size_t commandSize, SerializeBuffer* serializeBuffer) const;\n\n    WireResult Deserialize(DeserializeBuffer* deserializeBuffer, DeserializeAllocator* allocator, const ObjectIdResolver& resolver);\n    // Override which produces a FatalError if any object is used.\n    WireResult Deserialize(DeserializeBuffer* deserializeBuffer, DeserializeAllocator* allocator);\n\n    ObjectId selfId;\n\n    WGPUComputePassEncoder self;\n    char const * groupLabel;\n};\n\n    struct ComputePassEncoderSetBindGroupCmd {\n    size_t GetRequiredSize() const;\n\n    WireResult Serialize(size_t commandSize, SerializeBuffer* serializeBuffer, const ObjectIdProvider& objectIdProvider) const;\n    // Override which produces a FatalError if any object is used.\n    WireResult Serialize(size_t commandSize, SerializeBuffer* serializeBuffer) const;\n\n    WireResult Deserialize(DeserializeBuffer* deserializeBuffer, DeserializeAllocator* allocator, const ObjectIdResolver& resolver);\n    // Override which produces a FatalError if any object is used.\n    WireResult Deserialize(DeserializeBuffer* deserializeBuffer, DeserializeAllocator* allocator);\n\n    ObjectId selfId;\n\n    WGPUComputePassEncoder self;\n    uint32_t groupIndex;\n    WGPUBindGroup group;\n    size_t dynamicOffsetCount;\n    uint32_t const * dynamicOffsets;\n};\n\n    struct ComputePassEncoderSetLabelCmd {\n    size_t GetRequiredSize() const;\n\n    WireResult Serialize(size_t commandSize, SerializeBuffer* serializeBuffer, const ObjectIdProvider& objectIdProvider) const;\n    // Override which produces a FatalError if any object is used.\n    WireResult Serialize(size_t commandSize, SerializeBuffer* serializeBuffer) const;\n\n    WireResult Deserialize(DeserializeBuffer* deserializeBuffer, DeserializeAllocator* allocator, const ObjectIdResolver& resolver);\n    // Override which produces a FatalError if any object is used.\n    WireResult Deserialize(DeserializeBuffer* deserializeBuffer, DeserializeAllocator* allocator);\n\n    ObjectId selfId;\n\n    WGPUComputePassEncoder self;\n    char const * label;\n};\n\n    struct ComputePassEncoderSetPipelineCmd {\n    size_t GetRequiredSize() const;\n\n    WireResult Serialize(size_t commandSize, SerializeBuffer* serializeBuffer, const ObjectIdProvider& objectIdProvider) const;\n    // Override which produces a FatalError if any object is used.\n    WireResult Serialize(size_t commandSize, SerializeBuffer* serializeBuffer) const;\n\n    WireResult Deserialize(DeserializeBuffer* deserializeBuffer, DeserializeAllocator* allocator, const ObjectIdResolver& resolver);\n    // Override which produces a FatalError if any object is used.\n    WireResult Deserialize(DeserializeBuffer* deserializeBuffer, DeserializeAllocator* allocator);\n\n    ObjectId selfId;\n\n    WGPUComputePassEncoder self;\n    WGPUComputePipeline pipeline;\n};\n\n    struct ComputePassEncoderWriteTimestampCmd {\n    size_t GetRequiredSize() const;\n\n    WireResult Serialize(size_t commandSize, SerializeBuffer* serializeBuffer, const ObjectIdProvider& objectIdProvider) const;\n    // Override which produces a FatalError if any object is used.\n    WireResult Serialize(size_t commandSize, SerializeBuffer* serializeBuffer) const;\n\n    WireResult Deserialize(DeserializeBuffer* deserializeBuffer, DeserializeAllocator* allocator, const ObjectIdResolver& resolver);\n    // Override which produces a FatalError if any object is used.\n    WireResult Deserialize(DeserializeBuffer* deserializeBuffer, DeserializeAllocator* allocator);\n\n    ObjectId selfId;\n\n    WGPUComputePassEncoder self;\n    WGPUQuerySet querySet;\n    uint32_t queryIndex;\n};\n\n    struct ComputePipelineGetBindGroupLayoutCmd {\n    size_t GetRequiredSize() const;\n\n    WireResult Serialize(size_t commandSize, SerializeBuffer* serializeBuffer, const ObjectIdProvider& objectIdProvider) const;\n    // Override which produces a FatalError if any object is used.\n    WireResult Serialize(size_t commandSize, SerializeBuffer* serializeBuffer) const;\n\n    WireResult Deserialize(DeserializeBuffer* deserializeBuffer, DeserializeAllocator* allocator, const ObjectIdResolver& resolver);\n    // Override which produces a FatalError if any object is used.\n    WireResult Deserialize(DeserializeBuffer* deserializeBuffer, DeserializeAllocator* allocator);\n\n    ObjectId selfId;\n\n    WGPUComputePipeline self;\n    uint32_t groupIndex;\n    ObjectHandle result;\n};\n\n    struct ComputePipelineSetLabelCmd {\n    size_t GetRequiredSize() const;\n\n    WireResult Serialize(size_t commandSize, SerializeBuffer* serializeBuffer, const ObjectIdProvider& objectIdProvider) const;\n    // Override which produces a FatalError if any object is used.\n    WireResult Serialize(size_t commandSize, SerializeBuffer* serializeBuffer) const;\n\n    WireResult Deserialize(DeserializeBuffer* deserializeBuffer, DeserializeAllocator* allocator, const ObjectIdResolver& resolver);\n    // Override which produces a FatalError if any object is used.\n    WireResult Deserialize(DeserializeBuffer* deserializeBuffer, DeserializeAllocator* allocator);\n\n    ObjectId selfId;\n\n    WGPUComputePipeline self;\n    char const * label;\n};\n\n    struct DestroyObjectCmd {\n    size_t GetRequiredSize() const;\n\n    WireResult Serialize(size_t commandSize, SerializeBuffer* serializeBuffer, const ObjectIdProvider& objectIdProvider) const;\n    // Override which produces a FatalError if any object is used.\n    WireResult Serialize(size_t commandSize, SerializeBuffer* serializeBuffer) const;\n\n    WireResult Deserialize(DeserializeBuffer* deserializeBuffer, DeserializeAllocator* allocator, const ObjectIdResolver& resolver);\n    // Override which produces a FatalError if any object is used.\n    WireResult Deserialize(DeserializeBuffer* deserializeBuffer, DeserializeAllocator* allocator);\n\n\n    ObjectType objectType;\n    ObjectId objectId;\n};\n\n    struct DeviceCreateBindGroupCmd {\n    size_t GetRequiredSize() const;\n\n    WireResult Serialize(size_t commandSize, SerializeBuffer* serializeBuffer, const ObjectIdProvider& objectIdProvider) const;\n    // Override which produces a FatalError if any object is used.\n    WireResult Serialize(size_t commandSize, SerializeBuffer* serializeBuffer) const;\n\n    WireResult Deserialize(DeserializeBuffer* deserializeBuffer, DeserializeAllocator* allocator, const ObjectIdResolver& resolver);\n    // Override which produces a FatalError if any object is used.\n    WireResult Deserialize(DeserializeBuffer* deserializeBuffer, DeserializeAllocator* allocator);\n\n    ObjectId selfId;\n\n    WGPUDevice self;\n    WGPUBindGroupDescriptor const * descriptor;\n    ObjectHandle result;\n};\n\n    struct DeviceCreateBindGroupLayoutCmd {\n    size_t GetRequiredSize() const;\n\n    WireResult Serialize(size_t commandSize, SerializeBuffer* serializeBuffer, const ObjectIdProvider& objectIdProvider) const;\n    // Override which produces a FatalError if any object is used.\n    WireResult Serialize(size_t commandSize, SerializeBuffer* serializeBuffer) const;\n\n    WireResult Deserialize(DeserializeBuffer* deserializeBuffer, DeserializeAllocator* allocator, const ObjectIdResolver& resolver);\n    // Override which produces a FatalError if any object is used.\n    WireResult Deserialize(DeserializeBuffer* deserializeBuffer, DeserializeAllocator* allocator);\n\n    ObjectId selfId;\n\n    WGPUDevice self;\n    WGPUBindGroupLayoutDescriptor const * descriptor;\n    ObjectHandle result;\n};\n\n    struct DeviceCreateBufferCmd {\n    size_t GetRequiredSize() const;\n\n    WireResult Serialize(size_t commandSize, SerializeBuffer* serializeBuffer, const ObjectIdProvider& objectIdProvider) const;\n    // Override which produces a FatalError if any object is used.\n    WireResult Serialize(size_t commandSize, SerializeBuffer* serializeBuffer) const;\n\n    WireResult Deserialize(DeserializeBuffer* deserializeBuffer, DeserializeAllocator* allocator, const ObjectIdResolver& resolver);\n    // Override which produces a FatalError if any object is used.\n    WireResult Deserialize(DeserializeBuffer* deserializeBuffer, DeserializeAllocator* allocator);\n\n\n    ObjectId deviceId;\n    WGPUBufferDescriptor const * descriptor;\n    ObjectHandle result;\n    uint64_t readHandleCreateInfoLength;\n    uint8_t const * readHandleCreateInfo;\n    uint64_t writeHandleCreateInfoLength;\n    uint8_t const * writeHandleCreateInfo;\n};\n\n    struct DeviceCreateCommandEncoderCmd {\n    size_t GetRequiredSize() const;\n\n    WireResult Serialize(size_t commandSize, SerializeBuffer* serializeBuffer, const ObjectIdProvider& objectIdProvider) const;\n    // Override which produces a FatalError if any object is used.\n    WireResult Serialize(size_t commandSize, SerializeBuffer* serializeBuffer) const;\n\n    WireResult Deserialize(DeserializeBuffer* deserializeBuffer, DeserializeAllocator* allocator, const ObjectIdResolver& resolver);\n    // Override which produces a FatalError if any object is used.\n    WireResult Deserialize(DeserializeBuffer* deserializeBuffer, DeserializeAllocator* allocator);\n\n    ObjectId selfId;\n\n    WGPUDevice self;\n    WGPUCommandEncoderDescriptor const * descriptor;\n    ObjectHandle result;\n};\n\n    struct DeviceCreateComputePipelineCmd {\n    size_t GetRequiredSize() const;\n\n    WireResult Serialize(size_t commandSize, SerializeBuffer* serializeBuffer, const ObjectIdProvider& objectIdProvider) const;\n    // Override which produces a FatalError if any object is used.\n    WireResult Serialize(size_t commandSize, SerializeBuffer* serializeBuffer) const;\n\n    WireResult Deserialize(DeserializeBuffer* deserializeBuffer, DeserializeAllocator* allocator, const ObjectIdResolver& resolver);\n    // Override which produces a FatalError if any object is used.\n    WireResult Deserialize(DeserializeBuffer* deserializeBuffer, DeserializeAllocator* allocator);\n\n    ObjectId selfId;\n\n    WGPUDevice self;\n    WGPUComputePipelineDescriptor const * descriptor;\n    ObjectHandle result;\n};\n\n    struct DeviceCreateComputePipelineAsyncCmd {\n    size_t GetRequiredSize() const;\n\n    WireResult Serialize(size_t commandSize, SerializeBuffer* serializeBuffer, const ObjectIdProvider& objectIdProvider) const;\n    // Override which produces a FatalError if any object is used.\n    WireResult Serialize(size_t commandSize, SerializeBuffer* serializeBuffer) const;\n\n    WireResult Deserialize(DeserializeBuffer* deserializeBuffer, DeserializeAllocator* allocator, const ObjectIdResolver& resolver);\n    // Override which produces a FatalError if any object is used.\n    WireResult Deserialize(DeserializeBuffer* deserializeBuffer, DeserializeAllocator* allocator);\n\n\n    ObjectId deviceId;\n    uint64_t requestSerial;\n    ObjectHandle pipelineObjectHandle;\n    WGPUComputePipelineDescriptor const * descriptor;\n};\n\n    struct DeviceCreateErrorBufferCmd {\n    size_t GetRequiredSize() const;\n\n    WireResult Serialize(size_t commandSize, SerializeBuffer* serializeBuffer, const ObjectIdProvider& objectIdProvider) const;\n    // Override which produces a FatalError if any object is used.\n    WireResult Serialize(size_t commandSize, SerializeBuffer* serializeBuffer) const;\n\n    WireResult Deserialize(DeserializeBuffer* deserializeBuffer, DeserializeAllocator* allocator, const ObjectIdResolver& resolver);\n    // Override which produces a FatalError if any object is used.\n    WireResult Deserialize(DeserializeBuffer* deserializeBuffer, DeserializeAllocator* allocator);\n\n    ObjectId selfId;\n\n    WGPUDevice self;\n    WGPUBufferDescriptor const * descriptor;\n    ObjectHandle result;\n};\n\n    struct DeviceCreateErrorExternalTextureCmd {\n    size_t GetRequiredSize() const;\n\n    WireResult Serialize(size_t commandSize, SerializeBuffer* serializeBuffer, const ObjectIdProvider& objectIdProvider) const;\n    // Override which produces a FatalError if any object is used.\n    WireResult Serialize(size_t commandSize, SerializeBuffer* serializeBuffer) const;\n\n    WireResult Deserialize(DeserializeBuffer* deserializeBuffer, DeserializeAllocator* allocator, const ObjectIdResolver& resolver);\n    // Override which produces a FatalError if any object is used.\n    WireResult Deserialize(DeserializeBuffer* deserializeBuffer, DeserializeAllocator* allocator);\n\n    ObjectId selfId;\n\n    WGPUDevice self;\n    ObjectHandle result;\n};\n\n    struct DeviceCreateErrorShaderModuleCmd {\n    size_t GetRequiredSize() const;\n\n    WireResult Serialize(size_t commandSize, SerializeBuffer* serializeBuffer, const ObjectIdProvider& objectIdProvider) const;\n    // Override which produces a FatalError if any object is used.\n    WireResult Serialize(size_t commandSize, SerializeBuffer* serializeBuffer) const;\n\n    WireResult Deserialize(DeserializeBuffer* deserializeBuffer, DeserializeAllocator* allocator, const ObjectIdResolver& resolver);\n    // Override which produces a FatalError if any object is used.\n    WireResult Deserialize(DeserializeBuffer* deserializeBuffer, DeserializeAllocator* allocator);\n\n    ObjectId selfId;\n\n    WGPUDevice self;\n    WGPUShaderModuleDescriptor const * descriptor;\n    char const * errorMessage;\n    ObjectHandle result;\n};\n\n    struct DeviceCreateErrorTextureCmd {\n    size_t GetRequiredSize() const;\n\n    WireResult Serialize(size_t commandSize, SerializeBuffer* serializeBuffer, const ObjectIdProvider& objectIdProvider) const;\n    // Override which produces a FatalError if any object is used.\n    WireResult Serialize(size_t commandSize, SerializeBuffer* serializeBuffer) const;\n\n    WireResult Deserialize(DeserializeBuffer* deserializeBuffer, DeserializeAllocator* allocator, const ObjectIdResolver& resolver);\n    // Override which produces a FatalError if any object is used.\n    WireResult Deserialize(DeserializeBuffer* deserializeBuffer, DeserializeAllocator* allocator);\n\n    ObjectId selfId;\n\n    WGPUDevice self;\n    WGPUTextureDescriptor const * descriptor;\n    ObjectHandle result;\n};\n\n    struct DeviceCreateExternalTextureCmd {\n    size_t GetRequiredSize() const;\n\n    WireResult Serialize(size_t commandSize, SerializeBuffer* serializeBuffer, const ObjectIdProvider& objectIdProvider) const;\n    // Override which produces a FatalError if any object is used.\n    WireResult Serialize(size_t commandSize, SerializeBuffer* serializeBuffer) const;\n\n    WireResult Deserialize(DeserializeBuffer* deserializeBuffer, DeserializeAllocator* allocator, const ObjectIdResolver& resolver);\n    // Override which produces a FatalError if any object is used.\n    WireResult Deserialize(DeserializeBuffer* deserializeBuffer, DeserializeAllocator* allocator);\n\n    ObjectId selfId;\n\n    WGPUDevice self;\n    WGPUExternalTextureDescriptor const * externalTextureDescriptor;\n    ObjectHandle result;\n};\n\n    struct DeviceCreatePipelineLayoutCmd {\n    size_t GetRequiredSize() const;\n\n    WireResult Serialize(size_t commandSize, SerializeBuffer* serializeBuffer, const ObjectIdProvider& objectIdProvider) const;\n    // Override which produces a FatalError if any object is used.\n    WireResult Serialize(size_t commandSize, SerializeBuffer* serializeBuffer) const;\n\n    WireResult Deserialize(DeserializeBuffer* deserializeBuffer, DeserializeAllocator* allocator, const ObjectIdResolver& resolver);\n    // Override which produces a FatalError if any object is used.\n    WireResult Deserialize(DeserializeBuffer* deserializeBuffer, DeserializeAllocator* allocator);\n\n    ObjectId selfId;\n\n    WGPUDevice self;\n    WGPUPipelineLayoutDescriptor const * descriptor;\n    ObjectHandle result;\n};\n\n    struct DeviceCreateQuerySetCmd {\n    size_t GetRequiredSize() const;\n\n    WireResult Serialize(size_t commandSize, SerializeBuffer* serializeBuffer, const ObjectIdProvider& objectIdProvider) const;\n    // Override which produces a FatalError if any object is used.\n    WireResult Serialize(size_t commandSize, SerializeBuffer* serializeBuffer) const;\n\n    WireResult Deserialize(DeserializeBuffer* deserializeBuffer, DeserializeAllocator* allocator, const ObjectIdResolver& resolver);\n    // Override which produces a FatalError if any object is used.\n    WireResult Deserialize(DeserializeBuffer* deserializeBuffer, DeserializeAllocator* allocator);\n\n    ObjectId selfId;\n\n    WGPUDevice self;\n    WGPUQuerySetDescriptor const * descriptor;\n    ObjectHandle result;\n};\n\n    struct DeviceCreateRenderBundleEncoderCmd {\n    size_t GetRequiredSize() const;\n\n    WireResult Serialize(size_t commandSize, SerializeBuffer* serializeBuffer, const ObjectIdProvider& objectIdProvider) const;\n    // Override which produces a FatalError if any object is used.\n    WireResult Serialize(size_t commandSize, SerializeBuffer* serializeBuffer) const;\n\n    WireResult Deserialize(DeserializeBuffer* deserializeBuffer, DeserializeAllocator* allocator, const ObjectIdResolver& resolver);\n    // Override which produces a FatalError if any object is used.\n    WireResult Deserialize(DeserializeBuffer* deserializeBuffer, DeserializeAllocator* allocator);\n\n    ObjectId selfId;\n\n    WGPUDevice self;\n    WGPURenderBundleEncoderDescriptor const * descriptor;\n    ObjectHandle result;\n};\n\n    struct DeviceCreateRenderPipelineCmd {\n    size_t GetRequiredSize() const;\n\n    WireResult Serialize(size_t commandSize, SerializeBuffer* serializeBuffer, const ObjectIdProvider& objectIdProvider) const;\n    // Override which produces a FatalError if any object is used.\n    WireResult Serialize(size_t commandSize, SerializeBuffer* serializeBuffer) const;\n\n    WireResult Deserialize(DeserializeBuffer* deserializeBuffer, DeserializeAllocator* allocator, const ObjectIdResolver& resolver);\n    // Override which produces a FatalError if any object is used.\n    WireResult Deserialize(DeserializeBuffer* deserializeBuffer, DeserializeAllocator* allocator);\n\n    ObjectId selfId;\n\n    WGPUDevice self;\n    WGPURenderPipelineDescriptor const * descriptor;\n    ObjectHandle result;\n};\n\n    struct DeviceCreateRenderPipelineAsyncCmd {\n    size_t GetRequiredSize() const;\n\n    WireResult Serialize(size_t commandSize, SerializeBuffer* serializeBuffer, const ObjectIdProvider& objectIdProvider) const;\n    // Override which produces a FatalError if any object is used.\n    WireResult Serialize(size_t commandSize, SerializeBuffer* serializeBuffer) const;\n\n    WireResult Deserialize(DeserializeBuffer* deserializeBuffer, DeserializeAllocator* allocator, const ObjectIdResolver& resolver);\n    // Override which produces a FatalError if any object is used.\n    WireResult Deserialize(DeserializeBuffer* deserializeBuffer, DeserializeAllocator* allocator);\n\n\n    ObjectId deviceId;\n    uint64_t requestSerial;\n    ObjectHandle pipelineObjectHandle;\n    WGPURenderPipelineDescriptor const * descriptor;\n};\n\n    struct DeviceCreateSamplerCmd {\n    size_t GetRequiredSize() const;\n\n    WireResult Serialize(size_t commandSize, SerializeBuffer* serializeBuffer, const ObjectIdProvider& objectIdProvider) const;\n    // Override which produces a FatalError if any object is used.\n    WireResult Serialize(size_t commandSize, SerializeBuffer* serializeBuffer) const;\n\n    WireResult Deserialize(DeserializeBuffer* deserializeBuffer, DeserializeAllocator* allocator, const ObjectIdResolver& resolver);\n    // Override which produces a FatalError if any object is used.\n    WireResult Deserialize(DeserializeBuffer* deserializeBuffer, DeserializeAllocator* allocator);\n\n    ObjectId selfId;\n\n    WGPUDevice self;\n    WGPUSamplerDescriptor const * descriptor;\n    ObjectHandle result;\n};\n\n    struct DeviceCreateShaderModuleCmd {\n    size_t GetRequiredSize() const;\n\n    WireResult Serialize(size_t commandSize, SerializeBuffer* serializeBuffer, const ObjectIdProvider& objectIdProvider) const;\n    // Override which produces a FatalError if any object is used.\n    WireResult Serialize(size_t commandSize, SerializeBuffer* serializeBuffer) const;\n\n    WireResult Deserialize(DeserializeBuffer* deserializeBuffer, DeserializeAllocator* allocator, const ObjectIdResolver& resolver);\n    // Override which produces a FatalError if any object is used.\n    WireResult Deserialize(DeserializeBuffer* deserializeBuffer, DeserializeAllocator* allocator);\n\n    ObjectId selfId;\n\n    WGPUDevice self;\n    WGPUShaderModuleDescriptor const * descriptor;\n    ObjectHandle result;\n};\n\n    struct DeviceCreateSwapChainCmd {\n    size_t GetRequiredSize() const;\n\n    WireResult Serialize(size_t commandSize, SerializeBuffer* serializeBuffer, const ObjectIdProvider& objectIdProvider) const;\n    // Override which produces a FatalError if any object is used.\n    WireResult Serialize(size_t commandSize, SerializeBuffer* serializeBuffer) const;\n\n    WireResult Deserialize(DeserializeBuffer* deserializeBuffer, DeserializeAllocator* allocator, const ObjectIdResolver& resolver);\n    // Override which produces a FatalError if any object is used.\n    WireResult Deserialize(DeserializeBuffer* deserializeBuffer, DeserializeAllocator* allocator);\n\n    ObjectId selfId;\n\n    WGPUDevice self;\n    WGPUSurface surface;\n    WGPUSwapChainDescriptor const * descriptor;\n    ObjectHandle result;\n};\n\n    struct DeviceCreateTextureCmd {\n    size_t GetRequiredSize() const;\n\n    WireResult Serialize(size_t commandSize, SerializeBuffer* serializeBuffer, const ObjectIdProvider& objectIdProvider) const;\n    // Override which produces a FatalError if any object is used.\n    WireResult Serialize(size_t commandSize, SerializeBuffer* serializeBuffer) const;\n\n    WireResult Deserialize(DeserializeBuffer* deserializeBuffer, DeserializeAllocator* allocator, const ObjectIdResolver& resolver);\n    // Override which produces a FatalError if any object is used.\n    WireResult Deserialize(DeserializeBuffer* deserializeBuffer, DeserializeAllocator* allocator);\n\n    ObjectId selfId;\n\n    WGPUDevice self;\n    WGPUTextureDescriptor const * descriptor;\n    ObjectHandle result;\n};\n\n    struct DeviceDestroyCmd {\n    size_t GetRequiredSize() const;\n\n    WireResult Serialize(size_t commandSize, SerializeBuffer* serializeBuffer, const ObjectIdProvider& objectIdProvider) const;\n    // Override which produces a FatalError if any object is used.\n    WireResult Serialize(size_t commandSize, SerializeBuffer* serializeBuffer) const;\n\n    WireResult Deserialize(DeserializeBuffer* deserializeBuffer, DeserializeAllocator* allocator, const ObjectIdResolver& resolver);\n    // Override which produces a FatalError if any object is used.\n    WireResult Deserialize(DeserializeBuffer* deserializeBuffer, DeserializeAllocator* allocator);\n\n    ObjectId selfId;\n\n    WGPUDevice self;\n};\n\n    struct DeviceForceLossCmd {\n    size_t GetRequiredSize() const;\n\n    WireResult Serialize(size_t commandSize, SerializeBuffer* serializeBuffer, const ObjectIdProvider& objectIdProvider) const;\n    // Override which produces a FatalError if any object is used.\n    WireResult Serialize(size_t commandSize, SerializeBuffer* serializeBuffer) const;\n\n    WireResult Deserialize(DeserializeBuffer* deserializeBuffer, DeserializeAllocator* allocator, const ObjectIdResolver& resolver);\n    // Override which produces a FatalError if any object is used.\n    WireResult Deserialize(DeserializeBuffer* deserializeBuffer, DeserializeAllocator* allocator);\n\n    ObjectId selfId;\n\n    WGPUDevice self;\n    WGPUDeviceLostReason type;\n    char const * message;\n};\n\n    struct DeviceGetAdapterCmd {\n    size_t GetRequiredSize() const;\n\n    WireResult Serialize(size_t commandSize, SerializeBuffer* serializeBuffer, const ObjectIdProvider& objectIdProvider) const;\n    // Override which produces a FatalError if any object is used.\n    WireResult Serialize(size_t commandSize, SerializeBuffer* serializeBuffer) const;\n\n    WireResult Deserialize(DeserializeBuffer* deserializeBuffer, DeserializeAllocator* allocator, const ObjectIdResolver& resolver);\n    // Override which produces a FatalError if any object is used.\n    WireResult Deserialize(DeserializeBuffer* deserializeBuffer, DeserializeAllocator* allocator);\n\n    ObjectId selfId;\n\n    WGPUDevice self;\n    ObjectHandle result;\n};\n\n    struct DeviceGetQueueCmd {\n    size_t GetRequiredSize() const;\n\n    WireResult Serialize(size_t commandSize, SerializeBuffer* serializeBuffer, const ObjectIdProvider& objectIdProvider) const;\n    // Override which produces a FatalError if any object is used.\n    WireResult Serialize(size_t commandSize, SerializeBuffer* serializeBuffer) const;\n\n    WireResult Deserialize(DeserializeBuffer* deserializeBuffer, DeserializeAllocator* allocator, const ObjectIdResolver& resolver);\n    // Override which produces a FatalError if any object is used.\n    WireResult Deserialize(DeserializeBuffer* deserializeBuffer, DeserializeAllocator* allocator);\n\n    ObjectId selfId;\n\n    WGPUDevice self;\n    ObjectHandle result;\n};\n\n    struct DeviceInjectErrorCmd {\n    size_t GetRequiredSize() const;\n\n    WireResult Serialize(size_t commandSize, SerializeBuffer* serializeBuffer, const ObjectIdProvider& objectIdProvider) const;\n    // Override which produces a FatalError if any object is used.\n    WireResult Serialize(size_t commandSize, SerializeBuffer* serializeBuffer) const;\n\n    WireResult Deserialize(DeserializeBuffer* deserializeBuffer, DeserializeAllocator* allocator, const ObjectIdResolver& resolver);\n    // Override which produces a FatalError if any object is used.\n    WireResult Deserialize(DeserializeBuffer* deserializeBuffer, DeserializeAllocator* allocator);\n\n    ObjectId selfId;\n\n    WGPUDevice self;\n    WGPUErrorType type;\n    char const * message;\n};\n\n    struct DevicePopErrorScopeCmd {\n    size_t GetRequiredSize() const;\n\n    WireResult Serialize(size_t commandSize, SerializeBuffer* serializeBuffer, const ObjectIdProvider& objectIdProvider) const;\n    // Override which produces a FatalError if any object is used.\n    WireResult Serialize(size_t commandSize, SerializeBuffer* serializeBuffer) const;\n\n    WireResult Deserialize(DeserializeBuffer* deserializeBuffer, DeserializeAllocator* allocator, const ObjectIdResolver& resolver);\n    // Override which produces a FatalError if any object is used.\n    WireResult Deserialize(DeserializeBuffer* deserializeBuffer, DeserializeAllocator* allocator);\n\n\n    ObjectId deviceId;\n    uint64_t requestSerial;\n};\n\n    struct DevicePushErrorScopeCmd {\n    size_t GetRequiredSize() const;\n\n    WireResult Serialize(size_t commandSize, SerializeBuffer* serializeBuffer, const ObjectIdProvider& objectIdProvider) const;\n    // Override which produces a FatalError if any object is used.\n    WireResult Serialize(size_t commandSize, SerializeBuffer* serializeBuffer) const;\n\n    WireResult Deserialize(DeserializeBuffer* deserializeBuffer, DeserializeAllocator* allocator, const ObjectIdResolver& resolver);\n    // Override which produces a FatalError if any object is used.\n    WireResult Deserialize(DeserializeBuffer* deserializeBuffer, DeserializeAllocator* allocator);\n\n    ObjectId selfId;\n\n    WGPUDevice self;\n    WGPUErrorFilter filter;\n};\n\n    struct DeviceSetLabelCmd {\n    size_t GetRequiredSize() const;\n\n    WireResult Serialize(size_t commandSize, SerializeBuffer* serializeBuffer, const ObjectIdProvider& objectIdProvider) const;\n    // Override which produces a FatalError if any object is used.\n    WireResult Serialize(size_t commandSize, SerializeBuffer* serializeBuffer) const;\n\n    WireResult Deserialize(DeserializeBuffer* deserializeBuffer, DeserializeAllocator* allocator, const ObjectIdResolver& resolver);\n    // Override which produces a FatalError if any object is used.\n    WireResult Deserialize(DeserializeBuffer* deserializeBuffer, DeserializeAllocator* allocator);\n\n    ObjectId selfId;\n\n    WGPUDevice self;\n    char const * label;\n};\n\n    struct DeviceTickCmd {\n    size_t GetRequiredSize() const;\n\n    WireResult Serialize(size_t commandSize, SerializeBuffer* serializeBuffer, const ObjectIdProvider& objectIdProvider) const;\n    // Override which produces a FatalError if any object is used.\n    WireResult Serialize(size_t commandSize, SerializeBuffer* serializeBuffer) const;\n\n    WireResult Deserialize(DeserializeBuffer* deserializeBuffer, DeserializeAllocator* allocator, const ObjectIdResolver& resolver);\n    // Override which produces a FatalError if any object is used.\n    WireResult Deserialize(DeserializeBuffer* deserializeBuffer, DeserializeAllocator* allocator);\n\n    ObjectId selfId;\n\n    WGPUDevice self;\n};\n\n    struct DeviceValidateTextureDescriptorCmd {\n    size_t GetRequiredSize() const;\n\n    WireResult Serialize(size_t commandSize, SerializeBuffer* serializeBuffer, const ObjectIdProvider& objectIdProvider) const;\n    // Override which produces a FatalError if any object is used.\n    WireResult Serialize(size_t commandSize, SerializeBuffer* serializeBuffer) const;\n\n    WireResult Deserialize(DeserializeBuffer* deserializeBuffer, DeserializeAllocator* allocator, const ObjectIdResolver& resolver);\n    // Override which produces a FatalError if any object is used.\n    WireResult Deserialize(DeserializeBuffer* deserializeBuffer, DeserializeAllocator* allocator);\n\n    ObjectId selfId;\n\n    WGPUDevice self;\n    WGPUTextureDescriptor const * descriptor;\n};\n\n    struct ExternalTextureDestroyCmd {\n    size_t GetRequiredSize() const;\n\n    WireResult Serialize(size_t commandSize, SerializeBuffer* serializeBuffer, const ObjectIdProvider& objectIdProvider) const;\n    // Override which produces a FatalError if any object is used.\n    WireResult Serialize(size_t commandSize, SerializeBuffer* serializeBuffer) const;\n\n    WireResult Deserialize(DeserializeBuffer* deserializeBuffer, DeserializeAllocator* allocator, const ObjectIdResolver& resolver);\n    // Override which produces a FatalError if any object is used.\n    WireResult Deserialize(DeserializeBuffer* deserializeBuffer, DeserializeAllocator* allocator);\n\n    ObjectId selfId;\n\n    WGPUExternalTexture self;\n};\n\n    struct ExternalTextureExpireCmd {\n    size_t GetRequiredSize() const;\n\n    WireResult Serialize(size_t commandSize, SerializeBuffer* serializeBuffer, const ObjectIdProvider& objectIdProvider) const;\n    // Override which produces a FatalError if any object is used.\n    WireResult Serialize(size_t commandSize, SerializeBuffer* serializeBuffer) const;\n\n    WireResult Deserialize(DeserializeBuffer* deserializeBuffer, DeserializeAllocator* allocator, const ObjectIdResolver& resolver);\n    // Override which produces a FatalError if any object is used.\n    WireResult Deserialize(DeserializeBuffer* deserializeBuffer, DeserializeAllocator* allocator);\n\n    ObjectId selfId;\n\n    WGPUExternalTexture self;\n};\n\n    struct ExternalTextureRefreshCmd {\n    size_t GetRequiredSize() const;\n\n    WireResult Serialize(size_t commandSize, SerializeBuffer* serializeBuffer, const ObjectIdProvider& objectIdProvider) const;\n    // Override which produces a FatalError if any object is used.\n    WireResult Serialize(size_t commandSize, SerializeBuffer* serializeBuffer) const;\n\n    WireResult Deserialize(DeserializeBuffer* deserializeBuffer, DeserializeAllocator* allocator, const ObjectIdResolver& resolver);\n    // Override which produces a FatalError if any object is used.\n    WireResult Deserialize(DeserializeBuffer* deserializeBuffer, DeserializeAllocator* allocator);\n\n    ObjectId selfId;\n\n    WGPUExternalTexture self;\n};\n\n    struct ExternalTextureSetLabelCmd {\n    size_t GetRequiredSize() const;\n\n    WireResult Serialize(size_t commandSize, SerializeBuffer* serializeBuffer, const ObjectIdProvider& objectIdProvider) const;\n    // Override which produces a FatalError if any object is used.\n    WireResult Serialize(size_t commandSize, SerializeBuffer* serializeBuffer) const;\n\n    WireResult Deserialize(DeserializeBuffer* deserializeBuffer, DeserializeAllocator* allocator, const ObjectIdResolver& resolver);\n    // Override which produces a FatalError if any object is used.\n    WireResult Deserialize(DeserializeBuffer* deserializeBuffer, DeserializeAllocator* allocator);\n\n    ObjectId selfId;\n\n    WGPUExternalTexture self;\n    char const * label;\n};\n\n    struct InstanceCreateSurfaceCmd {\n    size_t GetRequiredSize() const;\n\n    WireResult Serialize(size_t commandSize, SerializeBuffer* serializeBuffer, const ObjectIdProvider& objectIdProvider) const;\n    // Override which produces a FatalError if any object is used.\n    WireResult Serialize(size_t commandSize, SerializeBuffer* serializeBuffer) const;\n\n    WireResult Deserialize(DeserializeBuffer* deserializeBuffer, DeserializeAllocator* allocator, const ObjectIdResolver& resolver);\n    // Override which produces a FatalError if any object is used.\n    WireResult Deserialize(DeserializeBuffer* deserializeBuffer, DeserializeAllocator* allocator);\n\n    ObjectId selfId;\n\n    WGPUInstance self;\n    WGPUSurfaceDescriptor const * descriptor;\n    ObjectHandle result;\n};\n\n    struct InstanceProcessEventsCmd {\n    size_t GetRequiredSize() const;\n\n    WireResult Serialize(size_t commandSize, SerializeBuffer* serializeBuffer, const ObjectIdProvider& objectIdProvider) const;\n    // Override which produces a FatalError if any object is used.\n    WireResult Serialize(size_t commandSize, SerializeBuffer* serializeBuffer) const;\n\n    WireResult Deserialize(DeserializeBuffer* deserializeBuffer, DeserializeAllocator* allocator, const ObjectIdResolver& resolver);\n    // Override which produces a FatalError if any object is used.\n    WireResult Deserialize(DeserializeBuffer* deserializeBuffer, DeserializeAllocator* allocator);\n\n    ObjectId selfId;\n\n    WGPUInstance self;\n};\n\n    struct InstanceRequestAdapterCmd {\n    size_t GetRequiredSize() const;\n\n    WireResult Serialize(size_t commandSize, SerializeBuffer* serializeBuffer, const ObjectIdProvider& objectIdProvider) const;\n    // Override which produces a FatalError if any object is used.\n    WireResult Serialize(size_t commandSize, SerializeBuffer* serializeBuffer) const;\n\n    WireResult Deserialize(DeserializeBuffer* deserializeBuffer, DeserializeAllocator* allocator, const ObjectIdResolver& resolver);\n    // Override which produces a FatalError if any object is used.\n    WireResult Deserialize(DeserializeBuffer* deserializeBuffer, DeserializeAllocator* allocator);\n\n\n    ObjectId instanceId;\n    uint64_t requestSerial;\n    ObjectHandle adapterObjectHandle;\n    WGPURequestAdapterOptions const * options;\n};\n\n    struct PipelineLayoutSetLabelCmd {\n    size_t GetRequiredSize() const;\n\n    WireResult Serialize(size_t commandSize, SerializeBuffer* serializeBuffer, const ObjectIdProvider& objectIdProvider) const;\n    // Override which produces a FatalError if any object is used.\n    WireResult Serialize(size_t commandSize, SerializeBuffer* serializeBuffer) const;\n\n    WireResult Deserialize(DeserializeBuffer* deserializeBuffer, DeserializeAllocator* allocator, const ObjectIdResolver& resolver);\n    // Override which produces a FatalError if any object is used.\n    WireResult Deserialize(DeserializeBuffer* deserializeBuffer, DeserializeAllocator* allocator);\n\n    ObjectId selfId;\n\n    WGPUPipelineLayout self;\n    char const * label;\n};\n\n    struct QuerySetDestroyCmd {\n    size_t GetRequiredSize() const;\n\n    WireResult Serialize(size_t commandSize, SerializeBuffer* serializeBuffer, const ObjectIdProvider& objectIdProvider) const;\n    // Override which produces a FatalError if any object is used.\n    WireResult Serialize(size_t commandSize, SerializeBuffer* serializeBuffer) const;\n\n    WireResult Deserialize(DeserializeBuffer* deserializeBuffer, DeserializeAllocator* allocator, const ObjectIdResolver& resolver);\n    // Override which produces a FatalError if any object is used.\n    WireResult Deserialize(DeserializeBuffer* deserializeBuffer, DeserializeAllocator* allocator);\n\n    ObjectId selfId;\n\n    WGPUQuerySet self;\n};\n\n    struct QuerySetSetLabelCmd {\n    size_t GetRequiredSize() const;\n\n    WireResult Serialize(size_t commandSize, SerializeBuffer* serializeBuffer, const ObjectIdProvider& objectIdProvider) const;\n    // Override which produces a FatalError if any object is used.\n    WireResult Serialize(size_t commandSize, SerializeBuffer* serializeBuffer) const;\n\n    WireResult Deserialize(DeserializeBuffer* deserializeBuffer, DeserializeAllocator* allocator, const ObjectIdResolver& resolver);\n    // Override which produces a FatalError if any object is used.\n    WireResult Deserialize(DeserializeBuffer* deserializeBuffer, DeserializeAllocator* allocator);\n\n    ObjectId selfId;\n\n    WGPUQuerySet self;\n    char const * label;\n};\n\n    struct QueueCopyExternalTextureForBrowserCmd {\n    size_t GetRequiredSize() const;\n\n    WireResult Serialize(size_t commandSize, SerializeBuffer* serializeBuffer, const ObjectIdProvider& objectIdProvider) const;\n    // Override which produces a FatalError if any object is used.\n    WireResult Serialize(size_t commandSize, SerializeBuffer* serializeBuffer) const;\n\n    WireResult Deserialize(DeserializeBuffer* deserializeBuffer, DeserializeAllocator* allocator, const ObjectIdResolver& resolver);\n    // Override which produces a FatalError if any object is used.\n    WireResult Deserialize(DeserializeBuffer* deserializeBuffer, DeserializeAllocator* allocator);\n\n    ObjectId selfId;\n\n    WGPUQueue self;\n    WGPUImageCopyExternalTexture const * source;\n    WGPUImageCopyTexture const * destination;\n    WGPUExtent3D const * copySize;\n    WGPUCopyTextureForBrowserOptions const * options;\n};\n\n    struct QueueCopyTextureForBrowserCmd {\n    size_t GetRequiredSize() const;\n\n    WireResult Serialize(size_t commandSize, SerializeBuffer* serializeBuffer, const ObjectIdProvider& objectIdProvider) const;\n    // Override which produces a FatalError if any object is used.\n    WireResult Serialize(size_t commandSize, SerializeBuffer* serializeBuffer) const;\n\n    WireResult Deserialize(DeserializeBuffer* deserializeBuffer, DeserializeAllocator* allocator, const ObjectIdResolver& resolver);\n    // Override which produces a FatalError if any object is used.\n    WireResult Deserialize(DeserializeBuffer* deserializeBuffer, DeserializeAllocator* allocator);\n\n    ObjectId selfId;\n\n    WGPUQueue self;\n    WGPUImageCopyTexture const * source;\n    WGPUImageCopyTexture const * destination;\n    WGPUExtent3D const * copySize;\n    WGPUCopyTextureForBrowserOptions const * options;\n};\n\n    struct QueueOnSubmittedWorkDoneCmd {\n    size_t GetRequiredSize() const;\n\n    WireResult Serialize(size_t commandSize, SerializeBuffer* serializeBuffer, const ObjectIdProvider& objectIdProvider) const;\n    // Override which produces a FatalError if any object is used.\n    WireResult Serialize(size_t commandSize, SerializeBuffer* serializeBuffer) const;\n\n    WireResult Deserialize(DeserializeBuffer* deserializeBuffer, DeserializeAllocator* allocator, const ObjectIdResolver& resolver);\n    // Override which produces a FatalError if any object is used.\n    WireResult Deserialize(DeserializeBuffer* deserializeBuffer, DeserializeAllocator* allocator);\n\n\n    ObjectId queueId;\n    uint64_t signalValue;\n    uint64_t requestSerial;\n};\n\n    struct QueueSetLabelCmd {\n    size_t GetRequiredSize() const;\n\n    WireResult Serialize(size_t commandSize, SerializeBuffer* serializeBuffer, const ObjectIdProvider& objectIdProvider) const;\n    // Override which produces a FatalError if any object is used.\n    WireResult Serialize(size_t commandSize, SerializeBuffer* serializeBuffer) const;\n\n    WireResult Deserialize(DeserializeBuffer* deserializeBuffer, DeserializeAllocator* allocator, const ObjectIdResolver& resolver);\n    // Override which produces a FatalError if any object is used.\n    WireResult Deserialize(DeserializeBuffer* deserializeBuffer, DeserializeAllocator* allocator);\n\n    ObjectId selfId;\n\n    WGPUQueue self;\n    char const * label;\n};\n\n    struct QueueSubmitCmd {\n    size_t GetRequiredSize() const;\n\n    WireResult Serialize(size_t commandSize, SerializeBuffer* serializeBuffer, const ObjectIdProvider& objectIdProvider) const;\n    // Override which produces a FatalError if any object is used.\n    WireResult Serialize(size_t commandSize, SerializeBuffer* serializeBuffer) const;\n\n    WireResult Deserialize(DeserializeBuffer* deserializeBuffer, DeserializeAllocator* allocator, const ObjectIdResolver& resolver);\n    // Override which produces a FatalError if any object is used.\n    WireResult Deserialize(DeserializeBuffer* deserializeBuffer, DeserializeAllocator* allocator);\n\n    ObjectId selfId;\n\n    WGPUQueue self;\n    size_t commandCount;\n    WGPUCommandBuffer const * commands;\n};\n\n    struct QueueWriteBufferCmd {\n    size_t GetRequiredSize() const;\n\n    WireResult Serialize(size_t commandSize, SerializeBuffer* serializeBuffer, const ObjectIdProvider& objectIdProvider) const;\n    // Override which produces a FatalError if any object is used.\n    WireResult Serialize(size_t commandSize, SerializeBuffer* serializeBuffer) const;\n\n    WireResult Deserialize(DeserializeBuffer* deserializeBuffer, DeserializeAllocator* allocator, const ObjectIdResolver& resolver);\n    // Override which produces a FatalError if any object is used.\n    WireResult Deserialize(DeserializeBuffer* deserializeBuffer, DeserializeAllocator* allocator);\n\n\n    ObjectId queueId;\n    ObjectId bufferId;\n    uint64_t bufferOffset;\n    uint8_t const * data;\n    uint64_t size;\n};\n\n    struct QueueWriteTextureCmd {\n    size_t GetRequiredSize() const;\n\n    WireResult Serialize(size_t commandSize, SerializeBuffer* serializeBuffer, const ObjectIdProvider& objectIdProvider) const;\n    // Override which produces a FatalError if any object is used.\n    WireResult Serialize(size_t commandSize, SerializeBuffer* serializeBuffer) const;\n\n    WireResult Deserialize(DeserializeBuffer* deserializeBuffer, DeserializeAllocator* allocator, const ObjectIdResolver& resolver);\n    // Override which produces a FatalError if any object is used.\n    WireResult Deserialize(DeserializeBuffer* deserializeBuffer, DeserializeAllocator* allocator);\n\n\n    ObjectId queueId;\n    WGPUImageCopyTexture const * destination;\n    uint8_t const * data;\n    uint64_t dataSize;\n    WGPUTextureDataLayout const * dataLayout;\n    WGPUExtent3D const * writeSize;\n};\n\n    struct RenderBundleEncoderDrawCmd {\n    size_t GetRequiredSize() const;\n\n    WireResult Serialize(size_t commandSize, SerializeBuffer* serializeBuffer, const ObjectIdProvider& objectIdProvider) const;\n    // Override which produces a FatalError if any object is used.\n    WireResult Serialize(size_t commandSize, SerializeBuffer* serializeBuffer) const;\n\n    WireResult Deserialize(DeserializeBuffer* deserializeBuffer, DeserializeAllocator* allocator, const ObjectIdResolver& resolver);\n    // Override which produces a FatalError if any object is used.\n    WireResult Deserialize(DeserializeBuffer* deserializeBuffer, DeserializeAllocator* allocator);\n\n    ObjectId selfId;\n\n    WGPURenderBundleEncoder self;\n    uint32_t vertexCount;\n    uint32_t instanceCount;\n    uint32_t firstVertex;\n    uint32_t firstInstance;\n};\n\n    struct RenderBundleEncoderDrawIndexedCmd {\n    size_t GetRequiredSize() const;\n\n    WireResult Serialize(size_t commandSize, SerializeBuffer* serializeBuffer, const ObjectIdProvider& objectIdProvider) const;\n    // Override which produces a FatalError if any object is used.\n    WireResult Serialize(size_t commandSize, SerializeBuffer* serializeBuffer) const;\n\n    WireResult Deserialize(DeserializeBuffer* deserializeBuffer, DeserializeAllocator* allocator, const ObjectIdResolver& resolver);\n    // Override which produces a FatalError if any object is used.\n    WireResult Deserialize(DeserializeBuffer* deserializeBuffer, DeserializeAllocator* allocator);\n\n    ObjectId selfId;\n\n    WGPURenderBundleEncoder self;\n    uint32_t indexCount;\n    uint32_t instanceCount;\n    uint32_t firstIndex;\n    int32_t baseVertex;\n    uint32_t firstInstance;\n};\n\n    struct RenderBundleEncoderDrawIndexedIndirectCmd {\n    size_t GetRequiredSize() const;\n\n    WireResult Serialize(size_t commandSize, SerializeBuffer* serializeBuffer, const ObjectIdProvider& objectIdProvider) const;\n    // Override which produces a FatalError if any object is used.\n    WireResult Serialize(size_t commandSize, SerializeBuffer* serializeBuffer) const;\n\n    WireResult Deserialize(DeserializeBuffer* deserializeBuffer, DeserializeAllocator* allocator, const ObjectIdResolver& resolver);\n    // Override which produces a FatalError if any object is used.\n    WireResult Deserialize(DeserializeBuffer* deserializeBuffer, DeserializeAllocator* allocator);\n\n    ObjectId selfId;\n\n    WGPURenderBundleEncoder self;\n    WGPUBuffer indirectBuffer;\n    uint64_t indirectOffset;\n};\n\n    struct RenderBundleEncoderDrawIndirectCmd {\n    size_t GetRequiredSize() const;\n\n    WireResult Serialize(size_t commandSize, SerializeBuffer* serializeBuffer, const ObjectIdProvider& objectIdProvider) const;\n    // Override which produces a FatalError if any object is used.\n    WireResult Serialize(size_t commandSize, SerializeBuffer* serializeBuffer) const;\n\n    WireResult Deserialize(DeserializeBuffer* deserializeBuffer, DeserializeAllocator* allocator, const ObjectIdResolver& resolver);\n    // Override which produces a FatalError if any object is used.\n    WireResult Deserialize(DeserializeBuffer* deserializeBuffer, DeserializeAllocator* allocator);\n\n    ObjectId selfId;\n\n    WGPURenderBundleEncoder self;\n    WGPUBuffer indirectBuffer;\n    uint64_t indirectOffset;\n};\n\n    struct RenderBundleEncoderFinishCmd {\n    size_t GetRequiredSize() const;\n\n    WireResult Serialize(size_t commandSize, SerializeBuffer* serializeBuffer, const ObjectIdProvider& objectIdProvider) const;\n    // Override which produces a FatalError if any object is used.\n    WireResult Serialize(size_t commandSize, SerializeBuffer* serializeBuffer) const;\n\n    WireResult Deserialize(DeserializeBuffer* deserializeBuffer, DeserializeAllocator* allocator, const ObjectIdResolver& resolver);\n    // Override which produces a FatalError if any object is used.\n    WireResult Deserialize(DeserializeBuffer* deserializeBuffer, DeserializeAllocator* allocator);\n\n    ObjectId selfId;\n\n    WGPURenderBundleEncoder self;\n    WGPURenderBundleDescriptor const * descriptor;\n    ObjectHandle result;\n};\n\n    struct RenderBundleEncoderInsertDebugMarkerCmd {\n    size_t GetRequiredSize() const;\n\n    WireResult Serialize(size_t commandSize, SerializeBuffer* serializeBuffer, const ObjectIdProvider& objectIdProvider) const;\n    // Override which produces a FatalError if any object is used.\n    WireResult Serialize(size_t commandSize, SerializeBuffer* serializeBuffer) const;\n\n    WireResult Deserialize(DeserializeBuffer* deserializeBuffer, DeserializeAllocator* allocator, const ObjectIdResolver& resolver);\n    // Override which produces a FatalError if any object is used.\n    WireResult Deserialize(DeserializeBuffer* deserializeBuffer, DeserializeAllocator* allocator);\n\n    ObjectId selfId;\n\n    WGPURenderBundleEncoder self;\n    char const * markerLabel;\n};\n\n    struct RenderBundleEncoderPopDebugGroupCmd {\n    size_t GetRequiredSize() const;\n\n    WireResult Serialize(size_t commandSize, SerializeBuffer* serializeBuffer, const ObjectIdProvider& objectIdProvider) const;\n    // Override which produces a FatalError if any object is used.\n    WireResult Serialize(size_t commandSize, SerializeBuffer* serializeBuffer) const;\n\n    WireResult Deserialize(DeserializeBuffer* deserializeBuffer, DeserializeAllocator* allocator, const ObjectIdResolver& resolver);\n    // Override which produces a FatalError if any object is used.\n    WireResult Deserialize(DeserializeBuffer* deserializeBuffer, DeserializeAllocator* allocator);\n\n    ObjectId selfId;\n\n    WGPURenderBundleEncoder self;\n};\n\n    struct RenderBundleEncoderPushDebugGroupCmd {\n    size_t GetRequiredSize() const;\n\n    WireResult Serialize(size_t commandSize, SerializeBuffer* serializeBuffer, const ObjectIdProvider& objectIdProvider) const;\n    // Override which produces a FatalError if any object is used.\n    WireResult Serialize(size_t commandSize, SerializeBuffer* serializeBuffer) const;\n\n    WireResult Deserialize(DeserializeBuffer* deserializeBuffer, DeserializeAllocator* allocator, const ObjectIdResolver& resolver);\n    // Override which produces a FatalError if any object is used.\n    WireResult Deserialize(DeserializeBuffer* deserializeBuffer, DeserializeAllocator* allocator);\n\n    ObjectId selfId;\n\n    WGPURenderBundleEncoder self;\n    char const * groupLabel;\n};\n\n    struct RenderBundleEncoderSetBindGroupCmd {\n    size_t GetRequiredSize() const;\n\n    WireResult Serialize(size_t commandSize, SerializeBuffer* serializeBuffer, const ObjectIdProvider& objectIdProvider) const;\n    // Override which produces a FatalError if any object is used.\n    WireResult Serialize(size_t commandSize, SerializeBuffer* serializeBuffer) const;\n\n    WireResult Deserialize(DeserializeBuffer* deserializeBuffer, DeserializeAllocator* allocator, const ObjectIdResolver& resolver);\n    // Override which produces a FatalError if any object is used.\n    WireResult Deserialize(DeserializeBuffer* deserializeBuffer, DeserializeAllocator* allocator);\n\n    ObjectId selfId;\n\n    WGPURenderBundleEncoder self;\n    uint32_t groupIndex;\n    WGPUBindGroup group;\n    size_t dynamicOffsetCount;\n    uint32_t const * dynamicOffsets;\n};\n\n    struct RenderBundleEncoderSetIndexBufferCmd {\n    size_t GetRequiredSize() const;\n\n    WireResult Serialize(size_t commandSize, SerializeBuffer* serializeBuffer, const ObjectIdProvider& objectIdProvider) const;\n    // Override which produces a FatalError if any object is used.\n    WireResult Serialize(size_t commandSize, SerializeBuffer* serializeBuffer) const;\n\n    WireResult Deserialize(DeserializeBuffer* deserializeBuffer, DeserializeAllocator* allocator, const ObjectIdResolver& resolver);\n    // Override which produces a FatalError if any object is used.\n    WireResult Deserialize(DeserializeBuffer* deserializeBuffer, DeserializeAllocator* allocator);\n\n    ObjectId selfId;\n\n    WGPURenderBundleEncoder self;\n    WGPUBuffer buffer;\n    WGPUIndexFormat format;\n    uint64_t offset;\n    uint64_t size;\n};\n\n    struct RenderBundleEncoderSetLabelCmd {\n    size_t GetRequiredSize() const;\n\n    WireResult Serialize(size_t commandSize, SerializeBuffer* serializeBuffer, const ObjectIdProvider& objectIdProvider) const;\n    // Override which produces a FatalError if any object is used.\n    WireResult Serialize(size_t commandSize, SerializeBuffer* serializeBuffer) const;\n\n    WireResult Deserialize(DeserializeBuffer* deserializeBuffer, DeserializeAllocator* allocator, const ObjectIdResolver& resolver);\n    // Override which produces a FatalError if any object is used.\n    WireResult Deserialize(DeserializeBuffer* deserializeBuffer, DeserializeAllocator* allocator);\n\n    ObjectId selfId;\n\n    WGPURenderBundleEncoder self;\n    char const * label;\n};\n\n    struct RenderBundleEncoderSetPipelineCmd {\n    size_t GetRequiredSize() const;\n\n    WireResult Serialize(size_t commandSize, SerializeBuffer* serializeBuffer, const ObjectIdProvider& objectIdProvider) const;\n    // Override which produces a FatalError if any object is used.\n    WireResult Serialize(size_t commandSize, SerializeBuffer* serializeBuffer) const;\n\n    WireResult Deserialize(DeserializeBuffer* deserializeBuffer, DeserializeAllocator* allocator, const ObjectIdResolver& resolver);\n    // Override which produces a FatalError if any object is used.\n    WireResult Deserialize(DeserializeBuffer* deserializeBuffer, DeserializeAllocator* allocator);\n\n    ObjectId selfId;\n\n    WGPURenderBundleEncoder self;\n    WGPURenderPipeline pipeline;\n};\n\n    struct RenderBundleEncoderSetVertexBufferCmd {\n    size_t GetRequiredSize() const;\n\n    WireResult Serialize(size_t commandSize, SerializeBuffer* serializeBuffer, const ObjectIdProvider& objectIdProvider) const;\n    // Override which produces a FatalError if any object is used.\n    WireResult Serialize(size_t commandSize, SerializeBuffer* serializeBuffer) const;\n\n    WireResult Deserialize(DeserializeBuffer* deserializeBuffer, DeserializeAllocator* allocator, const ObjectIdResolver& resolver);\n    // Override which produces a FatalError if any object is used.\n    WireResult Deserialize(DeserializeBuffer* deserializeBuffer, DeserializeAllocator* allocator);\n\n    ObjectId selfId;\n\n    WGPURenderBundleEncoder self;\n    uint32_t slot;\n    WGPUBuffer buffer;\n    uint64_t offset;\n    uint64_t size;\n};\n\n    struct RenderBundleSetLabelCmd {\n    size_t GetRequiredSize() const;\n\n    WireResult Serialize(size_t commandSize, SerializeBuffer* serializeBuffer, const ObjectIdProvider& objectIdProvider) const;\n    // Override which produces a FatalError if any object is used.\n    WireResult Serialize(size_t commandSize, SerializeBuffer* serializeBuffer) const;\n\n    WireResult Deserialize(DeserializeBuffer* deserializeBuffer, DeserializeAllocator* allocator, const ObjectIdResolver& resolver);\n    // Override which produces a FatalError if any object is used.\n    WireResult Deserialize(DeserializeBuffer* deserializeBuffer, DeserializeAllocator* allocator);\n\n    ObjectId selfId;\n\n    WGPURenderBundle self;\n    char const * label;\n};\n\n    struct RenderPassEncoderBeginOcclusionQueryCmd {\n    size_t GetRequiredSize() const;\n\n    WireResult Serialize(size_t commandSize, SerializeBuffer* serializeBuffer, const ObjectIdProvider& objectIdProvider) const;\n    // Override which produces a FatalError if any object is used.\n    WireResult Serialize(size_t commandSize, SerializeBuffer* serializeBuffer) const;\n\n    WireResult Deserialize(DeserializeBuffer* deserializeBuffer, DeserializeAllocator* allocator, const ObjectIdResolver& resolver);\n    // Override which produces a FatalError if any object is used.\n    WireResult Deserialize(DeserializeBuffer* deserializeBuffer, DeserializeAllocator* allocator);\n\n    ObjectId selfId;\n\n    WGPURenderPassEncoder self;\n    uint32_t queryIndex;\n};\n\n    struct RenderPassEncoderDrawCmd {\n    size_t GetRequiredSize() const;\n\n    WireResult Serialize(size_t commandSize, SerializeBuffer* serializeBuffer, const ObjectIdProvider& objectIdProvider) const;\n    // Override which produces a FatalError if any object is used.\n    WireResult Serialize(size_t commandSize, SerializeBuffer* serializeBuffer) const;\n\n    WireResult Deserialize(DeserializeBuffer* deserializeBuffer, DeserializeAllocator* allocator, const ObjectIdResolver& resolver);\n    // Override which produces a FatalError if any object is used.\n    WireResult Deserialize(DeserializeBuffer* deserializeBuffer, DeserializeAllocator* allocator);\n\n    ObjectId selfId;\n\n    WGPURenderPassEncoder self;\n    uint32_t vertexCount;\n    uint32_t instanceCount;\n    uint32_t firstVertex;\n    uint32_t firstInstance;\n};\n\n    struct RenderPassEncoderDrawIndexedCmd {\n    size_t GetRequiredSize() const;\n\n    WireResult Serialize(size_t commandSize, SerializeBuffer* serializeBuffer, const ObjectIdProvider& objectIdProvider) const;\n    // Override which produces a FatalError if any object is used.\n    WireResult Serialize(size_t commandSize, SerializeBuffer* serializeBuffer) const;\n\n    WireResult Deserialize(DeserializeBuffer* deserializeBuffer, DeserializeAllocator* allocator, const ObjectIdResolver& resolver);\n    // Override which produces a FatalError if any object is used.\n    WireResult Deserialize(DeserializeBuffer* deserializeBuffer, DeserializeAllocator* allocator);\n\n    ObjectId selfId;\n\n    WGPURenderPassEncoder self;\n    uint32_t indexCount;\n    uint32_t instanceCount;\n    uint32_t firstIndex;\n    int32_t baseVertex;\n    uint32_t firstInstance;\n};\n\n    struct RenderPassEncoderDrawIndexedIndirectCmd {\n    size_t GetRequiredSize() const;\n\n    WireResult Serialize(size_t commandSize, SerializeBuffer* serializeBuffer, const ObjectIdProvider& objectIdProvider) const;\n    // Override which produces a FatalError if any object is used.\n    WireResult Serialize(size_t commandSize, SerializeBuffer* serializeBuffer) const;\n\n    WireResult Deserialize(DeserializeBuffer* deserializeBuffer, DeserializeAllocator* allocator, const ObjectIdResolver& resolver);\n    // Override which produces a FatalError if any object is used.\n    WireResult Deserialize(DeserializeBuffer* deserializeBuffer, DeserializeAllocator* allocator);\n\n    ObjectId selfId;\n\n    WGPURenderPassEncoder self;\n    WGPUBuffer indirectBuffer;\n    uint64_t indirectOffset;\n};\n\n    struct RenderPassEncoderDrawIndirectCmd {\n    size_t GetRequiredSize() const;\n\n    WireResult Serialize(size_t commandSize, SerializeBuffer* serializeBuffer, const ObjectIdProvider& objectIdProvider) const;\n    // Override which produces a FatalError if any object is used.\n    WireResult Serialize(size_t commandSize, SerializeBuffer* serializeBuffer) const;\n\n    WireResult Deserialize(DeserializeBuffer* deserializeBuffer, DeserializeAllocator* allocator, const ObjectIdResolver& resolver);\n    // Override which produces a FatalError if any object is used.\n    WireResult Deserialize(DeserializeBuffer* deserializeBuffer, DeserializeAllocator* allocator);\n\n    ObjectId selfId;\n\n    WGPURenderPassEncoder self;\n    WGPUBuffer indirectBuffer;\n    uint64_t indirectOffset;\n};\n\n    struct RenderPassEncoderEndCmd {\n    size_t GetRequiredSize() const;\n\n    WireResult Serialize(size_t commandSize, SerializeBuffer* serializeBuffer, const ObjectIdProvider& objectIdProvider) const;\n    // Override which produces a FatalError if any object is used.\n    WireResult Serialize(size_t commandSize, SerializeBuffer* serializeBuffer) const;\n\n    WireResult Deserialize(DeserializeBuffer* deserializeBuffer, DeserializeAllocator* allocator, const ObjectIdResolver& resolver);\n    // Override which produces a FatalError if any object is used.\n    WireResult Deserialize(DeserializeBuffer* deserializeBuffer, DeserializeAllocator* allocator);\n\n    ObjectId selfId;\n\n    WGPURenderPassEncoder self;\n};\n\n    struct RenderPassEncoderEndOcclusionQueryCmd {\n    size_t GetRequiredSize() const;\n\n    WireResult Serialize(size_t commandSize, SerializeBuffer* serializeBuffer, const ObjectIdProvider& objectIdProvider) const;\n    // Override which produces a FatalError if any object is used.\n    WireResult Serialize(size_t commandSize, SerializeBuffer* serializeBuffer) const;\n\n    WireResult Deserialize(DeserializeBuffer* deserializeBuffer, DeserializeAllocator* allocator, const ObjectIdResolver& resolver);\n    // Override which produces a FatalError if any object is used.\n    WireResult Deserialize(DeserializeBuffer* deserializeBuffer, DeserializeAllocator* allocator);\n\n    ObjectId selfId;\n\n    WGPURenderPassEncoder self;\n};\n\n    struct RenderPassEncoderExecuteBundlesCmd {\n    size_t GetRequiredSize() const;\n\n    WireResult Serialize(size_t commandSize, SerializeBuffer* serializeBuffer, const ObjectIdProvider& objectIdProvider) const;\n    // Override which produces a FatalError if any object is used.\n    WireResult Serialize(size_t commandSize, SerializeBuffer* serializeBuffer) const;\n\n    WireResult Deserialize(DeserializeBuffer* deserializeBuffer, DeserializeAllocator* allocator, const ObjectIdResolver& resolver);\n    // Override which produces a FatalError if any object is used.\n    WireResult Deserialize(DeserializeBuffer* deserializeBuffer, DeserializeAllocator* allocator);\n\n    ObjectId selfId;\n\n    WGPURenderPassEncoder self;\n    size_t bundleCount;\n    WGPURenderBundle const * bundles;\n};\n\n    struct RenderPassEncoderInsertDebugMarkerCmd {\n    size_t GetRequiredSize() const;\n\n    WireResult Serialize(size_t commandSize, SerializeBuffer* serializeBuffer, const ObjectIdProvider& objectIdProvider) const;\n    // Override which produces a FatalError if any object is used.\n    WireResult Serialize(size_t commandSize, SerializeBuffer* serializeBuffer) const;\n\n    WireResult Deserialize(DeserializeBuffer* deserializeBuffer, DeserializeAllocator* allocator, const ObjectIdResolver& resolver);\n    // Override which produces a FatalError if any object is used.\n    WireResult Deserialize(DeserializeBuffer* deserializeBuffer, DeserializeAllocator* allocator);\n\n    ObjectId selfId;\n\n    WGPURenderPassEncoder self;\n    char const * markerLabel;\n};\n\n    struct RenderPassEncoderPopDebugGroupCmd {\n    size_t GetRequiredSize() const;\n\n    WireResult Serialize(size_t commandSize, SerializeBuffer* serializeBuffer, const ObjectIdProvider& objectIdProvider) const;\n    // Override which produces a FatalError if any object is used.\n    WireResult Serialize(size_t commandSize, SerializeBuffer* serializeBuffer) const;\n\n    WireResult Deserialize(DeserializeBuffer* deserializeBuffer, DeserializeAllocator* allocator, const ObjectIdResolver& resolver);\n    // Override which produces a FatalError if any object is used.\n    WireResult Deserialize(DeserializeBuffer* deserializeBuffer, DeserializeAllocator* allocator);\n\n    ObjectId selfId;\n\n    WGPURenderPassEncoder self;\n};\n\n    struct RenderPassEncoderPushDebugGroupCmd {\n    size_t GetRequiredSize() const;\n\n    WireResult Serialize(size_t commandSize, SerializeBuffer* serializeBuffer, const ObjectIdProvider& objectIdProvider) const;\n    // Override which produces a FatalError if any object is used.\n    WireResult Serialize(size_t commandSize, SerializeBuffer* serializeBuffer) const;\n\n    WireResult Deserialize(DeserializeBuffer* deserializeBuffer, DeserializeAllocator* allocator, const ObjectIdResolver& resolver);\n    // Override which produces a FatalError if any object is used.\n    WireResult Deserialize(DeserializeBuffer* deserializeBuffer, DeserializeAllocator* allocator);\n\n    ObjectId selfId;\n\n    WGPURenderPassEncoder self;\n    char const * groupLabel;\n};\n\n    struct RenderPassEncoderSetBindGroupCmd {\n    size_t GetRequiredSize() const;\n\n    WireResult Serialize(size_t commandSize, SerializeBuffer* serializeBuffer, const ObjectIdProvider& objectIdProvider) const;\n    // Override which produces a FatalError if any object is used.\n    WireResult Serialize(size_t commandSize, SerializeBuffer* serializeBuffer) const;\n\n    WireResult Deserialize(DeserializeBuffer* deserializeBuffer, DeserializeAllocator* allocator, const ObjectIdResolver& resolver);\n    // Override which produces a FatalError if any object is used.\n    WireResult Deserialize(DeserializeBuffer* deserializeBuffer, DeserializeAllocator* allocator);\n\n    ObjectId selfId;\n\n    WGPURenderPassEncoder self;\n    uint32_t groupIndex;\n    WGPUBindGroup group;\n    size_t dynamicOffsetCount;\n    uint32_t const * dynamicOffsets;\n};\n\n    struct RenderPassEncoderSetBlendConstantCmd {\n    size_t GetRequiredSize() const;\n\n    WireResult Serialize(size_t commandSize, SerializeBuffer* serializeBuffer, const ObjectIdProvider& objectIdProvider) const;\n    // Override which produces a FatalError if any object is used.\n    WireResult Serialize(size_t commandSize, SerializeBuffer* serializeBuffer) const;\n\n    WireResult Deserialize(DeserializeBuffer* deserializeBuffer, DeserializeAllocator* allocator, const ObjectIdResolver& resolver);\n    // Override which produces a FatalError if any object is used.\n    WireResult Deserialize(DeserializeBuffer* deserializeBuffer, DeserializeAllocator* allocator);\n\n    ObjectId selfId;\n\n    WGPURenderPassEncoder self;\n    WGPUColor const * color;\n};\n\n    struct RenderPassEncoderSetIndexBufferCmd {\n    size_t GetRequiredSize() const;\n\n    WireResult Serialize(size_t commandSize, SerializeBuffer* serializeBuffer, const ObjectIdProvider& objectIdProvider) const;\n    // Override which produces a FatalError if any object is used.\n    WireResult Serialize(size_t commandSize, SerializeBuffer* serializeBuffer) const;\n\n    WireResult Deserialize(DeserializeBuffer* deserializeBuffer, DeserializeAllocator* allocator, const ObjectIdResolver& resolver);\n    // Override which produces a FatalError if any object is used.\n    WireResult Deserialize(DeserializeBuffer* deserializeBuffer, DeserializeAllocator* allocator);\n\n    ObjectId selfId;\n\n    WGPURenderPassEncoder self;\n    WGPUBuffer buffer;\n    WGPUIndexFormat format;\n    uint64_t offset;\n    uint64_t size;\n};\n\n    struct RenderPassEncoderSetLabelCmd {\n    size_t GetRequiredSize() const;\n\n    WireResult Serialize(size_t commandSize, SerializeBuffer* serializeBuffer, const ObjectIdProvider& objectIdProvider) const;\n    // Override which produces a FatalError if any object is used.\n    WireResult Serialize(size_t commandSize, SerializeBuffer* serializeBuffer) const;\n\n    WireResult Deserialize(DeserializeBuffer* deserializeBuffer, DeserializeAllocator* allocator, const ObjectIdResolver& resolver);\n    // Override which produces a FatalError if any object is used.\n    WireResult Deserialize(DeserializeBuffer* deserializeBuffer, DeserializeAllocator* allocator);\n\n    ObjectId selfId;\n\n    WGPURenderPassEncoder self;\n    char const * label;\n};\n\n    struct RenderPassEncoderSetPipelineCmd {\n    size_t GetRequiredSize() const;\n\n    WireResult Serialize(size_t commandSize, SerializeBuffer* serializeBuffer, const ObjectIdProvider& objectIdProvider) const;\n    // Override which produces a FatalError if any object is used.\n    WireResult Serialize(size_t commandSize, SerializeBuffer* serializeBuffer) const;\n\n    WireResult Deserialize(DeserializeBuffer* deserializeBuffer, DeserializeAllocator* allocator, const ObjectIdResolver& resolver);\n    // Override which produces a FatalError if any object is used.\n    WireResult Deserialize(DeserializeBuffer* deserializeBuffer, DeserializeAllocator* allocator);\n\n    ObjectId selfId;\n\n    WGPURenderPassEncoder self;\n    WGPURenderPipeline pipeline;\n};\n\n    struct RenderPassEncoderSetScissorRectCmd {\n    size_t GetRequiredSize() const;\n\n    WireResult Serialize(size_t commandSize, SerializeBuffer* serializeBuffer, const ObjectIdProvider& objectIdProvider) const;\n    // Override which produces a FatalError if any object is used.\n    WireResult Serialize(size_t commandSize, SerializeBuffer* serializeBuffer) const;\n\n    WireResult Deserialize(DeserializeBuffer* deserializeBuffer, DeserializeAllocator* allocator, const ObjectIdResolver& resolver);\n    // Override which produces a FatalError if any object is used.\n    WireResult Deserialize(DeserializeBuffer* deserializeBuffer, DeserializeAllocator* allocator);\n\n    ObjectId selfId;\n\n    WGPURenderPassEncoder self;\n    uint32_t x;\n    uint32_t y;\n    uint32_t width;\n    uint32_t height;\n};\n\n    struct RenderPassEncoderSetStencilReferenceCmd {\n    size_t GetRequiredSize() const;\n\n    WireResult Serialize(size_t commandSize, SerializeBuffer* serializeBuffer, const ObjectIdProvider& objectIdProvider) const;\n    // Override which produces a FatalError if any object is used.\n    WireResult Serialize(size_t commandSize, SerializeBuffer* serializeBuffer) const;\n\n    WireResult Deserialize(DeserializeBuffer* deserializeBuffer, DeserializeAllocator* allocator, const ObjectIdResolver& resolver);\n    // Override which produces a FatalError if any object is used.\n    WireResult Deserialize(DeserializeBuffer* deserializeBuffer, DeserializeAllocator* allocator);\n\n    ObjectId selfId;\n\n    WGPURenderPassEncoder self;\n    uint32_t reference;\n};\n\n    struct RenderPassEncoderSetVertexBufferCmd {\n    size_t GetRequiredSize() const;\n\n    WireResult Serialize(size_t commandSize, SerializeBuffer* serializeBuffer, const ObjectIdProvider& objectIdProvider) const;\n    // Override which produces a FatalError if any object is used.\n    WireResult Serialize(size_t commandSize, SerializeBuffer* serializeBuffer) const;\n\n    WireResult Deserialize(DeserializeBuffer* deserializeBuffer, DeserializeAllocator* allocator, const ObjectIdResolver& resolver);\n    // Override which produces a FatalError if any object is used.\n    WireResult Deserialize(DeserializeBuffer* deserializeBuffer, DeserializeAllocator* allocator);\n\n    ObjectId selfId;\n\n    WGPURenderPassEncoder self;\n    uint32_t slot;\n    WGPUBuffer buffer;\n    uint64_t offset;\n    uint64_t size;\n};\n\n    struct RenderPassEncoderSetViewportCmd {\n    size_t GetRequiredSize() const;\n\n    WireResult Serialize(size_t commandSize, SerializeBuffer* serializeBuffer, const ObjectIdProvider& objectIdProvider) const;\n    // Override which produces a FatalError if any object is used.\n    WireResult Serialize(size_t commandSize, SerializeBuffer* serializeBuffer) const;\n\n    WireResult Deserialize(DeserializeBuffer* deserializeBuffer, DeserializeAllocator* allocator, const ObjectIdResolver& resolver);\n    // Override which produces a FatalError if any object is used.\n    WireResult Deserialize(DeserializeBuffer* deserializeBuffer, DeserializeAllocator* allocator);\n\n    ObjectId selfId;\n\n    WGPURenderPassEncoder self;\n    float x;\n    float y;\n    float width;\n    float height;\n    float minDepth;\n    float maxDepth;\n};\n\n    struct RenderPassEncoderWriteTimestampCmd {\n    size_t GetRequiredSize() const;\n\n    WireResult Serialize(size_t commandSize, SerializeBuffer* serializeBuffer, const ObjectIdProvider& objectIdProvider) const;\n    // Override which produces a FatalError if any object is used.\n    WireResult Serialize(size_t commandSize, SerializeBuffer* serializeBuffer) const;\n\n    WireResult Deserialize(DeserializeBuffer* deserializeBuffer, DeserializeAllocator* allocator, const ObjectIdResolver& resolver);\n    // Override which produces a FatalError if any object is used.\n    WireResult Deserialize(DeserializeBuffer* deserializeBuffer, DeserializeAllocator* allocator);\n\n    ObjectId selfId;\n\n    WGPURenderPassEncoder self;\n    WGPUQuerySet querySet;\n    uint32_t queryIndex;\n};\n\n    struct RenderPipelineGetBindGroupLayoutCmd {\n    size_t GetRequiredSize() const;\n\n    WireResult Serialize(size_t commandSize, SerializeBuffer* serializeBuffer, const ObjectIdProvider& objectIdProvider) const;\n    // Override which produces a FatalError if any object is used.\n    WireResult Serialize(size_t commandSize, SerializeBuffer* serializeBuffer) const;\n\n    WireResult Deserialize(DeserializeBuffer* deserializeBuffer, DeserializeAllocator* allocator, const ObjectIdResolver& resolver);\n    // Override which produces a FatalError if any object is used.\n    WireResult Deserialize(DeserializeBuffer* deserializeBuffer, DeserializeAllocator* allocator);\n\n    ObjectId selfId;\n\n    WGPURenderPipeline self;\n    uint32_t groupIndex;\n    ObjectHandle result;\n};\n\n    struct RenderPipelineSetLabelCmd {\n    size_t GetRequiredSize() const;\n\n    WireResult Serialize(size_t commandSize, SerializeBuffer* serializeBuffer, const ObjectIdProvider& objectIdProvider) const;\n    // Override which produces a FatalError if any object is used.\n    WireResult Serialize(size_t commandSize, SerializeBuffer* serializeBuffer) const;\n\n    WireResult Deserialize(DeserializeBuffer* deserializeBuffer, DeserializeAllocator* allocator, const ObjectIdResolver& resolver);\n    // Override which produces a FatalError if any object is used.\n    WireResult Deserialize(DeserializeBuffer* deserializeBuffer, DeserializeAllocator* allocator);\n\n    ObjectId selfId;\n\n    WGPURenderPipeline self;\n    char const * label;\n};\n\n    struct SamplerSetLabelCmd {\n    size_t GetRequiredSize() const;\n\n    WireResult Serialize(size_t commandSize, SerializeBuffer* serializeBuffer, const ObjectIdProvider& objectIdProvider) const;\n    // Override which produces a FatalError if any object is used.\n    WireResult Serialize(size_t commandSize, SerializeBuffer* serializeBuffer) const;\n\n    WireResult Deserialize(DeserializeBuffer* deserializeBuffer, DeserializeAllocator* allocator, const ObjectIdResolver& resolver);\n    // Override which produces a FatalError if any object is used.\n    WireResult Deserialize(DeserializeBuffer* deserializeBuffer, DeserializeAllocator* allocator);\n\n    ObjectId selfId;\n\n    WGPUSampler self;\n    char const * label;\n};\n\n    struct ShaderModuleGetCompilationInfoCmd {\n    size_t GetRequiredSize() const;\n\n    WireResult Serialize(size_t commandSize, SerializeBuffer* serializeBuffer, const ObjectIdProvider& objectIdProvider) const;\n    // Override which produces a FatalError if any object is used.\n    WireResult Serialize(size_t commandSize, SerializeBuffer* serializeBuffer) const;\n\n    WireResult Deserialize(DeserializeBuffer* deserializeBuffer, DeserializeAllocator* allocator, const ObjectIdResolver& resolver);\n    // Override which produces a FatalError if any object is used.\n    WireResult Deserialize(DeserializeBuffer* deserializeBuffer, DeserializeAllocator* allocator);\n\n\n    ObjectId shaderModuleId;\n    uint64_t requestSerial;\n};\n\n    struct ShaderModuleSetLabelCmd {\n    size_t GetRequiredSize() const;\n\n    WireResult Serialize(size_t commandSize, SerializeBuffer* serializeBuffer, const ObjectIdProvider& objectIdProvider) const;\n    // Override which produces a FatalError if any object is used.\n    WireResult Serialize(size_t commandSize, SerializeBuffer* serializeBuffer) const;\n\n    WireResult Deserialize(DeserializeBuffer* deserializeBuffer, DeserializeAllocator* allocator, const ObjectIdResolver& resolver);\n    // Override which produces a FatalError if any object is used.\n    WireResult Deserialize(DeserializeBuffer* deserializeBuffer, DeserializeAllocator* allocator);\n\n    ObjectId selfId;\n\n    WGPUShaderModule self;\n    char const * label;\n};\n\n    struct SwapChainGetCurrentTextureCmd {\n    size_t GetRequiredSize() const;\n\n    WireResult Serialize(size_t commandSize, SerializeBuffer* serializeBuffer, const ObjectIdProvider& objectIdProvider) const;\n    // Override which produces a FatalError if any object is used.\n    WireResult Serialize(size_t commandSize, SerializeBuffer* serializeBuffer) const;\n\n    WireResult Deserialize(DeserializeBuffer* deserializeBuffer, DeserializeAllocator* allocator, const ObjectIdResolver& resolver);\n    // Override which produces a FatalError if any object is used.\n    WireResult Deserialize(DeserializeBuffer* deserializeBuffer, DeserializeAllocator* allocator);\n\n    ObjectId selfId;\n\n    WGPUSwapChain self;\n    ObjectHandle result;\n};\n\n    struct SwapChainGetCurrentTextureViewCmd {\n    size_t GetRequiredSize() const;\n\n    WireResult Serialize(size_t commandSize, SerializeBuffer* serializeBuffer, const ObjectIdProvider& objectIdProvider) const;\n    // Override which produces a FatalError if any object is used.\n    WireResult Serialize(size_t commandSize, SerializeBuffer* serializeBuffer) const;\n\n    WireResult Deserialize(DeserializeBuffer* deserializeBuffer, DeserializeAllocator* allocator, const ObjectIdResolver& resolver);\n    // Override which produces a FatalError if any object is used.\n    WireResult Deserialize(DeserializeBuffer* deserializeBuffer, DeserializeAllocator* allocator);\n\n    ObjectId selfId;\n\n    WGPUSwapChain self;\n    ObjectHandle result;\n};\n\n    struct SwapChainPresentCmd {\n    size_t GetRequiredSize() const;\n\n    WireResult Serialize(size_t commandSize, SerializeBuffer* serializeBuffer, const ObjectIdProvider& objectIdProvider) const;\n    // Override which produces a FatalError if any object is used.\n    WireResult Serialize(size_t commandSize, SerializeBuffer* serializeBuffer) const;\n\n    WireResult Deserialize(DeserializeBuffer* deserializeBuffer, DeserializeAllocator* allocator, const ObjectIdResolver& resolver);\n    // Override which produces a FatalError if any object is used.\n    WireResult Deserialize(DeserializeBuffer* deserializeBuffer, DeserializeAllocator* allocator);\n\n    ObjectId selfId;\n\n    WGPUSwapChain self;\n};\n\n    struct TextureCreateViewCmd {\n    size_t GetRequiredSize() const;\n\n    WireResult Serialize(size_t commandSize, SerializeBuffer* serializeBuffer, const ObjectIdProvider& objectIdProvider) const;\n    // Override which produces a FatalError if any object is used.\n    WireResult Serialize(size_t commandSize, SerializeBuffer* serializeBuffer) const;\n\n    WireResult Deserialize(DeserializeBuffer* deserializeBuffer, DeserializeAllocator* allocator, const ObjectIdResolver& resolver);\n    // Override which produces a FatalError if any object is used.\n    WireResult Deserialize(DeserializeBuffer* deserializeBuffer, DeserializeAllocator* allocator);\n\n    ObjectId selfId;\n\n    WGPUTexture self;\n    WGPUTextureViewDescriptor const * descriptor;\n    ObjectHandle result;\n};\n\n    struct TextureDestroyCmd {\n    size_t GetRequiredSize() const;\n\n    WireResult Serialize(size_t commandSize, SerializeBuffer* serializeBuffer, const ObjectIdProvider& objectIdProvider) const;\n    // Override which produces a FatalError if any object is used.\n    WireResult Serialize(size_t commandSize, SerializeBuffer* serializeBuffer) const;\n\n    WireResult Deserialize(DeserializeBuffer* deserializeBuffer, DeserializeAllocator* allocator, const ObjectIdResolver& resolver);\n    // Override which produces a FatalError if any object is used.\n    WireResult Deserialize(DeserializeBuffer* deserializeBuffer, DeserializeAllocator* allocator);\n\n    ObjectId selfId;\n\n    WGPUTexture self;\n};\n\n    struct TextureSetLabelCmd {\n    size_t GetRequiredSize() const;\n\n    WireResult Serialize(size_t commandSize, SerializeBuffer* serializeBuffer, const ObjectIdProvider& objectIdProvider) const;\n    // Override which produces a FatalError if any object is used.\n    WireResult Serialize(size_t commandSize, SerializeBuffer* serializeBuffer) const;\n\n    WireResult Deserialize(DeserializeBuffer* deserializeBuffer, DeserializeAllocator* allocator, const ObjectIdResolver& resolver);\n    // Override which produces a FatalError if any object is used.\n    WireResult Deserialize(DeserializeBuffer* deserializeBuffer, DeserializeAllocator* allocator);\n\n    ObjectId selfId;\n\n    WGPUTexture self;\n    char const * label;\n};\n\n    struct TextureViewSetLabelCmd {\n    size_t GetRequiredSize() const;\n\n    WireResult Serialize(size_t commandSize, SerializeBuffer* serializeBuffer, const ObjectIdProvider& objectIdProvider) const;\n    // Override which produces a FatalError if any object is used.\n    WireResult Serialize(size_t commandSize, SerializeBuffer* serializeBuffer) const;\n\n    WireResult Deserialize(DeserializeBuffer* deserializeBuffer, DeserializeAllocator* allocator, const ObjectIdResolver& resolver);\n    // Override which produces a FatalError if any object is used.\n    WireResult Deserialize(DeserializeBuffer* deserializeBuffer, DeserializeAllocator* allocator);\n\n    ObjectId selfId;\n\n    WGPUTextureView self;\n    char const * label;\n};\n\n\n    struct ReturnAdapterRequestDeviceCallbackCmd {\n    size_t GetRequiredSize() const;\n\n    WireResult Serialize(size_t commandSize, SerializeBuffer* serializeBuffer, const ObjectIdProvider& objectIdProvider) const;\n    // Override which produces a FatalError if any object is used.\n    WireResult Serialize(size_t commandSize, SerializeBuffer* serializeBuffer) const;\n\n    WireResult Deserialize(DeserializeBuffer* deserializeBuffer, DeserializeAllocator* allocator, const ObjectIdResolver& resolver);\n    // Override which produces a FatalError if any object is used.\n    WireResult Deserialize(DeserializeBuffer* deserializeBuffer, DeserializeAllocator* allocator);\n\n\n    ObjectHandle adapter;\n    uint64_t requestSerial;\n    WGPURequestDeviceStatus status;\n    char const * message;\n    WGPUSupportedLimits const * limits;\n    uint32_t featuresCount;\n    WGPUFeatureName const * features;\n};\n\n    struct ReturnBufferMapAsyncCallbackCmd {\n    size_t GetRequiredSize() const;\n\n    WireResult Serialize(size_t commandSize, SerializeBuffer* serializeBuffer, const ObjectIdProvider& objectIdProvider) const;\n    // Override which produces a FatalError if any object is used.\n    WireResult Serialize(size_t commandSize, SerializeBuffer* serializeBuffer) const;\n\n    WireResult Deserialize(DeserializeBuffer* deserializeBuffer, DeserializeAllocator* allocator, const ObjectIdResolver& resolver);\n    // Override which produces a FatalError if any object is used.\n    WireResult Deserialize(DeserializeBuffer* deserializeBuffer, DeserializeAllocator* allocator);\n\n\n    ObjectHandle buffer;\n    uint64_t requestSerial;\n    uint32_t status;\n    uint64_t readDataUpdateInfoLength;\n    uint8_t const * readDataUpdateInfo;\n};\n\n    struct ReturnDeviceCreateComputePipelineAsyncCallbackCmd {\n    size_t GetRequiredSize() const;\n\n    WireResult Serialize(size_t commandSize, SerializeBuffer* serializeBuffer, const ObjectIdProvider& objectIdProvider) const;\n    // Override which produces a FatalError if any object is used.\n    WireResult Serialize(size_t commandSize, SerializeBuffer* serializeBuffer) const;\n\n    WireResult Deserialize(DeserializeBuffer* deserializeBuffer, DeserializeAllocator* allocator, const ObjectIdResolver& resolver);\n    // Override which produces a FatalError if any object is used.\n    WireResult Deserialize(DeserializeBuffer* deserializeBuffer, DeserializeAllocator* allocator);\n\n\n    ObjectHandle device;\n    uint64_t requestSerial;\n    WGPUCreatePipelineAsyncStatus status;\n    char const * message;\n};\n\n    struct ReturnDeviceCreateRenderPipelineAsyncCallbackCmd {\n    size_t GetRequiredSize() const;\n\n    WireResult Serialize(size_t commandSize, SerializeBuffer* serializeBuffer, const ObjectIdProvider& objectIdProvider) const;\n    // Override which produces a FatalError if any object is used.\n    WireResult Serialize(size_t commandSize, SerializeBuffer* serializeBuffer) const;\n\n    WireResult Deserialize(DeserializeBuffer* deserializeBuffer, DeserializeAllocator* allocator, const ObjectIdResolver& resolver);\n    // Override which produces a FatalError if any object is used.\n    WireResult Deserialize(DeserializeBuffer* deserializeBuffer, DeserializeAllocator* allocator);\n\n\n    ObjectHandle device;\n    uint64_t requestSerial;\n    WGPUCreatePipelineAsyncStatus status;\n    char const * message;\n};\n\n    struct ReturnDeviceLoggingCallbackCmd {\n    size_t GetRequiredSize() const;\n\n    WireResult Serialize(size_t commandSize, SerializeBuffer* serializeBuffer, const ObjectIdProvider& objectIdProvider) const;\n    // Override which produces a FatalError if any object is used.\n    WireResult Serialize(size_t commandSize, SerializeBuffer* serializeBuffer) const;\n\n    WireResult Deserialize(DeserializeBuffer* deserializeBuffer, DeserializeAllocator* allocator, const ObjectIdResolver& resolver);\n    // Override which produces a FatalError if any object is used.\n    WireResult Deserialize(DeserializeBuffer* deserializeBuffer, DeserializeAllocator* allocator);\n\n\n    ObjectHandle device;\n    WGPULoggingType type;\n    char const * message;\n};\n\n    struct ReturnDeviceLostCallbackCmd {\n    size_t GetRequiredSize() const;\n\n    WireResult Serialize(size_t commandSize, SerializeBuffer* serializeBuffer, const ObjectIdProvider& objectIdProvider) const;\n    // Override which produces a FatalError if any object is used.\n    WireResult Serialize(size_t commandSize, SerializeBuffer* serializeBuffer) const;\n\n    WireResult Deserialize(DeserializeBuffer* deserializeBuffer, DeserializeAllocator* allocator, const ObjectIdResolver& resolver);\n    // Override which produces a FatalError if any object is used.\n    WireResult Deserialize(DeserializeBuffer* deserializeBuffer, DeserializeAllocator* allocator);\n\n\n    ObjectHandle device;\n    WGPUDeviceLostReason reason;\n    char const * message;\n};\n\n    struct ReturnDevicePopErrorScopeCallbackCmd {\n    size_t GetRequiredSize() const;\n\n    WireResult Serialize(size_t commandSize, SerializeBuffer* serializeBuffer, const ObjectIdProvider& objectIdProvider) const;\n    // Override which produces a FatalError if any object is used.\n    WireResult Serialize(size_t commandSize, SerializeBuffer* serializeBuffer) const;\n\n    WireResult Deserialize(DeserializeBuffer* deserializeBuffer, DeserializeAllocator* allocator, const ObjectIdResolver& resolver);\n    // Override which produces a FatalError if any object is used.\n    WireResult Deserialize(DeserializeBuffer* deserializeBuffer, DeserializeAllocator* allocator);\n\n\n    ObjectHandle device;\n    uint64_t requestSerial;\n    WGPUErrorType type;\n    char const * message;\n};\n\n    struct ReturnDeviceUncapturedErrorCallbackCmd {\n    size_t GetRequiredSize() const;\n\n    WireResult Serialize(size_t commandSize, SerializeBuffer* serializeBuffer, const ObjectIdProvider& objectIdProvider) const;\n    // Override which produces a FatalError if any object is used.\n    WireResult Serialize(size_t commandSize, SerializeBuffer* serializeBuffer) const;\n\n    WireResult Deserialize(DeserializeBuffer* deserializeBuffer, DeserializeAllocator* allocator, const ObjectIdResolver& resolver);\n    // Override which produces a FatalError if any object is used.\n    WireResult Deserialize(DeserializeBuffer* deserializeBuffer, DeserializeAllocator* allocator);\n\n\n    ObjectHandle device;\n    WGPUErrorType type;\n    char const * message;\n};\n\n    struct ReturnInstanceRequestAdapterCallbackCmd {\n    size_t GetRequiredSize() const;\n\n    WireResult Serialize(size_t commandSize, SerializeBuffer* serializeBuffer, const ObjectIdProvider& objectIdProvider) const;\n    // Override which produces a FatalError if any object is used.\n    WireResult Serialize(size_t commandSize, SerializeBuffer* serializeBuffer) const;\n\n    WireResult Deserialize(DeserializeBuffer* deserializeBuffer, DeserializeAllocator* allocator, const ObjectIdResolver& resolver);\n    // Override which produces a FatalError if any object is used.\n    WireResult Deserialize(DeserializeBuffer* deserializeBuffer, DeserializeAllocator* allocator);\n\n\n    ObjectHandle instance;\n    uint64_t requestSerial;\n    WGPURequestAdapterStatus status;\n    char const * message;\n    WGPUAdapterProperties const * properties;\n    WGPUSupportedLimits const * limits;\n    uint32_t featuresCount;\n    WGPUFeatureName const * features;\n};\n\n    struct ReturnQueueWorkDoneCallbackCmd {\n    size_t GetRequiredSize() const;\n\n    WireResult Serialize(size_t commandSize, SerializeBuffer* serializeBuffer, const ObjectIdProvider& objectIdProvider) const;\n    // Override which produces a FatalError if any object is used.\n    WireResult Serialize(size_t commandSize, SerializeBuffer* serializeBuffer) const;\n\n    WireResult Deserialize(DeserializeBuffer* deserializeBuffer, DeserializeAllocator* allocator, const ObjectIdResolver& resolver);\n    // Override which produces a FatalError if any object is used.\n    WireResult Deserialize(DeserializeBuffer* deserializeBuffer, DeserializeAllocator* allocator);\n\n\n    ObjectHandle queue;\n    uint64_t requestSerial;\n    WGPUQueueWorkDoneStatus status;\n};\n\n    struct ReturnShaderModuleGetCompilationInfoCallbackCmd {\n    size_t GetRequiredSize() const;\n\n    WireResult Serialize(size_t commandSize, SerializeBuffer* serializeBuffer, const ObjectIdProvider& objectIdProvider) const;\n    // Override which produces a FatalError if any object is used.\n    WireResult Serialize(size_t commandSize, SerializeBuffer* serializeBuffer) const;\n\n    WireResult Deserialize(DeserializeBuffer* deserializeBuffer, DeserializeAllocator* allocator, const ObjectIdResolver& resolver);\n    // Override which produces a FatalError if any object is used.\n    WireResult Deserialize(DeserializeBuffer* deserializeBuffer, DeserializeAllocator* allocator);\n\n\n    ObjectHandle shaderModule;\n    uint64_t requestSerial;\n    WGPUCompilationInfoRequestStatus status;\n    WGPUCompilationInfo const * info;\n};\n\n\n}  // namespace dawn::wire\n\n#endif // DAWNWIRE_WIRECMD_AUTOGEN_H_\n", "src/dawn/wire/WireCmd_autogen.cpp": "\n#include \"dawn/wire/WireCmd_autogen.h\"\n\n#include \"dawn/common/Assert.h\"\n#include \"dawn/common/Log.h\"\n#include \"dawn/common/Numeric.h\"\n#include \"dawn/wire/BufferConsumer_impl.h\"\n#include \"dawn/wire/Wire.h\"\n\n#include <algorithm>\n#include <cstring>\n#include <limits>\n\n#ifdef __GNUC__\n// error: 'offsetof' within non-standard-layout type 'wgpu::XXX' is conditionally-supported\n#pragma GCC diagnostic ignored \"-Winvalid-offsetof\"\n#endif\n\nnamespace dawn::wire {\nnamespace {\n\n// Allocates enough space from allocator to countain T[count] and return it in out.\n// Return FatalError if the allocator couldn't allocate the memory.\n// Always writes to |out| on success.\ntemplate <typename T, typename N>\nWireResult GetSpace(DeserializeAllocator* allocator, N count, T** out) {\n    // Because we use this function extensively when `count` == 1, we can optimize the\n    // size computations a bit more for those cases via constexpr version of the\n    // alignment computation.\n    constexpr size_t kSizeofT = WireAlignSizeof<T>();\n    size_t size = 0;\n    if (count == 1) {\n      size = kSizeofT;\n    } else {\n      auto sizeN = WireAlignSizeofN<T>(count);\n      // A size of 0 indicates an overflow, so return an error.\n      if (!sizeN) {\n        return WireResult::FatalError;\n      }\n      size = *sizeN;\n    }\n\n    *out = static_cast<T*>(allocator->GetSpace(size));\n    if (*out == nullptr) {\n        return WireResult::FatalError;\n    }\n\n    return WireResult::Success;\n}\n\nstruct WGPUChainedStructTransfer {\n    WGPUSType sType;\n    bool hasNext;\n};\n\nsize_t GetChainedStructExtraRequiredSize(const WGPUChainedStruct* chainedStruct);\n[[nodiscard]] WireResult SerializeChainedStruct(const WGPUChainedStruct* chainedStruct,\n                                                  SerializeBuffer* buffer,\n                                                  const ObjectIdProvider& provider);\nWireResult DeserializeChainedStruct(const WGPUChainedStruct** outChainNext,\n                                    DeserializeBuffer* deserializeBuffer,\n                                    DeserializeAllocator* allocator,\n                                    const ObjectIdResolver& resolver);\n\nsize_t GetChainedStructExtraRequiredSize(WGPUChainedStructOut* chainedStruct);\n[[nodiscard]] WireResult SerializeChainedStruct(WGPUChainedStructOut* chainedStruct,\n                                                  SerializeBuffer* buffer,\n                                                  const ObjectIdProvider& provider);\nWireResult DeserializeChainedStruct(WGPUChainedStructOut** outChainNext,\n                                    DeserializeBuffer* deserializeBuffer,\n                                    DeserializeAllocator* allocator,\n                                    const ObjectIdResolver& resolver);\n\n\nstruct WGPUAdapterPropertiesTransfer {\n    static_assert(0 <= 1,\n                  \"Record must be at most one of is_cmd, extensible, and chained.\");\n    bool hasNextInChain;\n\n    uint32_t vendorID;\n    uint64_t vendorNameStrlen;\n    uint64_t architectureStrlen;\n    uint32_t deviceID;\n    uint64_t nameStrlen;\n    uint64_t driverDescriptionStrlen;\n    WGPUAdapterType adapterType;\n    WGPUBackendType backendType;\n    bool compatibilityMode;\n};\n\n\nDAWN_DECLARE_UNUSED size_t WGPUAdapterPropertiesGetExtraRequiredSize(const WGPUAdapterProperties& record) {\n    DAWN_UNUSED(record);\n    size_t result = 0;\n\n    if (record.nextInChain != nullptr) {\n        result += GetChainedStructExtraRequiredSize(record.nextInChain);\n    }\n    ASSERT(record.vendorName != nullptr);\n    result += Align(std::strlen(record.vendorName), kWireBufferAlignment);\n    ASSERT(record.architecture != nullptr);\n    result += Align(std::strlen(record.architecture), kWireBufferAlignment);\n    ASSERT(record.name != nullptr);\n    result += Align(std::strlen(record.name), kWireBufferAlignment);\n    ASSERT(record.driverDescription != nullptr);\n    result += Align(std::strlen(record.driverDescription), kWireBufferAlignment);\n    return result;\n}\n// GetExtraRequiredSize isn't used for structures that are value members of other structures\n// because we assume they cannot contain pointers themselves.\nDAWN_UNUSED_FUNC(WGPUAdapterPropertiesGetExtraRequiredSize);\n\nDAWN_DECLARE_UNUSED WireResult WGPUAdapterPropertiesSerialize(\n    const WGPUAdapterProperties& record,\n    WGPUAdapterPropertiesTransfer* transfer,\n    SerializeBuffer* buffer, const ObjectIdProvider& provider) {\n    DAWN_UNUSED(buffer);\n\n    if (record.nextInChain != nullptr) {\n        transfer->hasNextInChain = true;\n        WIRE_TRY(SerializeChainedStruct(record.nextInChain, buffer, provider));\n    } else {\n        transfer->hasNextInChain = false;\n    }\n\n    transfer->vendorID = record.vendorID;\n    transfer->deviceID = record.deviceID;\n    transfer->adapterType = record.adapterType;\n    transfer->backendType = record.backendType;\n    transfer->compatibilityMode = record.compatibilityMode;\n    {\n        transfer->vendorNameStrlen = std::strlen(record.vendorName);\n\n        char* stringInBuffer;\n        WIRE_TRY(buffer->NextN(transfer->vendorNameStrlen, &stringInBuffer));\n        memcpy(stringInBuffer, record.vendorName, transfer->vendorNameStrlen);\n    }\n    {\n        transfer->architectureStrlen = std::strlen(record.architecture);\n\n        char* stringInBuffer;\n        WIRE_TRY(buffer->NextN(transfer->architectureStrlen, &stringInBuffer));\n        memcpy(stringInBuffer, record.architecture, transfer->architectureStrlen);\n    }\n    {\n        transfer->nameStrlen = std::strlen(record.name);\n\n        char* stringInBuffer;\n        WIRE_TRY(buffer->NextN(transfer->nameStrlen, &stringInBuffer));\n        memcpy(stringInBuffer, record.name, transfer->nameStrlen);\n    }\n    {\n        transfer->driverDescriptionStrlen = std::strlen(record.driverDescription);\n\n        char* stringInBuffer;\n        WIRE_TRY(buffer->NextN(transfer->driverDescriptionStrlen, &stringInBuffer));\n        memcpy(stringInBuffer, record.driverDescription, transfer->driverDescriptionStrlen);\n    }\n\n    return WireResult::Success;\n}\nDAWN_UNUSED_FUNC(WGPUAdapterPropertiesSerialize);\n\nDAWN_DECLARE_UNUSED WireResult WGPUAdapterPropertiesDeserialize(\n    WGPUAdapterProperties* record,\n    const volatile WGPUAdapterPropertiesTransfer* transfer,\n    DeserializeBuffer* deserializeBuffer,\n    DeserializeAllocator* allocator, const ObjectIdResolver& resolver) {\n    DAWN_UNUSED(allocator);\n\n\n    record->nextInChain = nullptr;\n    if (transfer->hasNextInChain) {\n        WIRE_TRY(DeserializeChainedStruct(&record->nextInChain, deserializeBuffer, allocator, resolver));\n    }\n\n    static_assert(sizeof(record->vendorID) >= sizeof(transfer->vendorID), \"Deserialize assignment may not narrow.\");\n    record->vendorID = transfer->vendorID;\n    static_assert(sizeof(record->deviceID) >= sizeof(transfer->deviceID), \"Deserialize assignment may not narrow.\");\n    record->deviceID = transfer->deviceID;\n    static_assert(sizeof(record->adapterType) >= sizeof(transfer->adapterType), \"Deserialize assignment may not narrow.\");\n    record->adapterType = transfer->adapterType;\n    static_assert(sizeof(record->backendType) >= sizeof(transfer->backendType), \"Deserialize assignment may not narrow.\");\n    record->backendType = transfer->backendType;\n    static_assert(sizeof(record->compatibilityMode) >= sizeof(transfer->compatibilityMode), \"Deserialize assignment may not narrow.\");\n    record->compatibilityMode = transfer->compatibilityMode;\n    {\n        uint64_t stringLength64 = transfer->vendorNameStrlen;\n        if (stringLength64 >= std::numeric_limits<size_t>::max()) {\n            return WireResult::FatalError;\n        }\n        size_t stringLength = static_cast<size_t>(stringLength64);\n\n        const volatile char* stringInBuffer;\n        WIRE_TRY(deserializeBuffer->ReadN(stringLength, &stringInBuffer));\n\n        char* copiedString;\n        WIRE_TRY(GetSpace(allocator, stringLength + 1, &copiedString));\n        memcpy(copiedString, const_cast<const char*>(stringInBuffer), stringLength);\n        copiedString[stringLength] = '\\0';\n        record->vendorName = copiedString;\n    }\n    {\n        uint64_t stringLength64 = transfer->architectureStrlen;\n        if (stringLength64 >= std::numeric_limits<size_t>::max()) {\n            return WireResult::FatalError;\n        }\n        size_t stringLength = static_cast<size_t>(stringLength64);\n\n        const volatile char* stringInBuffer;\n        WIRE_TRY(deserializeBuffer->ReadN(stringLength, &stringInBuffer));\n\n        char* copiedString;\n        WIRE_TRY(GetSpace(allocator, stringLength + 1, &copiedString));\n        memcpy(copiedString, const_cast<const char*>(stringInBuffer), stringLength);\n        copiedString[stringLength] = '\\0';\n        record->architecture = copiedString;\n    }\n    {\n        uint64_t stringLength64 = transfer->nameStrlen;\n        if (stringLength64 >= std::numeric_limits<size_t>::max()) {\n            return WireResult::FatalError;\n        }\n        size_t stringLength = static_cast<size_t>(stringLength64);\n\n        const volatile char* stringInBuffer;\n        WIRE_TRY(deserializeBuffer->ReadN(stringLength, &stringInBuffer));\n\n        char* copiedString;\n        WIRE_TRY(GetSpace(allocator, stringLength + 1, &copiedString));\n        memcpy(copiedString, const_cast<const char*>(stringInBuffer), stringLength);\n        copiedString[stringLength] = '\\0';\n        record->name = copiedString;\n    }\n    {\n        uint64_t stringLength64 = transfer->driverDescriptionStrlen;\n        if (stringLength64 >= std::numeric_limits<size_t>::max()) {\n            return WireResult::FatalError;\n        }\n        size_t stringLength = static_cast<size_t>(stringLength64);\n\n        const volatile char* stringInBuffer;\n        WIRE_TRY(deserializeBuffer->ReadN(stringLength, &stringInBuffer));\n\n        char* copiedString;\n        WIRE_TRY(GetSpace(allocator, stringLength + 1, &copiedString));\n        memcpy(copiedString, const_cast<const char*>(stringInBuffer), stringLength);\n        copiedString[stringLength] = '\\0';\n        record->driverDescription = copiedString;\n    }\n\n    return WireResult::Success;\n}\nDAWN_UNUSED_FUNC(WGPUAdapterPropertiesDeserialize);\n\nstruct WGPUBindGroupEntryTransfer {\n    static_assert(0 <= 1,\n                  \"Record must be at most one of is_cmd, extensible, and chained.\");\n    bool hasNextInChain;\n\n    uint32_t binding;\n    ObjectId buffer;\n    uint64_t offset;\n    uint64_t size;\n    ObjectId sampler;\n    ObjectId textureView;\n};\n\n\nDAWN_DECLARE_UNUSED size_t WGPUBindGroupEntryGetExtraRequiredSize(const WGPUBindGroupEntry& record) {\n    DAWN_UNUSED(record);\n    size_t result = 0;\n\n    if (record.nextInChain != nullptr) {\n        result += GetChainedStructExtraRequiredSize(record.nextInChain);\n    }\n    return result;\n}\n// GetExtraRequiredSize isn't used for structures that are value members of other structures\n// because we assume they cannot contain pointers themselves.\nDAWN_UNUSED_FUNC(WGPUBindGroupEntryGetExtraRequiredSize);\n\nDAWN_DECLARE_UNUSED WireResult WGPUBindGroupEntrySerialize(\n    const WGPUBindGroupEntry& record,\n    WGPUBindGroupEntryTransfer* transfer,\n    SerializeBuffer* buffer, const ObjectIdProvider& provider) {\n    DAWN_UNUSED(buffer);\n\n    if (record.nextInChain != nullptr) {\n        transfer->hasNextInChain = true;\n        WIRE_TRY(SerializeChainedStruct(record.nextInChain, buffer, provider));\n    } else {\n        transfer->hasNextInChain = false;\n    }\n\n    transfer->binding = record.binding;\n    WIRE_TRY(provider.GetOptionalId(record.buffer, &transfer->buffer));\n    transfer->offset = record.offset;\n    transfer->size = record.size;\n    WIRE_TRY(provider.GetOptionalId(record.sampler, &transfer->sampler));\n    WIRE_TRY(provider.GetOptionalId(record.textureView, &transfer->textureView));\n\n    return WireResult::Success;\n}\nDAWN_UNUSED_FUNC(WGPUBindGroupEntrySerialize);\n\nDAWN_DECLARE_UNUSED WireResult WGPUBindGroupEntryDeserialize(\n    WGPUBindGroupEntry* record,\n    const volatile WGPUBindGroupEntryTransfer* transfer,\n    DeserializeBuffer* deserializeBuffer,\n    DeserializeAllocator* allocator, const ObjectIdResolver& resolver) {\n    DAWN_UNUSED(allocator);\n\n\n    record->nextInChain = nullptr;\n    if (transfer->hasNextInChain) {\n        WIRE_TRY(DeserializeChainedStruct(&record->nextInChain, deserializeBuffer, allocator, resolver));\n    }\n\n    static_assert(sizeof(record->binding) >= sizeof(transfer->binding), \"Deserialize assignment may not narrow.\");\n    record->binding = transfer->binding;\n    WIRE_TRY(resolver.GetOptionalFromId(transfer->buffer, &record->buffer));\n    static_assert(sizeof(record->offset) >= sizeof(transfer->offset), \"Deserialize assignment may not narrow.\");\n    record->offset = transfer->offset;\n    static_assert(sizeof(record->size) >= sizeof(transfer->size), \"Deserialize assignment may not narrow.\");\n    record->size = transfer->size;\n    WIRE_TRY(resolver.GetOptionalFromId(transfer->sampler, &record->sampler));\n    WIRE_TRY(resolver.GetOptionalFromId(transfer->textureView, &record->textureView));\n\n    return WireResult::Success;\n}\nDAWN_UNUSED_FUNC(WGPUBindGroupEntryDeserialize);\n\nstruct WGPUBlendComponentTransfer {\n    static_assert(0 <= 1,\n                  \"Record must be at most one of is_cmd, extensible, and chained.\");\n\n    WGPUBlendOperation operation;\n    WGPUBlendFactor srcFactor;\n    WGPUBlendFactor dstFactor;\n};\n\n\nDAWN_DECLARE_UNUSED size_t WGPUBlendComponentGetExtraRequiredSize(const WGPUBlendComponent& record) {\n    DAWN_UNUSED(record);\n    size_t result = 0;\n\n    return result;\n}\n// GetExtraRequiredSize isn't used for structures that are value members of other structures\n// because we assume they cannot contain pointers themselves.\nDAWN_UNUSED_FUNC(WGPUBlendComponentGetExtraRequiredSize);\n\nDAWN_DECLARE_UNUSED WireResult WGPUBlendComponentSerialize(\n    const WGPUBlendComponent& record,\n    WGPUBlendComponentTransfer* transfer,\n    SerializeBuffer* buffer) {\n    DAWN_UNUSED(buffer);\n\n\n    transfer->operation = record.operation;\n    transfer->srcFactor = record.srcFactor;\n    transfer->dstFactor = record.dstFactor;\n\n    return WireResult::Success;\n}\nDAWN_UNUSED_FUNC(WGPUBlendComponentSerialize);\n\nDAWN_DECLARE_UNUSED WireResult WGPUBlendComponentDeserialize(\n    WGPUBlendComponent* record,\n    const volatile WGPUBlendComponentTransfer* transfer,\n    DeserializeBuffer* deserializeBuffer,\n    DeserializeAllocator* allocator) {\n    DAWN_UNUSED(allocator);\n\n\n\n    static_assert(sizeof(record->operation) >= sizeof(transfer->operation), \"Deserialize assignment may not narrow.\");\n    record->operation = transfer->operation;\n    static_assert(sizeof(record->srcFactor) >= sizeof(transfer->srcFactor), \"Deserialize assignment may not narrow.\");\n    record->srcFactor = transfer->srcFactor;\n    static_assert(sizeof(record->dstFactor) >= sizeof(transfer->dstFactor), \"Deserialize assignment may not narrow.\");\n    record->dstFactor = transfer->dstFactor;\n\n    return WireResult::Success;\n}\nDAWN_UNUSED_FUNC(WGPUBlendComponentDeserialize);\n\nstruct WGPUBufferBindingLayoutTransfer {\n    static_assert(0 <= 1,\n                  \"Record must be at most one of is_cmd, extensible, and chained.\");\n    bool hasNextInChain;\n\n    WGPUBufferBindingType type;\n    bool hasDynamicOffset;\n    uint64_t minBindingSize;\n};\n\n\nDAWN_DECLARE_UNUSED size_t WGPUBufferBindingLayoutGetExtraRequiredSize(const WGPUBufferBindingLayout& record) {\n    DAWN_UNUSED(record);\n    size_t result = 0;\n\n    if (record.nextInChain != nullptr) {\n        result += GetChainedStructExtraRequiredSize(record.nextInChain);\n    }\n    return result;\n}\n// GetExtraRequiredSize isn't used for structures that are value members of other structures\n// because we assume they cannot contain pointers themselves.\nDAWN_UNUSED_FUNC(WGPUBufferBindingLayoutGetExtraRequiredSize);\n\nDAWN_DECLARE_UNUSED WireResult WGPUBufferBindingLayoutSerialize(\n    const WGPUBufferBindingLayout& record,\n    WGPUBufferBindingLayoutTransfer* transfer,\n    SerializeBuffer* buffer, const ObjectIdProvider& provider) {\n    DAWN_UNUSED(buffer);\n\n    if (record.nextInChain != nullptr) {\n        transfer->hasNextInChain = true;\n        WIRE_TRY(SerializeChainedStruct(record.nextInChain, buffer, provider));\n    } else {\n        transfer->hasNextInChain = false;\n    }\n\n    transfer->type = record.type;\n    transfer->hasDynamicOffset = record.hasDynamicOffset;\n    transfer->minBindingSize = record.minBindingSize;\n\n    return WireResult::Success;\n}\nDAWN_UNUSED_FUNC(WGPUBufferBindingLayoutSerialize);\n\nDAWN_DECLARE_UNUSED WireResult WGPUBufferBindingLayoutDeserialize(\n    WGPUBufferBindingLayout* record,\n    const volatile WGPUBufferBindingLayoutTransfer* transfer,\n    DeserializeBuffer* deserializeBuffer,\n    DeserializeAllocator* allocator, const ObjectIdResolver& resolver) {\n    DAWN_UNUSED(allocator);\n\n\n    record->nextInChain = nullptr;\n    if (transfer->hasNextInChain) {\n        WIRE_TRY(DeserializeChainedStruct(&record->nextInChain, deserializeBuffer, allocator, resolver));\n    }\n\n    static_assert(sizeof(record->type) >= sizeof(transfer->type), \"Deserialize assignment may not narrow.\");\n    record->type = transfer->type;\n    static_assert(sizeof(record->hasDynamicOffset) >= sizeof(transfer->hasDynamicOffset), \"Deserialize assignment may not narrow.\");\n    record->hasDynamicOffset = transfer->hasDynamicOffset;\n    static_assert(sizeof(record->minBindingSize) >= sizeof(transfer->minBindingSize), \"Deserialize assignment may not narrow.\");\n    record->minBindingSize = transfer->minBindingSize;\n\n    return WireResult::Success;\n}\nDAWN_UNUSED_FUNC(WGPUBufferBindingLayoutDeserialize);\n\nstruct WGPUBufferDescriptorTransfer {\n    static_assert(0 <= 1,\n                  \"Record must be at most one of is_cmd, extensible, and chained.\");\n    bool hasNextInChain;\n\n    uint64_t labelStrlen;\n    bool has_label;\n    WGPUBufferUsageFlags usage;\n    uint64_t size;\n    bool mappedAtCreation;\n};\n\n\nDAWN_DECLARE_UNUSED size_t WGPUBufferDescriptorGetExtraRequiredSize(const WGPUBufferDescriptor& record) {\n    DAWN_UNUSED(record);\n    size_t result = 0;\n\n    if (record.nextInChain != nullptr) {\n        result += GetChainedStructExtraRequiredSize(record.nextInChain);\n    }\n    if (record.label != nullptr) {\n        result += Align(std::strlen(record.label), kWireBufferAlignment);\n    }\n    return result;\n}\n// GetExtraRequiredSize isn't used for structures that are value members of other structures\n// because we assume they cannot contain pointers themselves.\nDAWN_UNUSED_FUNC(WGPUBufferDescriptorGetExtraRequiredSize);\n\nDAWN_DECLARE_UNUSED WireResult WGPUBufferDescriptorSerialize(\n    const WGPUBufferDescriptor& record,\n    WGPUBufferDescriptorTransfer* transfer,\n    SerializeBuffer* buffer, const ObjectIdProvider& provider) {\n    DAWN_UNUSED(buffer);\n\n    if (record.nextInChain != nullptr) {\n        transfer->hasNextInChain = true;\n        WIRE_TRY(SerializeChainedStruct(record.nextInChain, buffer, provider));\n    } else {\n        transfer->hasNextInChain = false;\n    }\n\n    transfer->usage = record.usage;\n    transfer->size = record.size;\n    transfer->mappedAtCreation = record.mappedAtCreation;\n    bool has_label = record.label != nullptr;\n    transfer->has_label = has_label;\n    if (has_label) {\n        transfer->labelStrlen = std::strlen(record.label);\n\n        char* stringInBuffer;\n        WIRE_TRY(buffer->NextN(transfer->labelStrlen, &stringInBuffer));\n        memcpy(stringInBuffer, record.label, transfer->labelStrlen);\n    }\n\n    return WireResult::Success;\n}\nDAWN_UNUSED_FUNC(WGPUBufferDescriptorSerialize);\n\nDAWN_DECLARE_UNUSED WireResult WGPUBufferDescriptorDeserialize(\n    WGPUBufferDescriptor* record,\n    const volatile WGPUBufferDescriptorTransfer* transfer,\n    DeserializeBuffer* deserializeBuffer,\n    DeserializeAllocator* allocator, const ObjectIdResolver& resolver) {\n    DAWN_UNUSED(allocator);\n\n\n    record->nextInChain = nullptr;\n    if (transfer->hasNextInChain) {\n        WIRE_TRY(DeserializeChainedStruct(&record->nextInChain, deserializeBuffer, allocator, resolver));\n    }\n\n    static_assert(sizeof(record->usage) >= sizeof(transfer->usage), \"Deserialize assignment may not narrow.\");\n    record->usage = transfer->usage;\n    static_assert(sizeof(record->size) >= sizeof(transfer->size), \"Deserialize assignment may not narrow.\");\n    record->size = transfer->size;\n    static_assert(sizeof(record->mappedAtCreation) >= sizeof(transfer->mappedAtCreation), \"Deserialize assignment may not narrow.\");\n    record->mappedAtCreation = transfer->mappedAtCreation;\n    bool has_label = transfer->has_label;\n    record->label = nullptr;\n    if (has_label) {\n        uint64_t stringLength64 = transfer->labelStrlen;\n        if (stringLength64 >= std::numeric_limits<size_t>::max()) {\n            return WireResult::FatalError;\n        }\n        size_t stringLength = static_cast<size_t>(stringLength64);\n\n        const volatile char* stringInBuffer;\n        WIRE_TRY(deserializeBuffer->ReadN(stringLength, &stringInBuffer));\n\n        char* copiedString;\n        WIRE_TRY(GetSpace(allocator, stringLength + 1, &copiedString));\n        memcpy(copiedString, const_cast<const char*>(stringInBuffer), stringLength);\n        copiedString[stringLength] = '\\0';\n        record->label = copiedString;\n    }\n\n    return WireResult::Success;\n}\nDAWN_UNUSED_FUNC(WGPUBufferDescriptorDeserialize);\n\nstruct WGPUColorTransfer {\n    static_assert(0 <= 1,\n                  \"Record must be at most one of is_cmd, extensible, and chained.\");\n\n    double r;\n    double g;\n    double b;\n    double a;\n};\n\n\nDAWN_DECLARE_UNUSED size_t WGPUColorGetExtraRequiredSize(const WGPUColor& record) {\n    DAWN_UNUSED(record);\n    size_t result = 0;\n\n    return result;\n}\n// GetExtraRequiredSize isn't used for structures that are value members of other structures\n// because we assume they cannot contain pointers themselves.\nDAWN_UNUSED_FUNC(WGPUColorGetExtraRequiredSize);\n\nDAWN_DECLARE_UNUSED WireResult WGPUColorSerialize(\n    const WGPUColor& record,\n    WGPUColorTransfer* transfer,\n    SerializeBuffer* buffer) {\n    DAWN_UNUSED(buffer);\n\n\n    transfer->r = record.r;\n    transfer->g = record.g;\n    transfer->b = record.b;\n    transfer->a = record.a;\n\n    return WireResult::Success;\n}\nDAWN_UNUSED_FUNC(WGPUColorSerialize);\n\nDAWN_DECLARE_UNUSED WireResult WGPUColorDeserialize(\n    WGPUColor* record,\n    const volatile WGPUColorTransfer* transfer,\n    DeserializeBuffer* deserializeBuffer,\n    DeserializeAllocator* allocator) {\n    DAWN_UNUSED(allocator);\n\n\n\n    static_assert(sizeof(record->r) >= sizeof(transfer->r), \"Deserialize assignment may not narrow.\");\n    record->r = transfer->r;\n    static_assert(sizeof(record->g) >= sizeof(transfer->g), \"Deserialize assignment may not narrow.\");\n    record->g = transfer->g;\n    static_assert(sizeof(record->b) >= sizeof(transfer->b), \"Deserialize assignment may not narrow.\");\n    record->b = transfer->b;\n    static_assert(sizeof(record->a) >= sizeof(transfer->a), \"Deserialize assignment may not narrow.\");\n    record->a = transfer->a;\n\n    return WireResult::Success;\n}\nDAWN_UNUSED_FUNC(WGPUColorDeserialize);\n\nstruct WGPUCommandBufferDescriptorTransfer {\n    static_assert(0 <= 1,\n                  \"Record must be at most one of is_cmd, extensible, and chained.\");\n    bool hasNextInChain;\n\n    uint64_t labelStrlen;\n    bool has_label;\n};\n\n\nDAWN_DECLARE_UNUSED size_t WGPUCommandBufferDescriptorGetExtraRequiredSize(const WGPUCommandBufferDescriptor& record) {\n    DAWN_UNUSED(record);\n    size_t result = 0;\n\n    if (record.nextInChain != nullptr) {\n        result += GetChainedStructExtraRequiredSize(record.nextInChain);\n    }\n    if (record.label != nullptr) {\n        result += Align(std::strlen(record.label), kWireBufferAlignment);\n    }\n    return result;\n}\n// GetExtraRequiredSize isn't used for structures that are value members of other structures\n// because we assume they cannot contain pointers themselves.\nDAWN_UNUSED_FUNC(WGPUCommandBufferDescriptorGetExtraRequiredSize);\n\nDAWN_DECLARE_UNUSED WireResult WGPUCommandBufferDescriptorSerialize(\n    const WGPUCommandBufferDescriptor& record,\n    WGPUCommandBufferDescriptorTransfer* transfer,\n    SerializeBuffer* buffer, const ObjectIdProvider& provider) {\n    DAWN_UNUSED(buffer);\n\n    if (record.nextInChain != nullptr) {\n        transfer->hasNextInChain = true;\n        WIRE_TRY(SerializeChainedStruct(record.nextInChain, buffer, provider));\n    } else {\n        transfer->hasNextInChain = false;\n    }\n\n    bool has_label = record.label != nullptr;\n    transfer->has_label = has_label;\n    if (has_label) {\n        transfer->labelStrlen = std::strlen(record.label);\n\n        char* stringInBuffer;\n        WIRE_TRY(buffer->NextN(transfer->labelStrlen, &stringInBuffer));\n        memcpy(stringInBuffer, record.label, transfer->labelStrlen);\n    }\n\n    return WireResult::Success;\n}\nDAWN_UNUSED_FUNC(WGPUCommandBufferDescriptorSerialize);\n\nDAWN_DECLARE_UNUSED WireResult WGPUCommandBufferDescriptorDeserialize(\n    WGPUCommandBufferDescriptor* record,\n    const volatile WGPUCommandBufferDescriptorTransfer* transfer,\n    DeserializeBuffer* deserializeBuffer,\n    DeserializeAllocator* allocator, const ObjectIdResolver& resolver) {\n    DAWN_UNUSED(allocator);\n\n\n    record->nextInChain = nullptr;\n    if (transfer->hasNextInChain) {\n        WIRE_TRY(DeserializeChainedStruct(&record->nextInChain, deserializeBuffer, allocator, resolver));\n    }\n\n    bool has_label = transfer->has_label;\n    record->label = nullptr;\n    if (has_label) {\n        uint64_t stringLength64 = transfer->labelStrlen;\n        if (stringLength64 >= std::numeric_limits<size_t>::max()) {\n            return WireResult::FatalError;\n        }\n        size_t stringLength = static_cast<size_t>(stringLength64);\n\n        const volatile char* stringInBuffer;\n        WIRE_TRY(deserializeBuffer->ReadN(stringLength, &stringInBuffer));\n\n        char* copiedString;\n        WIRE_TRY(GetSpace(allocator, stringLength + 1, &copiedString));\n        memcpy(copiedString, const_cast<const char*>(stringInBuffer), stringLength);\n        copiedString[stringLength] = '\\0';\n        record->label = copiedString;\n    }\n\n    return WireResult::Success;\n}\nDAWN_UNUSED_FUNC(WGPUCommandBufferDescriptorDeserialize);\n\nstruct WGPUCommandEncoderDescriptorTransfer {\n    static_assert(0 <= 1,\n                  \"Record must be at most one of is_cmd, extensible, and chained.\");\n    bool hasNextInChain;\n\n    uint64_t labelStrlen;\n    bool has_label;\n};\n\n\nDAWN_DECLARE_UNUSED size_t WGPUCommandEncoderDescriptorGetExtraRequiredSize(const WGPUCommandEncoderDescriptor& record) {\n    DAWN_UNUSED(record);\n    size_t result = 0;\n\n    if (record.nextInChain != nullptr) {\n        result += GetChainedStructExtraRequiredSize(record.nextInChain);\n    }\n    if (record.label != nullptr) {\n        result += Align(std::strlen(record.label), kWireBufferAlignment);\n    }\n    return result;\n}\n// GetExtraRequiredSize isn't used for structures that are value members of other structures\n// because we assume they cannot contain pointers themselves.\nDAWN_UNUSED_FUNC(WGPUCommandEncoderDescriptorGetExtraRequiredSize);\n\nDAWN_DECLARE_UNUSED WireResult WGPUCommandEncoderDescriptorSerialize(\n    const WGPUCommandEncoderDescriptor& record,\n    WGPUCommandEncoderDescriptorTransfer* transfer,\n    SerializeBuffer* buffer, const ObjectIdProvider& provider) {\n    DAWN_UNUSED(buffer);\n\n    if (record.nextInChain != nullptr) {\n        transfer->hasNextInChain = true;\n        WIRE_TRY(SerializeChainedStruct(record.nextInChain, buffer, provider));\n    } else {\n        transfer->hasNextInChain = false;\n    }\n\n    bool has_label = record.label != nullptr;\n    transfer->has_label = has_label;\n    if (has_label) {\n        transfer->labelStrlen = std::strlen(record.label);\n\n        char* stringInBuffer;\n        WIRE_TRY(buffer->NextN(transfer->labelStrlen, &stringInBuffer));\n        memcpy(stringInBuffer, record.label, transfer->labelStrlen);\n    }\n\n    return WireResult::Success;\n}\nDAWN_UNUSED_FUNC(WGPUCommandEncoderDescriptorSerialize);\n\nDAWN_DECLARE_UNUSED WireResult WGPUCommandEncoderDescriptorDeserialize(\n    WGPUCommandEncoderDescriptor* record,\n    const volatile WGPUCommandEncoderDescriptorTransfer* transfer,\n    DeserializeBuffer* deserializeBuffer,\n    DeserializeAllocator* allocator, const ObjectIdResolver& resolver) {\n    DAWN_UNUSED(allocator);\n\n\n    record->nextInChain = nullptr;\n    if (transfer->hasNextInChain) {\n        WIRE_TRY(DeserializeChainedStruct(&record->nextInChain, deserializeBuffer, allocator, resolver));\n    }\n\n    bool has_label = transfer->has_label;\n    record->label = nullptr;\n    if (has_label) {\n        uint64_t stringLength64 = transfer->labelStrlen;\n        if (stringLength64 >= std::numeric_limits<size_t>::max()) {\n            return WireResult::FatalError;\n        }\n        size_t stringLength = static_cast<size_t>(stringLength64);\n\n        const volatile char* stringInBuffer;\n        WIRE_TRY(deserializeBuffer->ReadN(stringLength, &stringInBuffer));\n\n        char* copiedString;\n        WIRE_TRY(GetSpace(allocator, stringLength + 1, &copiedString));\n        memcpy(copiedString, const_cast<const char*>(stringInBuffer), stringLength);\n        copiedString[stringLength] = '\\0';\n        record->label = copiedString;\n    }\n\n    return WireResult::Success;\n}\nDAWN_UNUSED_FUNC(WGPUCommandEncoderDescriptorDeserialize);\n\nstruct WGPUCompilationMessageTransfer {\n    static_assert(0 <= 1,\n                  \"Record must be at most one of is_cmd, extensible, and chained.\");\n    bool hasNextInChain;\n\n    uint64_t messageStrlen;\n    bool has_message;\n    WGPUCompilationMessageType type;\n    uint64_t lineNum;\n    uint64_t linePos;\n    uint64_t offset;\n    uint64_t length;\n    uint64_t utf16LinePos;\n    uint64_t utf16Offset;\n    uint64_t utf16Length;\n};\n\n\nDAWN_DECLARE_UNUSED size_t WGPUCompilationMessageGetExtraRequiredSize(const WGPUCompilationMessage& record) {\n    DAWN_UNUSED(record);\n    size_t result = 0;\n\n    if (record.nextInChain != nullptr) {\n        result += GetChainedStructExtraRequiredSize(record.nextInChain);\n    }\n    if (record.message != nullptr) {\n        result += Align(std::strlen(record.message), kWireBufferAlignment);\n    }\n    return result;\n}\n// GetExtraRequiredSize isn't used for structures that are value members of other structures\n// because we assume they cannot contain pointers themselves.\nDAWN_UNUSED_FUNC(WGPUCompilationMessageGetExtraRequiredSize);\n\nDAWN_DECLARE_UNUSED WireResult WGPUCompilationMessageSerialize(\n    const WGPUCompilationMessage& record,\n    WGPUCompilationMessageTransfer* transfer,\n    SerializeBuffer* buffer, const ObjectIdProvider& provider) {\n    DAWN_UNUSED(buffer);\n\n    if (record.nextInChain != nullptr) {\n        transfer->hasNextInChain = true;\n        WIRE_TRY(SerializeChainedStruct(record.nextInChain, buffer, provider));\n    } else {\n        transfer->hasNextInChain = false;\n    }\n\n    transfer->type = record.type;\n    transfer->lineNum = record.lineNum;\n    transfer->linePos = record.linePos;\n    transfer->offset = record.offset;\n    transfer->length = record.length;\n    transfer->utf16LinePos = record.utf16LinePos;\n    transfer->utf16Offset = record.utf16Offset;\n    transfer->utf16Length = record.utf16Length;\n    bool has_message = record.message != nullptr;\n    transfer->has_message = has_message;\n    if (has_message) {\n        transfer->messageStrlen = std::strlen(record.message);\n\n        char* stringInBuffer;\n        WIRE_TRY(buffer->NextN(transfer->messageStrlen, &stringInBuffer));\n        memcpy(stringInBuffer, record.message, transfer->messageStrlen);\n    }\n\n    return WireResult::Success;\n}\nDAWN_UNUSED_FUNC(WGPUCompilationMessageSerialize);\n\nDAWN_DECLARE_UNUSED WireResult WGPUCompilationMessageDeserialize(\n    WGPUCompilationMessage* record,\n    const volatile WGPUCompilationMessageTransfer* transfer,\n    DeserializeBuffer* deserializeBuffer,\n    DeserializeAllocator* allocator, const ObjectIdResolver& resolver) {\n    DAWN_UNUSED(allocator);\n\n\n    record->nextInChain = nullptr;\n    if (transfer->hasNextInChain) {\n        WIRE_TRY(DeserializeChainedStruct(&record->nextInChain, deserializeBuffer, allocator, resolver));\n    }\n\n    static_assert(sizeof(record->type) >= sizeof(transfer->type), \"Deserialize assignment may not narrow.\");\n    record->type = transfer->type;\n    static_assert(sizeof(record->lineNum) >= sizeof(transfer->lineNum), \"Deserialize assignment may not narrow.\");\n    record->lineNum = transfer->lineNum;\n    static_assert(sizeof(record->linePos) >= sizeof(transfer->linePos), \"Deserialize assignment may not narrow.\");\n    record->linePos = transfer->linePos;\n    static_assert(sizeof(record->offset) >= sizeof(transfer->offset), \"Deserialize assignment may not narrow.\");\n    record->offset = transfer->offset;\n    static_assert(sizeof(record->length) >= sizeof(transfer->length), \"Deserialize assignment may not narrow.\");\n    record->length = transfer->length;\n    static_assert(sizeof(record->utf16LinePos) >= sizeof(transfer->utf16LinePos), \"Deserialize assignment may not narrow.\");\n    record->utf16LinePos = transfer->utf16LinePos;\n    static_assert(sizeof(record->utf16Offset) >= sizeof(transfer->utf16Offset), \"Deserialize assignment may not narrow.\");\n    record->utf16Offset = transfer->utf16Offset;\n    static_assert(sizeof(record->utf16Length) >= sizeof(transfer->utf16Length), \"Deserialize assignment may not narrow.\");\n    record->utf16Length = transfer->utf16Length;\n    bool has_message = transfer->has_message;\n    record->message = nullptr;\n    if (has_message) {\n        uint64_t stringLength64 = transfer->messageStrlen;\n        if (stringLength64 >= std::numeric_limits<size_t>::max()) {\n            return WireResult::FatalError;\n        }\n        size_t stringLength = static_cast<size_t>(stringLength64);\n\n        const volatile char* stringInBuffer;\n        WIRE_TRY(deserializeBuffer->ReadN(stringLength, &stringInBuffer));\n\n        char* copiedString;\n        WIRE_TRY(GetSpace(allocator, stringLength + 1, &copiedString));\n        memcpy(copiedString, const_cast<const char*>(stringInBuffer), stringLength);\n        copiedString[stringLength] = '\\0';\n        record->message = copiedString;\n    }\n\n    return WireResult::Success;\n}\nDAWN_UNUSED_FUNC(WGPUCompilationMessageDeserialize);\n\nstruct WGPUComputePassTimestampWriteTransfer {\n    static_assert(0 <= 1,\n                  \"Record must be at most one of is_cmd, extensible, and chained.\");\n\n    ObjectId querySet;\n    uint32_t queryIndex;\n    WGPUComputePassTimestampLocation location;\n};\n\n\nDAWN_DECLARE_UNUSED size_t WGPUComputePassTimestampWriteGetExtraRequiredSize(const WGPUComputePassTimestampWrite& record) {\n    DAWN_UNUSED(record);\n    size_t result = 0;\n\n    return result;\n}\n// GetExtraRequiredSize isn't used for structures that are value members of other structures\n// because we assume they cannot contain pointers themselves.\nDAWN_UNUSED_FUNC(WGPUComputePassTimestampWriteGetExtraRequiredSize);\n\nDAWN_DECLARE_UNUSED WireResult WGPUComputePassTimestampWriteSerialize(\n    const WGPUComputePassTimestampWrite& record,\n    WGPUComputePassTimestampWriteTransfer* transfer,\n    SerializeBuffer* buffer, const ObjectIdProvider& provider) {\n    DAWN_UNUSED(buffer);\n\n\n    WIRE_TRY(provider.GetId(record.querySet, &transfer->querySet));\n    transfer->queryIndex = record.queryIndex;\n    transfer->location = record.location;\n\n    return WireResult::Success;\n}\nDAWN_UNUSED_FUNC(WGPUComputePassTimestampWriteSerialize);\n\nDAWN_DECLARE_UNUSED WireResult WGPUComputePassTimestampWriteDeserialize(\n    WGPUComputePassTimestampWrite* record,\n    const volatile WGPUComputePassTimestampWriteTransfer* transfer,\n    DeserializeBuffer* deserializeBuffer,\n    DeserializeAllocator* allocator, const ObjectIdResolver& resolver) {\n    DAWN_UNUSED(allocator);\n\n\n\n    WIRE_TRY(resolver.GetFromId(transfer->querySet, &record->querySet));\n    static_assert(sizeof(record->queryIndex) >= sizeof(transfer->queryIndex), \"Deserialize assignment may not narrow.\");\n    record->queryIndex = transfer->queryIndex;\n    static_assert(sizeof(record->location) >= sizeof(transfer->location), \"Deserialize assignment may not narrow.\");\n    record->location = transfer->location;\n\n    return WireResult::Success;\n}\nDAWN_UNUSED_FUNC(WGPUComputePassTimestampWriteDeserialize);\n\nstruct WGPUConstantEntryTransfer {\n    static_assert(0 <= 1,\n                  \"Record must be at most one of is_cmd, extensible, and chained.\");\n    bool hasNextInChain;\n\n    uint64_t keyStrlen;\n    double value;\n};\n\n\nDAWN_DECLARE_UNUSED size_t WGPUConstantEntryGetExtraRequiredSize(const WGPUConstantEntry& record) {\n    DAWN_UNUSED(record);\n    size_t result = 0;\n\n    if (record.nextInChain != nullptr) {\n        result += GetChainedStructExtraRequiredSize(record.nextInChain);\n    }\n    ASSERT(record.key != nullptr);\n    result += Align(std::strlen(record.key), kWireBufferAlignment);\n    return result;\n}\n// GetExtraRequiredSize isn't used for structures that are value members of other structures\n// because we assume they cannot contain pointers themselves.\nDAWN_UNUSED_FUNC(WGPUConstantEntryGetExtraRequiredSize);\n\nDAWN_DECLARE_UNUSED WireResult WGPUConstantEntrySerialize(\n    const WGPUConstantEntry& record,\n    WGPUConstantEntryTransfer* transfer,\n    SerializeBuffer* buffer, const ObjectIdProvider& provider) {\n    DAWN_UNUSED(buffer);\n\n    if (record.nextInChain != nullptr) {\n        transfer->hasNextInChain = true;\n        WIRE_TRY(SerializeChainedStruct(record.nextInChain, buffer, provider));\n    } else {\n        transfer->hasNextInChain = false;\n    }\n\n    transfer->value = record.value;\n    {\n        transfer->keyStrlen = std::strlen(record.key);\n\n        char* stringInBuffer;\n        WIRE_TRY(buffer->NextN(transfer->keyStrlen, &stringInBuffer));\n        memcpy(stringInBuffer, record.key, transfer->keyStrlen);\n    }\n\n    return WireResult::Success;\n}\nDAWN_UNUSED_FUNC(WGPUConstantEntrySerialize);\n\nDAWN_DECLARE_UNUSED WireResult WGPUConstantEntryDeserialize(\n    WGPUConstantEntry* record,\n    const volatile WGPUConstantEntryTransfer* transfer,\n    DeserializeBuffer* deserializeBuffer,\n    DeserializeAllocator* allocator, const ObjectIdResolver& resolver) {\n    DAWN_UNUSED(allocator);\n\n\n    record->nextInChain = nullptr;\n    if (transfer->hasNextInChain) {\n        WIRE_TRY(DeserializeChainedStruct(&record->nextInChain, deserializeBuffer, allocator, resolver));\n    }\n\n    static_assert(sizeof(record->value) >= sizeof(transfer->value), \"Deserialize assignment may not narrow.\");\n    record->value = transfer->value;\n    {\n        uint64_t stringLength64 = transfer->keyStrlen;\n        if (stringLength64 >= std::numeric_limits<size_t>::max()) {\n            return WireResult::FatalError;\n        }\n        size_t stringLength = static_cast<size_t>(stringLength64);\n\n        const volatile char* stringInBuffer;\n        WIRE_TRY(deserializeBuffer->ReadN(stringLength, &stringInBuffer));\n\n        char* copiedString;\n        WIRE_TRY(GetSpace(allocator, stringLength + 1, &copiedString));\n        memcpy(copiedString, const_cast<const char*>(stringInBuffer), stringLength);\n        copiedString[stringLength] = '\\0';\n        record->key = copiedString;\n    }\n\n    return WireResult::Success;\n}\nDAWN_UNUSED_FUNC(WGPUConstantEntryDeserialize);\n\nstruct WGPUCopyTextureForBrowserOptionsTransfer {\n    static_assert(0 <= 1,\n                  \"Record must be at most one of is_cmd, extensible, and chained.\");\n    bool hasNextInChain;\n\n    bool flipY;\n    bool needsColorSpaceConversion;\n    WGPUAlphaMode srcAlphaMode;\n    bool has_srcTransferFunctionParameters;\n    bool has_conversionMatrix;\n    bool has_dstTransferFunctionParameters;\n    WGPUAlphaMode dstAlphaMode;\n    bool internalUsage;\n};\n\n\nDAWN_DECLARE_UNUSED size_t WGPUCopyTextureForBrowserOptionsGetExtraRequiredSize(const WGPUCopyTextureForBrowserOptions& record) {\n    DAWN_UNUSED(record);\n    size_t result = 0;\n\n    if (record.nextInChain != nullptr) {\n        result += GetChainedStructExtraRequiredSize(record.nextInChain);\n    }\n    if (record.srcTransferFunctionParameters != nullptr) {\n        auto memberLength = 7u;\n        auto size = WireAlignSizeofN<float>(memberLength);\n        ASSERT(size);\n        result += *size;\n    }\n    if (record.conversionMatrix != nullptr) {\n        auto memberLength = 9u;\n        auto size = WireAlignSizeofN<float>(memberLength);\n        ASSERT(size);\n        result += *size;\n    }\n    if (record.dstTransferFunctionParameters != nullptr) {\n        auto memberLength = 7u;\n        auto size = WireAlignSizeofN<float>(memberLength);\n        ASSERT(size);\n        result += *size;\n    }\n    return result;\n}\n// GetExtraRequiredSize isn't used for structures that are value members of other structures\n// because we assume they cannot contain pointers themselves.\nDAWN_UNUSED_FUNC(WGPUCopyTextureForBrowserOptionsGetExtraRequiredSize);\n\nDAWN_DECLARE_UNUSED WireResult WGPUCopyTextureForBrowserOptionsSerialize(\n    const WGPUCopyTextureForBrowserOptions& record,\n    WGPUCopyTextureForBrowserOptionsTransfer* transfer,\n    SerializeBuffer* buffer, const ObjectIdProvider& provider) {\n    DAWN_UNUSED(buffer);\n\n    if (record.nextInChain != nullptr) {\n        transfer->hasNextInChain = true;\n        WIRE_TRY(SerializeChainedStruct(record.nextInChain, buffer, provider));\n    } else {\n        transfer->hasNextInChain = false;\n    }\n\n    transfer->flipY = record.flipY;\n    transfer->needsColorSpaceConversion = record.needsColorSpaceConversion;\n    transfer->srcAlphaMode = record.srcAlphaMode;\n    transfer->dstAlphaMode = record.dstAlphaMode;\n    transfer->internalUsage = record.internalUsage;\n    bool has_srcTransferFunctionParameters = record.srcTransferFunctionParameters != nullptr;\n    transfer->has_srcTransferFunctionParameters = has_srcTransferFunctionParameters;\n    if (has_srcTransferFunctionParameters) {\n        auto memberLength = 7u;\n\n        float* memberBuffer;\n        WIRE_TRY(buffer->NextN(memberLength, &memberBuffer));\n\n        memcpy(\n            memberBuffer, record.srcTransferFunctionParameters,\n            sizeof(float) * memberLength);\n    }\n    bool has_conversionMatrix = record.conversionMatrix != nullptr;\n    transfer->has_conversionMatrix = has_conversionMatrix;\n    if (has_conversionMatrix) {\n        auto memberLength = 9u;\n\n        float* memberBuffer;\n        WIRE_TRY(buffer->NextN(memberLength, &memberBuffer));\n\n        memcpy(\n            memberBuffer, record.conversionMatrix,\n            sizeof(float) * memberLength);\n    }\n    bool has_dstTransferFunctionParameters = record.dstTransferFunctionParameters != nullptr;\n    transfer->has_dstTransferFunctionParameters = has_dstTransferFunctionParameters;\n    if (has_dstTransferFunctionParameters) {\n        auto memberLength = 7u;\n\n        float* memberBuffer;\n        WIRE_TRY(buffer->NextN(memberLength, &memberBuffer));\n\n        memcpy(\n            memberBuffer, record.dstTransferFunctionParameters,\n            sizeof(float) * memberLength);\n    }\n\n    return WireResult::Success;\n}\nDAWN_UNUSED_FUNC(WGPUCopyTextureForBrowserOptionsSerialize);\n\nDAWN_DECLARE_UNUSED WireResult WGPUCopyTextureForBrowserOptionsDeserialize(\n    WGPUCopyTextureForBrowserOptions* record,\n    const volatile WGPUCopyTextureForBrowserOptionsTransfer* transfer,\n    DeserializeBuffer* deserializeBuffer,\n    DeserializeAllocator* allocator, const ObjectIdResolver& resolver) {\n    DAWN_UNUSED(allocator);\n\n\n    record->nextInChain = nullptr;\n    if (transfer->hasNextInChain) {\n        WIRE_TRY(DeserializeChainedStruct(&record->nextInChain, deserializeBuffer, allocator, resolver));\n    }\n\n    static_assert(sizeof(record->flipY) >= sizeof(transfer->flipY), \"Deserialize assignment may not narrow.\");\n    record->flipY = transfer->flipY;\n    static_assert(sizeof(record->needsColorSpaceConversion) >= sizeof(transfer->needsColorSpaceConversion), \"Deserialize assignment may not narrow.\");\n    record->needsColorSpaceConversion = transfer->needsColorSpaceConversion;\n    static_assert(sizeof(record->srcAlphaMode) >= sizeof(transfer->srcAlphaMode), \"Deserialize assignment may not narrow.\");\n    record->srcAlphaMode = transfer->srcAlphaMode;\n    static_assert(sizeof(record->dstAlphaMode) >= sizeof(transfer->dstAlphaMode), \"Deserialize assignment may not narrow.\");\n    record->dstAlphaMode = transfer->dstAlphaMode;\n    static_assert(sizeof(record->internalUsage) >= sizeof(transfer->internalUsage), \"Deserialize assignment may not narrow.\");\n    record->internalUsage = transfer->internalUsage;\n    bool has_srcTransferFunctionParameters = transfer->has_srcTransferFunctionParameters;\n    record->srcTransferFunctionParameters = nullptr;\n    if (has_srcTransferFunctionParameters) {\n        auto memberLength = 7u;\n        const volatile float* memberBuffer;\n        WIRE_TRY(deserializeBuffer->ReadN(memberLength, &memberBuffer));\n\n        float* copiedMembers;\n        WIRE_TRY(GetSpace(allocator, memberLength, &copiedMembers));\n        record->srcTransferFunctionParameters = copiedMembers;\n\n        memcpy(\n            copiedMembers,\n            const_cast<const float*>(memberBuffer),\n           sizeof(float) * memberLength);\n    }\n    bool has_conversionMatrix = transfer->has_conversionMatrix;\n    record->conversionMatrix = nullptr;\n    if (has_conversionMatrix) {\n        auto memberLength = 9u;\n        const volatile float* memberBuffer;\n        WIRE_TRY(deserializeBuffer->ReadN(memberLength, &memberBuffer));\n\n        float* copiedMembers;\n        WIRE_TRY(GetSpace(allocator, memberLength, &copiedMembers));\n        record->conversionMatrix = copiedMembers;\n\n        memcpy(\n            copiedMembers,\n            const_cast<const float*>(memberBuffer),\n           sizeof(float) * memberLength);\n    }\n    bool has_dstTransferFunctionParameters = transfer->has_dstTransferFunctionParameters;\n    record->dstTransferFunctionParameters = nullptr;\n    if (has_dstTransferFunctionParameters) {\n        auto memberLength = 7u;\n        const volatile float* memberBuffer;\n        WIRE_TRY(deserializeBuffer->ReadN(memberLength, &memberBuffer));\n\n        float* copiedMembers;\n        WIRE_TRY(GetSpace(allocator, memberLength, &copiedMembers));\n        record->dstTransferFunctionParameters = copiedMembers;\n\n        memcpy(\n            copiedMembers,\n            const_cast<const float*>(memberBuffer),\n           sizeof(float) * memberLength);\n    }\n\n    return WireResult::Success;\n}\nDAWN_UNUSED_FUNC(WGPUCopyTextureForBrowserOptionsDeserialize);\n\nstruct WGPUDawnAdapterPropertiesPowerPreferenceTransfer {\n    static_assert(0 <= 1,\n                  \"Record must be at most one of is_cmd, extensible, and chained.\");\n    WGPUChainedStructTransfer chain;\n\n    WGPUPowerPreference powerPreference;\n};\n\nstatic_assert(offsetof(WGPUDawnAdapterPropertiesPowerPreferenceTransfer, chain) == 0);\n\nDAWN_DECLARE_UNUSED size_t WGPUDawnAdapterPropertiesPowerPreferenceGetExtraRequiredSize(const WGPUDawnAdapterPropertiesPowerPreference& record) {\n    DAWN_UNUSED(record);\n    size_t result = 0;\n\n    return result;\n}\n// GetExtraRequiredSize isn't used for structures that are value members of other structures\n// because we assume they cannot contain pointers themselves.\nDAWN_UNUSED_FUNC(WGPUDawnAdapterPropertiesPowerPreferenceGetExtraRequiredSize);\n\nDAWN_DECLARE_UNUSED WireResult WGPUDawnAdapterPropertiesPowerPreferenceSerialize(\n    const WGPUDawnAdapterPropertiesPowerPreference& record,\n    WGPUDawnAdapterPropertiesPowerPreferenceTransfer* transfer,\n    SerializeBuffer* buffer, const ObjectIdProvider& provider) {\n    DAWN_UNUSED(buffer);\n\n    ASSERT(transfer->chain.sType == WGPUSType_DawnAdapterPropertiesPowerPreference);\n    ASSERT(transfer->chain.hasNext == (record.chain.next != nullptr));\n\n    transfer->powerPreference = record.powerPreference;\n\n    return WireResult::Success;\n}\nDAWN_UNUSED_FUNC(WGPUDawnAdapterPropertiesPowerPreferenceSerialize);\n\nDAWN_DECLARE_UNUSED WireResult WGPUDawnAdapterPropertiesPowerPreferenceDeserialize(\n    WGPUDawnAdapterPropertiesPowerPreference* record,\n    const volatile WGPUDawnAdapterPropertiesPowerPreferenceTransfer* transfer,\n    DeserializeBuffer* deserializeBuffer,\n    DeserializeAllocator* allocator, const ObjectIdResolver& resolver) {\n    DAWN_UNUSED(allocator);\n\n\n    ASSERT(record->chain.sType == WGPUSType_DawnAdapterPropertiesPowerPreference);\n    ASSERT(record->chain.next == nullptr);\n\n    static_assert(sizeof(record->powerPreference) >= sizeof(transfer->powerPreference), \"Deserialize assignment may not narrow.\");\n    record->powerPreference = transfer->powerPreference;\n\n    return WireResult::Success;\n}\nDAWN_UNUSED_FUNC(WGPUDawnAdapterPropertiesPowerPreferenceDeserialize);\n\nstruct WGPUDawnBufferDescriptorErrorInfoFromWireClientTransfer {\n    static_assert(0 <= 1,\n                  \"Record must be at most one of is_cmd, extensible, and chained.\");\n    WGPUChainedStructTransfer chain;\n\n    bool outOfMemory;\n};\n\nstatic_assert(offsetof(WGPUDawnBufferDescriptorErrorInfoFromWireClientTransfer, chain) == 0);\n\nDAWN_DECLARE_UNUSED size_t WGPUDawnBufferDescriptorErrorInfoFromWireClientGetExtraRequiredSize(const WGPUDawnBufferDescriptorErrorInfoFromWireClient& record) {\n    DAWN_UNUSED(record);\n    size_t result = 0;\n\n    return result;\n}\n// GetExtraRequiredSize isn't used for structures that are value members of other structures\n// because we assume they cannot contain pointers themselves.\nDAWN_UNUSED_FUNC(WGPUDawnBufferDescriptorErrorInfoFromWireClientGetExtraRequiredSize);\n\nDAWN_DECLARE_UNUSED WireResult WGPUDawnBufferDescriptorErrorInfoFromWireClientSerialize(\n    const WGPUDawnBufferDescriptorErrorInfoFromWireClient& record,\n    WGPUDawnBufferDescriptorErrorInfoFromWireClientTransfer* transfer,\n    SerializeBuffer* buffer, const ObjectIdProvider& provider) {\n    DAWN_UNUSED(buffer);\n\n    ASSERT(transfer->chain.sType == WGPUSType_DawnBufferDescriptorErrorInfoFromWireClient);\n    ASSERT(transfer->chain.hasNext == (record.chain.next != nullptr));\n\n    transfer->outOfMemory = record.outOfMemory;\n\n    return WireResult::Success;\n}\nDAWN_UNUSED_FUNC(WGPUDawnBufferDescriptorErrorInfoFromWireClientSerialize);\n\nDAWN_DECLARE_UNUSED WireResult WGPUDawnBufferDescriptorErrorInfoFromWireClientDeserialize(\n    WGPUDawnBufferDescriptorErrorInfoFromWireClient* record,\n    const volatile WGPUDawnBufferDescriptorErrorInfoFromWireClientTransfer* transfer,\n    DeserializeBuffer* deserializeBuffer,\n    DeserializeAllocator* allocator, const ObjectIdResolver& resolver) {\n    DAWN_UNUSED(allocator);\n\n\n    ASSERT(record->chain.sType == WGPUSType_DawnBufferDescriptorErrorInfoFromWireClient);\n    ASSERT(record->chain.next == nullptr);\n\n    static_assert(sizeof(record->outOfMemory) >= sizeof(transfer->outOfMemory), \"Deserialize assignment may not narrow.\");\n    record->outOfMemory = transfer->outOfMemory;\n\n    return WireResult::Success;\n}\nDAWN_UNUSED_FUNC(WGPUDawnBufferDescriptorErrorInfoFromWireClientDeserialize);\n\nstruct WGPUDawnEncoderInternalUsageDescriptorTransfer {\n    static_assert(0 <= 1,\n                  \"Record must be at most one of is_cmd, extensible, and chained.\");\n    WGPUChainedStructTransfer chain;\n\n    bool useInternalUsages;\n};\n\nstatic_assert(offsetof(WGPUDawnEncoderInternalUsageDescriptorTransfer, chain) == 0);\n\nDAWN_DECLARE_UNUSED size_t WGPUDawnEncoderInternalUsageDescriptorGetExtraRequiredSize(const WGPUDawnEncoderInternalUsageDescriptor& record) {\n    DAWN_UNUSED(record);\n    size_t result = 0;\n\n    return result;\n}\n// GetExtraRequiredSize isn't used for structures that are value members of other structures\n// because we assume they cannot contain pointers themselves.\nDAWN_UNUSED_FUNC(WGPUDawnEncoderInternalUsageDescriptorGetExtraRequiredSize);\n\nDAWN_DECLARE_UNUSED WireResult WGPUDawnEncoderInternalUsageDescriptorSerialize(\n    const WGPUDawnEncoderInternalUsageDescriptor& record,\n    WGPUDawnEncoderInternalUsageDescriptorTransfer* transfer,\n    SerializeBuffer* buffer, const ObjectIdProvider& provider) {\n    DAWN_UNUSED(buffer);\n\n    ASSERT(transfer->chain.sType == WGPUSType_DawnEncoderInternalUsageDescriptor);\n    ASSERT(transfer->chain.hasNext == (record.chain.next != nullptr));\n\n    transfer->useInternalUsages = record.useInternalUsages;\n\n    return WireResult::Success;\n}\nDAWN_UNUSED_FUNC(WGPUDawnEncoderInternalUsageDescriptorSerialize);\n\nDAWN_DECLARE_UNUSED WireResult WGPUDawnEncoderInternalUsageDescriptorDeserialize(\n    WGPUDawnEncoderInternalUsageDescriptor* record,\n    const volatile WGPUDawnEncoderInternalUsageDescriptorTransfer* transfer,\n    DeserializeBuffer* deserializeBuffer,\n    DeserializeAllocator* allocator, const ObjectIdResolver& resolver) {\n    DAWN_UNUSED(allocator);\n\n\n    ASSERT(record->chain.sType == WGPUSType_DawnEncoderInternalUsageDescriptor);\n    ASSERT(record->chain.next == nullptr);\n\n    static_assert(sizeof(record->useInternalUsages) >= sizeof(transfer->useInternalUsages), \"Deserialize assignment may not narrow.\");\n    record->useInternalUsages = transfer->useInternalUsages;\n\n    return WireResult::Success;\n}\nDAWN_UNUSED_FUNC(WGPUDawnEncoderInternalUsageDescriptorDeserialize);\n\nstruct WGPUDawnMultisampleStateRenderToSingleSampledTransfer {\n    static_assert(0 <= 1,\n                  \"Record must be at most one of is_cmd, extensible, and chained.\");\n    WGPUChainedStructTransfer chain;\n\n    bool enabled;\n};\n\nstatic_assert(offsetof(WGPUDawnMultisampleStateRenderToSingleSampledTransfer, chain) == 0);\n\nDAWN_DECLARE_UNUSED size_t WGPUDawnMultisampleStateRenderToSingleSampledGetExtraRequiredSize(const WGPUDawnMultisampleStateRenderToSingleSampled& record) {\n    DAWN_UNUSED(record);\n    size_t result = 0;\n\n    return result;\n}\n// GetExtraRequiredSize isn't used for structures that are value members of other structures\n// because we assume they cannot contain pointers themselves.\nDAWN_UNUSED_FUNC(WGPUDawnMultisampleStateRenderToSingleSampledGetExtraRequiredSize);\n\nDAWN_DECLARE_UNUSED WireResult WGPUDawnMultisampleStateRenderToSingleSampledSerialize(\n    const WGPUDawnMultisampleStateRenderToSingleSampled& record,\n    WGPUDawnMultisampleStateRenderToSingleSampledTransfer* transfer,\n    SerializeBuffer* buffer, const ObjectIdProvider& provider) {\n    DAWN_UNUSED(buffer);\n\n    ASSERT(transfer->chain.sType == WGPUSType_DawnMultisampleStateRenderToSingleSampled);\n    ASSERT(transfer->chain.hasNext == (record.chain.next != nullptr));\n\n    transfer->enabled = record.enabled;\n\n    return WireResult::Success;\n}\nDAWN_UNUSED_FUNC(WGPUDawnMultisampleStateRenderToSingleSampledSerialize);\n\nDAWN_DECLARE_UNUSED WireResult WGPUDawnMultisampleStateRenderToSingleSampledDeserialize(\n    WGPUDawnMultisampleStateRenderToSingleSampled* record,\n    const volatile WGPUDawnMultisampleStateRenderToSingleSampledTransfer* transfer,\n    DeserializeBuffer* deserializeBuffer,\n    DeserializeAllocator* allocator, const ObjectIdResolver& resolver) {\n    DAWN_UNUSED(allocator);\n\n\n    ASSERT(record->chain.sType == WGPUSType_DawnMultisampleStateRenderToSingleSampled);\n    ASSERT(record->chain.next == nullptr);\n\n    static_assert(sizeof(record->enabled) >= sizeof(transfer->enabled), \"Deserialize assignment may not narrow.\");\n    record->enabled = transfer->enabled;\n\n    return WireResult::Success;\n}\nDAWN_UNUSED_FUNC(WGPUDawnMultisampleStateRenderToSingleSampledDeserialize);\n\nstruct WGPUDawnRenderPassColorAttachmentRenderToSingleSampledTransfer {\n    static_assert(0 <= 1,\n                  \"Record must be at most one of is_cmd, extensible, and chained.\");\n    WGPUChainedStructTransfer chain;\n\n    uint32_t implicitSampleCount;\n};\n\nstatic_assert(offsetof(WGPUDawnRenderPassColorAttachmentRenderToSingleSampledTransfer, chain) == 0);\n\nDAWN_DECLARE_UNUSED size_t WGPUDawnRenderPassColorAttachmentRenderToSingleSampledGetExtraRequiredSize(const WGPUDawnRenderPassColorAttachmentRenderToSingleSampled& record) {\n    DAWN_UNUSED(record);\n    size_t result = 0;\n\n    return result;\n}\n// GetExtraRequiredSize isn't used for structures that are value members of other structures\n// because we assume they cannot contain pointers themselves.\nDAWN_UNUSED_FUNC(WGPUDawnRenderPassColorAttachmentRenderToSingleSampledGetExtraRequiredSize);\n\nDAWN_DECLARE_UNUSED WireResult WGPUDawnRenderPassColorAttachmentRenderToSingleSampledSerialize(\n    const WGPUDawnRenderPassColorAttachmentRenderToSingleSampled& record,\n    WGPUDawnRenderPassColorAttachmentRenderToSingleSampledTransfer* transfer,\n    SerializeBuffer* buffer, const ObjectIdProvider& provider) {\n    DAWN_UNUSED(buffer);\n\n    ASSERT(transfer->chain.sType == WGPUSType_DawnRenderPassColorAttachmentRenderToSingleSampled);\n    ASSERT(transfer->chain.hasNext == (record.chain.next != nullptr));\n\n    transfer->implicitSampleCount = record.implicitSampleCount;\n\n    return WireResult::Success;\n}\nDAWN_UNUSED_FUNC(WGPUDawnRenderPassColorAttachmentRenderToSingleSampledSerialize);\n\nDAWN_DECLARE_UNUSED WireResult WGPUDawnRenderPassColorAttachmentRenderToSingleSampledDeserialize(\n    WGPUDawnRenderPassColorAttachmentRenderToSingleSampled* record,\n    const volatile WGPUDawnRenderPassColorAttachmentRenderToSingleSampledTransfer* transfer,\n    DeserializeBuffer* deserializeBuffer,\n    DeserializeAllocator* allocator, const ObjectIdResolver& resolver) {\n    DAWN_UNUSED(allocator);\n\n\n    ASSERT(record->chain.sType == WGPUSType_DawnRenderPassColorAttachmentRenderToSingleSampled);\n    ASSERT(record->chain.next == nullptr);\n\n    static_assert(sizeof(record->implicitSampleCount) >= sizeof(transfer->implicitSampleCount), \"Deserialize assignment may not narrow.\");\n    record->implicitSampleCount = transfer->implicitSampleCount;\n\n    return WireResult::Success;\n}\nDAWN_UNUSED_FUNC(WGPUDawnRenderPassColorAttachmentRenderToSingleSampledDeserialize);\n\nstruct WGPUDawnShaderModuleSPIRVOptionsDescriptorTransfer {\n    static_assert(0 <= 1,\n                  \"Record must be at most one of is_cmd, extensible, and chained.\");\n    WGPUChainedStructTransfer chain;\n\n    bool allowNonUniformDerivatives;\n};\n\nstatic_assert(offsetof(WGPUDawnShaderModuleSPIRVOptionsDescriptorTransfer, chain) == 0);\n\nDAWN_DECLARE_UNUSED size_t WGPUDawnShaderModuleSPIRVOptionsDescriptorGetExtraRequiredSize(const WGPUDawnShaderModuleSPIRVOptionsDescriptor& record) {\n    DAWN_UNUSED(record);\n    size_t result = 0;\n\n    return result;\n}\n// GetExtraRequiredSize isn't used for structures that are value members of other structures\n// because we assume they cannot contain pointers themselves.\nDAWN_UNUSED_FUNC(WGPUDawnShaderModuleSPIRVOptionsDescriptorGetExtraRequiredSize);\n\nDAWN_DECLARE_UNUSED WireResult WGPUDawnShaderModuleSPIRVOptionsDescriptorSerialize(\n    const WGPUDawnShaderModuleSPIRVOptionsDescriptor& record,\n    WGPUDawnShaderModuleSPIRVOptionsDescriptorTransfer* transfer,\n    SerializeBuffer* buffer, const ObjectIdProvider& provider) {\n    DAWN_UNUSED(buffer);\n\n    ASSERT(transfer->chain.sType == WGPUSType_DawnShaderModuleSPIRVOptionsDescriptor);\n    ASSERT(transfer->chain.hasNext == (record.chain.next != nullptr));\n\n    transfer->allowNonUniformDerivatives = record.allowNonUniformDerivatives;\n\n    return WireResult::Success;\n}\nDAWN_UNUSED_FUNC(WGPUDawnShaderModuleSPIRVOptionsDescriptorSerialize);\n\nDAWN_DECLARE_UNUSED WireResult WGPUDawnShaderModuleSPIRVOptionsDescriptorDeserialize(\n    WGPUDawnShaderModuleSPIRVOptionsDescriptor* record,\n    const volatile WGPUDawnShaderModuleSPIRVOptionsDescriptorTransfer* transfer,\n    DeserializeBuffer* deserializeBuffer,\n    DeserializeAllocator* allocator, const ObjectIdResolver& resolver) {\n    DAWN_UNUSED(allocator);\n\n\n    ASSERT(record->chain.sType == WGPUSType_DawnShaderModuleSPIRVOptionsDescriptor);\n    ASSERT(record->chain.next == nullptr);\n\n    static_assert(sizeof(record->allowNonUniformDerivatives) >= sizeof(transfer->allowNonUniformDerivatives), \"Deserialize assignment may not narrow.\");\n    record->allowNonUniformDerivatives = transfer->allowNonUniformDerivatives;\n\n    return WireResult::Success;\n}\nDAWN_UNUSED_FUNC(WGPUDawnShaderModuleSPIRVOptionsDescriptorDeserialize);\n\nstruct WGPUDawnTextureInternalUsageDescriptorTransfer {\n    static_assert(0 <= 1,\n                  \"Record must be at most one of is_cmd, extensible, and chained.\");\n    WGPUChainedStructTransfer chain;\n\n    WGPUTextureUsageFlags internalUsage;\n};\n\nstatic_assert(offsetof(WGPUDawnTextureInternalUsageDescriptorTransfer, chain) == 0);\n\nDAWN_DECLARE_UNUSED size_t WGPUDawnTextureInternalUsageDescriptorGetExtraRequiredSize(const WGPUDawnTextureInternalUsageDescriptor& record) {\n    DAWN_UNUSED(record);\n    size_t result = 0;\n\n    return result;\n}\n// GetExtraRequiredSize isn't used for structures that are value members of other structures\n// because we assume they cannot contain pointers themselves.\nDAWN_UNUSED_FUNC(WGPUDawnTextureInternalUsageDescriptorGetExtraRequiredSize);\n\nDAWN_DECLARE_UNUSED WireResult WGPUDawnTextureInternalUsageDescriptorSerialize(\n    const WGPUDawnTextureInternalUsageDescriptor& record,\n    WGPUDawnTextureInternalUsageDescriptorTransfer* transfer,\n    SerializeBuffer* buffer, const ObjectIdProvider& provider) {\n    DAWN_UNUSED(buffer);\n\n    ASSERT(transfer->chain.sType == WGPUSType_DawnTextureInternalUsageDescriptor);\n    ASSERT(transfer->chain.hasNext == (record.chain.next != nullptr));\n\n    transfer->internalUsage = record.internalUsage;\n\n    return WireResult::Success;\n}\nDAWN_UNUSED_FUNC(WGPUDawnTextureInternalUsageDescriptorSerialize);\n\nDAWN_DECLARE_UNUSED WireResult WGPUDawnTextureInternalUsageDescriptorDeserialize(\n    WGPUDawnTextureInternalUsageDescriptor* record,\n    const volatile WGPUDawnTextureInternalUsageDescriptorTransfer* transfer,\n    DeserializeBuffer* deserializeBuffer,\n    DeserializeAllocator* allocator, const ObjectIdResolver& resolver) {\n    DAWN_UNUSED(allocator);\n\n\n    ASSERT(record->chain.sType == WGPUSType_DawnTextureInternalUsageDescriptor);\n    ASSERT(record->chain.next == nullptr);\n\n    static_assert(sizeof(record->internalUsage) >= sizeof(transfer->internalUsage), \"Deserialize assignment may not narrow.\");\n    record->internalUsage = transfer->internalUsage;\n\n    return WireResult::Success;\n}\nDAWN_UNUSED_FUNC(WGPUDawnTextureInternalUsageDescriptorDeserialize);\n\nstruct WGPUExtent2DTransfer {\n    static_assert(0 <= 1,\n                  \"Record must be at most one of is_cmd, extensible, and chained.\");\n\n    uint32_t width;\n    uint32_t height;\n};\n\n\nDAWN_DECLARE_UNUSED size_t WGPUExtent2DGetExtraRequiredSize(const WGPUExtent2D& record) {\n    DAWN_UNUSED(record);\n    size_t result = 0;\n\n    return result;\n}\n// GetExtraRequiredSize isn't used for structures that are value members of other structures\n// because we assume they cannot contain pointers themselves.\nDAWN_UNUSED_FUNC(WGPUExtent2DGetExtraRequiredSize);\n\nDAWN_DECLARE_UNUSED WireResult WGPUExtent2DSerialize(\n    const WGPUExtent2D& record,\n    WGPUExtent2DTransfer* transfer,\n    SerializeBuffer* buffer) {\n    DAWN_UNUSED(buffer);\n\n\n    transfer->width = record.width;\n    transfer->height = record.height;\n\n    return WireResult::Success;\n}\nDAWN_UNUSED_FUNC(WGPUExtent2DSerialize);\n\nDAWN_DECLARE_UNUSED WireResult WGPUExtent2DDeserialize(\n    WGPUExtent2D* record,\n    const volatile WGPUExtent2DTransfer* transfer,\n    DeserializeBuffer* deserializeBuffer,\n    DeserializeAllocator* allocator) {\n    DAWN_UNUSED(allocator);\n\n\n\n    static_assert(sizeof(record->width) >= sizeof(transfer->width), \"Deserialize assignment may not narrow.\");\n    record->width = transfer->width;\n    static_assert(sizeof(record->height) >= sizeof(transfer->height), \"Deserialize assignment may not narrow.\");\n    record->height = transfer->height;\n\n    return WireResult::Success;\n}\nDAWN_UNUSED_FUNC(WGPUExtent2DDeserialize);\n\nstruct WGPUExtent3DTransfer {\n    static_assert(0 <= 1,\n                  \"Record must be at most one of is_cmd, extensible, and chained.\");\n\n    uint32_t width;\n    uint32_t height;\n    uint32_t depthOrArrayLayers;\n};\n\n\nDAWN_DECLARE_UNUSED size_t WGPUExtent3DGetExtraRequiredSize(const WGPUExtent3D& record) {\n    DAWN_UNUSED(record);\n    size_t result = 0;\n\n    return result;\n}\n// GetExtraRequiredSize isn't used for structures that are value members of other structures\n// because we assume they cannot contain pointers themselves.\nDAWN_UNUSED_FUNC(WGPUExtent3DGetExtraRequiredSize);\n\nDAWN_DECLARE_UNUSED WireResult WGPUExtent3DSerialize(\n    const WGPUExtent3D& record,\n    WGPUExtent3DTransfer* transfer,\n    SerializeBuffer* buffer) {\n    DAWN_UNUSED(buffer);\n\n\n    transfer->width = record.width;\n    transfer->height = record.height;\n    transfer->depthOrArrayLayers = record.depthOrArrayLayers;\n\n    return WireResult::Success;\n}\nDAWN_UNUSED_FUNC(WGPUExtent3DSerialize);\n\nDAWN_DECLARE_UNUSED WireResult WGPUExtent3DDeserialize(\n    WGPUExtent3D* record,\n    const volatile WGPUExtent3DTransfer* transfer,\n    DeserializeBuffer* deserializeBuffer,\n    DeserializeAllocator* allocator) {\n    DAWN_UNUSED(allocator);\n\n\n\n    static_assert(sizeof(record->width) >= sizeof(transfer->width), \"Deserialize assignment may not narrow.\");\n    record->width = transfer->width;\n    static_assert(sizeof(record->height) >= sizeof(transfer->height), \"Deserialize assignment may not narrow.\");\n    record->height = transfer->height;\n    static_assert(sizeof(record->depthOrArrayLayers) >= sizeof(transfer->depthOrArrayLayers), \"Deserialize assignment may not narrow.\");\n    record->depthOrArrayLayers = transfer->depthOrArrayLayers;\n\n    return WireResult::Success;\n}\nDAWN_UNUSED_FUNC(WGPUExtent3DDeserialize);\n\nstruct WGPUExternalTextureBindingEntryTransfer {\n    static_assert(0 <= 1,\n                  \"Record must be at most one of is_cmd, extensible, and chained.\");\n    WGPUChainedStructTransfer chain;\n\n    ObjectId externalTexture;\n};\n\nstatic_assert(offsetof(WGPUExternalTextureBindingEntryTransfer, chain) == 0);\n\nDAWN_DECLARE_UNUSED size_t WGPUExternalTextureBindingEntryGetExtraRequiredSize(const WGPUExternalTextureBindingEntry& record) {\n    DAWN_UNUSED(record);\n    size_t result = 0;\n\n    return result;\n}\n// GetExtraRequiredSize isn't used for structures that are value members of other structures\n// because we assume they cannot contain pointers themselves.\nDAWN_UNUSED_FUNC(WGPUExternalTextureBindingEntryGetExtraRequiredSize);\n\nDAWN_DECLARE_UNUSED WireResult WGPUExternalTextureBindingEntrySerialize(\n    const WGPUExternalTextureBindingEntry& record,\n    WGPUExternalTextureBindingEntryTransfer* transfer,\n    SerializeBuffer* buffer, const ObjectIdProvider& provider) {\n    DAWN_UNUSED(buffer);\n\n    ASSERT(transfer->chain.sType == WGPUSType_ExternalTextureBindingEntry);\n    ASSERT(transfer->chain.hasNext == (record.chain.next != nullptr));\n\n    WIRE_TRY(provider.GetId(record.externalTexture, &transfer->externalTexture));\n\n    return WireResult::Success;\n}\nDAWN_UNUSED_FUNC(WGPUExternalTextureBindingEntrySerialize);\n\nDAWN_DECLARE_UNUSED WireResult WGPUExternalTextureBindingEntryDeserialize(\n    WGPUExternalTextureBindingEntry* record,\n    const volatile WGPUExternalTextureBindingEntryTransfer* transfer,\n    DeserializeBuffer* deserializeBuffer,\n    DeserializeAllocator* allocator, const ObjectIdResolver& resolver) {\n    DAWN_UNUSED(allocator);\n\n\n    ASSERT(record->chain.sType == WGPUSType_ExternalTextureBindingEntry);\n    ASSERT(record->chain.next == nullptr);\n\n    WIRE_TRY(resolver.GetFromId(transfer->externalTexture, &record->externalTexture));\n\n    return WireResult::Success;\n}\nDAWN_UNUSED_FUNC(WGPUExternalTextureBindingEntryDeserialize);\n\nstruct WGPUExternalTextureBindingLayoutTransfer {\n    static_assert(0 <= 1,\n                  \"Record must be at most one of is_cmd, extensible, and chained.\");\n    WGPUChainedStructTransfer chain;\n\n};\n\nstatic_assert(offsetof(WGPUExternalTextureBindingLayoutTransfer, chain) == 0);\n\nDAWN_DECLARE_UNUSED size_t WGPUExternalTextureBindingLayoutGetExtraRequiredSize(const WGPUExternalTextureBindingLayout& record) {\n    DAWN_UNUSED(record);\n    size_t result = 0;\n\n    return result;\n}\n// GetExtraRequiredSize isn't used for structures that are value members of other structures\n// because we assume they cannot contain pointers themselves.\nDAWN_UNUSED_FUNC(WGPUExternalTextureBindingLayoutGetExtraRequiredSize);\n\nDAWN_DECLARE_UNUSED WireResult WGPUExternalTextureBindingLayoutSerialize(\n    const WGPUExternalTextureBindingLayout& record,\n    WGPUExternalTextureBindingLayoutTransfer* transfer,\n    SerializeBuffer* buffer, const ObjectIdProvider& provider) {\n    DAWN_UNUSED(buffer);\n\n    ASSERT(transfer->chain.sType == WGPUSType_ExternalTextureBindingLayout);\n    ASSERT(transfer->chain.hasNext == (record.chain.next != nullptr));\n\n\n    return WireResult::Success;\n}\nDAWN_UNUSED_FUNC(WGPUExternalTextureBindingLayoutSerialize);\n\nDAWN_DECLARE_UNUSED WireResult WGPUExternalTextureBindingLayoutDeserialize(\n    WGPUExternalTextureBindingLayout* record,\n    const volatile WGPUExternalTextureBindingLayoutTransfer* transfer,\n    DeserializeBuffer* deserializeBuffer,\n    DeserializeAllocator* allocator, const ObjectIdResolver& resolver) {\n    DAWN_UNUSED(allocator);\n\n\n    ASSERT(record->chain.sType == WGPUSType_ExternalTextureBindingLayout);\n    ASSERT(record->chain.next == nullptr);\n\n\n    return WireResult::Success;\n}\nDAWN_UNUSED_FUNC(WGPUExternalTextureBindingLayoutDeserialize);\n\nstruct WGPUInstanceDescriptorTransfer {\n    static_assert(0 <= 1,\n                  \"Record must be at most one of is_cmd, extensible, and chained.\");\n    bool hasNextInChain;\n\n};\n\n\nDAWN_DECLARE_UNUSED size_t WGPUInstanceDescriptorGetExtraRequiredSize(const WGPUInstanceDescriptor& record) {\n    DAWN_UNUSED(record);\n    size_t result = 0;\n\n    if (record.nextInChain != nullptr) {\n        result += GetChainedStructExtraRequiredSize(record.nextInChain);\n    }\n    return result;\n}\n// GetExtraRequiredSize isn't used for structures that are value members of other structures\n// because we assume they cannot contain pointers themselves.\nDAWN_UNUSED_FUNC(WGPUInstanceDescriptorGetExtraRequiredSize);\n\nDAWN_DECLARE_UNUSED WireResult WGPUInstanceDescriptorSerialize(\n    const WGPUInstanceDescriptor& record,\n    WGPUInstanceDescriptorTransfer* transfer,\n    SerializeBuffer* buffer, const ObjectIdProvider& provider) {\n    DAWN_UNUSED(buffer);\n\n    if (record.nextInChain != nullptr) {\n        transfer->hasNextInChain = true;\n        WIRE_TRY(SerializeChainedStruct(record.nextInChain, buffer, provider));\n    } else {\n        transfer->hasNextInChain = false;\n    }\n\n\n    return WireResult::Success;\n}\nDAWN_UNUSED_FUNC(WGPUInstanceDescriptorSerialize);\n\nDAWN_DECLARE_UNUSED WireResult WGPUInstanceDescriptorDeserialize(\n    WGPUInstanceDescriptor* record,\n    const volatile WGPUInstanceDescriptorTransfer* transfer,\n    DeserializeBuffer* deserializeBuffer,\n    DeserializeAllocator* allocator, const ObjectIdResolver& resolver) {\n    DAWN_UNUSED(allocator);\n\n\n    record->nextInChain = nullptr;\n    if (transfer->hasNextInChain) {\n        WIRE_TRY(DeserializeChainedStruct(&record->nextInChain, deserializeBuffer, allocator, resolver));\n    }\n\n\n    return WireResult::Success;\n}\nDAWN_UNUSED_FUNC(WGPUInstanceDescriptorDeserialize);\n\nstruct WGPULimitsTransfer {\n    static_assert(0 <= 1,\n                  \"Record must be at most one of is_cmd, extensible, and chained.\");\n\n    uint32_t maxTextureDimension1D;\n    uint32_t maxTextureDimension2D;\n    uint32_t maxTextureDimension3D;\n    uint32_t maxTextureArrayLayers;\n    uint32_t maxBindGroups;\n    uint32_t maxBindGroupsPlusVertexBuffers;\n    uint32_t maxBindingsPerBindGroup;\n    uint32_t maxDynamicUniformBuffersPerPipelineLayout;\n    uint32_t maxDynamicStorageBuffersPerPipelineLayout;\n    uint32_t maxSampledTexturesPerShaderStage;\n    uint32_t maxSamplersPerShaderStage;\n    uint32_t maxStorageBuffersPerShaderStage;\n    uint32_t maxStorageTexturesPerShaderStage;\n    uint32_t maxUniformBuffersPerShaderStage;\n    uint64_t maxUniformBufferBindingSize;\n    uint64_t maxStorageBufferBindingSize;\n    uint32_t minUniformBufferOffsetAlignment;\n    uint32_t minStorageBufferOffsetAlignment;\n    uint32_t maxVertexBuffers;\n    uint64_t maxBufferSize;\n    uint32_t maxVertexAttributes;\n    uint32_t maxVertexBufferArrayStride;\n    uint32_t maxInterStageShaderComponents;\n    uint32_t maxInterStageShaderVariables;\n    uint32_t maxColorAttachments;\n    uint32_t maxColorAttachmentBytesPerSample;\n    uint32_t maxComputeWorkgroupStorageSize;\n    uint32_t maxComputeInvocationsPerWorkgroup;\n    uint32_t maxComputeWorkgroupSizeX;\n    uint32_t maxComputeWorkgroupSizeY;\n    uint32_t maxComputeWorkgroupSizeZ;\n    uint32_t maxComputeWorkgroupsPerDimension;\n};\n\n\nDAWN_DECLARE_UNUSED size_t WGPULimitsGetExtraRequiredSize(const WGPULimits& record) {\n    DAWN_UNUSED(record);\n    size_t result = 0;\n\n    return result;\n}\n// GetExtraRequiredSize isn't used for structures that are value members of other structures\n// because we assume they cannot contain pointers themselves.\nDAWN_UNUSED_FUNC(WGPULimitsGetExtraRequiredSize);\n\nDAWN_DECLARE_UNUSED WireResult WGPULimitsSerialize(\n    const WGPULimits& record,\n    WGPULimitsTransfer* transfer,\n    SerializeBuffer* buffer) {\n    DAWN_UNUSED(buffer);\n\n\n    transfer->maxTextureDimension1D = record.maxTextureDimension1D;\n    transfer->maxTextureDimension2D = record.maxTextureDimension2D;\n    transfer->maxTextureDimension3D = record.maxTextureDimension3D;\n    transfer->maxTextureArrayLayers = record.maxTextureArrayLayers;\n    transfer->maxBindGroups = record.maxBindGroups;\n    transfer->maxBindGroupsPlusVertexBuffers = record.maxBindGroupsPlusVertexBuffers;\n    transfer->maxBindingsPerBindGroup = record.maxBindingsPerBindGroup;\n    transfer->maxDynamicUniformBuffersPerPipelineLayout = record.maxDynamicUniformBuffersPerPipelineLayout;\n    transfer->maxDynamicStorageBuffersPerPipelineLayout = record.maxDynamicStorageBuffersPerPipelineLayout;\n    transfer->maxSampledTexturesPerShaderStage = record.maxSampledTexturesPerShaderStage;\n    transfer->maxSamplersPerShaderStage = record.maxSamplersPerShaderStage;\n    transfer->maxStorageBuffersPerShaderStage = record.maxStorageBuffersPerShaderStage;\n    transfer->maxStorageTexturesPerShaderStage = record.maxStorageTexturesPerShaderStage;\n    transfer->maxUniformBuffersPerShaderStage = record.maxUniformBuffersPerShaderStage;\n    transfer->maxUniformBufferBindingSize = record.maxUniformBufferBindingSize;\n    transfer->maxStorageBufferBindingSize = record.maxStorageBufferBindingSize;\n    transfer->minUniformBufferOffsetAlignment = record.minUniformBufferOffsetAlignment;\n    transfer->minStorageBufferOffsetAlignment = record.minStorageBufferOffsetAlignment;\n    transfer->maxVertexBuffers = record.maxVertexBuffers;\n    transfer->maxBufferSize = record.maxBufferSize;\n    transfer->maxVertexAttributes = record.maxVertexAttributes;\n    transfer->maxVertexBufferArrayStride = record.maxVertexBufferArrayStride;\n    transfer->maxInterStageShaderComponents = record.maxInterStageShaderComponents;\n    transfer->maxInterStageShaderVariables = record.maxInterStageShaderVariables;\n    transfer->maxColorAttachments = record.maxColorAttachments;\n    transfer->maxColorAttachmentBytesPerSample = record.maxColorAttachmentBytesPerSample;\n    transfer->maxComputeWorkgroupStorageSize = record.maxComputeWorkgroupStorageSize;\n    transfer->maxComputeInvocationsPerWorkgroup = record.maxComputeInvocationsPerWorkgroup;\n    transfer->maxComputeWorkgroupSizeX = record.maxComputeWorkgroupSizeX;\n    transfer->maxComputeWorkgroupSizeY = record.maxComputeWorkgroupSizeY;\n    transfer->maxComputeWorkgroupSizeZ = record.maxComputeWorkgroupSizeZ;\n    transfer->maxComputeWorkgroupsPerDimension = record.maxComputeWorkgroupsPerDimension;\n\n    return WireResult::Success;\n}\nDAWN_UNUSED_FUNC(WGPULimitsSerialize);\n\nDAWN_DECLARE_UNUSED WireResult WGPULimitsDeserialize(\n    WGPULimits* record,\n    const volatile WGPULimitsTransfer* transfer,\n    DeserializeBuffer* deserializeBuffer,\n    DeserializeAllocator* allocator) {\n    DAWN_UNUSED(allocator);\n\n\n\n    static_assert(sizeof(record->maxTextureDimension1D) >= sizeof(transfer->maxTextureDimension1D), \"Deserialize assignment may not narrow.\");\n    record->maxTextureDimension1D = transfer->maxTextureDimension1D;\n    static_assert(sizeof(record->maxTextureDimension2D) >= sizeof(transfer->maxTextureDimension2D), \"Deserialize assignment may not narrow.\");\n    record->maxTextureDimension2D = transfer->maxTextureDimension2D;\n    static_assert(sizeof(record->maxTextureDimension3D) >= sizeof(transfer->maxTextureDimension3D), \"Deserialize assignment may not narrow.\");\n    record->maxTextureDimension3D = transfer->maxTextureDimension3D;\n    static_assert(sizeof(record->maxTextureArrayLayers) >= sizeof(transfer->maxTextureArrayLayers), \"Deserialize assignment may not narrow.\");\n    record->maxTextureArrayLayers = transfer->maxTextureArrayLayers;\n    static_assert(sizeof(record->maxBindGroups) >= sizeof(transfer->maxBindGroups), \"Deserialize assignment may not narrow.\");\n    record->maxBindGroups = transfer->maxBindGroups;\n    static_assert(sizeof(record->maxBindGroupsPlusVertexBuffers) >= sizeof(transfer->maxBindGroupsPlusVertexBuffers), \"Deserialize assignment may not narrow.\");\n    record->maxBindGroupsPlusVertexBuffers = transfer->maxBindGroupsPlusVertexBuffers;\n    static_assert(sizeof(record->maxBindingsPerBindGroup) >= sizeof(transfer->maxBindingsPerBindGroup), \"Deserialize assignment may not narrow.\");\n    record->maxBindingsPerBindGroup = transfer->maxBindingsPerBindGroup;\n    static_assert(sizeof(record->maxDynamicUniformBuffersPerPipelineLayout) >= sizeof(transfer->maxDynamicUniformBuffersPerPipelineLayout), \"Deserialize assignment may not narrow.\");\n    record->maxDynamicUniformBuffersPerPipelineLayout = transfer->maxDynamicUniformBuffersPerPipelineLayout;\n    static_assert(sizeof(record->maxDynamicStorageBuffersPerPipelineLayout) >= sizeof(transfer->maxDynamicStorageBuffersPerPipelineLayout), \"Deserialize assignment may not narrow.\");\n    record->maxDynamicStorageBuffersPerPipelineLayout = transfer->maxDynamicStorageBuffersPerPipelineLayout;\n    static_assert(sizeof(record->maxSampledTexturesPerShaderStage) >= sizeof(transfer->maxSampledTexturesPerShaderStage), \"Deserialize assignment may not narrow.\");\n    record->maxSampledTexturesPerShaderStage = transfer->maxSampledTexturesPerShaderStage;\n    static_assert(sizeof(record->maxSamplersPerShaderStage) >= sizeof(transfer->maxSamplersPerShaderStage), \"Deserialize assignment may not narrow.\");\n    record->maxSamplersPerShaderStage = transfer->maxSamplersPerShaderStage;\n    static_assert(sizeof(record->maxStorageBuffersPerShaderStage) >= sizeof(transfer->maxStorageBuffersPerShaderStage), \"Deserialize assignment may not narrow.\");\n    record->maxStorageBuffersPerShaderStage = transfer->maxStorageBuffersPerShaderStage;\n    static_assert(sizeof(record->maxStorageTexturesPerShaderStage) >= sizeof(transfer->maxStorageTexturesPerShaderStage), \"Deserialize assignment may not narrow.\");\n    record->maxStorageTexturesPerShaderStage = transfer->maxStorageTexturesPerShaderStage;\n    static_assert(sizeof(record->maxUniformBuffersPerShaderStage) >= sizeof(transfer->maxUniformBuffersPerShaderStage), \"Deserialize assignment may not narrow.\");\n    record->maxUniformBuffersPerShaderStage = transfer->maxUniformBuffersPerShaderStage;\n    static_assert(sizeof(record->maxUniformBufferBindingSize) >= sizeof(transfer->maxUniformBufferBindingSize), \"Deserialize assignment may not narrow.\");\n    record->maxUniformBufferBindingSize = transfer->maxUniformBufferBindingSize;\n    static_assert(sizeof(record->maxStorageBufferBindingSize) >= sizeof(transfer->maxStorageBufferBindingSize), \"Deserialize assignment may not narrow.\");\n    record->maxStorageBufferBindingSize = transfer->maxStorageBufferBindingSize;\n    static_assert(sizeof(record->minUniformBufferOffsetAlignment) >= sizeof(transfer->minUniformBufferOffsetAlignment), \"Deserialize assignment may not narrow.\");\n    record->minUniformBufferOffsetAlignment = transfer->minUniformBufferOffsetAlignment;\n    static_assert(sizeof(record->minStorageBufferOffsetAlignment) >= sizeof(transfer->minStorageBufferOffsetAlignment), \"Deserialize assignment may not narrow.\");\n    record->minStorageBufferOffsetAlignment = transfer->minStorageBufferOffsetAlignment;\n    static_assert(sizeof(record->maxVertexBuffers) >= sizeof(transfer->maxVertexBuffers), \"Deserialize assignment may not narrow.\");\n    record->maxVertexBuffers = transfer->maxVertexBuffers;\n    static_assert(sizeof(record->maxBufferSize) >= sizeof(transfer->maxBufferSize), \"Deserialize assignment may not narrow.\");\n    record->maxBufferSize = transfer->maxBufferSize;\n    static_assert(sizeof(record->maxVertexAttributes) >= sizeof(transfer->maxVertexAttributes), \"Deserialize assignment may not narrow.\");\n    record->maxVertexAttributes = transfer->maxVertexAttributes;\n    static_assert(sizeof(record->maxVertexBufferArrayStride) >= sizeof(transfer->maxVertexBufferArrayStride), \"Deserialize assignment may not narrow.\");\n    record->maxVertexBufferArrayStride = transfer->maxVertexBufferArrayStride;\n    static_assert(sizeof(record->maxInterStageShaderComponents) >= sizeof(transfer->maxInterStageShaderComponents), \"Deserialize assignment may not narrow.\");\n    record->maxInterStageShaderComponents = transfer->maxInterStageShaderComponents;\n    static_assert(sizeof(record->maxInterStageShaderVariables) >= sizeof(transfer->maxInterStageShaderVariables), \"Deserialize assignment may not narrow.\");\n    record->maxInterStageShaderVariables = transfer->maxInterStageShaderVariables;\n    static_assert(sizeof(record->maxColorAttachments) >= sizeof(transfer->maxColorAttachments), \"Deserialize assignment may not narrow.\");\n    record->maxColorAttachments = transfer->maxColorAttachments;\n    static_assert(sizeof(record->maxColorAttachmentBytesPerSample) >= sizeof(transfer->maxColorAttachmentBytesPerSample), \"Deserialize assignment may not narrow.\");\n    record->maxColorAttachmentBytesPerSample = transfer->maxColorAttachmentBytesPerSample;\n    static_assert(sizeof(record->maxComputeWorkgroupStorageSize) >= sizeof(transfer->maxComputeWorkgroupStorageSize), \"Deserialize assignment may not narrow.\");\n    record->maxComputeWorkgroupStorageSize = transfer->maxComputeWorkgroupStorageSize;\n    static_assert(sizeof(record->maxComputeInvocationsPerWorkgroup) >= sizeof(transfer->maxComputeInvocationsPerWorkgroup), \"Deserialize assignment may not narrow.\");\n    record->maxComputeInvocationsPerWorkgroup = transfer->maxComputeInvocationsPerWorkgroup;\n    static_assert(sizeof(record->maxComputeWorkgroupSizeX) >= sizeof(transfer->maxComputeWorkgroupSizeX), \"Deserialize assignment may not narrow.\");\n    record->maxComputeWorkgroupSizeX = transfer->maxComputeWorkgroupSizeX;\n    static_assert(sizeof(record->maxComputeWorkgroupSizeY) >= sizeof(transfer->maxComputeWorkgroupSizeY), \"Deserialize assignment may not narrow.\");\n    record->maxComputeWorkgroupSizeY = transfer->maxComputeWorkgroupSizeY;\n    static_assert(sizeof(record->maxComputeWorkgroupSizeZ) >= sizeof(transfer->maxComputeWorkgroupSizeZ), \"Deserialize assignment may not narrow.\");\n    record->maxComputeWorkgroupSizeZ = transfer->maxComputeWorkgroupSizeZ;\n    static_assert(sizeof(record->maxComputeWorkgroupsPerDimension) >= sizeof(transfer->maxComputeWorkgroupsPerDimension), \"Deserialize assignment may not narrow.\");\n    record->maxComputeWorkgroupsPerDimension = transfer->maxComputeWorkgroupsPerDimension;\n\n    return WireResult::Success;\n}\nDAWN_UNUSED_FUNC(WGPULimitsDeserialize);\n\nstruct WGPUMultisampleStateTransfer {\n    static_assert(0 <= 1,\n                  \"Record must be at most one of is_cmd, extensible, and chained.\");\n    bool hasNextInChain;\n\n    uint32_t count;\n    uint32_t mask;\n    bool alphaToCoverageEnabled;\n};\n\n\nDAWN_DECLARE_UNUSED size_t WGPUMultisampleStateGetExtraRequiredSize(const WGPUMultisampleState& record) {\n    DAWN_UNUSED(record);\n    size_t result = 0;\n\n    if (record.nextInChain != nullptr) {\n        result += GetChainedStructExtraRequiredSize(record.nextInChain);\n    }\n    return result;\n}\n// GetExtraRequiredSize isn't used for structures that are value members of other structures\n// because we assume they cannot contain pointers themselves.\nDAWN_UNUSED_FUNC(WGPUMultisampleStateGetExtraRequiredSize);\n\nDAWN_DECLARE_UNUSED WireResult WGPUMultisampleStateSerialize(\n    const WGPUMultisampleState& record,\n    WGPUMultisampleStateTransfer* transfer,\n    SerializeBuffer* buffer, const ObjectIdProvider& provider) {\n    DAWN_UNUSED(buffer);\n\n    if (record.nextInChain != nullptr) {\n        transfer->hasNextInChain = true;\n        WIRE_TRY(SerializeChainedStruct(record.nextInChain, buffer, provider));\n    } else {\n        transfer->hasNextInChain = false;\n    }\n\n    transfer->count = record.count;\n    transfer->mask = record.mask;\n    transfer->alphaToCoverageEnabled = record.alphaToCoverageEnabled;\n\n    return WireResult::Success;\n}\nDAWN_UNUSED_FUNC(WGPUMultisampleStateSerialize);\n\nDAWN_DECLARE_UNUSED WireResult WGPUMultisampleStateDeserialize(\n    WGPUMultisampleState* record,\n    const volatile WGPUMultisampleStateTransfer* transfer,\n    DeserializeBuffer* deserializeBuffer,\n    DeserializeAllocator* allocator, const ObjectIdResolver& resolver) {\n    DAWN_UNUSED(allocator);\n\n\n    record->nextInChain = nullptr;\n    if (transfer->hasNextInChain) {\n        WIRE_TRY(DeserializeChainedStruct(&record->nextInChain, deserializeBuffer, allocator, resolver));\n    }\n\n    static_assert(sizeof(record->count) >= sizeof(transfer->count), \"Deserialize assignment may not narrow.\");\n    record->count = transfer->count;\n    static_assert(sizeof(record->mask) >= sizeof(transfer->mask), \"Deserialize assignment may not narrow.\");\n    record->mask = transfer->mask;\n    static_assert(sizeof(record->alphaToCoverageEnabled) >= sizeof(transfer->alphaToCoverageEnabled), \"Deserialize assignment may not narrow.\");\n    record->alphaToCoverageEnabled = transfer->alphaToCoverageEnabled;\n\n    return WireResult::Success;\n}\nDAWN_UNUSED_FUNC(WGPUMultisampleStateDeserialize);\n\nstruct WGPUOrigin2DTransfer {\n    static_assert(0 <= 1,\n                  \"Record must be at most one of is_cmd, extensible, and chained.\");\n\n    uint32_t x;\n    uint32_t y;\n};\n\n\nDAWN_DECLARE_UNUSED size_t WGPUOrigin2DGetExtraRequiredSize(const WGPUOrigin2D& record) {\n    DAWN_UNUSED(record);\n    size_t result = 0;\n\n    return result;\n}\n// GetExtraRequiredSize isn't used for structures that are value members of other structures\n// because we assume they cannot contain pointers themselves.\nDAWN_UNUSED_FUNC(WGPUOrigin2DGetExtraRequiredSize);\n\nDAWN_DECLARE_UNUSED WireResult WGPUOrigin2DSerialize(\n    const WGPUOrigin2D& record,\n    WGPUOrigin2DTransfer* transfer,\n    SerializeBuffer* buffer) {\n    DAWN_UNUSED(buffer);\n\n\n    transfer->x = record.x;\n    transfer->y = record.y;\n\n    return WireResult::Success;\n}\nDAWN_UNUSED_FUNC(WGPUOrigin2DSerialize);\n\nDAWN_DECLARE_UNUSED WireResult WGPUOrigin2DDeserialize(\n    WGPUOrigin2D* record,\n    const volatile WGPUOrigin2DTransfer* transfer,\n    DeserializeBuffer* deserializeBuffer,\n    DeserializeAllocator* allocator) {\n    DAWN_UNUSED(allocator);\n\n\n\n    static_assert(sizeof(record->x) >= sizeof(transfer->x), \"Deserialize assignment may not narrow.\");\n    record->x = transfer->x;\n    static_assert(sizeof(record->y) >= sizeof(transfer->y), \"Deserialize assignment may not narrow.\");\n    record->y = transfer->y;\n\n    return WireResult::Success;\n}\nDAWN_UNUSED_FUNC(WGPUOrigin2DDeserialize);\n\nstruct WGPUOrigin3DTransfer {\n    static_assert(0 <= 1,\n                  \"Record must be at most one of is_cmd, extensible, and chained.\");\n\n    uint32_t x;\n    uint32_t y;\n    uint32_t z;\n};\n\n\nDAWN_DECLARE_UNUSED size_t WGPUOrigin3DGetExtraRequiredSize(const WGPUOrigin3D& record) {\n    DAWN_UNUSED(record);\n    size_t result = 0;\n\n    return result;\n}\n// GetExtraRequiredSize isn't used for structures that are value members of other structures\n// because we assume they cannot contain pointers themselves.\nDAWN_UNUSED_FUNC(WGPUOrigin3DGetExtraRequiredSize);\n\nDAWN_DECLARE_UNUSED WireResult WGPUOrigin3DSerialize(\n    const WGPUOrigin3D& record,\n    WGPUOrigin3DTransfer* transfer,\n    SerializeBuffer* buffer) {\n    DAWN_UNUSED(buffer);\n\n\n    transfer->x = record.x;\n    transfer->y = record.y;\n    transfer->z = record.z;\n\n    return WireResult::Success;\n}\nDAWN_UNUSED_FUNC(WGPUOrigin3DSerialize);\n\nDAWN_DECLARE_UNUSED WireResult WGPUOrigin3DDeserialize(\n    WGPUOrigin3D* record,\n    const volatile WGPUOrigin3DTransfer* transfer,\n    DeserializeBuffer* deserializeBuffer,\n    DeserializeAllocator* allocator) {\n    DAWN_UNUSED(allocator);\n\n\n\n    static_assert(sizeof(record->x) >= sizeof(transfer->x), \"Deserialize assignment may not narrow.\");\n    record->x = transfer->x;\n    static_assert(sizeof(record->y) >= sizeof(transfer->y), \"Deserialize assignment may not narrow.\");\n    record->y = transfer->y;\n    static_assert(sizeof(record->z) >= sizeof(transfer->z), \"Deserialize assignment may not narrow.\");\n    record->z = transfer->z;\n\n    return WireResult::Success;\n}\nDAWN_UNUSED_FUNC(WGPUOrigin3DDeserialize);\n\nstruct WGPUPipelineLayoutDescriptorTransfer {\n    static_assert(0 <= 1,\n                  \"Record must be at most one of is_cmd, extensible, and chained.\");\n    bool hasNextInChain;\n\n    uint64_t labelStrlen;\n    bool has_label;\n    uint64_t bindGroupLayoutCount;\n};\n\n\nDAWN_DECLARE_UNUSED size_t WGPUPipelineLayoutDescriptorGetExtraRequiredSize(const WGPUPipelineLayoutDescriptor& record) {\n    DAWN_UNUSED(record);\n    size_t result = 0;\n\n    if (record.nextInChain != nullptr) {\n        result += GetChainedStructExtraRequiredSize(record.nextInChain);\n    }\n    if (record.label != nullptr) {\n        result += Align(std::strlen(record.label), kWireBufferAlignment);\n    }\n    {\n        auto memberLength = record.bindGroupLayoutCount;\n        auto size = WireAlignSizeofN<ObjectId>(memberLength);\n        ASSERT(size);\n        result += *size;\n    }\n    return result;\n}\n// GetExtraRequiredSize isn't used for structures that are value members of other structures\n// because we assume they cannot contain pointers themselves.\nDAWN_UNUSED_FUNC(WGPUPipelineLayoutDescriptorGetExtraRequiredSize);\n\nDAWN_DECLARE_UNUSED WireResult WGPUPipelineLayoutDescriptorSerialize(\n    const WGPUPipelineLayoutDescriptor& record,\n    WGPUPipelineLayoutDescriptorTransfer* transfer,\n    SerializeBuffer* buffer, const ObjectIdProvider& provider) {\n    DAWN_UNUSED(buffer);\n\n    if (record.nextInChain != nullptr) {\n        transfer->hasNextInChain = true;\n        WIRE_TRY(SerializeChainedStruct(record.nextInChain, buffer, provider));\n    } else {\n        transfer->hasNextInChain = false;\n    }\n\n    transfer->bindGroupLayoutCount = record.bindGroupLayoutCount;\n    bool has_label = record.label != nullptr;\n    transfer->has_label = has_label;\n    if (has_label) {\n        transfer->labelStrlen = std::strlen(record.label);\n\n        char* stringInBuffer;\n        WIRE_TRY(buffer->NextN(transfer->labelStrlen, &stringInBuffer));\n        memcpy(stringInBuffer, record.label, transfer->labelStrlen);\n    }\n    {\n        auto memberLength = record.bindGroupLayoutCount;\n\n        ObjectId* memberBuffer;\n        WIRE_TRY(buffer->NextN(memberLength, &memberBuffer));\n\n        for (decltype(memberLength) i = 0; i < memberLength; ++i) {\n            WIRE_TRY(provider.GetId(record.bindGroupLayouts[i], &memberBuffer[i]));\n        }\n    }\n\n    return WireResult::Success;\n}\nDAWN_UNUSED_FUNC(WGPUPipelineLayoutDescriptorSerialize);\n\nDAWN_DECLARE_UNUSED WireResult WGPUPipelineLayoutDescriptorDeserialize(\n    WGPUPipelineLayoutDescriptor* record,\n    const volatile WGPUPipelineLayoutDescriptorTransfer* transfer,\n    DeserializeBuffer* deserializeBuffer,\n    DeserializeAllocator* allocator, const ObjectIdResolver& resolver) {\n    DAWN_UNUSED(allocator);\n\n\n    record->nextInChain = nullptr;\n    if (transfer->hasNextInChain) {\n        WIRE_TRY(DeserializeChainedStruct(&record->nextInChain, deserializeBuffer, allocator, resolver));\n    }\n\n    if (transfer->bindGroupLayoutCount > std::numeric_limits<size_t>::max()) return WireResult::FatalError;\n    record->bindGroupLayoutCount = checked_cast<size_t>(transfer->bindGroupLayoutCount);\n    bool has_label = transfer->has_label;\n    record->label = nullptr;\n    if (has_label) {\n        uint64_t stringLength64 = transfer->labelStrlen;\n        if (stringLength64 >= std::numeric_limits<size_t>::max()) {\n            return WireResult::FatalError;\n        }\n        size_t stringLength = static_cast<size_t>(stringLength64);\n\n        const volatile char* stringInBuffer;\n        WIRE_TRY(deserializeBuffer->ReadN(stringLength, &stringInBuffer));\n\n        char* copiedString;\n        WIRE_TRY(GetSpace(allocator, stringLength + 1, &copiedString));\n        memcpy(copiedString, const_cast<const char*>(stringInBuffer), stringLength);\n        copiedString[stringLength] = '\\0';\n        record->label = copiedString;\n    }\n    {\n        auto memberLength = record->bindGroupLayoutCount;\n        const volatile ObjectId* memberBuffer;\n        WIRE_TRY(deserializeBuffer->ReadN(memberLength, &memberBuffer));\n\n        WGPUBindGroupLayout* copiedMembers;\n        WIRE_TRY(GetSpace(allocator, memberLength, &copiedMembers));\n        record->bindGroupLayouts = copiedMembers;\n\n        for (decltype(memberLength) i = 0; i < memberLength; ++i) {\n            WIRE_TRY(resolver.GetFromId(memberBuffer[i], &copiedMembers[i]));\n        }\n    }\n\n    return WireResult::Success;\n}\nDAWN_UNUSED_FUNC(WGPUPipelineLayoutDescriptorDeserialize);\n\nstruct WGPUPrimitiveDepthClipControlTransfer {\n    static_assert(0 <= 1,\n                  \"Record must be at most one of is_cmd, extensible, and chained.\");\n    WGPUChainedStructTransfer chain;\n\n    bool unclippedDepth;\n};\n\nstatic_assert(offsetof(WGPUPrimitiveDepthClipControlTransfer, chain) == 0);\n\nDAWN_DECLARE_UNUSED size_t WGPUPrimitiveDepthClipControlGetExtraRequiredSize(const WGPUPrimitiveDepthClipControl& record) {\n    DAWN_UNUSED(record);\n    size_t result = 0;\n\n    return result;\n}\n// GetExtraRequiredSize isn't used for structures that are value members of other structures\n// because we assume they cannot contain pointers themselves.\nDAWN_UNUSED_FUNC(WGPUPrimitiveDepthClipControlGetExtraRequiredSize);\n\nDAWN_DECLARE_UNUSED WireResult WGPUPrimitiveDepthClipControlSerialize(\n    const WGPUPrimitiveDepthClipControl& record,\n    WGPUPrimitiveDepthClipControlTransfer* transfer,\n    SerializeBuffer* buffer, const ObjectIdProvider& provider) {\n    DAWN_UNUSED(buffer);\n\n    ASSERT(transfer->chain.sType == WGPUSType_PrimitiveDepthClipControl);\n    ASSERT(transfer->chain.hasNext == (record.chain.next != nullptr));\n\n    transfer->unclippedDepth = record.unclippedDepth;\n\n    return WireResult::Success;\n}\nDAWN_UNUSED_FUNC(WGPUPrimitiveDepthClipControlSerialize);\n\nDAWN_DECLARE_UNUSED WireResult WGPUPrimitiveDepthClipControlDeserialize(\n    WGPUPrimitiveDepthClipControl* record,\n    const volatile WGPUPrimitiveDepthClipControlTransfer* transfer,\n    DeserializeBuffer* deserializeBuffer,\n    DeserializeAllocator* allocator, const ObjectIdResolver& resolver) {\n    DAWN_UNUSED(allocator);\n\n\n    ASSERT(record->chain.sType == WGPUSType_PrimitiveDepthClipControl);\n    ASSERT(record->chain.next == nullptr);\n\n    static_assert(sizeof(record->unclippedDepth) >= sizeof(transfer->unclippedDepth), \"Deserialize assignment may not narrow.\");\n    record->unclippedDepth = transfer->unclippedDepth;\n\n    return WireResult::Success;\n}\nDAWN_UNUSED_FUNC(WGPUPrimitiveDepthClipControlDeserialize);\n\nstruct WGPUPrimitiveStateTransfer {\n    static_assert(0 <= 1,\n                  \"Record must be at most one of is_cmd, extensible, and chained.\");\n    bool hasNextInChain;\n\n    WGPUPrimitiveTopology topology;\n    WGPUIndexFormat stripIndexFormat;\n    WGPUFrontFace frontFace;\n    WGPUCullMode cullMode;\n};\n\n\nDAWN_DECLARE_UNUSED size_t WGPUPrimitiveStateGetExtraRequiredSize(const WGPUPrimitiveState& record) {\n    DAWN_UNUSED(record);\n    size_t result = 0;\n\n    if (record.nextInChain != nullptr) {\n        result += GetChainedStructExtraRequiredSize(record.nextInChain);\n    }\n    return result;\n}\n// GetExtraRequiredSize isn't used for structures that are value members of other structures\n// because we assume they cannot contain pointers themselves.\nDAWN_UNUSED_FUNC(WGPUPrimitiveStateGetExtraRequiredSize);\n\nDAWN_DECLARE_UNUSED WireResult WGPUPrimitiveStateSerialize(\n    const WGPUPrimitiveState& record,\n    WGPUPrimitiveStateTransfer* transfer,\n    SerializeBuffer* buffer, const ObjectIdProvider& provider) {\n    DAWN_UNUSED(buffer);\n\n    if (record.nextInChain != nullptr) {\n        transfer->hasNextInChain = true;\n        WIRE_TRY(SerializeChainedStruct(record.nextInChain, buffer, provider));\n    } else {\n        transfer->hasNextInChain = false;\n    }\n\n    transfer->topology = record.topology;\n    transfer->stripIndexFormat = record.stripIndexFormat;\n    transfer->frontFace = record.frontFace;\n    transfer->cullMode = record.cullMode;\n\n    return WireResult::Success;\n}\nDAWN_UNUSED_FUNC(WGPUPrimitiveStateSerialize);\n\nDAWN_DECLARE_UNUSED WireResult WGPUPrimitiveStateDeserialize(\n    WGPUPrimitiveState* record,\n    const volatile WGPUPrimitiveStateTransfer* transfer,\n    DeserializeBuffer* deserializeBuffer,\n    DeserializeAllocator* allocator, const ObjectIdResolver& resolver) {\n    DAWN_UNUSED(allocator);\n\n\n    record->nextInChain = nullptr;\n    if (transfer->hasNextInChain) {\n        WIRE_TRY(DeserializeChainedStruct(&record->nextInChain, deserializeBuffer, allocator, resolver));\n    }\n\n    static_assert(sizeof(record->topology) >= sizeof(transfer->topology), \"Deserialize assignment may not narrow.\");\n    record->topology = transfer->topology;\n    static_assert(sizeof(record->stripIndexFormat) >= sizeof(transfer->stripIndexFormat), \"Deserialize assignment may not narrow.\");\n    record->stripIndexFormat = transfer->stripIndexFormat;\n    static_assert(sizeof(record->frontFace) >= sizeof(transfer->frontFace), \"Deserialize assignment may not narrow.\");\n    record->frontFace = transfer->frontFace;\n    static_assert(sizeof(record->cullMode) >= sizeof(transfer->cullMode), \"Deserialize assignment may not narrow.\");\n    record->cullMode = transfer->cullMode;\n\n    return WireResult::Success;\n}\nDAWN_UNUSED_FUNC(WGPUPrimitiveStateDeserialize);\n\nstruct WGPUQuerySetDescriptorTransfer {\n    static_assert(0 <= 1,\n                  \"Record must be at most one of is_cmd, extensible, and chained.\");\n    bool hasNextInChain;\n\n    uint64_t labelStrlen;\n    bool has_label;\n    WGPUQueryType type;\n    uint32_t count;\n    uint64_t pipelineStatisticsCount;\n};\n\n\nDAWN_DECLARE_UNUSED size_t WGPUQuerySetDescriptorGetExtraRequiredSize(const WGPUQuerySetDescriptor& record) {\n    DAWN_UNUSED(record);\n    size_t result = 0;\n\n    if (record.nextInChain != nullptr) {\n        result += GetChainedStructExtraRequiredSize(record.nextInChain);\n    }\n    if (record.label != nullptr) {\n        result += Align(std::strlen(record.label), kWireBufferAlignment);\n    }\n    {\n        auto memberLength = record.pipelineStatisticsCount;\n        auto size = WireAlignSizeofN<WGPUPipelineStatisticName>(memberLength);\n        ASSERT(size);\n        result += *size;\n    }\n    return result;\n}\n// GetExtraRequiredSize isn't used for structures that are value members of other structures\n// because we assume they cannot contain pointers themselves.\nDAWN_UNUSED_FUNC(WGPUQuerySetDescriptorGetExtraRequiredSize);\n\nDAWN_DECLARE_UNUSED WireResult WGPUQuerySetDescriptorSerialize(\n    const WGPUQuerySetDescriptor& record,\n    WGPUQuerySetDescriptorTransfer* transfer,\n    SerializeBuffer* buffer, const ObjectIdProvider& provider) {\n    DAWN_UNUSED(buffer);\n\n    if (record.nextInChain != nullptr) {\n        transfer->hasNextInChain = true;\n        WIRE_TRY(SerializeChainedStruct(record.nextInChain, buffer, provider));\n    } else {\n        transfer->hasNextInChain = false;\n    }\n\n    transfer->type = record.type;\n    transfer->count = record.count;\n    transfer->pipelineStatisticsCount = record.pipelineStatisticsCount;\n    bool has_label = record.label != nullptr;\n    transfer->has_label = has_label;\n    if (has_label) {\n        transfer->labelStrlen = std::strlen(record.label);\n\n        char* stringInBuffer;\n        WIRE_TRY(buffer->NextN(transfer->labelStrlen, &stringInBuffer));\n        memcpy(stringInBuffer, record.label, transfer->labelStrlen);\n    }\n    {\n        auto memberLength = record.pipelineStatisticsCount;\n\n        WGPUPipelineStatisticName* memberBuffer;\n        WIRE_TRY(buffer->NextN(memberLength, &memberBuffer));\n\n        memcpy(\n            memberBuffer, record.pipelineStatistics,\n            sizeof(WGPUPipelineStatisticName) * memberLength);\n    }\n\n    return WireResult::Success;\n}\nDAWN_UNUSED_FUNC(WGPUQuerySetDescriptorSerialize);\n\nDAWN_DECLARE_UNUSED WireResult WGPUQuerySetDescriptorDeserialize(\n    WGPUQuerySetDescriptor* record,\n    const volatile WGPUQuerySetDescriptorTransfer* transfer,\n    DeserializeBuffer* deserializeBuffer,\n    DeserializeAllocator* allocator, const ObjectIdResolver& resolver) {\n    DAWN_UNUSED(allocator);\n\n\n    record->nextInChain = nullptr;\n    if (transfer->hasNextInChain) {\n        WIRE_TRY(DeserializeChainedStruct(&record->nextInChain, deserializeBuffer, allocator, resolver));\n    }\n\n    static_assert(sizeof(record->type) >= sizeof(transfer->type), \"Deserialize assignment may not narrow.\");\n    record->type = transfer->type;\n    static_assert(sizeof(record->count) >= sizeof(transfer->count), \"Deserialize assignment may not narrow.\");\n    record->count = transfer->count;\n    if (transfer->pipelineStatisticsCount > std::numeric_limits<size_t>::max()) return WireResult::FatalError;\n    record->pipelineStatisticsCount = checked_cast<size_t>(transfer->pipelineStatisticsCount);\n    bool has_label = transfer->has_label;\n    record->label = nullptr;\n    if (has_label) {\n        uint64_t stringLength64 = transfer->labelStrlen;\n        if (stringLength64 >= std::numeric_limits<size_t>::max()) {\n            return WireResult::FatalError;\n        }\n        size_t stringLength = static_cast<size_t>(stringLength64);\n\n        const volatile char* stringInBuffer;\n        WIRE_TRY(deserializeBuffer->ReadN(stringLength, &stringInBuffer));\n\n        char* copiedString;\n        WIRE_TRY(GetSpace(allocator, stringLength + 1, &copiedString));\n        memcpy(copiedString, const_cast<const char*>(stringInBuffer), stringLength);\n        copiedString[stringLength] = '\\0';\n        record->label = copiedString;\n    }\n    {\n        auto memberLength = record->pipelineStatisticsCount;\n        const volatile WGPUPipelineStatisticName* memberBuffer;\n        WIRE_TRY(deserializeBuffer->ReadN(memberLength, &memberBuffer));\n\n        WGPUPipelineStatisticName* copiedMembers;\n        WIRE_TRY(GetSpace(allocator, memberLength, &copiedMembers));\n        record->pipelineStatistics = copiedMembers;\n\n        memcpy(\n            copiedMembers,\n            const_cast<const WGPUPipelineStatisticName*>(memberBuffer),\n           sizeof(WGPUPipelineStatisticName) * memberLength);\n    }\n\n    return WireResult::Success;\n}\nDAWN_UNUSED_FUNC(WGPUQuerySetDescriptorDeserialize);\n\nstruct WGPUQueueDescriptorTransfer {\n    static_assert(0 <= 1,\n                  \"Record must be at most one of is_cmd, extensible, and chained.\");\n    bool hasNextInChain;\n\n    uint64_t labelStrlen;\n    bool has_label;\n};\n\n\nDAWN_DECLARE_UNUSED size_t WGPUQueueDescriptorGetExtraRequiredSize(const WGPUQueueDescriptor& record) {\n    DAWN_UNUSED(record);\n    size_t result = 0;\n\n    if (record.nextInChain != nullptr) {\n        result += GetChainedStructExtraRequiredSize(record.nextInChain);\n    }\n    if (record.label != nullptr) {\n        result += Align(std::strlen(record.label), kWireBufferAlignment);\n    }\n    return result;\n}\n// GetExtraRequiredSize isn't used for structures that are value members of other structures\n// because we assume they cannot contain pointers themselves.\nDAWN_UNUSED_FUNC(WGPUQueueDescriptorGetExtraRequiredSize);\n\nDAWN_DECLARE_UNUSED WireResult WGPUQueueDescriptorSerialize(\n    const WGPUQueueDescriptor& record,\n    WGPUQueueDescriptorTransfer* transfer,\n    SerializeBuffer* buffer, const ObjectIdProvider& provider) {\n    DAWN_UNUSED(buffer);\n\n    if (record.nextInChain != nullptr) {\n        transfer->hasNextInChain = true;\n        WIRE_TRY(SerializeChainedStruct(record.nextInChain, buffer, provider));\n    } else {\n        transfer->hasNextInChain = false;\n    }\n\n    bool has_label = record.label != nullptr;\n    transfer->has_label = has_label;\n    if (has_label) {\n        transfer->labelStrlen = std::strlen(record.label);\n\n        char* stringInBuffer;\n        WIRE_TRY(buffer->NextN(transfer->labelStrlen, &stringInBuffer));\n        memcpy(stringInBuffer, record.label, transfer->labelStrlen);\n    }\n\n    return WireResult::Success;\n}\nDAWN_UNUSED_FUNC(WGPUQueueDescriptorSerialize);\n\nDAWN_DECLARE_UNUSED WireResult WGPUQueueDescriptorDeserialize(\n    WGPUQueueDescriptor* record,\n    const volatile WGPUQueueDescriptorTransfer* transfer,\n    DeserializeBuffer* deserializeBuffer,\n    DeserializeAllocator* allocator, const ObjectIdResolver& resolver) {\n    DAWN_UNUSED(allocator);\n\n\n    record->nextInChain = nullptr;\n    if (transfer->hasNextInChain) {\n        WIRE_TRY(DeserializeChainedStruct(&record->nextInChain, deserializeBuffer, allocator, resolver));\n    }\n\n    bool has_label = transfer->has_label;\n    record->label = nullptr;\n    if (has_label) {\n        uint64_t stringLength64 = transfer->labelStrlen;\n        if (stringLength64 >= std::numeric_limits<size_t>::max()) {\n            return WireResult::FatalError;\n        }\n        size_t stringLength = static_cast<size_t>(stringLength64);\n\n        const volatile char* stringInBuffer;\n        WIRE_TRY(deserializeBuffer->ReadN(stringLength, &stringInBuffer));\n\n        char* copiedString;\n        WIRE_TRY(GetSpace(allocator, stringLength + 1, &copiedString));\n        memcpy(copiedString, const_cast<const char*>(stringInBuffer), stringLength);\n        copiedString[stringLength] = '\\0';\n        record->label = copiedString;\n    }\n\n    return WireResult::Success;\n}\nDAWN_UNUSED_FUNC(WGPUQueueDescriptorDeserialize);\n\nstruct WGPURenderBundleDescriptorTransfer {\n    static_assert(0 <= 1,\n                  \"Record must be at most one of is_cmd, extensible, and chained.\");\n    bool hasNextInChain;\n\n    uint64_t labelStrlen;\n    bool has_label;\n};\n\n\nDAWN_DECLARE_UNUSED size_t WGPURenderBundleDescriptorGetExtraRequiredSize(const WGPURenderBundleDescriptor& record) {\n    DAWN_UNUSED(record);\n    size_t result = 0;\n\n    if (record.nextInChain != nullptr) {\n        result += GetChainedStructExtraRequiredSize(record.nextInChain);\n    }\n    if (record.label != nullptr) {\n        result += Align(std::strlen(record.label), kWireBufferAlignment);\n    }\n    return result;\n}\n// GetExtraRequiredSize isn't used for structures that are value members of other structures\n// because we assume they cannot contain pointers themselves.\nDAWN_UNUSED_FUNC(WGPURenderBundleDescriptorGetExtraRequiredSize);\n\nDAWN_DECLARE_UNUSED WireResult WGPURenderBundleDescriptorSerialize(\n    const WGPURenderBundleDescriptor& record,\n    WGPURenderBundleDescriptorTransfer* transfer,\n    SerializeBuffer* buffer, const ObjectIdProvider& provider) {\n    DAWN_UNUSED(buffer);\n\n    if (record.nextInChain != nullptr) {\n        transfer->hasNextInChain = true;\n        WIRE_TRY(SerializeChainedStruct(record.nextInChain, buffer, provider));\n    } else {\n        transfer->hasNextInChain = false;\n    }\n\n    bool has_label = record.label != nullptr;\n    transfer->has_label = has_label;\n    if (has_label) {\n        transfer->labelStrlen = std::strlen(record.label);\n\n        char* stringInBuffer;\n        WIRE_TRY(buffer->NextN(transfer->labelStrlen, &stringInBuffer));\n        memcpy(stringInBuffer, record.label, transfer->labelStrlen);\n    }\n\n    return WireResult::Success;\n}\nDAWN_UNUSED_FUNC(WGPURenderBundleDescriptorSerialize);\n\nDAWN_DECLARE_UNUSED WireResult WGPURenderBundleDescriptorDeserialize(\n    WGPURenderBundleDescriptor* record,\n    const volatile WGPURenderBundleDescriptorTransfer* transfer,\n    DeserializeBuffer* deserializeBuffer,\n    DeserializeAllocator* allocator, const ObjectIdResolver& resolver) {\n    DAWN_UNUSED(allocator);\n\n\n    record->nextInChain = nullptr;\n    if (transfer->hasNextInChain) {\n        WIRE_TRY(DeserializeChainedStruct(&record->nextInChain, deserializeBuffer, allocator, resolver));\n    }\n\n    bool has_label = transfer->has_label;\n    record->label = nullptr;\n    if (has_label) {\n        uint64_t stringLength64 = transfer->labelStrlen;\n        if (stringLength64 >= std::numeric_limits<size_t>::max()) {\n            return WireResult::FatalError;\n        }\n        size_t stringLength = static_cast<size_t>(stringLength64);\n\n        const volatile char* stringInBuffer;\n        WIRE_TRY(deserializeBuffer->ReadN(stringLength, &stringInBuffer));\n\n        char* copiedString;\n        WIRE_TRY(GetSpace(allocator, stringLength + 1, &copiedString));\n        memcpy(copiedString, const_cast<const char*>(stringInBuffer), stringLength);\n        copiedString[stringLength] = '\\0';\n        record->label = copiedString;\n    }\n\n    return WireResult::Success;\n}\nDAWN_UNUSED_FUNC(WGPURenderBundleDescriptorDeserialize);\n\nstruct WGPURenderBundleEncoderDescriptorTransfer {\n    static_assert(0 <= 1,\n                  \"Record must be at most one of is_cmd, extensible, and chained.\");\n    bool hasNextInChain;\n\n    uint64_t labelStrlen;\n    bool has_label;\n    uint64_t colorFormatsCount;\n    WGPUTextureFormat depthStencilFormat;\n    uint32_t sampleCount;\n    bool depthReadOnly;\n    bool stencilReadOnly;\n};\n\n\nDAWN_DECLARE_UNUSED size_t WGPURenderBundleEncoderDescriptorGetExtraRequiredSize(const WGPURenderBundleEncoderDescriptor& record) {\n    DAWN_UNUSED(record);\n    size_t result = 0;\n\n    if (record.nextInChain != nullptr) {\n        result += GetChainedStructExtraRequiredSize(record.nextInChain);\n    }\n    if (record.label != nullptr) {\n        result += Align(std::strlen(record.label), kWireBufferAlignment);\n    }\n    {\n        auto memberLength = record.colorFormatsCount;\n        auto size = WireAlignSizeofN<WGPUTextureFormat>(memberLength);\n        ASSERT(size);\n        result += *size;\n    }\n    return result;\n}\n// GetExtraRequiredSize isn't used for structures that are value members of other structures\n// because we assume they cannot contain pointers themselves.\nDAWN_UNUSED_FUNC(WGPURenderBundleEncoderDescriptorGetExtraRequiredSize);\n\nDAWN_DECLARE_UNUSED WireResult WGPURenderBundleEncoderDescriptorSerialize(\n    const WGPURenderBundleEncoderDescriptor& record,\n    WGPURenderBundleEncoderDescriptorTransfer* transfer,\n    SerializeBuffer* buffer, const ObjectIdProvider& provider) {\n    DAWN_UNUSED(buffer);\n\n    if (record.nextInChain != nullptr) {\n        transfer->hasNextInChain = true;\n        WIRE_TRY(SerializeChainedStruct(record.nextInChain, buffer, provider));\n    } else {\n        transfer->hasNextInChain = false;\n    }\n\n    transfer->colorFormatsCount = record.colorFormatsCount;\n    transfer->depthStencilFormat = record.depthStencilFormat;\n    transfer->sampleCount = record.sampleCount;\n    transfer->depthReadOnly = record.depthReadOnly;\n    transfer->stencilReadOnly = record.stencilReadOnly;\n    bool has_label = record.label != nullptr;\n    transfer->has_label = has_label;\n    if (has_label) {\n        transfer->labelStrlen = std::strlen(record.label);\n\n        char* stringInBuffer;\n        WIRE_TRY(buffer->NextN(transfer->labelStrlen, &stringInBuffer));\n        memcpy(stringInBuffer, record.label, transfer->labelStrlen);\n    }\n    {\n        auto memberLength = record.colorFormatsCount;\n\n        WGPUTextureFormat* memberBuffer;\n        WIRE_TRY(buffer->NextN(memberLength, &memberBuffer));\n\n        memcpy(\n            memberBuffer, record.colorFormats,\n            sizeof(WGPUTextureFormat) * memberLength);\n    }\n\n    return WireResult::Success;\n}\nDAWN_UNUSED_FUNC(WGPURenderBundleEncoderDescriptorSerialize);\n\nDAWN_DECLARE_UNUSED WireResult WGPURenderBundleEncoderDescriptorDeserialize(\n    WGPURenderBundleEncoderDescriptor* record,\n    const volatile WGPURenderBundleEncoderDescriptorTransfer* transfer,\n    DeserializeBuffer* deserializeBuffer,\n    DeserializeAllocator* allocator, const ObjectIdResolver& resolver) {\n    DAWN_UNUSED(allocator);\n\n\n    record->nextInChain = nullptr;\n    if (transfer->hasNextInChain) {\n        WIRE_TRY(DeserializeChainedStruct(&record->nextInChain, deserializeBuffer, allocator, resolver));\n    }\n\n    if (transfer->colorFormatsCount > std::numeric_limits<size_t>::max()) return WireResult::FatalError;\n    record->colorFormatsCount = checked_cast<size_t>(transfer->colorFormatsCount);\n    static_assert(sizeof(record->depthStencilFormat) >= sizeof(transfer->depthStencilFormat), \"Deserialize assignment may not narrow.\");\n    record->depthStencilFormat = transfer->depthStencilFormat;\n    static_assert(sizeof(record->sampleCount) >= sizeof(transfer->sampleCount), \"Deserialize assignment may not narrow.\");\n    record->sampleCount = transfer->sampleCount;\n    static_assert(sizeof(record->depthReadOnly) >= sizeof(transfer->depthReadOnly), \"Deserialize assignment may not narrow.\");\n    record->depthReadOnly = transfer->depthReadOnly;\n    static_assert(sizeof(record->stencilReadOnly) >= sizeof(transfer->stencilReadOnly), \"Deserialize assignment may not narrow.\");\n    record->stencilReadOnly = transfer->stencilReadOnly;\n    bool has_label = transfer->has_label;\n    record->label = nullptr;\n    if (has_label) {\n        uint64_t stringLength64 = transfer->labelStrlen;\n        if (stringLength64 >= std::numeric_limits<size_t>::max()) {\n            return WireResult::FatalError;\n        }\n        size_t stringLength = static_cast<size_t>(stringLength64);\n\n        const volatile char* stringInBuffer;\n        WIRE_TRY(deserializeBuffer->ReadN(stringLength, &stringInBuffer));\n\n        char* copiedString;\n        WIRE_TRY(GetSpace(allocator, stringLength + 1, &copiedString));\n        memcpy(copiedString, const_cast<const char*>(stringInBuffer), stringLength);\n        copiedString[stringLength] = '\\0';\n        record->label = copiedString;\n    }\n    {\n        auto memberLength = record->colorFormatsCount;\n        const volatile WGPUTextureFormat* memberBuffer;\n        WIRE_TRY(deserializeBuffer->ReadN(memberLength, &memberBuffer));\n\n        WGPUTextureFormat* copiedMembers;\n        WIRE_TRY(GetSpace(allocator, memberLength, &copiedMembers));\n        record->colorFormats = copiedMembers;\n\n        memcpy(\n            copiedMembers,\n            const_cast<const WGPUTextureFormat*>(memberBuffer),\n           sizeof(WGPUTextureFormat) * memberLength);\n    }\n\n    return WireResult::Success;\n}\nDAWN_UNUSED_FUNC(WGPURenderBundleEncoderDescriptorDeserialize);\n\nstruct WGPURenderPassDepthStencilAttachmentTransfer {\n    static_assert(0 <= 1,\n                  \"Record must be at most one of is_cmd, extensible, and chained.\");\n\n    ObjectId view;\n    WGPULoadOp depthLoadOp;\n    WGPUStoreOp depthStoreOp;\n    float depthClearValue;\n    bool depthReadOnly;\n    WGPULoadOp stencilLoadOp;\n    WGPUStoreOp stencilStoreOp;\n    uint32_t stencilClearValue;\n    bool stencilReadOnly;\n};\n\n\nDAWN_DECLARE_UNUSED size_t WGPURenderPassDepthStencilAttachmentGetExtraRequiredSize(const WGPURenderPassDepthStencilAttachment& record) {\n    DAWN_UNUSED(record);\n    size_t result = 0;\n\n    return result;\n}\n// GetExtraRequiredSize isn't used for structures that are value members of other structures\n// because we assume they cannot contain pointers themselves.\nDAWN_UNUSED_FUNC(WGPURenderPassDepthStencilAttachmentGetExtraRequiredSize);\n\nDAWN_DECLARE_UNUSED WireResult WGPURenderPassDepthStencilAttachmentSerialize(\n    const WGPURenderPassDepthStencilAttachment& record,\n    WGPURenderPassDepthStencilAttachmentTransfer* transfer,\n    SerializeBuffer* buffer, const ObjectIdProvider& provider) {\n    DAWN_UNUSED(buffer);\n\n\n    WIRE_TRY(provider.GetId(record.view, &transfer->view));\n    transfer->depthLoadOp = record.depthLoadOp;\n    transfer->depthStoreOp = record.depthStoreOp;\n    transfer->depthClearValue = record.depthClearValue;\n    transfer->depthReadOnly = record.depthReadOnly;\n    transfer->stencilLoadOp = record.stencilLoadOp;\n    transfer->stencilStoreOp = record.stencilStoreOp;\n    transfer->stencilClearValue = record.stencilClearValue;\n    transfer->stencilReadOnly = record.stencilReadOnly;\n\n    return WireResult::Success;\n}\nDAWN_UNUSED_FUNC(WGPURenderPassDepthStencilAttachmentSerialize);\n\nDAWN_DECLARE_UNUSED WireResult WGPURenderPassDepthStencilAttachmentDeserialize(\n    WGPURenderPassDepthStencilAttachment* record,\n    const volatile WGPURenderPassDepthStencilAttachmentTransfer* transfer,\n    DeserializeBuffer* deserializeBuffer,\n    DeserializeAllocator* allocator, const ObjectIdResolver& resolver) {\n    DAWN_UNUSED(allocator);\n\n\n\n    WIRE_TRY(resolver.GetFromId(transfer->view, &record->view));\n    static_assert(sizeof(record->depthLoadOp) >= sizeof(transfer->depthLoadOp), \"Deserialize assignment may not narrow.\");\n    record->depthLoadOp = transfer->depthLoadOp;\n    static_assert(sizeof(record->depthStoreOp) >= sizeof(transfer->depthStoreOp), \"Deserialize assignment may not narrow.\");\n    record->depthStoreOp = transfer->depthStoreOp;\n    static_assert(sizeof(record->depthClearValue) >= sizeof(transfer->depthClearValue), \"Deserialize assignment may not narrow.\");\n    record->depthClearValue = transfer->depthClearValue;\n    static_assert(sizeof(record->depthReadOnly) >= sizeof(transfer->depthReadOnly), \"Deserialize assignment may not narrow.\");\n    record->depthReadOnly = transfer->depthReadOnly;\n    static_assert(sizeof(record->stencilLoadOp) >= sizeof(transfer->stencilLoadOp), \"Deserialize assignment may not narrow.\");\n    record->stencilLoadOp = transfer->stencilLoadOp;\n    static_assert(sizeof(record->stencilStoreOp) >= sizeof(transfer->stencilStoreOp), \"Deserialize assignment may not narrow.\");\n    record->stencilStoreOp = transfer->stencilStoreOp;\n    static_assert(sizeof(record->stencilClearValue) >= sizeof(transfer->stencilClearValue), \"Deserialize assignment may not narrow.\");\n    record->stencilClearValue = transfer->stencilClearValue;\n    static_assert(sizeof(record->stencilReadOnly) >= sizeof(transfer->stencilReadOnly), \"Deserialize assignment may not narrow.\");\n    record->stencilReadOnly = transfer->stencilReadOnly;\n\n    return WireResult::Success;\n}\nDAWN_UNUSED_FUNC(WGPURenderPassDepthStencilAttachmentDeserialize);\n\nstruct WGPURenderPassDescriptorMaxDrawCountTransfer {\n    static_assert(0 <= 1,\n                  \"Record must be at most one of is_cmd, extensible, and chained.\");\n    WGPUChainedStructTransfer chain;\n\n    uint64_t maxDrawCount;\n};\n\nstatic_assert(offsetof(WGPURenderPassDescriptorMaxDrawCountTransfer, chain) == 0);\n\nDAWN_DECLARE_UNUSED size_t WGPURenderPassDescriptorMaxDrawCountGetExtraRequiredSize(const WGPURenderPassDescriptorMaxDrawCount& record) {\n    DAWN_UNUSED(record);\n    size_t result = 0;\n\n    return result;\n}\n// GetExtraRequiredSize isn't used for structures that are value members of other structures\n// because we assume they cannot contain pointers themselves.\nDAWN_UNUSED_FUNC(WGPURenderPassDescriptorMaxDrawCountGetExtraRequiredSize);\n\nDAWN_DECLARE_UNUSED WireResult WGPURenderPassDescriptorMaxDrawCountSerialize(\n    const WGPURenderPassDescriptorMaxDrawCount& record,\n    WGPURenderPassDescriptorMaxDrawCountTransfer* transfer,\n    SerializeBuffer* buffer, const ObjectIdProvider& provider) {\n    DAWN_UNUSED(buffer);\n\n    ASSERT(transfer->chain.sType == WGPUSType_RenderPassDescriptorMaxDrawCount);\n    ASSERT(transfer->chain.hasNext == (record.chain.next != nullptr));\n\n    transfer->maxDrawCount = record.maxDrawCount;\n\n    return WireResult::Success;\n}\nDAWN_UNUSED_FUNC(WGPURenderPassDescriptorMaxDrawCountSerialize);\n\nDAWN_DECLARE_UNUSED WireResult WGPURenderPassDescriptorMaxDrawCountDeserialize(\n    WGPURenderPassDescriptorMaxDrawCount* record,\n    const volatile WGPURenderPassDescriptorMaxDrawCountTransfer* transfer,\n    DeserializeBuffer* deserializeBuffer,\n    DeserializeAllocator* allocator, const ObjectIdResolver& resolver) {\n    DAWN_UNUSED(allocator);\n\n\n    ASSERT(record->chain.sType == WGPUSType_RenderPassDescriptorMaxDrawCount);\n    ASSERT(record->chain.next == nullptr);\n\n    static_assert(sizeof(record->maxDrawCount) >= sizeof(transfer->maxDrawCount), \"Deserialize assignment may not narrow.\");\n    record->maxDrawCount = transfer->maxDrawCount;\n\n    return WireResult::Success;\n}\nDAWN_UNUSED_FUNC(WGPURenderPassDescriptorMaxDrawCountDeserialize);\n\nstruct WGPURenderPassTimestampWriteTransfer {\n    static_assert(0 <= 1,\n                  \"Record must be at most one of is_cmd, extensible, and chained.\");\n\n    ObjectId querySet;\n    uint32_t queryIndex;\n    WGPURenderPassTimestampLocation location;\n};\n\n\nDAWN_DECLARE_UNUSED size_t WGPURenderPassTimestampWriteGetExtraRequiredSize(const WGPURenderPassTimestampWrite& record) {\n    DAWN_UNUSED(record);\n    size_t result = 0;\n\n    return result;\n}\n// GetExtraRequiredSize isn't used for structures that are value members of other structures\n// because we assume they cannot contain pointers themselves.\nDAWN_UNUSED_FUNC(WGPURenderPassTimestampWriteGetExtraRequiredSize);\n\nDAWN_DECLARE_UNUSED WireResult WGPURenderPassTimestampWriteSerialize(\n    const WGPURenderPassTimestampWrite& record,\n    WGPURenderPassTimestampWriteTransfer* transfer,\n    SerializeBuffer* buffer, const ObjectIdProvider& provider) {\n    DAWN_UNUSED(buffer);\n\n\n    WIRE_TRY(provider.GetId(record.querySet, &transfer->querySet));\n    transfer->queryIndex = record.queryIndex;\n    transfer->location = record.location;\n\n    return WireResult::Success;\n}\nDAWN_UNUSED_FUNC(WGPURenderPassTimestampWriteSerialize);\n\nDAWN_DECLARE_UNUSED WireResult WGPURenderPassTimestampWriteDeserialize(\n    WGPURenderPassTimestampWrite* record,\n    const volatile WGPURenderPassTimestampWriteTransfer* transfer,\n    DeserializeBuffer* deserializeBuffer,\n    DeserializeAllocator* allocator, const ObjectIdResolver& resolver) {\n    DAWN_UNUSED(allocator);\n\n\n\n    WIRE_TRY(resolver.GetFromId(transfer->querySet, &record->querySet));\n    static_assert(sizeof(record->queryIndex) >= sizeof(transfer->queryIndex), \"Deserialize assignment may not narrow.\");\n    record->queryIndex = transfer->queryIndex;\n    static_assert(sizeof(record->location) >= sizeof(transfer->location), \"Deserialize assignment may not narrow.\");\n    record->location = transfer->location;\n\n    return WireResult::Success;\n}\nDAWN_UNUSED_FUNC(WGPURenderPassTimestampWriteDeserialize);\n\nstruct WGPURequestAdapterOptionsTransfer {\n    static_assert(0 <= 1,\n                  \"Record must be at most one of is_cmd, extensible, and chained.\");\n    bool hasNextInChain;\n\n    ObjectId compatibleSurface;\n    WGPUPowerPreference powerPreference;\n    WGPUBackendType backendType;\n    bool forceFallbackAdapter;\n    bool compatibilityMode;\n};\n\n\nDAWN_DECLARE_UNUSED size_t WGPURequestAdapterOptionsGetExtraRequiredSize(const WGPURequestAdapterOptions& record) {\n    DAWN_UNUSED(record);\n    size_t result = 0;\n\n    if (record.nextInChain != nullptr) {\n        result += GetChainedStructExtraRequiredSize(record.nextInChain);\n    }\n    return result;\n}\n// GetExtraRequiredSize isn't used for structures that are value members of other structures\n// because we assume they cannot contain pointers themselves.\nDAWN_UNUSED_FUNC(WGPURequestAdapterOptionsGetExtraRequiredSize);\n\nDAWN_DECLARE_UNUSED WireResult WGPURequestAdapterOptionsSerialize(\n    const WGPURequestAdapterOptions& record,\n    WGPURequestAdapterOptionsTransfer* transfer,\n    SerializeBuffer* buffer, const ObjectIdProvider& provider) {\n    DAWN_UNUSED(buffer);\n\n    if (record.nextInChain != nullptr) {\n        transfer->hasNextInChain = true;\n        WIRE_TRY(SerializeChainedStruct(record.nextInChain, buffer, provider));\n    } else {\n        transfer->hasNextInChain = false;\n    }\n\n    WIRE_TRY(provider.GetOptionalId(record.compatibleSurface, &transfer->compatibleSurface));\n    transfer->powerPreference = record.powerPreference;\n    transfer->backendType = record.backendType;\n    transfer->forceFallbackAdapter = record.forceFallbackAdapter;\n    transfer->compatibilityMode = record.compatibilityMode;\n\n    return WireResult::Success;\n}\nDAWN_UNUSED_FUNC(WGPURequestAdapterOptionsSerialize);\n\nDAWN_DECLARE_UNUSED WireResult WGPURequestAdapterOptionsDeserialize(\n    WGPURequestAdapterOptions* record,\n    const volatile WGPURequestAdapterOptionsTransfer* transfer,\n    DeserializeBuffer* deserializeBuffer,\n    DeserializeAllocator* allocator, const ObjectIdResolver& resolver) {\n    DAWN_UNUSED(allocator);\n\n\n    record->nextInChain = nullptr;\n    if (transfer->hasNextInChain) {\n        WIRE_TRY(DeserializeChainedStruct(&record->nextInChain, deserializeBuffer, allocator, resolver));\n    }\n\n    WIRE_TRY(resolver.GetOptionalFromId(transfer->compatibleSurface, &record->compatibleSurface));\n    static_assert(sizeof(record->powerPreference) >= sizeof(transfer->powerPreference), \"Deserialize assignment may not narrow.\");\n    record->powerPreference = transfer->powerPreference;\n    static_assert(sizeof(record->backendType) >= sizeof(transfer->backendType), \"Deserialize assignment may not narrow.\");\n    record->backendType = transfer->backendType;\n    static_assert(sizeof(record->forceFallbackAdapter) >= sizeof(transfer->forceFallbackAdapter), \"Deserialize assignment may not narrow.\");\n    record->forceFallbackAdapter = transfer->forceFallbackAdapter;\n    static_assert(sizeof(record->compatibilityMode) >= sizeof(transfer->compatibilityMode), \"Deserialize assignment may not narrow.\");\n    record->compatibilityMode = transfer->compatibilityMode;\n\n    return WireResult::Success;\n}\nDAWN_UNUSED_FUNC(WGPURequestAdapterOptionsDeserialize);\n\nstruct WGPUSamplerBindingLayoutTransfer {\n    static_assert(0 <= 1,\n                  \"Record must be at most one of is_cmd, extensible, and chained.\");\n    bool hasNextInChain;\n\n    WGPUSamplerBindingType type;\n};\n\n\nDAWN_DECLARE_UNUSED size_t WGPUSamplerBindingLayoutGetExtraRequiredSize(const WGPUSamplerBindingLayout& record) {\n    DAWN_UNUSED(record);\n    size_t result = 0;\n\n    if (record.nextInChain != nullptr) {\n        result += GetChainedStructExtraRequiredSize(record.nextInChain);\n    }\n    return result;\n}\n// GetExtraRequiredSize isn't used for structures that are value members of other structures\n// because we assume they cannot contain pointers themselves.\nDAWN_UNUSED_FUNC(WGPUSamplerBindingLayoutGetExtraRequiredSize);\n\nDAWN_DECLARE_UNUSED WireResult WGPUSamplerBindingLayoutSerialize(\n    const WGPUSamplerBindingLayout& record,\n    WGPUSamplerBindingLayoutTransfer* transfer,\n    SerializeBuffer* buffer, const ObjectIdProvider& provider) {\n    DAWN_UNUSED(buffer);\n\n    if (record.nextInChain != nullptr) {\n        transfer->hasNextInChain = true;\n        WIRE_TRY(SerializeChainedStruct(record.nextInChain, buffer, provider));\n    } else {\n        transfer->hasNextInChain = false;\n    }\n\n    transfer->type = record.type;\n\n    return WireResult::Success;\n}\nDAWN_UNUSED_FUNC(WGPUSamplerBindingLayoutSerialize);\n\nDAWN_DECLARE_UNUSED WireResult WGPUSamplerBindingLayoutDeserialize(\n    WGPUSamplerBindingLayout* record,\n    const volatile WGPUSamplerBindingLayoutTransfer* transfer,\n    DeserializeBuffer* deserializeBuffer,\n    DeserializeAllocator* allocator, const ObjectIdResolver& resolver) {\n    DAWN_UNUSED(allocator);\n\n\n    record->nextInChain = nullptr;\n    if (transfer->hasNextInChain) {\n        WIRE_TRY(DeserializeChainedStruct(&record->nextInChain, deserializeBuffer, allocator, resolver));\n    }\n\n    static_assert(sizeof(record->type) >= sizeof(transfer->type), \"Deserialize assignment may not narrow.\");\n    record->type = transfer->type;\n\n    return WireResult::Success;\n}\nDAWN_UNUSED_FUNC(WGPUSamplerBindingLayoutDeserialize);\n\nstruct WGPUSamplerDescriptorTransfer {\n    static_assert(0 <= 1,\n                  \"Record must be at most one of is_cmd, extensible, and chained.\");\n    bool hasNextInChain;\n\n    uint64_t labelStrlen;\n    bool has_label;\n    WGPUAddressMode addressModeU;\n    WGPUAddressMode addressModeV;\n    WGPUAddressMode addressModeW;\n    WGPUFilterMode magFilter;\n    WGPUFilterMode minFilter;\n    WGPUMipmapFilterMode mipmapFilter;\n    float lodMinClamp;\n    float lodMaxClamp;\n    WGPUCompareFunction compare;\n    uint16_t maxAnisotropy;\n};\n\n\nDAWN_DECLARE_UNUSED size_t WGPUSamplerDescriptorGetExtraRequiredSize(const WGPUSamplerDescriptor& record) {\n    DAWN_UNUSED(record);\n    size_t result = 0;\n\n    if (record.nextInChain != nullptr) {\n        result += GetChainedStructExtraRequiredSize(record.nextInChain);\n    }\n    if (record.label != nullptr) {\n        result += Align(std::strlen(record.label), kWireBufferAlignment);\n    }\n    return result;\n}\n// GetExtraRequiredSize isn't used for structures that are value members of other structures\n// because we assume they cannot contain pointers themselves.\nDAWN_UNUSED_FUNC(WGPUSamplerDescriptorGetExtraRequiredSize);\n\nDAWN_DECLARE_UNUSED WireResult WGPUSamplerDescriptorSerialize(\n    const WGPUSamplerDescriptor& record,\n    WGPUSamplerDescriptorTransfer* transfer,\n    SerializeBuffer* buffer, const ObjectIdProvider& provider) {\n    DAWN_UNUSED(buffer);\n\n    if (record.nextInChain != nullptr) {\n        transfer->hasNextInChain = true;\n        WIRE_TRY(SerializeChainedStruct(record.nextInChain, buffer, provider));\n    } else {\n        transfer->hasNextInChain = false;\n    }\n\n    transfer->addressModeU = record.addressModeU;\n    transfer->addressModeV = record.addressModeV;\n    transfer->addressModeW = record.addressModeW;\n    transfer->magFilter = record.magFilter;\n    transfer->minFilter = record.minFilter;\n    transfer->mipmapFilter = record.mipmapFilter;\n    transfer->lodMinClamp = record.lodMinClamp;\n    transfer->lodMaxClamp = record.lodMaxClamp;\n    transfer->compare = record.compare;\n    transfer->maxAnisotropy = record.maxAnisotropy;\n    bool has_label = record.label != nullptr;\n    transfer->has_label = has_label;\n    if (has_label) {\n        transfer->labelStrlen = std::strlen(record.label);\n\n        char* stringInBuffer;\n        WIRE_TRY(buffer->NextN(transfer->labelStrlen, &stringInBuffer));\n        memcpy(stringInBuffer, record.label, transfer->labelStrlen);\n    }\n\n    return WireResult::Success;\n}\nDAWN_UNUSED_FUNC(WGPUSamplerDescriptorSerialize);\n\nDAWN_DECLARE_UNUSED WireResult WGPUSamplerDescriptorDeserialize(\n    WGPUSamplerDescriptor* record,\n    const volatile WGPUSamplerDescriptorTransfer* transfer,\n    DeserializeBuffer* deserializeBuffer,\n    DeserializeAllocator* allocator, const ObjectIdResolver& resolver) {\n    DAWN_UNUSED(allocator);\n\n\n    record->nextInChain = nullptr;\n    if (transfer->hasNextInChain) {\n        WIRE_TRY(DeserializeChainedStruct(&record->nextInChain, deserializeBuffer, allocator, resolver));\n    }\n\n    static_assert(sizeof(record->addressModeU) >= sizeof(transfer->addressModeU), \"Deserialize assignment may not narrow.\");\n    record->addressModeU = transfer->addressModeU;\n    static_assert(sizeof(record->addressModeV) >= sizeof(transfer->addressModeV), \"Deserialize assignment may not narrow.\");\n    record->addressModeV = transfer->addressModeV;\n    static_assert(sizeof(record->addressModeW) >= sizeof(transfer->addressModeW), \"Deserialize assignment may not narrow.\");\n    record->addressModeW = transfer->addressModeW;\n    static_assert(sizeof(record->magFilter) >= sizeof(transfer->magFilter), \"Deserialize assignment may not narrow.\");\n    record->magFilter = transfer->magFilter;\n    static_assert(sizeof(record->minFilter) >= sizeof(transfer->minFilter), \"Deserialize assignment may not narrow.\");\n    record->minFilter = transfer->minFilter;\n    static_assert(sizeof(record->mipmapFilter) >= sizeof(transfer->mipmapFilter), \"Deserialize assignment may not narrow.\");\n    record->mipmapFilter = transfer->mipmapFilter;\n    static_assert(sizeof(record->lodMinClamp) >= sizeof(transfer->lodMinClamp), \"Deserialize assignment may not narrow.\");\n    record->lodMinClamp = transfer->lodMinClamp;\n    static_assert(sizeof(record->lodMaxClamp) >= sizeof(transfer->lodMaxClamp), \"Deserialize assignment may not narrow.\");\n    record->lodMaxClamp = transfer->lodMaxClamp;\n    static_assert(sizeof(record->compare) >= sizeof(transfer->compare), \"Deserialize assignment may not narrow.\");\n    record->compare = transfer->compare;\n    static_assert(sizeof(record->maxAnisotropy) >= sizeof(transfer->maxAnisotropy), \"Deserialize assignment may not narrow.\");\n    record->maxAnisotropy = transfer->maxAnisotropy;\n    bool has_label = transfer->has_label;\n    record->label = nullptr;\n    if (has_label) {\n        uint64_t stringLength64 = transfer->labelStrlen;\n        if (stringLength64 >= std::numeric_limits<size_t>::max()) {\n            return WireResult::FatalError;\n        }\n        size_t stringLength = static_cast<size_t>(stringLength64);\n\n        const volatile char* stringInBuffer;\n        WIRE_TRY(deserializeBuffer->ReadN(stringLength, &stringInBuffer));\n\n        char* copiedString;\n        WIRE_TRY(GetSpace(allocator, stringLength + 1, &copiedString));\n        memcpy(copiedString, const_cast<const char*>(stringInBuffer), stringLength);\n        copiedString[stringLength] = '\\0';\n        record->label = copiedString;\n    }\n\n    return WireResult::Success;\n}\nDAWN_UNUSED_FUNC(WGPUSamplerDescriptorDeserialize);\n\nstruct WGPUShaderModuleDescriptorTransfer {\n    static_assert(0 <= 1,\n                  \"Record must be at most one of is_cmd, extensible, and chained.\");\n    bool hasNextInChain;\n\n    uint64_t labelStrlen;\n    bool has_label;\n};\n\n\nDAWN_DECLARE_UNUSED size_t WGPUShaderModuleDescriptorGetExtraRequiredSize(const WGPUShaderModuleDescriptor& record) {\n    DAWN_UNUSED(record);\n    size_t result = 0;\n\n    if (record.nextInChain != nullptr) {\n        result += GetChainedStructExtraRequiredSize(record.nextInChain);\n    }\n    if (record.label != nullptr) {\n        result += Align(std::strlen(record.label), kWireBufferAlignment);\n    }\n    return result;\n}\n// GetExtraRequiredSize isn't used for structures that are value members of other structures\n// because we assume they cannot contain pointers themselves.\nDAWN_UNUSED_FUNC(WGPUShaderModuleDescriptorGetExtraRequiredSize);\n\nDAWN_DECLARE_UNUSED WireResult WGPUShaderModuleDescriptorSerialize(\n    const WGPUShaderModuleDescriptor& record,\n    WGPUShaderModuleDescriptorTransfer* transfer,\n    SerializeBuffer* buffer, const ObjectIdProvider& provider) {\n    DAWN_UNUSED(buffer);\n\n    if (record.nextInChain != nullptr) {\n        transfer->hasNextInChain = true;\n        WIRE_TRY(SerializeChainedStruct(record.nextInChain, buffer, provider));\n    } else {\n        transfer->hasNextInChain = false;\n    }\n\n    bool has_label = record.label != nullptr;\n    transfer->has_label = has_label;\n    if (has_label) {\n        transfer->labelStrlen = std::strlen(record.label);\n\n        char* stringInBuffer;\n        WIRE_TRY(buffer->NextN(transfer->labelStrlen, &stringInBuffer));\n        memcpy(stringInBuffer, record.label, transfer->labelStrlen);\n    }\n\n    return WireResult::Success;\n}\nDAWN_UNUSED_FUNC(WGPUShaderModuleDescriptorSerialize);\n\nDAWN_DECLARE_UNUSED WireResult WGPUShaderModuleDescriptorDeserialize(\n    WGPUShaderModuleDescriptor* record,\n    const volatile WGPUShaderModuleDescriptorTransfer* transfer,\n    DeserializeBuffer* deserializeBuffer,\n    DeserializeAllocator* allocator, const ObjectIdResolver& resolver) {\n    DAWN_UNUSED(allocator);\n\n\n    record->nextInChain = nullptr;\n    if (transfer->hasNextInChain) {\n        WIRE_TRY(DeserializeChainedStruct(&record->nextInChain, deserializeBuffer, allocator, resolver));\n    }\n\n    bool has_label = transfer->has_label;\n    record->label = nullptr;\n    if (has_label) {\n        uint64_t stringLength64 = transfer->labelStrlen;\n        if (stringLength64 >= std::numeric_limits<size_t>::max()) {\n            return WireResult::FatalError;\n        }\n        size_t stringLength = static_cast<size_t>(stringLength64);\n\n        const volatile char* stringInBuffer;\n        WIRE_TRY(deserializeBuffer->ReadN(stringLength, &stringInBuffer));\n\n        char* copiedString;\n        WIRE_TRY(GetSpace(allocator, stringLength + 1, &copiedString));\n        memcpy(copiedString, const_cast<const char*>(stringInBuffer), stringLength);\n        copiedString[stringLength] = '\\0';\n        record->label = copiedString;\n    }\n\n    return WireResult::Success;\n}\nDAWN_UNUSED_FUNC(WGPUShaderModuleDescriptorDeserialize);\n\nstruct WGPUShaderModuleSPIRVDescriptorTransfer {\n    static_assert(0 <= 1,\n                  \"Record must be at most one of is_cmd, extensible, and chained.\");\n    WGPUChainedStructTransfer chain;\n\n    uint32_t codeSize;\n};\n\nstatic_assert(offsetof(WGPUShaderModuleSPIRVDescriptorTransfer, chain) == 0);\n\nDAWN_DECLARE_UNUSED size_t WGPUShaderModuleSPIRVDescriptorGetExtraRequiredSize(const WGPUShaderModuleSPIRVDescriptor& record) {\n    DAWN_UNUSED(record);\n    size_t result = 0;\n\n    {\n        auto memberLength = record.codeSize;\n        auto size = WireAlignSizeofN<uint32_t>(memberLength);\n        ASSERT(size);\n        result += *size;\n    }\n    return result;\n}\n// GetExtraRequiredSize isn't used for structures that are value members of other structures\n// because we assume they cannot contain pointers themselves.\nDAWN_UNUSED_FUNC(WGPUShaderModuleSPIRVDescriptorGetExtraRequiredSize);\n\nDAWN_DECLARE_UNUSED WireResult WGPUShaderModuleSPIRVDescriptorSerialize(\n    const WGPUShaderModuleSPIRVDescriptor& record,\n    WGPUShaderModuleSPIRVDescriptorTransfer* transfer,\n    SerializeBuffer* buffer, const ObjectIdProvider& provider) {\n    DAWN_UNUSED(buffer);\n\n    ASSERT(transfer->chain.sType == WGPUSType_ShaderModuleSPIRVDescriptor);\n    ASSERT(transfer->chain.hasNext == (record.chain.next != nullptr));\n\n    transfer->codeSize = record.codeSize;\n    {\n        auto memberLength = record.codeSize;\n\n        uint32_t* memberBuffer;\n        WIRE_TRY(buffer->NextN(memberLength, &memberBuffer));\n\n        memcpy(\n            memberBuffer, record.code,\n            sizeof(uint32_t) * memberLength);\n    }\n\n    return WireResult::Success;\n}\nDAWN_UNUSED_FUNC(WGPUShaderModuleSPIRVDescriptorSerialize);\n\nDAWN_DECLARE_UNUSED WireResult WGPUShaderModuleSPIRVDescriptorDeserialize(\n    WGPUShaderModuleSPIRVDescriptor* record,\n    const volatile WGPUShaderModuleSPIRVDescriptorTransfer* transfer,\n    DeserializeBuffer* deserializeBuffer,\n    DeserializeAllocator* allocator, const ObjectIdResolver& resolver) {\n    DAWN_UNUSED(allocator);\n\n\n    ASSERT(record->chain.sType == WGPUSType_ShaderModuleSPIRVDescriptor);\n    ASSERT(record->chain.next == nullptr);\n\n    static_assert(sizeof(record->codeSize) >= sizeof(transfer->codeSize), \"Deserialize assignment may not narrow.\");\n    record->codeSize = transfer->codeSize;\n    {\n        auto memberLength = record->codeSize;\n        const volatile uint32_t* memberBuffer;\n        WIRE_TRY(deserializeBuffer->ReadN(memberLength, &memberBuffer));\n\n        uint32_t* copiedMembers;\n        WIRE_TRY(GetSpace(allocator, memberLength, &copiedMembers));\n        record->code = copiedMembers;\n\n        memcpy(\n            copiedMembers,\n            const_cast<const uint32_t*>(memberBuffer),\n           sizeof(uint32_t) * memberLength);\n    }\n\n    return WireResult::Success;\n}\nDAWN_UNUSED_FUNC(WGPUShaderModuleSPIRVDescriptorDeserialize);\n\nstruct WGPUShaderModuleWGSLDescriptorTransfer {\n    static_assert(0 <= 1,\n                  \"Record must be at most one of is_cmd, extensible, and chained.\");\n    WGPUChainedStructTransfer chain;\n\n    uint64_t codeStrlen;\n};\n\nstatic_assert(offsetof(WGPUShaderModuleWGSLDescriptorTransfer, chain) == 0);\n\nDAWN_DECLARE_UNUSED size_t WGPUShaderModuleWGSLDescriptorGetExtraRequiredSize(const WGPUShaderModuleWGSLDescriptor& record) {\n    DAWN_UNUSED(record);\n    size_t result = 0;\n\n    ASSERT(record.code != nullptr);\n    result += Align(std::strlen(record.code), kWireBufferAlignment);\n    return result;\n}\n// GetExtraRequiredSize isn't used for structures that are value members of other structures\n// because we assume they cannot contain pointers themselves.\nDAWN_UNUSED_FUNC(WGPUShaderModuleWGSLDescriptorGetExtraRequiredSize);\n\nDAWN_DECLARE_UNUSED WireResult WGPUShaderModuleWGSLDescriptorSerialize(\n    const WGPUShaderModuleWGSLDescriptor& record,\n    WGPUShaderModuleWGSLDescriptorTransfer* transfer,\n    SerializeBuffer* buffer, const ObjectIdProvider& provider) {\n    DAWN_UNUSED(buffer);\n\n    ASSERT(transfer->chain.sType == WGPUSType_ShaderModuleWGSLDescriptor);\n    ASSERT(transfer->chain.hasNext == (record.chain.next != nullptr));\n\n    {\n        transfer->codeStrlen = std::strlen(record.code);\n\n        char* stringInBuffer;\n        WIRE_TRY(buffer->NextN(transfer->codeStrlen, &stringInBuffer));\n        memcpy(stringInBuffer, record.code, transfer->codeStrlen);\n    }\n\n    return WireResult::Success;\n}\nDAWN_UNUSED_FUNC(WGPUShaderModuleWGSLDescriptorSerialize);\n\nDAWN_DECLARE_UNUSED WireResult WGPUShaderModuleWGSLDescriptorDeserialize(\n    WGPUShaderModuleWGSLDescriptor* record,\n    const volatile WGPUShaderModuleWGSLDescriptorTransfer* transfer,\n    DeserializeBuffer* deserializeBuffer,\n    DeserializeAllocator* allocator, const ObjectIdResolver& resolver) {\n    DAWN_UNUSED(allocator);\n\n\n    ASSERT(record->chain.sType == WGPUSType_ShaderModuleWGSLDescriptor);\n    ASSERT(record->chain.next == nullptr);\n\n    {\n        uint64_t stringLength64 = transfer->codeStrlen;\n        if (stringLength64 >= std::numeric_limits<size_t>::max()) {\n            return WireResult::FatalError;\n        }\n        size_t stringLength = static_cast<size_t>(stringLength64);\n\n        const volatile char* stringInBuffer;\n        WIRE_TRY(deserializeBuffer->ReadN(stringLength, &stringInBuffer));\n\n        char* copiedString;\n        WIRE_TRY(GetSpace(allocator, stringLength + 1, &copiedString));\n        memcpy(copiedString, const_cast<const char*>(stringInBuffer), stringLength);\n        copiedString[stringLength] = '\\0';\n        record->code = copiedString;\n    }\n\n    return WireResult::Success;\n}\nDAWN_UNUSED_FUNC(WGPUShaderModuleWGSLDescriptorDeserialize);\n\nstruct WGPUStencilFaceStateTransfer {\n    static_assert(0 <= 1,\n                  \"Record must be at most one of is_cmd, extensible, and chained.\");\n\n    WGPUCompareFunction compare;\n    WGPUStencilOperation failOp;\n    WGPUStencilOperation depthFailOp;\n    WGPUStencilOperation passOp;\n};\n\n\nDAWN_DECLARE_UNUSED size_t WGPUStencilFaceStateGetExtraRequiredSize(const WGPUStencilFaceState& record) {\n    DAWN_UNUSED(record);\n    size_t result = 0;\n\n    return result;\n}\n// GetExtraRequiredSize isn't used for structures that are value members of other structures\n// because we assume they cannot contain pointers themselves.\nDAWN_UNUSED_FUNC(WGPUStencilFaceStateGetExtraRequiredSize);\n\nDAWN_DECLARE_UNUSED WireResult WGPUStencilFaceStateSerialize(\n    const WGPUStencilFaceState& record,\n    WGPUStencilFaceStateTransfer* transfer,\n    SerializeBuffer* buffer) {\n    DAWN_UNUSED(buffer);\n\n\n    transfer->compare = record.compare;\n    transfer->failOp = record.failOp;\n    transfer->depthFailOp = record.depthFailOp;\n    transfer->passOp = record.passOp;\n\n    return WireResult::Success;\n}\nDAWN_UNUSED_FUNC(WGPUStencilFaceStateSerialize);\n\nDAWN_DECLARE_UNUSED WireResult WGPUStencilFaceStateDeserialize(\n    WGPUStencilFaceState* record,\n    const volatile WGPUStencilFaceStateTransfer* transfer,\n    DeserializeBuffer* deserializeBuffer,\n    DeserializeAllocator* allocator) {\n    DAWN_UNUSED(allocator);\n\n\n\n    static_assert(sizeof(record->compare) >= sizeof(transfer->compare), \"Deserialize assignment may not narrow.\");\n    record->compare = transfer->compare;\n    static_assert(sizeof(record->failOp) >= sizeof(transfer->failOp), \"Deserialize assignment may not narrow.\");\n    record->failOp = transfer->failOp;\n    static_assert(sizeof(record->depthFailOp) >= sizeof(transfer->depthFailOp), \"Deserialize assignment may not narrow.\");\n    record->depthFailOp = transfer->depthFailOp;\n    static_assert(sizeof(record->passOp) >= sizeof(transfer->passOp), \"Deserialize assignment may not narrow.\");\n    record->passOp = transfer->passOp;\n\n    return WireResult::Success;\n}\nDAWN_UNUSED_FUNC(WGPUStencilFaceStateDeserialize);\n\nstruct WGPUStorageTextureBindingLayoutTransfer {\n    static_assert(0 <= 1,\n                  \"Record must be at most one of is_cmd, extensible, and chained.\");\n    bool hasNextInChain;\n\n    WGPUStorageTextureAccess access;\n    WGPUTextureFormat format;\n    WGPUTextureViewDimension viewDimension;\n};\n\n\nDAWN_DECLARE_UNUSED size_t WGPUStorageTextureBindingLayoutGetExtraRequiredSize(const WGPUStorageTextureBindingLayout& record) {\n    DAWN_UNUSED(record);\n    size_t result = 0;\n\n    if (record.nextInChain != nullptr) {\n        result += GetChainedStructExtraRequiredSize(record.nextInChain);\n    }\n    return result;\n}\n// GetExtraRequiredSize isn't used for structures that are value members of other structures\n// because we assume they cannot contain pointers themselves.\nDAWN_UNUSED_FUNC(WGPUStorageTextureBindingLayoutGetExtraRequiredSize);\n\nDAWN_DECLARE_UNUSED WireResult WGPUStorageTextureBindingLayoutSerialize(\n    const WGPUStorageTextureBindingLayout& record,\n    WGPUStorageTextureBindingLayoutTransfer* transfer,\n    SerializeBuffer* buffer, const ObjectIdProvider& provider) {\n    DAWN_UNUSED(buffer);\n\n    if (record.nextInChain != nullptr) {\n        transfer->hasNextInChain = true;\n        WIRE_TRY(SerializeChainedStruct(record.nextInChain, buffer, provider));\n    } else {\n        transfer->hasNextInChain = false;\n    }\n\n    transfer->access = record.access;\n    transfer->format = record.format;\n    transfer->viewDimension = record.viewDimension;\n\n    return WireResult::Success;\n}\nDAWN_UNUSED_FUNC(WGPUStorageTextureBindingLayoutSerialize);\n\nDAWN_DECLARE_UNUSED WireResult WGPUStorageTextureBindingLayoutDeserialize(\n    WGPUStorageTextureBindingLayout* record,\n    const volatile WGPUStorageTextureBindingLayoutTransfer* transfer,\n    DeserializeBuffer* deserializeBuffer,\n    DeserializeAllocator* allocator, const ObjectIdResolver& resolver) {\n    DAWN_UNUSED(allocator);\n\n\n    record->nextInChain = nullptr;\n    if (transfer->hasNextInChain) {\n        WIRE_TRY(DeserializeChainedStruct(&record->nextInChain, deserializeBuffer, allocator, resolver));\n    }\n\n    static_assert(sizeof(record->access) >= sizeof(transfer->access), \"Deserialize assignment may not narrow.\");\n    record->access = transfer->access;\n    static_assert(sizeof(record->format) >= sizeof(transfer->format), \"Deserialize assignment may not narrow.\");\n    record->format = transfer->format;\n    static_assert(sizeof(record->viewDimension) >= sizeof(transfer->viewDimension), \"Deserialize assignment may not narrow.\");\n    record->viewDimension = transfer->viewDimension;\n\n    return WireResult::Success;\n}\nDAWN_UNUSED_FUNC(WGPUStorageTextureBindingLayoutDeserialize);\n\nstruct WGPUSurfaceDescriptorTransfer {\n    static_assert(0 <= 1,\n                  \"Record must be at most one of is_cmd, extensible, and chained.\");\n    bool hasNextInChain;\n\n    uint64_t labelStrlen;\n    bool has_label;\n};\n\n\nDAWN_DECLARE_UNUSED size_t WGPUSurfaceDescriptorGetExtraRequiredSize(const WGPUSurfaceDescriptor& record) {\n    DAWN_UNUSED(record);\n    size_t result = 0;\n\n    if (record.nextInChain != nullptr) {\n        result += GetChainedStructExtraRequiredSize(record.nextInChain);\n    }\n    if (record.label != nullptr) {\n        result += Align(std::strlen(record.label), kWireBufferAlignment);\n    }\n    return result;\n}\n// GetExtraRequiredSize isn't used for structures that are value members of other structures\n// because we assume they cannot contain pointers themselves.\nDAWN_UNUSED_FUNC(WGPUSurfaceDescriptorGetExtraRequiredSize);\n\nDAWN_DECLARE_UNUSED WireResult WGPUSurfaceDescriptorSerialize(\n    const WGPUSurfaceDescriptor& record,\n    WGPUSurfaceDescriptorTransfer* transfer,\n    SerializeBuffer* buffer, const ObjectIdProvider& provider) {\n    DAWN_UNUSED(buffer);\n\n    if (record.nextInChain != nullptr) {\n        transfer->hasNextInChain = true;\n        WIRE_TRY(SerializeChainedStruct(record.nextInChain, buffer, provider));\n    } else {\n        transfer->hasNextInChain = false;\n    }\n\n    bool has_label = record.label != nullptr;\n    transfer->has_label = has_label;\n    if (has_label) {\n        transfer->labelStrlen = std::strlen(record.label);\n\n        char* stringInBuffer;\n        WIRE_TRY(buffer->NextN(transfer->labelStrlen, &stringInBuffer));\n        memcpy(stringInBuffer, record.label, transfer->labelStrlen);\n    }\n\n    return WireResult::Success;\n}\nDAWN_UNUSED_FUNC(WGPUSurfaceDescriptorSerialize);\n\nDAWN_DECLARE_UNUSED WireResult WGPUSurfaceDescriptorDeserialize(\n    WGPUSurfaceDescriptor* record,\n    const volatile WGPUSurfaceDescriptorTransfer* transfer,\n    DeserializeBuffer* deserializeBuffer,\n    DeserializeAllocator* allocator, const ObjectIdResolver& resolver) {\n    DAWN_UNUSED(allocator);\n\n\n    record->nextInChain = nullptr;\n    if (transfer->hasNextInChain) {\n        WIRE_TRY(DeserializeChainedStruct(&record->nextInChain, deserializeBuffer, allocator, resolver));\n    }\n\n    bool has_label = transfer->has_label;\n    record->label = nullptr;\n    if (has_label) {\n        uint64_t stringLength64 = transfer->labelStrlen;\n        if (stringLength64 >= std::numeric_limits<size_t>::max()) {\n            return WireResult::FatalError;\n        }\n        size_t stringLength = static_cast<size_t>(stringLength64);\n\n        const volatile char* stringInBuffer;\n        WIRE_TRY(deserializeBuffer->ReadN(stringLength, &stringInBuffer));\n\n        char* copiedString;\n        WIRE_TRY(GetSpace(allocator, stringLength + 1, &copiedString));\n        memcpy(copiedString, const_cast<const char*>(stringInBuffer), stringLength);\n        copiedString[stringLength] = '\\0';\n        record->label = copiedString;\n    }\n\n    return WireResult::Success;\n}\nDAWN_UNUSED_FUNC(WGPUSurfaceDescriptorDeserialize);\n\nstruct WGPUSurfaceDescriptorFromCanvasHTMLSelectorTransfer {\n    static_assert(0 <= 1,\n                  \"Record must be at most one of is_cmd, extensible, and chained.\");\n    WGPUChainedStructTransfer chain;\n\n    uint64_t selectorStrlen;\n};\n\nstatic_assert(offsetof(WGPUSurfaceDescriptorFromCanvasHTMLSelectorTransfer, chain) == 0);\n\nDAWN_DECLARE_UNUSED size_t WGPUSurfaceDescriptorFromCanvasHTMLSelectorGetExtraRequiredSize(const WGPUSurfaceDescriptorFromCanvasHTMLSelector& record) {\n    DAWN_UNUSED(record);\n    size_t result = 0;\n\n    ASSERT(record.selector != nullptr);\n    result += Align(std::strlen(record.selector), kWireBufferAlignment);\n    return result;\n}\n// GetExtraRequiredSize isn't used for structures that are value members of other structures\n// because we assume they cannot contain pointers themselves.\nDAWN_UNUSED_FUNC(WGPUSurfaceDescriptorFromCanvasHTMLSelectorGetExtraRequiredSize);\n\nDAWN_DECLARE_UNUSED WireResult WGPUSurfaceDescriptorFromCanvasHTMLSelectorSerialize(\n    const WGPUSurfaceDescriptorFromCanvasHTMLSelector& record,\n    WGPUSurfaceDescriptorFromCanvasHTMLSelectorTransfer* transfer,\n    SerializeBuffer* buffer, const ObjectIdProvider& provider) {\n    DAWN_UNUSED(buffer);\n\n    ASSERT(transfer->chain.sType == WGPUSType_SurfaceDescriptorFromCanvasHTMLSelector);\n    ASSERT(transfer->chain.hasNext == (record.chain.next != nullptr));\n\n    {\n        transfer->selectorStrlen = std::strlen(record.selector);\n\n        char* stringInBuffer;\n        WIRE_TRY(buffer->NextN(transfer->selectorStrlen, &stringInBuffer));\n        memcpy(stringInBuffer, record.selector, transfer->selectorStrlen);\n    }\n\n    return WireResult::Success;\n}\nDAWN_UNUSED_FUNC(WGPUSurfaceDescriptorFromCanvasHTMLSelectorSerialize);\n\nDAWN_DECLARE_UNUSED WireResult WGPUSurfaceDescriptorFromCanvasHTMLSelectorDeserialize(\n    WGPUSurfaceDescriptorFromCanvasHTMLSelector* record,\n    const volatile WGPUSurfaceDescriptorFromCanvasHTMLSelectorTransfer* transfer,\n    DeserializeBuffer* deserializeBuffer,\n    DeserializeAllocator* allocator, const ObjectIdResolver& resolver) {\n    DAWN_UNUSED(allocator);\n\n\n    ASSERT(record->chain.sType == WGPUSType_SurfaceDescriptorFromCanvasHTMLSelector);\n    ASSERT(record->chain.next == nullptr);\n\n    {\n        uint64_t stringLength64 = transfer->selectorStrlen;\n        if (stringLength64 >= std::numeric_limits<size_t>::max()) {\n            return WireResult::FatalError;\n        }\n        size_t stringLength = static_cast<size_t>(stringLength64);\n\n        const volatile char* stringInBuffer;\n        WIRE_TRY(deserializeBuffer->ReadN(stringLength, &stringInBuffer));\n\n        char* copiedString;\n        WIRE_TRY(GetSpace(allocator, stringLength + 1, &copiedString));\n        memcpy(copiedString, const_cast<const char*>(stringInBuffer), stringLength);\n        copiedString[stringLength] = '\\0';\n        record->selector = copiedString;\n    }\n\n    return WireResult::Success;\n}\nDAWN_UNUSED_FUNC(WGPUSurfaceDescriptorFromCanvasHTMLSelectorDeserialize);\n\nstruct WGPUSwapChainDescriptorTransfer {\n    static_assert(0 <= 1,\n                  \"Record must be at most one of is_cmd, extensible, and chained.\");\n    bool hasNextInChain;\n\n    uint64_t labelStrlen;\n    bool has_label;\n    WGPUTextureUsageFlags usage;\n    WGPUTextureFormat format;\n    uint32_t width;\n    uint32_t height;\n    WGPUPresentMode presentMode;\n};\n\n\nDAWN_DECLARE_UNUSED size_t WGPUSwapChainDescriptorGetExtraRequiredSize(const WGPUSwapChainDescriptor& record) {\n    DAWN_UNUSED(record);\n    size_t result = 0;\n\n    if (record.nextInChain != nullptr) {\n        result += GetChainedStructExtraRequiredSize(record.nextInChain);\n    }\n    if (record.label != nullptr) {\n        result += Align(std::strlen(record.label), kWireBufferAlignment);\n    }\n    return result;\n}\n// GetExtraRequiredSize isn't used for structures that are value members of other structures\n// because we assume they cannot contain pointers themselves.\nDAWN_UNUSED_FUNC(WGPUSwapChainDescriptorGetExtraRequiredSize);\n\nDAWN_DECLARE_UNUSED WireResult WGPUSwapChainDescriptorSerialize(\n    const WGPUSwapChainDescriptor& record,\n    WGPUSwapChainDescriptorTransfer* transfer,\n    SerializeBuffer* buffer, const ObjectIdProvider& provider) {\n    DAWN_UNUSED(buffer);\n\n    if (record.nextInChain != nullptr) {\n        transfer->hasNextInChain = true;\n        WIRE_TRY(SerializeChainedStruct(record.nextInChain, buffer, provider));\n    } else {\n        transfer->hasNextInChain = false;\n    }\n\n    transfer->usage = record.usage;\n    transfer->format = record.format;\n    transfer->width = record.width;\n    transfer->height = record.height;\n    transfer->presentMode = record.presentMode;\n    bool has_label = record.label != nullptr;\n    transfer->has_label = has_label;\n    if (has_label) {\n        transfer->labelStrlen = std::strlen(record.label);\n\n        char* stringInBuffer;\n        WIRE_TRY(buffer->NextN(transfer->labelStrlen, &stringInBuffer));\n        memcpy(stringInBuffer, record.label, transfer->labelStrlen);\n    }\n\n    return WireResult::Success;\n}\nDAWN_UNUSED_FUNC(WGPUSwapChainDescriptorSerialize);\n\nDAWN_DECLARE_UNUSED WireResult WGPUSwapChainDescriptorDeserialize(\n    WGPUSwapChainDescriptor* record,\n    const volatile WGPUSwapChainDescriptorTransfer* transfer,\n    DeserializeBuffer* deserializeBuffer,\n    DeserializeAllocator* allocator, const ObjectIdResolver& resolver) {\n    DAWN_UNUSED(allocator);\n\n\n    record->nextInChain = nullptr;\n    if (transfer->hasNextInChain) {\n        WIRE_TRY(DeserializeChainedStruct(&record->nextInChain, deserializeBuffer, allocator, resolver));\n    }\n\n    static_assert(sizeof(record->usage) >= sizeof(transfer->usage), \"Deserialize assignment may not narrow.\");\n    record->usage = transfer->usage;\n    static_assert(sizeof(record->format) >= sizeof(transfer->format), \"Deserialize assignment may not narrow.\");\n    record->format = transfer->format;\n    static_assert(sizeof(record->width) >= sizeof(transfer->width), \"Deserialize assignment may not narrow.\");\n    record->width = transfer->width;\n    static_assert(sizeof(record->height) >= sizeof(transfer->height), \"Deserialize assignment may not narrow.\");\n    record->height = transfer->height;\n    static_assert(sizeof(record->presentMode) >= sizeof(transfer->presentMode), \"Deserialize assignment may not narrow.\");\n    record->presentMode = transfer->presentMode;\n    bool has_label = transfer->has_label;\n    record->label = nullptr;\n    if (has_label) {\n        uint64_t stringLength64 = transfer->labelStrlen;\n        if (stringLength64 >= std::numeric_limits<size_t>::max()) {\n            return WireResult::FatalError;\n        }\n        size_t stringLength = static_cast<size_t>(stringLength64);\n\n        const volatile char* stringInBuffer;\n        WIRE_TRY(deserializeBuffer->ReadN(stringLength, &stringInBuffer));\n\n        char* copiedString;\n        WIRE_TRY(GetSpace(allocator, stringLength + 1, &copiedString));\n        memcpy(copiedString, const_cast<const char*>(stringInBuffer), stringLength);\n        copiedString[stringLength] = '\\0';\n        record->label = copiedString;\n    }\n\n    return WireResult::Success;\n}\nDAWN_UNUSED_FUNC(WGPUSwapChainDescriptorDeserialize);\n\nstruct WGPUTextureBindingLayoutTransfer {\n    static_assert(0 <= 1,\n                  \"Record must be at most one of is_cmd, extensible, and chained.\");\n    bool hasNextInChain;\n\n    WGPUTextureSampleType sampleType;\n    WGPUTextureViewDimension viewDimension;\n    bool multisampled;\n};\n\n\nDAWN_DECLARE_UNUSED size_t WGPUTextureBindingLayoutGetExtraRequiredSize(const WGPUTextureBindingLayout& record) {\n    DAWN_UNUSED(record);\n    size_t result = 0;\n\n    if (record.nextInChain != nullptr) {\n        result += GetChainedStructExtraRequiredSize(record.nextInChain);\n    }\n    return result;\n}\n// GetExtraRequiredSize isn't used for structures that are value members of other structures\n// because we assume they cannot contain pointers themselves.\nDAWN_UNUSED_FUNC(WGPUTextureBindingLayoutGetExtraRequiredSize);\n\nDAWN_DECLARE_UNUSED WireResult WGPUTextureBindingLayoutSerialize(\n    const WGPUTextureBindingLayout& record,\n    WGPUTextureBindingLayoutTransfer* transfer,\n    SerializeBuffer* buffer, const ObjectIdProvider& provider) {\n    DAWN_UNUSED(buffer);\n\n    if (record.nextInChain != nullptr) {\n        transfer->hasNextInChain = true;\n        WIRE_TRY(SerializeChainedStruct(record.nextInChain, buffer, provider));\n    } else {\n        transfer->hasNextInChain = false;\n    }\n\n    transfer->sampleType = record.sampleType;\n    transfer->viewDimension = record.viewDimension;\n    transfer->multisampled = record.multisampled;\n\n    return WireResult::Success;\n}\nDAWN_UNUSED_FUNC(WGPUTextureBindingLayoutSerialize);\n\nDAWN_DECLARE_UNUSED WireResult WGPUTextureBindingLayoutDeserialize(\n    WGPUTextureBindingLayout* record,\n    const volatile WGPUTextureBindingLayoutTransfer* transfer,\n    DeserializeBuffer* deserializeBuffer,\n    DeserializeAllocator* allocator, const ObjectIdResolver& resolver) {\n    DAWN_UNUSED(allocator);\n\n\n    record->nextInChain = nullptr;\n    if (transfer->hasNextInChain) {\n        WIRE_TRY(DeserializeChainedStruct(&record->nextInChain, deserializeBuffer, allocator, resolver));\n    }\n\n    static_assert(sizeof(record->sampleType) >= sizeof(transfer->sampleType), \"Deserialize assignment may not narrow.\");\n    record->sampleType = transfer->sampleType;\n    static_assert(sizeof(record->viewDimension) >= sizeof(transfer->viewDimension), \"Deserialize assignment may not narrow.\");\n    record->viewDimension = transfer->viewDimension;\n    static_assert(sizeof(record->multisampled) >= sizeof(transfer->multisampled), \"Deserialize assignment may not narrow.\");\n    record->multisampled = transfer->multisampled;\n\n    return WireResult::Success;\n}\nDAWN_UNUSED_FUNC(WGPUTextureBindingLayoutDeserialize);\n\nstruct WGPUTextureDataLayoutTransfer {\n    static_assert(0 <= 1,\n                  \"Record must be at most one of is_cmd, extensible, and chained.\");\n    bool hasNextInChain;\n\n    uint64_t offset;\n    uint32_t bytesPerRow;\n    uint32_t rowsPerImage;\n};\n\n\nDAWN_DECLARE_UNUSED size_t WGPUTextureDataLayoutGetExtraRequiredSize(const WGPUTextureDataLayout& record) {\n    DAWN_UNUSED(record);\n    size_t result = 0;\n\n    if (record.nextInChain != nullptr) {\n        result += GetChainedStructExtraRequiredSize(record.nextInChain);\n    }\n    return result;\n}\n// GetExtraRequiredSize isn't used for structures that are value members of other structures\n// because we assume they cannot contain pointers themselves.\nDAWN_UNUSED_FUNC(WGPUTextureDataLayoutGetExtraRequiredSize);\n\nDAWN_DECLARE_UNUSED WireResult WGPUTextureDataLayoutSerialize(\n    const WGPUTextureDataLayout& record,\n    WGPUTextureDataLayoutTransfer* transfer,\n    SerializeBuffer* buffer, const ObjectIdProvider& provider) {\n    DAWN_UNUSED(buffer);\n\n    if (record.nextInChain != nullptr) {\n        transfer->hasNextInChain = true;\n        WIRE_TRY(SerializeChainedStruct(record.nextInChain, buffer, provider));\n    } else {\n        transfer->hasNextInChain = false;\n    }\n\n    transfer->offset = record.offset;\n    transfer->bytesPerRow = record.bytesPerRow;\n    transfer->rowsPerImage = record.rowsPerImage;\n\n    return WireResult::Success;\n}\nDAWN_UNUSED_FUNC(WGPUTextureDataLayoutSerialize);\n\nDAWN_DECLARE_UNUSED WireResult WGPUTextureDataLayoutDeserialize(\n    WGPUTextureDataLayout* record,\n    const volatile WGPUTextureDataLayoutTransfer* transfer,\n    DeserializeBuffer* deserializeBuffer,\n    DeserializeAllocator* allocator, const ObjectIdResolver& resolver) {\n    DAWN_UNUSED(allocator);\n\n\n    record->nextInChain = nullptr;\n    if (transfer->hasNextInChain) {\n        WIRE_TRY(DeserializeChainedStruct(&record->nextInChain, deserializeBuffer, allocator, resolver));\n    }\n\n    static_assert(sizeof(record->offset) >= sizeof(transfer->offset), \"Deserialize assignment may not narrow.\");\n    record->offset = transfer->offset;\n    static_assert(sizeof(record->bytesPerRow) >= sizeof(transfer->bytesPerRow), \"Deserialize assignment may not narrow.\");\n    record->bytesPerRow = transfer->bytesPerRow;\n    static_assert(sizeof(record->rowsPerImage) >= sizeof(transfer->rowsPerImage), \"Deserialize assignment may not narrow.\");\n    record->rowsPerImage = transfer->rowsPerImage;\n\n    return WireResult::Success;\n}\nDAWN_UNUSED_FUNC(WGPUTextureDataLayoutDeserialize);\n\nstruct WGPUTextureViewDescriptorTransfer {\n    static_assert(0 <= 1,\n                  \"Record must be at most one of is_cmd, extensible, and chained.\");\n    bool hasNextInChain;\n\n    uint64_t labelStrlen;\n    bool has_label;\n    WGPUTextureFormat format;\n    WGPUTextureViewDimension dimension;\n    uint32_t baseMipLevel;\n    uint32_t mipLevelCount;\n    uint32_t baseArrayLayer;\n    uint32_t arrayLayerCount;\n    WGPUTextureAspect aspect;\n};\n\n\nDAWN_DECLARE_UNUSED size_t WGPUTextureViewDescriptorGetExtraRequiredSize(const WGPUTextureViewDescriptor& record) {\n    DAWN_UNUSED(record);\n    size_t result = 0;\n\n    if (record.nextInChain != nullptr) {\n        result += GetChainedStructExtraRequiredSize(record.nextInChain);\n    }\n    if (record.label != nullptr) {\n        result += Align(std::strlen(record.label), kWireBufferAlignment);\n    }\n    return result;\n}\n// GetExtraRequiredSize isn't used for structures that are value members of other structures\n// because we assume they cannot contain pointers themselves.\nDAWN_UNUSED_FUNC(WGPUTextureViewDescriptorGetExtraRequiredSize);\n\nDAWN_DECLARE_UNUSED WireResult WGPUTextureViewDescriptorSerialize(\n    const WGPUTextureViewDescriptor& record,\n    WGPUTextureViewDescriptorTransfer* transfer,\n    SerializeBuffer* buffer, const ObjectIdProvider& provider) {\n    DAWN_UNUSED(buffer);\n\n    if (record.nextInChain != nullptr) {\n        transfer->hasNextInChain = true;\n        WIRE_TRY(SerializeChainedStruct(record.nextInChain, buffer, provider));\n    } else {\n        transfer->hasNextInChain = false;\n    }\n\n    transfer->format = record.format;\n    transfer->dimension = record.dimension;\n    transfer->baseMipLevel = record.baseMipLevel;\n    transfer->mipLevelCount = record.mipLevelCount;\n    transfer->baseArrayLayer = record.baseArrayLayer;\n    transfer->arrayLayerCount = record.arrayLayerCount;\n    transfer->aspect = record.aspect;\n    bool has_label = record.label != nullptr;\n    transfer->has_label = has_label;\n    if (has_label) {\n        transfer->labelStrlen = std::strlen(record.label);\n\n        char* stringInBuffer;\n        WIRE_TRY(buffer->NextN(transfer->labelStrlen, &stringInBuffer));\n        memcpy(stringInBuffer, record.label, transfer->labelStrlen);\n    }\n\n    return WireResult::Success;\n}\nDAWN_UNUSED_FUNC(WGPUTextureViewDescriptorSerialize);\n\nDAWN_DECLARE_UNUSED WireResult WGPUTextureViewDescriptorDeserialize(\n    WGPUTextureViewDescriptor* record,\n    const volatile WGPUTextureViewDescriptorTransfer* transfer,\n    DeserializeBuffer* deserializeBuffer,\n    DeserializeAllocator* allocator, const ObjectIdResolver& resolver) {\n    DAWN_UNUSED(allocator);\n\n\n    record->nextInChain = nullptr;\n    if (transfer->hasNextInChain) {\n        WIRE_TRY(DeserializeChainedStruct(&record->nextInChain, deserializeBuffer, allocator, resolver));\n    }\n\n    static_assert(sizeof(record->format) >= sizeof(transfer->format), \"Deserialize assignment may not narrow.\");\n    record->format = transfer->format;\n    static_assert(sizeof(record->dimension) >= sizeof(transfer->dimension), \"Deserialize assignment may not narrow.\");\n    record->dimension = transfer->dimension;\n    static_assert(sizeof(record->baseMipLevel) >= sizeof(transfer->baseMipLevel), \"Deserialize assignment may not narrow.\");\n    record->baseMipLevel = transfer->baseMipLevel;\n    static_assert(sizeof(record->mipLevelCount) >= sizeof(transfer->mipLevelCount), \"Deserialize assignment may not narrow.\");\n    record->mipLevelCount = transfer->mipLevelCount;\n    static_assert(sizeof(record->baseArrayLayer) >= sizeof(transfer->baseArrayLayer), \"Deserialize assignment may not narrow.\");\n    record->baseArrayLayer = transfer->baseArrayLayer;\n    static_assert(sizeof(record->arrayLayerCount) >= sizeof(transfer->arrayLayerCount), \"Deserialize assignment may not narrow.\");\n    record->arrayLayerCount = transfer->arrayLayerCount;\n    static_assert(sizeof(record->aspect) >= sizeof(transfer->aspect), \"Deserialize assignment may not narrow.\");\n    record->aspect = transfer->aspect;\n    bool has_label = transfer->has_label;\n    record->label = nullptr;\n    if (has_label) {\n        uint64_t stringLength64 = transfer->labelStrlen;\n        if (stringLength64 >= std::numeric_limits<size_t>::max()) {\n            return WireResult::FatalError;\n        }\n        size_t stringLength = static_cast<size_t>(stringLength64);\n\n        const volatile char* stringInBuffer;\n        WIRE_TRY(deserializeBuffer->ReadN(stringLength, &stringInBuffer));\n\n        char* copiedString;\n        WIRE_TRY(GetSpace(allocator, stringLength + 1, &copiedString));\n        memcpy(copiedString, const_cast<const char*>(stringInBuffer), stringLength);\n        copiedString[stringLength] = '\\0';\n        record->label = copiedString;\n    }\n\n    return WireResult::Success;\n}\nDAWN_UNUSED_FUNC(WGPUTextureViewDescriptorDeserialize);\n\nstruct WGPUVertexAttributeTransfer {\n    static_assert(0 <= 1,\n                  \"Record must be at most one of is_cmd, extensible, and chained.\");\n\n    WGPUVertexFormat format;\n    uint64_t offset;\n    uint32_t shaderLocation;\n};\n\n\nDAWN_DECLARE_UNUSED size_t WGPUVertexAttributeGetExtraRequiredSize(const WGPUVertexAttribute& record) {\n    DAWN_UNUSED(record);\n    size_t result = 0;\n\n    return result;\n}\n// GetExtraRequiredSize isn't used for structures that are value members of other structures\n// because we assume they cannot contain pointers themselves.\nDAWN_UNUSED_FUNC(WGPUVertexAttributeGetExtraRequiredSize);\n\nDAWN_DECLARE_UNUSED WireResult WGPUVertexAttributeSerialize(\n    const WGPUVertexAttribute& record,\n    WGPUVertexAttributeTransfer* transfer,\n    SerializeBuffer* buffer) {\n    DAWN_UNUSED(buffer);\n\n\n    transfer->format = record.format;\n    transfer->offset = record.offset;\n    transfer->shaderLocation = record.shaderLocation;\n\n    return WireResult::Success;\n}\nDAWN_UNUSED_FUNC(WGPUVertexAttributeSerialize);\n\nDAWN_DECLARE_UNUSED WireResult WGPUVertexAttributeDeserialize(\n    WGPUVertexAttribute* record,\n    const volatile WGPUVertexAttributeTransfer* transfer,\n    DeserializeBuffer* deserializeBuffer,\n    DeserializeAllocator* allocator) {\n    DAWN_UNUSED(allocator);\n\n\n\n    static_assert(sizeof(record->format) >= sizeof(transfer->format), \"Deserialize assignment may not narrow.\");\n    record->format = transfer->format;\n    static_assert(sizeof(record->offset) >= sizeof(transfer->offset), \"Deserialize assignment may not narrow.\");\n    record->offset = transfer->offset;\n    static_assert(sizeof(record->shaderLocation) >= sizeof(transfer->shaderLocation), \"Deserialize assignment may not narrow.\");\n    record->shaderLocation = transfer->shaderLocation;\n\n    return WireResult::Success;\n}\nDAWN_UNUSED_FUNC(WGPUVertexAttributeDeserialize);\n\nstruct WGPUBindGroupDescriptorTransfer {\n    static_assert(0 <= 1,\n                  \"Record must be at most one of is_cmd, extensible, and chained.\");\n    bool hasNextInChain;\n\n    uint64_t labelStrlen;\n    bool has_label;\n    ObjectId layout;\n    uint64_t entryCount;\n};\n\n\nDAWN_DECLARE_UNUSED size_t WGPUBindGroupDescriptorGetExtraRequiredSize(const WGPUBindGroupDescriptor& record) {\n    DAWN_UNUSED(record);\n    size_t result = 0;\n\n    if (record.nextInChain != nullptr) {\n        result += GetChainedStructExtraRequiredSize(record.nextInChain);\n    }\n    if (record.label != nullptr) {\n        result += Align(std::strlen(record.label), kWireBufferAlignment);\n    }\n    {\n        auto memberLength = record.entryCount;\n        auto size = WireAlignSizeofN<WGPUBindGroupEntryTransfer>(memberLength);\n        ASSERT(size);\n        result += *size;\n        for (decltype(memberLength) i = 0; i < memberLength; ++i) {\n            result += WGPUBindGroupEntryGetExtraRequiredSize(record.entries[i]);\n        }\n    }\n    return result;\n}\n// GetExtraRequiredSize isn't used for structures that are value members of other structures\n// because we assume they cannot contain pointers themselves.\nDAWN_UNUSED_FUNC(WGPUBindGroupDescriptorGetExtraRequiredSize);\n\nDAWN_DECLARE_UNUSED WireResult WGPUBindGroupDescriptorSerialize(\n    const WGPUBindGroupDescriptor& record,\n    WGPUBindGroupDescriptorTransfer* transfer,\n    SerializeBuffer* buffer, const ObjectIdProvider& provider) {\n    DAWN_UNUSED(buffer);\n\n    if (record.nextInChain != nullptr) {\n        transfer->hasNextInChain = true;\n        WIRE_TRY(SerializeChainedStruct(record.nextInChain, buffer, provider));\n    } else {\n        transfer->hasNextInChain = false;\n    }\n\n    WIRE_TRY(provider.GetId(record.layout, &transfer->layout));\n    transfer->entryCount = record.entryCount;\n    bool has_label = record.label != nullptr;\n    transfer->has_label = has_label;\n    if (has_label) {\n        transfer->labelStrlen = std::strlen(record.label);\n\n        char* stringInBuffer;\n        WIRE_TRY(buffer->NextN(transfer->labelStrlen, &stringInBuffer));\n        memcpy(stringInBuffer, record.label, transfer->labelStrlen);\n    }\n    {\n        auto memberLength = record.entryCount;\n\n        WGPUBindGroupEntryTransfer* memberBuffer;\n        WIRE_TRY(buffer->NextN(memberLength, &memberBuffer));\n\n        for (decltype(memberLength) i = 0; i < memberLength; ++i) {\n            WIRE_TRY(WGPUBindGroupEntrySerialize(record.entries[i], &memberBuffer[i], buffer, provider));\n        }\n    }\n\n    return WireResult::Success;\n}\nDAWN_UNUSED_FUNC(WGPUBindGroupDescriptorSerialize);\n\nDAWN_DECLARE_UNUSED WireResult WGPUBindGroupDescriptorDeserialize(\n    WGPUBindGroupDescriptor* record,\n    const volatile WGPUBindGroupDescriptorTransfer* transfer,\n    DeserializeBuffer* deserializeBuffer,\n    DeserializeAllocator* allocator, const ObjectIdResolver& resolver) {\n    DAWN_UNUSED(allocator);\n\n\n    record->nextInChain = nullptr;\n    if (transfer->hasNextInChain) {\n        WIRE_TRY(DeserializeChainedStruct(&record->nextInChain, deserializeBuffer, allocator, resolver));\n    }\n\n    WIRE_TRY(resolver.GetFromId(transfer->layout, &record->layout));\n    if (transfer->entryCount > std::numeric_limits<size_t>::max()) return WireResult::FatalError;\n    record->entryCount = checked_cast<size_t>(transfer->entryCount);\n    bool has_label = transfer->has_label;\n    record->label = nullptr;\n    if (has_label) {\n        uint64_t stringLength64 = transfer->labelStrlen;\n        if (stringLength64 >= std::numeric_limits<size_t>::max()) {\n            return WireResult::FatalError;\n        }\n        size_t stringLength = static_cast<size_t>(stringLength64);\n\n        const volatile char* stringInBuffer;\n        WIRE_TRY(deserializeBuffer->ReadN(stringLength, &stringInBuffer));\n\n        char* copiedString;\n        WIRE_TRY(GetSpace(allocator, stringLength + 1, &copiedString));\n        memcpy(copiedString, const_cast<const char*>(stringInBuffer), stringLength);\n        copiedString[stringLength] = '\\0';\n        record->label = copiedString;\n    }\n    {\n        auto memberLength = record->entryCount;\n        const volatile WGPUBindGroupEntryTransfer* memberBuffer;\n        WIRE_TRY(deserializeBuffer->ReadN(memberLength, &memberBuffer));\n\n        WGPUBindGroupEntry* copiedMembers;\n        WIRE_TRY(GetSpace(allocator, memberLength, &copiedMembers));\n        record->entries = copiedMembers;\n\n        for (decltype(memberLength) i = 0; i < memberLength; ++i) {\n            WIRE_TRY(WGPUBindGroupEntryDeserialize(&copiedMembers[i], &memberBuffer[i], deserializeBuffer, allocator, resolver));\n        }\n    }\n\n    return WireResult::Success;\n}\nDAWN_UNUSED_FUNC(WGPUBindGroupDescriptorDeserialize);\n\nstruct WGPUBindGroupLayoutEntryTransfer {\n    static_assert(0 <= 1,\n                  \"Record must be at most one of is_cmd, extensible, and chained.\");\n    bool hasNextInChain;\n\n    uint32_t binding;\n    WGPUShaderStageFlags visibility;\n    WGPUBufferBindingLayoutTransfer buffer;\n    WGPUSamplerBindingLayoutTransfer sampler;\n    WGPUTextureBindingLayoutTransfer texture;\n    WGPUStorageTextureBindingLayoutTransfer storageTexture;\n};\n\n\nDAWN_DECLARE_UNUSED size_t WGPUBindGroupLayoutEntryGetExtraRequiredSize(const WGPUBindGroupLayoutEntry& record) {\n    DAWN_UNUSED(record);\n    size_t result = 0;\n\n    if (record.nextInChain != nullptr) {\n        result += GetChainedStructExtraRequiredSize(record.nextInChain);\n    }\n    {\n        result += WGPUBufferBindingLayoutGetExtraRequiredSize(record.buffer);\n    }\n    {\n        result += WGPUSamplerBindingLayoutGetExtraRequiredSize(record.sampler);\n    }\n    {\n        result += WGPUTextureBindingLayoutGetExtraRequiredSize(record.texture);\n    }\n    {\n        result += WGPUStorageTextureBindingLayoutGetExtraRequiredSize(record.storageTexture);\n    }\n    return result;\n}\n// GetExtraRequiredSize isn't used for structures that are value members of other structures\n// because we assume they cannot contain pointers themselves.\nDAWN_UNUSED_FUNC(WGPUBindGroupLayoutEntryGetExtraRequiredSize);\n\nDAWN_DECLARE_UNUSED WireResult WGPUBindGroupLayoutEntrySerialize(\n    const WGPUBindGroupLayoutEntry& record,\n    WGPUBindGroupLayoutEntryTransfer* transfer,\n    SerializeBuffer* buffer, const ObjectIdProvider& provider) {\n    DAWN_UNUSED(buffer);\n\n    if (record.nextInChain != nullptr) {\n        transfer->hasNextInChain = true;\n        WIRE_TRY(SerializeChainedStruct(record.nextInChain, buffer, provider));\n    } else {\n        transfer->hasNextInChain = false;\n    }\n\n    transfer->binding = record.binding;\n    transfer->visibility = record.visibility;\n    WIRE_TRY(WGPUBufferBindingLayoutSerialize(record.buffer, &transfer->buffer, buffer, provider));\n    WIRE_TRY(WGPUSamplerBindingLayoutSerialize(record.sampler, &transfer->sampler, buffer, provider));\n    WIRE_TRY(WGPUTextureBindingLayoutSerialize(record.texture, &transfer->texture, buffer, provider));\n    WIRE_TRY(WGPUStorageTextureBindingLayoutSerialize(record.storageTexture, &transfer->storageTexture, buffer, provider));\n\n    return WireResult::Success;\n}\nDAWN_UNUSED_FUNC(WGPUBindGroupLayoutEntrySerialize);\n\nDAWN_DECLARE_UNUSED WireResult WGPUBindGroupLayoutEntryDeserialize(\n    WGPUBindGroupLayoutEntry* record,\n    const volatile WGPUBindGroupLayoutEntryTransfer* transfer,\n    DeserializeBuffer* deserializeBuffer,\n    DeserializeAllocator* allocator, const ObjectIdResolver& resolver) {\n    DAWN_UNUSED(allocator);\n\n\n    record->nextInChain = nullptr;\n    if (transfer->hasNextInChain) {\n        WIRE_TRY(DeserializeChainedStruct(&record->nextInChain, deserializeBuffer, allocator, resolver));\n    }\n\n    static_assert(sizeof(record->binding) >= sizeof(transfer->binding), \"Deserialize assignment may not narrow.\");\n    record->binding = transfer->binding;\n    static_assert(sizeof(record->visibility) >= sizeof(transfer->visibility), \"Deserialize assignment may not narrow.\");\n    record->visibility = transfer->visibility;\n    WIRE_TRY(WGPUBufferBindingLayoutDeserialize(&record->buffer, &transfer->buffer, deserializeBuffer, allocator, resolver));\n    WIRE_TRY(WGPUSamplerBindingLayoutDeserialize(&record->sampler, &transfer->sampler, deserializeBuffer, allocator, resolver));\n    WIRE_TRY(WGPUTextureBindingLayoutDeserialize(&record->texture, &transfer->texture, deserializeBuffer, allocator, resolver));\n    WIRE_TRY(WGPUStorageTextureBindingLayoutDeserialize(&record->storageTexture, &transfer->storageTexture, deserializeBuffer, allocator, resolver));\n\n    return WireResult::Success;\n}\nDAWN_UNUSED_FUNC(WGPUBindGroupLayoutEntryDeserialize);\n\nstruct WGPUBlendStateTransfer {\n    static_assert(0 <= 1,\n                  \"Record must be at most one of is_cmd, extensible, and chained.\");\n\n    WGPUBlendComponentTransfer color;\n    WGPUBlendComponentTransfer alpha;\n};\n\n\nDAWN_DECLARE_UNUSED size_t WGPUBlendStateGetExtraRequiredSize(const WGPUBlendState& record) {\n    DAWN_UNUSED(record);\n    size_t result = 0;\n\n    {\n        result += WGPUBlendComponentGetExtraRequiredSize(record.color);\n    }\n    {\n        result += WGPUBlendComponentGetExtraRequiredSize(record.alpha);\n    }\n    return result;\n}\n// GetExtraRequiredSize isn't used for structures that are value members of other structures\n// because we assume they cannot contain pointers themselves.\nDAWN_UNUSED_FUNC(WGPUBlendStateGetExtraRequiredSize);\n\nDAWN_DECLARE_UNUSED WireResult WGPUBlendStateSerialize(\n    const WGPUBlendState& record,\n    WGPUBlendStateTransfer* transfer,\n    SerializeBuffer* buffer) {\n    DAWN_UNUSED(buffer);\n\n\n    WIRE_TRY(WGPUBlendComponentSerialize(record.color, &transfer->color, buffer));\n    WIRE_TRY(WGPUBlendComponentSerialize(record.alpha, &transfer->alpha, buffer));\n\n    return WireResult::Success;\n}\nDAWN_UNUSED_FUNC(WGPUBlendStateSerialize);\n\nDAWN_DECLARE_UNUSED WireResult WGPUBlendStateDeserialize(\n    WGPUBlendState* record,\n    const volatile WGPUBlendStateTransfer* transfer,\n    DeserializeBuffer* deserializeBuffer,\n    DeserializeAllocator* allocator) {\n    DAWN_UNUSED(allocator);\n\n\n\n    static_assert(sizeof(record->color) == sizeof(transfer->color), \"Deserialize memcpy size must match.\");\n    memcpy(&record->color, const_cast<const WGPUBlendComponentTransfer*>(&transfer->color), sizeof(WGPUBlendComponentTransfer));\n    static_assert(sizeof(record->alpha) == sizeof(transfer->alpha), \"Deserialize memcpy size must match.\");\n    memcpy(&record->alpha, const_cast<const WGPUBlendComponentTransfer*>(&transfer->alpha), sizeof(WGPUBlendComponentTransfer));\n\n    return WireResult::Success;\n}\nDAWN_UNUSED_FUNC(WGPUBlendStateDeserialize);\n\nstruct WGPUCompilationInfoTransfer {\n    static_assert(0 <= 1,\n                  \"Record must be at most one of is_cmd, extensible, and chained.\");\n    bool hasNextInChain;\n\n    uint64_t messageCount;\n};\n\n\nDAWN_DECLARE_UNUSED size_t WGPUCompilationInfoGetExtraRequiredSize(const WGPUCompilationInfo& record) {\n    DAWN_UNUSED(record);\n    size_t result = 0;\n\n    if (record.nextInChain != nullptr) {\n        result += GetChainedStructExtraRequiredSize(record.nextInChain);\n    }\n    {\n        auto memberLength = record.messageCount;\n        auto size = WireAlignSizeofN<WGPUCompilationMessageTransfer>(memberLength);\n        ASSERT(size);\n        result += *size;\n        for (decltype(memberLength) i = 0; i < memberLength; ++i) {\n            result += WGPUCompilationMessageGetExtraRequiredSize(record.messages[i]);\n        }\n    }\n    return result;\n}\n// GetExtraRequiredSize isn't used for structures that are value members of other structures\n// because we assume they cannot contain pointers themselves.\nDAWN_UNUSED_FUNC(WGPUCompilationInfoGetExtraRequiredSize);\n\nDAWN_DECLARE_UNUSED WireResult WGPUCompilationInfoSerialize(\n    const WGPUCompilationInfo& record,\n    WGPUCompilationInfoTransfer* transfer,\n    SerializeBuffer* buffer, const ObjectIdProvider& provider) {\n    DAWN_UNUSED(buffer);\n\n    if (record.nextInChain != nullptr) {\n        transfer->hasNextInChain = true;\n        WIRE_TRY(SerializeChainedStruct(record.nextInChain, buffer, provider));\n    } else {\n        transfer->hasNextInChain = false;\n    }\n\n    transfer->messageCount = record.messageCount;\n    {\n        auto memberLength = record.messageCount;\n\n        WGPUCompilationMessageTransfer* memberBuffer;\n        WIRE_TRY(buffer->NextN(memberLength, &memberBuffer));\n\n        for (decltype(memberLength) i = 0; i < memberLength; ++i) {\n            WIRE_TRY(WGPUCompilationMessageSerialize(record.messages[i], &memberBuffer[i], buffer, provider));\n        }\n    }\n\n    return WireResult::Success;\n}\nDAWN_UNUSED_FUNC(WGPUCompilationInfoSerialize);\n\nDAWN_DECLARE_UNUSED WireResult WGPUCompilationInfoDeserialize(\n    WGPUCompilationInfo* record,\n    const volatile WGPUCompilationInfoTransfer* transfer,\n    DeserializeBuffer* deserializeBuffer,\n    DeserializeAllocator* allocator, const ObjectIdResolver& resolver) {\n    DAWN_UNUSED(allocator);\n\n\n    record->nextInChain = nullptr;\n    if (transfer->hasNextInChain) {\n        WIRE_TRY(DeserializeChainedStruct(&record->nextInChain, deserializeBuffer, allocator, resolver));\n    }\n\n    if (transfer->messageCount > std::numeric_limits<size_t>::max()) return WireResult::FatalError;\n    record->messageCount = checked_cast<size_t>(transfer->messageCount);\n    {\n        auto memberLength = record->messageCount;\n        const volatile WGPUCompilationMessageTransfer* memberBuffer;\n        WIRE_TRY(deserializeBuffer->ReadN(memberLength, &memberBuffer));\n\n        WGPUCompilationMessage* copiedMembers;\n        WIRE_TRY(GetSpace(allocator, memberLength, &copiedMembers));\n        record->messages = copiedMembers;\n\n        for (decltype(memberLength) i = 0; i < memberLength; ++i) {\n            WIRE_TRY(WGPUCompilationMessageDeserialize(&copiedMembers[i], &memberBuffer[i], deserializeBuffer, allocator, resolver));\n        }\n    }\n\n    return WireResult::Success;\n}\nDAWN_UNUSED_FUNC(WGPUCompilationInfoDeserialize);\n\nstruct WGPUComputePassDescriptorTransfer {\n    static_assert(0 <= 1,\n                  \"Record must be at most one of is_cmd, extensible, and chained.\");\n    bool hasNextInChain;\n\n    uint64_t labelStrlen;\n    bool has_label;\n    uint64_t timestampWriteCount;\n};\n\n\nDAWN_DECLARE_UNUSED size_t WGPUComputePassDescriptorGetExtraRequiredSize(const WGPUComputePassDescriptor& record) {\n    DAWN_UNUSED(record);\n    size_t result = 0;\n\n    if (record.nextInChain != nullptr) {\n        result += GetChainedStructExtraRequiredSize(record.nextInChain);\n    }\n    if (record.label != nullptr) {\n        result += Align(std::strlen(record.label), kWireBufferAlignment);\n    }\n    {\n        auto memberLength = record.timestampWriteCount;\n        auto size = WireAlignSizeofN<WGPUComputePassTimestampWriteTransfer>(memberLength);\n        ASSERT(size);\n        result += *size;\n        for (decltype(memberLength) i = 0; i < memberLength; ++i) {\n            result += WGPUComputePassTimestampWriteGetExtraRequiredSize(record.timestampWrites[i]);\n        }\n    }\n    return result;\n}\n// GetExtraRequiredSize isn't used for structures that are value members of other structures\n// because we assume they cannot contain pointers themselves.\nDAWN_UNUSED_FUNC(WGPUComputePassDescriptorGetExtraRequiredSize);\n\nDAWN_DECLARE_UNUSED WireResult WGPUComputePassDescriptorSerialize(\n    const WGPUComputePassDescriptor& record,\n    WGPUComputePassDescriptorTransfer* transfer,\n    SerializeBuffer* buffer, const ObjectIdProvider& provider) {\n    DAWN_UNUSED(buffer);\n\n    if (record.nextInChain != nullptr) {\n        transfer->hasNextInChain = true;\n        WIRE_TRY(SerializeChainedStruct(record.nextInChain, buffer, provider));\n    } else {\n        transfer->hasNextInChain = false;\n    }\n\n    transfer->timestampWriteCount = record.timestampWriteCount;\n    bool has_label = record.label != nullptr;\n    transfer->has_label = has_label;\n    if (has_label) {\n        transfer->labelStrlen = std::strlen(record.label);\n\n        char* stringInBuffer;\n        WIRE_TRY(buffer->NextN(transfer->labelStrlen, &stringInBuffer));\n        memcpy(stringInBuffer, record.label, transfer->labelStrlen);\n    }\n    {\n        auto memberLength = record.timestampWriteCount;\n\n        WGPUComputePassTimestampWriteTransfer* memberBuffer;\n        WIRE_TRY(buffer->NextN(memberLength, &memberBuffer));\n\n        for (decltype(memberLength) i = 0; i < memberLength; ++i) {\n            WIRE_TRY(WGPUComputePassTimestampWriteSerialize(record.timestampWrites[i], &memberBuffer[i], buffer, provider));\n        }\n    }\n\n    return WireResult::Success;\n}\nDAWN_UNUSED_FUNC(WGPUComputePassDescriptorSerialize);\n\nDAWN_DECLARE_UNUSED WireResult WGPUComputePassDescriptorDeserialize(\n    WGPUComputePassDescriptor* record,\n    const volatile WGPUComputePassDescriptorTransfer* transfer,\n    DeserializeBuffer* deserializeBuffer,\n    DeserializeAllocator* allocator, const ObjectIdResolver& resolver) {\n    DAWN_UNUSED(allocator);\n\n\n    record->nextInChain = nullptr;\n    if (transfer->hasNextInChain) {\n        WIRE_TRY(DeserializeChainedStruct(&record->nextInChain, deserializeBuffer, allocator, resolver));\n    }\n\n    if (transfer->timestampWriteCount > std::numeric_limits<size_t>::max()) return WireResult::FatalError;\n    record->timestampWriteCount = checked_cast<size_t>(transfer->timestampWriteCount);\n    bool has_label = transfer->has_label;\n    record->label = nullptr;\n    if (has_label) {\n        uint64_t stringLength64 = transfer->labelStrlen;\n        if (stringLength64 >= std::numeric_limits<size_t>::max()) {\n            return WireResult::FatalError;\n        }\n        size_t stringLength = static_cast<size_t>(stringLength64);\n\n        const volatile char* stringInBuffer;\n        WIRE_TRY(deserializeBuffer->ReadN(stringLength, &stringInBuffer));\n\n        char* copiedString;\n        WIRE_TRY(GetSpace(allocator, stringLength + 1, &copiedString));\n        memcpy(copiedString, const_cast<const char*>(stringInBuffer), stringLength);\n        copiedString[stringLength] = '\\0';\n        record->label = copiedString;\n    }\n    {\n        auto memberLength = record->timestampWriteCount;\n        const volatile WGPUComputePassTimestampWriteTransfer* memberBuffer;\n        WIRE_TRY(deserializeBuffer->ReadN(memberLength, &memberBuffer));\n\n        WGPUComputePassTimestampWrite* copiedMembers;\n        WIRE_TRY(GetSpace(allocator, memberLength, &copiedMembers));\n        record->timestampWrites = copiedMembers;\n\n        for (decltype(memberLength) i = 0; i < memberLength; ++i) {\n            WIRE_TRY(WGPUComputePassTimestampWriteDeserialize(&copiedMembers[i], &memberBuffer[i], deserializeBuffer, allocator, resolver));\n        }\n    }\n\n    return WireResult::Success;\n}\nDAWN_UNUSED_FUNC(WGPUComputePassDescriptorDeserialize);\n\nstruct WGPUDepthStencilStateTransfer {\n    static_assert(0 <= 1,\n                  \"Record must be at most one of is_cmd, extensible, and chained.\");\n    bool hasNextInChain;\n\n    WGPUTextureFormat format;\n    bool depthWriteEnabled;\n    WGPUCompareFunction depthCompare;\n    WGPUStencilFaceStateTransfer stencilFront;\n    WGPUStencilFaceStateTransfer stencilBack;\n    uint32_t stencilReadMask;\n    uint32_t stencilWriteMask;\n    int32_t depthBias;\n    float depthBiasSlopeScale;\n    float depthBiasClamp;\n};\n\n\nDAWN_DECLARE_UNUSED size_t WGPUDepthStencilStateGetExtraRequiredSize(const WGPUDepthStencilState& record) {\n    DAWN_UNUSED(record);\n    size_t result = 0;\n\n    if (record.nextInChain != nullptr) {\n        result += GetChainedStructExtraRequiredSize(record.nextInChain);\n    }\n    {\n        result += WGPUStencilFaceStateGetExtraRequiredSize(record.stencilFront);\n    }\n    {\n        result += WGPUStencilFaceStateGetExtraRequiredSize(record.stencilBack);\n    }\n    return result;\n}\n// GetExtraRequiredSize isn't used for structures that are value members of other structures\n// because we assume they cannot contain pointers themselves.\nDAWN_UNUSED_FUNC(WGPUDepthStencilStateGetExtraRequiredSize);\n\nDAWN_DECLARE_UNUSED WireResult WGPUDepthStencilStateSerialize(\n    const WGPUDepthStencilState& record,\n    WGPUDepthStencilStateTransfer* transfer,\n    SerializeBuffer* buffer, const ObjectIdProvider& provider) {\n    DAWN_UNUSED(buffer);\n\n    if (record.nextInChain != nullptr) {\n        transfer->hasNextInChain = true;\n        WIRE_TRY(SerializeChainedStruct(record.nextInChain, buffer, provider));\n    } else {\n        transfer->hasNextInChain = false;\n    }\n\n    transfer->format = record.format;\n    transfer->depthWriteEnabled = record.depthWriteEnabled;\n    transfer->depthCompare = record.depthCompare;\n    WIRE_TRY(WGPUStencilFaceStateSerialize(record.stencilFront, &transfer->stencilFront, buffer));\n    WIRE_TRY(WGPUStencilFaceStateSerialize(record.stencilBack, &transfer->stencilBack, buffer));\n    transfer->stencilReadMask = record.stencilReadMask;\n    transfer->stencilWriteMask = record.stencilWriteMask;\n    transfer->depthBias = record.depthBias;\n    transfer->depthBiasSlopeScale = record.depthBiasSlopeScale;\n    transfer->depthBiasClamp = record.depthBiasClamp;\n\n    return WireResult::Success;\n}\nDAWN_UNUSED_FUNC(WGPUDepthStencilStateSerialize);\n\nDAWN_DECLARE_UNUSED WireResult WGPUDepthStencilStateDeserialize(\n    WGPUDepthStencilState* record,\n    const volatile WGPUDepthStencilStateTransfer* transfer,\n    DeserializeBuffer* deserializeBuffer,\n    DeserializeAllocator* allocator, const ObjectIdResolver& resolver) {\n    DAWN_UNUSED(allocator);\n\n\n    record->nextInChain = nullptr;\n    if (transfer->hasNextInChain) {\n        WIRE_TRY(DeserializeChainedStruct(&record->nextInChain, deserializeBuffer, allocator, resolver));\n    }\n\n    static_assert(sizeof(record->format) >= sizeof(transfer->format), \"Deserialize assignment may not narrow.\");\n    record->format = transfer->format;\n    static_assert(sizeof(record->depthWriteEnabled) >= sizeof(transfer->depthWriteEnabled), \"Deserialize assignment may not narrow.\");\n    record->depthWriteEnabled = transfer->depthWriteEnabled;\n    static_assert(sizeof(record->depthCompare) >= sizeof(transfer->depthCompare), \"Deserialize assignment may not narrow.\");\n    record->depthCompare = transfer->depthCompare;\n    static_assert(sizeof(record->stencilFront) == sizeof(transfer->stencilFront), \"Deserialize memcpy size must match.\");\n    memcpy(&record->stencilFront, const_cast<const WGPUStencilFaceStateTransfer*>(&transfer->stencilFront), sizeof(WGPUStencilFaceStateTransfer));\n    static_assert(sizeof(record->stencilBack) == sizeof(transfer->stencilBack), \"Deserialize memcpy size must match.\");\n    memcpy(&record->stencilBack, const_cast<const WGPUStencilFaceStateTransfer*>(&transfer->stencilBack), sizeof(WGPUStencilFaceStateTransfer));\n    static_assert(sizeof(record->stencilReadMask) >= sizeof(transfer->stencilReadMask), \"Deserialize assignment may not narrow.\");\n    record->stencilReadMask = transfer->stencilReadMask;\n    static_assert(sizeof(record->stencilWriteMask) >= sizeof(transfer->stencilWriteMask), \"Deserialize assignment may not narrow.\");\n    record->stencilWriteMask = transfer->stencilWriteMask;\n    static_assert(sizeof(record->depthBias) >= sizeof(transfer->depthBias), \"Deserialize assignment may not narrow.\");\n    record->depthBias = transfer->depthBias;\n    static_assert(sizeof(record->depthBiasSlopeScale) >= sizeof(transfer->depthBiasSlopeScale), \"Deserialize assignment may not narrow.\");\n    record->depthBiasSlopeScale = transfer->depthBiasSlopeScale;\n    static_assert(sizeof(record->depthBiasClamp) >= sizeof(transfer->depthBiasClamp), \"Deserialize assignment may not narrow.\");\n    record->depthBiasClamp = transfer->depthBiasClamp;\n\n    return WireResult::Success;\n}\nDAWN_UNUSED_FUNC(WGPUDepthStencilStateDeserialize);\n\nstruct WGPUExternalTextureDescriptorTransfer {\n    static_assert(0 <= 1,\n                  \"Record must be at most one of is_cmd, extensible, and chained.\");\n    bool hasNextInChain;\n\n    uint64_t labelStrlen;\n    bool has_label;\n    ObjectId plane0;\n    ObjectId plane1;\n    WGPUOrigin2DTransfer visibleOrigin;\n    WGPUExtent2DTransfer visibleSize;\n    bool doYuvToRgbConversionOnly;\n    bool has_yuvToRgbConversionMatrix;\n    bool flipY;\n    WGPUExternalTextureRotation rotation;\n};\n\n\nDAWN_DECLARE_UNUSED size_t WGPUExternalTextureDescriptorGetExtraRequiredSize(const WGPUExternalTextureDescriptor& record) {\n    DAWN_UNUSED(record);\n    size_t result = 0;\n\n    if (record.nextInChain != nullptr) {\n        result += GetChainedStructExtraRequiredSize(record.nextInChain);\n    }\n    if (record.label != nullptr) {\n        result += Align(std::strlen(record.label), kWireBufferAlignment);\n    }\n    {\n        result += WGPUOrigin2DGetExtraRequiredSize(record.visibleOrigin);\n    }\n    {\n        result += WGPUExtent2DGetExtraRequiredSize(record.visibleSize);\n    }\n    if (record.yuvToRgbConversionMatrix != nullptr) {\n        auto memberLength = 12u;\n        auto size = WireAlignSizeofN<float>(memberLength);\n        ASSERT(size);\n        result += *size;\n    }\n    {\n        auto memberLength = 7u;\n        auto size = WireAlignSizeofN<float>(memberLength);\n        ASSERT(size);\n        result += *size;\n    }\n    {\n        auto memberLength = 7u;\n        auto size = WireAlignSizeofN<float>(memberLength);\n        ASSERT(size);\n        result += *size;\n    }\n    {\n        auto memberLength = 9u;\n        auto size = WireAlignSizeofN<float>(memberLength);\n        ASSERT(size);\n        result += *size;\n    }\n    return result;\n}\n// GetExtraRequiredSize isn't used for structures that are value members of other structures\n// because we assume they cannot contain pointers themselves.\nDAWN_UNUSED_FUNC(WGPUExternalTextureDescriptorGetExtraRequiredSize);\n\nDAWN_DECLARE_UNUSED WireResult WGPUExternalTextureDescriptorSerialize(\n    const WGPUExternalTextureDescriptor& record,\n    WGPUExternalTextureDescriptorTransfer* transfer,\n    SerializeBuffer* buffer, const ObjectIdProvider& provider) {\n    DAWN_UNUSED(buffer);\n\n    if (record.nextInChain != nullptr) {\n        transfer->hasNextInChain = true;\n        WIRE_TRY(SerializeChainedStruct(record.nextInChain, buffer, provider));\n    } else {\n        transfer->hasNextInChain = false;\n    }\n\n    WIRE_TRY(provider.GetId(record.plane0, &transfer->plane0));\n    WIRE_TRY(provider.GetOptionalId(record.plane1, &transfer->plane1));\n    WIRE_TRY(WGPUOrigin2DSerialize(record.visibleOrigin, &transfer->visibleOrigin, buffer));\n    WIRE_TRY(WGPUExtent2DSerialize(record.visibleSize, &transfer->visibleSize, buffer));\n    transfer->doYuvToRgbConversionOnly = record.doYuvToRgbConversionOnly;\n    transfer->flipY = record.flipY;\n    transfer->rotation = record.rotation;\n    bool has_label = record.label != nullptr;\n    transfer->has_label = has_label;\n    if (has_label) {\n        transfer->labelStrlen = std::strlen(record.label);\n\n        char* stringInBuffer;\n        WIRE_TRY(buffer->NextN(transfer->labelStrlen, &stringInBuffer));\n        memcpy(stringInBuffer, record.label, transfer->labelStrlen);\n    }\n    bool has_yuvToRgbConversionMatrix = record.yuvToRgbConversionMatrix != nullptr;\n    transfer->has_yuvToRgbConversionMatrix = has_yuvToRgbConversionMatrix;\n    if (has_yuvToRgbConversionMatrix) {\n        auto memberLength = 12u;\n\n        float* memberBuffer;\n        WIRE_TRY(buffer->NextN(memberLength, &memberBuffer));\n\n        memcpy(\n            memberBuffer, record.yuvToRgbConversionMatrix,\n            sizeof(float) * memberLength);\n    }\n    {\n        auto memberLength = 7u;\n\n        float* memberBuffer;\n        WIRE_TRY(buffer->NextN(memberLength, &memberBuffer));\n\n        memcpy(\n            memberBuffer, record.srcTransferFunctionParameters,\n            sizeof(float) * memberLength);\n    }\n    {\n        auto memberLength = 7u;\n\n        float* memberBuffer;\n        WIRE_TRY(buffer->NextN(memberLength, &memberBuffer));\n\n        memcpy(\n            memberBuffer, record.dstTransferFunctionParameters,\n            sizeof(float) * memberLength);\n    }\n    {\n        auto memberLength = 9u;\n\n        float* memberBuffer;\n        WIRE_TRY(buffer->NextN(memberLength, &memberBuffer));\n\n        memcpy(\n            memberBuffer, record.gamutConversionMatrix,\n            sizeof(float) * memberLength);\n    }\n\n    return WireResult::Success;\n}\nDAWN_UNUSED_FUNC(WGPUExternalTextureDescriptorSerialize);\n\nDAWN_DECLARE_UNUSED WireResult WGPUExternalTextureDescriptorDeserialize(\n    WGPUExternalTextureDescriptor* record,\n    const volatile WGPUExternalTextureDescriptorTransfer* transfer,\n    DeserializeBuffer* deserializeBuffer,\n    DeserializeAllocator* allocator, const ObjectIdResolver& resolver) {\n    DAWN_UNUSED(allocator);\n\n\n    record->nextInChain = nullptr;\n    if (transfer->hasNextInChain) {\n        WIRE_TRY(DeserializeChainedStruct(&record->nextInChain, deserializeBuffer, allocator, resolver));\n    }\n\n    WIRE_TRY(resolver.GetFromId(transfer->plane0, &record->plane0));\n    WIRE_TRY(resolver.GetOptionalFromId(transfer->plane1, &record->plane1));\n    static_assert(sizeof(record->visibleOrigin) == sizeof(transfer->visibleOrigin), \"Deserialize memcpy size must match.\");\n    memcpy(&record->visibleOrigin, const_cast<const WGPUOrigin2DTransfer*>(&transfer->visibleOrigin), sizeof(WGPUOrigin2DTransfer));\n    static_assert(sizeof(record->visibleSize) == sizeof(transfer->visibleSize), \"Deserialize memcpy size must match.\");\n    memcpy(&record->visibleSize, const_cast<const WGPUExtent2DTransfer*>(&transfer->visibleSize), sizeof(WGPUExtent2DTransfer));\n    static_assert(sizeof(record->doYuvToRgbConversionOnly) >= sizeof(transfer->doYuvToRgbConversionOnly), \"Deserialize assignment may not narrow.\");\n    record->doYuvToRgbConversionOnly = transfer->doYuvToRgbConversionOnly;\n    static_assert(sizeof(record->flipY) >= sizeof(transfer->flipY), \"Deserialize assignment may not narrow.\");\n    record->flipY = transfer->flipY;\n    static_assert(sizeof(record->rotation) >= sizeof(transfer->rotation), \"Deserialize assignment may not narrow.\");\n    record->rotation = transfer->rotation;\n    bool has_label = transfer->has_label;\n    record->label = nullptr;\n    if (has_label) {\n        uint64_t stringLength64 = transfer->labelStrlen;\n        if (stringLength64 >= std::numeric_limits<size_t>::max()) {\n            return WireResult::FatalError;\n        }\n        size_t stringLength = static_cast<size_t>(stringLength64);\n\n        const volatile char* stringInBuffer;\n        WIRE_TRY(deserializeBuffer->ReadN(stringLength, &stringInBuffer));\n\n        char* copiedString;\n        WIRE_TRY(GetSpace(allocator, stringLength + 1, &copiedString));\n        memcpy(copiedString, const_cast<const char*>(stringInBuffer), stringLength);\n        copiedString[stringLength] = '\\0';\n        record->label = copiedString;\n    }\n    bool has_yuvToRgbConversionMatrix = transfer->has_yuvToRgbConversionMatrix;\n    record->yuvToRgbConversionMatrix = nullptr;\n    if (has_yuvToRgbConversionMatrix) {\n        auto memberLength = 12u;\n        const volatile float* memberBuffer;\n        WIRE_TRY(deserializeBuffer->ReadN(memberLength, &memberBuffer));\n\n        float* copiedMembers;\n        WIRE_TRY(GetSpace(allocator, memberLength, &copiedMembers));\n        record->yuvToRgbConversionMatrix = copiedMembers;\n\n        memcpy(\n            copiedMembers,\n            const_cast<const float*>(memberBuffer),\n           sizeof(float) * memberLength);\n    }\n    {\n        auto memberLength = 7u;\n        const volatile float* memberBuffer;\n        WIRE_TRY(deserializeBuffer->ReadN(memberLength, &memberBuffer));\n\n        float* copiedMembers;\n        WIRE_TRY(GetSpace(allocator, memberLength, &copiedMembers));\n        record->srcTransferFunctionParameters = copiedMembers;\n\n        memcpy(\n            copiedMembers,\n            const_cast<const float*>(memberBuffer),\n           sizeof(float) * memberLength);\n    }\n    {\n        auto memberLength = 7u;\n        const volatile float* memberBuffer;\n        WIRE_TRY(deserializeBuffer->ReadN(memberLength, &memberBuffer));\n\n        float* copiedMembers;\n        WIRE_TRY(GetSpace(allocator, memberLength, &copiedMembers));\n        record->dstTransferFunctionParameters = copiedMembers;\n\n        memcpy(\n            copiedMembers,\n            const_cast<const float*>(memberBuffer),\n           sizeof(float) * memberLength);\n    }\n    {\n        auto memberLength = 9u;\n        const volatile float* memberBuffer;\n        WIRE_TRY(deserializeBuffer->ReadN(memberLength, &memberBuffer));\n\n        float* copiedMembers;\n        WIRE_TRY(GetSpace(allocator, memberLength, &copiedMembers));\n        record->gamutConversionMatrix = copiedMembers;\n\n        memcpy(\n            copiedMembers,\n            const_cast<const float*>(memberBuffer),\n           sizeof(float) * memberLength);\n    }\n\n    return WireResult::Success;\n}\nDAWN_UNUSED_FUNC(WGPUExternalTextureDescriptorDeserialize);\n\nstruct WGPUImageCopyBufferTransfer {\n    static_assert(0 <= 1,\n                  \"Record must be at most one of is_cmd, extensible, and chained.\");\n    bool hasNextInChain;\n\n    WGPUTextureDataLayoutTransfer layout;\n    ObjectId buffer;\n};\n\n\nDAWN_DECLARE_UNUSED size_t WGPUImageCopyBufferGetExtraRequiredSize(const WGPUImageCopyBuffer& record) {\n    DAWN_UNUSED(record);\n    size_t result = 0;\n\n    if (record.nextInChain != nullptr) {\n        result += GetChainedStructExtraRequiredSize(record.nextInChain);\n    }\n    {\n        result += WGPUTextureDataLayoutGetExtraRequiredSize(record.layout);\n    }\n    return result;\n}\n// GetExtraRequiredSize isn't used for structures that are value members of other structures\n// because we assume they cannot contain pointers themselves.\nDAWN_UNUSED_FUNC(WGPUImageCopyBufferGetExtraRequiredSize);\n\nDAWN_DECLARE_UNUSED WireResult WGPUImageCopyBufferSerialize(\n    const WGPUImageCopyBuffer& record,\n    WGPUImageCopyBufferTransfer* transfer,\n    SerializeBuffer* buffer, const ObjectIdProvider& provider) {\n    DAWN_UNUSED(buffer);\n\n    if (record.nextInChain != nullptr) {\n        transfer->hasNextInChain = true;\n        WIRE_TRY(SerializeChainedStruct(record.nextInChain, buffer, provider));\n    } else {\n        transfer->hasNextInChain = false;\n    }\n\n    WIRE_TRY(WGPUTextureDataLayoutSerialize(record.layout, &transfer->layout, buffer, provider));\n    WIRE_TRY(provider.GetId(record.buffer, &transfer->buffer));\n\n    return WireResult::Success;\n}\nDAWN_UNUSED_FUNC(WGPUImageCopyBufferSerialize);\n\nDAWN_DECLARE_UNUSED WireResult WGPUImageCopyBufferDeserialize(\n    WGPUImageCopyBuffer* record,\n    const volatile WGPUImageCopyBufferTransfer* transfer,\n    DeserializeBuffer* deserializeBuffer,\n    DeserializeAllocator* allocator, const ObjectIdResolver& resolver) {\n    DAWN_UNUSED(allocator);\n\n\n    record->nextInChain = nullptr;\n    if (transfer->hasNextInChain) {\n        WIRE_TRY(DeserializeChainedStruct(&record->nextInChain, deserializeBuffer, allocator, resolver));\n    }\n\n    WIRE_TRY(WGPUTextureDataLayoutDeserialize(&record->layout, &transfer->layout, deserializeBuffer, allocator, resolver));\n    WIRE_TRY(resolver.GetFromId(transfer->buffer, &record->buffer));\n\n    return WireResult::Success;\n}\nDAWN_UNUSED_FUNC(WGPUImageCopyBufferDeserialize);\n\nstruct WGPUImageCopyExternalTextureTransfer {\n    static_assert(0 <= 1,\n                  \"Record must be at most one of is_cmd, extensible, and chained.\");\n    bool hasNextInChain;\n\n    ObjectId externalTexture;\n    WGPUOrigin3DTransfer origin;\n    WGPUExtent2DTransfer naturalSize;\n};\n\n\nDAWN_DECLARE_UNUSED size_t WGPUImageCopyExternalTextureGetExtraRequiredSize(const WGPUImageCopyExternalTexture& record) {\n    DAWN_UNUSED(record);\n    size_t result = 0;\n\n    if (record.nextInChain != nullptr) {\n        result += GetChainedStructExtraRequiredSize(record.nextInChain);\n    }\n    {\n        result += WGPUOrigin3DGetExtraRequiredSize(record.origin);\n    }\n    {\n        result += WGPUExtent2DGetExtraRequiredSize(record.naturalSize);\n    }\n    return result;\n}\n// GetExtraRequiredSize isn't used for structures that are value members of other structures\n// because we assume they cannot contain pointers themselves.\nDAWN_UNUSED_FUNC(WGPUImageCopyExternalTextureGetExtraRequiredSize);\n\nDAWN_DECLARE_UNUSED WireResult WGPUImageCopyExternalTextureSerialize(\n    const WGPUImageCopyExternalTexture& record,\n    WGPUImageCopyExternalTextureTransfer* transfer,\n    SerializeBuffer* buffer, const ObjectIdProvider& provider) {\n    DAWN_UNUSED(buffer);\n\n    if (record.nextInChain != nullptr) {\n        transfer->hasNextInChain = true;\n        WIRE_TRY(SerializeChainedStruct(record.nextInChain, buffer, provider));\n    } else {\n        transfer->hasNextInChain = false;\n    }\n\n    WIRE_TRY(provider.GetId(record.externalTexture, &transfer->externalTexture));\n    WIRE_TRY(WGPUOrigin3DSerialize(record.origin, &transfer->origin, buffer));\n    WIRE_TRY(WGPUExtent2DSerialize(record.naturalSize, &transfer->naturalSize, buffer));\n\n    return WireResult::Success;\n}\nDAWN_UNUSED_FUNC(WGPUImageCopyExternalTextureSerialize);\n\nDAWN_DECLARE_UNUSED WireResult WGPUImageCopyExternalTextureDeserialize(\n    WGPUImageCopyExternalTexture* record,\n    const volatile WGPUImageCopyExternalTextureTransfer* transfer,\n    DeserializeBuffer* deserializeBuffer,\n    DeserializeAllocator* allocator, const ObjectIdResolver& resolver) {\n    DAWN_UNUSED(allocator);\n\n\n    record->nextInChain = nullptr;\n    if (transfer->hasNextInChain) {\n        WIRE_TRY(DeserializeChainedStruct(&record->nextInChain, deserializeBuffer, allocator, resolver));\n    }\n\n    WIRE_TRY(resolver.GetFromId(transfer->externalTexture, &record->externalTexture));\n    static_assert(sizeof(record->origin) == sizeof(transfer->origin), \"Deserialize memcpy size must match.\");\n    memcpy(&record->origin, const_cast<const WGPUOrigin3DTransfer*>(&transfer->origin), sizeof(WGPUOrigin3DTransfer));\n    static_assert(sizeof(record->naturalSize) == sizeof(transfer->naturalSize), \"Deserialize memcpy size must match.\");\n    memcpy(&record->naturalSize, const_cast<const WGPUExtent2DTransfer*>(&transfer->naturalSize), sizeof(WGPUExtent2DTransfer));\n\n    return WireResult::Success;\n}\nDAWN_UNUSED_FUNC(WGPUImageCopyExternalTextureDeserialize);\n\nstruct WGPUImageCopyTextureTransfer {\n    static_assert(0 <= 1,\n                  \"Record must be at most one of is_cmd, extensible, and chained.\");\n    bool hasNextInChain;\n\n    ObjectId texture;\n    uint32_t mipLevel;\n    WGPUOrigin3DTransfer origin;\n    WGPUTextureAspect aspect;\n};\n\n\nDAWN_DECLARE_UNUSED size_t WGPUImageCopyTextureGetExtraRequiredSize(const WGPUImageCopyTexture& record) {\n    DAWN_UNUSED(record);\n    size_t result = 0;\n\n    if (record.nextInChain != nullptr) {\n        result += GetChainedStructExtraRequiredSize(record.nextInChain);\n    }\n    {\n        result += WGPUOrigin3DGetExtraRequiredSize(record.origin);\n    }\n    return result;\n}\n// GetExtraRequiredSize isn't used for structures that are value members of other structures\n// because we assume they cannot contain pointers themselves.\nDAWN_UNUSED_FUNC(WGPUImageCopyTextureGetExtraRequiredSize);\n\nDAWN_DECLARE_UNUSED WireResult WGPUImageCopyTextureSerialize(\n    const WGPUImageCopyTexture& record,\n    WGPUImageCopyTextureTransfer* transfer,\n    SerializeBuffer* buffer, const ObjectIdProvider& provider) {\n    DAWN_UNUSED(buffer);\n\n    if (record.nextInChain != nullptr) {\n        transfer->hasNextInChain = true;\n        WIRE_TRY(SerializeChainedStruct(record.nextInChain, buffer, provider));\n    } else {\n        transfer->hasNextInChain = false;\n    }\n\n    WIRE_TRY(provider.GetId(record.texture, &transfer->texture));\n    transfer->mipLevel = record.mipLevel;\n    WIRE_TRY(WGPUOrigin3DSerialize(record.origin, &transfer->origin, buffer));\n    transfer->aspect = record.aspect;\n\n    return WireResult::Success;\n}\nDAWN_UNUSED_FUNC(WGPUImageCopyTextureSerialize);\n\nDAWN_DECLARE_UNUSED WireResult WGPUImageCopyTextureDeserialize(\n    WGPUImageCopyTexture* record,\n    const volatile WGPUImageCopyTextureTransfer* transfer,\n    DeserializeBuffer* deserializeBuffer,\n    DeserializeAllocator* allocator, const ObjectIdResolver& resolver) {\n    DAWN_UNUSED(allocator);\n\n\n    record->nextInChain = nullptr;\n    if (transfer->hasNextInChain) {\n        WIRE_TRY(DeserializeChainedStruct(&record->nextInChain, deserializeBuffer, allocator, resolver));\n    }\n\n    WIRE_TRY(resolver.GetFromId(transfer->texture, &record->texture));\n    static_assert(sizeof(record->mipLevel) >= sizeof(transfer->mipLevel), \"Deserialize assignment may not narrow.\");\n    record->mipLevel = transfer->mipLevel;\n    static_assert(sizeof(record->origin) == sizeof(transfer->origin), \"Deserialize memcpy size must match.\");\n    memcpy(&record->origin, const_cast<const WGPUOrigin3DTransfer*>(&transfer->origin), sizeof(WGPUOrigin3DTransfer));\n    static_assert(sizeof(record->aspect) >= sizeof(transfer->aspect), \"Deserialize assignment may not narrow.\");\n    record->aspect = transfer->aspect;\n\n    return WireResult::Success;\n}\nDAWN_UNUSED_FUNC(WGPUImageCopyTextureDeserialize);\n\nstruct WGPUProgrammableStageDescriptorTransfer {\n    static_assert(0 <= 1,\n                  \"Record must be at most one of is_cmd, extensible, and chained.\");\n    bool hasNextInChain;\n\n    ObjectId module;\n    uint64_t entryPointStrlen;\n    uint64_t constantCount;\n};\n\n\nDAWN_DECLARE_UNUSED size_t WGPUProgrammableStageDescriptorGetExtraRequiredSize(const WGPUProgrammableStageDescriptor& record) {\n    DAWN_UNUSED(record);\n    size_t result = 0;\n\n    if (record.nextInChain != nullptr) {\n        result += GetChainedStructExtraRequiredSize(record.nextInChain);\n    }\n    ASSERT(record.entryPoint != nullptr);\n    result += Align(std::strlen(record.entryPoint), kWireBufferAlignment);\n    {\n        auto memberLength = record.constantCount;\n        auto size = WireAlignSizeofN<WGPUConstantEntryTransfer>(memberLength);\n        ASSERT(size);\n        result += *size;\n        for (decltype(memberLength) i = 0; i < memberLength; ++i) {\n            result += WGPUConstantEntryGetExtraRequiredSize(record.constants[i]);\n        }\n    }\n    return result;\n}\n// GetExtraRequiredSize isn't used for structures that are value members of other structures\n// because we assume they cannot contain pointers themselves.\nDAWN_UNUSED_FUNC(WGPUProgrammableStageDescriptorGetExtraRequiredSize);\n\nDAWN_DECLARE_UNUSED WireResult WGPUProgrammableStageDescriptorSerialize(\n    const WGPUProgrammableStageDescriptor& record,\n    WGPUProgrammableStageDescriptorTransfer* transfer,\n    SerializeBuffer* buffer, const ObjectIdProvider& provider) {\n    DAWN_UNUSED(buffer);\n\n    if (record.nextInChain != nullptr) {\n        transfer->hasNextInChain = true;\n        WIRE_TRY(SerializeChainedStruct(record.nextInChain, buffer, provider));\n    } else {\n        transfer->hasNextInChain = false;\n    }\n\n    WIRE_TRY(provider.GetId(record.module, &transfer->module));\n    transfer->constantCount = record.constantCount;\n    {\n        transfer->entryPointStrlen = std::strlen(record.entryPoint);\n\n        char* stringInBuffer;\n        WIRE_TRY(buffer->NextN(transfer->entryPointStrlen, &stringInBuffer));\n        memcpy(stringInBuffer, record.entryPoint, transfer->entryPointStrlen);\n    }\n    {\n        auto memberLength = record.constantCount;\n\n        WGPUConstantEntryTransfer* memberBuffer;\n        WIRE_TRY(buffer->NextN(memberLength, &memberBuffer));\n\n        for (decltype(memberLength) i = 0; i < memberLength; ++i) {\n            WIRE_TRY(WGPUConstantEntrySerialize(record.constants[i], &memberBuffer[i], buffer, provider));\n        }\n    }\n\n    return WireResult::Success;\n}\nDAWN_UNUSED_FUNC(WGPUProgrammableStageDescriptorSerialize);\n\nDAWN_DECLARE_UNUSED WireResult WGPUProgrammableStageDescriptorDeserialize(\n    WGPUProgrammableStageDescriptor* record,\n    const volatile WGPUProgrammableStageDescriptorTransfer* transfer,\n    DeserializeBuffer* deserializeBuffer,\n    DeserializeAllocator* allocator, const ObjectIdResolver& resolver) {\n    DAWN_UNUSED(allocator);\n\n\n    record->nextInChain = nullptr;\n    if (transfer->hasNextInChain) {\n        WIRE_TRY(DeserializeChainedStruct(&record->nextInChain, deserializeBuffer, allocator, resolver));\n    }\n\n    WIRE_TRY(resolver.GetFromId(transfer->module, &record->module));\n    if (transfer->constantCount > std::numeric_limits<size_t>::max()) return WireResult::FatalError;\n    record->constantCount = checked_cast<size_t>(transfer->constantCount);\n    {\n        uint64_t stringLength64 = transfer->entryPointStrlen;\n        if (stringLength64 >= std::numeric_limits<size_t>::max()) {\n            return WireResult::FatalError;\n        }\n        size_t stringLength = static_cast<size_t>(stringLength64);\n\n        const volatile char* stringInBuffer;\n        WIRE_TRY(deserializeBuffer->ReadN(stringLength, &stringInBuffer));\n\n        char* copiedString;\n        WIRE_TRY(GetSpace(allocator, stringLength + 1, &copiedString));\n        memcpy(copiedString, const_cast<const char*>(stringInBuffer), stringLength);\n        copiedString[stringLength] = '\\0';\n        record->entryPoint = copiedString;\n    }\n    {\n        auto memberLength = record->constantCount;\n        const volatile WGPUConstantEntryTransfer* memberBuffer;\n        WIRE_TRY(deserializeBuffer->ReadN(memberLength, &memberBuffer));\n\n        WGPUConstantEntry* copiedMembers;\n        WIRE_TRY(GetSpace(allocator, memberLength, &copiedMembers));\n        record->constants = copiedMembers;\n\n        for (decltype(memberLength) i = 0; i < memberLength; ++i) {\n            WIRE_TRY(WGPUConstantEntryDeserialize(&copiedMembers[i], &memberBuffer[i], deserializeBuffer, allocator, resolver));\n        }\n    }\n\n    return WireResult::Success;\n}\nDAWN_UNUSED_FUNC(WGPUProgrammableStageDescriptorDeserialize);\n\nstruct WGPURenderPassColorAttachmentTransfer {\n    static_assert(0 <= 1,\n                  \"Record must be at most one of is_cmd, extensible, and chained.\");\n    bool hasNextInChain;\n\n    ObjectId view;\n    ObjectId resolveTarget;\n    WGPULoadOp loadOp;\n    WGPUStoreOp storeOp;\n    WGPUColorTransfer clearValue;\n};\n\n\nDAWN_DECLARE_UNUSED size_t WGPURenderPassColorAttachmentGetExtraRequiredSize(const WGPURenderPassColorAttachment& record) {\n    DAWN_UNUSED(record);\n    size_t result = 0;\n\n    if (record.nextInChain != nullptr) {\n        result += GetChainedStructExtraRequiredSize(record.nextInChain);\n    }\n    {\n        result += WGPUColorGetExtraRequiredSize(record.clearValue);\n    }\n    return result;\n}\n// GetExtraRequiredSize isn't used for structures that are value members of other structures\n// because we assume they cannot contain pointers themselves.\nDAWN_UNUSED_FUNC(WGPURenderPassColorAttachmentGetExtraRequiredSize);\n\nDAWN_DECLARE_UNUSED WireResult WGPURenderPassColorAttachmentSerialize(\n    const WGPURenderPassColorAttachment& record,\n    WGPURenderPassColorAttachmentTransfer* transfer,\n    SerializeBuffer* buffer, const ObjectIdProvider& provider) {\n    DAWN_UNUSED(buffer);\n\n    if (record.nextInChain != nullptr) {\n        transfer->hasNextInChain = true;\n        WIRE_TRY(SerializeChainedStruct(record.nextInChain, buffer, provider));\n    } else {\n        transfer->hasNextInChain = false;\n    }\n\n    WIRE_TRY(provider.GetOptionalId(record.view, &transfer->view));\n    WIRE_TRY(provider.GetOptionalId(record.resolveTarget, &transfer->resolveTarget));\n    transfer->loadOp = record.loadOp;\n    transfer->storeOp = record.storeOp;\n    WIRE_TRY(WGPUColorSerialize(record.clearValue, &transfer->clearValue, buffer));\n\n    return WireResult::Success;\n}\nDAWN_UNUSED_FUNC(WGPURenderPassColorAttachmentSerialize);\n\nDAWN_DECLARE_UNUSED WireResult WGPURenderPassColorAttachmentDeserialize(\n    WGPURenderPassColorAttachment* record,\n    const volatile WGPURenderPassColorAttachmentTransfer* transfer,\n    DeserializeBuffer* deserializeBuffer,\n    DeserializeAllocator* allocator, const ObjectIdResolver& resolver) {\n    DAWN_UNUSED(allocator);\n\n\n    record->nextInChain = nullptr;\n    if (transfer->hasNextInChain) {\n        WIRE_TRY(DeserializeChainedStruct(&record->nextInChain, deserializeBuffer, allocator, resolver));\n    }\n\n    WIRE_TRY(resolver.GetOptionalFromId(transfer->view, &record->view));\n    WIRE_TRY(resolver.GetOptionalFromId(transfer->resolveTarget, &record->resolveTarget));\n    static_assert(sizeof(record->loadOp) >= sizeof(transfer->loadOp), \"Deserialize assignment may not narrow.\");\n    record->loadOp = transfer->loadOp;\n    static_assert(sizeof(record->storeOp) >= sizeof(transfer->storeOp), \"Deserialize assignment may not narrow.\");\n    record->storeOp = transfer->storeOp;\n    static_assert(sizeof(record->clearValue) == sizeof(transfer->clearValue), \"Deserialize memcpy size must match.\");\n    memcpy(&record->clearValue, const_cast<const WGPUColorTransfer*>(&transfer->clearValue), sizeof(WGPUColorTransfer));\n\n    return WireResult::Success;\n}\nDAWN_UNUSED_FUNC(WGPURenderPassColorAttachmentDeserialize);\n\nstruct WGPURequiredLimitsTransfer {\n    static_assert(0 <= 1,\n                  \"Record must be at most one of is_cmd, extensible, and chained.\");\n    bool hasNextInChain;\n\n    WGPULimitsTransfer limits;\n};\n\n\nDAWN_DECLARE_UNUSED size_t WGPURequiredLimitsGetExtraRequiredSize(const WGPURequiredLimits& record) {\n    DAWN_UNUSED(record);\n    size_t result = 0;\n\n    if (record.nextInChain != nullptr) {\n        result += GetChainedStructExtraRequiredSize(record.nextInChain);\n    }\n    {\n        result += WGPULimitsGetExtraRequiredSize(record.limits);\n    }\n    return result;\n}\n// GetExtraRequiredSize isn't used for structures that are value members of other structures\n// because we assume they cannot contain pointers themselves.\nDAWN_UNUSED_FUNC(WGPURequiredLimitsGetExtraRequiredSize);\n\nDAWN_DECLARE_UNUSED WireResult WGPURequiredLimitsSerialize(\n    const WGPURequiredLimits& record,\n    WGPURequiredLimitsTransfer* transfer,\n    SerializeBuffer* buffer, const ObjectIdProvider& provider) {\n    DAWN_UNUSED(buffer);\n\n    if (record.nextInChain != nullptr) {\n        transfer->hasNextInChain = true;\n        WIRE_TRY(SerializeChainedStruct(record.nextInChain, buffer, provider));\n    } else {\n        transfer->hasNextInChain = false;\n    }\n\n    WIRE_TRY(WGPULimitsSerialize(record.limits, &transfer->limits, buffer));\n\n    return WireResult::Success;\n}\nDAWN_UNUSED_FUNC(WGPURequiredLimitsSerialize);\n\nDAWN_DECLARE_UNUSED WireResult WGPURequiredLimitsDeserialize(\n    WGPURequiredLimits* record,\n    const volatile WGPURequiredLimitsTransfer* transfer,\n    DeserializeBuffer* deserializeBuffer,\n    DeserializeAllocator* allocator, const ObjectIdResolver& resolver) {\n    DAWN_UNUSED(allocator);\n\n\n    record->nextInChain = nullptr;\n    if (transfer->hasNextInChain) {\n        WIRE_TRY(DeserializeChainedStruct(&record->nextInChain, deserializeBuffer, allocator, resolver));\n    }\n\n    static_assert(sizeof(record->limits) == sizeof(transfer->limits), \"Deserialize memcpy size must match.\");\n    memcpy(&record->limits, const_cast<const WGPULimitsTransfer*>(&transfer->limits), sizeof(WGPULimitsTransfer));\n\n    return WireResult::Success;\n}\nDAWN_UNUSED_FUNC(WGPURequiredLimitsDeserialize);\n\nstruct WGPUSupportedLimitsTransfer {\n    static_assert(0 <= 1,\n                  \"Record must be at most one of is_cmd, extensible, and chained.\");\n    bool hasNextInChain;\n\n    WGPULimitsTransfer limits;\n};\n\n\nDAWN_DECLARE_UNUSED size_t WGPUSupportedLimitsGetExtraRequiredSize(const WGPUSupportedLimits& record) {\n    DAWN_UNUSED(record);\n    size_t result = 0;\n\n    if (record.nextInChain != nullptr) {\n        result += GetChainedStructExtraRequiredSize(record.nextInChain);\n    }\n    {\n        result += WGPULimitsGetExtraRequiredSize(record.limits);\n    }\n    return result;\n}\n// GetExtraRequiredSize isn't used for structures that are value members of other structures\n// because we assume they cannot contain pointers themselves.\nDAWN_UNUSED_FUNC(WGPUSupportedLimitsGetExtraRequiredSize);\n\nDAWN_DECLARE_UNUSED WireResult WGPUSupportedLimitsSerialize(\n    const WGPUSupportedLimits& record,\n    WGPUSupportedLimitsTransfer* transfer,\n    SerializeBuffer* buffer, const ObjectIdProvider& provider) {\n    DAWN_UNUSED(buffer);\n\n    if (record.nextInChain != nullptr) {\n        transfer->hasNextInChain = true;\n        WIRE_TRY(SerializeChainedStruct(record.nextInChain, buffer, provider));\n    } else {\n        transfer->hasNextInChain = false;\n    }\n\n    WIRE_TRY(WGPULimitsSerialize(record.limits, &transfer->limits, buffer));\n\n    return WireResult::Success;\n}\nDAWN_UNUSED_FUNC(WGPUSupportedLimitsSerialize);\n\nDAWN_DECLARE_UNUSED WireResult WGPUSupportedLimitsDeserialize(\n    WGPUSupportedLimits* record,\n    const volatile WGPUSupportedLimitsTransfer* transfer,\n    DeserializeBuffer* deserializeBuffer,\n    DeserializeAllocator* allocator, const ObjectIdResolver& resolver) {\n    DAWN_UNUSED(allocator);\n\n\n    record->nextInChain = nullptr;\n    if (transfer->hasNextInChain) {\n        WIRE_TRY(DeserializeChainedStruct(&record->nextInChain, deserializeBuffer, allocator, resolver));\n    }\n\n    static_assert(sizeof(record->limits) == sizeof(transfer->limits), \"Deserialize memcpy size must match.\");\n    memcpy(&record->limits, const_cast<const WGPULimitsTransfer*>(&transfer->limits), sizeof(WGPULimitsTransfer));\n\n    return WireResult::Success;\n}\nDAWN_UNUSED_FUNC(WGPUSupportedLimitsDeserialize);\n\nstruct WGPUTextureDescriptorTransfer {\n    static_assert(0 <= 1,\n                  \"Record must be at most one of is_cmd, extensible, and chained.\");\n    bool hasNextInChain;\n\n    uint64_t labelStrlen;\n    bool has_label;\n    WGPUTextureUsageFlags usage;\n    WGPUTextureDimension dimension;\n    WGPUExtent3DTransfer size;\n    WGPUTextureFormat format;\n    uint32_t mipLevelCount;\n    uint32_t sampleCount;\n    uint64_t viewFormatCount;\n};\n\n\nDAWN_DECLARE_UNUSED size_t WGPUTextureDescriptorGetExtraRequiredSize(const WGPUTextureDescriptor& record) {\n    DAWN_UNUSED(record);\n    size_t result = 0;\n\n    if (record.nextInChain != nullptr) {\n        result += GetChainedStructExtraRequiredSize(record.nextInChain);\n    }\n    if (record.label != nullptr) {\n        result += Align(std::strlen(record.label), kWireBufferAlignment);\n    }\n    {\n        result += WGPUExtent3DGetExtraRequiredSize(record.size);\n    }\n    {\n        auto memberLength = record.viewFormatCount;\n        auto size = WireAlignSizeofN<WGPUTextureFormat>(memberLength);\n        ASSERT(size);\n        result += *size;\n    }\n    return result;\n}\n// GetExtraRequiredSize isn't used for structures that are value members of other structures\n// because we assume they cannot contain pointers themselves.\nDAWN_UNUSED_FUNC(WGPUTextureDescriptorGetExtraRequiredSize);\n\nDAWN_DECLARE_UNUSED WireResult WGPUTextureDescriptorSerialize(\n    const WGPUTextureDescriptor& record,\n    WGPUTextureDescriptorTransfer* transfer,\n    SerializeBuffer* buffer, const ObjectIdProvider& provider) {\n    DAWN_UNUSED(buffer);\n\n    if (record.nextInChain != nullptr) {\n        transfer->hasNextInChain = true;\n        WIRE_TRY(SerializeChainedStruct(record.nextInChain, buffer, provider));\n    } else {\n        transfer->hasNextInChain = false;\n    }\n\n    transfer->usage = record.usage;\n    transfer->dimension = record.dimension;\n    WIRE_TRY(WGPUExtent3DSerialize(record.size, &transfer->size, buffer));\n    transfer->format = record.format;\n    transfer->mipLevelCount = record.mipLevelCount;\n    transfer->sampleCount = record.sampleCount;\n    transfer->viewFormatCount = record.viewFormatCount;\n    bool has_label = record.label != nullptr;\n    transfer->has_label = has_label;\n    if (has_label) {\n        transfer->labelStrlen = std::strlen(record.label);\n\n        char* stringInBuffer;\n        WIRE_TRY(buffer->NextN(transfer->labelStrlen, &stringInBuffer));\n        memcpy(stringInBuffer, record.label, transfer->labelStrlen);\n    }\n    {\n        auto memberLength = record.viewFormatCount;\n\n        WGPUTextureFormat* memberBuffer;\n        WIRE_TRY(buffer->NextN(memberLength, &memberBuffer));\n\n        memcpy(\n            memberBuffer, record.viewFormats,\n            sizeof(WGPUTextureFormat) * memberLength);\n    }\n\n    return WireResult::Success;\n}\nDAWN_UNUSED_FUNC(WGPUTextureDescriptorSerialize);\n\nDAWN_DECLARE_UNUSED WireResult WGPUTextureDescriptorDeserialize(\n    WGPUTextureDescriptor* record,\n    const volatile WGPUTextureDescriptorTransfer* transfer,\n    DeserializeBuffer* deserializeBuffer,\n    DeserializeAllocator* allocator, const ObjectIdResolver& resolver) {\n    DAWN_UNUSED(allocator);\n\n\n    record->nextInChain = nullptr;\n    if (transfer->hasNextInChain) {\n        WIRE_TRY(DeserializeChainedStruct(&record->nextInChain, deserializeBuffer, allocator, resolver));\n    }\n\n    static_assert(sizeof(record->usage) >= sizeof(transfer->usage), \"Deserialize assignment may not narrow.\");\n    record->usage = transfer->usage;\n    static_assert(sizeof(record->dimension) >= sizeof(transfer->dimension), \"Deserialize assignment may not narrow.\");\n    record->dimension = transfer->dimension;\n    static_assert(sizeof(record->size) == sizeof(transfer->size), \"Deserialize memcpy size must match.\");\n    memcpy(&record->size, const_cast<const WGPUExtent3DTransfer*>(&transfer->size), sizeof(WGPUExtent3DTransfer));\n    static_assert(sizeof(record->format) >= sizeof(transfer->format), \"Deserialize assignment may not narrow.\");\n    record->format = transfer->format;\n    static_assert(sizeof(record->mipLevelCount) >= sizeof(transfer->mipLevelCount), \"Deserialize assignment may not narrow.\");\n    record->mipLevelCount = transfer->mipLevelCount;\n    static_assert(sizeof(record->sampleCount) >= sizeof(transfer->sampleCount), \"Deserialize assignment may not narrow.\");\n    record->sampleCount = transfer->sampleCount;\n    if (transfer->viewFormatCount > std::numeric_limits<size_t>::max()) return WireResult::FatalError;\n    record->viewFormatCount = checked_cast<size_t>(transfer->viewFormatCount);\n    bool has_label = transfer->has_label;\n    record->label = nullptr;\n    if (has_label) {\n        uint64_t stringLength64 = transfer->labelStrlen;\n        if (stringLength64 >= std::numeric_limits<size_t>::max()) {\n            return WireResult::FatalError;\n        }\n        size_t stringLength = static_cast<size_t>(stringLength64);\n\n        const volatile char* stringInBuffer;\n        WIRE_TRY(deserializeBuffer->ReadN(stringLength, &stringInBuffer));\n\n        char* copiedString;\n        WIRE_TRY(GetSpace(allocator, stringLength + 1, &copiedString));\n        memcpy(copiedString, const_cast<const char*>(stringInBuffer), stringLength);\n        copiedString[stringLength] = '\\0';\n        record->label = copiedString;\n    }\n    {\n        auto memberLength = record->viewFormatCount;\n        const volatile WGPUTextureFormat* memberBuffer;\n        WIRE_TRY(deserializeBuffer->ReadN(memberLength, &memberBuffer));\n\n        WGPUTextureFormat* copiedMembers;\n        WIRE_TRY(GetSpace(allocator, memberLength, &copiedMembers));\n        record->viewFormats = copiedMembers;\n\n        memcpy(\n            copiedMembers,\n            const_cast<const WGPUTextureFormat*>(memberBuffer),\n           sizeof(WGPUTextureFormat) * memberLength);\n    }\n\n    return WireResult::Success;\n}\nDAWN_UNUSED_FUNC(WGPUTextureDescriptorDeserialize);\n\nstruct WGPUVertexBufferLayoutTransfer {\n    static_assert(0 <= 1,\n                  \"Record must be at most one of is_cmd, extensible, and chained.\");\n\n    uint64_t arrayStride;\n    WGPUVertexStepMode stepMode;\n    uint64_t attributeCount;\n};\n\n\nDAWN_DECLARE_UNUSED size_t WGPUVertexBufferLayoutGetExtraRequiredSize(const WGPUVertexBufferLayout& record) {\n    DAWN_UNUSED(record);\n    size_t result = 0;\n\n    {\n        auto memberLength = record.attributeCount;\n        auto size = WireAlignSizeofN<WGPUVertexAttributeTransfer>(memberLength);\n        ASSERT(size);\n        result += *size;\n        for (decltype(memberLength) i = 0; i < memberLength; ++i) {\n            result += WGPUVertexAttributeGetExtraRequiredSize(record.attributes[i]);\n        }\n    }\n    return result;\n}\n// GetExtraRequiredSize isn't used for structures that are value members of other structures\n// because we assume they cannot contain pointers themselves.\nDAWN_UNUSED_FUNC(WGPUVertexBufferLayoutGetExtraRequiredSize);\n\nDAWN_DECLARE_UNUSED WireResult WGPUVertexBufferLayoutSerialize(\n    const WGPUVertexBufferLayout& record,\n    WGPUVertexBufferLayoutTransfer* transfer,\n    SerializeBuffer* buffer) {\n    DAWN_UNUSED(buffer);\n\n\n    transfer->arrayStride = record.arrayStride;\n    transfer->stepMode = record.stepMode;\n    transfer->attributeCount = record.attributeCount;\n    {\n        auto memberLength = record.attributeCount;\n\n        WGPUVertexAttributeTransfer* memberBuffer;\n        WIRE_TRY(buffer->NextN(memberLength, &memberBuffer));\n\n        memcpy(\n            memberBuffer, record.attributes,\n            sizeof(WGPUVertexAttributeTransfer) * memberLength);\n    }\n\n    return WireResult::Success;\n}\nDAWN_UNUSED_FUNC(WGPUVertexBufferLayoutSerialize);\n\nDAWN_DECLARE_UNUSED WireResult WGPUVertexBufferLayoutDeserialize(\n    WGPUVertexBufferLayout* record,\n    const volatile WGPUVertexBufferLayoutTransfer* transfer,\n    DeserializeBuffer* deserializeBuffer,\n    DeserializeAllocator* allocator) {\n    DAWN_UNUSED(allocator);\n\n\n\n    static_assert(sizeof(record->arrayStride) >= sizeof(transfer->arrayStride), \"Deserialize assignment may not narrow.\");\n    record->arrayStride = transfer->arrayStride;\n    static_assert(sizeof(record->stepMode) >= sizeof(transfer->stepMode), \"Deserialize assignment may not narrow.\");\n    record->stepMode = transfer->stepMode;\n    if (transfer->attributeCount > std::numeric_limits<size_t>::max()) return WireResult::FatalError;\n    record->attributeCount = checked_cast<size_t>(transfer->attributeCount);\n    {\n        auto memberLength = record->attributeCount;\n        const volatile WGPUVertexAttributeTransfer* memberBuffer;\n        WIRE_TRY(deserializeBuffer->ReadN(memberLength, &memberBuffer));\n\n        WGPUVertexAttribute* copiedMembers;\n        WIRE_TRY(GetSpace(allocator, memberLength, &copiedMembers));\n        record->attributes = copiedMembers;\n\n        memcpy(\n            copiedMembers,\n            const_cast<const WGPUVertexAttributeTransfer*>(memberBuffer),\n           sizeof(WGPUVertexAttributeTransfer) * memberLength);\n    }\n\n    return WireResult::Success;\n}\nDAWN_UNUSED_FUNC(WGPUVertexBufferLayoutDeserialize);\n\nstruct WGPUBindGroupLayoutDescriptorTransfer {\n    static_assert(0 <= 1,\n                  \"Record must be at most one of is_cmd, extensible, and chained.\");\n    bool hasNextInChain;\n\n    uint64_t labelStrlen;\n    bool has_label;\n    uint64_t entryCount;\n};\n\n\nDAWN_DECLARE_UNUSED size_t WGPUBindGroupLayoutDescriptorGetExtraRequiredSize(const WGPUBindGroupLayoutDescriptor& record) {\n    DAWN_UNUSED(record);\n    size_t result = 0;\n\n    if (record.nextInChain != nullptr) {\n        result += GetChainedStructExtraRequiredSize(record.nextInChain);\n    }\n    if (record.label != nullptr) {\n        result += Align(std::strlen(record.label), kWireBufferAlignment);\n    }\n    {\n        auto memberLength = record.entryCount;\n        auto size = WireAlignSizeofN<WGPUBindGroupLayoutEntryTransfer>(memberLength);\n        ASSERT(size);\n        result += *size;\n        for (decltype(memberLength) i = 0; i < memberLength; ++i) {\n            result += WGPUBindGroupLayoutEntryGetExtraRequiredSize(record.entries[i]);\n        }\n    }\n    return result;\n}\n// GetExtraRequiredSize isn't used for structures that are value members of other structures\n// because we assume they cannot contain pointers themselves.\nDAWN_UNUSED_FUNC(WGPUBindGroupLayoutDescriptorGetExtraRequiredSize);\n\nDAWN_DECLARE_UNUSED WireResult WGPUBindGroupLayoutDescriptorSerialize(\n    const WGPUBindGroupLayoutDescriptor& record,\n    WGPUBindGroupLayoutDescriptorTransfer* transfer,\n    SerializeBuffer* buffer, const ObjectIdProvider& provider) {\n    DAWN_UNUSED(buffer);\n\n    if (record.nextInChain != nullptr) {\n        transfer->hasNextInChain = true;\n        WIRE_TRY(SerializeChainedStruct(record.nextInChain, buffer, provider));\n    } else {\n        transfer->hasNextInChain = false;\n    }\n\n    transfer->entryCount = record.entryCount;\n    bool has_label = record.label != nullptr;\n    transfer->has_label = has_label;\n    if (has_label) {\n        transfer->labelStrlen = std::strlen(record.label);\n\n        char* stringInBuffer;\n        WIRE_TRY(buffer->NextN(transfer->labelStrlen, &stringInBuffer));\n        memcpy(stringInBuffer, record.label, transfer->labelStrlen);\n    }\n    {\n        auto memberLength = record.entryCount;\n\n        WGPUBindGroupLayoutEntryTransfer* memberBuffer;\n        WIRE_TRY(buffer->NextN(memberLength, &memberBuffer));\n\n        for (decltype(memberLength) i = 0; i < memberLength; ++i) {\n            WIRE_TRY(WGPUBindGroupLayoutEntrySerialize(record.entries[i], &memberBuffer[i], buffer, provider));\n        }\n    }\n\n    return WireResult::Success;\n}\nDAWN_UNUSED_FUNC(WGPUBindGroupLayoutDescriptorSerialize);\n\nDAWN_DECLARE_UNUSED WireResult WGPUBindGroupLayoutDescriptorDeserialize(\n    WGPUBindGroupLayoutDescriptor* record,\n    const volatile WGPUBindGroupLayoutDescriptorTransfer* transfer,\n    DeserializeBuffer* deserializeBuffer,\n    DeserializeAllocator* allocator, const ObjectIdResolver& resolver) {\n    DAWN_UNUSED(allocator);\n\n\n    record->nextInChain = nullptr;\n    if (transfer->hasNextInChain) {\n        WIRE_TRY(DeserializeChainedStruct(&record->nextInChain, deserializeBuffer, allocator, resolver));\n    }\n\n    if (transfer->entryCount > std::numeric_limits<size_t>::max()) return WireResult::FatalError;\n    record->entryCount = checked_cast<size_t>(transfer->entryCount);\n    bool has_label = transfer->has_label;\n    record->label = nullptr;\n    if (has_label) {\n        uint64_t stringLength64 = transfer->labelStrlen;\n        if (stringLength64 >= std::numeric_limits<size_t>::max()) {\n            return WireResult::FatalError;\n        }\n        size_t stringLength = static_cast<size_t>(stringLength64);\n\n        const volatile char* stringInBuffer;\n        WIRE_TRY(deserializeBuffer->ReadN(stringLength, &stringInBuffer));\n\n        char* copiedString;\n        WIRE_TRY(GetSpace(allocator, stringLength + 1, &copiedString));\n        memcpy(copiedString, const_cast<const char*>(stringInBuffer), stringLength);\n        copiedString[stringLength] = '\\0';\n        record->label = copiedString;\n    }\n    {\n        auto memberLength = record->entryCount;\n        const volatile WGPUBindGroupLayoutEntryTransfer* memberBuffer;\n        WIRE_TRY(deserializeBuffer->ReadN(memberLength, &memberBuffer));\n\n        WGPUBindGroupLayoutEntry* copiedMembers;\n        WIRE_TRY(GetSpace(allocator, memberLength, &copiedMembers));\n        record->entries = copiedMembers;\n\n        for (decltype(memberLength) i = 0; i < memberLength; ++i) {\n            WIRE_TRY(WGPUBindGroupLayoutEntryDeserialize(&copiedMembers[i], &memberBuffer[i], deserializeBuffer, allocator, resolver));\n        }\n    }\n\n    return WireResult::Success;\n}\nDAWN_UNUSED_FUNC(WGPUBindGroupLayoutDescriptorDeserialize);\n\nstruct WGPUColorTargetStateTransfer {\n    static_assert(0 <= 1,\n                  \"Record must be at most one of is_cmd, extensible, and chained.\");\n    bool hasNextInChain;\n\n    WGPUTextureFormat format;\n    bool has_blend;\n    WGPUColorWriteMaskFlags writeMask;\n};\n\n\nDAWN_DECLARE_UNUSED size_t WGPUColorTargetStateGetExtraRequiredSize(const WGPUColorTargetState& record) {\n    DAWN_UNUSED(record);\n    size_t result = 0;\n\n    if (record.nextInChain != nullptr) {\n        result += GetChainedStructExtraRequiredSize(record.nextInChain);\n    }\n    if (record.blend != nullptr) {\n        auto memberLength = 1u;\n        auto size = WireAlignSizeofN<WGPUBlendStateTransfer>(memberLength);\n        ASSERT(size);\n        result += *size;\n        for (decltype(memberLength) i = 0; i < memberLength; ++i) {\n            result += WGPUBlendStateGetExtraRequiredSize(record.blend[i]);\n        }\n    }\n    return result;\n}\n// GetExtraRequiredSize isn't used for structures that are value members of other structures\n// because we assume they cannot contain pointers themselves.\nDAWN_UNUSED_FUNC(WGPUColorTargetStateGetExtraRequiredSize);\n\nDAWN_DECLARE_UNUSED WireResult WGPUColorTargetStateSerialize(\n    const WGPUColorTargetState& record,\n    WGPUColorTargetStateTransfer* transfer,\n    SerializeBuffer* buffer, const ObjectIdProvider& provider) {\n    DAWN_UNUSED(buffer);\n\n    if (record.nextInChain != nullptr) {\n        transfer->hasNextInChain = true;\n        WIRE_TRY(SerializeChainedStruct(record.nextInChain, buffer, provider));\n    } else {\n        transfer->hasNextInChain = false;\n    }\n\n    transfer->format = record.format;\n    transfer->writeMask = record.writeMask;\n    bool has_blend = record.blend != nullptr;\n    transfer->has_blend = has_blend;\n    if (has_blend) {\n        auto memberLength = 1u;\n\n        WGPUBlendStateTransfer* memberBuffer;\n        WIRE_TRY(buffer->NextN(memberLength, &memberBuffer));\n\n        memcpy(\n            memberBuffer, record.blend,\n            sizeof(WGPUBlendStateTransfer) * memberLength);\n    }\n\n    return WireResult::Success;\n}\nDAWN_UNUSED_FUNC(WGPUColorTargetStateSerialize);\n\nDAWN_DECLARE_UNUSED WireResult WGPUColorTargetStateDeserialize(\n    WGPUColorTargetState* record,\n    const volatile WGPUColorTargetStateTransfer* transfer,\n    DeserializeBuffer* deserializeBuffer,\n    DeserializeAllocator* allocator, const ObjectIdResolver& resolver) {\n    DAWN_UNUSED(allocator);\n\n\n    record->nextInChain = nullptr;\n    if (transfer->hasNextInChain) {\n        WIRE_TRY(DeserializeChainedStruct(&record->nextInChain, deserializeBuffer, allocator, resolver));\n    }\n\n    static_assert(sizeof(record->format) >= sizeof(transfer->format), \"Deserialize assignment may not narrow.\");\n    record->format = transfer->format;\n    static_assert(sizeof(record->writeMask) >= sizeof(transfer->writeMask), \"Deserialize assignment may not narrow.\");\n    record->writeMask = transfer->writeMask;\n    bool has_blend = transfer->has_blend;\n    record->blend = nullptr;\n    if (has_blend) {\n        auto memberLength = 1u;\n        const volatile WGPUBlendStateTransfer* memberBuffer;\n        WIRE_TRY(deserializeBuffer->ReadN(memberLength, &memberBuffer));\n\n        WGPUBlendState* copiedMembers;\n        WIRE_TRY(GetSpace(allocator, memberLength, &copiedMembers));\n        record->blend = copiedMembers;\n\n        memcpy(\n            copiedMembers,\n            const_cast<const WGPUBlendStateTransfer*>(memberBuffer),\n           sizeof(WGPUBlendStateTransfer) * memberLength);\n    }\n\n    return WireResult::Success;\n}\nDAWN_UNUSED_FUNC(WGPUColorTargetStateDeserialize);\n\nstruct WGPUComputePipelineDescriptorTransfer {\n    static_assert(0 <= 1,\n                  \"Record must be at most one of is_cmd, extensible, and chained.\");\n    bool hasNextInChain;\n\n    uint64_t labelStrlen;\n    bool has_label;\n    ObjectId layout;\n    WGPUProgrammableStageDescriptorTransfer compute;\n};\n\n\nDAWN_DECLARE_UNUSED size_t WGPUComputePipelineDescriptorGetExtraRequiredSize(const WGPUComputePipelineDescriptor& record) {\n    DAWN_UNUSED(record);\n    size_t result = 0;\n\n    if (record.nextInChain != nullptr) {\n        result += GetChainedStructExtraRequiredSize(record.nextInChain);\n    }\n    if (record.label != nullptr) {\n        result += Align(std::strlen(record.label), kWireBufferAlignment);\n    }\n    {\n        result += WGPUProgrammableStageDescriptorGetExtraRequiredSize(record.compute);\n    }\n    return result;\n}\n// GetExtraRequiredSize isn't used for structures that are value members of other structures\n// because we assume they cannot contain pointers themselves.\nDAWN_UNUSED_FUNC(WGPUComputePipelineDescriptorGetExtraRequiredSize);\n\nDAWN_DECLARE_UNUSED WireResult WGPUComputePipelineDescriptorSerialize(\n    const WGPUComputePipelineDescriptor& record,\n    WGPUComputePipelineDescriptorTransfer* transfer,\n    SerializeBuffer* buffer, const ObjectIdProvider& provider) {\n    DAWN_UNUSED(buffer);\n\n    if (record.nextInChain != nullptr) {\n        transfer->hasNextInChain = true;\n        WIRE_TRY(SerializeChainedStruct(record.nextInChain, buffer, provider));\n    } else {\n        transfer->hasNextInChain = false;\n    }\n\n    WIRE_TRY(provider.GetOptionalId(record.layout, &transfer->layout));\n    WIRE_TRY(WGPUProgrammableStageDescriptorSerialize(record.compute, &transfer->compute, buffer, provider));\n    bool has_label = record.label != nullptr;\n    transfer->has_label = has_label;\n    if (has_label) {\n        transfer->labelStrlen = std::strlen(record.label);\n\n        char* stringInBuffer;\n        WIRE_TRY(buffer->NextN(transfer->labelStrlen, &stringInBuffer));\n        memcpy(stringInBuffer, record.label, transfer->labelStrlen);\n    }\n\n    return WireResult::Success;\n}\nDAWN_UNUSED_FUNC(WGPUComputePipelineDescriptorSerialize);\n\nDAWN_DECLARE_UNUSED WireResult WGPUComputePipelineDescriptorDeserialize(\n    WGPUComputePipelineDescriptor* record,\n    const volatile WGPUComputePipelineDescriptorTransfer* transfer,\n    DeserializeBuffer* deserializeBuffer,\n    DeserializeAllocator* allocator, const ObjectIdResolver& resolver) {\n    DAWN_UNUSED(allocator);\n\n\n    record->nextInChain = nullptr;\n    if (transfer->hasNextInChain) {\n        WIRE_TRY(DeserializeChainedStruct(&record->nextInChain, deserializeBuffer, allocator, resolver));\n    }\n\n    WIRE_TRY(resolver.GetOptionalFromId(transfer->layout, &record->layout));\n    WIRE_TRY(WGPUProgrammableStageDescriptorDeserialize(&record->compute, &transfer->compute, deserializeBuffer, allocator, resolver));\n    bool has_label = transfer->has_label;\n    record->label = nullptr;\n    if (has_label) {\n        uint64_t stringLength64 = transfer->labelStrlen;\n        if (stringLength64 >= std::numeric_limits<size_t>::max()) {\n            return WireResult::FatalError;\n        }\n        size_t stringLength = static_cast<size_t>(stringLength64);\n\n        const volatile char* stringInBuffer;\n        WIRE_TRY(deserializeBuffer->ReadN(stringLength, &stringInBuffer));\n\n        char* copiedString;\n        WIRE_TRY(GetSpace(allocator, stringLength + 1, &copiedString));\n        memcpy(copiedString, const_cast<const char*>(stringInBuffer), stringLength);\n        copiedString[stringLength] = '\\0';\n        record->label = copiedString;\n    }\n\n    return WireResult::Success;\n}\nDAWN_UNUSED_FUNC(WGPUComputePipelineDescriptorDeserialize);\n\nstruct WGPUDeviceDescriptorTransfer {\n    static_assert(0 <= 1,\n                  \"Record must be at most one of is_cmd, extensible, and chained.\");\n    bool hasNextInChain;\n\n    uint64_t labelStrlen;\n    bool has_label;\n    uint64_t requiredFeaturesCount;\n    bool has_requiredLimits;\n    WGPUQueueDescriptorTransfer defaultQueue;\n};\n\n\nDAWN_DECLARE_UNUSED size_t WGPUDeviceDescriptorGetExtraRequiredSize(const WGPUDeviceDescriptor& record) {\n    DAWN_UNUSED(record);\n    size_t result = 0;\n\n    if (record.nextInChain != nullptr) {\n        result += GetChainedStructExtraRequiredSize(record.nextInChain);\n    }\n    if (record.label != nullptr) {\n        result += Align(std::strlen(record.label), kWireBufferAlignment);\n    }\n    {\n        auto memberLength = record.requiredFeaturesCount;\n        auto size = WireAlignSizeofN<WGPUFeatureName>(memberLength);\n        ASSERT(size);\n        result += *size;\n    }\n    if (record.requiredLimits != nullptr) {\n        auto memberLength = 1u;\n        auto size = WireAlignSizeofN<WGPURequiredLimitsTransfer>(memberLength);\n        ASSERT(size);\n        result += *size;\n        for (decltype(memberLength) i = 0; i < memberLength; ++i) {\n            result += WGPURequiredLimitsGetExtraRequiredSize(record.requiredLimits[i]);\n        }\n    }\n    {\n        result += WGPUQueueDescriptorGetExtraRequiredSize(record.defaultQueue);\n    }\n    return result;\n}\n// GetExtraRequiredSize isn't used for structures that are value members of other structures\n// because we assume they cannot contain pointers themselves.\nDAWN_UNUSED_FUNC(WGPUDeviceDescriptorGetExtraRequiredSize);\n\nDAWN_DECLARE_UNUSED WireResult WGPUDeviceDescriptorSerialize(\n    const WGPUDeviceDescriptor& record,\n    WGPUDeviceDescriptorTransfer* transfer,\n    SerializeBuffer* buffer, const ObjectIdProvider& provider) {\n    DAWN_UNUSED(buffer);\n\n    if (record.nextInChain != nullptr) {\n        transfer->hasNextInChain = true;\n        WIRE_TRY(SerializeChainedStruct(record.nextInChain, buffer, provider));\n    } else {\n        transfer->hasNextInChain = false;\n    }\n\n    transfer->requiredFeaturesCount = record.requiredFeaturesCount;\n    WIRE_TRY(WGPUQueueDescriptorSerialize(record.defaultQueue, &transfer->defaultQueue, buffer, provider));\n    if (record.deviceLostCallback != nullptr) return WireResult::FatalError;\n    if (record.deviceLostUserdata != nullptr) return WireResult::FatalError;\n    bool has_label = record.label != nullptr;\n    transfer->has_label = has_label;\n    if (has_label) {\n        transfer->labelStrlen = std::strlen(record.label);\n\n        char* stringInBuffer;\n        WIRE_TRY(buffer->NextN(transfer->labelStrlen, &stringInBuffer));\n        memcpy(stringInBuffer, record.label, transfer->labelStrlen);\n    }\n    {\n        auto memberLength = record.requiredFeaturesCount;\n\n        WGPUFeatureName* memberBuffer;\n        WIRE_TRY(buffer->NextN(memberLength, &memberBuffer));\n\n        memcpy(\n            memberBuffer, record.requiredFeatures,\n            sizeof(WGPUFeatureName) * memberLength);\n    }\n    bool has_requiredLimits = record.requiredLimits != nullptr;\n    transfer->has_requiredLimits = has_requiredLimits;\n    if (has_requiredLimits) {\n        auto memberLength = 1u;\n\n        WGPURequiredLimitsTransfer* memberBuffer;\n        WIRE_TRY(buffer->NextN(memberLength, &memberBuffer));\n\n        for (decltype(memberLength) i = 0; i < memberLength; ++i) {\n            WIRE_TRY(WGPURequiredLimitsSerialize(record.requiredLimits[i], &memberBuffer[i], buffer, provider));\n        }\n    }\n\n    return WireResult::Success;\n}\nDAWN_UNUSED_FUNC(WGPUDeviceDescriptorSerialize);\n\nDAWN_DECLARE_UNUSED WireResult WGPUDeviceDescriptorDeserialize(\n    WGPUDeviceDescriptor* record,\n    const volatile WGPUDeviceDescriptorTransfer* transfer,\n    DeserializeBuffer* deserializeBuffer,\n    DeserializeAllocator* allocator, const ObjectIdResolver& resolver) {\n    DAWN_UNUSED(allocator);\n\n\n    record->nextInChain = nullptr;\n    if (transfer->hasNextInChain) {\n        WIRE_TRY(DeserializeChainedStruct(&record->nextInChain, deserializeBuffer, allocator, resolver));\n    }\n\n    if (transfer->requiredFeaturesCount > std::numeric_limits<size_t>::max()) return WireResult::FatalError;\n    record->requiredFeaturesCount = checked_cast<size_t>(transfer->requiredFeaturesCount);\n    WIRE_TRY(WGPUQueueDescriptorDeserialize(&record->defaultQueue, &transfer->defaultQueue, deserializeBuffer, allocator, resolver));\n    record->deviceLostCallback = nullptr;\n    record->deviceLostUserdata = nullptr;\n    bool has_label = transfer->has_label;\n    record->label = nullptr;\n    if (has_label) {\n        uint64_t stringLength64 = transfer->labelStrlen;\n        if (stringLength64 >= std::numeric_limits<size_t>::max()) {\n            return WireResult::FatalError;\n        }\n        size_t stringLength = static_cast<size_t>(stringLength64);\n\n        const volatile char* stringInBuffer;\n        WIRE_TRY(deserializeBuffer->ReadN(stringLength, &stringInBuffer));\n\n        char* copiedString;\n        WIRE_TRY(GetSpace(allocator, stringLength + 1, &copiedString));\n        memcpy(copiedString, const_cast<const char*>(stringInBuffer), stringLength);\n        copiedString[stringLength] = '\\0';\n        record->label = copiedString;\n    }\n    {\n        auto memberLength = record->requiredFeaturesCount;\n        const volatile WGPUFeatureName* memberBuffer;\n        WIRE_TRY(deserializeBuffer->ReadN(memberLength, &memberBuffer));\n\n        WGPUFeatureName* copiedMembers;\n        WIRE_TRY(GetSpace(allocator, memberLength, &copiedMembers));\n        record->requiredFeatures = copiedMembers;\n\n        memcpy(\n            copiedMembers,\n            const_cast<const WGPUFeatureName*>(memberBuffer),\n           sizeof(WGPUFeatureName) * memberLength);\n    }\n    bool has_requiredLimits = transfer->has_requiredLimits;\n    record->requiredLimits = nullptr;\n    if (has_requiredLimits) {\n        auto memberLength = 1u;\n        const volatile WGPURequiredLimitsTransfer* memberBuffer;\n        WIRE_TRY(deserializeBuffer->ReadN(memberLength, &memberBuffer));\n\n        WGPURequiredLimits* copiedMembers;\n        WIRE_TRY(GetSpace(allocator, memberLength, &copiedMembers));\n        record->requiredLimits = copiedMembers;\n\n        for (decltype(memberLength) i = 0; i < memberLength; ++i) {\n            WIRE_TRY(WGPURequiredLimitsDeserialize(&copiedMembers[i], &memberBuffer[i], deserializeBuffer, allocator, resolver));\n        }\n    }\n\n    return WireResult::Success;\n}\nDAWN_UNUSED_FUNC(WGPUDeviceDescriptorDeserialize);\n\nstruct WGPURenderPassDescriptorTransfer {\n    static_assert(0 <= 1,\n                  \"Record must be at most one of is_cmd, extensible, and chained.\");\n    bool hasNextInChain;\n\n    uint64_t labelStrlen;\n    bool has_label;\n    uint64_t colorAttachmentCount;\n    bool has_depthStencilAttachment;\n    ObjectId occlusionQuerySet;\n    uint64_t timestampWriteCount;\n};\n\n\nDAWN_DECLARE_UNUSED size_t WGPURenderPassDescriptorGetExtraRequiredSize(const WGPURenderPassDescriptor& record) {\n    DAWN_UNUSED(record);\n    size_t result = 0;\n\n    if (record.nextInChain != nullptr) {\n        result += GetChainedStructExtraRequiredSize(record.nextInChain);\n    }\n    if (record.label != nullptr) {\n        result += Align(std::strlen(record.label), kWireBufferAlignment);\n    }\n    {\n        auto memberLength = record.colorAttachmentCount;\n        auto size = WireAlignSizeofN<WGPURenderPassColorAttachmentTransfer>(memberLength);\n        ASSERT(size);\n        result += *size;\n        for (decltype(memberLength) i = 0; i < memberLength; ++i) {\n            result += WGPURenderPassColorAttachmentGetExtraRequiredSize(record.colorAttachments[i]);\n        }\n    }\n    if (record.depthStencilAttachment != nullptr) {\n        auto memberLength = 1u;\n        auto size = WireAlignSizeofN<WGPURenderPassDepthStencilAttachmentTransfer>(memberLength);\n        ASSERT(size);\n        result += *size;\n        for (decltype(memberLength) i = 0; i < memberLength; ++i) {\n            result += WGPURenderPassDepthStencilAttachmentGetExtraRequiredSize(record.depthStencilAttachment[i]);\n        }\n    }\n    {\n        auto memberLength = record.timestampWriteCount;\n        auto size = WireAlignSizeofN<WGPURenderPassTimestampWriteTransfer>(memberLength);\n        ASSERT(size);\n        result += *size;\n        for (decltype(memberLength) i = 0; i < memberLength; ++i) {\n            result += WGPURenderPassTimestampWriteGetExtraRequiredSize(record.timestampWrites[i]);\n        }\n    }\n    return result;\n}\n// GetExtraRequiredSize isn't used for structures that are value members of other structures\n// because we assume they cannot contain pointers themselves.\nDAWN_UNUSED_FUNC(WGPURenderPassDescriptorGetExtraRequiredSize);\n\nDAWN_DECLARE_UNUSED WireResult WGPURenderPassDescriptorSerialize(\n    const WGPURenderPassDescriptor& record,\n    WGPURenderPassDescriptorTransfer* transfer,\n    SerializeBuffer* buffer, const ObjectIdProvider& provider) {\n    DAWN_UNUSED(buffer);\n\n    if (record.nextInChain != nullptr) {\n        transfer->hasNextInChain = true;\n        WIRE_TRY(SerializeChainedStruct(record.nextInChain, buffer, provider));\n    } else {\n        transfer->hasNextInChain = false;\n    }\n\n    transfer->colorAttachmentCount = record.colorAttachmentCount;\n    WIRE_TRY(provider.GetOptionalId(record.occlusionQuerySet, &transfer->occlusionQuerySet));\n    transfer->timestampWriteCount = record.timestampWriteCount;\n    bool has_label = record.label != nullptr;\n    transfer->has_label = has_label;\n    if (has_label) {\n        transfer->labelStrlen = std::strlen(record.label);\n\n        char* stringInBuffer;\n        WIRE_TRY(buffer->NextN(transfer->labelStrlen, &stringInBuffer));\n        memcpy(stringInBuffer, record.label, transfer->labelStrlen);\n    }\n    {\n        auto memberLength = record.colorAttachmentCount;\n\n        WGPURenderPassColorAttachmentTransfer* memberBuffer;\n        WIRE_TRY(buffer->NextN(memberLength, &memberBuffer));\n\n        for (decltype(memberLength) i = 0; i < memberLength; ++i) {\n            WIRE_TRY(WGPURenderPassColorAttachmentSerialize(record.colorAttachments[i], &memberBuffer[i], buffer, provider));\n        }\n    }\n    bool has_depthStencilAttachment = record.depthStencilAttachment != nullptr;\n    transfer->has_depthStencilAttachment = has_depthStencilAttachment;\n    if (has_depthStencilAttachment) {\n        auto memberLength = 1u;\n\n        WGPURenderPassDepthStencilAttachmentTransfer* memberBuffer;\n        WIRE_TRY(buffer->NextN(memberLength, &memberBuffer));\n\n        for (decltype(memberLength) i = 0; i < memberLength; ++i) {\n            WIRE_TRY(WGPURenderPassDepthStencilAttachmentSerialize(record.depthStencilAttachment[i], &memberBuffer[i], buffer, provider));\n        }\n    }\n    {\n        auto memberLength = record.timestampWriteCount;\n\n        WGPURenderPassTimestampWriteTransfer* memberBuffer;\n        WIRE_TRY(buffer->NextN(memberLength, &memberBuffer));\n\n        for (decltype(memberLength) i = 0; i < memberLength; ++i) {\n            WIRE_TRY(WGPURenderPassTimestampWriteSerialize(record.timestampWrites[i], &memberBuffer[i], buffer, provider));\n        }\n    }\n\n    return WireResult::Success;\n}\nDAWN_UNUSED_FUNC(WGPURenderPassDescriptorSerialize);\n\nDAWN_DECLARE_UNUSED WireResult WGPURenderPassDescriptorDeserialize(\n    WGPURenderPassDescriptor* record,\n    const volatile WGPURenderPassDescriptorTransfer* transfer,\n    DeserializeBuffer* deserializeBuffer,\n    DeserializeAllocator* allocator, const ObjectIdResolver& resolver) {\n    DAWN_UNUSED(allocator);\n\n\n    record->nextInChain = nullptr;\n    if (transfer->hasNextInChain) {\n        WIRE_TRY(DeserializeChainedStruct(&record->nextInChain, deserializeBuffer, allocator, resolver));\n    }\n\n    if (transfer->colorAttachmentCount > std::numeric_limits<size_t>::max()) return WireResult::FatalError;\n    record->colorAttachmentCount = checked_cast<size_t>(transfer->colorAttachmentCount);\n    WIRE_TRY(resolver.GetOptionalFromId(transfer->occlusionQuerySet, &record->occlusionQuerySet));\n    if (transfer->timestampWriteCount > std::numeric_limits<size_t>::max()) return WireResult::FatalError;\n    record->timestampWriteCount = checked_cast<size_t>(transfer->timestampWriteCount);\n    bool has_label = transfer->has_label;\n    record->label = nullptr;\n    if (has_label) {\n        uint64_t stringLength64 = transfer->labelStrlen;\n        if (stringLength64 >= std::numeric_limits<size_t>::max()) {\n            return WireResult::FatalError;\n        }\n        size_t stringLength = static_cast<size_t>(stringLength64);\n\n        const volatile char* stringInBuffer;\n        WIRE_TRY(deserializeBuffer->ReadN(stringLength, &stringInBuffer));\n\n        char* copiedString;\n        WIRE_TRY(GetSpace(allocator, stringLength + 1, &copiedString));\n        memcpy(copiedString, const_cast<const char*>(stringInBuffer), stringLength);\n        copiedString[stringLength] = '\\0';\n        record->label = copiedString;\n    }\n    {\n        auto memberLength = record->colorAttachmentCount;\n        const volatile WGPURenderPassColorAttachmentTransfer* memberBuffer;\n        WIRE_TRY(deserializeBuffer->ReadN(memberLength, &memberBuffer));\n\n        WGPURenderPassColorAttachment* copiedMembers;\n        WIRE_TRY(GetSpace(allocator, memberLength, &copiedMembers));\n        record->colorAttachments = copiedMembers;\n\n        for (decltype(memberLength) i = 0; i < memberLength; ++i) {\n            WIRE_TRY(WGPURenderPassColorAttachmentDeserialize(&copiedMembers[i], &memberBuffer[i], deserializeBuffer, allocator, resolver));\n        }\n    }\n    bool has_depthStencilAttachment = transfer->has_depthStencilAttachment;\n    record->depthStencilAttachment = nullptr;\n    if (has_depthStencilAttachment) {\n        auto memberLength = 1u;\n        const volatile WGPURenderPassDepthStencilAttachmentTransfer* memberBuffer;\n        WIRE_TRY(deserializeBuffer->ReadN(memberLength, &memberBuffer));\n\n        WGPURenderPassDepthStencilAttachment* copiedMembers;\n        WIRE_TRY(GetSpace(allocator, memberLength, &copiedMembers));\n        record->depthStencilAttachment = copiedMembers;\n\n        for (decltype(memberLength) i = 0; i < memberLength; ++i) {\n            WIRE_TRY(WGPURenderPassDepthStencilAttachmentDeserialize(&copiedMembers[i], &memberBuffer[i], deserializeBuffer, allocator, resolver));\n        }\n    }\n    {\n        auto memberLength = record->timestampWriteCount;\n        const volatile WGPURenderPassTimestampWriteTransfer* memberBuffer;\n        WIRE_TRY(deserializeBuffer->ReadN(memberLength, &memberBuffer));\n\n        WGPURenderPassTimestampWrite* copiedMembers;\n        WIRE_TRY(GetSpace(allocator, memberLength, &copiedMembers));\n        record->timestampWrites = copiedMembers;\n\n        for (decltype(memberLength) i = 0; i < memberLength; ++i) {\n            WIRE_TRY(WGPURenderPassTimestampWriteDeserialize(&copiedMembers[i], &memberBuffer[i], deserializeBuffer, allocator, resolver));\n        }\n    }\n\n    return WireResult::Success;\n}\nDAWN_UNUSED_FUNC(WGPURenderPassDescriptorDeserialize);\n\nstruct WGPUVertexStateTransfer {\n    static_assert(0 <= 1,\n                  \"Record must be at most one of is_cmd, extensible, and chained.\");\n    bool hasNextInChain;\n\n    ObjectId module;\n    uint64_t entryPointStrlen;\n    uint64_t constantCount;\n    uint64_t bufferCount;\n};\n\n\nDAWN_DECLARE_UNUSED size_t WGPUVertexStateGetExtraRequiredSize(const WGPUVertexState& record) {\n    DAWN_UNUSED(record);\n    size_t result = 0;\n\n    if (record.nextInChain != nullptr) {\n        result += GetChainedStructExtraRequiredSize(record.nextInChain);\n    }\n    ASSERT(record.entryPoint != nullptr);\n    result += Align(std::strlen(record.entryPoint), kWireBufferAlignment);\n    {\n        auto memberLength = record.constantCount;\n        auto size = WireAlignSizeofN<WGPUConstantEntryTransfer>(memberLength);\n        ASSERT(size);\n        result += *size;\n        for (decltype(memberLength) i = 0; i < memberLength; ++i) {\n            result += WGPUConstantEntryGetExtraRequiredSize(record.constants[i]);\n        }\n    }\n    {\n        auto memberLength = record.bufferCount;\n        auto size = WireAlignSizeofN<WGPUVertexBufferLayoutTransfer>(memberLength);\n        ASSERT(size);\n        result += *size;\n        for (decltype(memberLength) i = 0; i < memberLength; ++i) {\n            result += WGPUVertexBufferLayoutGetExtraRequiredSize(record.buffers[i]);\n        }\n    }\n    return result;\n}\n// GetExtraRequiredSize isn't used for structures that are value members of other structures\n// because we assume they cannot contain pointers themselves.\nDAWN_UNUSED_FUNC(WGPUVertexStateGetExtraRequiredSize);\n\nDAWN_DECLARE_UNUSED WireResult WGPUVertexStateSerialize(\n    const WGPUVertexState& record,\n    WGPUVertexStateTransfer* transfer,\n    SerializeBuffer* buffer, const ObjectIdProvider& provider) {\n    DAWN_UNUSED(buffer);\n\n    if (record.nextInChain != nullptr) {\n        transfer->hasNextInChain = true;\n        WIRE_TRY(SerializeChainedStruct(record.nextInChain, buffer, provider));\n    } else {\n        transfer->hasNextInChain = false;\n    }\n\n    WIRE_TRY(provider.GetId(record.module, &transfer->module));\n    transfer->constantCount = record.constantCount;\n    transfer->bufferCount = record.bufferCount;\n    {\n        transfer->entryPointStrlen = std::strlen(record.entryPoint);\n\n        char* stringInBuffer;\n        WIRE_TRY(buffer->NextN(transfer->entryPointStrlen, &stringInBuffer));\n        memcpy(stringInBuffer, record.entryPoint, transfer->entryPointStrlen);\n    }\n    {\n        auto memberLength = record.constantCount;\n\n        WGPUConstantEntryTransfer* memberBuffer;\n        WIRE_TRY(buffer->NextN(memberLength, &memberBuffer));\n\n        for (decltype(memberLength) i = 0; i < memberLength; ++i) {\n            WIRE_TRY(WGPUConstantEntrySerialize(record.constants[i], &memberBuffer[i], buffer, provider));\n        }\n    }\n    {\n        auto memberLength = record.bufferCount;\n\n        WGPUVertexBufferLayoutTransfer* memberBuffer;\n        WIRE_TRY(buffer->NextN(memberLength, &memberBuffer));\n\n        for (decltype(memberLength) i = 0; i < memberLength; ++i) {\n            WIRE_TRY(WGPUVertexBufferLayoutSerialize(record.buffers[i], &memberBuffer[i], buffer));\n        }\n    }\n\n    return WireResult::Success;\n}\nDAWN_UNUSED_FUNC(WGPUVertexStateSerialize);\n\nDAWN_DECLARE_UNUSED WireResult WGPUVertexStateDeserialize(\n    WGPUVertexState* record,\n    const volatile WGPUVertexStateTransfer* transfer,\n    DeserializeBuffer* deserializeBuffer,\n    DeserializeAllocator* allocator, const ObjectIdResolver& resolver) {\n    DAWN_UNUSED(allocator);\n\n\n    record->nextInChain = nullptr;\n    if (transfer->hasNextInChain) {\n        WIRE_TRY(DeserializeChainedStruct(&record->nextInChain, deserializeBuffer, allocator, resolver));\n    }\n\n    WIRE_TRY(resolver.GetFromId(transfer->module, &record->module));\n    if (transfer->constantCount > std::numeric_limits<size_t>::max()) return WireResult::FatalError;\n    record->constantCount = checked_cast<size_t>(transfer->constantCount);\n    if (transfer->bufferCount > std::numeric_limits<size_t>::max()) return WireResult::FatalError;\n    record->bufferCount = checked_cast<size_t>(transfer->bufferCount);\n    {\n        uint64_t stringLength64 = transfer->entryPointStrlen;\n        if (stringLength64 >= std::numeric_limits<size_t>::max()) {\n            return WireResult::FatalError;\n        }\n        size_t stringLength = static_cast<size_t>(stringLength64);\n\n        const volatile char* stringInBuffer;\n        WIRE_TRY(deserializeBuffer->ReadN(stringLength, &stringInBuffer));\n\n        char* copiedString;\n        WIRE_TRY(GetSpace(allocator, stringLength + 1, &copiedString));\n        memcpy(copiedString, const_cast<const char*>(stringInBuffer), stringLength);\n        copiedString[stringLength] = '\\0';\n        record->entryPoint = copiedString;\n    }\n    {\n        auto memberLength = record->constantCount;\n        const volatile WGPUConstantEntryTransfer* memberBuffer;\n        WIRE_TRY(deserializeBuffer->ReadN(memberLength, &memberBuffer));\n\n        WGPUConstantEntry* copiedMembers;\n        WIRE_TRY(GetSpace(allocator, memberLength, &copiedMembers));\n        record->constants = copiedMembers;\n\n        for (decltype(memberLength) i = 0; i < memberLength; ++i) {\n            WIRE_TRY(WGPUConstantEntryDeserialize(&copiedMembers[i], &memberBuffer[i], deserializeBuffer, allocator, resolver));\n        }\n    }\n    {\n        auto memberLength = record->bufferCount;\n        const volatile WGPUVertexBufferLayoutTransfer* memberBuffer;\n        WIRE_TRY(deserializeBuffer->ReadN(memberLength, &memberBuffer));\n\n        WGPUVertexBufferLayout* copiedMembers;\n        WIRE_TRY(GetSpace(allocator, memberLength, &copiedMembers));\n        record->buffers = copiedMembers;\n\n        for (decltype(memberLength) i = 0; i < memberLength; ++i) {\n            WIRE_TRY(WGPUVertexBufferLayoutDeserialize(&copiedMembers[i], &memberBuffer[i], deserializeBuffer, allocator));\n        }\n    }\n\n    return WireResult::Success;\n}\nDAWN_UNUSED_FUNC(WGPUVertexStateDeserialize);\n\nstruct WGPUFragmentStateTransfer {\n    static_assert(0 <= 1,\n                  \"Record must be at most one of is_cmd, extensible, and chained.\");\n    bool hasNextInChain;\n\n    ObjectId module;\n    uint64_t entryPointStrlen;\n    uint64_t constantCount;\n    uint64_t targetCount;\n};\n\n\nDAWN_DECLARE_UNUSED size_t WGPUFragmentStateGetExtraRequiredSize(const WGPUFragmentState& record) {\n    DAWN_UNUSED(record);\n    size_t result = 0;\n\n    if (record.nextInChain != nullptr) {\n        result += GetChainedStructExtraRequiredSize(record.nextInChain);\n    }\n    ASSERT(record.entryPoint != nullptr);\n    result += Align(std::strlen(record.entryPoint), kWireBufferAlignment);\n    {\n        auto memberLength = record.constantCount;\n        auto size = WireAlignSizeofN<WGPUConstantEntryTransfer>(memberLength);\n        ASSERT(size);\n        result += *size;\n        for (decltype(memberLength) i = 0; i < memberLength; ++i) {\n            result += WGPUConstantEntryGetExtraRequiredSize(record.constants[i]);\n        }\n    }\n    {\n        auto memberLength = record.targetCount;\n        auto size = WireAlignSizeofN<WGPUColorTargetStateTransfer>(memberLength);\n        ASSERT(size);\n        result += *size;\n        for (decltype(memberLength) i = 0; i < memberLength; ++i) {\n            result += WGPUColorTargetStateGetExtraRequiredSize(record.targets[i]);\n        }\n    }\n    return result;\n}\n// GetExtraRequiredSize isn't used for structures that are value members of other structures\n// because we assume they cannot contain pointers themselves.\nDAWN_UNUSED_FUNC(WGPUFragmentStateGetExtraRequiredSize);\n\nDAWN_DECLARE_UNUSED WireResult WGPUFragmentStateSerialize(\n    const WGPUFragmentState& record,\n    WGPUFragmentStateTransfer* transfer,\n    SerializeBuffer* buffer, const ObjectIdProvider& provider) {\n    DAWN_UNUSED(buffer);\n\n    if (record.nextInChain != nullptr) {\n        transfer->hasNextInChain = true;\n        WIRE_TRY(SerializeChainedStruct(record.nextInChain, buffer, provider));\n    } else {\n        transfer->hasNextInChain = false;\n    }\n\n    WIRE_TRY(provider.GetId(record.module, &transfer->module));\n    transfer->constantCount = record.constantCount;\n    transfer->targetCount = record.targetCount;\n    {\n        transfer->entryPointStrlen = std::strlen(record.entryPoint);\n\n        char* stringInBuffer;\n        WIRE_TRY(buffer->NextN(transfer->entryPointStrlen, &stringInBuffer));\n        memcpy(stringInBuffer, record.entryPoint, transfer->entryPointStrlen);\n    }\n    {\n        auto memberLength = record.constantCount;\n\n        WGPUConstantEntryTransfer* memberBuffer;\n        WIRE_TRY(buffer->NextN(memberLength, &memberBuffer));\n\n        for (decltype(memberLength) i = 0; i < memberLength; ++i) {\n            WIRE_TRY(WGPUConstantEntrySerialize(record.constants[i], &memberBuffer[i], buffer, provider));\n        }\n    }\n    {\n        auto memberLength = record.targetCount;\n\n        WGPUColorTargetStateTransfer* memberBuffer;\n        WIRE_TRY(buffer->NextN(memberLength, &memberBuffer));\n\n        for (decltype(memberLength) i = 0; i < memberLength; ++i) {\n            WIRE_TRY(WGPUColorTargetStateSerialize(record.targets[i], &memberBuffer[i], buffer, provider));\n        }\n    }\n\n    return WireResult::Success;\n}\nDAWN_UNUSED_FUNC(WGPUFragmentStateSerialize);\n\nDAWN_DECLARE_UNUSED WireResult WGPUFragmentStateDeserialize(\n    WGPUFragmentState* record,\n    const volatile WGPUFragmentStateTransfer* transfer,\n    DeserializeBuffer* deserializeBuffer,\n    DeserializeAllocator* allocator, const ObjectIdResolver& resolver) {\n    DAWN_UNUSED(allocator);\n\n\n    record->nextInChain = nullptr;\n    if (transfer->hasNextInChain) {\n        WIRE_TRY(DeserializeChainedStruct(&record->nextInChain, deserializeBuffer, allocator, resolver));\n    }\n\n    WIRE_TRY(resolver.GetFromId(transfer->module, &record->module));\n    if (transfer->constantCount > std::numeric_limits<size_t>::max()) return WireResult::FatalError;\n    record->constantCount = checked_cast<size_t>(transfer->constantCount);\n    if (transfer->targetCount > std::numeric_limits<size_t>::max()) return WireResult::FatalError;\n    record->targetCount = checked_cast<size_t>(transfer->targetCount);\n    {\n        uint64_t stringLength64 = transfer->entryPointStrlen;\n        if (stringLength64 >= std::numeric_limits<size_t>::max()) {\n            return WireResult::FatalError;\n        }\n        size_t stringLength = static_cast<size_t>(stringLength64);\n\n        const volatile char* stringInBuffer;\n        WIRE_TRY(deserializeBuffer->ReadN(stringLength, &stringInBuffer));\n\n        char* copiedString;\n        WIRE_TRY(GetSpace(allocator, stringLength + 1, &copiedString));\n        memcpy(copiedString, const_cast<const char*>(stringInBuffer), stringLength);\n        copiedString[stringLength] = '\\0';\n        record->entryPoint = copiedString;\n    }\n    {\n        auto memberLength = record->constantCount;\n        const volatile WGPUConstantEntryTransfer* memberBuffer;\n        WIRE_TRY(deserializeBuffer->ReadN(memberLength, &memberBuffer));\n\n        WGPUConstantEntry* copiedMembers;\n        WIRE_TRY(GetSpace(allocator, memberLength, &copiedMembers));\n        record->constants = copiedMembers;\n\n        for (decltype(memberLength) i = 0; i < memberLength; ++i) {\n            WIRE_TRY(WGPUConstantEntryDeserialize(&copiedMembers[i], &memberBuffer[i], deserializeBuffer, allocator, resolver));\n        }\n    }\n    {\n        auto memberLength = record->targetCount;\n        const volatile WGPUColorTargetStateTransfer* memberBuffer;\n        WIRE_TRY(deserializeBuffer->ReadN(memberLength, &memberBuffer));\n\n        WGPUColorTargetState* copiedMembers;\n        WIRE_TRY(GetSpace(allocator, memberLength, &copiedMembers));\n        record->targets = copiedMembers;\n\n        for (decltype(memberLength) i = 0; i < memberLength; ++i) {\n            WIRE_TRY(WGPUColorTargetStateDeserialize(&copiedMembers[i], &memberBuffer[i], deserializeBuffer, allocator, resolver));\n        }\n    }\n\n    return WireResult::Success;\n}\nDAWN_UNUSED_FUNC(WGPUFragmentStateDeserialize);\n\nstruct WGPURenderPipelineDescriptorTransfer {\n    static_assert(0 <= 1,\n                  \"Record must be at most one of is_cmd, extensible, and chained.\");\n    bool hasNextInChain;\n\n    uint64_t labelStrlen;\n    bool has_label;\n    ObjectId layout;\n    WGPUVertexStateTransfer vertex;\n    WGPUPrimitiveStateTransfer primitive;\n    bool has_depthStencil;\n    WGPUMultisampleStateTransfer multisample;\n    bool has_fragment;\n};\n\n\nDAWN_DECLARE_UNUSED size_t WGPURenderPipelineDescriptorGetExtraRequiredSize(const WGPURenderPipelineDescriptor& record) {\n    DAWN_UNUSED(record);\n    size_t result = 0;\n\n    if (record.nextInChain != nullptr) {\n        result += GetChainedStructExtraRequiredSize(record.nextInChain);\n    }\n    if (record.label != nullptr) {\n        result += Align(std::strlen(record.label), kWireBufferAlignment);\n    }\n    {\n        result += WGPUVertexStateGetExtraRequiredSize(record.vertex);\n    }\n    {\n        result += WGPUPrimitiveStateGetExtraRequiredSize(record.primitive);\n    }\n    if (record.depthStencil != nullptr) {\n        auto memberLength = 1u;\n        auto size = WireAlignSizeofN<WGPUDepthStencilStateTransfer>(memberLength);\n        ASSERT(size);\n        result += *size;\n        for (decltype(memberLength) i = 0; i < memberLength; ++i) {\n            result += WGPUDepthStencilStateGetExtraRequiredSize(record.depthStencil[i]);\n        }\n    }\n    {\n        result += WGPUMultisampleStateGetExtraRequiredSize(record.multisample);\n    }\n    if (record.fragment != nullptr) {\n        auto memberLength = 1u;\n        auto size = WireAlignSizeofN<WGPUFragmentStateTransfer>(memberLength);\n        ASSERT(size);\n        result += *size;\n        for (decltype(memberLength) i = 0; i < memberLength; ++i) {\n            result += WGPUFragmentStateGetExtraRequiredSize(record.fragment[i]);\n        }\n    }\n    return result;\n}\n// GetExtraRequiredSize isn't used for structures that are value members of other structures\n// because we assume they cannot contain pointers themselves.\nDAWN_UNUSED_FUNC(WGPURenderPipelineDescriptorGetExtraRequiredSize);\n\nDAWN_DECLARE_UNUSED WireResult WGPURenderPipelineDescriptorSerialize(\n    const WGPURenderPipelineDescriptor& record,\n    WGPURenderPipelineDescriptorTransfer* transfer,\n    SerializeBuffer* buffer, const ObjectIdProvider& provider) {\n    DAWN_UNUSED(buffer);\n\n    if (record.nextInChain != nullptr) {\n        transfer->hasNextInChain = true;\n        WIRE_TRY(SerializeChainedStruct(record.nextInChain, buffer, provider));\n    } else {\n        transfer->hasNextInChain = false;\n    }\n\n    WIRE_TRY(provider.GetOptionalId(record.layout, &transfer->layout));\n    WIRE_TRY(WGPUVertexStateSerialize(record.vertex, &transfer->vertex, buffer, provider));\n    WIRE_TRY(WGPUPrimitiveStateSerialize(record.primitive, &transfer->primitive, buffer, provider));\n    WIRE_TRY(WGPUMultisampleStateSerialize(record.multisample, &transfer->multisample, buffer, provider));\n    bool has_label = record.label != nullptr;\n    transfer->has_label = has_label;\n    if (has_label) {\n        transfer->labelStrlen = std::strlen(record.label);\n\n        char* stringInBuffer;\n        WIRE_TRY(buffer->NextN(transfer->labelStrlen, &stringInBuffer));\n        memcpy(stringInBuffer, record.label, transfer->labelStrlen);\n    }\n    bool has_depthStencil = record.depthStencil != nullptr;\n    transfer->has_depthStencil = has_depthStencil;\n    if (has_depthStencil) {\n        auto memberLength = 1u;\n\n        WGPUDepthStencilStateTransfer* memberBuffer;\n        WIRE_TRY(buffer->NextN(memberLength, &memberBuffer));\n\n        for (decltype(memberLength) i = 0; i < memberLength; ++i) {\n            WIRE_TRY(WGPUDepthStencilStateSerialize(record.depthStencil[i], &memberBuffer[i], buffer, provider));\n        }\n    }\n    bool has_fragment = record.fragment != nullptr;\n    transfer->has_fragment = has_fragment;\n    if (has_fragment) {\n        auto memberLength = 1u;\n\n        WGPUFragmentStateTransfer* memberBuffer;\n        WIRE_TRY(buffer->NextN(memberLength, &memberBuffer));\n\n        for (decltype(memberLength) i = 0; i < memberLength; ++i) {\n            WIRE_TRY(WGPUFragmentStateSerialize(record.fragment[i], &memberBuffer[i], buffer, provider));\n        }\n    }\n\n    return WireResult::Success;\n}\nDAWN_UNUSED_FUNC(WGPURenderPipelineDescriptorSerialize);\n\nDAWN_DECLARE_UNUSED WireResult WGPURenderPipelineDescriptorDeserialize(\n    WGPURenderPipelineDescriptor* record,\n    const volatile WGPURenderPipelineDescriptorTransfer* transfer,\n    DeserializeBuffer* deserializeBuffer,\n    DeserializeAllocator* allocator, const ObjectIdResolver& resolver) {\n    DAWN_UNUSED(allocator);\n\n\n    record->nextInChain = nullptr;\n    if (transfer->hasNextInChain) {\n        WIRE_TRY(DeserializeChainedStruct(&record->nextInChain, deserializeBuffer, allocator, resolver));\n    }\n\n    WIRE_TRY(resolver.GetOptionalFromId(transfer->layout, &record->layout));\n    WIRE_TRY(WGPUVertexStateDeserialize(&record->vertex, &transfer->vertex, deserializeBuffer, allocator, resolver));\n    WIRE_TRY(WGPUPrimitiveStateDeserialize(&record->primitive, &transfer->primitive, deserializeBuffer, allocator, resolver));\n    WIRE_TRY(WGPUMultisampleStateDeserialize(&record->multisample, &transfer->multisample, deserializeBuffer, allocator, resolver));\n    bool has_label = transfer->has_label;\n    record->label = nullptr;\n    if (has_label) {\n        uint64_t stringLength64 = transfer->labelStrlen;\n        if (stringLength64 >= std::numeric_limits<size_t>::max()) {\n            return WireResult::FatalError;\n        }\n        size_t stringLength = static_cast<size_t>(stringLength64);\n\n        const volatile char* stringInBuffer;\n        WIRE_TRY(deserializeBuffer->ReadN(stringLength, &stringInBuffer));\n\n        char* copiedString;\n        WIRE_TRY(GetSpace(allocator, stringLength + 1, &copiedString));\n        memcpy(copiedString, const_cast<const char*>(stringInBuffer), stringLength);\n        copiedString[stringLength] = '\\0';\n        record->label = copiedString;\n    }\n    bool has_depthStencil = transfer->has_depthStencil;\n    record->depthStencil = nullptr;\n    if (has_depthStencil) {\n        auto memberLength = 1u;\n        const volatile WGPUDepthStencilStateTransfer* memberBuffer;\n        WIRE_TRY(deserializeBuffer->ReadN(memberLength, &memberBuffer));\n\n        WGPUDepthStencilState* copiedMembers;\n        WIRE_TRY(GetSpace(allocator, memberLength, &copiedMembers));\n        record->depthStencil = copiedMembers;\n\n        for (decltype(memberLength) i = 0; i < memberLength; ++i) {\n            WIRE_TRY(WGPUDepthStencilStateDeserialize(&copiedMembers[i], &memberBuffer[i], deserializeBuffer, allocator, resolver));\n        }\n    }\n    bool has_fragment = transfer->has_fragment;\n    record->fragment = nullptr;\n    if (has_fragment) {\n        auto memberLength = 1u;\n        const volatile WGPUFragmentStateTransfer* memberBuffer;\n        WIRE_TRY(deserializeBuffer->ReadN(memberLength, &memberBuffer));\n\n        WGPUFragmentState* copiedMembers;\n        WIRE_TRY(GetSpace(allocator, memberLength, &copiedMembers));\n        record->fragment = copiedMembers;\n\n        for (decltype(memberLength) i = 0; i < memberLength; ++i) {\n            WIRE_TRY(WGPUFragmentStateDeserialize(&copiedMembers[i], &memberBuffer[i], deserializeBuffer, allocator, resolver));\n        }\n    }\n\n    return WireResult::Success;\n}\nDAWN_UNUSED_FUNC(WGPURenderPipelineDescriptorDeserialize);\n\n\nsize_t GetChainedStructExtraRequiredSize(const WGPUChainedStruct* chainedStruct) {\n    ASSERT(chainedStruct != nullptr);\n    size_t result = 0;\n    while (chainedStruct != nullptr) {\n        switch (chainedStruct->sType) {\n            case WGPUSType_SurfaceDescriptorFromCanvasHTMLSelector: {\n                const auto& typedStruct = *reinterpret_cast<WGPUSurfaceDescriptorFromCanvasHTMLSelector const *>(chainedStruct);\n                result += WireAlignSizeof<WGPUSurfaceDescriptorFromCanvasHTMLSelectorTransfer>();\n                result += WGPUSurfaceDescriptorFromCanvasHTMLSelectorGetExtraRequiredSize(typedStruct);\n                chainedStruct = typedStruct.chain.next;\n                break;\n            }\n            case WGPUSType_ShaderModuleSPIRVDescriptor: {\n                const auto& typedStruct = *reinterpret_cast<WGPUShaderModuleSPIRVDescriptor const *>(chainedStruct);\n                result += WireAlignSizeof<WGPUShaderModuleSPIRVDescriptorTransfer>();\n                result += WGPUShaderModuleSPIRVDescriptorGetExtraRequiredSize(typedStruct);\n                chainedStruct = typedStruct.chain.next;\n                break;\n            }\n            case WGPUSType_ShaderModuleWGSLDescriptor: {\n                const auto& typedStruct = *reinterpret_cast<WGPUShaderModuleWGSLDescriptor const *>(chainedStruct);\n                result += WireAlignSizeof<WGPUShaderModuleWGSLDescriptorTransfer>();\n                result += WGPUShaderModuleWGSLDescriptorGetExtraRequiredSize(typedStruct);\n                chainedStruct = typedStruct.chain.next;\n                break;\n            }\n            case WGPUSType_PrimitiveDepthClipControl: {\n                const auto& typedStruct = *reinterpret_cast<WGPUPrimitiveDepthClipControl const *>(chainedStruct);\n                result += WireAlignSizeof<WGPUPrimitiveDepthClipControlTransfer>();\n                result += WGPUPrimitiveDepthClipControlGetExtraRequiredSize(typedStruct);\n                chainedStruct = typedStruct.chain.next;\n                break;\n            }\n            case WGPUSType_ExternalTextureBindingEntry: {\n                const auto& typedStruct = *reinterpret_cast<WGPUExternalTextureBindingEntry const *>(chainedStruct);\n                result += WireAlignSizeof<WGPUExternalTextureBindingEntryTransfer>();\n                result += WGPUExternalTextureBindingEntryGetExtraRequiredSize(typedStruct);\n                chainedStruct = typedStruct.chain.next;\n                break;\n            }\n            case WGPUSType_ExternalTextureBindingLayout: {\n                const auto& typedStruct = *reinterpret_cast<WGPUExternalTextureBindingLayout const *>(chainedStruct);\n                result += WireAlignSizeof<WGPUExternalTextureBindingLayoutTransfer>();\n                result += WGPUExternalTextureBindingLayoutGetExtraRequiredSize(typedStruct);\n                chainedStruct = typedStruct.chain.next;\n                break;\n            }\n            case WGPUSType_RenderPassDescriptorMaxDrawCount: {\n                const auto& typedStruct = *reinterpret_cast<WGPURenderPassDescriptorMaxDrawCount const *>(chainedStruct);\n                result += WireAlignSizeof<WGPURenderPassDescriptorMaxDrawCountTransfer>();\n                result += WGPURenderPassDescriptorMaxDrawCountGetExtraRequiredSize(typedStruct);\n                chainedStruct = typedStruct.chain.next;\n                break;\n            }\n            case WGPUSType_DawnTextureInternalUsageDescriptor: {\n                const auto& typedStruct = *reinterpret_cast<WGPUDawnTextureInternalUsageDescriptor const *>(chainedStruct);\n                result += WireAlignSizeof<WGPUDawnTextureInternalUsageDescriptorTransfer>();\n                result += WGPUDawnTextureInternalUsageDescriptorGetExtraRequiredSize(typedStruct);\n                chainedStruct = typedStruct.chain.next;\n                break;\n            }\n            case WGPUSType_DawnEncoderInternalUsageDescriptor: {\n                const auto& typedStruct = *reinterpret_cast<WGPUDawnEncoderInternalUsageDescriptor const *>(chainedStruct);\n                result += WireAlignSizeof<WGPUDawnEncoderInternalUsageDescriptorTransfer>();\n                result += WGPUDawnEncoderInternalUsageDescriptorGetExtraRequiredSize(typedStruct);\n                chainedStruct = typedStruct.chain.next;\n                break;\n            }\n            case WGPUSType_DawnBufferDescriptorErrorInfoFromWireClient: {\n                const auto& typedStruct = *reinterpret_cast<WGPUDawnBufferDescriptorErrorInfoFromWireClient const *>(chainedStruct);\n                result += WireAlignSizeof<WGPUDawnBufferDescriptorErrorInfoFromWireClientTransfer>();\n                result += WGPUDawnBufferDescriptorErrorInfoFromWireClientGetExtraRequiredSize(typedStruct);\n                chainedStruct = typedStruct.chain.next;\n                break;\n            }\n            case WGPUSType_DawnShaderModuleSPIRVOptionsDescriptor: {\n                const auto& typedStruct = *reinterpret_cast<WGPUDawnShaderModuleSPIRVOptionsDescriptor const *>(chainedStruct);\n                result += WireAlignSizeof<WGPUDawnShaderModuleSPIRVOptionsDescriptorTransfer>();\n                result += WGPUDawnShaderModuleSPIRVOptionsDescriptorGetExtraRequiredSize(typedStruct);\n                chainedStruct = typedStruct.chain.next;\n                break;\n            }\n            case WGPUSType_DawnMultisampleStateRenderToSingleSampled: {\n                const auto& typedStruct = *reinterpret_cast<WGPUDawnMultisampleStateRenderToSingleSampled const *>(chainedStruct);\n                result += WireAlignSizeof<WGPUDawnMultisampleStateRenderToSingleSampledTransfer>();\n                result += WGPUDawnMultisampleStateRenderToSingleSampledGetExtraRequiredSize(typedStruct);\n                chainedStruct = typedStruct.chain.next;\n                break;\n            }\n            case WGPUSType_DawnRenderPassColorAttachmentRenderToSingleSampled: {\n                const auto& typedStruct = *reinterpret_cast<WGPUDawnRenderPassColorAttachmentRenderToSingleSampled const *>(chainedStruct);\n                result += WireAlignSizeof<WGPUDawnRenderPassColorAttachmentRenderToSingleSampledTransfer>();\n                result += WGPUDawnRenderPassColorAttachmentRenderToSingleSampledGetExtraRequiredSize(typedStruct);\n                chainedStruct = typedStruct.chain.next;\n                break;\n            }\n            // Explicitly list the Invalid enum. MSVC complains about no case labels.\n            case WGPUSType_Invalid:\n            default:\n                // Invalid enum. Reserve space just for the transfer header (sType and hasNext).\n                result += WireAlignSizeof<WGPUChainedStructTransfer>();\n                chainedStruct = chainedStruct->next;\n                break;\n        }\n    }\n    return result;\n}\n\n[[nodiscard]] WireResult SerializeChainedStruct(const WGPUChainedStruct* chainedStruct,\n                                                SerializeBuffer* buffer,\n                                                const ObjectIdProvider& provider) {\n    ASSERT(chainedStruct != nullptr);\n    ASSERT(buffer != nullptr);\n    do {\n        switch (chainedStruct->sType) {\n            case WGPUSType_SurfaceDescriptorFromCanvasHTMLSelector: {\n                WGPUSurfaceDescriptorFromCanvasHTMLSelectorTransfer* transfer;\n                WIRE_TRY(buffer->Next(&transfer));\n                transfer->chain.sType = chainedStruct->sType;\n                transfer->chain.hasNext = chainedStruct->next != nullptr;\n\n                WIRE_TRY(WGPUSurfaceDescriptorFromCanvasHTMLSelectorSerialize(*reinterpret_cast<WGPUSurfaceDescriptorFromCanvasHTMLSelector const*>(chainedStruct), transfer, buffer, provider));\n\n                chainedStruct = chainedStruct->next;\n            } break;\n            case WGPUSType_ShaderModuleSPIRVDescriptor: {\n                WGPUShaderModuleSPIRVDescriptorTransfer* transfer;\n                WIRE_TRY(buffer->Next(&transfer));\n                transfer->chain.sType = chainedStruct->sType;\n                transfer->chain.hasNext = chainedStruct->next != nullptr;\n\n                WIRE_TRY(WGPUShaderModuleSPIRVDescriptorSerialize(*reinterpret_cast<WGPUShaderModuleSPIRVDescriptor const*>(chainedStruct), transfer, buffer, provider));\n\n                chainedStruct = chainedStruct->next;\n            } break;\n            case WGPUSType_ShaderModuleWGSLDescriptor: {\n                WGPUShaderModuleWGSLDescriptorTransfer* transfer;\n                WIRE_TRY(buffer->Next(&transfer));\n                transfer->chain.sType = chainedStruct->sType;\n                transfer->chain.hasNext = chainedStruct->next != nullptr;\n\n                WIRE_TRY(WGPUShaderModuleWGSLDescriptorSerialize(*reinterpret_cast<WGPUShaderModuleWGSLDescriptor const*>(chainedStruct), transfer, buffer, provider));\n\n                chainedStruct = chainedStruct->next;\n            } break;\n            case WGPUSType_PrimitiveDepthClipControl: {\n                WGPUPrimitiveDepthClipControlTransfer* transfer;\n                WIRE_TRY(buffer->Next(&transfer));\n                transfer->chain.sType = chainedStruct->sType;\n                transfer->chain.hasNext = chainedStruct->next != nullptr;\n\n                WIRE_TRY(WGPUPrimitiveDepthClipControlSerialize(*reinterpret_cast<WGPUPrimitiveDepthClipControl const*>(chainedStruct), transfer, buffer, provider));\n\n                chainedStruct = chainedStruct->next;\n            } break;\n            case WGPUSType_ExternalTextureBindingEntry: {\n                WGPUExternalTextureBindingEntryTransfer* transfer;\n                WIRE_TRY(buffer->Next(&transfer));\n                transfer->chain.sType = chainedStruct->sType;\n                transfer->chain.hasNext = chainedStruct->next != nullptr;\n\n                WIRE_TRY(WGPUExternalTextureBindingEntrySerialize(*reinterpret_cast<WGPUExternalTextureBindingEntry const*>(chainedStruct), transfer, buffer, provider));\n\n                chainedStruct = chainedStruct->next;\n            } break;\n            case WGPUSType_ExternalTextureBindingLayout: {\n                WGPUExternalTextureBindingLayoutTransfer* transfer;\n                WIRE_TRY(buffer->Next(&transfer));\n                transfer->chain.sType = chainedStruct->sType;\n                transfer->chain.hasNext = chainedStruct->next != nullptr;\n\n                WIRE_TRY(WGPUExternalTextureBindingLayoutSerialize(*reinterpret_cast<WGPUExternalTextureBindingLayout const*>(chainedStruct), transfer, buffer, provider));\n\n                chainedStruct = chainedStruct->next;\n            } break;\n            case WGPUSType_RenderPassDescriptorMaxDrawCount: {\n                WGPURenderPassDescriptorMaxDrawCountTransfer* transfer;\n                WIRE_TRY(buffer->Next(&transfer));\n                transfer->chain.sType = chainedStruct->sType;\n                transfer->chain.hasNext = chainedStruct->next != nullptr;\n\n                WIRE_TRY(WGPURenderPassDescriptorMaxDrawCountSerialize(*reinterpret_cast<WGPURenderPassDescriptorMaxDrawCount const*>(chainedStruct), transfer, buffer, provider));\n\n                chainedStruct = chainedStruct->next;\n            } break;\n            case WGPUSType_DawnTextureInternalUsageDescriptor: {\n                WGPUDawnTextureInternalUsageDescriptorTransfer* transfer;\n                WIRE_TRY(buffer->Next(&transfer));\n                transfer->chain.sType = chainedStruct->sType;\n                transfer->chain.hasNext = chainedStruct->next != nullptr;\n\n                WIRE_TRY(WGPUDawnTextureInternalUsageDescriptorSerialize(*reinterpret_cast<WGPUDawnTextureInternalUsageDescriptor const*>(chainedStruct), transfer, buffer, provider));\n\n                chainedStruct = chainedStruct->next;\n            } break;\n            case WGPUSType_DawnEncoderInternalUsageDescriptor: {\n                WGPUDawnEncoderInternalUsageDescriptorTransfer* transfer;\n                WIRE_TRY(buffer->Next(&transfer));\n                transfer->chain.sType = chainedStruct->sType;\n                transfer->chain.hasNext = chainedStruct->next != nullptr;\n\n                WIRE_TRY(WGPUDawnEncoderInternalUsageDescriptorSerialize(*reinterpret_cast<WGPUDawnEncoderInternalUsageDescriptor const*>(chainedStruct), transfer, buffer, provider));\n\n                chainedStruct = chainedStruct->next;\n            } break;\n            case WGPUSType_DawnBufferDescriptorErrorInfoFromWireClient: {\n                WGPUDawnBufferDescriptorErrorInfoFromWireClientTransfer* transfer;\n                WIRE_TRY(buffer->Next(&transfer));\n                transfer->chain.sType = chainedStruct->sType;\n                transfer->chain.hasNext = chainedStruct->next != nullptr;\n\n                WIRE_TRY(WGPUDawnBufferDescriptorErrorInfoFromWireClientSerialize(*reinterpret_cast<WGPUDawnBufferDescriptorErrorInfoFromWireClient const*>(chainedStruct), transfer, buffer, provider));\n\n                chainedStruct = chainedStruct->next;\n            } break;\n            case WGPUSType_DawnShaderModuleSPIRVOptionsDescriptor: {\n                WGPUDawnShaderModuleSPIRVOptionsDescriptorTransfer* transfer;\n                WIRE_TRY(buffer->Next(&transfer));\n                transfer->chain.sType = chainedStruct->sType;\n                transfer->chain.hasNext = chainedStruct->next != nullptr;\n\n                WIRE_TRY(WGPUDawnShaderModuleSPIRVOptionsDescriptorSerialize(*reinterpret_cast<WGPUDawnShaderModuleSPIRVOptionsDescriptor const*>(chainedStruct), transfer, buffer, provider));\n\n                chainedStruct = chainedStruct->next;\n            } break;\n            case WGPUSType_DawnMultisampleStateRenderToSingleSampled: {\n                WGPUDawnMultisampleStateRenderToSingleSampledTransfer* transfer;\n                WIRE_TRY(buffer->Next(&transfer));\n                transfer->chain.sType = chainedStruct->sType;\n                transfer->chain.hasNext = chainedStruct->next != nullptr;\n\n                WIRE_TRY(WGPUDawnMultisampleStateRenderToSingleSampledSerialize(*reinterpret_cast<WGPUDawnMultisampleStateRenderToSingleSampled const*>(chainedStruct), transfer, buffer, provider));\n\n                chainedStruct = chainedStruct->next;\n            } break;\n            case WGPUSType_DawnRenderPassColorAttachmentRenderToSingleSampled: {\n                WGPUDawnRenderPassColorAttachmentRenderToSingleSampledTransfer* transfer;\n                WIRE_TRY(buffer->Next(&transfer));\n                transfer->chain.sType = chainedStruct->sType;\n                transfer->chain.hasNext = chainedStruct->next != nullptr;\n\n                WIRE_TRY(WGPUDawnRenderPassColorAttachmentRenderToSingleSampledSerialize(*reinterpret_cast<WGPUDawnRenderPassColorAttachmentRenderToSingleSampled const*>(chainedStruct), transfer, buffer, provider));\n\n                chainedStruct = chainedStruct->next;\n            } break;\n            // Explicitly list the Invalid enum. MSVC complains about no case labels.\n            case WGPUSType_Invalid:\n            default: {\n                // Invalid enum. Serialize just the transfer header with Invalid as the sType.\n                // TODO(crbug.com/dawn/369): Unknown sTypes are silently discarded.\n                if (chainedStruct->sType != WGPUSType_Invalid) {\n                    dawn::WarningLog() << \"Unknown sType \" << chainedStruct->sType << \" discarded.\";\n                }\n\n                WGPUChainedStructTransfer* transfer;\n                WIRE_TRY(buffer->Next(&transfer));\n                transfer->sType = WGPUSType_Invalid;\n                transfer->hasNext = chainedStruct->next != nullptr;\n\n                // Still move on in case there are valid structs after this.\n                chainedStruct = chainedStruct->next;\n                break;\n            }\n        }\n    } while (chainedStruct != nullptr);\n    return WireResult::Success;\n}\n\nWireResult DeserializeChainedStruct(const WGPUChainedStruct** outChainNext,\n                                    DeserializeBuffer* deserializeBuffer,\n                                    DeserializeAllocator* allocator,\n                                    const ObjectIdResolver& resolver) {\n    bool hasNext;\n    do {\n        const volatile WGPUChainedStructTransfer* header;\n        WIRE_TRY(deserializeBuffer->Peek(&header));\n        WGPUSType sType = header->sType;\n        switch (sType) {\n            case WGPUSType_SurfaceDescriptorFromCanvasHTMLSelector: {\n                const volatile WGPUSurfaceDescriptorFromCanvasHTMLSelectorTransfer* transfer;\n                WIRE_TRY(deserializeBuffer->Read(&transfer));\n\n                WGPUSurfaceDescriptorFromCanvasHTMLSelector* outStruct;\n                WIRE_TRY(GetSpace(allocator, 1u, &outStruct));\n                outStruct->chain.sType = sType;\n                outStruct->chain.next = nullptr;\n\n                *outChainNext = &outStruct->chain;\n                outChainNext = &outStruct->chain.next;\n\n                WIRE_TRY(WGPUSurfaceDescriptorFromCanvasHTMLSelectorDeserialize(outStruct, transfer, deserializeBuffer, allocator, resolver));\n\n                hasNext = transfer->chain.hasNext;\n            } break;\n            case WGPUSType_ShaderModuleSPIRVDescriptor: {\n                const volatile WGPUShaderModuleSPIRVDescriptorTransfer* transfer;\n                WIRE_TRY(deserializeBuffer->Read(&transfer));\n\n                WGPUShaderModuleSPIRVDescriptor* outStruct;\n                WIRE_TRY(GetSpace(allocator, 1u, &outStruct));\n                outStruct->chain.sType = sType;\n                outStruct->chain.next = nullptr;\n\n                *outChainNext = &outStruct->chain;\n                outChainNext = &outStruct->chain.next;\n\n                WIRE_TRY(WGPUShaderModuleSPIRVDescriptorDeserialize(outStruct, transfer, deserializeBuffer, allocator, resolver));\n\n                hasNext = transfer->chain.hasNext;\n            } break;\n            case WGPUSType_ShaderModuleWGSLDescriptor: {\n                const volatile WGPUShaderModuleWGSLDescriptorTransfer* transfer;\n                WIRE_TRY(deserializeBuffer->Read(&transfer));\n\n                WGPUShaderModuleWGSLDescriptor* outStruct;\n                WIRE_TRY(GetSpace(allocator, 1u, &outStruct));\n                outStruct->chain.sType = sType;\n                outStruct->chain.next = nullptr;\n\n                *outChainNext = &outStruct->chain;\n                outChainNext = &outStruct->chain.next;\n\n                WIRE_TRY(WGPUShaderModuleWGSLDescriptorDeserialize(outStruct, transfer, deserializeBuffer, allocator, resolver));\n\n                hasNext = transfer->chain.hasNext;\n            } break;\n            case WGPUSType_PrimitiveDepthClipControl: {\n                const volatile WGPUPrimitiveDepthClipControlTransfer* transfer;\n                WIRE_TRY(deserializeBuffer->Read(&transfer));\n\n                WGPUPrimitiveDepthClipControl* outStruct;\n                WIRE_TRY(GetSpace(allocator, 1u, &outStruct));\n                outStruct->chain.sType = sType;\n                outStruct->chain.next = nullptr;\n\n                *outChainNext = &outStruct->chain;\n                outChainNext = &outStruct->chain.next;\n\n                WIRE_TRY(WGPUPrimitiveDepthClipControlDeserialize(outStruct, transfer, deserializeBuffer, allocator, resolver));\n\n                hasNext = transfer->chain.hasNext;\n            } break;\n            case WGPUSType_ExternalTextureBindingEntry: {\n                const volatile WGPUExternalTextureBindingEntryTransfer* transfer;\n                WIRE_TRY(deserializeBuffer->Read(&transfer));\n\n                WGPUExternalTextureBindingEntry* outStruct;\n                WIRE_TRY(GetSpace(allocator, 1u, &outStruct));\n                outStruct->chain.sType = sType;\n                outStruct->chain.next = nullptr;\n\n                *outChainNext = &outStruct->chain;\n                outChainNext = &outStruct->chain.next;\n\n                WIRE_TRY(WGPUExternalTextureBindingEntryDeserialize(outStruct, transfer, deserializeBuffer, allocator, resolver));\n\n                hasNext = transfer->chain.hasNext;\n            } break;\n            case WGPUSType_ExternalTextureBindingLayout: {\n                const volatile WGPUExternalTextureBindingLayoutTransfer* transfer;\n                WIRE_TRY(deserializeBuffer->Read(&transfer));\n\n                WGPUExternalTextureBindingLayout* outStruct;\n                WIRE_TRY(GetSpace(allocator, 1u, &outStruct));\n                outStruct->chain.sType = sType;\n                outStruct->chain.next = nullptr;\n\n                *outChainNext = &outStruct->chain;\n                outChainNext = &outStruct->chain.next;\n\n                WIRE_TRY(WGPUExternalTextureBindingLayoutDeserialize(outStruct, transfer, deserializeBuffer, allocator, resolver));\n\n                hasNext = transfer->chain.hasNext;\n            } break;\n            case WGPUSType_RenderPassDescriptorMaxDrawCount: {\n                const volatile WGPURenderPassDescriptorMaxDrawCountTransfer* transfer;\n                WIRE_TRY(deserializeBuffer->Read(&transfer));\n\n                WGPURenderPassDescriptorMaxDrawCount* outStruct;\n                WIRE_TRY(GetSpace(allocator, 1u, &outStruct));\n                outStruct->chain.sType = sType;\n                outStruct->chain.next = nullptr;\n\n                *outChainNext = &outStruct->chain;\n                outChainNext = &outStruct->chain.next;\n\n                WIRE_TRY(WGPURenderPassDescriptorMaxDrawCountDeserialize(outStruct, transfer, deserializeBuffer, allocator, resolver));\n\n                hasNext = transfer->chain.hasNext;\n            } break;\n            case WGPUSType_DawnTextureInternalUsageDescriptor: {\n                const volatile WGPUDawnTextureInternalUsageDescriptorTransfer* transfer;\n                WIRE_TRY(deserializeBuffer->Read(&transfer));\n\n                WGPUDawnTextureInternalUsageDescriptor* outStruct;\n                WIRE_TRY(GetSpace(allocator, 1u, &outStruct));\n                outStruct->chain.sType = sType;\n                outStruct->chain.next = nullptr;\n\n                *outChainNext = &outStruct->chain;\n                outChainNext = &outStruct->chain.next;\n\n                WIRE_TRY(WGPUDawnTextureInternalUsageDescriptorDeserialize(outStruct, transfer, deserializeBuffer, allocator, resolver));\n\n                hasNext = transfer->chain.hasNext;\n            } break;\n            case WGPUSType_DawnEncoderInternalUsageDescriptor: {\n                const volatile WGPUDawnEncoderInternalUsageDescriptorTransfer* transfer;\n                WIRE_TRY(deserializeBuffer->Read(&transfer));\n\n                WGPUDawnEncoderInternalUsageDescriptor* outStruct;\n                WIRE_TRY(GetSpace(allocator, 1u, &outStruct));\n                outStruct->chain.sType = sType;\n                outStruct->chain.next = nullptr;\n\n                *outChainNext = &outStruct->chain;\n                outChainNext = &outStruct->chain.next;\n\n                WIRE_TRY(WGPUDawnEncoderInternalUsageDescriptorDeserialize(outStruct, transfer, deserializeBuffer, allocator, resolver));\n\n                hasNext = transfer->chain.hasNext;\n            } break;\n            case WGPUSType_DawnBufferDescriptorErrorInfoFromWireClient: {\n                const volatile WGPUDawnBufferDescriptorErrorInfoFromWireClientTransfer* transfer;\n                WIRE_TRY(deserializeBuffer->Read(&transfer));\n\n                WGPUDawnBufferDescriptorErrorInfoFromWireClient* outStruct;\n                WIRE_TRY(GetSpace(allocator, 1u, &outStruct));\n                outStruct->chain.sType = sType;\n                outStruct->chain.next = nullptr;\n\n                *outChainNext = &outStruct->chain;\n                outChainNext = &outStruct->chain.next;\n\n                WIRE_TRY(WGPUDawnBufferDescriptorErrorInfoFromWireClientDeserialize(outStruct, transfer, deserializeBuffer, allocator, resolver));\n\n                hasNext = transfer->chain.hasNext;\n            } break;\n            case WGPUSType_DawnShaderModuleSPIRVOptionsDescriptor: {\n                const volatile WGPUDawnShaderModuleSPIRVOptionsDescriptorTransfer* transfer;\n                WIRE_TRY(deserializeBuffer->Read(&transfer));\n\n                WGPUDawnShaderModuleSPIRVOptionsDescriptor* outStruct;\n                WIRE_TRY(GetSpace(allocator, 1u, &outStruct));\n                outStruct->chain.sType = sType;\n                outStruct->chain.next = nullptr;\n\n                *outChainNext = &outStruct->chain;\n                outChainNext = &outStruct->chain.next;\n\n                WIRE_TRY(WGPUDawnShaderModuleSPIRVOptionsDescriptorDeserialize(outStruct, transfer, deserializeBuffer, allocator, resolver));\n\n                hasNext = transfer->chain.hasNext;\n            } break;\n            case WGPUSType_DawnMultisampleStateRenderToSingleSampled: {\n                const volatile WGPUDawnMultisampleStateRenderToSingleSampledTransfer* transfer;\n                WIRE_TRY(deserializeBuffer->Read(&transfer));\n\n                WGPUDawnMultisampleStateRenderToSingleSampled* outStruct;\n                WIRE_TRY(GetSpace(allocator, 1u, &outStruct));\n                outStruct->chain.sType = sType;\n                outStruct->chain.next = nullptr;\n\n                *outChainNext = &outStruct->chain;\n                outChainNext = &outStruct->chain.next;\n\n                WIRE_TRY(WGPUDawnMultisampleStateRenderToSingleSampledDeserialize(outStruct, transfer, deserializeBuffer, allocator, resolver));\n\n                hasNext = transfer->chain.hasNext;\n            } break;\n            case WGPUSType_DawnRenderPassColorAttachmentRenderToSingleSampled: {\n                const volatile WGPUDawnRenderPassColorAttachmentRenderToSingleSampledTransfer* transfer;\n                WIRE_TRY(deserializeBuffer->Read(&transfer));\n\n                WGPUDawnRenderPassColorAttachmentRenderToSingleSampled* outStruct;\n                WIRE_TRY(GetSpace(allocator, 1u, &outStruct));\n                outStruct->chain.sType = sType;\n                outStruct->chain.next = nullptr;\n\n                *outChainNext = &outStruct->chain;\n                outChainNext = &outStruct->chain.next;\n\n                WIRE_TRY(WGPUDawnRenderPassColorAttachmentRenderToSingleSampledDeserialize(outStruct, transfer, deserializeBuffer, allocator, resolver));\n\n                hasNext = transfer->chain.hasNext;\n            } break;\n            // Explicitly list the Invalid enum. MSVC complains about no case labels.\n            case WGPUSType_Invalid:\n            default: {\n                // Invalid enum. Deserialize just the transfer header with Invalid as the sType.\n                // TODO(crbug.com/dawn/369): Unknown sTypes are silently discarded.\n                if (sType != WGPUSType_Invalid) {\n                    dawn::WarningLog() << \"Unknown sType \" << sType << \" discarded.\";\n                }\n\n                const volatile WGPUChainedStructTransfer* transfer;\n                WIRE_TRY(deserializeBuffer->Read(&transfer));\n\n                WGPUChainedStruct* outStruct;\n                WIRE_TRY(GetSpace(allocator, 1u, &outStruct));\n                outStruct->sType = WGPUSType_Invalid;\n                outStruct->next = nullptr;\n\n                // Still move on in case there are valid structs after this.\n                *outChainNext = outStruct;\n                outChainNext = &outStruct->next;\n                hasNext = transfer->hasNext;\n                break;\n            }\n        }\n    } while (hasNext);\n    return WireResult::Success;\n}\n\n\nsize_t GetChainedStructExtraRequiredSize(WGPUChainedStructOut* chainedStruct) {\n    ASSERT(chainedStruct != nullptr);\n    size_t result = 0;\n    while (chainedStruct != nullptr) {\n        switch (chainedStruct->sType) {\n            // Explicitly list the Invalid enum. MSVC complains about no case labels.\n            case WGPUSType_Invalid:\n            default:\n                // Invalid enum. Reserve space just for the transfer header (sType and hasNext).\n                result += WireAlignSizeof<WGPUChainedStructTransfer>();\n                chainedStruct = chainedStruct->next;\n                break;\n        }\n    }\n    return result;\n}\n\n[[nodiscard]] WireResult SerializeChainedStruct(WGPUChainedStructOut* chainedStruct,\n                                                SerializeBuffer* buffer,\n                                                const ObjectIdProvider& provider) {\n    ASSERT(chainedStruct != nullptr);\n    ASSERT(buffer != nullptr);\n    do {\n        switch (chainedStruct->sType) {\n            // Explicitly list the Invalid enum. MSVC complains about no case labels.\n            case WGPUSType_Invalid:\n            default: {\n                // Invalid enum. Serialize just the transfer header with Invalid as the sType.\n                // TODO(crbug.com/dawn/369): Unknown sTypes are silently discarded.\n                if (chainedStruct->sType != WGPUSType_Invalid) {\n                    dawn::WarningLog() << \"Unknown sType \" << chainedStruct->sType << \" discarded.\";\n                }\n\n                WGPUChainedStructTransfer* transfer;\n                WIRE_TRY(buffer->Next(&transfer));\n                transfer->sType = WGPUSType_Invalid;\n                transfer->hasNext = chainedStruct->next != nullptr;\n\n                // Still move on in case there are valid structs after this.\n                chainedStruct = chainedStruct->next;\n                break;\n            }\n        }\n    } while (chainedStruct != nullptr);\n    return WireResult::Success;\n}\n\nWireResult DeserializeChainedStruct(WGPUChainedStructOut** outChainNext,\n                                    DeserializeBuffer* deserializeBuffer,\n                                    DeserializeAllocator* allocator,\n                                    const ObjectIdResolver& resolver) {\n    bool hasNext;\n    do {\n        const volatile WGPUChainedStructTransfer* header;\n        WIRE_TRY(deserializeBuffer->Peek(&header));\n        WGPUSType sType = header->sType;\n        switch (sType) {\n            // Explicitly list the Invalid enum. MSVC complains about no case labels.\n            case WGPUSType_Invalid:\n            default: {\n                // Invalid enum. Deserialize just the transfer header with Invalid as the sType.\n                // TODO(crbug.com/dawn/369): Unknown sTypes are silently discarded.\n                if (sType != WGPUSType_Invalid) {\n                    dawn::WarningLog() << \"Unknown sType \" << sType << \" discarded.\";\n                }\n\n                const volatile WGPUChainedStructTransfer* transfer;\n                WIRE_TRY(deserializeBuffer->Read(&transfer));\n\n                WGPUChainedStructOut* outStruct;\n                WIRE_TRY(GetSpace(allocator, 1u, &outStruct));\n                outStruct->sType = WGPUSType_Invalid;\n                outStruct->next = nullptr;\n\n                // Still move on in case there are valid structs after this.\n                *outChainNext = outStruct;\n                outChainNext = &outStruct->next;\n                hasNext = transfer->hasNext;\n                break;\n            }\n        }\n    } while (hasNext);\n    return WireResult::Success;\n}\n\n\n\nstruct AdapterGetInstanceTransfer : CmdHeader {\n    static_assert(1 <= 1,\n                  \"Record must be at most one of is_cmd, extensible, and chained.\");\n    WireCmd commandId;\n\n    ObjectId self;\n    ObjectHandle result;\n};\n\nstatic_assert(offsetof(AdapterGetInstanceTransfer, commandSize) == 0);\nstatic_assert(offsetof(AdapterGetInstanceTransfer, commandId) == sizeof(CmdHeader));\n\nDAWN_DECLARE_UNUSED size_t AdapterGetInstanceGetExtraRequiredSize(const AdapterGetInstanceCmd& record) {\n    DAWN_UNUSED(record);\n    size_t result = 0;\n\n    return result;\n}\n// GetExtraRequiredSize isn't used for structures that are value members of other structures\n// because we assume they cannot contain pointers themselves.\nDAWN_UNUSED_FUNC(AdapterGetInstanceGetExtraRequiredSize);\n\nDAWN_DECLARE_UNUSED WireResult AdapterGetInstanceSerialize(\n    const AdapterGetInstanceCmd& record,\n    AdapterGetInstanceTransfer* transfer,\n    SerializeBuffer* buffer, const ObjectIdProvider& provider) {\n    DAWN_UNUSED(buffer);\n    transfer->commandId = WireCmd::AdapterGetInstance;\n\n\n    WIRE_TRY(provider.GetId(record.self, &transfer->self));\n    transfer->result = record.result;\n\n    return WireResult::Success;\n}\nDAWN_UNUSED_FUNC(AdapterGetInstanceSerialize);\n\nDAWN_DECLARE_UNUSED WireResult AdapterGetInstanceDeserialize(\n    AdapterGetInstanceCmd* record,\n    const volatile AdapterGetInstanceTransfer* transfer,\n    DeserializeBuffer* deserializeBuffer,\n    DeserializeAllocator* allocator, const ObjectIdResolver& resolver) {\n    DAWN_UNUSED(allocator);\n\n    ASSERT(transfer->commandId == WireCmd::AdapterGetInstance);\n    record->selfId = transfer->self;\n\n\n    WIRE_TRY(resolver.GetFromId(transfer->self, &record->self));\n    static_assert(sizeof(record->result) >= sizeof(transfer->result), \"Deserialize assignment may not narrow.\");\n    record->result = transfer->result;\n\n    return WireResult::Success;\n}\nDAWN_UNUSED_FUNC(AdapterGetInstanceDeserialize);\n\nstruct AdapterRequestDeviceTransfer : CmdHeader {\n    static_assert(1 <= 1,\n                  \"Record must be at most one of is_cmd, extensible, and chained.\");\n    WireCmd commandId;\n\n    ObjectId adapterId;\n    uint64_t requestSerial;\n    ObjectHandle deviceObjectHandle;\n};\n\nstatic_assert(offsetof(AdapterRequestDeviceTransfer, commandSize) == 0);\nstatic_assert(offsetof(AdapterRequestDeviceTransfer, commandId) == sizeof(CmdHeader));\n\nDAWN_DECLARE_UNUSED size_t AdapterRequestDeviceGetExtraRequiredSize(const AdapterRequestDeviceCmd& record) {\n    DAWN_UNUSED(record);\n    size_t result = 0;\n\n    {\n        auto memberLength = 1u;\n        auto size = WireAlignSizeofN<WGPUDeviceDescriptorTransfer>(memberLength);\n        ASSERT(size);\n        result += *size;\n        for (decltype(memberLength) i = 0; i < memberLength; ++i) {\n            result += WGPUDeviceDescriptorGetExtraRequiredSize(record.descriptor[i]);\n        }\n    }\n    return result;\n}\n// GetExtraRequiredSize isn't used for structures that are value members of other structures\n// because we assume they cannot contain pointers themselves.\nDAWN_UNUSED_FUNC(AdapterRequestDeviceGetExtraRequiredSize);\n\nDAWN_DECLARE_UNUSED WireResult AdapterRequestDeviceSerialize(\n    const AdapterRequestDeviceCmd& record,\n    AdapterRequestDeviceTransfer* transfer,\n    SerializeBuffer* buffer, const ObjectIdProvider& provider) {\n    DAWN_UNUSED(buffer);\n    transfer->commandId = WireCmd::AdapterRequestDevice;\n\n\n    transfer->adapterId = record.adapterId;\n    transfer->requestSerial = record.requestSerial;\n    transfer->deviceObjectHandle = record.deviceObjectHandle;\n    {\n        auto memberLength = 1u;\n\n        WGPUDeviceDescriptorTransfer* memberBuffer;\n        WIRE_TRY(buffer->NextN(memberLength, &memberBuffer));\n\n        for (decltype(memberLength) i = 0; i < memberLength; ++i) {\n            WIRE_TRY(WGPUDeviceDescriptorSerialize(record.descriptor[i], &memberBuffer[i], buffer, provider));\n        }\n    }\n\n    return WireResult::Success;\n}\nDAWN_UNUSED_FUNC(AdapterRequestDeviceSerialize);\n\nDAWN_DECLARE_UNUSED WireResult AdapterRequestDeviceDeserialize(\n    AdapterRequestDeviceCmd* record,\n    const volatile AdapterRequestDeviceTransfer* transfer,\n    DeserializeBuffer* deserializeBuffer,\n    DeserializeAllocator* allocator, const ObjectIdResolver& resolver) {\n    DAWN_UNUSED(allocator);\n\n    ASSERT(transfer->commandId == WireCmd::AdapterRequestDevice);\n\n\n    static_assert(sizeof(record->adapterId) >= sizeof(transfer->adapterId), \"Deserialize assignment may not narrow.\");\n    record->adapterId = transfer->adapterId;\n    static_assert(sizeof(record->requestSerial) >= sizeof(transfer->requestSerial), \"Deserialize assignment may not narrow.\");\n    record->requestSerial = transfer->requestSerial;\n    static_assert(sizeof(record->deviceObjectHandle) >= sizeof(transfer->deviceObjectHandle), \"Deserialize assignment may not narrow.\");\n    record->deviceObjectHandle = transfer->deviceObjectHandle;\n    {\n        auto memberLength = 1u;\n        const volatile WGPUDeviceDescriptorTransfer* memberBuffer;\n        WIRE_TRY(deserializeBuffer->ReadN(memberLength, &memberBuffer));\n\n        WGPUDeviceDescriptor* copiedMembers;\n        WIRE_TRY(GetSpace(allocator, memberLength, &copiedMembers));\n        record->descriptor = copiedMembers;\n\n        for (decltype(memberLength) i = 0; i < memberLength; ++i) {\n            WIRE_TRY(WGPUDeviceDescriptorDeserialize(&copiedMembers[i], &memberBuffer[i], deserializeBuffer, allocator, resolver));\n        }\n    }\n\n    return WireResult::Success;\n}\nDAWN_UNUSED_FUNC(AdapterRequestDeviceDeserialize);\n\nstruct BindGroupLayoutSetLabelTransfer : CmdHeader {\n    static_assert(1 <= 1,\n                  \"Record must be at most one of is_cmd, extensible, and chained.\");\n    WireCmd commandId;\n\n    ObjectId self;\n    uint64_t labelStrlen;\n};\n\nstatic_assert(offsetof(BindGroupLayoutSetLabelTransfer, commandSize) == 0);\nstatic_assert(offsetof(BindGroupLayoutSetLabelTransfer, commandId) == sizeof(CmdHeader));\n\nDAWN_DECLARE_UNUSED size_t BindGroupLayoutSetLabelGetExtraRequiredSize(const BindGroupLayoutSetLabelCmd& record) {\n    DAWN_UNUSED(record);\n    size_t result = 0;\n\n    ASSERT(record.label != nullptr);\n    result += Align(std::strlen(record.label), kWireBufferAlignment);\n    return result;\n}\n// GetExtraRequiredSize isn't used for structures that are value members of other structures\n// because we assume they cannot contain pointers themselves.\nDAWN_UNUSED_FUNC(BindGroupLayoutSetLabelGetExtraRequiredSize);\n\nDAWN_DECLARE_UNUSED WireResult BindGroupLayoutSetLabelSerialize(\n    const BindGroupLayoutSetLabelCmd& record,\n    BindGroupLayoutSetLabelTransfer* transfer,\n    SerializeBuffer* buffer, const ObjectIdProvider& provider) {\n    DAWN_UNUSED(buffer);\n    transfer->commandId = WireCmd::BindGroupLayoutSetLabel;\n\n\n    WIRE_TRY(provider.GetId(record.self, &transfer->self));\n    {\n        transfer->labelStrlen = std::strlen(record.label);\n\n        char* stringInBuffer;\n        WIRE_TRY(buffer->NextN(transfer->labelStrlen, &stringInBuffer));\n        memcpy(stringInBuffer, record.label, transfer->labelStrlen);\n    }\n\n    return WireResult::Success;\n}\nDAWN_UNUSED_FUNC(BindGroupLayoutSetLabelSerialize);\n\nDAWN_DECLARE_UNUSED WireResult BindGroupLayoutSetLabelDeserialize(\n    BindGroupLayoutSetLabelCmd* record,\n    const volatile BindGroupLayoutSetLabelTransfer* transfer,\n    DeserializeBuffer* deserializeBuffer,\n    DeserializeAllocator* allocator, const ObjectIdResolver& resolver) {\n    DAWN_UNUSED(allocator);\n\n    ASSERT(transfer->commandId == WireCmd::BindGroupLayoutSetLabel);\n    record->selfId = transfer->self;\n\n\n    WIRE_TRY(resolver.GetFromId(transfer->self, &record->self));\n    {\n        uint64_t stringLength64 = transfer->labelStrlen;\n        if (stringLength64 >= std::numeric_limits<size_t>::max()) {\n            return WireResult::FatalError;\n        }\n        size_t stringLength = static_cast<size_t>(stringLength64);\n\n        const volatile char* stringInBuffer;\n        WIRE_TRY(deserializeBuffer->ReadN(stringLength, &stringInBuffer));\n\n        char* copiedString;\n        WIRE_TRY(GetSpace(allocator, stringLength + 1, &copiedString));\n        memcpy(copiedString, const_cast<const char*>(stringInBuffer), stringLength);\n        copiedString[stringLength] = '\\0';\n        record->label = copiedString;\n    }\n\n    return WireResult::Success;\n}\nDAWN_UNUSED_FUNC(BindGroupLayoutSetLabelDeserialize);\n\nstruct BindGroupSetLabelTransfer : CmdHeader {\n    static_assert(1 <= 1,\n                  \"Record must be at most one of is_cmd, extensible, and chained.\");\n    WireCmd commandId;\n\n    ObjectId self;\n    uint64_t labelStrlen;\n};\n\nstatic_assert(offsetof(BindGroupSetLabelTransfer, commandSize) == 0);\nstatic_assert(offsetof(BindGroupSetLabelTransfer, commandId) == sizeof(CmdHeader));\n\nDAWN_DECLARE_UNUSED size_t BindGroupSetLabelGetExtraRequiredSize(const BindGroupSetLabelCmd& record) {\n    DAWN_UNUSED(record);\n    size_t result = 0;\n\n    ASSERT(record.label != nullptr);\n    result += Align(std::strlen(record.label), kWireBufferAlignment);\n    return result;\n}\n// GetExtraRequiredSize isn't used for structures that are value members of other structures\n// because we assume they cannot contain pointers themselves.\nDAWN_UNUSED_FUNC(BindGroupSetLabelGetExtraRequiredSize);\n\nDAWN_DECLARE_UNUSED WireResult BindGroupSetLabelSerialize(\n    const BindGroupSetLabelCmd& record,\n    BindGroupSetLabelTransfer* transfer,\n    SerializeBuffer* buffer, const ObjectIdProvider& provider) {\n    DAWN_UNUSED(buffer);\n    transfer->commandId = WireCmd::BindGroupSetLabel;\n\n\n    WIRE_TRY(provider.GetId(record.self, &transfer->self));\n    {\n        transfer->labelStrlen = std::strlen(record.label);\n\n        char* stringInBuffer;\n        WIRE_TRY(buffer->NextN(transfer->labelStrlen, &stringInBuffer));\n        memcpy(stringInBuffer, record.label, transfer->labelStrlen);\n    }\n\n    return WireResult::Success;\n}\nDAWN_UNUSED_FUNC(BindGroupSetLabelSerialize);\n\nDAWN_DECLARE_UNUSED WireResult BindGroupSetLabelDeserialize(\n    BindGroupSetLabelCmd* record,\n    const volatile BindGroupSetLabelTransfer* transfer,\n    DeserializeBuffer* deserializeBuffer,\n    DeserializeAllocator* allocator, const ObjectIdResolver& resolver) {\n    DAWN_UNUSED(allocator);\n\n    ASSERT(transfer->commandId == WireCmd::BindGroupSetLabel);\n    record->selfId = transfer->self;\n\n\n    WIRE_TRY(resolver.GetFromId(transfer->self, &record->self));\n    {\n        uint64_t stringLength64 = transfer->labelStrlen;\n        if (stringLength64 >= std::numeric_limits<size_t>::max()) {\n            return WireResult::FatalError;\n        }\n        size_t stringLength = static_cast<size_t>(stringLength64);\n\n        const volatile char* stringInBuffer;\n        WIRE_TRY(deserializeBuffer->ReadN(stringLength, &stringInBuffer));\n\n        char* copiedString;\n        WIRE_TRY(GetSpace(allocator, stringLength + 1, &copiedString));\n        memcpy(copiedString, const_cast<const char*>(stringInBuffer), stringLength);\n        copiedString[stringLength] = '\\0';\n        record->label = copiedString;\n    }\n\n    return WireResult::Success;\n}\nDAWN_UNUSED_FUNC(BindGroupSetLabelDeserialize);\n\nstruct BufferDestroyTransfer : CmdHeader {\n    static_assert(1 <= 1,\n                  \"Record must be at most one of is_cmd, extensible, and chained.\");\n    WireCmd commandId;\n\n    ObjectId self;\n};\n\nstatic_assert(offsetof(BufferDestroyTransfer, commandSize) == 0);\nstatic_assert(offsetof(BufferDestroyTransfer, commandId) == sizeof(CmdHeader));\n\nDAWN_DECLARE_UNUSED size_t BufferDestroyGetExtraRequiredSize(const BufferDestroyCmd& record) {\n    DAWN_UNUSED(record);\n    size_t result = 0;\n\n    return result;\n}\n// GetExtraRequiredSize isn't used for structures that are value members of other structures\n// because we assume they cannot contain pointers themselves.\nDAWN_UNUSED_FUNC(BufferDestroyGetExtraRequiredSize);\n\nDAWN_DECLARE_UNUSED WireResult BufferDestroySerialize(\n    const BufferDestroyCmd& record,\n    BufferDestroyTransfer* transfer,\n    SerializeBuffer* buffer, const ObjectIdProvider& provider) {\n    DAWN_UNUSED(buffer);\n    transfer->commandId = WireCmd::BufferDestroy;\n\n\n    WIRE_TRY(provider.GetId(record.self, &transfer->self));\n\n    return WireResult::Success;\n}\nDAWN_UNUSED_FUNC(BufferDestroySerialize);\n\nDAWN_DECLARE_UNUSED WireResult BufferDestroyDeserialize(\n    BufferDestroyCmd* record,\n    const volatile BufferDestroyTransfer* transfer,\n    DeserializeBuffer* deserializeBuffer,\n    DeserializeAllocator* allocator, const ObjectIdResolver& resolver) {\n    DAWN_UNUSED(allocator);\n\n    ASSERT(transfer->commandId == WireCmd::BufferDestroy);\n    record->selfId = transfer->self;\n\n\n    WIRE_TRY(resolver.GetFromId(transfer->self, &record->self));\n\n    return WireResult::Success;\n}\nDAWN_UNUSED_FUNC(BufferDestroyDeserialize);\n\nstruct BufferMapAsyncTransfer : CmdHeader {\n    static_assert(1 <= 1,\n                  \"Record must be at most one of is_cmd, extensible, and chained.\");\n    WireCmd commandId;\n\n    ObjectId bufferId;\n    uint64_t requestSerial;\n    WGPUMapModeFlags mode;\n    uint64_t offset;\n    uint64_t size;\n};\n\nstatic_assert(offsetof(BufferMapAsyncTransfer, commandSize) == 0);\nstatic_assert(offsetof(BufferMapAsyncTransfer, commandId) == sizeof(CmdHeader));\n\nDAWN_DECLARE_UNUSED size_t BufferMapAsyncGetExtraRequiredSize(const BufferMapAsyncCmd& record) {\n    DAWN_UNUSED(record);\n    size_t result = 0;\n\n    return result;\n}\n// GetExtraRequiredSize isn't used for structures that are value members of other structures\n// because we assume they cannot contain pointers themselves.\nDAWN_UNUSED_FUNC(BufferMapAsyncGetExtraRequiredSize);\n\nDAWN_DECLARE_UNUSED WireResult BufferMapAsyncSerialize(\n    const BufferMapAsyncCmd& record,\n    BufferMapAsyncTransfer* transfer,\n    SerializeBuffer* buffer) {\n    DAWN_UNUSED(buffer);\n    transfer->commandId = WireCmd::BufferMapAsync;\n\n\n    transfer->bufferId = record.bufferId;\n    transfer->requestSerial = record.requestSerial;\n    transfer->mode = record.mode;\n    transfer->offset = record.offset;\n    transfer->size = record.size;\n\n    return WireResult::Success;\n}\nDAWN_UNUSED_FUNC(BufferMapAsyncSerialize);\n\nDAWN_DECLARE_UNUSED WireResult BufferMapAsyncDeserialize(\n    BufferMapAsyncCmd* record,\n    const volatile BufferMapAsyncTransfer* transfer,\n    DeserializeBuffer* deserializeBuffer,\n    DeserializeAllocator* allocator) {\n    DAWN_UNUSED(allocator);\n\n    ASSERT(transfer->commandId == WireCmd::BufferMapAsync);\n\n\n    static_assert(sizeof(record->bufferId) >= sizeof(transfer->bufferId), \"Deserialize assignment may not narrow.\");\n    record->bufferId = transfer->bufferId;\n    static_assert(sizeof(record->requestSerial) >= sizeof(transfer->requestSerial), \"Deserialize assignment may not narrow.\");\n    record->requestSerial = transfer->requestSerial;\n    static_assert(sizeof(record->mode) >= sizeof(transfer->mode), \"Deserialize assignment may not narrow.\");\n    record->mode = transfer->mode;\n    static_assert(sizeof(record->offset) >= sizeof(transfer->offset), \"Deserialize assignment may not narrow.\");\n    record->offset = transfer->offset;\n    static_assert(sizeof(record->size) >= sizeof(transfer->size), \"Deserialize assignment may not narrow.\");\n    record->size = transfer->size;\n\n    return WireResult::Success;\n}\nDAWN_UNUSED_FUNC(BufferMapAsyncDeserialize);\n\nstruct BufferSetLabelTransfer : CmdHeader {\n    static_assert(1 <= 1,\n                  \"Record must be at most one of is_cmd, extensible, and chained.\");\n    WireCmd commandId;\n\n    ObjectId self;\n    uint64_t labelStrlen;\n};\n\nstatic_assert(offsetof(BufferSetLabelTransfer, commandSize) == 0);\nstatic_assert(offsetof(BufferSetLabelTransfer, commandId) == sizeof(CmdHeader));\n\nDAWN_DECLARE_UNUSED size_t BufferSetLabelGetExtraRequiredSize(const BufferSetLabelCmd& record) {\n    DAWN_UNUSED(record);\n    size_t result = 0;\n\n    ASSERT(record.label != nullptr);\n    result += Align(std::strlen(record.label), kWireBufferAlignment);\n    return result;\n}\n// GetExtraRequiredSize isn't used for structures that are value members of other structures\n// because we assume they cannot contain pointers themselves.\nDAWN_UNUSED_FUNC(BufferSetLabelGetExtraRequiredSize);\n\nDAWN_DECLARE_UNUSED WireResult BufferSetLabelSerialize(\n    const BufferSetLabelCmd& record,\n    BufferSetLabelTransfer* transfer,\n    SerializeBuffer* buffer, const ObjectIdProvider& provider) {\n    DAWN_UNUSED(buffer);\n    transfer->commandId = WireCmd::BufferSetLabel;\n\n\n    WIRE_TRY(provider.GetId(record.self, &transfer->self));\n    {\n        transfer->labelStrlen = std::strlen(record.label);\n\n        char* stringInBuffer;\n        WIRE_TRY(buffer->NextN(transfer->labelStrlen, &stringInBuffer));\n        memcpy(stringInBuffer, record.label, transfer->labelStrlen);\n    }\n\n    return WireResult::Success;\n}\nDAWN_UNUSED_FUNC(BufferSetLabelSerialize);\n\nDAWN_DECLARE_UNUSED WireResult BufferSetLabelDeserialize(\n    BufferSetLabelCmd* record,\n    const volatile BufferSetLabelTransfer* transfer,\n    DeserializeBuffer* deserializeBuffer,\n    DeserializeAllocator* allocator, const ObjectIdResolver& resolver) {\n    DAWN_UNUSED(allocator);\n\n    ASSERT(transfer->commandId == WireCmd::BufferSetLabel);\n    record->selfId = transfer->self;\n\n\n    WIRE_TRY(resolver.GetFromId(transfer->self, &record->self));\n    {\n        uint64_t stringLength64 = transfer->labelStrlen;\n        if (stringLength64 >= std::numeric_limits<size_t>::max()) {\n            return WireResult::FatalError;\n        }\n        size_t stringLength = static_cast<size_t>(stringLength64);\n\n        const volatile char* stringInBuffer;\n        WIRE_TRY(deserializeBuffer->ReadN(stringLength, &stringInBuffer));\n\n        char* copiedString;\n        WIRE_TRY(GetSpace(allocator, stringLength + 1, &copiedString));\n        memcpy(copiedString, const_cast<const char*>(stringInBuffer), stringLength);\n        copiedString[stringLength] = '\\0';\n        record->label = copiedString;\n    }\n\n    return WireResult::Success;\n}\nDAWN_UNUSED_FUNC(BufferSetLabelDeserialize);\n\nstruct BufferUnmapTransfer : CmdHeader {\n    static_assert(1 <= 1,\n                  \"Record must be at most one of is_cmd, extensible, and chained.\");\n    WireCmd commandId;\n\n    ObjectId self;\n};\n\nstatic_assert(offsetof(BufferUnmapTransfer, commandSize) == 0);\nstatic_assert(offsetof(BufferUnmapTransfer, commandId) == sizeof(CmdHeader));\n\nDAWN_DECLARE_UNUSED size_t BufferUnmapGetExtraRequiredSize(const BufferUnmapCmd& record) {\n    DAWN_UNUSED(record);\n    size_t result = 0;\n\n    return result;\n}\n// GetExtraRequiredSize isn't used for structures that are value members of other structures\n// because we assume they cannot contain pointers themselves.\nDAWN_UNUSED_FUNC(BufferUnmapGetExtraRequiredSize);\n\nDAWN_DECLARE_UNUSED WireResult BufferUnmapSerialize(\n    const BufferUnmapCmd& record,\n    BufferUnmapTransfer* transfer,\n    SerializeBuffer* buffer, const ObjectIdProvider& provider) {\n    DAWN_UNUSED(buffer);\n    transfer->commandId = WireCmd::BufferUnmap;\n\n\n    WIRE_TRY(provider.GetId(record.self, &transfer->self));\n\n    return WireResult::Success;\n}\nDAWN_UNUSED_FUNC(BufferUnmapSerialize);\n\nDAWN_DECLARE_UNUSED WireResult BufferUnmapDeserialize(\n    BufferUnmapCmd* record,\n    const volatile BufferUnmapTransfer* transfer,\n    DeserializeBuffer* deserializeBuffer,\n    DeserializeAllocator* allocator, const ObjectIdResolver& resolver) {\n    DAWN_UNUSED(allocator);\n\n    ASSERT(transfer->commandId == WireCmd::BufferUnmap);\n    record->selfId = transfer->self;\n\n\n    WIRE_TRY(resolver.GetFromId(transfer->self, &record->self));\n\n    return WireResult::Success;\n}\nDAWN_UNUSED_FUNC(BufferUnmapDeserialize);\n\nstruct BufferUpdateMappedDataTransfer : CmdHeader {\n    static_assert(1 <= 1,\n                  \"Record must be at most one of is_cmd, extensible, and chained.\");\n    WireCmd commandId;\n\n    ObjectId bufferId;\n    uint64_t writeDataUpdateInfoLength;\n    uint64_t offset;\n    uint64_t size;\n};\n\nstatic_assert(offsetof(BufferUpdateMappedDataTransfer, commandSize) == 0);\nstatic_assert(offsetof(BufferUpdateMappedDataTransfer, commandId) == sizeof(CmdHeader));\n\nDAWN_DECLARE_UNUSED size_t BufferUpdateMappedDataGetExtraRequiredSize(const BufferUpdateMappedDataCmd& record) {\n    DAWN_UNUSED(record);\n    size_t result = 0;\n\n    return result;\n}\n// GetExtraRequiredSize isn't used for structures that are value members of other structures\n// because we assume they cannot contain pointers themselves.\nDAWN_UNUSED_FUNC(BufferUpdateMappedDataGetExtraRequiredSize);\n\nDAWN_DECLARE_UNUSED WireResult BufferUpdateMappedDataSerialize(\n    const BufferUpdateMappedDataCmd& record,\n    BufferUpdateMappedDataTransfer* transfer,\n    SerializeBuffer* buffer) {\n    DAWN_UNUSED(buffer);\n    transfer->commandId = WireCmd::BufferUpdateMappedData;\n\n\n    transfer->bufferId = record.bufferId;\n    transfer->writeDataUpdateInfoLength = record.writeDataUpdateInfoLength;\n    transfer->offset = record.offset;\n    transfer->size = record.size;\n\n    return WireResult::Success;\n}\nDAWN_UNUSED_FUNC(BufferUpdateMappedDataSerialize);\n\nDAWN_DECLARE_UNUSED WireResult BufferUpdateMappedDataDeserialize(\n    BufferUpdateMappedDataCmd* record,\n    const volatile BufferUpdateMappedDataTransfer* transfer,\n    DeserializeBuffer* deserializeBuffer,\n    DeserializeAllocator* allocator) {\n    DAWN_UNUSED(allocator);\n\n    ASSERT(transfer->commandId == WireCmd::BufferUpdateMappedData);\n\n\n    static_assert(sizeof(record->bufferId) >= sizeof(transfer->bufferId), \"Deserialize assignment may not narrow.\");\n    record->bufferId = transfer->bufferId;\n    static_assert(sizeof(record->writeDataUpdateInfoLength) >= sizeof(transfer->writeDataUpdateInfoLength), \"Deserialize assignment may not narrow.\");\n    record->writeDataUpdateInfoLength = transfer->writeDataUpdateInfoLength;\n    static_assert(sizeof(record->offset) >= sizeof(transfer->offset), \"Deserialize assignment may not narrow.\");\n    record->offset = transfer->offset;\n    static_assert(sizeof(record->size) >= sizeof(transfer->size), \"Deserialize assignment may not narrow.\");\n    record->size = transfer->size;\n    {\n        auto memberLength = record->writeDataUpdateInfoLength;\n        const volatile uint8_t* memberBuffer;\n        WIRE_TRY(deserializeBuffer->ReadN(memberLength, &memberBuffer));\n\n        uint8_t* copiedMembers;\n        WIRE_TRY(GetSpace(allocator, memberLength, &copiedMembers));\n        record->writeDataUpdateInfo = copiedMembers;\n\n        memcpy(\n            copiedMembers,\n            const_cast<const uint8_t*>(memberBuffer),\n           sizeof(uint8_t) * memberLength);\n    }\n\n    return WireResult::Success;\n}\nDAWN_UNUSED_FUNC(BufferUpdateMappedDataDeserialize);\n\nstruct CommandBufferSetLabelTransfer : CmdHeader {\n    static_assert(1 <= 1,\n                  \"Record must be at most one of is_cmd, extensible, and chained.\");\n    WireCmd commandId;\n\n    ObjectId self;\n    uint64_t labelStrlen;\n};\n\nstatic_assert(offsetof(CommandBufferSetLabelTransfer, commandSize) == 0);\nstatic_assert(offsetof(CommandBufferSetLabelTransfer, commandId) == sizeof(CmdHeader));\n\nDAWN_DECLARE_UNUSED size_t CommandBufferSetLabelGetExtraRequiredSize(const CommandBufferSetLabelCmd& record) {\n    DAWN_UNUSED(record);\n    size_t result = 0;\n\n    ASSERT(record.label != nullptr);\n    result += Align(std::strlen(record.label), kWireBufferAlignment);\n    return result;\n}\n// GetExtraRequiredSize isn't used for structures that are value members of other structures\n// because we assume they cannot contain pointers themselves.\nDAWN_UNUSED_FUNC(CommandBufferSetLabelGetExtraRequiredSize);\n\nDAWN_DECLARE_UNUSED WireResult CommandBufferSetLabelSerialize(\n    const CommandBufferSetLabelCmd& record,\n    CommandBufferSetLabelTransfer* transfer,\n    SerializeBuffer* buffer, const ObjectIdProvider& provider) {\n    DAWN_UNUSED(buffer);\n    transfer->commandId = WireCmd::CommandBufferSetLabel;\n\n\n    WIRE_TRY(provider.GetId(record.self, &transfer->self));\n    {\n        transfer->labelStrlen = std::strlen(record.label);\n\n        char* stringInBuffer;\n        WIRE_TRY(buffer->NextN(transfer->labelStrlen, &stringInBuffer));\n        memcpy(stringInBuffer, record.label, transfer->labelStrlen);\n    }\n\n    return WireResult::Success;\n}\nDAWN_UNUSED_FUNC(CommandBufferSetLabelSerialize);\n\nDAWN_DECLARE_UNUSED WireResult CommandBufferSetLabelDeserialize(\n    CommandBufferSetLabelCmd* record,\n    const volatile CommandBufferSetLabelTransfer* transfer,\n    DeserializeBuffer* deserializeBuffer,\n    DeserializeAllocator* allocator, const ObjectIdResolver& resolver) {\n    DAWN_UNUSED(allocator);\n\n    ASSERT(transfer->commandId == WireCmd::CommandBufferSetLabel);\n    record->selfId = transfer->self;\n\n\n    WIRE_TRY(resolver.GetFromId(transfer->self, &record->self));\n    {\n        uint64_t stringLength64 = transfer->labelStrlen;\n        if (stringLength64 >= std::numeric_limits<size_t>::max()) {\n            return WireResult::FatalError;\n        }\n        size_t stringLength = static_cast<size_t>(stringLength64);\n\n        const volatile char* stringInBuffer;\n        WIRE_TRY(deserializeBuffer->ReadN(stringLength, &stringInBuffer));\n\n        char* copiedString;\n        WIRE_TRY(GetSpace(allocator, stringLength + 1, &copiedString));\n        memcpy(copiedString, const_cast<const char*>(stringInBuffer), stringLength);\n        copiedString[stringLength] = '\\0';\n        record->label = copiedString;\n    }\n\n    return WireResult::Success;\n}\nDAWN_UNUSED_FUNC(CommandBufferSetLabelDeserialize);\n\nstruct CommandEncoderBeginComputePassTransfer : CmdHeader {\n    static_assert(1 <= 1,\n                  \"Record must be at most one of is_cmd, extensible, and chained.\");\n    WireCmd commandId;\n\n    ObjectId self;\n    bool has_descriptor;\n    ObjectHandle result;\n};\n\nstatic_assert(offsetof(CommandEncoderBeginComputePassTransfer, commandSize) == 0);\nstatic_assert(offsetof(CommandEncoderBeginComputePassTransfer, commandId) == sizeof(CmdHeader));\n\nDAWN_DECLARE_UNUSED size_t CommandEncoderBeginComputePassGetExtraRequiredSize(const CommandEncoderBeginComputePassCmd& record) {\n    DAWN_UNUSED(record);\n    size_t result = 0;\n\n    if (record.descriptor != nullptr) {\n        auto memberLength = 1u;\n        auto size = WireAlignSizeofN<WGPUComputePassDescriptorTransfer>(memberLength);\n        ASSERT(size);\n        result += *size;\n        for (decltype(memberLength) i = 0; i < memberLength; ++i) {\n            result += WGPUComputePassDescriptorGetExtraRequiredSize(record.descriptor[i]);\n        }\n    }\n    return result;\n}\n// GetExtraRequiredSize isn't used for structures that are value members of other structures\n// because we assume they cannot contain pointers themselves.\nDAWN_UNUSED_FUNC(CommandEncoderBeginComputePassGetExtraRequiredSize);\n\nDAWN_DECLARE_UNUSED WireResult CommandEncoderBeginComputePassSerialize(\n    const CommandEncoderBeginComputePassCmd& record,\n    CommandEncoderBeginComputePassTransfer* transfer,\n    SerializeBuffer* buffer, const ObjectIdProvider& provider) {\n    DAWN_UNUSED(buffer);\n    transfer->commandId = WireCmd::CommandEncoderBeginComputePass;\n\n\n    WIRE_TRY(provider.GetId(record.self, &transfer->self));\n    transfer->result = record.result;\n    bool has_descriptor = record.descriptor != nullptr;\n    transfer->has_descriptor = has_descriptor;\n    if (has_descriptor) {\n        auto memberLength = 1u;\n\n        WGPUComputePassDescriptorTransfer* memberBuffer;\n        WIRE_TRY(buffer->NextN(memberLength, &memberBuffer));\n\n        for (decltype(memberLength) i = 0; i < memberLength; ++i) {\n            WIRE_TRY(WGPUComputePassDescriptorSerialize(record.descriptor[i], &memberBuffer[i], buffer, provider));\n        }\n    }\n\n    return WireResult::Success;\n}\nDAWN_UNUSED_FUNC(CommandEncoderBeginComputePassSerialize);\n\nDAWN_DECLARE_UNUSED WireResult CommandEncoderBeginComputePassDeserialize(\n    CommandEncoderBeginComputePassCmd* record,\n    const volatile CommandEncoderBeginComputePassTransfer* transfer,\n    DeserializeBuffer* deserializeBuffer,\n    DeserializeAllocator* allocator, const ObjectIdResolver& resolver) {\n    DAWN_UNUSED(allocator);\n\n    ASSERT(transfer->commandId == WireCmd::CommandEncoderBeginComputePass);\n    record->selfId = transfer->self;\n\n\n    WIRE_TRY(resolver.GetFromId(transfer->self, &record->self));\n    static_assert(sizeof(record->result) >= sizeof(transfer->result), \"Deserialize assignment may not narrow.\");\n    record->result = transfer->result;\n    bool has_descriptor = transfer->has_descriptor;\n    record->descriptor = nullptr;\n    if (has_descriptor) {\n        auto memberLength = 1u;\n        const volatile WGPUComputePassDescriptorTransfer* memberBuffer;\n        WIRE_TRY(deserializeBuffer->ReadN(memberLength, &memberBuffer));\n\n        WGPUComputePassDescriptor* copiedMembers;\n        WIRE_TRY(GetSpace(allocator, memberLength, &copiedMembers));\n        record->descriptor = copiedMembers;\n\n        for (decltype(memberLength) i = 0; i < memberLength; ++i) {\n            WIRE_TRY(WGPUComputePassDescriptorDeserialize(&copiedMembers[i], &memberBuffer[i], deserializeBuffer, allocator, resolver));\n        }\n    }\n\n    return WireResult::Success;\n}\nDAWN_UNUSED_FUNC(CommandEncoderBeginComputePassDeserialize);\n\nstruct CommandEncoderBeginRenderPassTransfer : CmdHeader {\n    static_assert(1 <= 1,\n                  \"Record must be at most one of is_cmd, extensible, and chained.\");\n    WireCmd commandId;\n\n    ObjectId self;\n    ObjectHandle result;\n};\n\nstatic_assert(offsetof(CommandEncoderBeginRenderPassTransfer, commandSize) == 0);\nstatic_assert(offsetof(CommandEncoderBeginRenderPassTransfer, commandId) == sizeof(CmdHeader));\n\nDAWN_DECLARE_UNUSED size_t CommandEncoderBeginRenderPassGetExtraRequiredSize(const CommandEncoderBeginRenderPassCmd& record) {\n    DAWN_UNUSED(record);\n    size_t result = 0;\n\n    {\n        auto memberLength = 1u;\n        auto size = WireAlignSizeofN<WGPURenderPassDescriptorTransfer>(memberLength);\n        ASSERT(size);\n        result += *size;\n        for (decltype(memberLength) i = 0; i < memberLength; ++i) {\n            result += WGPURenderPassDescriptorGetExtraRequiredSize(record.descriptor[i]);\n        }\n    }\n    return result;\n}\n// GetExtraRequiredSize isn't used for structures that are value members of other structures\n// because we assume they cannot contain pointers themselves.\nDAWN_UNUSED_FUNC(CommandEncoderBeginRenderPassGetExtraRequiredSize);\n\nDAWN_DECLARE_UNUSED WireResult CommandEncoderBeginRenderPassSerialize(\n    const CommandEncoderBeginRenderPassCmd& record,\n    CommandEncoderBeginRenderPassTransfer* transfer,\n    SerializeBuffer* buffer, const ObjectIdProvider& provider) {\n    DAWN_UNUSED(buffer);\n    transfer->commandId = WireCmd::CommandEncoderBeginRenderPass;\n\n\n    WIRE_TRY(provider.GetId(record.self, &transfer->self));\n    transfer->result = record.result;\n    {\n        auto memberLength = 1u;\n\n        WGPURenderPassDescriptorTransfer* memberBuffer;\n        WIRE_TRY(buffer->NextN(memberLength, &memberBuffer));\n\n        for (decltype(memberLength) i = 0; i < memberLength; ++i) {\n            WIRE_TRY(WGPURenderPassDescriptorSerialize(record.descriptor[i], &memberBuffer[i], buffer, provider));\n        }\n    }\n\n    return WireResult::Success;\n}\nDAWN_UNUSED_FUNC(CommandEncoderBeginRenderPassSerialize);\n\nDAWN_DECLARE_UNUSED WireResult CommandEncoderBeginRenderPassDeserialize(\n    CommandEncoderBeginRenderPassCmd* record,\n    const volatile CommandEncoderBeginRenderPassTransfer* transfer,\n    DeserializeBuffer* deserializeBuffer,\n    DeserializeAllocator* allocator, const ObjectIdResolver& resolver) {\n    DAWN_UNUSED(allocator);\n\n    ASSERT(transfer->commandId == WireCmd::CommandEncoderBeginRenderPass);\n    record->selfId = transfer->self;\n\n\n    WIRE_TRY(resolver.GetFromId(transfer->self, &record->self));\n    static_assert(sizeof(record->result) >= sizeof(transfer->result), \"Deserialize assignment may not narrow.\");\n    record->result = transfer->result;\n    {\n        auto memberLength = 1u;\n        const volatile WGPURenderPassDescriptorTransfer* memberBuffer;\n        WIRE_TRY(deserializeBuffer->ReadN(memberLength, &memberBuffer));\n\n        WGPURenderPassDescriptor* copiedMembers;\n        WIRE_TRY(GetSpace(allocator, memberLength, &copiedMembers));\n        record->descriptor = copiedMembers;\n\n        for (decltype(memberLength) i = 0; i < memberLength; ++i) {\n            WIRE_TRY(WGPURenderPassDescriptorDeserialize(&copiedMembers[i], &memberBuffer[i], deserializeBuffer, allocator, resolver));\n        }\n    }\n\n    return WireResult::Success;\n}\nDAWN_UNUSED_FUNC(CommandEncoderBeginRenderPassDeserialize);\n\nstruct CommandEncoderClearBufferTransfer : CmdHeader {\n    static_assert(1 <= 1,\n                  \"Record must be at most one of is_cmd, extensible, and chained.\");\n    WireCmd commandId;\n\n    ObjectId self;\n    ObjectId buffer;\n    uint64_t offset;\n    uint64_t size;\n};\n\nstatic_assert(offsetof(CommandEncoderClearBufferTransfer, commandSize) == 0);\nstatic_assert(offsetof(CommandEncoderClearBufferTransfer, commandId) == sizeof(CmdHeader));\n\nDAWN_DECLARE_UNUSED size_t CommandEncoderClearBufferGetExtraRequiredSize(const CommandEncoderClearBufferCmd& record) {\n    DAWN_UNUSED(record);\n    size_t result = 0;\n\n    return result;\n}\n// GetExtraRequiredSize isn't used for structures that are value members of other structures\n// because we assume they cannot contain pointers themselves.\nDAWN_UNUSED_FUNC(CommandEncoderClearBufferGetExtraRequiredSize);\n\nDAWN_DECLARE_UNUSED WireResult CommandEncoderClearBufferSerialize(\n    const CommandEncoderClearBufferCmd& record,\n    CommandEncoderClearBufferTransfer* transfer,\n    SerializeBuffer* buffer, const ObjectIdProvider& provider) {\n    DAWN_UNUSED(buffer);\n    transfer->commandId = WireCmd::CommandEncoderClearBuffer;\n\n\n    WIRE_TRY(provider.GetId(record.self, &transfer->self));\n    WIRE_TRY(provider.GetId(record.buffer, &transfer->buffer));\n    transfer->offset = record.offset;\n    transfer->size = record.size;\n\n    return WireResult::Success;\n}\nDAWN_UNUSED_FUNC(CommandEncoderClearBufferSerialize);\n\nDAWN_DECLARE_UNUSED WireResult CommandEncoderClearBufferDeserialize(\n    CommandEncoderClearBufferCmd* record,\n    const volatile CommandEncoderClearBufferTransfer* transfer,\n    DeserializeBuffer* deserializeBuffer,\n    DeserializeAllocator* allocator, const ObjectIdResolver& resolver) {\n    DAWN_UNUSED(allocator);\n\n    ASSERT(transfer->commandId == WireCmd::CommandEncoderClearBuffer);\n    record->selfId = transfer->self;\n\n\n    WIRE_TRY(resolver.GetFromId(transfer->self, &record->self));\n    WIRE_TRY(resolver.GetFromId(transfer->buffer, &record->buffer));\n    static_assert(sizeof(record->offset) >= sizeof(transfer->offset), \"Deserialize assignment may not narrow.\");\n    record->offset = transfer->offset;\n    static_assert(sizeof(record->size) >= sizeof(transfer->size), \"Deserialize assignment may not narrow.\");\n    record->size = transfer->size;\n\n    return WireResult::Success;\n}\nDAWN_UNUSED_FUNC(CommandEncoderClearBufferDeserialize);\n\nstruct CommandEncoderCopyBufferToBufferTransfer : CmdHeader {\n    static_assert(1 <= 1,\n                  \"Record must be at most one of is_cmd, extensible, and chained.\");\n    WireCmd commandId;\n\n    ObjectId self;\n    ObjectId source;\n    uint64_t sourceOffset;\n    ObjectId destination;\n    uint64_t destinationOffset;\n    uint64_t size;\n};\n\nstatic_assert(offsetof(CommandEncoderCopyBufferToBufferTransfer, commandSize) == 0);\nstatic_assert(offsetof(CommandEncoderCopyBufferToBufferTransfer, commandId) == sizeof(CmdHeader));\n\nDAWN_DECLARE_UNUSED size_t CommandEncoderCopyBufferToBufferGetExtraRequiredSize(const CommandEncoderCopyBufferToBufferCmd& record) {\n    DAWN_UNUSED(record);\n    size_t result = 0;\n\n    return result;\n}\n// GetExtraRequiredSize isn't used for structures that are value members of other structures\n// because we assume they cannot contain pointers themselves.\nDAWN_UNUSED_FUNC(CommandEncoderCopyBufferToBufferGetExtraRequiredSize);\n\nDAWN_DECLARE_UNUSED WireResult CommandEncoderCopyBufferToBufferSerialize(\n    const CommandEncoderCopyBufferToBufferCmd& record,\n    CommandEncoderCopyBufferToBufferTransfer* transfer,\n    SerializeBuffer* buffer, const ObjectIdProvider& provider) {\n    DAWN_UNUSED(buffer);\n    transfer->commandId = WireCmd::CommandEncoderCopyBufferToBuffer;\n\n\n    WIRE_TRY(provider.GetId(record.self, &transfer->self));\n    WIRE_TRY(provider.GetId(record.source, &transfer->source));\n    transfer->sourceOffset = record.sourceOffset;\n    WIRE_TRY(provider.GetId(record.destination, &transfer->destination));\n    transfer->destinationOffset = record.destinationOffset;\n    transfer->size = record.size;\n\n    return WireResult::Success;\n}\nDAWN_UNUSED_FUNC(CommandEncoderCopyBufferToBufferSerialize);\n\nDAWN_DECLARE_UNUSED WireResult CommandEncoderCopyBufferToBufferDeserialize(\n    CommandEncoderCopyBufferToBufferCmd* record,\n    const volatile CommandEncoderCopyBufferToBufferTransfer* transfer,\n    DeserializeBuffer* deserializeBuffer,\n    DeserializeAllocator* allocator, const ObjectIdResolver& resolver) {\n    DAWN_UNUSED(allocator);\n\n    ASSERT(transfer->commandId == WireCmd::CommandEncoderCopyBufferToBuffer);\n    record->selfId = transfer->self;\n\n\n    WIRE_TRY(resolver.GetFromId(transfer->self, &record->self));\n    WIRE_TRY(resolver.GetFromId(transfer->source, &record->source));\n    static_assert(sizeof(record->sourceOffset) >= sizeof(transfer->sourceOffset), \"Deserialize assignment may not narrow.\");\n    record->sourceOffset = transfer->sourceOffset;\n    WIRE_TRY(resolver.GetFromId(transfer->destination, &record->destination));\n    static_assert(sizeof(record->destinationOffset) >= sizeof(transfer->destinationOffset), \"Deserialize assignment may not narrow.\");\n    record->destinationOffset = transfer->destinationOffset;\n    static_assert(sizeof(record->size) >= sizeof(transfer->size), \"Deserialize assignment may not narrow.\");\n    record->size = transfer->size;\n\n    return WireResult::Success;\n}\nDAWN_UNUSED_FUNC(CommandEncoderCopyBufferToBufferDeserialize);\n\nstruct CommandEncoderCopyBufferToTextureTransfer : CmdHeader {\n    static_assert(1 <= 1,\n                  \"Record must be at most one of is_cmd, extensible, and chained.\");\n    WireCmd commandId;\n\n    ObjectId self;\n};\n\nstatic_assert(offsetof(CommandEncoderCopyBufferToTextureTransfer, commandSize) == 0);\nstatic_assert(offsetof(CommandEncoderCopyBufferToTextureTransfer, commandId) == sizeof(CmdHeader));\n\nDAWN_DECLARE_UNUSED size_t CommandEncoderCopyBufferToTextureGetExtraRequiredSize(const CommandEncoderCopyBufferToTextureCmd& record) {\n    DAWN_UNUSED(record);\n    size_t result = 0;\n\n    {\n        auto memberLength = 1u;\n        auto size = WireAlignSizeofN<WGPUImageCopyBufferTransfer>(memberLength);\n        ASSERT(size);\n        result += *size;\n        for (decltype(memberLength) i = 0; i < memberLength; ++i) {\n            result += WGPUImageCopyBufferGetExtraRequiredSize(record.source[i]);\n        }\n    }\n    {\n        auto memberLength = 1u;\n        auto size = WireAlignSizeofN<WGPUImageCopyTextureTransfer>(memberLength);\n        ASSERT(size);\n        result += *size;\n        for (decltype(memberLength) i = 0; i < memberLength; ++i) {\n            result += WGPUImageCopyTextureGetExtraRequiredSize(record.destination[i]);\n        }\n    }\n    {\n        auto memberLength = 1u;\n        auto size = WireAlignSizeofN<WGPUExtent3DTransfer>(memberLength);\n        ASSERT(size);\n        result += *size;\n        for (decltype(memberLength) i = 0; i < memberLength; ++i) {\n            result += WGPUExtent3DGetExtraRequiredSize(record.copySize[i]);\n        }\n    }\n    return result;\n}\n// GetExtraRequiredSize isn't used for structures that are value members of other structures\n// because we assume they cannot contain pointers themselves.\nDAWN_UNUSED_FUNC(CommandEncoderCopyBufferToTextureGetExtraRequiredSize);\n\nDAWN_DECLARE_UNUSED WireResult CommandEncoderCopyBufferToTextureSerialize(\n    const CommandEncoderCopyBufferToTextureCmd& record,\n    CommandEncoderCopyBufferToTextureTransfer* transfer,\n    SerializeBuffer* buffer, const ObjectIdProvider& provider) {\n    DAWN_UNUSED(buffer);\n    transfer->commandId = WireCmd::CommandEncoderCopyBufferToTexture;\n\n\n    WIRE_TRY(provider.GetId(record.self, &transfer->self));\n    {\n        auto memberLength = 1u;\n\n        WGPUImageCopyBufferTransfer* memberBuffer;\n        WIRE_TRY(buffer->NextN(memberLength, &memberBuffer));\n\n        for (decltype(memberLength) i = 0; i < memberLength; ++i) {\n            WIRE_TRY(WGPUImageCopyBufferSerialize(record.source[i], &memberBuffer[i], buffer, provider));\n        }\n    }\n    {\n        auto memberLength = 1u;\n\n        WGPUImageCopyTextureTransfer* memberBuffer;\n        WIRE_TRY(buffer->NextN(memberLength, &memberBuffer));\n\n        for (decltype(memberLength) i = 0; i < memberLength; ++i) {\n            WIRE_TRY(WGPUImageCopyTextureSerialize(record.destination[i], &memberBuffer[i], buffer, provider));\n        }\n    }\n    {\n        auto memberLength = 1u;\n\n        WGPUExtent3DTransfer* memberBuffer;\n        WIRE_TRY(buffer->NextN(memberLength, &memberBuffer));\n\n        memcpy(\n            memberBuffer, record.copySize,\n            sizeof(WGPUExtent3DTransfer) * memberLength);\n    }\n\n    return WireResult::Success;\n}\nDAWN_UNUSED_FUNC(CommandEncoderCopyBufferToTextureSerialize);\n\nDAWN_DECLARE_UNUSED WireResult CommandEncoderCopyBufferToTextureDeserialize(\n    CommandEncoderCopyBufferToTextureCmd* record,\n    const volatile CommandEncoderCopyBufferToTextureTransfer* transfer,\n    DeserializeBuffer* deserializeBuffer,\n    DeserializeAllocator* allocator, const ObjectIdResolver& resolver) {\n    DAWN_UNUSED(allocator);\n\n    ASSERT(transfer->commandId == WireCmd::CommandEncoderCopyBufferToTexture);\n    record->selfId = transfer->self;\n\n\n    WIRE_TRY(resolver.GetFromId(transfer->self, &record->self));\n    {\n        auto memberLength = 1u;\n        const volatile WGPUImageCopyBufferTransfer* memberBuffer;\n        WIRE_TRY(deserializeBuffer->ReadN(memberLength, &memberBuffer));\n\n        WGPUImageCopyBuffer* copiedMembers;\n        WIRE_TRY(GetSpace(allocator, memberLength, &copiedMembers));\n        record->source = copiedMembers;\n\n        for (decltype(memberLength) i = 0; i < memberLength; ++i) {\n            WIRE_TRY(WGPUImageCopyBufferDeserialize(&copiedMembers[i], &memberBuffer[i], deserializeBuffer, allocator, resolver));\n        }\n    }\n    {\n        auto memberLength = 1u;\n        const volatile WGPUImageCopyTextureTransfer* memberBuffer;\n        WIRE_TRY(deserializeBuffer->ReadN(memberLength, &memberBuffer));\n\n        WGPUImageCopyTexture* copiedMembers;\n        WIRE_TRY(GetSpace(allocator, memberLength, &copiedMembers));\n        record->destination = copiedMembers;\n\n        for (decltype(memberLength) i = 0; i < memberLength; ++i) {\n            WIRE_TRY(WGPUImageCopyTextureDeserialize(&copiedMembers[i], &memberBuffer[i], deserializeBuffer, allocator, resolver));\n        }\n    }\n    {\n        auto memberLength = 1u;\n        const volatile WGPUExtent3DTransfer* memberBuffer;\n        WIRE_TRY(deserializeBuffer->ReadN(memberLength, &memberBuffer));\n\n        WGPUExtent3D* copiedMembers;\n        WIRE_TRY(GetSpace(allocator, memberLength, &copiedMembers));\n        record->copySize = copiedMembers;\n\n        memcpy(\n            copiedMembers,\n            const_cast<const WGPUExtent3DTransfer*>(memberBuffer),\n           sizeof(WGPUExtent3DTransfer) * memberLength);\n    }\n\n    return WireResult::Success;\n}\nDAWN_UNUSED_FUNC(CommandEncoderCopyBufferToTextureDeserialize);\n\nstruct CommandEncoderCopyTextureToBufferTransfer : CmdHeader {\n    static_assert(1 <= 1,\n                  \"Record must be at most one of is_cmd, extensible, and chained.\");\n    WireCmd commandId;\n\n    ObjectId self;\n};\n\nstatic_assert(offsetof(CommandEncoderCopyTextureToBufferTransfer, commandSize) == 0);\nstatic_assert(offsetof(CommandEncoderCopyTextureToBufferTransfer, commandId) == sizeof(CmdHeader));\n\nDAWN_DECLARE_UNUSED size_t CommandEncoderCopyTextureToBufferGetExtraRequiredSize(const CommandEncoderCopyTextureToBufferCmd& record) {\n    DAWN_UNUSED(record);\n    size_t result = 0;\n\n    {\n        auto memberLength = 1u;\n        auto size = WireAlignSizeofN<WGPUImageCopyTextureTransfer>(memberLength);\n        ASSERT(size);\n        result += *size;\n        for (decltype(memberLength) i = 0; i < memberLength; ++i) {\n            result += WGPUImageCopyTextureGetExtraRequiredSize(record.source[i]);\n        }\n    }\n    {\n        auto memberLength = 1u;\n        auto size = WireAlignSizeofN<WGPUImageCopyBufferTransfer>(memberLength);\n        ASSERT(size);\n        result += *size;\n        for (decltype(memberLength) i = 0; i < memberLength; ++i) {\n            result += WGPUImageCopyBufferGetExtraRequiredSize(record.destination[i]);\n        }\n    }\n    {\n        auto memberLength = 1u;\n        auto size = WireAlignSizeofN<WGPUExtent3DTransfer>(memberLength);\n        ASSERT(size);\n        result += *size;\n        for (decltype(memberLength) i = 0; i < memberLength; ++i) {\n            result += WGPUExtent3DGetExtraRequiredSize(record.copySize[i]);\n        }\n    }\n    return result;\n}\n// GetExtraRequiredSize isn't used for structures that are value members of other structures\n// because we assume they cannot contain pointers themselves.\nDAWN_UNUSED_FUNC(CommandEncoderCopyTextureToBufferGetExtraRequiredSize);\n\nDAWN_DECLARE_UNUSED WireResult CommandEncoderCopyTextureToBufferSerialize(\n    const CommandEncoderCopyTextureToBufferCmd& record,\n    CommandEncoderCopyTextureToBufferTransfer* transfer,\n    SerializeBuffer* buffer, const ObjectIdProvider& provider) {\n    DAWN_UNUSED(buffer);\n    transfer->commandId = WireCmd::CommandEncoderCopyTextureToBuffer;\n\n\n    WIRE_TRY(provider.GetId(record.self, &transfer->self));\n    {\n        auto memberLength = 1u;\n\n        WGPUImageCopyTextureTransfer* memberBuffer;\n        WIRE_TRY(buffer->NextN(memberLength, &memberBuffer));\n\n        for (decltype(memberLength) i = 0; i < memberLength; ++i) {\n            WIRE_TRY(WGPUImageCopyTextureSerialize(record.source[i], &memberBuffer[i], buffer, provider));\n        }\n    }\n    {\n        auto memberLength = 1u;\n\n        WGPUImageCopyBufferTransfer* memberBuffer;\n        WIRE_TRY(buffer->NextN(memberLength, &memberBuffer));\n\n        for (decltype(memberLength) i = 0; i < memberLength; ++i) {\n            WIRE_TRY(WGPUImageCopyBufferSerialize(record.destination[i], &memberBuffer[i], buffer, provider));\n        }\n    }\n    {\n        auto memberLength = 1u;\n\n        WGPUExtent3DTransfer* memberBuffer;\n        WIRE_TRY(buffer->NextN(memberLength, &memberBuffer));\n\n        memcpy(\n            memberBuffer, record.copySize,\n            sizeof(WGPUExtent3DTransfer) * memberLength);\n    }\n\n    return WireResult::Success;\n}\nDAWN_UNUSED_FUNC(CommandEncoderCopyTextureToBufferSerialize);\n\nDAWN_DECLARE_UNUSED WireResult CommandEncoderCopyTextureToBufferDeserialize(\n    CommandEncoderCopyTextureToBufferCmd* record,\n    const volatile CommandEncoderCopyTextureToBufferTransfer* transfer,\n    DeserializeBuffer* deserializeBuffer,\n    DeserializeAllocator* allocator, const ObjectIdResolver& resolver) {\n    DAWN_UNUSED(allocator);\n\n    ASSERT(transfer->commandId == WireCmd::CommandEncoderCopyTextureToBuffer);\n    record->selfId = transfer->self;\n\n\n    WIRE_TRY(resolver.GetFromId(transfer->self, &record->self));\n    {\n        auto memberLength = 1u;\n        const volatile WGPUImageCopyTextureTransfer* memberBuffer;\n        WIRE_TRY(deserializeBuffer->ReadN(memberLength, &memberBuffer));\n\n        WGPUImageCopyTexture* copiedMembers;\n        WIRE_TRY(GetSpace(allocator, memberLength, &copiedMembers));\n        record->source = copiedMembers;\n\n        for (decltype(memberLength) i = 0; i < memberLength; ++i) {\n            WIRE_TRY(WGPUImageCopyTextureDeserialize(&copiedMembers[i], &memberBuffer[i], deserializeBuffer, allocator, resolver));\n        }\n    }\n    {\n        auto memberLength = 1u;\n        const volatile WGPUImageCopyBufferTransfer* memberBuffer;\n        WIRE_TRY(deserializeBuffer->ReadN(memberLength, &memberBuffer));\n\n        WGPUImageCopyBuffer* copiedMembers;\n        WIRE_TRY(GetSpace(allocator, memberLength, &copiedMembers));\n        record->destination = copiedMembers;\n\n        for (decltype(memberLength) i = 0; i < memberLength; ++i) {\n            WIRE_TRY(WGPUImageCopyBufferDeserialize(&copiedMembers[i], &memberBuffer[i], deserializeBuffer, allocator, resolver));\n        }\n    }\n    {\n        auto memberLength = 1u;\n        const volatile WGPUExtent3DTransfer* memberBuffer;\n        WIRE_TRY(deserializeBuffer->ReadN(memberLength, &memberBuffer));\n\n        WGPUExtent3D* copiedMembers;\n        WIRE_TRY(GetSpace(allocator, memberLength, &copiedMembers));\n        record->copySize = copiedMembers;\n\n        memcpy(\n            copiedMembers,\n            const_cast<const WGPUExtent3DTransfer*>(memberBuffer),\n           sizeof(WGPUExtent3DTransfer) * memberLength);\n    }\n\n    return WireResult::Success;\n}\nDAWN_UNUSED_FUNC(CommandEncoderCopyTextureToBufferDeserialize);\n\nstruct CommandEncoderCopyTextureToTextureTransfer : CmdHeader {\n    static_assert(1 <= 1,\n                  \"Record must be at most one of is_cmd, extensible, and chained.\");\n    WireCmd commandId;\n\n    ObjectId self;\n};\n\nstatic_assert(offsetof(CommandEncoderCopyTextureToTextureTransfer, commandSize) == 0);\nstatic_assert(offsetof(CommandEncoderCopyTextureToTextureTransfer, commandId) == sizeof(CmdHeader));\n\nDAWN_DECLARE_UNUSED size_t CommandEncoderCopyTextureToTextureGetExtraRequiredSize(const CommandEncoderCopyTextureToTextureCmd& record) {\n    DAWN_UNUSED(record);\n    size_t result = 0;\n\n    {\n        auto memberLength = 1u;\n        auto size = WireAlignSizeofN<WGPUImageCopyTextureTransfer>(memberLength);\n        ASSERT(size);\n        result += *size;\n        for (decltype(memberLength) i = 0; i < memberLength; ++i) {\n            result += WGPUImageCopyTextureGetExtraRequiredSize(record.source[i]);\n        }\n    }\n    {\n        auto memberLength = 1u;\n        auto size = WireAlignSizeofN<WGPUImageCopyTextureTransfer>(memberLength);\n        ASSERT(size);\n        result += *size;\n        for (decltype(memberLength) i = 0; i < memberLength; ++i) {\n            result += WGPUImageCopyTextureGetExtraRequiredSize(record.destination[i]);\n        }\n    }\n    {\n        auto memberLength = 1u;\n        auto size = WireAlignSizeofN<WGPUExtent3DTransfer>(memberLength);\n        ASSERT(size);\n        result += *size;\n        for (decltype(memberLength) i = 0; i < memberLength; ++i) {\n            result += WGPUExtent3DGetExtraRequiredSize(record.copySize[i]);\n        }\n    }\n    return result;\n}\n// GetExtraRequiredSize isn't used for structures that are value members of other structures\n// because we assume they cannot contain pointers themselves.\nDAWN_UNUSED_FUNC(CommandEncoderCopyTextureToTextureGetExtraRequiredSize);\n\nDAWN_DECLARE_UNUSED WireResult CommandEncoderCopyTextureToTextureSerialize(\n    const CommandEncoderCopyTextureToTextureCmd& record,\n    CommandEncoderCopyTextureToTextureTransfer* transfer,\n    SerializeBuffer* buffer, const ObjectIdProvider& provider) {\n    DAWN_UNUSED(buffer);\n    transfer->commandId = WireCmd::CommandEncoderCopyTextureToTexture;\n\n\n    WIRE_TRY(provider.GetId(record.self, &transfer->self));\n    {\n        auto memberLength = 1u;\n\n        WGPUImageCopyTextureTransfer* memberBuffer;\n        WIRE_TRY(buffer->NextN(memberLength, &memberBuffer));\n\n        for (decltype(memberLength) i = 0; i < memberLength; ++i) {\n            WIRE_TRY(WGPUImageCopyTextureSerialize(record.source[i], &memberBuffer[i], buffer, provider));\n        }\n    }\n    {\n        auto memberLength = 1u;\n\n        WGPUImageCopyTextureTransfer* memberBuffer;\n        WIRE_TRY(buffer->NextN(memberLength, &memberBuffer));\n\n        for (decltype(memberLength) i = 0; i < memberLength; ++i) {\n            WIRE_TRY(WGPUImageCopyTextureSerialize(record.destination[i], &memberBuffer[i], buffer, provider));\n        }\n    }\n    {\n        auto memberLength = 1u;\n\n        WGPUExtent3DTransfer* memberBuffer;\n        WIRE_TRY(buffer->NextN(memberLength, &memberBuffer));\n\n        memcpy(\n            memberBuffer, record.copySize,\n            sizeof(WGPUExtent3DTransfer) * memberLength);\n    }\n\n    return WireResult::Success;\n}\nDAWN_UNUSED_FUNC(CommandEncoderCopyTextureToTextureSerialize);\n\nDAWN_DECLARE_UNUSED WireResult CommandEncoderCopyTextureToTextureDeserialize(\n    CommandEncoderCopyTextureToTextureCmd* record,\n    const volatile CommandEncoderCopyTextureToTextureTransfer* transfer,\n    DeserializeBuffer* deserializeBuffer,\n    DeserializeAllocator* allocator, const ObjectIdResolver& resolver) {\n    DAWN_UNUSED(allocator);\n\n    ASSERT(transfer->commandId == WireCmd::CommandEncoderCopyTextureToTexture);\n    record->selfId = transfer->self;\n\n\n    WIRE_TRY(resolver.GetFromId(transfer->self, &record->self));\n    {\n        auto memberLength = 1u;\n        const volatile WGPUImageCopyTextureTransfer* memberBuffer;\n        WIRE_TRY(deserializeBuffer->ReadN(memberLength, &memberBuffer));\n\n        WGPUImageCopyTexture* copiedMembers;\n        WIRE_TRY(GetSpace(allocator, memberLength, &copiedMembers));\n        record->source = copiedMembers;\n\n        for (decltype(memberLength) i = 0; i < memberLength; ++i) {\n            WIRE_TRY(WGPUImageCopyTextureDeserialize(&copiedMembers[i], &memberBuffer[i], deserializeBuffer, allocator, resolver));\n        }\n    }\n    {\n        auto memberLength = 1u;\n        const volatile WGPUImageCopyTextureTransfer* memberBuffer;\n        WIRE_TRY(deserializeBuffer->ReadN(memberLength, &memberBuffer));\n\n        WGPUImageCopyTexture* copiedMembers;\n        WIRE_TRY(GetSpace(allocator, memberLength, &copiedMembers));\n        record->destination = copiedMembers;\n\n        for (decltype(memberLength) i = 0; i < memberLength; ++i) {\n            WIRE_TRY(WGPUImageCopyTextureDeserialize(&copiedMembers[i], &memberBuffer[i], deserializeBuffer, allocator, resolver));\n        }\n    }\n    {\n        auto memberLength = 1u;\n        const volatile WGPUExtent3DTransfer* memberBuffer;\n        WIRE_TRY(deserializeBuffer->ReadN(memberLength, &memberBuffer));\n\n        WGPUExtent3D* copiedMembers;\n        WIRE_TRY(GetSpace(allocator, memberLength, &copiedMembers));\n        record->copySize = copiedMembers;\n\n        memcpy(\n            copiedMembers,\n            const_cast<const WGPUExtent3DTransfer*>(memberBuffer),\n           sizeof(WGPUExtent3DTransfer) * memberLength);\n    }\n\n    return WireResult::Success;\n}\nDAWN_UNUSED_FUNC(CommandEncoderCopyTextureToTextureDeserialize);\n\nstruct CommandEncoderCopyTextureToTextureInternalTransfer : CmdHeader {\n    static_assert(1 <= 1,\n                  \"Record must be at most one of is_cmd, extensible, and chained.\");\n    WireCmd commandId;\n\n    ObjectId self;\n};\n\nstatic_assert(offsetof(CommandEncoderCopyTextureToTextureInternalTransfer, commandSize) == 0);\nstatic_assert(offsetof(CommandEncoderCopyTextureToTextureInternalTransfer, commandId) == sizeof(CmdHeader));\n\nDAWN_DECLARE_UNUSED size_t CommandEncoderCopyTextureToTextureInternalGetExtraRequiredSize(const CommandEncoderCopyTextureToTextureInternalCmd& record) {\n    DAWN_UNUSED(record);\n    size_t result = 0;\n\n    {\n        auto memberLength = 1u;\n        auto size = WireAlignSizeofN<WGPUImageCopyTextureTransfer>(memberLength);\n        ASSERT(size);\n        result += *size;\n        for (decltype(memberLength) i = 0; i < memberLength; ++i) {\n            result += WGPUImageCopyTextureGetExtraRequiredSize(record.source[i]);\n        }\n    }\n    {\n        auto memberLength = 1u;\n        auto size = WireAlignSizeofN<WGPUImageCopyTextureTransfer>(memberLength);\n        ASSERT(size);\n        result += *size;\n        for (decltype(memberLength) i = 0; i < memberLength; ++i) {\n            result += WGPUImageCopyTextureGetExtraRequiredSize(record.destination[i]);\n        }\n    }\n    {\n        auto memberLength = 1u;\n        auto size = WireAlignSizeofN<WGPUExtent3DTransfer>(memberLength);\n        ASSERT(size);\n        result += *size;\n        for (decltype(memberLength) i = 0; i < memberLength; ++i) {\n            result += WGPUExtent3DGetExtraRequiredSize(record.copySize[i]);\n        }\n    }\n    return result;\n}\n// GetExtraRequiredSize isn't used for structures that are value members of other structures\n// because we assume they cannot contain pointers themselves.\nDAWN_UNUSED_FUNC(CommandEncoderCopyTextureToTextureInternalGetExtraRequiredSize);\n\nDAWN_DECLARE_UNUSED WireResult CommandEncoderCopyTextureToTextureInternalSerialize(\n    const CommandEncoderCopyTextureToTextureInternalCmd& record,\n    CommandEncoderCopyTextureToTextureInternalTransfer* transfer,\n    SerializeBuffer* buffer, const ObjectIdProvider& provider) {\n    DAWN_UNUSED(buffer);\n    transfer->commandId = WireCmd::CommandEncoderCopyTextureToTextureInternal;\n\n\n    WIRE_TRY(provider.GetId(record.self, &transfer->self));\n    {\n        auto memberLength = 1u;\n\n        WGPUImageCopyTextureTransfer* memberBuffer;\n        WIRE_TRY(buffer->NextN(memberLength, &memberBuffer));\n\n        for (decltype(memberLength) i = 0; i < memberLength; ++i) {\n            WIRE_TRY(WGPUImageCopyTextureSerialize(record.source[i], &memberBuffer[i], buffer, provider));\n        }\n    }\n    {\n        auto memberLength = 1u;\n\n        WGPUImageCopyTextureTransfer* memberBuffer;\n        WIRE_TRY(buffer->NextN(memberLength, &memberBuffer));\n\n        for (decltype(memberLength) i = 0; i < memberLength; ++i) {\n            WIRE_TRY(WGPUImageCopyTextureSerialize(record.destination[i], &memberBuffer[i], buffer, provider));\n        }\n    }\n    {\n        auto memberLength = 1u;\n\n        WGPUExtent3DTransfer* memberBuffer;\n        WIRE_TRY(buffer->NextN(memberLength, &memberBuffer));\n\n        memcpy(\n            memberBuffer, record.copySize,\n            sizeof(WGPUExtent3DTransfer) * memberLength);\n    }\n\n    return WireResult::Success;\n}\nDAWN_UNUSED_FUNC(CommandEncoderCopyTextureToTextureInternalSerialize);\n\nDAWN_DECLARE_UNUSED WireResult CommandEncoderCopyTextureToTextureInternalDeserialize(\n    CommandEncoderCopyTextureToTextureInternalCmd* record,\n    const volatile CommandEncoderCopyTextureToTextureInternalTransfer* transfer,\n    DeserializeBuffer* deserializeBuffer,\n    DeserializeAllocator* allocator, const ObjectIdResolver& resolver) {\n    DAWN_UNUSED(allocator);\n\n    ASSERT(transfer->commandId == WireCmd::CommandEncoderCopyTextureToTextureInternal);\n    record->selfId = transfer->self;\n\n\n    WIRE_TRY(resolver.GetFromId(transfer->self, &record->self));\n    {\n        auto memberLength = 1u;\n        const volatile WGPUImageCopyTextureTransfer* memberBuffer;\n        WIRE_TRY(deserializeBuffer->ReadN(memberLength, &memberBuffer));\n\n        WGPUImageCopyTexture* copiedMembers;\n        WIRE_TRY(GetSpace(allocator, memberLength, &copiedMembers));\n        record->source = copiedMembers;\n\n        for (decltype(memberLength) i = 0; i < memberLength; ++i) {\n            WIRE_TRY(WGPUImageCopyTextureDeserialize(&copiedMembers[i], &memberBuffer[i], deserializeBuffer, allocator, resolver));\n        }\n    }\n    {\n        auto memberLength = 1u;\n        const volatile WGPUImageCopyTextureTransfer* memberBuffer;\n        WIRE_TRY(deserializeBuffer->ReadN(memberLength, &memberBuffer));\n\n        WGPUImageCopyTexture* copiedMembers;\n        WIRE_TRY(GetSpace(allocator, memberLength, &copiedMembers));\n        record->destination = copiedMembers;\n\n        for (decltype(memberLength) i = 0; i < memberLength; ++i) {\n            WIRE_TRY(WGPUImageCopyTextureDeserialize(&copiedMembers[i], &memberBuffer[i], deserializeBuffer, allocator, resolver));\n        }\n    }\n    {\n        auto memberLength = 1u;\n        const volatile WGPUExtent3DTransfer* memberBuffer;\n        WIRE_TRY(deserializeBuffer->ReadN(memberLength, &memberBuffer));\n\n        WGPUExtent3D* copiedMembers;\n        WIRE_TRY(GetSpace(allocator, memberLength, &copiedMembers));\n        record->copySize = copiedMembers;\n\n        memcpy(\n            copiedMembers,\n            const_cast<const WGPUExtent3DTransfer*>(memberBuffer),\n           sizeof(WGPUExtent3DTransfer) * memberLength);\n    }\n\n    return WireResult::Success;\n}\nDAWN_UNUSED_FUNC(CommandEncoderCopyTextureToTextureInternalDeserialize);\n\nstruct CommandEncoderFinishTransfer : CmdHeader {\n    static_assert(1 <= 1,\n                  \"Record must be at most one of is_cmd, extensible, and chained.\");\n    WireCmd commandId;\n\n    ObjectId self;\n    bool has_descriptor;\n    ObjectHandle result;\n};\n\nstatic_assert(offsetof(CommandEncoderFinishTransfer, commandSize) == 0);\nstatic_assert(offsetof(CommandEncoderFinishTransfer, commandId) == sizeof(CmdHeader));\n\nDAWN_DECLARE_UNUSED size_t CommandEncoderFinishGetExtraRequiredSize(const CommandEncoderFinishCmd& record) {\n    DAWN_UNUSED(record);\n    size_t result = 0;\n\n    if (record.descriptor != nullptr) {\n        auto memberLength = 1u;\n        auto size = WireAlignSizeofN<WGPUCommandBufferDescriptorTransfer>(memberLength);\n        ASSERT(size);\n        result += *size;\n        for (decltype(memberLength) i = 0; i < memberLength; ++i) {\n            result += WGPUCommandBufferDescriptorGetExtraRequiredSize(record.descriptor[i]);\n        }\n    }\n    return result;\n}\n// GetExtraRequiredSize isn't used for structures that are value members of other structures\n// because we assume they cannot contain pointers themselves.\nDAWN_UNUSED_FUNC(CommandEncoderFinishGetExtraRequiredSize);\n\nDAWN_DECLARE_UNUSED WireResult CommandEncoderFinishSerialize(\n    const CommandEncoderFinishCmd& record,\n    CommandEncoderFinishTransfer* transfer,\n    SerializeBuffer* buffer, const ObjectIdProvider& provider) {\n    DAWN_UNUSED(buffer);\n    transfer->commandId = WireCmd::CommandEncoderFinish;\n\n\n    WIRE_TRY(provider.GetId(record.self, &transfer->self));\n    transfer->result = record.result;\n    bool has_descriptor = record.descriptor != nullptr;\n    transfer->has_descriptor = has_descriptor;\n    if (has_descriptor) {\n        auto memberLength = 1u;\n\n        WGPUCommandBufferDescriptorTransfer* memberBuffer;\n        WIRE_TRY(buffer->NextN(memberLength, &memberBuffer));\n\n        for (decltype(memberLength) i = 0; i < memberLength; ++i) {\n            WIRE_TRY(WGPUCommandBufferDescriptorSerialize(record.descriptor[i], &memberBuffer[i], buffer, provider));\n        }\n    }\n\n    return WireResult::Success;\n}\nDAWN_UNUSED_FUNC(CommandEncoderFinishSerialize);\n\nDAWN_DECLARE_UNUSED WireResult CommandEncoderFinishDeserialize(\n    CommandEncoderFinishCmd* record,\n    const volatile CommandEncoderFinishTransfer* transfer,\n    DeserializeBuffer* deserializeBuffer,\n    DeserializeAllocator* allocator, const ObjectIdResolver& resolver) {\n    DAWN_UNUSED(allocator);\n\n    ASSERT(transfer->commandId == WireCmd::CommandEncoderFinish);\n    record->selfId = transfer->self;\n\n\n    WIRE_TRY(resolver.GetFromId(transfer->self, &record->self));\n    static_assert(sizeof(record->result) >= sizeof(transfer->result), \"Deserialize assignment may not narrow.\");\n    record->result = transfer->result;\n    bool has_descriptor = transfer->has_descriptor;\n    record->descriptor = nullptr;\n    if (has_descriptor) {\n        auto memberLength = 1u;\n        const volatile WGPUCommandBufferDescriptorTransfer* memberBuffer;\n        WIRE_TRY(deserializeBuffer->ReadN(memberLength, &memberBuffer));\n\n        WGPUCommandBufferDescriptor* copiedMembers;\n        WIRE_TRY(GetSpace(allocator, memberLength, &copiedMembers));\n        record->descriptor = copiedMembers;\n\n        for (decltype(memberLength) i = 0; i < memberLength; ++i) {\n            WIRE_TRY(WGPUCommandBufferDescriptorDeserialize(&copiedMembers[i], &memberBuffer[i], deserializeBuffer, allocator, resolver));\n        }\n    }\n\n    return WireResult::Success;\n}\nDAWN_UNUSED_FUNC(CommandEncoderFinishDeserialize);\n\nstruct CommandEncoderInjectValidationErrorTransfer : CmdHeader {\n    static_assert(1 <= 1,\n                  \"Record must be at most one of is_cmd, extensible, and chained.\");\n    WireCmd commandId;\n\n    ObjectId self;\n    uint64_t messageStrlen;\n};\n\nstatic_assert(offsetof(CommandEncoderInjectValidationErrorTransfer, commandSize) == 0);\nstatic_assert(offsetof(CommandEncoderInjectValidationErrorTransfer, commandId) == sizeof(CmdHeader));\n\nDAWN_DECLARE_UNUSED size_t CommandEncoderInjectValidationErrorGetExtraRequiredSize(const CommandEncoderInjectValidationErrorCmd& record) {\n    DAWN_UNUSED(record);\n    size_t result = 0;\n\n    ASSERT(record.message != nullptr);\n    result += Align(std::strlen(record.message), kWireBufferAlignment);\n    return result;\n}\n// GetExtraRequiredSize isn't used for structures that are value members of other structures\n// because we assume they cannot contain pointers themselves.\nDAWN_UNUSED_FUNC(CommandEncoderInjectValidationErrorGetExtraRequiredSize);\n\nDAWN_DECLARE_UNUSED WireResult CommandEncoderInjectValidationErrorSerialize(\n    const CommandEncoderInjectValidationErrorCmd& record,\n    CommandEncoderInjectValidationErrorTransfer* transfer,\n    SerializeBuffer* buffer, const ObjectIdProvider& provider) {\n    DAWN_UNUSED(buffer);\n    transfer->commandId = WireCmd::CommandEncoderInjectValidationError;\n\n\n    WIRE_TRY(provider.GetId(record.self, &transfer->self));\n    {\n        transfer->messageStrlen = std::strlen(record.message);\n\n        char* stringInBuffer;\n        WIRE_TRY(buffer->NextN(transfer->messageStrlen, &stringInBuffer));\n        memcpy(stringInBuffer, record.message, transfer->messageStrlen);\n    }\n\n    return WireResult::Success;\n}\nDAWN_UNUSED_FUNC(CommandEncoderInjectValidationErrorSerialize);\n\nDAWN_DECLARE_UNUSED WireResult CommandEncoderInjectValidationErrorDeserialize(\n    CommandEncoderInjectValidationErrorCmd* record,\n    const volatile CommandEncoderInjectValidationErrorTransfer* transfer,\n    DeserializeBuffer* deserializeBuffer,\n    DeserializeAllocator* allocator, const ObjectIdResolver& resolver) {\n    DAWN_UNUSED(allocator);\n\n    ASSERT(transfer->commandId == WireCmd::CommandEncoderInjectValidationError);\n    record->selfId = transfer->self;\n\n\n    WIRE_TRY(resolver.GetFromId(transfer->self, &record->self));\n    {\n        uint64_t stringLength64 = transfer->messageStrlen;\n        if (stringLength64 >= std::numeric_limits<size_t>::max()) {\n            return WireResult::FatalError;\n        }\n        size_t stringLength = static_cast<size_t>(stringLength64);\n\n        const volatile char* stringInBuffer;\n        WIRE_TRY(deserializeBuffer->ReadN(stringLength, &stringInBuffer));\n\n        char* copiedString;\n        WIRE_TRY(GetSpace(allocator, stringLength + 1, &copiedString));\n        memcpy(copiedString, const_cast<const char*>(stringInBuffer), stringLength);\n        copiedString[stringLength] = '\\0';\n        record->message = copiedString;\n    }\n\n    return WireResult::Success;\n}\nDAWN_UNUSED_FUNC(CommandEncoderInjectValidationErrorDeserialize);\n\nstruct CommandEncoderInsertDebugMarkerTransfer : CmdHeader {\n    static_assert(1 <= 1,\n                  \"Record must be at most one of is_cmd, extensible, and chained.\");\n    WireCmd commandId;\n\n    ObjectId self;\n    uint64_t markerLabelStrlen;\n};\n\nstatic_assert(offsetof(CommandEncoderInsertDebugMarkerTransfer, commandSize) == 0);\nstatic_assert(offsetof(CommandEncoderInsertDebugMarkerTransfer, commandId) == sizeof(CmdHeader));\n\nDAWN_DECLARE_UNUSED size_t CommandEncoderInsertDebugMarkerGetExtraRequiredSize(const CommandEncoderInsertDebugMarkerCmd& record) {\n    DAWN_UNUSED(record);\n    size_t result = 0;\n\n    ASSERT(record.markerLabel != nullptr);\n    result += Align(std::strlen(record.markerLabel), kWireBufferAlignment);\n    return result;\n}\n// GetExtraRequiredSize isn't used for structures that are value members of other structures\n// because we assume they cannot contain pointers themselves.\nDAWN_UNUSED_FUNC(CommandEncoderInsertDebugMarkerGetExtraRequiredSize);\n\nDAWN_DECLARE_UNUSED WireResult CommandEncoderInsertDebugMarkerSerialize(\n    const CommandEncoderInsertDebugMarkerCmd& record,\n    CommandEncoderInsertDebugMarkerTransfer* transfer,\n    SerializeBuffer* buffer, const ObjectIdProvider& provider) {\n    DAWN_UNUSED(buffer);\n    transfer->commandId = WireCmd::CommandEncoderInsertDebugMarker;\n\n\n    WIRE_TRY(provider.GetId(record.self, &transfer->self));\n    {\n        transfer->markerLabelStrlen = std::strlen(record.markerLabel);\n\n        char* stringInBuffer;\n        WIRE_TRY(buffer->NextN(transfer->markerLabelStrlen, &stringInBuffer));\n        memcpy(stringInBuffer, record.markerLabel, transfer->markerLabelStrlen);\n    }\n\n    return WireResult::Success;\n}\nDAWN_UNUSED_FUNC(CommandEncoderInsertDebugMarkerSerialize);\n\nDAWN_DECLARE_UNUSED WireResult CommandEncoderInsertDebugMarkerDeserialize(\n    CommandEncoderInsertDebugMarkerCmd* record,\n    const volatile CommandEncoderInsertDebugMarkerTransfer* transfer,\n    DeserializeBuffer* deserializeBuffer,\n    DeserializeAllocator* allocator, const ObjectIdResolver& resolver) {\n    DAWN_UNUSED(allocator);\n\n    ASSERT(transfer->commandId == WireCmd::CommandEncoderInsertDebugMarker);\n    record->selfId = transfer->self;\n\n\n    WIRE_TRY(resolver.GetFromId(transfer->self, &record->self));\n    {\n        uint64_t stringLength64 = transfer->markerLabelStrlen;\n        if (stringLength64 >= std::numeric_limits<size_t>::max()) {\n            return WireResult::FatalError;\n        }\n        size_t stringLength = static_cast<size_t>(stringLength64);\n\n        const volatile char* stringInBuffer;\n        WIRE_TRY(deserializeBuffer->ReadN(stringLength, &stringInBuffer));\n\n        char* copiedString;\n        WIRE_TRY(GetSpace(allocator, stringLength + 1, &copiedString));\n        memcpy(copiedString, const_cast<const char*>(stringInBuffer), stringLength);\n        copiedString[stringLength] = '\\0';\n        record->markerLabel = copiedString;\n    }\n\n    return WireResult::Success;\n}\nDAWN_UNUSED_FUNC(CommandEncoderInsertDebugMarkerDeserialize);\n\nstruct CommandEncoderPopDebugGroupTransfer : CmdHeader {\n    static_assert(1 <= 1,\n                  \"Record must be at most one of is_cmd, extensible, and chained.\");\n    WireCmd commandId;\n\n    ObjectId self;\n};\n\nstatic_assert(offsetof(CommandEncoderPopDebugGroupTransfer, commandSize) == 0);\nstatic_assert(offsetof(CommandEncoderPopDebugGroupTransfer, commandId) == sizeof(CmdHeader));\n\nDAWN_DECLARE_UNUSED size_t CommandEncoderPopDebugGroupGetExtraRequiredSize(const CommandEncoderPopDebugGroupCmd& record) {\n    DAWN_UNUSED(record);\n    size_t result = 0;\n\n    return result;\n}\n// GetExtraRequiredSize isn't used for structures that are value members of other structures\n// because we assume they cannot contain pointers themselves.\nDAWN_UNUSED_FUNC(CommandEncoderPopDebugGroupGetExtraRequiredSize);\n\nDAWN_DECLARE_UNUSED WireResult CommandEncoderPopDebugGroupSerialize(\n    const CommandEncoderPopDebugGroupCmd& record,\n    CommandEncoderPopDebugGroupTransfer* transfer,\n    SerializeBuffer* buffer, const ObjectIdProvider& provider) {\n    DAWN_UNUSED(buffer);\n    transfer->commandId = WireCmd::CommandEncoderPopDebugGroup;\n\n\n    WIRE_TRY(provider.GetId(record.self, &transfer->self));\n\n    return WireResult::Success;\n}\nDAWN_UNUSED_FUNC(CommandEncoderPopDebugGroupSerialize);\n\nDAWN_DECLARE_UNUSED WireResult CommandEncoderPopDebugGroupDeserialize(\n    CommandEncoderPopDebugGroupCmd* record,\n    const volatile CommandEncoderPopDebugGroupTransfer* transfer,\n    DeserializeBuffer* deserializeBuffer,\n    DeserializeAllocator* allocator, const ObjectIdResolver& resolver) {\n    DAWN_UNUSED(allocator);\n\n    ASSERT(transfer->commandId == WireCmd::CommandEncoderPopDebugGroup);\n    record->selfId = transfer->self;\n\n\n    WIRE_TRY(resolver.GetFromId(transfer->self, &record->self));\n\n    return WireResult::Success;\n}\nDAWN_UNUSED_FUNC(CommandEncoderPopDebugGroupDeserialize);\n\nstruct CommandEncoderPushDebugGroupTransfer : CmdHeader {\n    static_assert(1 <= 1,\n                  \"Record must be at most one of is_cmd, extensible, and chained.\");\n    WireCmd commandId;\n\n    ObjectId self;\n    uint64_t groupLabelStrlen;\n};\n\nstatic_assert(offsetof(CommandEncoderPushDebugGroupTransfer, commandSize) == 0);\nstatic_assert(offsetof(CommandEncoderPushDebugGroupTransfer, commandId) == sizeof(CmdHeader));\n\nDAWN_DECLARE_UNUSED size_t CommandEncoderPushDebugGroupGetExtraRequiredSize(const CommandEncoderPushDebugGroupCmd& record) {\n    DAWN_UNUSED(record);\n    size_t result = 0;\n\n    ASSERT(record.groupLabel != nullptr);\n    result += Align(std::strlen(record.groupLabel), kWireBufferAlignment);\n    return result;\n}\n// GetExtraRequiredSize isn't used for structures that are value members of other structures\n// because we assume they cannot contain pointers themselves.\nDAWN_UNUSED_FUNC(CommandEncoderPushDebugGroupGetExtraRequiredSize);\n\nDAWN_DECLARE_UNUSED WireResult CommandEncoderPushDebugGroupSerialize(\n    const CommandEncoderPushDebugGroupCmd& record,\n    CommandEncoderPushDebugGroupTransfer* transfer,\n    SerializeBuffer* buffer, const ObjectIdProvider& provider) {\n    DAWN_UNUSED(buffer);\n    transfer->commandId = WireCmd::CommandEncoderPushDebugGroup;\n\n\n    WIRE_TRY(provider.GetId(record.self, &transfer->self));\n    {\n        transfer->groupLabelStrlen = std::strlen(record.groupLabel);\n\n        char* stringInBuffer;\n        WIRE_TRY(buffer->NextN(transfer->groupLabelStrlen, &stringInBuffer));\n        memcpy(stringInBuffer, record.groupLabel, transfer->groupLabelStrlen);\n    }\n\n    return WireResult::Success;\n}\nDAWN_UNUSED_FUNC(CommandEncoderPushDebugGroupSerialize);\n\nDAWN_DECLARE_UNUSED WireResult CommandEncoderPushDebugGroupDeserialize(\n    CommandEncoderPushDebugGroupCmd* record,\n    const volatile CommandEncoderPushDebugGroupTransfer* transfer,\n    DeserializeBuffer* deserializeBuffer,\n    DeserializeAllocator* allocator, const ObjectIdResolver& resolver) {\n    DAWN_UNUSED(allocator);\n\n    ASSERT(transfer->commandId == WireCmd::CommandEncoderPushDebugGroup);\n    record->selfId = transfer->self;\n\n\n    WIRE_TRY(resolver.GetFromId(transfer->self, &record->self));\n    {\n        uint64_t stringLength64 = transfer->groupLabelStrlen;\n        if (stringLength64 >= std::numeric_limits<size_t>::max()) {\n            return WireResult::FatalError;\n        }\n        size_t stringLength = static_cast<size_t>(stringLength64);\n\n        const volatile char* stringInBuffer;\n        WIRE_TRY(deserializeBuffer->ReadN(stringLength, &stringInBuffer));\n\n        char* copiedString;\n        WIRE_TRY(GetSpace(allocator, stringLength + 1, &copiedString));\n        memcpy(copiedString, const_cast<const char*>(stringInBuffer), stringLength);\n        copiedString[stringLength] = '\\0';\n        record->groupLabel = copiedString;\n    }\n\n    return WireResult::Success;\n}\nDAWN_UNUSED_FUNC(CommandEncoderPushDebugGroupDeserialize);\n\nstruct CommandEncoderResolveQuerySetTransfer : CmdHeader {\n    static_assert(1 <= 1,\n                  \"Record must be at most one of is_cmd, extensible, and chained.\");\n    WireCmd commandId;\n\n    ObjectId self;\n    ObjectId querySet;\n    uint32_t firstQuery;\n    uint32_t queryCount;\n    ObjectId destination;\n    uint64_t destinationOffset;\n};\n\nstatic_assert(offsetof(CommandEncoderResolveQuerySetTransfer, commandSize) == 0);\nstatic_assert(offsetof(CommandEncoderResolveQuerySetTransfer, commandId) == sizeof(CmdHeader));\n\nDAWN_DECLARE_UNUSED size_t CommandEncoderResolveQuerySetGetExtraRequiredSize(const CommandEncoderResolveQuerySetCmd& record) {\n    DAWN_UNUSED(record);\n    size_t result = 0;\n\n    return result;\n}\n// GetExtraRequiredSize isn't used for structures that are value members of other structures\n// because we assume they cannot contain pointers themselves.\nDAWN_UNUSED_FUNC(CommandEncoderResolveQuerySetGetExtraRequiredSize);\n\nDAWN_DECLARE_UNUSED WireResult CommandEncoderResolveQuerySetSerialize(\n    const CommandEncoderResolveQuerySetCmd& record,\n    CommandEncoderResolveQuerySetTransfer* transfer,\n    SerializeBuffer* buffer, const ObjectIdProvider& provider) {\n    DAWN_UNUSED(buffer);\n    transfer->commandId = WireCmd::CommandEncoderResolveQuerySet;\n\n\n    WIRE_TRY(provider.GetId(record.self, &transfer->self));\n    WIRE_TRY(provider.GetId(record.querySet, &transfer->querySet));\n    transfer->firstQuery = record.firstQuery;\n    transfer->queryCount = record.queryCount;\n    WIRE_TRY(provider.GetId(record.destination, &transfer->destination));\n    transfer->destinationOffset = record.destinationOffset;\n\n    return WireResult::Success;\n}\nDAWN_UNUSED_FUNC(CommandEncoderResolveQuerySetSerialize);\n\nDAWN_DECLARE_UNUSED WireResult CommandEncoderResolveQuerySetDeserialize(\n    CommandEncoderResolveQuerySetCmd* record,\n    const volatile CommandEncoderResolveQuerySetTransfer* transfer,\n    DeserializeBuffer* deserializeBuffer,\n    DeserializeAllocator* allocator, const ObjectIdResolver& resolver) {\n    DAWN_UNUSED(allocator);\n\n    ASSERT(transfer->commandId == WireCmd::CommandEncoderResolveQuerySet);\n    record->selfId = transfer->self;\n\n\n    WIRE_TRY(resolver.GetFromId(transfer->self, &record->self));\n    WIRE_TRY(resolver.GetFromId(transfer->querySet, &record->querySet));\n    static_assert(sizeof(record->firstQuery) >= sizeof(transfer->firstQuery), \"Deserialize assignment may not narrow.\");\n    record->firstQuery = transfer->firstQuery;\n    static_assert(sizeof(record->queryCount) >= sizeof(transfer->queryCount), \"Deserialize assignment may not narrow.\");\n    record->queryCount = transfer->queryCount;\n    WIRE_TRY(resolver.GetFromId(transfer->destination, &record->destination));\n    static_assert(sizeof(record->destinationOffset) >= sizeof(transfer->destinationOffset), \"Deserialize assignment may not narrow.\");\n    record->destinationOffset = transfer->destinationOffset;\n\n    return WireResult::Success;\n}\nDAWN_UNUSED_FUNC(CommandEncoderResolveQuerySetDeserialize);\n\nstruct CommandEncoderSetLabelTransfer : CmdHeader {\n    static_assert(1 <= 1,\n                  \"Record must be at most one of is_cmd, extensible, and chained.\");\n    WireCmd commandId;\n\n    ObjectId self;\n    uint64_t labelStrlen;\n};\n\nstatic_assert(offsetof(CommandEncoderSetLabelTransfer, commandSize) == 0);\nstatic_assert(offsetof(CommandEncoderSetLabelTransfer, commandId) == sizeof(CmdHeader));\n\nDAWN_DECLARE_UNUSED size_t CommandEncoderSetLabelGetExtraRequiredSize(const CommandEncoderSetLabelCmd& record) {\n    DAWN_UNUSED(record);\n    size_t result = 0;\n\n    ASSERT(record.label != nullptr);\n    result += Align(std::strlen(record.label), kWireBufferAlignment);\n    return result;\n}\n// GetExtraRequiredSize isn't used for structures that are value members of other structures\n// because we assume they cannot contain pointers themselves.\nDAWN_UNUSED_FUNC(CommandEncoderSetLabelGetExtraRequiredSize);\n\nDAWN_DECLARE_UNUSED WireResult CommandEncoderSetLabelSerialize(\n    const CommandEncoderSetLabelCmd& record,\n    CommandEncoderSetLabelTransfer* transfer,\n    SerializeBuffer* buffer, const ObjectIdProvider& provider) {\n    DAWN_UNUSED(buffer);\n    transfer->commandId = WireCmd::CommandEncoderSetLabel;\n\n\n    WIRE_TRY(provider.GetId(record.self, &transfer->self));\n    {\n        transfer->labelStrlen = std::strlen(record.label);\n\n        char* stringInBuffer;\n        WIRE_TRY(buffer->NextN(transfer->labelStrlen, &stringInBuffer));\n        memcpy(stringInBuffer, record.label, transfer->labelStrlen);\n    }\n\n    return WireResult::Success;\n}\nDAWN_UNUSED_FUNC(CommandEncoderSetLabelSerialize);\n\nDAWN_DECLARE_UNUSED WireResult CommandEncoderSetLabelDeserialize(\n    CommandEncoderSetLabelCmd* record,\n    const volatile CommandEncoderSetLabelTransfer* transfer,\n    DeserializeBuffer* deserializeBuffer,\n    DeserializeAllocator* allocator, const ObjectIdResolver& resolver) {\n    DAWN_UNUSED(allocator);\n\n    ASSERT(transfer->commandId == WireCmd::CommandEncoderSetLabel);\n    record->selfId = transfer->self;\n\n\n    WIRE_TRY(resolver.GetFromId(transfer->self, &record->self));\n    {\n        uint64_t stringLength64 = transfer->labelStrlen;\n        if (stringLength64 >= std::numeric_limits<size_t>::max()) {\n            return WireResult::FatalError;\n        }\n        size_t stringLength = static_cast<size_t>(stringLength64);\n\n        const volatile char* stringInBuffer;\n        WIRE_TRY(deserializeBuffer->ReadN(stringLength, &stringInBuffer));\n\n        char* copiedString;\n        WIRE_TRY(GetSpace(allocator, stringLength + 1, &copiedString));\n        memcpy(copiedString, const_cast<const char*>(stringInBuffer), stringLength);\n        copiedString[stringLength] = '\\0';\n        record->label = copiedString;\n    }\n\n    return WireResult::Success;\n}\nDAWN_UNUSED_FUNC(CommandEncoderSetLabelDeserialize);\n\nstruct CommandEncoderWriteBufferTransfer : CmdHeader {\n    static_assert(1 <= 1,\n                  \"Record must be at most one of is_cmd, extensible, and chained.\");\n    WireCmd commandId;\n\n    ObjectId self;\n    ObjectId buffer;\n    uint64_t bufferOffset;\n    uint64_t size;\n};\n\nstatic_assert(offsetof(CommandEncoderWriteBufferTransfer, commandSize) == 0);\nstatic_assert(offsetof(CommandEncoderWriteBufferTransfer, commandId) == sizeof(CmdHeader));\n\nDAWN_DECLARE_UNUSED size_t CommandEncoderWriteBufferGetExtraRequiredSize(const CommandEncoderWriteBufferCmd& record) {\n    DAWN_UNUSED(record);\n    size_t result = 0;\n\n    {\n        auto memberLength = record.size;\n        auto size = WireAlignSizeofN<uint8_t>(memberLength);\n        ASSERT(size);\n        result += *size;\n    }\n    return result;\n}\n// GetExtraRequiredSize isn't used for structures that are value members of other structures\n// because we assume they cannot contain pointers themselves.\nDAWN_UNUSED_FUNC(CommandEncoderWriteBufferGetExtraRequiredSize);\n\nDAWN_DECLARE_UNUSED WireResult CommandEncoderWriteBufferSerialize(\n    const CommandEncoderWriteBufferCmd& record,\n    CommandEncoderWriteBufferTransfer* transfer,\n    SerializeBuffer* buffer, const ObjectIdProvider& provider) {\n    DAWN_UNUSED(buffer);\n    transfer->commandId = WireCmd::CommandEncoderWriteBuffer;\n\n\n    WIRE_TRY(provider.GetId(record.self, &transfer->self));\n    WIRE_TRY(provider.GetId(record.buffer, &transfer->buffer));\n    transfer->bufferOffset = record.bufferOffset;\n    transfer->size = record.size;\n    {\n        auto memberLength = record.size;\n\n        uint8_t* memberBuffer;\n        WIRE_TRY(buffer->NextN(memberLength, &memberBuffer));\n\n        memcpy(\n            memberBuffer, record.data,\n            sizeof(uint8_t) * memberLength);\n    }\n\n    return WireResult::Success;\n}\nDAWN_UNUSED_FUNC(CommandEncoderWriteBufferSerialize);\n\nDAWN_DECLARE_UNUSED WireResult CommandEncoderWriteBufferDeserialize(\n    CommandEncoderWriteBufferCmd* record,\n    const volatile CommandEncoderWriteBufferTransfer* transfer,\n    DeserializeBuffer* deserializeBuffer,\n    DeserializeAllocator* allocator, const ObjectIdResolver& resolver) {\n    DAWN_UNUSED(allocator);\n\n    ASSERT(transfer->commandId == WireCmd::CommandEncoderWriteBuffer);\n    record->selfId = transfer->self;\n\n\n    WIRE_TRY(resolver.GetFromId(transfer->self, &record->self));\n    WIRE_TRY(resolver.GetFromId(transfer->buffer, &record->buffer));\n    static_assert(sizeof(record->bufferOffset) >= sizeof(transfer->bufferOffset), \"Deserialize assignment may not narrow.\");\n    record->bufferOffset = transfer->bufferOffset;\n    static_assert(sizeof(record->size) >= sizeof(transfer->size), \"Deserialize assignment may not narrow.\");\n    record->size = transfer->size;\n    {\n        auto memberLength = record->size;\n        const volatile uint8_t* memberBuffer;\n        WIRE_TRY(deserializeBuffer->ReadN(memberLength, &memberBuffer));\n\n        uint8_t* copiedMembers;\n        WIRE_TRY(GetSpace(allocator, memberLength, &copiedMembers));\n        record->data = copiedMembers;\n\n        memcpy(\n            copiedMembers,\n            const_cast<const uint8_t*>(memberBuffer),\n           sizeof(uint8_t) * memberLength);\n    }\n\n    return WireResult::Success;\n}\nDAWN_UNUSED_FUNC(CommandEncoderWriteBufferDeserialize);\n\nstruct CommandEncoderWriteTimestampTransfer : CmdHeader {\n    static_assert(1 <= 1,\n                  \"Record must be at most one of is_cmd, extensible, and chained.\");\n    WireCmd commandId;\n\n    ObjectId self;\n    ObjectId querySet;\n    uint32_t queryIndex;\n};\n\nstatic_assert(offsetof(CommandEncoderWriteTimestampTransfer, commandSize) == 0);\nstatic_assert(offsetof(CommandEncoderWriteTimestampTransfer, commandId) == sizeof(CmdHeader));\n\nDAWN_DECLARE_UNUSED size_t CommandEncoderWriteTimestampGetExtraRequiredSize(const CommandEncoderWriteTimestampCmd& record) {\n    DAWN_UNUSED(record);\n    size_t result = 0;\n\n    return result;\n}\n// GetExtraRequiredSize isn't used for structures that are value members of other structures\n// because we assume they cannot contain pointers themselves.\nDAWN_UNUSED_FUNC(CommandEncoderWriteTimestampGetExtraRequiredSize);\n\nDAWN_DECLARE_UNUSED WireResult CommandEncoderWriteTimestampSerialize(\n    const CommandEncoderWriteTimestampCmd& record,\n    CommandEncoderWriteTimestampTransfer* transfer,\n    SerializeBuffer* buffer, const ObjectIdProvider& provider) {\n    DAWN_UNUSED(buffer);\n    transfer->commandId = WireCmd::CommandEncoderWriteTimestamp;\n\n\n    WIRE_TRY(provider.GetId(record.self, &transfer->self));\n    WIRE_TRY(provider.GetId(record.querySet, &transfer->querySet));\n    transfer->queryIndex = record.queryIndex;\n\n    return WireResult::Success;\n}\nDAWN_UNUSED_FUNC(CommandEncoderWriteTimestampSerialize);\n\nDAWN_DECLARE_UNUSED WireResult CommandEncoderWriteTimestampDeserialize(\n    CommandEncoderWriteTimestampCmd* record,\n    const volatile CommandEncoderWriteTimestampTransfer* transfer,\n    DeserializeBuffer* deserializeBuffer,\n    DeserializeAllocator* allocator, const ObjectIdResolver& resolver) {\n    DAWN_UNUSED(allocator);\n\n    ASSERT(transfer->commandId == WireCmd::CommandEncoderWriteTimestamp);\n    record->selfId = transfer->self;\n\n\n    WIRE_TRY(resolver.GetFromId(transfer->self, &record->self));\n    WIRE_TRY(resolver.GetFromId(transfer->querySet, &record->querySet));\n    static_assert(sizeof(record->queryIndex) >= sizeof(transfer->queryIndex), \"Deserialize assignment may not narrow.\");\n    record->queryIndex = transfer->queryIndex;\n\n    return WireResult::Success;\n}\nDAWN_UNUSED_FUNC(CommandEncoderWriteTimestampDeserialize);\n\nstruct ComputePassEncoderDispatchWorkgroupsTransfer : CmdHeader {\n    static_assert(1 <= 1,\n                  \"Record must be at most one of is_cmd, extensible, and chained.\");\n    WireCmd commandId;\n\n    ObjectId self;\n    uint32_t workgroupCountX;\n    uint32_t workgroupCountY;\n    uint32_t workgroupCountZ;\n};\n\nstatic_assert(offsetof(ComputePassEncoderDispatchWorkgroupsTransfer, commandSize) == 0);\nstatic_assert(offsetof(ComputePassEncoderDispatchWorkgroupsTransfer, commandId) == sizeof(CmdHeader));\n\nDAWN_DECLARE_UNUSED size_t ComputePassEncoderDispatchWorkgroupsGetExtraRequiredSize(const ComputePassEncoderDispatchWorkgroupsCmd& record) {\n    DAWN_UNUSED(record);\n    size_t result = 0;\n\n    return result;\n}\n// GetExtraRequiredSize isn't used for structures that are value members of other structures\n// because we assume they cannot contain pointers themselves.\nDAWN_UNUSED_FUNC(ComputePassEncoderDispatchWorkgroupsGetExtraRequiredSize);\n\nDAWN_DECLARE_UNUSED WireResult ComputePassEncoderDispatchWorkgroupsSerialize(\n    const ComputePassEncoderDispatchWorkgroupsCmd& record,\n    ComputePassEncoderDispatchWorkgroupsTransfer* transfer,\n    SerializeBuffer* buffer, const ObjectIdProvider& provider) {\n    DAWN_UNUSED(buffer);\n    transfer->commandId = WireCmd::ComputePassEncoderDispatchWorkgroups;\n\n\n    WIRE_TRY(provider.GetId(record.self, &transfer->self));\n    transfer->workgroupCountX = record.workgroupCountX;\n    transfer->workgroupCountY = record.workgroupCountY;\n    transfer->workgroupCountZ = record.workgroupCountZ;\n\n    return WireResult::Success;\n}\nDAWN_UNUSED_FUNC(ComputePassEncoderDispatchWorkgroupsSerialize);\n\nDAWN_DECLARE_UNUSED WireResult ComputePassEncoderDispatchWorkgroupsDeserialize(\n    ComputePassEncoderDispatchWorkgroupsCmd* record,\n    const volatile ComputePassEncoderDispatchWorkgroupsTransfer* transfer,\n    DeserializeBuffer* deserializeBuffer,\n    DeserializeAllocator* allocator, const ObjectIdResolver& resolver) {\n    DAWN_UNUSED(allocator);\n\n    ASSERT(transfer->commandId == WireCmd::ComputePassEncoderDispatchWorkgroups);\n    record->selfId = transfer->self;\n\n\n    WIRE_TRY(resolver.GetFromId(transfer->self, &record->self));\n    static_assert(sizeof(record->workgroupCountX) >= sizeof(transfer->workgroupCountX), \"Deserialize assignment may not narrow.\");\n    record->workgroupCountX = transfer->workgroupCountX;\n    static_assert(sizeof(record->workgroupCountY) >= sizeof(transfer->workgroupCountY), \"Deserialize assignment may not narrow.\");\n    record->workgroupCountY = transfer->workgroupCountY;\n    static_assert(sizeof(record->workgroupCountZ) >= sizeof(transfer->workgroupCountZ), \"Deserialize assignment may not narrow.\");\n    record->workgroupCountZ = transfer->workgroupCountZ;\n\n    return WireResult::Success;\n}\nDAWN_UNUSED_FUNC(ComputePassEncoderDispatchWorkgroupsDeserialize);\n\nstruct ComputePassEncoderDispatchWorkgroupsIndirectTransfer : CmdHeader {\n    static_assert(1 <= 1,\n                  \"Record must be at most one of is_cmd, extensible, and chained.\");\n    WireCmd commandId;\n\n    ObjectId self;\n    ObjectId indirectBuffer;\n    uint64_t indirectOffset;\n};\n\nstatic_assert(offsetof(ComputePassEncoderDispatchWorkgroupsIndirectTransfer, commandSize) == 0);\nstatic_assert(offsetof(ComputePassEncoderDispatchWorkgroupsIndirectTransfer, commandId) == sizeof(CmdHeader));\n\nDAWN_DECLARE_UNUSED size_t ComputePassEncoderDispatchWorkgroupsIndirectGetExtraRequiredSize(const ComputePassEncoderDispatchWorkgroupsIndirectCmd& record) {\n    DAWN_UNUSED(record);\n    size_t result = 0;\n\n    return result;\n}\n// GetExtraRequiredSize isn't used for structures that are value members of other structures\n// because we assume they cannot contain pointers themselves.\nDAWN_UNUSED_FUNC(ComputePassEncoderDispatchWorkgroupsIndirectGetExtraRequiredSize);\n\nDAWN_DECLARE_UNUSED WireResult ComputePassEncoderDispatchWorkgroupsIndirectSerialize(\n    const ComputePassEncoderDispatchWorkgroupsIndirectCmd& record,\n    ComputePassEncoderDispatchWorkgroupsIndirectTransfer* transfer,\n    SerializeBuffer* buffer, const ObjectIdProvider& provider) {\n    DAWN_UNUSED(buffer);\n    transfer->commandId = WireCmd::ComputePassEncoderDispatchWorkgroupsIndirect;\n\n\n    WIRE_TRY(provider.GetId(record.self, &transfer->self));\n    WIRE_TRY(provider.GetId(record.indirectBuffer, &transfer->indirectBuffer));\n    transfer->indirectOffset = record.indirectOffset;\n\n    return WireResult::Success;\n}\nDAWN_UNUSED_FUNC(ComputePassEncoderDispatchWorkgroupsIndirectSerialize);\n\nDAWN_DECLARE_UNUSED WireResult ComputePassEncoderDispatchWorkgroupsIndirectDeserialize(\n    ComputePassEncoderDispatchWorkgroupsIndirectCmd* record,\n    const volatile ComputePassEncoderDispatchWorkgroupsIndirectTransfer* transfer,\n    DeserializeBuffer* deserializeBuffer,\n    DeserializeAllocator* allocator, const ObjectIdResolver& resolver) {\n    DAWN_UNUSED(allocator);\n\n    ASSERT(transfer->commandId == WireCmd::ComputePassEncoderDispatchWorkgroupsIndirect);\n    record->selfId = transfer->self;\n\n\n    WIRE_TRY(resolver.GetFromId(transfer->self, &record->self));\n    WIRE_TRY(resolver.GetFromId(transfer->indirectBuffer, &record->indirectBuffer));\n    static_assert(sizeof(record->indirectOffset) >= sizeof(transfer->indirectOffset), \"Deserialize assignment may not narrow.\");\n    record->indirectOffset = transfer->indirectOffset;\n\n    return WireResult::Success;\n}\nDAWN_UNUSED_FUNC(ComputePassEncoderDispatchWorkgroupsIndirectDeserialize);\n\nstruct ComputePassEncoderEndTransfer : CmdHeader {\n    static_assert(1 <= 1,\n                  \"Record must be at most one of is_cmd, extensible, and chained.\");\n    WireCmd commandId;\n\n    ObjectId self;\n};\n\nstatic_assert(offsetof(ComputePassEncoderEndTransfer, commandSize) == 0);\nstatic_assert(offsetof(ComputePassEncoderEndTransfer, commandId) == sizeof(CmdHeader));\n\nDAWN_DECLARE_UNUSED size_t ComputePassEncoderEndGetExtraRequiredSize(const ComputePassEncoderEndCmd& record) {\n    DAWN_UNUSED(record);\n    size_t result = 0;\n\n    return result;\n}\n// GetExtraRequiredSize isn't used for structures that are value members of other structures\n// because we assume they cannot contain pointers themselves.\nDAWN_UNUSED_FUNC(ComputePassEncoderEndGetExtraRequiredSize);\n\nDAWN_DECLARE_UNUSED WireResult ComputePassEncoderEndSerialize(\n    const ComputePassEncoderEndCmd& record,\n    ComputePassEncoderEndTransfer* transfer,\n    SerializeBuffer* buffer, const ObjectIdProvider& provider) {\n    DAWN_UNUSED(buffer);\n    transfer->commandId = WireCmd::ComputePassEncoderEnd;\n\n\n    WIRE_TRY(provider.GetId(record.self, &transfer->self));\n\n    return WireResult::Success;\n}\nDAWN_UNUSED_FUNC(ComputePassEncoderEndSerialize);\n\nDAWN_DECLARE_UNUSED WireResult ComputePassEncoderEndDeserialize(\n    ComputePassEncoderEndCmd* record,\n    const volatile ComputePassEncoderEndTransfer* transfer,\n    DeserializeBuffer* deserializeBuffer,\n    DeserializeAllocator* allocator, const ObjectIdResolver& resolver) {\n    DAWN_UNUSED(allocator);\n\n    ASSERT(transfer->commandId == WireCmd::ComputePassEncoderEnd);\n    record->selfId = transfer->self;\n\n\n    WIRE_TRY(resolver.GetFromId(transfer->self, &record->self));\n\n    return WireResult::Success;\n}\nDAWN_UNUSED_FUNC(ComputePassEncoderEndDeserialize);\n\nstruct ComputePassEncoderInsertDebugMarkerTransfer : CmdHeader {\n    static_assert(1 <= 1,\n                  \"Record must be at most one of is_cmd, extensible, and chained.\");\n    WireCmd commandId;\n\n    ObjectId self;\n    uint64_t markerLabelStrlen;\n};\n\nstatic_assert(offsetof(ComputePassEncoderInsertDebugMarkerTransfer, commandSize) == 0);\nstatic_assert(offsetof(ComputePassEncoderInsertDebugMarkerTransfer, commandId) == sizeof(CmdHeader));\n\nDAWN_DECLARE_UNUSED size_t ComputePassEncoderInsertDebugMarkerGetExtraRequiredSize(const ComputePassEncoderInsertDebugMarkerCmd& record) {\n    DAWN_UNUSED(record);\n    size_t result = 0;\n\n    ASSERT(record.markerLabel != nullptr);\n    result += Align(std::strlen(record.markerLabel), kWireBufferAlignment);\n    return result;\n}\n// GetExtraRequiredSize isn't used for structures that are value members of other structures\n// because we assume they cannot contain pointers themselves.\nDAWN_UNUSED_FUNC(ComputePassEncoderInsertDebugMarkerGetExtraRequiredSize);\n\nDAWN_DECLARE_UNUSED WireResult ComputePassEncoderInsertDebugMarkerSerialize(\n    const ComputePassEncoderInsertDebugMarkerCmd& record,\n    ComputePassEncoderInsertDebugMarkerTransfer* transfer,\n    SerializeBuffer* buffer, const ObjectIdProvider& provider) {\n    DAWN_UNUSED(buffer);\n    transfer->commandId = WireCmd::ComputePassEncoderInsertDebugMarker;\n\n\n    WIRE_TRY(provider.GetId(record.self, &transfer->self));\n    {\n        transfer->markerLabelStrlen = std::strlen(record.markerLabel);\n\n        char* stringInBuffer;\n        WIRE_TRY(buffer->NextN(transfer->markerLabelStrlen, &stringInBuffer));\n        memcpy(stringInBuffer, record.markerLabel, transfer->markerLabelStrlen);\n    }\n\n    return WireResult::Success;\n}\nDAWN_UNUSED_FUNC(ComputePassEncoderInsertDebugMarkerSerialize);\n\nDAWN_DECLARE_UNUSED WireResult ComputePassEncoderInsertDebugMarkerDeserialize(\n    ComputePassEncoderInsertDebugMarkerCmd* record,\n    const volatile ComputePassEncoderInsertDebugMarkerTransfer* transfer,\n    DeserializeBuffer* deserializeBuffer,\n    DeserializeAllocator* allocator, const ObjectIdResolver& resolver) {\n    DAWN_UNUSED(allocator);\n\n    ASSERT(transfer->commandId == WireCmd::ComputePassEncoderInsertDebugMarker);\n    record->selfId = transfer->self;\n\n\n    WIRE_TRY(resolver.GetFromId(transfer->self, &record->self));\n    {\n        uint64_t stringLength64 = transfer->markerLabelStrlen;\n        if (stringLength64 >= std::numeric_limits<size_t>::max()) {\n            return WireResult::FatalError;\n        }\n        size_t stringLength = static_cast<size_t>(stringLength64);\n\n        const volatile char* stringInBuffer;\n        WIRE_TRY(deserializeBuffer->ReadN(stringLength, &stringInBuffer));\n\n        char* copiedString;\n        WIRE_TRY(GetSpace(allocator, stringLength + 1, &copiedString));\n        memcpy(copiedString, const_cast<const char*>(stringInBuffer), stringLength);\n        copiedString[stringLength] = '\\0';\n        record->markerLabel = copiedString;\n    }\n\n    return WireResult::Success;\n}\nDAWN_UNUSED_FUNC(ComputePassEncoderInsertDebugMarkerDeserialize);\n\nstruct ComputePassEncoderPopDebugGroupTransfer : CmdHeader {\n    static_assert(1 <= 1,\n                  \"Record must be at most one of is_cmd, extensible, and chained.\");\n    WireCmd commandId;\n\n    ObjectId self;\n};\n\nstatic_assert(offsetof(ComputePassEncoderPopDebugGroupTransfer, commandSize) == 0);\nstatic_assert(offsetof(ComputePassEncoderPopDebugGroupTransfer, commandId) == sizeof(CmdHeader));\n\nDAWN_DECLARE_UNUSED size_t ComputePassEncoderPopDebugGroupGetExtraRequiredSize(const ComputePassEncoderPopDebugGroupCmd& record) {\n    DAWN_UNUSED(record);\n    size_t result = 0;\n\n    return result;\n}\n// GetExtraRequiredSize isn't used for structures that are value members of other structures\n// because we assume they cannot contain pointers themselves.\nDAWN_UNUSED_FUNC(ComputePassEncoderPopDebugGroupGetExtraRequiredSize);\n\nDAWN_DECLARE_UNUSED WireResult ComputePassEncoderPopDebugGroupSerialize(\n    const ComputePassEncoderPopDebugGroupCmd& record,\n    ComputePassEncoderPopDebugGroupTransfer* transfer,\n    SerializeBuffer* buffer, const ObjectIdProvider& provider) {\n    DAWN_UNUSED(buffer);\n    transfer->commandId = WireCmd::ComputePassEncoderPopDebugGroup;\n\n\n    WIRE_TRY(provider.GetId(record.self, &transfer->self));\n\n    return WireResult::Success;\n}\nDAWN_UNUSED_FUNC(ComputePassEncoderPopDebugGroupSerialize);\n\nDAWN_DECLARE_UNUSED WireResult ComputePassEncoderPopDebugGroupDeserialize(\n    ComputePassEncoderPopDebugGroupCmd* record,\n    const volatile ComputePassEncoderPopDebugGroupTransfer* transfer,\n    DeserializeBuffer* deserializeBuffer,\n    DeserializeAllocator* allocator, const ObjectIdResolver& resolver) {\n    DAWN_UNUSED(allocator);\n\n    ASSERT(transfer->commandId == WireCmd::ComputePassEncoderPopDebugGroup);\n    record->selfId = transfer->self;\n\n\n    WIRE_TRY(resolver.GetFromId(transfer->self, &record->self));\n\n    return WireResult::Success;\n}\nDAWN_UNUSED_FUNC(ComputePassEncoderPopDebugGroupDeserialize);\n\nstruct ComputePassEncoderPushDebugGroupTransfer : CmdHeader {\n    static_assert(1 <= 1,\n                  \"Record must be at most one of is_cmd, extensible, and chained.\");\n    WireCmd commandId;\n\n    ObjectId self;\n    uint64_t groupLabelStrlen;\n};\n\nstatic_assert(offsetof(ComputePassEncoderPushDebugGroupTransfer, commandSize) == 0);\nstatic_assert(offsetof(ComputePassEncoderPushDebugGroupTransfer, commandId) == sizeof(CmdHeader));\n\nDAWN_DECLARE_UNUSED size_t ComputePassEncoderPushDebugGroupGetExtraRequiredSize(const ComputePassEncoderPushDebugGroupCmd& record) {\n    DAWN_UNUSED(record);\n    size_t result = 0;\n\n    ASSERT(record.groupLabel != nullptr);\n    result += Align(std::strlen(record.groupLabel), kWireBufferAlignment);\n    return result;\n}\n// GetExtraRequiredSize isn't used for structures that are value members of other structures\n// because we assume they cannot contain pointers themselves.\nDAWN_UNUSED_FUNC(ComputePassEncoderPushDebugGroupGetExtraRequiredSize);\n\nDAWN_DECLARE_UNUSED WireResult ComputePassEncoderPushDebugGroupSerialize(\n    const ComputePassEncoderPushDebugGroupCmd& record,\n    ComputePassEncoderPushDebugGroupTransfer* transfer,\n    SerializeBuffer* buffer, const ObjectIdProvider& provider) {\n    DAWN_UNUSED(buffer);\n    transfer->commandId = WireCmd::ComputePassEncoderPushDebugGroup;\n\n\n    WIRE_TRY(provider.GetId(record.self, &transfer->self));\n    {\n        transfer->groupLabelStrlen = std::strlen(record.groupLabel);\n\n        char* stringInBuffer;\n        WIRE_TRY(buffer->NextN(transfer->groupLabelStrlen, &stringInBuffer));\n        memcpy(stringInBuffer, record.groupLabel, transfer->groupLabelStrlen);\n    }\n\n    return WireResult::Success;\n}\nDAWN_UNUSED_FUNC(ComputePassEncoderPushDebugGroupSerialize);\n\nDAWN_DECLARE_UNUSED WireResult ComputePassEncoderPushDebugGroupDeserialize(\n    ComputePassEncoderPushDebugGroupCmd* record,\n    const volatile ComputePassEncoderPushDebugGroupTransfer* transfer,\n    DeserializeBuffer* deserializeBuffer,\n    DeserializeAllocator* allocator, const ObjectIdResolver& resolver) {\n    DAWN_UNUSED(allocator);\n\n    ASSERT(transfer->commandId == WireCmd::ComputePassEncoderPushDebugGroup);\n    record->selfId = transfer->self;\n\n\n    WIRE_TRY(resolver.GetFromId(transfer->self, &record->self));\n    {\n        uint64_t stringLength64 = transfer->groupLabelStrlen;\n        if (stringLength64 >= std::numeric_limits<size_t>::max()) {\n            return WireResult::FatalError;\n        }\n        size_t stringLength = static_cast<size_t>(stringLength64);\n\n        const volatile char* stringInBuffer;\n        WIRE_TRY(deserializeBuffer->ReadN(stringLength, &stringInBuffer));\n\n        char* copiedString;\n        WIRE_TRY(GetSpace(allocator, stringLength + 1, &copiedString));\n        memcpy(copiedString, const_cast<const char*>(stringInBuffer), stringLength);\n        copiedString[stringLength] = '\\0';\n        record->groupLabel = copiedString;\n    }\n\n    return WireResult::Success;\n}\nDAWN_UNUSED_FUNC(ComputePassEncoderPushDebugGroupDeserialize);\n\nstruct ComputePassEncoderSetBindGroupTransfer : CmdHeader {\n    static_assert(1 <= 1,\n                  \"Record must be at most one of is_cmd, extensible, and chained.\");\n    WireCmd commandId;\n\n    ObjectId self;\n    uint32_t groupIndex;\n    ObjectId group;\n    uint64_t dynamicOffsetCount;\n};\n\nstatic_assert(offsetof(ComputePassEncoderSetBindGroupTransfer, commandSize) == 0);\nstatic_assert(offsetof(ComputePassEncoderSetBindGroupTransfer, commandId) == sizeof(CmdHeader));\n\nDAWN_DECLARE_UNUSED size_t ComputePassEncoderSetBindGroupGetExtraRequiredSize(const ComputePassEncoderSetBindGroupCmd& record) {\n    DAWN_UNUSED(record);\n    size_t result = 0;\n\n    {\n        auto memberLength = record.dynamicOffsetCount;\n        auto size = WireAlignSizeofN<uint32_t>(memberLength);\n        ASSERT(size);\n        result += *size;\n    }\n    return result;\n}\n// GetExtraRequiredSize isn't used for structures that are value members of other structures\n// because we assume they cannot contain pointers themselves.\nDAWN_UNUSED_FUNC(ComputePassEncoderSetBindGroupGetExtraRequiredSize);\n\nDAWN_DECLARE_UNUSED WireResult ComputePassEncoderSetBindGroupSerialize(\n    const ComputePassEncoderSetBindGroupCmd& record,\n    ComputePassEncoderSetBindGroupTransfer* transfer,\n    SerializeBuffer* buffer, const ObjectIdProvider& provider) {\n    DAWN_UNUSED(buffer);\n    transfer->commandId = WireCmd::ComputePassEncoderSetBindGroup;\n\n\n    WIRE_TRY(provider.GetId(record.self, &transfer->self));\n    transfer->groupIndex = record.groupIndex;\n    WIRE_TRY(provider.GetOptionalId(record.group, &transfer->group));\n    transfer->dynamicOffsetCount = record.dynamicOffsetCount;\n    {\n        auto memberLength = record.dynamicOffsetCount;\n\n        uint32_t* memberBuffer;\n        WIRE_TRY(buffer->NextN(memberLength, &memberBuffer));\n\n        memcpy(\n            memberBuffer, record.dynamicOffsets,\n            sizeof(uint32_t) * memberLength);\n    }\n\n    return WireResult::Success;\n}\nDAWN_UNUSED_FUNC(ComputePassEncoderSetBindGroupSerialize);\n\nDAWN_DECLARE_UNUSED WireResult ComputePassEncoderSetBindGroupDeserialize(\n    ComputePassEncoderSetBindGroupCmd* record,\n    const volatile ComputePassEncoderSetBindGroupTransfer* transfer,\n    DeserializeBuffer* deserializeBuffer,\n    DeserializeAllocator* allocator, const ObjectIdResolver& resolver) {\n    DAWN_UNUSED(allocator);\n\n    ASSERT(transfer->commandId == WireCmd::ComputePassEncoderSetBindGroup);\n    record->selfId = transfer->self;\n\n\n    WIRE_TRY(resolver.GetFromId(transfer->self, &record->self));\n    static_assert(sizeof(record->groupIndex) >= sizeof(transfer->groupIndex), \"Deserialize assignment may not narrow.\");\n    record->groupIndex = transfer->groupIndex;\n    WIRE_TRY(resolver.GetOptionalFromId(transfer->group, &record->group));\n    if (transfer->dynamicOffsetCount > std::numeric_limits<size_t>::max()) return WireResult::FatalError;\n    record->dynamicOffsetCount = checked_cast<size_t>(transfer->dynamicOffsetCount);\n    {\n        auto memberLength = record->dynamicOffsetCount;\n        const volatile uint32_t* memberBuffer;\n        WIRE_TRY(deserializeBuffer->ReadN(memberLength, &memberBuffer));\n\n        uint32_t* copiedMembers;\n        WIRE_TRY(GetSpace(allocator, memberLength, &copiedMembers));\n        record->dynamicOffsets = copiedMembers;\n\n        memcpy(\n            copiedMembers,\n            const_cast<const uint32_t*>(memberBuffer),\n           sizeof(uint32_t) * memberLength);\n    }\n\n    return WireResult::Success;\n}\nDAWN_UNUSED_FUNC(ComputePassEncoderSetBindGroupDeserialize);\n\nstruct ComputePassEncoderSetLabelTransfer : CmdHeader {\n    static_assert(1 <= 1,\n                  \"Record must be at most one of is_cmd, extensible, and chained.\");\n    WireCmd commandId;\n\n    ObjectId self;\n    uint64_t labelStrlen;\n};\n\nstatic_assert(offsetof(ComputePassEncoderSetLabelTransfer, commandSize) == 0);\nstatic_assert(offsetof(ComputePassEncoderSetLabelTransfer, commandId) == sizeof(CmdHeader));\n\nDAWN_DECLARE_UNUSED size_t ComputePassEncoderSetLabelGetExtraRequiredSize(const ComputePassEncoderSetLabelCmd& record) {\n    DAWN_UNUSED(record);\n    size_t result = 0;\n\n    ASSERT(record.label != nullptr);\n    result += Align(std::strlen(record.label), kWireBufferAlignment);\n    return result;\n}\n// GetExtraRequiredSize isn't used for structures that are value members of other structures\n// because we assume they cannot contain pointers themselves.\nDAWN_UNUSED_FUNC(ComputePassEncoderSetLabelGetExtraRequiredSize);\n\nDAWN_DECLARE_UNUSED WireResult ComputePassEncoderSetLabelSerialize(\n    const ComputePassEncoderSetLabelCmd& record,\n    ComputePassEncoderSetLabelTransfer* transfer,\n    SerializeBuffer* buffer, const ObjectIdProvider& provider) {\n    DAWN_UNUSED(buffer);\n    transfer->commandId = WireCmd::ComputePassEncoderSetLabel;\n\n\n    WIRE_TRY(provider.GetId(record.self, &transfer->self));\n    {\n        transfer->labelStrlen = std::strlen(record.label);\n\n        char* stringInBuffer;\n        WIRE_TRY(buffer->NextN(transfer->labelStrlen, &stringInBuffer));\n        memcpy(stringInBuffer, record.label, transfer->labelStrlen);\n    }\n\n    return WireResult::Success;\n}\nDAWN_UNUSED_FUNC(ComputePassEncoderSetLabelSerialize);\n\nDAWN_DECLARE_UNUSED WireResult ComputePassEncoderSetLabelDeserialize(\n    ComputePassEncoderSetLabelCmd* record,\n    const volatile ComputePassEncoderSetLabelTransfer* transfer,\n    DeserializeBuffer* deserializeBuffer,\n    DeserializeAllocator* allocator, const ObjectIdResolver& resolver) {\n    DAWN_UNUSED(allocator);\n\n    ASSERT(transfer->commandId == WireCmd::ComputePassEncoderSetLabel);\n    record->selfId = transfer->self;\n\n\n    WIRE_TRY(resolver.GetFromId(transfer->self, &record->self));\n    {\n        uint64_t stringLength64 = transfer->labelStrlen;\n        if (stringLength64 >= std::numeric_limits<size_t>::max()) {\n            return WireResult::FatalError;\n        }\n        size_t stringLength = static_cast<size_t>(stringLength64);\n\n        const volatile char* stringInBuffer;\n        WIRE_TRY(deserializeBuffer->ReadN(stringLength, &stringInBuffer));\n\n        char* copiedString;\n        WIRE_TRY(GetSpace(allocator, stringLength + 1, &copiedString));\n        memcpy(copiedString, const_cast<const char*>(stringInBuffer), stringLength);\n        copiedString[stringLength] = '\\0';\n        record->label = copiedString;\n    }\n\n    return WireResult::Success;\n}\nDAWN_UNUSED_FUNC(ComputePassEncoderSetLabelDeserialize);\n\nstruct ComputePassEncoderSetPipelineTransfer : CmdHeader {\n    static_assert(1 <= 1,\n                  \"Record must be at most one of is_cmd, extensible, and chained.\");\n    WireCmd commandId;\n\n    ObjectId self;\n    ObjectId pipeline;\n};\n\nstatic_assert(offsetof(ComputePassEncoderSetPipelineTransfer, commandSize) == 0);\nstatic_assert(offsetof(ComputePassEncoderSetPipelineTransfer, commandId) == sizeof(CmdHeader));\n\nDAWN_DECLARE_UNUSED size_t ComputePassEncoderSetPipelineGetExtraRequiredSize(const ComputePassEncoderSetPipelineCmd& record) {\n    DAWN_UNUSED(record);\n    size_t result = 0;\n\n    return result;\n}\n// GetExtraRequiredSize isn't used for structures that are value members of other structures\n// because we assume they cannot contain pointers themselves.\nDAWN_UNUSED_FUNC(ComputePassEncoderSetPipelineGetExtraRequiredSize);\n\nDAWN_DECLARE_UNUSED WireResult ComputePassEncoderSetPipelineSerialize(\n    const ComputePassEncoderSetPipelineCmd& record,\n    ComputePassEncoderSetPipelineTransfer* transfer,\n    SerializeBuffer* buffer, const ObjectIdProvider& provider) {\n    DAWN_UNUSED(buffer);\n    transfer->commandId = WireCmd::ComputePassEncoderSetPipeline;\n\n\n    WIRE_TRY(provider.GetId(record.self, &transfer->self));\n    WIRE_TRY(provider.GetId(record.pipeline, &transfer->pipeline));\n\n    return WireResult::Success;\n}\nDAWN_UNUSED_FUNC(ComputePassEncoderSetPipelineSerialize);\n\nDAWN_DECLARE_UNUSED WireResult ComputePassEncoderSetPipelineDeserialize(\n    ComputePassEncoderSetPipelineCmd* record,\n    const volatile ComputePassEncoderSetPipelineTransfer* transfer,\n    DeserializeBuffer* deserializeBuffer,\n    DeserializeAllocator* allocator, const ObjectIdResolver& resolver) {\n    DAWN_UNUSED(allocator);\n\n    ASSERT(transfer->commandId == WireCmd::ComputePassEncoderSetPipeline);\n    record->selfId = transfer->self;\n\n\n    WIRE_TRY(resolver.GetFromId(transfer->self, &record->self));\n    WIRE_TRY(resolver.GetFromId(transfer->pipeline, &record->pipeline));\n\n    return WireResult::Success;\n}\nDAWN_UNUSED_FUNC(ComputePassEncoderSetPipelineDeserialize);\n\nstruct ComputePassEncoderWriteTimestampTransfer : CmdHeader {\n    static_assert(1 <= 1,\n                  \"Record must be at most one of is_cmd, extensible, and chained.\");\n    WireCmd commandId;\n\n    ObjectId self;\n    ObjectId querySet;\n    uint32_t queryIndex;\n};\n\nstatic_assert(offsetof(ComputePassEncoderWriteTimestampTransfer, commandSize) == 0);\nstatic_assert(offsetof(ComputePassEncoderWriteTimestampTransfer, commandId) == sizeof(CmdHeader));\n\nDAWN_DECLARE_UNUSED size_t ComputePassEncoderWriteTimestampGetExtraRequiredSize(const ComputePassEncoderWriteTimestampCmd& record) {\n    DAWN_UNUSED(record);\n    size_t result = 0;\n\n    return result;\n}\n// GetExtraRequiredSize isn't used for structures that are value members of other structures\n// because we assume they cannot contain pointers themselves.\nDAWN_UNUSED_FUNC(ComputePassEncoderWriteTimestampGetExtraRequiredSize);\n\nDAWN_DECLARE_UNUSED WireResult ComputePassEncoderWriteTimestampSerialize(\n    const ComputePassEncoderWriteTimestampCmd& record,\n    ComputePassEncoderWriteTimestampTransfer* transfer,\n    SerializeBuffer* buffer, const ObjectIdProvider& provider) {\n    DAWN_UNUSED(buffer);\n    transfer->commandId = WireCmd::ComputePassEncoderWriteTimestamp;\n\n\n    WIRE_TRY(provider.GetId(record.self, &transfer->self));\n    WIRE_TRY(provider.GetId(record.querySet, &transfer->querySet));\n    transfer->queryIndex = record.queryIndex;\n\n    return WireResult::Success;\n}\nDAWN_UNUSED_FUNC(ComputePassEncoderWriteTimestampSerialize);\n\nDAWN_DECLARE_UNUSED WireResult ComputePassEncoderWriteTimestampDeserialize(\n    ComputePassEncoderWriteTimestampCmd* record,\n    const volatile ComputePassEncoderWriteTimestampTransfer* transfer,\n    DeserializeBuffer* deserializeBuffer,\n    DeserializeAllocator* allocator, const ObjectIdResolver& resolver) {\n    DAWN_UNUSED(allocator);\n\n    ASSERT(transfer->commandId == WireCmd::ComputePassEncoderWriteTimestamp);\n    record->selfId = transfer->self;\n\n\n    WIRE_TRY(resolver.GetFromId(transfer->self, &record->self));\n    WIRE_TRY(resolver.GetFromId(transfer->querySet, &record->querySet));\n    static_assert(sizeof(record->queryIndex) >= sizeof(transfer->queryIndex), \"Deserialize assignment may not narrow.\");\n    record->queryIndex = transfer->queryIndex;\n\n    return WireResult::Success;\n}\nDAWN_UNUSED_FUNC(ComputePassEncoderWriteTimestampDeserialize);\n\nstruct ComputePipelineGetBindGroupLayoutTransfer : CmdHeader {\n    static_assert(1 <= 1,\n                  \"Record must be at most one of is_cmd, extensible, and chained.\");\n    WireCmd commandId;\n\n    ObjectId self;\n    uint32_t groupIndex;\n    ObjectHandle result;\n};\n\nstatic_assert(offsetof(ComputePipelineGetBindGroupLayoutTransfer, commandSize) == 0);\nstatic_assert(offsetof(ComputePipelineGetBindGroupLayoutTransfer, commandId) == sizeof(CmdHeader));\n\nDAWN_DECLARE_UNUSED size_t ComputePipelineGetBindGroupLayoutGetExtraRequiredSize(const ComputePipelineGetBindGroupLayoutCmd& record) {\n    DAWN_UNUSED(record);\n    size_t result = 0;\n\n    return result;\n}\n// GetExtraRequiredSize isn't used for structures that are value members of other structures\n// because we assume they cannot contain pointers themselves.\nDAWN_UNUSED_FUNC(ComputePipelineGetBindGroupLayoutGetExtraRequiredSize);\n\nDAWN_DECLARE_UNUSED WireResult ComputePipelineGetBindGroupLayoutSerialize(\n    const ComputePipelineGetBindGroupLayoutCmd& record,\n    ComputePipelineGetBindGroupLayoutTransfer* transfer,\n    SerializeBuffer* buffer, const ObjectIdProvider& provider) {\n    DAWN_UNUSED(buffer);\n    transfer->commandId = WireCmd::ComputePipelineGetBindGroupLayout;\n\n\n    WIRE_TRY(provider.GetId(record.self, &transfer->self));\n    transfer->groupIndex = record.groupIndex;\n    transfer->result = record.result;\n\n    return WireResult::Success;\n}\nDAWN_UNUSED_FUNC(ComputePipelineGetBindGroupLayoutSerialize);\n\nDAWN_DECLARE_UNUSED WireResult ComputePipelineGetBindGroupLayoutDeserialize(\n    ComputePipelineGetBindGroupLayoutCmd* record,\n    const volatile ComputePipelineGetBindGroupLayoutTransfer* transfer,\n    DeserializeBuffer* deserializeBuffer,\n    DeserializeAllocator* allocator, const ObjectIdResolver& resolver) {\n    DAWN_UNUSED(allocator);\n\n    ASSERT(transfer->commandId == WireCmd::ComputePipelineGetBindGroupLayout);\n    record->selfId = transfer->self;\n\n\n    WIRE_TRY(resolver.GetFromId(transfer->self, &record->self));\n    static_assert(sizeof(record->groupIndex) >= sizeof(transfer->groupIndex), \"Deserialize assignment may not narrow.\");\n    record->groupIndex = transfer->groupIndex;\n    static_assert(sizeof(record->result) >= sizeof(transfer->result), \"Deserialize assignment may not narrow.\");\n    record->result = transfer->result;\n\n    return WireResult::Success;\n}\nDAWN_UNUSED_FUNC(ComputePipelineGetBindGroupLayoutDeserialize);\n\nstruct ComputePipelineSetLabelTransfer : CmdHeader {\n    static_assert(1 <= 1,\n                  \"Record must be at most one of is_cmd, extensible, and chained.\");\n    WireCmd commandId;\n\n    ObjectId self;\n    uint64_t labelStrlen;\n};\n\nstatic_assert(offsetof(ComputePipelineSetLabelTransfer, commandSize) == 0);\nstatic_assert(offsetof(ComputePipelineSetLabelTransfer, commandId) == sizeof(CmdHeader));\n\nDAWN_DECLARE_UNUSED size_t ComputePipelineSetLabelGetExtraRequiredSize(const ComputePipelineSetLabelCmd& record) {\n    DAWN_UNUSED(record);\n    size_t result = 0;\n\n    ASSERT(record.label != nullptr);\n    result += Align(std::strlen(record.label), kWireBufferAlignment);\n    return result;\n}\n// GetExtraRequiredSize isn't used for structures that are value members of other structures\n// because we assume they cannot contain pointers themselves.\nDAWN_UNUSED_FUNC(ComputePipelineSetLabelGetExtraRequiredSize);\n\nDAWN_DECLARE_UNUSED WireResult ComputePipelineSetLabelSerialize(\n    const ComputePipelineSetLabelCmd& record,\n    ComputePipelineSetLabelTransfer* transfer,\n    SerializeBuffer* buffer, const ObjectIdProvider& provider) {\n    DAWN_UNUSED(buffer);\n    transfer->commandId = WireCmd::ComputePipelineSetLabel;\n\n\n    WIRE_TRY(provider.GetId(record.self, &transfer->self));\n    {\n        transfer->labelStrlen = std::strlen(record.label);\n\n        char* stringInBuffer;\n        WIRE_TRY(buffer->NextN(transfer->labelStrlen, &stringInBuffer));\n        memcpy(stringInBuffer, record.label, transfer->labelStrlen);\n    }\n\n    return WireResult::Success;\n}\nDAWN_UNUSED_FUNC(ComputePipelineSetLabelSerialize);\n\nDAWN_DECLARE_UNUSED WireResult ComputePipelineSetLabelDeserialize(\n    ComputePipelineSetLabelCmd* record,\n    const volatile ComputePipelineSetLabelTransfer* transfer,\n    DeserializeBuffer* deserializeBuffer,\n    DeserializeAllocator* allocator, const ObjectIdResolver& resolver) {\n    DAWN_UNUSED(allocator);\n\n    ASSERT(transfer->commandId == WireCmd::ComputePipelineSetLabel);\n    record->selfId = transfer->self;\n\n\n    WIRE_TRY(resolver.GetFromId(transfer->self, &record->self));\n    {\n        uint64_t stringLength64 = transfer->labelStrlen;\n        if (stringLength64 >= std::numeric_limits<size_t>::max()) {\n            return WireResult::FatalError;\n        }\n        size_t stringLength = static_cast<size_t>(stringLength64);\n\n        const volatile char* stringInBuffer;\n        WIRE_TRY(deserializeBuffer->ReadN(stringLength, &stringInBuffer));\n\n        char* copiedString;\n        WIRE_TRY(GetSpace(allocator, stringLength + 1, &copiedString));\n        memcpy(copiedString, const_cast<const char*>(stringInBuffer), stringLength);\n        copiedString[stringLength] = '\\0';\n        record->label = copiedString;\n    }\n\n    return WireResult::Success;\n}\nDAWN_UNUSED_FUNC(ComputePipelineSetLabelDeserialize);\n\nstruct DestroyObjectTransfer : CmdHeader {\n    static_assert(1 <= 1,\n                  \"Record must be at most one of is_cmd, extensible, and chained.\");\n    WireCmd commandId;\n\n    ObjectType objectType;\n    ObjectId objectId;\n};\n\nstatic_assert(offsetof(DestroyObjectTransfer, commandSize) == 0);\nstatic_assert(offsetof(DestroyObjectTransfer, commandId) == sizeof(CmdHeader));\n\nDAWN_DECLARE_UNUSED size_t DestroyObjectGetExtraRequiredSize(const DestroyObjectCmd& record) {\n    DAWN_UNUSED(record);\n    size_t result = 0;\n\n    return result;\n}\n// GetExtraRequiredSize isn't used for structures that are value members of other structures\n// because we assume they cannot contain pointers themselves.\nDAWN_UNUSED_FUNC(DestroyObjectGetExtraRequiredSize);\n\nDAWN_DECLARE_UNUSED WireResult DestroyObjectSerialize(\n    const DestroyObjectCmd& record,\n    DestroyObjectTransfer* transfer,\n    SerializeBuffer* buffer) {\n    DAWN_UNUSED(buffer);\n    transfer->commandId = WireCmd::DestroyObject;\n\n\n    transfer->objectType = record.objectType;\n    transfer->objectId = record.objectId;\n\n    return WireResult::Success;\n}\nDAWN_UNUSED_FUNC(DestroyObjectSerialize);\n\nDAWN_DECLARE_UNUSED WireResult DestroyObjectDeserialize(\n    DestroyObjectCmd* record,\n    const volatile DestroyObjectTransfer* transfer,\n    DeserializeBuffer* deserializeBuffer,\n    DeserializeAllocator* allocator) {\n    DAWN_UNUSED(allocator);\n\n    ASSERT(transfer->commandId == WireCmd::DestroyObject);\n\n\n    static_assert(sizeof(record->objectType) >= sizeof(transfer->objectType), \"Deserialize assignment may not narrow.\");\n    record->objectType = transfer->objectType;\n    static_assert(sizeof(record->objectId) >= sizeof(transfer->objectId), \"Deserialize assignment may not narrow.\");\n    record->objectId = transfer->objectId;\n\n    return WireResult::Success;\n}\nDAWN_UNUSED_FUNC(DestroyObjectDeserialize);\n\nstruct DeviceCreateBindGroupTransfer : CmdHeader {\n    static_assert(1 <= 1,\n                  \"Record must be at most one of is_cmd, extensible, and chained.\");\n    WireCmd commandId;\n\n    ObjectId self;\n    ObjectHandle result;\n};\n\nstatic_assert(offsetof(DeviceCreateBindGroupTransfer, commandSize) == 0);\nstatic_assert(offsetof(DeviceCreateBindGroupTransfer, commandId) == sizeof(CmdHeader));\n\nDAWN_DECLARE_UNUSED size_t DeviceCreateBindGroupGetExtraRequiredSize(const DeviceCreateBindGroupCmd& record) {\n    DAWN_UNUSED(record);\n    size_t result = 0;\n\n    {\n        auto memberLength = 1u;\n        auto size = WireAlignSizeofN<WGPUBindGroupDescriptorTransfer>(memberLength);\n        ASSERT(size);\n        result += *size;\n        for (decltype(memberLength) i = 0; i < memberLength; ++i) {\n            result += WGPUBindGroupDescriptorGetExtraRequiredSize(record.descriptor[i]);\n        }\n    }\n    return result;\n}\n// GetExtraRequiredSize isn't used for structures that are value members of other structures\n// because we assume they cannot contain pointers themselves.\nDAWN_UNUSED_FUNC(DeviceCreateBindGroupGetExtraRequiredSize);\n\nDAWN_DECLARE_UNUSED WireResult DeviceCreateBindGroupSerialize(\n    const DeviceCreateBindGroupCmd& record,\n    DeviceCreateBindGroupTransfer* transfer,\n    SerializeBuffer* buffer, const ObjectIdProvider& provider) {\n    DAWN_UNUSED(buffer);\n    transfer->commandId = WireCmd::DeviceCreateBindGroup;\n\n\n    WIRE_TRY(provider.GetId(record.self, &transfer->self));\n    transfer->result = record.result;\n    {\n        auto memberLength = 1u;\n\n        WGPUBindGroupDescriptorTransfer* memberBuffer;\n        WIRE_TRY(buffer->NextN(memberLength, &memberBuffer));\n\n        for (decltype(memberLength) i = 0; i < memberLength; ++i) {\n            WIRE_TRY(WGPUBindGroupDescriptorSerialize(record.descriptor[i], &memberBuffer[i], buffer, provider));\n        }\n    }\n\n    return WireResult::Success;\n}\nDAWN_UNUSED_FUNC(DeviceCreateBindGroupSerialize);\n\nDAWN_DECLARE_UNUSED WireResult DeviceCreateBindGroupDeserialize(\n    DeviceCreateBindGroupCmd* record,\n    const volatile DeviceCreateBindGroupTransfer* transfer,\n    DeserializeBuffer* deserializeBuffer,\n    DeserializeAllocator* allocator, const ObjectIdResolver& resolver) {\n    DAWN_UNUSED(allocator);\n\n    ASSERT(transfer->commandId == WireCmd::DeviceCreateBindGroup);\n    record->selfId = transfer->self;\n\n\n    WIRE_TRY(resolver.GetFromId(transfer->self, &record->self));\n    static_assert(sizeof(record->result) >= sizeof(transfer->result), \"Deserialize assignment may not narrow.\");\n    record->result = transfer->result;\n    {\n        auto memberLength = 1u;\n        const volatile WGPUBindGroupDescriptorTransfer* memberBuffer;\n        WIRE_TRY(deserializeBuffer->ReadN(memberLength, &memberBuffer));\n\n        WGPUBindGroupDescriptor* copiedMembers;\n        WIRE_TRY(GetSpace(allocator, memberLength, &copiedMembers));\n        record->descriptor = copiedMembers;\n\n        for (decltype(memberLength) i = 0; i < memberLength; ++i) {\n            WIRE_TRY(WGPUBindGroupDescriptorDeserialize(&copiedMembers[i], &memberBuffer[i], deserializeBuffer, allocator, resolver));\n        }\n    }\n\n    return WireResult::Success;\n}\nDAWN_UNUSED_FUNC(DeviceCreateBindGroupDeserialize);\n\nstruct DeviceCreateBindGroupLayoutTransfer : CmdHeader {\n    static_assert(1 <= 1,\n                  \"Record must be at most one of is_cmd, extensible, and chained.\");\n    WireCmd commandId;\n\n    ObjectId self;\n    ObjectHandle result;\n};\n\nstatic_assert(offsetof(DeviceCreateBindGroupLayoutTransfer, commandSize) == 0);\nstatic_assert(offsetof(DeviceCreateBindGroupLayoutTransfer, commandId) == sizeof(CmdHeader));\n\nDAWN_DECLARE_UNUSED size_t DeviceCreateBindGroupLayoutGetExtraRequiredSize(const DeviceCreateBindGroupLayoutCmd& record) {\n    DAWN_UNUSED(record);\n    size_t result = 0;\n\n    {\n        auto memberLength = 1u;\n        auto size = WireAlignSizeofN<WGPUBindGroupLayoutDescriptorTransfer>(memberLength);\n        ASSERT(size);\n        result += *size;\n        for (decltype(memberLength) i = 0; i < memberLength; ++i) {\n            result += WGPUBindGroupLayoutDescriptorGetExtraRequiredSize(record.descriptor[i]);\n        }\n    }\n    return result;\n}\n// GetExtraRequiredSize isn't used for structures that are value members of other structures\n// because we assume they cannot contain pointers themselves.\nDAWN_UNUSED_FUNC(DeviceCreateBindGroupLayoutGetExtraRequiredSize);\n\nDAWN_DECLARE_UNUSED WireResult DeviceCreateBindGroupLayoutSerialize(\n    const DeviceCreateBindGroupLayoutCmd& record,\n    DeviceCreateBindGroupLayoutTransfer* transfer,\n    SerializeBuffer* buffer, const ObjectIdProvider& provider) {\n    DAWN_UNUSED(buffer);\n    transfer->commandId = WireCmd::DeviceCreateBindGroupLayout;\n\n\n    WIRE_TRY(provider.GetId(record.self, &transfer->self));\n    transfer->result = record.result;\n    {\n        auto memberLength = 1u;\n\n        WGPUBindGroupLayoutDescriptorTransfer* memberBuffer;\n        WIRE_TRY(buffer->NextN(memberLength, &memberBuffer));\n\n        for (decltype(memberLength) i = 0; i < memberLength; ++i) {\n            WIRE_TRY(WGPUBindGroupLayoutDescriptorSerialize(record.descriptor[i], &memberBuffer[i], buffer, provider));\n        }\n    }\n\n    return WireResult::Success;\n}\nDAWN_UNUSED_FUNC(DeviceCreateBindGroupLayoutSerialize);\n\nDAWN_DECLARE_UNUSED WireResult DeviceCreateBindGroupLayoutDeserialize(\n    DeviceCreateBindGroupLayoutCmd* record,\n    const volatile DeviceCreateBindGroupLayoutTransfer* transfer,\n    DeserializeBuffer* deserializeBuffer,\n    DeserializeAllocator* allocator, const ObjectIdResolver& resolver) {\n    DAWN_UNUSED(allocator);\n\n    ASSERT(transfer->commandId == WireCmd::DeviceCreateBindGroupLayout);\n    record->selfId = transfer->self;\n\n\n    WIRE_TRY(resolver.GetFromId(transfer->self, &record->self));\n    static_assert(sizeof(record->result) >= sizeof(transfer->result), \"Deserialize assignment may not narrow.\");\n    record->result = transfer->result;\n    {\n        auto memberLength = 1u;\n        const volatile WGPUBindGroupLayoutDescriptorTransfer* memberBuffer;\n        WIRE_TRY(deserializeBuffer->ReadN(memberLength, &memberBuffer));\n\n        WGPUBindGroupLayoutDescriptor* copiedMembers;\n        WIRE_TRY(GetSpace(allocator, memberLength, &copiedMembers));\n        record->descriptor = copiedMembers;\n\n        for (decltype(memberLength) i = 0; i < memberLength; ++i) {\n            WIRE_TRY(WGPUBindGroupLayoutDescriptorDeserialize(&copiedMembers[i], &memberBuffer[i], deserializeBuffer, allocator, resolver));\n        }\n    }\n\n    return WireResult::Success;\n}\nDAWN_UNUSED_FUNC(DeviceCreateBindGroupLayoutDeserialize);\n\nstruct DeviceCreateBufferTransfer : CmdHeader {\n    static_assert(1 <= 1,\n                  \"Record must be at most one of is_cmd, extensible, and chained.\");\n    WireCmd commandId;\n\n    ObjectId deviceId;\n    ObjectHandle result;\n    uint64_t readHandleCreateInfoLength;\n    uint64_t writeHandleCreateInfoLength;\n};\n\nstatic_assert(offsetof(DeviceCreateBufferTransfer, commandSize) == 0);\nstatic_assert(offsetof(DeviceCreateBufferTransfer, commandId) == sizeof(CmdHeader));\n\nDAWN_DECLARE_UNUSED size_t DeviceCreateBufferGetExtraRequiredSize(const DeviceCreateBufferCmd& record) {\n    DAWN_UNUSED(record);\n    size_t result = 0;\n\n    {\n        auto memberLength = 1u;\n        auto size = WireAlignSizeofN<WGPUBufferDescriptorTransfer>(memberLength);\n        ASSERT(size);\n        result += *size;\n        for (decltype(memberLength) i = 0; i < memberLength; ++i) {\n            result += WGPUBufferDescriptorGetExtraRequiredSize(record.descriptor[i]);\n        }\n    }\n    return result;\n}\n// GetExtraRequiredSize isn't used for structures that are value members of other structures\n// because we assume they cannot contain pointers themselves.\nDAWN_UNUSED_FUNC(DeviceCreateBufferGetExtraRequiredSize);\n\nDAWN_DECLARE_UNUSED WireResult DeviceCreateBufferSerialize(\n    const DeviceCreateBufferCmd& record,\n    DeviceCreateBufferTransfer* transfer,\n    SerializeBuffer* buffer, const ObjectIdProvider& provider) {\n    DAWN_UNUSED(buffer);\n    transfer->commandId = WireCmd::DeviceCreateBuffer;\n\n\n    transfer->deviceId = record.deviceId;\n    transfer->result = record.result;\n    transfer->readHandleCreateInfoLength = record.readHandleCreateInfoLength;\n    transfer->writeHandleCreateInfoLength = record.writeHandleCreateInfoLength;\n    {\n        auto memberLength = 1u;\n\n        WGPUBufferDescriptorTransfer* memberBuffer;\n        WIRE_TRY(buffer->NextN(memberLength, &memberBuffer));\n\n        for (decltype(memberLength) i = 0; i < memberLength; ++i) {\n            WIRE_TRY(WGPUBufferDescriptorSerialize(record.descriptor[i], &memberBuffer[i], buffer, provider));\n        }\n    }\n\n    return WireResult::Success;\n}\nDAWN_UNUSED_FUNC(DeviceCreateBufferSerialize);\n\nDAWN_DECLARE_UNUSED WireResult DeviceCreateBufferDeserialize(\n    DeviceCreateBufferCmd* record,\n    const volatile DeviceCreateBufferTransfer* transfer,\n    DeserializeBuffer* deserializeBuffer,\n    DeserializeAllocator* allocator, const ObjectIdResolver& resolver) {\n    DAWN_UNUSED(allocator);\n\n    ASSERT(transfer->commandId == WireCmd::DeviceCreateBuffer);\n\n\n    static_assert(sizeof(record->deviceId) >= sizeof(transfer->deviceId), \"Deserialize assignment may not narrow.\");\n    record->deviceId = transfer->deviceId;\n    static_assert(sizeof(record->result) >= sizeof(transfer->result), \"Deserialize assignment may not narrow.\");\n    record->result = transfer->result;\n    static_assert(sizeof(record->readHandleCreateInfoLength) >= sizeof(transfer->readHandleCreateInfoLength), \"Deserialize assignment may not narrow.\");\n    record->readHandleCreateInfoLength = transfer->readHandleCreateInfoLength;\n    static_assert(sizeof(record->writeHandleCreateInfoLength) >= sizeof(transfer->writeHandleCreateInfoLength), \"Deserialize assignment may not narrow.\");\n    record->writeHandleCreateInfoLength = transfer->writeHandleCreateInfoLength;\n    {\n        auto memberLength = 1u;\n        const volatile WGPUBufferDescriptorTransfer* memberBuffer;\n        WIRE_TRY(deserializeBuffer->ReadN(memberLength, &memberBuffer));\n\n        WGPUBufferDescriptor* copiedMembers;\n        WIRE_TRY(GetSpace(allocator, memberLength, &copiedMembers));\n        record->descriptor = copiedMembers;\n\n        for (decltype(memberLength) i = 0; i < memberLength; ++i) {\n            WIRE_TRY(WGPUBufferDescriptorDeserialize(&copiedMembers[i], &memberBuffer[i], deserializeBuffer, allocator, resolver));\n        }\n    }\n    {\n        auto memberLength = record->readHandleCreateInfoLength;\n        const volatile uint8_t* memberBuffer;\n        WIRE_TRY(deserializeBuffer->ReadN(memberLength, &memberBuffer));\n\n        uint8_t* copiedMembers;\n        WIRE_TRY(GetSpace(allocator, memberLength, &copiedMembers));\n        record->readHandleCreateInfo = copiedMembers;\n\n        memcpy(\n            copiedMembers,\n            const_cast<const uint8_t*>(memberBuffer),\n           sizeof(uint8_t) * memberLength);\n    }\n    {\n        auto memberLength = record->writeHandleCreateInfoLength;\n        const volatile uint8_t* memberBuffer;\n        WIRE_TRY(deserializeBuffer->ReadN(memberLength, &memberBuffer));\n\n        uint8_t* copiedMembers;\n        WIRE_TRY(GetSpace(allocator, memberLength, &copiedMembers));\n        record->writeHandleCreateInfo = copiedMembers;\n\n        memcpy(\n            copiedMembers,\n            const_cast<const uint8_t*>(memberBuffer),\n           sizeof(uint8_t) * memberLength);\n    }\n\n    return WireResult::Success;\n}\nDAWN_UNUSED_FUNC(DeviceCreateBufferDeserialize);\n\nstruct DeviceCreateCommandEncoderTransfer : CmdHeader {\n    static_assert(1 <= 1,\n                  \"Record must be at most one of is_cmd, extensible, and chained.\");\n    WireCmd commandId;\n\n    ObjectId self;\n    bool has_descriptor;\n    ObjectHandle result;\n};\n\nstatic_assert(offsetof(DeviceCreateCommandEncoderTransfer, commandSize) == 0);\nstatic_assert(offsetof(DeviceCreateCommandEncoderTransfer, commandId) == sizeof(CmdHeader));\n\nDAWN_DECLARE_UNUSED size_t DeviceCreateCommandEncoderGetExtraRequiredSize(const DeviceCreateCommandEncoderCmd& record) {\n    DAWN_UNUSED(record);\n    size_t result = 0;\n\n    if (record.descriptor != nullptr) {\n        auto memberLength = 1u;\n        auto size = WireAlignSizeofN<WGPUCommandEncoderDescriptorTransfer>(memberLength);\n        ASSERT(size);\n        result += *size;\n        for (decltype(memberLength) i = 0; i < memberLength; ++i) {\n            result += WGPUCommandEncoderDescriptorGetExtraRequiredSize(record.descriptor[i]);\n        }\n    }\n    return result;\n}\n// GetExtraRequiredSize isn't used for structures that are value members of other structures\n// because we assume they cannot contain pointers themselves.\nDAWN_UNUSED_FUNC(DeviceCreateCommandEncoderGetExtraRequiredSize);\n\nDAWN_DECLARE_UNUSED WireResult DeviceCreateCommandEncoderSerialize(\n    const DeviceCreateCommandEncoderCmd& record,\n    DeviceCreateCommandEncoderTransfer* transfer,\n    SerializeBuffer* buffer, const ObjectIdProvider& provider) {\n    DAWN_UNUSED(buffer);\n    transfer->commandId = WireCmd::DeviceCreateCommandEncoder;\n\n\n    WIRE_TRY(provider.GetId(record.self, &transfer->self));\n    transfer->result = record.result;\n    bool has_descriptor = record.descriptor != nullptr;\n    transfer->has_descriptor = has_descriptor;\n    if (has_descriptor) {\n        auto memberLength = 1u;\n\n        WGPUCommandEncoderDescriptorTransfer* memberBuffer;\n        WIRE_TRY(buffer->NextN(memberLength, &memberBuffer));\n\n        for (decltype(memberLength) i = 0; i < memberLength; ++i) {\n            WIRE_TRY(WGPUCommandEncoderDescriptorSerialize(record.descriptor[i], &memberBuffer[i], buffer, provider));\n        }\n    }\n\n    return WireResult::Success;\n}\nDAWN_UNUSED_FUNC(DeviceCreateCommandEncoderSerialize);\n\nDAWN_DECLARE_UNUSED WireResult DeviceCreateCommandEncoderDeserialize(\n    DeviceCreateCommandEncoderCmd* record,\n    const volatile DeviceCreateCommandEncoderTransfer* transfer,\n    DeserializeBuffer* deserializeBuffer,\n    DeserializeAllocator* allocator, const ObjectIdResolver& resolver) {\n    DAWN_UNUSED(allocator);\n\n    ASSERT(transfer->commandId == WireCmd::DeviceCreateCommandEncoder);\n    record->selfId = transfer->self;\n\n\n    WIRE_TRY(resolver.GetFromId(transfer->self, &record->self));\n    static_assert(sizeof(record->result) >= sizeof(transfer->result), \"Deserialize assignment may not narrow.\");\n    record->result = transfer->result;\n    bool has_descriptor = transfer->has_descriptor;\n    record->descriptor = nullptr;\n    if (has_descriptor) {\n        auto memberLength = 1u;\n        const volatile WGPUCommandEncoderDescriptorTransfer* memberBuffer;\n        WIRE_TRY(deserializeBuffer->ReadN(memberLength, &memberBuffer));\n\n        WGPUCommandEncoderDescriptor* copiedMembers;\n        WIRE_TRY(GetSpace(allocator, memberLength, &copiedMembers));\n        record->descriptor = copiedMembers;\n\n        for (decltype(memberLength) i = 0; i < memberLength; ++i) {\n            WIRE_TRY(WGPUCommandEncoderDescriptorDeserialize(&copiedMembers[i], &memberBuffer[i], deserializeBuffer, allocator, resolver));\n        }\n    }\n\n    return WireResult::Success;\n}\nDAWN_UNUSED_FUNC(DeviceCreateCommandEncoderDeserialize);\n\nstruct DeviceCreateComputePipelineTransfer : CmdHeader {\n    static_assert(1 <= 1,\n                  \"Record must be at most one of is_cmd, extensible, and chained.\");\n    WireCmd commandId;\n\n    ObjectId self;\n    ObjectHandle result;\n};\n\nstatic_assert(offsetof(DeviceCreateComputePipelineTransfer, commandSize) == 0);\nstatic_assert(offsetof(DeviceCreateComputePipelineTransfer, commandId) == sizeof(CmdHeader));\n\nDAWN_DECLARE_UNUSED size_t DeviceCreateComputePipelineGetExtraRequiredSize(const DeviceCreateComputePipelineCmd& record) {\n    DAWN_UNUSED(record);\n    size_t result = 0;\n\n    {\n        auto memberLength = 1u;\n        auto size = WireAlignSizeofN<WGPUComputePipelineDescriptorTransfer>(memberLength);\n        ASSERT(size);\n        result += *size;\n        for (decltype(memberLength) i = 0; i < memberLength; ++i) {\n            result += WGPUComputePipelineDescriptorGetExtraRequiredSize(record.descriptor[i]);\n        }\n    }\n    return result;\n}\n// GetExtraRequiredSize isn't used for structures that are value members of other structures\n// because we assume they cannot contain pointers themselves.\nDAWN_UNUSED_FUNC(DeviceCreateComputePipelineGetExtraRequiredSize);\n\nDAWN_DECLARE_UNUSED WireResult DeviceCreateComputePipelineSerialize(\n    const DeviceCreateComputePipelineCmd& record,\n    DeviceCreateComputePipelineTransfer* transfer,\n    SerializeBuffer* buffer, const ObjectIdProvider& provider) {\n    DAWN_UNUSED(buffer);\n    transfer->commandId = WireCmd::DeviceCreateComputePipeline;\n\n\n    WIRE_TRY(provider.GetId(record.self, &transfer->self));\n    transfer->result = record.result;\n    {\n        auto memberLength = 1u;\n\n        WGPUComputePipelineDescriptorTransfer* memberBuffer;\n        WIRE_TRY(buffer->NextN(memberLength, &memberBuffer));\n\n        for (decltype(memberLength) i = 0; i < memberLength; ++i) {\n            WIRE_TRY(WGPUComputePipelineDescriptorSerialize(record.descriptor[i], &memberBuffer[i], buffer, provider));\n        }\n    }\n\n    return WireResult::Success;\n}\nDAWN_UNUSED_FUNC(DeviceCreateComputePipelineSerialize);\n\nDAWN_DECLARE_UNUSED WireResult DeviceCreateComputePipelineDeserialize(\n    DeviceCreateComputePipelineCmd* record,\n    const volatile DeviceCreateComputePipelineTransfer* transfer,\n    DeserializeBuffer* deserializeBuffer,\n    DeserializeAllocator* allocator, const ObjectIdResolver& resolver) {\n    DAWN_UNUSED(allocator);\n\n    ASSERT(transfer->commandId == WireCmd::DeviceCreateComputePipeline);\n    record->selfId = transfer->self;\n\n\n    WIRE_TRY(resolver.GetFromId(transfer->self, &record->self));\n    static_assert(sizeof(record->result) >= sizeof(transfer->result), \"Deserialize assignment may not narrow.\");\n    record->result = transfer->result;\n    {\n        auto memberLength = 1u;\n        const volatile WGPUComputePipelineDescriptorTransfer* memberBuffer;\n        WIRE_TRY(deserializeBuffer->ReadN(memberLength, &memberBuffer));\n\n        WGPUComputePipelineDescriptor* copiedMembers;\n        WIRE_TRY(GetSpace(allocator, memberLength, &copiedMembers));\n        record->descriptor = copiedMembers;\n\n        for (decltype(memberLength) i = 0; i < memberLength; ++i) {\n            WIRE_TRY(WGPUComputePipelineDescriptorDeserialize(&copiedMembers[i], &memberBuffer[i], deserializeBuffer, allocator, resolver));\n        }\n    }\n\n    return WireResult::Success;\n}\nDAWN_UNUSED_FUNC(DeviceCreateComputePipelineDeserialize);\n\nstruct DeviceCreateComputePipelineAsyncTransfer : CmdHeader {\n    static_assert(1 <= 1,\n                  \"Record must be at most one of is_cmd, extensible, and chained.\");\n    WireCmd commandId;\n\n    ObjectId deviceId;\n    uint64_t requestSerial;\n    ObjectHandle pipelineObjectHandle;\n};\n\nstatic_assert(offsetof(DeviceCreateComputePipelineAsyncTransfer, commandSize) == 0);\nstatic_assert(offsetof(DeviceCreateComputePipelineAsyncTransfer, commandId) == sizeof(CmdHeader));\n\nDAWN_DECLARE_UNUSED size_t DeviceCreateComputePipelineAsyncGetExtraRequiredSize(const DeviceCreateComputePipelineAsyncCmd& record) {\n    DAWN_UNUSED(record);\n    size_t result = 0;\n\n    {\n        auto memberLength = 1u;\n        auto size = WireAlignSizeofN<WGPUComputePipelineDescriptorTransfer>(memberLength);\n        ASSERT(size);\n        result += *size;\n        for (decltype(memberLength) i = 0; i < memberLength; ++i) {\n            result += WGPUComputePipelineDescriptorGetExtraRequiredSize(record.descriptor[i]);\n        }\n    }\n    return result;\n}\n// GetExtraRequiredSize isn't used for structures that are value members of other structures\n// because we assume they cannot contain pointers themselves.\nDAWN_UNUSED_FUNC(DeviceCreateComputePipelineAsyncGetExtraRequiredSize);\n\nDAWN_DECLARE_UNUSED WireResult DeviceCreateComputePipelineAsyncSerialize(\n    const DeviceCreateComputePipelineAsyncCmd& record,\n    DeviceCreateComputePipelineAsyncTransfer* transfer,\n    SerializeBuffer* buffer, const ObjectIdProvider& provider) {\n    DAWN_UNUSED(buffer);\n    transfer->commandId = WireCmd::DeviceCreateComputePipelineAsync;\n\n\n    transfer->deviceId = record.deviceId;\n    transfer->requestSerial = record.requestSerial;\n    transfer->pipelineObjectHandle = record.pipelineObjectHandle;\n    {\n        auto memberLength = 1u;\n\n        WGPUComputePipelineDescriptorTransfer* memberBuffer;\n        WIRE_TRY(buffer->NextN(memberLength, &memberBuffer));\n\n        for (decltype(memberLength) i = 0; i < memberLength; ++i) {\n            WIRE_TRY(WGPUComputePipelineDescriptorSerialize(record.descriptor[i], &memberBuffer[i], buffer, provider));\n        }\n    }\n\n    return WireResult::Success;\n}\nDAWN_UNUSED_FUNC(DeviceCreateComputePipelineAsyncSerialize);\n\nDAWN_DECLARE_UNUSED WireResult DeviceCreateComputePipelineAsyncDeserialize(\n    DeviceCreateComputePipelineAsyncCmd* record,\n    const volatile DeviceCreateComputePipelineAsyncTransfer* transfer,\n    DeserializeBuffer* deserializeBuffer,\n    DeserializeAllocator* allocator, const ObjectIdResolver& resolver) {\n    DAWN_UNUSED(allocator);\n\n    ASSERT(transfer->commandId == WireCmd::DeviceCreateComputePipelineAsync);\n\n\n    static_assert(sizeof(record->deviceId) >= sizeof(transfer->deviceId), \"Deserialize assignment may not narrow.\");\n    record->deviceId = transfer->deviceId;\n    static_assert(sizeof(record->requestSerial) >= sizeof(transfer->requestSerial), \"Deserialize assignment may not narrow.\");\n    record->requestSerial = transfer->requestSerial;\n    static_assert(sizeof(record->pipelineObjectHandle) >= sizeof(transfer->pipelineObjectHandle), \"Deserialize assignment may not narrow.\");\n    record->pipelineObjectHandle = transfer->pipelineObjectHandle;\n    {\n        auto memberLength = 1u;\n        const volatile WGPUComputePipelineDescriptorTransfer* memberBuffer;\n        WIRE_TRY(deserializeBuffer->ReadN(memberLength, &memberBuffer));\n\n        WGPUComputePipelineDescriptor* copiedMembers;\n        WIRE_TRY(GetSpace(allocator, memberLength, &copiedMembers));\n        record->descriptor = copiedMembers;\n\n        for (decltype(memberLength) i = 0; i < memberLength; ++i) {\n            WIRE_TRY(WGPUComputePipelineDescriptorDeserialize(&copiedMembers[i], &memberBuffer[i], deserializeBuffer, allocator, resolver));\n        }\n    }\n\n    return WireResult::Success;\n}\nDAWN_UNUSED_FUNC(DeviceCreateComputePipelineAsyncDeserialize);\n\nstruct DeviceCreateErrorBufferTransfer : CmdHeader {\n    static_assert(1 <= 1,\n                  \"Record must be at most one of is_cmd, extensible, and chained.\");\n    WireCmd commandId;\n\n    ObjectId self;\n    ObjectHandle result;\n};\n\nstatic_assert(offsetof(DeviceCreateErrorBufferTransfer, commandSize) == 0);\nstatic_assert(offsetof(DeviceCreateErrorBufferTransfer, commandId) == sizeof(CmdHeader));\n\nDAWN_DECLARE_UNUSED size_t DeviceCreateErrorBufferGetExtraRequiredSize(const DeviceCreateErrorBufferCmd& record) {\n    DAWN_UNUSED(record);\n    size_t result = 0;\n\n    {\n        auto memberLength = 1u;\n        auto size = WireAlignSizeofN<WGPUBufferDescriptorTransfer>(memberLength);\n        ASSERT(size);\n        result += *size;\n        for (decltype(memberLength) i = 0; i < memberLength; ++i) {\n            result += WGPUBufferDescriptorGetExtraRequiredSize(record.descriptor[i]);\n        }\n    }\n    return result;\n}\n// GetExtraRequiredSize isn't used for structures that are value members of other structures\n// because we assume they cannot contain pointers themselves.\nDAWN_UNUSED_FUNC(DeviceCreateErrorBufferGetExtraRequiredSize);\n\nDAWN_DECLARE_UNUSED WireResult DeviceCreateErrorBufferSerialize(\n    const DeviceCreateErrorBufferCmd& record,\n    DeviceCreateErrorBufferTransfer* transfer,\n    SerializeBuffer* buffer, const ObjectIdProvider& provider) {\n    DAWN_UNUSED(buffer);\n    transfer->commandId = WireCmd::DeviceCreateErrorBuffer;\n\n\n    WIRE_TRY(provider.GetId(record.self, &transfer->self));\n    transfer->result = record.result;\n    {\n        auto memberLength = 1u;\n\n        WGPUBufferDescriptorTransfer* memberBuffer;\n        WIRE_TRY(buffer->NextN(memberLength, &memberBuffer));\n\n        for (decltype(memberLength) i = 0; i < memberLength; ++i) {\n            WIRE_TRY(WGPUBufferDescriptorSerialize(record.descriptor[i], &memberBuffer[i], buffer, provider));\n        }\n    }\n\n    return WireResult::Success;\n}\nDAWN_UNUSED_FUNC(DeviceCreateErrorBufferSerialize);\n\nDAWN_DECLARE_UNUSED WireResult DeviceCreateErrorBufferDeserialize(\n    DeviceCreateErrorBufferCmd* record,\n    const volatile DeviceCreateErrorBufferTransfer* transfer,\n    DeserializeBuffer* deserializeBuffer,\n    DeserializeAllocator* allocator, const ObjectIdResolver& resolver) {\n    DAWN_UNUSED(allocator);\n\n    ASSERT(transfer->commandId == WireCmd::DeviceCreateErrorBuffer);\n    record->selfId = transfer->self;\n\n\n    WIRE_TRY(resolver.GetFromId(transfer->self, &record->self));\n    static_assert(sizeof(record->result) >= sizeof(transfer->result), \"Deserialize assignment may not narrow.\");\n    record->result = transfer->result;\n    {\n        auto memberLength = 1u;\n        const volatile WGPUBufferDescriptorTransfer* memberBuffer;\n        WIRE_TRY(deserializeBuffer->ReadN(memberLength, &memberBuffer));\n\n        WGPUBufferDescriptor* copiedMembers;\n        WIRE_TRY(GetSpace(allocator, memberLength, &copiedMembers));\n        record->descriptor = copiedMembers;\n\n        for (decltype(memberLength) i = 0; i < memberLength; ++i) {\n            WIRE_TRY(WGPUBufferDescriptorDeserialize(&copiedMembers[i], &memberBuffer[i], deserializeBuffer, allocator, resolver));\n        }\n    }\n\n    return WireResult::Success;\n}\nDAWN_UNUSED_FUNC(DeviceCreateErrorBufferDeserialize);\n\nstruct DeviceCreateErrorExternalTextureTransfer : CmdHeader {\n    static_assert(1 <= 1,\n                  \"Record must be at most one of is_cmd, extensible, and chained.\");\n    WireCmd commandId;\n\n    ObjectId self;\n    ObjectHandle result;\n};\n\nstatic_assert(offsetof(DeviceCreateErrorExternalTextureTransfer, commandSize) == 0);\nstatic_assert(offsetof(DeviceCreateErrorExternalTextureTransfer, commandId) == sizeof(CmdHeader));\n\nDAWN_DECLARE_UNUSED size_t DeviceCreateErrorExternalTextureGetExtraRequiredSize(const DeviceCreateErrorExternalTextureCmd& record) {\n    DAWN_UNUSED(record);\n    size_t result = 0;\n\n    return result;\n}\n// GetExtraRequiredSize isn't used for structures that are value members of other structures\n// because we assume they cannot contain pointers themselves.\nDAWN_UNUSED_FUNC(DeviceCreateErrorExternalTextureGetExtraRequiredSize);\n\nDAWN_DECLARE_UNUSED WireResult DeviceCreateErrorExternalTextureSerialize(\n    const DeviceCreateErrorExternalTextureCmd& record,\n    DeviceCreateErrorExternalTextureTransfer* transfer,\n    SerializeBuffer* buffer, const ObjectIdProvider& provider) {\n    DAWN_UNUSED(buffer);\n    transfer->commandId = WireCmd::DeviceCreateErrorExternalTexture;\n\n\n    WIRE_TRY(provider.GetId(record.self, &transfer->self));\n    transfer->result = record.result;\n\n    return WireResult::Success;\n}\nDAWN_UNUSED_FUNC(DeviceCreateErrorExternalTextureSerialize);\n\nDAWN_DECLARE_UNUSED WireResult DeviceCreateErrorExternalTextureDeserialize(\n    DeviceCreateErrorExternalTextureCmd* record,\n    const volatile DeviceCreateErrorExternalTextureTransfer* transfer,\n    DeserializeBuffer* deserializeBuffer,\n    DeserializeAllocator* allocator, const ObjectIdResolver& resolver) {\n    DAWN_UNUSED(allocator);\n\n    ASSERT(transfer->commandId == WireCmd::DeviceCreateErrorExternalTexture);\n    record->selfId = transfer->self;\n\n\n    WIRE_TRY(resolver.GetFromId(transfer->self, &record->self));\n    static_assert(sizeof(record->result) >= sizeof(transfer->result), \"Deserialize assignment may not narrow.\");\n    record->result = transfer->result;\n\n    return WireResult::Success;\n}\nDAWN_UNUSED_FUNC(DeviceCreateErrorExternalTextureDeserialize);\n\nstruct DeviceCreateErrorShaderModuleTransfer : CmdHeader {\n    static_assert(1 <= 1,\n                  \"Record must be at most one of is_cmd, extensible, and chained.\");\n    WireCmd commandId;\n\n    ObjectId self;\n    uint64_t errorMessageStrlen;\n    ObjectHandle result;\n};\n\nstatic_assert(offsetof(DeviceCreateErrorShaderModuleTransfer, commandSize) == 0);\nstatic_assert(offsetof(DeviceCreateErrorShaderModuleTransfer, commandId) == sizeof(CmdHeader));\n\nDAWN_DECLARE_UNUSED size_t DeviceCreateErrorShaderModuleGetExtraRequiredSize(const DeviceCreateErrorShaderModuleCmd& record) {\n    DAWN_UNUSED(record);\n    size_t result = 0;\n\n    {\n        auto memberLength = 1u;\n        auto size = WireAlignSizeofN<WGPUShaderModuleDescriptorTransfer>(memberLength);\n        ASSERT(size);\n        result += *size;\n        for (decltype(memberLength) i = 0; i < memberLength; ++i) {\n            result += WGPUShaderModuleDescriptorGetExtraRequiredSize(record.descriptor[i]);\n        }\n    }\n    ASSERT(record.errorMessage != nullptr);\n    result += Align(std::strlen(record.errorMessage), kWireBufferAlignment);\n    return result;\n}\n// GetExtraRequiredSize isn't used for structures that are value members of other structures\n// because we assume they cannot contain pointers themselves.\nDAWN_UNUSED_FUNC(DeviceCreateErrorShaderModuleGetExtraRequiredSize);\n\nDAWN_DECLARE_UNUSED WireResult DeviceCreateErrorShaderModuleSerialize(\n    const DeviceCreateErrorShaderModuleCmd& record,\n    DeviceCreateErrorShaderModuleTransfer* transfer,\n    SerializeBuffer* buffer, const ObjectIdProvider& provider) {\n    DAWN_UNUSED(buffer);\n    transfer->commandId = WireCmd::DeviceCreateErrorShaderModule;\n\n\n    WIRE_TRY(provider.GetId(record.self, &transfer->self));\n    transfer->result = record.result;\n    {\n        auto memberLength = 1u;\n\n        WGPUShaderModuleDescriptorTransfer* memberBuffer;\n        WIRE_TRY(buffer->NextN(memberLength, &memberBuffer));\n\n        for (decltype(memberLength) i = 0; i < memberLength; ++i) {\n            WIRE_TRY(WGPUShaderModuleDescriptorSerialize(record.descriptor[i], &memberBuffer[i], buffer, provider));\n        }\n    }\n    {\n        transfer->errorMessageStrlen = std::strlen(record.errorMessage);\n\n        char* stringInBuffer;\n        WIRE_TRY(buffer->NextN(transfer->errorMessageStrlen, &stringInBuffer));\n        memcpy(stringInBuffer, record.errorMessage, transfer->errorMessageStrlen);\n    }\n\n    return WireResult::Success;\n}\nDAWN_UNUSED_FUNC(DeviceCreateErrorShaderModuleSerialize);\n\nDAWN_DECLARE_UNUSED WireResult DeviceCreateErrorShaderModuleDeserialize(\n    DeviceCreateErrorShaderModuleCmd* record,\n    const volatile DeviceCreateErrorShaderModuleTransfer* transfer,\n    DeserializeBuffer* deserializeBuffer,\n    DeserializeAllocator* allocator, const ObjectIdResolver& resolver) {\n    DAWN_UNUSED(allocator);\n\n    ASSERT(transfer->commandId == WireCmd::DeviceCreateErrorShaderModule);\n    record->selfId = transfer->self;\n\n\n    WIRE_TRY(resolver.GetFromId(transfer->self, &record->self));\n    static_assert(sizeof(record->result) >= sizeof(transfer->result), \"Deserialize assignment may not narrow.\");\n    record->result = transfer->result;\n    {\n        auto memberLength = 1u;\n        const volatile WGPUShaderModuleDescriptorTransfer* memberBuffer;\n        WIRE_TRY(deserializeBuffer->ReadN(memberLength, &memberBuffer));\n\n        WGPUShaderModuleDescriptor* copiedMembers;\n        WIRE_TRY(GetSpace(allocator, memberLength, &copiedMembers));\n        record->descriptor = copiedMembers;\n\n        for (decltype(memberLength) i = 0; i < memberLength; ++i) {\n            WIRE_TRY(WGPUShaderModuleDescriptorDeserialize(&copiedMembers[i], &memberBuffer[i], deserializeBuffer, allocator, resolver));\n        }\n    }\n    {\n        uint64_t stringLength64 = transfer->errorMessageStrlen;\n        if (stringLength64 >= std::numeric_limits<size_t>::max()) {\n            return WireResult::FatalError;\n        }\n        size_t stringLength = static_cast<size_t>(stringLength64);\n\n        const volatile char* stringInBuffer;\n        WIRE_TRY(deserializeBuffer->ReadN(stringLength, &stringInBuffer));\n\n        char* copiedString;\n        WIRE_TRY(GetSpace(allocator, stringLength + 1, &copiedString));\n        memcpy(copiedString, const_cast<const char*>(stringInBuffer), stringLength);\n        copiedString[stringLength] = '\\0';\n        record->errorMessage = copiedString;\n    }\n\n    return WireResult::Success;\n}\nDAWN_UNUSED_FUNC(DeviceCreateErrorShaderModuleDeserialize);\n\nstruct DeviceCreateErrorTextureTransfer : CmdHeader {\n    static_assert(1 <= 1,\n                  \"Record must be at most one of is_cmd, extensible, and chained.\");\n    WireCmd commandId;\n\n    ObjectId self;\n    ObjectHandle result;\n};\n\nstatic_assert(offsetof(DeviceCreateErrorTextureTransfer, commandSize) == 0);\nstatic_assert(offsetof(DeviceCreateErrorTextureTransfer, commandId) == sizeof(CmdHeader));\n\nDAWN_DECLARE_UNUSED size_t DeviceCreateErrorTextureGetExtraRequiredSize(const DeviceCreateErrorTextureCmd& record) {\n    DAWN_UNUSED(record);\n    size_t result = 0;\n\n    {\n        auto memberLength = 1u;\n        auto size = WireAlignSizeofN<WGPUTextureDescriptorTransfer>(memberLength);\n        ASSERT(size);\n        result += *size;\n        for (decltype(memberLength) i = 0; i < memberLength; ++i) {\n            result += WGPUTextureDescriptorGetExtraRequiredSize(record.descriptor[i]);\n        }\n    }\n    return result;\n}\n// GetExtraRequiredSize isn't used for structures that are value members of other structures\n// because we assume they cannot contain pointers themselves.\nDAWN_UNUSED_FUNC(DeviceCreateErrorTextureGetExtraRequiredSize);\n\nDAWN_DECLARE_UNUSED WireResult DeviceCreateErrorTextureSerialize(\n    const DeviceCreateErrorTextureCmd& record,\n    DeviceCreateErrorTextureTransfer* transfer,\n    SerializeBuffer* buffer, const ObjectIdProvider& provider) {\n    DAWN_UNUSED(buffer);\n    transfer->commandId = WireCmd::DeviceCreateErrorTexture;\n\n\n    WIRE_TRY(provider.GetId(record.self, &transfer->self));\n    transfer->result = record.result;\n    {\n        auto memberLength = 1u;\n\n        WGPUTextureDescriptorTransfer* memberBuffer;\n        WIRE_TRY(buffer->NextN(memberLength, &memberBuffer));\n\n        for (decltype(memberLength) i = 0; i < memberLength; ++i) {\n            WIRE_TRY(WGPUTextureDescriptorSerialize(record.descriptor[i], &memberBuffer[i], buffer, provider));\n        }\n    }\n\n    return WireResult::Success;\n}\nDAWN_UNUSED_FUNC(DeviceCreateErrorTextureSerialize);\n\nDAWN_DECLARE_UNUSED WireResult DeviceCreateErrorTextureDeserialize(\n    DeviceCreateErrorTextureCmd* record,\n    const volatile DeviceCreateErrorTextureTransfer* transfer,\n    DeserializeBuffer* deserializeBuffer,\n    DeserializeAllocator* allocator, const ObjectIdResolver& resolver) {\n    DAWN_UNUSED(allocator);\n\n    ASSERT(transfer->commandId == WireCmd::DeviceCreateErrorTexture);\n    record->selfId = transfer->self;\n\n\n    WIRE_TRY(resolver.GetFromId(transfer->self, &record->self));\n    static_assert(sizeof(record->result) >= sizeof(transfer->result), \"Deserialize assignment may not narrow.\");\n    record->result = transfer->result;\n    {\n        auto memberLength = 1u;\n        const volatile WGPUTextureDescriptorTransfer* memberBuffer;\n        WIRE_TRY(deserializeBuffer->ReadN(memberLength, &memberBuffer));\n\n        WGPUTextureDescriptor* copiedMembers;\n        WIRE_TRY(GetSpace(allocator, memberLength, &copiedMembers));\n        record->descriptor = copiedMembers;\n\n        for (decltype(memberLength) i = 0; i < memberLength; ++i) {\n            WIRE_TRY(WGPUTextureDescriptorDeserialize(&copiedMembers[i], &memberBuffer[i], deserializeBuffer, allocator, resolver));\n        }\n    }\n\n    return WireResult::Success;\n}\nDAWN_UNUSED_FUNC(DeviceCreateErrorTextureDeserialize);\n\nstruct DeviceCreateExternalTextureTransfer : CmdHeader {\n    static_assert(1 <= 1,\n                  \"Record must be at most one of is_cmd, extensible, and chained.\");\n    WireCmd commandId;\n\n    ObjectId self;\n    ObjectHandle result;\n};\n\nstatic_assert(offsetof(DeviceCreateExternalTextureTransfer, commandSize) == 0);\nstatic_assert(offsetof(DeviceCreateExternalTextureTransfer, commandId) == sizeof(CmdHeader));\n\nDAWN_DECLARE_UNUSED size_t DeviceCreateExternalTextureGetExtraRequiredSize(const DeviceCreateExternalTextureCmd& record) {\n    DAWN_UNUSED(record);\n    size_t result = 0;\n\n    {\n        auto memberLength = 1u;\n        auto size = WireAlignSizeofN<WGPUExternalTextureDescriptorTransfer>(memberLength);\n        ASSERT(size);\n        result += *size;\n        for (decltype(memberLength) i = 0; i < memberLength; ++i) {\n            result += WGPUExternalTextureDescriptorGetExtraRequiredSize(record.externalTextureDescriptor[i]);\n        }\n    }\n    return result;\n}\n// GetExtraRequiredSize isn't used for structures that are value members of other structures\n// because we assume they cannot contain pointers themselves.\nDAWN_UNUSED_FUNC(DeviceCreateExternalTextureGetExtraRequiredSize);\n\nDAWN_DECLARE_UNUSED WireResult DeviceCreateExternalTextureSerialize(\n    const DeviceCreateExternalTextureCmd& record,\n    DeviceCreateExternalTextureTransfer* transfer,\n    SerializeBuffer* buffer, const ObjectIdProvider& provider) {\n    DAWN_UNUSED(buffer);\n    transfer->commandId = WireCmd::DeviceCreateExternalTexture;\n\n\n    WIRE_TRY(provider.GetId(record.self, &transfer->self));\n    transfer->result = record.result;\n    {\n        auto memberLength = 1u;\n\n        WGPUExternalTextureDescriptorTransfer* memberBuffer;\n        WIRE_TRY(buffer->NextN(memberLength, &memberBuffer));\n\n        for (decltype(memberLength) i = 0; i < memberLength; ++i) {\n            WIRE_TRY(WGPUExternalTextureDescriptorSerialize(record.externalTextureDescriptor[i], &memberBuffer[i], buffer, provider));\n        }\n    }\n\n    return WireResult::Success;\n}\nDAWN_UNUSED_FUNC(DeviceCreateExternalTextureSerialize);\n\nDAWN_DECLARE_UNUSED WireResult DeviceCreateExternalTextureDeserialize(\n    DeviceCreateExternalTextureCmd* record,\n    const volatile DeviceCreateExternalTextureTransfer* transfer,\n    DeserializeBuffer* deserializeBuffer,\n    DeserializeAllocator* allocator, const ObjectIdResolver& resolver) {\n    DAWN_UNUSED(allocator);\n\n    ASSERT(transfer->commandId == WireCmd::DeviceCreateExternalTexture);\n    record->selfId = transfer->self;\n\n\n    WIRE_TRY(resolver.GetFromId(transfer->self, &record->self));\n    static_assert(sizeof(record->result) >= sizeof(transfer->result), \"Deserialize assignment may not narrow.\");\n    record->result = transfer->result;\n    {\n        auto memberLength = 1u;\n        const volatile WGPUExternalTextureDescriptorTransfer* memberBuffer;\n        WIRE_TRY(deserializeBuffer->ReadN(memberLength, &memberBuffer));\n\n        WGPUExternalTextureDescriptor* copiedMembers;\n        WIRE_TRY(GetSpace(allocator, memberLength, &copiedMembers));\n        record->externalTextureDescriptor = copiedMembers;\n\n        for (decltype(memberLength) i = 0; i < memberLength; ++i) {\n            WIRE_TRY(WGPUExternalTextureDescriptorDeserialize(&copiedMembers[i], &memberBuffer[i], deserializeBuffer, allocator, resolver));\n        }\n    }\n\n    return WireResult::Success;\n}\nDAWN_UNUSED_FUNC(DeviceCreateExternalTextureDeserialize);\n\nstruct DeviceCreatePipelineLayoutTransfer : CmdHeader {\n    static_assert(1 <= 1,\n                  \"Record must be at most one of is_cmd, extensible, and chained.\");\n    WireCmd commandId;\n\n    ObjectId self;\n    ObjectHandle result;\n};\n\nstatic_assert(offsetof(DeviceCreatePipelineLayoutTransfer, commandSize) == 0);\nstatic_assert(offsetof(DeviceCreatePipelineLayoutTransfer, commandId) == sizeof(CmdHeader));\n\nDAWN_DECLARE_UNUSED size_t DeviceCreatePipelineLayoutGetExtraRequiredSize(const DeviceCreatePipelineLayoutCmd& record) {\n    DAWN_UNUSED(record);\n    size_t result = 0;\n\n    {\n        auto memberLength = 1u;\n        auto size = WireAlignSizeofN<WGPUPipelineLayoutDescriptorTransfer>(memberLength);\n        ASSERT(size);\n        result += *size;\n        for (decltype(memberLength) i = 0; i < memberLength; ++i) {\n            result += WGPUPipelineLayoutDescriptorGetExtraRequiredSize(record.descriptor[i]);\n        }\n    }\n    return result;\n}\n// GetExtraRequiredSize isn't used for structures that are value members of other structures\n// because we assume they cannot contain pointers themselves.\nDAWN_UNUSED_FUNC(DeviceCreatePipelineLayoutGetExtraRequiredSize);\n\nDAWN_DECLARE_UNUSED WireResult DeviceCreatePipelineLayoutSerialize(\n    const DeviceCreatePipelineLayoutCmd& record,\n    DeviceCreatePipelineLayoutTransfer* transfer,\n    SerializeBuffer* buffer, const ObjectIdProvider& provider) {\n    DAWN_UNUSED(buffer);\n    transfer->commandId = WireCmd::DeviceCreatePipelineLayout;\n\n\n    WIRE_TRY(provider.GetId(record.self, &transfer->self));\n    transfer->result = record.result;\n    {\n        auto memberLength = 1u;\n\n        WGPUPipelineLayoutDescriptorTransfer* memberBuffer;\n        WIRE_TRY(buffer->NextN(memberLength, &memberBuffer));\n\n        for (decltype(memberLength) i = 0; i < memberLength; ++i) {\n            WIRE_TRY(WGPUPipelineLayoutDescriptorSerialize(record.descriptor[i], &memberBuffer[i], buffer, provider));\n        }\n    }\n\n    return WireResult::Success;\n}\nDAWN_UNUSED_FUNC(DeviceCreatePipelineLayoutSerialize);\n\nDAWN_DECLARE_UNUSED WireResult DeviceCreatePipelineLayoutDeserialize(\n    DeviceCreatePipelineLayoutCmd* record,\n    const volatile DeviceCreatePipelineLayoutTransfer* transfer,\n    DeserializeBuffer* deserializeBuffer,\n    DeserializeAllocator* allocator, const ObjectIdResolver& resolver) {\n    DAWN_UNUSED(allocator);\n\n    ASSERT(transfer->commandId == WireCmd::DeviceCreatePipelineLayout);\n    record->selfId = transfer->self;\n\n\n    WIRE_TRY(resolver.GetFromId(transfer->self, &record->self));\n    static_assert(sizeof(record->result) >= sizeof(transfer->result), \"Deserialize assignment may not narrow.\");\n    record->result = transfer->result;\n    {\n        auto memberLength = 1u;\n        const volatile WGPUPipelineLayoutDescriptorTransfer* memberBuffer;\n        WIRE_TRY(deserializeBuffer->ReadN(memberLength, &memberBuffer));\n\n        WGPUPipelineLayoutDescriptor* copiedMembers;\n        WIRE_TRY(GetSpace(allocator, memberLength, &copiedMembers));\n        record->descriptor = copiedMembers;\n\n        for (decltype(memberLength) i = 0; i < memberLength; ++i) {\n            WIRE_TRY(WGPUPipelineLayoutDescriptorDeserialize(&copiedMembers[i], &memberBuffer[i], deserializeBuffer, allocator, resolver));\n        }\n    }\n\n    return WireResult::Success;\n}\nDAWN_UNUSED_FUNC(DeviceCreatePipelineLayoutDeserialize);\n\nstruct DeviceCreateQuerySetTransfer : CmdHeader {\n    static_assert(1 <= 1,\n                  \"Record must be at most one of is_cmd, extensible, and chained.\");\n    WireCmd commandId;\n\n    ObjectId self;\n    ObjectHandle result;\n};\n\nstatic_assert(offsetof(DeviceCreateQuerySetTransfer, commandSize) == 0);\nstatic_assert(offsetof(DeviceCreateQuerySetTransfer, commandId) == sizeof(CmdHeader));\n\nDAWN_DECLARE_UNUSED size_t DeviceCreateQuerySetGetExtraRequiredSize(const DeviceCreateQuerySetCmd& record) {\n    DAWN_UNUSED(record);\n    size_t result = 0;\n\n    {\n        auto memberLength = 1u;\n        auto size = WireAlignSizeofN<WGPUQuerySetDescriptorTransfer>(memberLength);\n        ASSERT(size);\n        result += *size;\n        for (decltype(memberLength) i = 0; i < memberLength; ++i) {\n            result += WGPUQuerySetDescriptorGetExtraRequiredSize(record.descriptor[i]);\n        }\n    }\n    return result;\n}\n// GetExtraRequiredSize isn't used for structures that are value members of other structures\n// because we assume they cannot contain pointers themselves.\nDAWN_UNUSED_FUNC(DeviceCreateQuerySetGetExtraRequiredSize);\n\nDAWN_DECLARE_UNUSED WireResult DeviceCreateQuerySetSerialize(\n    const DeviceCreateQuerySetCmd& record,\n    DeviceCreateQuerySetTransfer* transfer,\n    SerializeBuffer* buffer, const ObjectIdProvider& provider) {\n    DAWN_UNUSED(buffer);\n    transfer->commandId = WireCmd::DeviceCreateQuerySet;\n\n\n    WIRE_TRY(provider.GetId(record.self, &transfer->self));\n    transfer->result = record.result;\n    {\n        auto memberLength = 1u;\n\n        WGPUQuerySetDescriptorTransfer* memberBuffer;\n        WIRE_TRY(buffer->NextN(memberLength, &memberBuffer));\n\n        for (decltype(memberLength) i = 0; i < memberLength; ++i) {\n            WIRE_TRY(WGPUQuerySetDescriptorSerialize(record.descriptor[i], &memberBuffer[i], buffer, provider));\n        }\n    }\n\n    return WireResult::Success;\n}\nDAWN_UNUSED_FUNC(DeviceCreateQuerySetSerialize);\n\nDAWN_DECLARE_UNUSED WireResult DeviceCreateQuerySetDeserialize(\n    DeviceCreateQuerySetCmd* record,\n    const volatile DeviceCreateQuerySetTransfer* transfer,\n    DeserializeBuffer* deserializeBuffer,\n    DeserializeAllocator* allocator, const ObjectIdResolver& resolver) {\n    DAWN_UNUSED(allocator);\n\n    ASSERT(transfer->commandId == WireCmd::DeviceCreateQuerySet);\n    record->selfId = transfer->self;\n\n\n    WIRE_TRY(resolver.GetFromId(transfer->self, &record->self));\n    static_assert(sizeof(record->result) >= sizeof(transfer->result), \"Deserialize assignment may not narrow.\");\n    record->result = transfer->result;\n    {\n        auto memberLength = 1u;\n        const volatile WGPUQuerySetDescriptorTransfer* memberBuffer;\n        WIRE_TRY(deserializeBuffer->ReadN(memberLength, &memberBuffer));\n\n        WGPUQuerySetDescriptor* copiedMembers;\n        WIRE_TRY(GetSpace(allocator, memberLength, &copiedMembers));\n        record->descriptor = copiedMembers;\n\n        for (decltype(memberLength) i = 0; i < memberLength; ++i) {\n            WIRE_TRY(WGPUQuerySetDescriptorDeserialize(&copiedMembers[i], &memberBuffer[i], deserializeBuffer, allocator, resolver));\n        }\n    }\n\n    return WireResult::Success;\n}\nDAWN_UNUSED_FUNC(DeviceCreateQuerySetDeserialize);\n\nstruct DeviceCreateRenderBundleEncoderTransfer : CmdHeader {\n    static_assert(1 <= 1,\n                  \"Record must be at most one of is_cmd, extensible, and chained.\");\n    WireCmd commandId;\n\n    ObjectId self;\n    ObjectHandle result;\n};\n\nstatic_assert(offsetof(DeviceCreateRenderBundleEncoderTransfer, commandSize) == 0);\nstatic_assert(offsetof(DeviceCreateRenderBundleEncoderTransfer, commandId) == sizeof(CmdHeader));\n\nDAWN_DECLARE_UNUSED size_t DeviceCreateRenderBundleEncoderGetExtraRequiredSize(const DeviceCreateRenderBundleEncoderCmd& record) {\n    DAWN_UNUSED(record);\n    size_t result = 0;\n\n    {\n        auto memberLength = 1u;\n        auto size = WireAlignSizeofN<WGPURenderBundleEncoderDescriptorTransfer>(memberLength);\n        ASSERT(size);\n        result += *size;\n        for (decltype(memberLength) i = 0; i < memberLength; ++i) {\n            result += WGPURenderBundleEncoderDescriptorGetExtraRequiredSize(record.descriptor[i]);\n        }\n    }\n    return result;\n}\n// GetExtraRequiredSize isn't used for structures that are value members of other structures\n// because we assume they cannot contain pointers themselves.\nDAWN_UNUSED_FUNC(DeviceCreateRenderBundleEncoderGetExtraRequiredSize);\n\nDAWN_DECLARE_UNUSED WireResult DeviceCreateRenderBundleEncoderSerialize(\n    const DeviceCreateRenderBundleEncoderCmd& record,\n    DeviceCreateRenderBundleEncoderTransfer* transfer,\n    SerializeBuffer* buffer, const ObjectIdProvider& provider) {\n    DAWN_UNUSED(buffer);\n    transfer->commandId = WireCmd::DeviceCreateRenderBundleEncoder;\n\n\n    WIRE_TRY(provider.GetId(record.self, &transfer->self));\n    transfer->result = record.result;\n    {\n        auto memberLength = 1u;\n\n        WGPURenderBundleEncoderDescriptorTransfer* memberBuffer;\n        WIRE_TRY(buffer->NextN(memberLength, &memberBuffer));\n\n        for (decltype(memberLength) i = 0; i < memberLength; ++i) {\n            WIRE_TRY(WGPURenderBundleEncoderDescriptorSerialize(record.descriptor[i], &memberBuffer[i], buffer, provider));\n        }\n    }\n\n    return WireResult::Success;\n}\nDAWN_UNUSED_FUNC(DeviceCreateRenderBundleEncoderSerialize);\n\nDAWN_DECLARE_UNUSED WireResult DeviceCreateRenderBundleEncoderDeserialize(\n    DeviceCreateRenderBundleEncoderCmd* record,\n    const volatile DeviceCreateRenderBundleEncoderTransfer* transfer,\n    DeserializeBuffer* deserializeBuffer,\n    DeserializeAllocator* allocator, const ObjectIdResolver& resolver) {\n    DAWN_UNUSED(allocator);\n\n    ASSERT(transfer->commandId == WireCmd::DeviceCreateRenderBundleEncoder);\n    record->selfId = transfer->self;\n\n\n    WIRE_TRY(resolver.GetFromId(transfer->self, &record->self));\n    static_assert(sizeof(record->result) >= sizeof(transfer->result), \"Deserialize assignment may not narrow.\");\n    record->result = transfer->result;\n    {\n        auto memberLength = 1u;\n        const volatile WGPURenderBundleEncoderDescriptorTransfer* memberBuffer;\n        WIRE_TRY(deserializeBuffer->ReadN(memberLength, &memberBuffer));\n\n        WGPURenderBundleEncoderDescriptor* copiedMembers;\n        WIRE_TRY(GetSpace(allocator, memberLength, &copiedMembers));\n        record->descriptor = copiedMembers;\n\n        for (decltype(memberLength) i = 0; i < memberLength; ++i) {\n            WIRE_TRY(WGPURenderBundleEncoderDescriptorDeserialize(&copiedMembers[i], &memberBuffer[i], deserializeBuffer, allocator, resolver));\n        }\n    }\n\n    return WireResult::Success;\n}\nDAWN_UNUSED_FUNC(DeviceCreateRenderBundleEncoderDeserialize);\n\nstruct DeviceCreateRenderPipelineTransfer : CmdHeader {\n    static_assert(1 <= 1,\n                  \"Record must be at most one of is_cmd, extensible, and chained.\");\n    WireCmd commandId;\n\n    ObjectId self;\n    ObjectHandle result;\n};\n\nstatic_assert(offsetof(DeviceCreateRenderPipelineTransfer, commandSize) == 0);\nstatic_assert(offsetof(DeviceCreateRenderPipelineTransfer, commandId) == sizeof(CmdHeader));\n\nDAWN_DECLARE_UNUSED size_t DeviceCreateRenderPipelineGetExtraRequiredSize(const DeviceCreateRenderPipelineCmd& record) {\n    DAWN_UNUSED(record);\n    size_t result = 0;\n\n    {\n        auto memberLength = 1u;\n        auto size = WireAlignSizeofN<WGPURenderPipelineDescriptorTransfer>(memberLength);\n        ASSERT(size);\n        result += *size;\n        for (decltype(memberLength) i = 0; i < memberLength; ++i) {\n            result += WGPURenderPipelineDescriptorGetExtraRequiredSize(record.descriptor[i]);\n        }\n    }\n    return result;\n}\n// GetExtraRequiredSize isn't used for structures that are value members of other structures\n// because we assume they cannot contain pointers themselves.\nDAWN_UNUSED_FUNC(DeviceCreateRenderPipelineGetExtraRequiredSize);\n\nDAWN_DECLARE_UNUSED WireResult DeviceCreateRenderPipelineSerialize(\n    const DeviceCreateRenderPipelineCmd& record,\n    DeviceCreateRenderPipelineTransfer* transfer,\n    SerializeBuffer* buffer, const ObjectIdProvider& provider) {\n    DAWN_UNUSED(buffer);\n    transfer->commandId = WireCmd::DeviceCreateRenderPipeline;\n\n\n    WIRE_TRY(provider.GetId(record.self, &transfer->self));\n    transfer->result = record.result;\n    {\n        auto memberLength = 1u;\n\n        WGPURenderPipelineDescriptorTransfer* memberBuffer;\n        WIRE_TRY(buffer->NextN(memberLength, &memberBuffer));\n\n        for (decltype(memberLength) i = 0; i < memberLength; ++i) {\n            WIRE_TRY(WGPURenderPipelineDescriptorSerialize(record.descriptor[i], &memberBuffer[i], buffer, provider));\n        }\n    }\n\n    return WireResult::Success;\n}\nDAWN_UNUSED_FUNC(DeviceCreateRenderPipelineSerialize);\n\nDAWN_DECLARE_UNUSED WireResult DeviceCreateRenderPipelineDeserialize(\n    DeviceCreateRenderPipelineCmd* record,\n    const volatile DeviceCreateRenderPipelineTransfer* transfer,\n    DeserializeBuffer* deserializeBuffer,\n    DeserializeAllocator* allocator, const ObjectIdResolver& resolver) {\n    DAWN_UNUSED(allocator);\n\n    ASSERT(transfer->commandId == WireCmd::DeviceCreateRenderPipeline);\n    record->selfId = transfer->self;\n\n\n    WIRE_TRY(resolver.GetFromId(transfer->self, &record->self));\n    static_assert(sizeof(record->result) >= sizeof(transfer->result), \"Deserialize assignment may not narrow.\");\n    record->result = transfer->result;\n    {\n        auto memberLength = 1u;\n        const volatile WGPURenderPipelineDescriptorTransfer* memberBuffer;\n        WIRE_TRY(deserializeBuffer->ReadN(memberLength, &memberBuffer));\n\n        WGPURenderPipelineDescriptor* copiedMembers;\n        WIRE_TRY(GetSpace(allocator, memberLength, &copiedMembers));\n        record->descriptor = copiedMembers;\n\n        for (decltype(memberLength) i = 0; i < memberLength; ++i) {\n            WIRE_TRY(WGPURenderPipelineDescriptorDeserialize(&copiedMembers[i], &memberBuffer[i], deserializeBuffer, allocator, resolver));\n        }\n    }\n\n    return WireResult::Success;\n}\nDAWN_UNUSED_FUNC(DeviceCreateRenderPipelineDeserialize);\n\nstruct DeviceCreateRenderPipelineAsyncTransfer : CmdHeader {\n    static_assert(1 <= 1,\n                  \"Record must be at most one of is_cmd, extensible, and chained.\");\n    WireCmd commandId;\n\n    ObjectId deviceId;\n    uint64_t requestSerial;\n    ObjectHandle pipelineObjectHandle;\n};\n\nstatic_assert(offsetof(DeviceCreateRenderPipelineAsyncTransfer, commandSize) == 0);\nstatic_assert(offsetof(DeviceCreateRenderPipelineAsyncTransfer, commandId) == sizeof(CmdHeader));\n\nDAWN_DECLARE_UNUSED size_t DeviceCreateRenderPipelineAsyncGetExtraRequiredSize(const DeviceCreateRenderPipelineAsyncCmd& record) {\n    DAWN_UNUSED(record);\n    size_t result = 0;\n\n    {\n        auto memberLength = 1u;\n        auto size = WireAlignSizeofN<WGPURenderPipelineDescriptorTransfer>(memberLength);\n        ASSERT(size);\n        result += *size;\n        for (decltype(memberLength) i = 0; i < memberLength; ++i) {\n            result += WGPURenderPipelineDescriptorGetExtraRequiredSize(record.descriptor[i]);\n        }\n    }\n    return result;\n}\n// GetExtraRequiredSize isn't used for structures that are value members of other structures\n// because we assume they cannot contain pointers themselves.\nDAWN_UNUSED_FUNC(DeviceCreateRenderPipelineAsyncGetExtraRequiredSize);\n\nDAWN_DECLARE_UNUSED WireResult DeviceCreateRenderPipelineAsyncSerialize(\n    const DeviceCreateRenderPipelineAsyncCmd& record,\n    DeviceCreateRenderPipelineAsyncTransfer* transfer,\n    SerializeBuffer* buffer, const ObjectIdProvider& provider) {\n    DAWN_UNUSED(buffer);\n    transfer->commandId = WireCmd::DeviceCreateRenderPipelineAsync;\n\n\n    transfer->deviceId = record.deviceId;\n    transfer->requestSerial = record.requestSerial;\n    transfer->pipelineObjectHandle = record.pipelineObjectHandle;\n    {\n        auto memberLength = 1u;\n\n        WGPURenderPipelineDescriptorTransfer* memberBuffer;\n        WIRE_TRY(buffer->NextN(memberLength, &memberBuffer));\n\n        for (decltype(memberLength) i = 0; i < memberLength; ++i) {\n            WIRE_TRY(WGPURenderPipelineDescriptorSerialize(record.descriptor[i], &memberBuffer[i], buffer, provider));\n        }\n    }\n\n    return WireResult::Success;\n}\nDAWN_UNUSED_FUNC(DeviceCreateRenderPipelineAsyncSerialize);\n\nDAWN_DECLARE_UNUSED WireResult DeviceCreateRenderPipelineAsyncDeserialize(\n    DeviceCreateRenderPipelineAsyncCmd* record,\n    const volatile DeviceCreateRenderPipelineAsyncTransfer* transfer,\n    DeserializeBuffer* deserializeBuffer,\n    DeserializeAllocator* allocator, const ObjectIdResolver& resolver) {\n    DAWN_UNUSED(allocator);\n\n    ASSERT(transfer->commandId == WireCmd::DeviceCreateRenderPipelineAsync);\n\n\n    static_assert(sizeof(record->deviceId) >= sizeof(transfer->deviceId), \"Deserialize assignment may not narrow.\");\n    record->deviceId = transfer->deviceId;\n    static_assert(sizeof(record->requestSerial) >= sizeof(transfer->requestSerial), \"Deserialize assignment may not narrow.\");\n    record->requestSerial = transfer->requestSerial;\n    static_assert(sizeof(record->pipelineObjectHandle) >= sizeof(transfer->pipelineObjectHandle), \"Deserialize assignment may not narrow.\");\n    record->pipelineObjectHandle = transfer->pipelineObjectHandle;\n    {\n        auto memberLength = 1u;\n        const volatile WGPURenderPipelineDescriptorTransfer* memberBuffer;\n        WIRE_TRY(deserializeBuffer->ReadN(memberLength, &memberBuffer));\n\n        WGPURenderPipelineDescriptor* copiedMembers;\n        WIRE_TRY(GetSpace(allocator, memberLength, &copiedMembers));\n        record->descriptor = copiedMembers;\n\n        for (decltype(memberLength) i = 0; i < memberLength; ++i) {\n            WIRE_TRY(WGPURenderPipelineDescriptorDeserialize(&copiedMembers[i], &memberBuffer[i], deserializeBuffer, allocator, resolver));\n        }\n    }\n\n    return WireResult::Success;\n}\nDAWN_UNUSED_FUNC(DeviceCreateRenderPipelineAsyncDeserialize);\n\nstruct DeviceCreateSamplerTransfer : CmdHeader {\n    static_assert(1 <= 1,\n                  \"Record must be at most one of is_cmd, extensible, and chained.\");\n    WireCmd commandId;\n\n    ObjectId self;\n    bool has_descriptor;\n    ObjectHandle result;\n};\n\nstatic_assert(offsetof(DeviceCreateSamplerTransfer, commandSize) == 0);\nstatic_assert(offsetof(DeviceCreateSamplerTransfer, commandId) == sizeof(CmdHeader));\n\nDAWN_DECLARE_UNUSED size_t DeviceCreateSamplerGetExtraRequiredSize(const DeviceCreateSamplerCmd& record) {\n    DAWN_UNUSED(record);\n    size_t result = 0;\n\n    if (record.descriptor != nullptr) {\n        auto memberLength = 1u;\n        auto size = WireAlignSizeofN<WGPUSamplerDescriptorTransfer>(memberLength);\n        ASSERT(size);\n        result += *size;\n        for (decltype(memberLength) i = 0; i < memberLength; ++i) {\n            result += WGPUSamplerDescriptorGetExtraRequiredSize(record.descriptor[i]);\n        }\n    }\n    return result;\n}\n// GetExtraRequiredSize isn't used for structures that are value members of other structures\n// because we assume they cannot contain pointers themselves.\nDAWN_UNUSED_FUNC(DeviceCreateSamplerGetExtraRequiredSize);\n\nDAWN_DECLARE_UNUSED WireResult DeviceCreateSamplerSerialize(\n    const DeviceCreateSamplerCmd& record,\n    DeviceCreateSamplerTransfer* transfer,\n    SerializeBuffer* buffer, const ObjectIdProvider& provider) {\n    DAWN_UNUSED(buffer);\n    transfer->commandId = WireCmd::DeviceCreateSampler;\n\n\n    WIRE_TRY(provider.GetId(record.self, &transfer->self));\n    transfer->result = record.result;\n    bool has_descriptor = record.descriptor != nullptr;\n    transfer->has_descriptor = has_descriptor;\n    if (has_descriptor) {\n        auto memberLength = 1u;\n\n        WGPUSamplerDescriptorTransfer* memberBuffer;\n        WIRE_TRY(buffer->NextN(memberLength, &memberBuffer));\n\n        for (decltype(memberLength) i = 0; i < memberLength; ++i) {\n            WIRE_TRY(WGPUSamplerDescriptorSerialize(record.descriptor[i], &memberBuffer[i], buffer, provider));\n        }\n    }\n\n    return WireResult::Success;\n}\nDAWN_UNUSED_FUNC(DeviceCreateSamplerSerialize);\n\nDAWN_DECLARE_UNUSED WireResult DeviceCreateSamplerDeserialize(\n    DeviceCreateSamplerCmd* record,\n    const volatile DeviceCreateSamplerTransfer* transfer,\n    DeserializeBuffer* deserializeBuffer,\n    DeserializeAllocator* allocator, const ObjectIdResolver& resolver) {\n    DAWN_UNUSED(allocator);\n\n    ASSERT(transfer->commandId == WireCmd::DeviceCreateSampler);\n    record->selfId = transfer->self;\n\n\n    WIRE_TRY(resolver.GetFromId(transfer->self, &record->self));\n    static_assert(sizeof(record->result) >= sizeof(transfer->result), \"Deserialize assignment may not narrow.\");\n    record->result = transfer->result;\n    bool has_descriptor = transfer->has_descriptor;\n    record->descriptor = nullptr;\n    if (has_descriptor) {\n        auto memberLength = 1u;\n        const volatile WGPUSamplerDescriptorTransfer* memberBuffer;\n        WIRE_TRY(deserializeBuffer->ReadN(memberLength, &memberBuffer));\n\n        WGPUSamplerDescriptor* copiedMembers;\n        WIRE_TRY(GetSpace(allocator, memberLength, &copiedMembers));\n        record->descriptor = copiedMembers;\n\n        for (decltype(memberLength) i = 0; i < memberLength; ++i) {\n            WIRE_TRY(WGPUSamplerDescriptorDeserialize(&copiedMembers[i], &memberBuffer[i], deserializeBuffer, allocator, resolver));\n        }\n    }\n\n    return WireResult::Success;\n}\nDAWN_UNUSED_FUNC(DeviceCreateSamplerDeserialize);\n\nstruct DeviceCreateShaderModuleTransfer : CmdHeader {\n    static_assert(1 <= 1,\n                  \"Record must be at most one of is_cmd, extensible, and chained.\");\n    WireCmd commandId;\n\n    ObjectId self;\n    ObjectHandle result;\n};\n\nstatic_assert(offsetof(DeviceCreateShaderModuleTransfer, commandSize) == 0);\nstatic_assert(offsetof(DeviceCreateShaderModuleTransfer, commandId) == sizeof(CmdHeader));\n\nDAWN_DECLARE_UNUSED size_t DeviceCreateShaderModuleGetExtraRequiredSize(const DeviceCreateShaderModuleCmd& record) {\n    DAWN_UNUSED(record);\n    size_t result = 0;\n\n    {\n        auto memberLength = 1u;\n        auto size = WireAlignSizeofN<WGPUShaderModuleDescriptorTransfer>(memberLength);\n        ASSERT(size);\n        result += *size;\n        for (decltype(memberLength) i = 0; i < memberLength; ++i) {\n            result += WGPUShaderModuleDescriptorGetExtraRequiredSize(record.descriptor[i]);\n        }\n    }\n    return result;\n}\n// GetExtraRequiredSize isn't used for structures that are value members of other structures\n// because we assume they cannot contain pointers themselves.\nDAWN_UNUSED_FUNC(DeviceCreateShaderModuleGetExtraRequiredSize);\n\nDAWN_DECLARE_UNUSED WireResult DeviceCreateShaderModuleSerialize(\n    const DeviceCreateShaderModuleCmd& record,\n    DeviceCreateShaderModuleTransfer* transfer,\n    SerializeBuffer* buffer, const ObjectIdProvider& provider) {\n    DAWN_UNUSED(buffer);\n    transfer->commandId = WireCmd::DeviceCreateShaderModule;\n\n\n    WIRE_TRY(provider.GetId(record.self, &transfer->self));\n    transfer->result = record.result;\n    {\n        auto memberLength = 1u;\n\n        WGPUShaderModuleDescriptorTransfer* memberBuffer;\n        WIRE_TRY(buffer->NextN(memberLength, &memberBuffer));\n\n        for (decltype(memberLength) i = 0; i < memberLength; ++i) {\n            WIRE_TRY(WGPUShaderModuleDescriptorSerialize(record.descriptor[i], &memberBuffer[i], buffer, provider));\n        }\n    }\n\n    return WireResult::Success;\n}\nDAWN_UNUSED_FUNC(DeviceCreateShaderModuleSerialize);\n\nDAWN_DECLARE_UNUSED WireResult DeviceCreateShaderModuleDeserialize(\n    DeviceCreateShaderModuleCmd* record,\n    const volatile DeviceCreateShaderModuleTransfer* transfer,\n    DeserializeBuffer* deserializeBuffer,\n    DeserializeAllocator* allocator, const ObjectIdResolver& resolver) {\n    DAWN_UNUSED(allocator);\n\n    ASSERT(transfer->commandId == WireCmd::DeviceCreateShaderModule);\n    record->selfId = transfer->self;\n\n\n    WIRE_TRY(resolver.GetFromId(transfer->self, &record->self));\n    static_assert(sizeof(record->result) >= sizeof(transfer->result), \"Deserialize assignment may not narrow.\");\n    record->result = transfer->result;\n    {\n        auto memberLength = 1u;\n        const volatile WGPUShaderModuleDescriptorTransfer* memberBuffer;\n        WIRE_TRY(deserializeBuffer->ReadN(memberLength, &memberBuffer));\n\n        WGPUShaderModuleDescriptor* copiedMembers;\n        WIRE_TRY(GetSpace(allocator, memberLength, &copiedMembers));\n        record->descriptor = copiedMembers;\n\n        for (decltype(memberLength) i = 0; i < memberLength; ++i) {\n            WIRE_TRY(WGPUShaderModuleDescriptorDeserialize(&copiedMembers[i], &memberBuffer[i], deserializeBuffer, allocator, resolver));\n        }\n    }\n\n    return WireResult::Success;\n}\nDAWN_UNUSED_FUNC(DeviceCreateShaderModuleDeserialize);\n\nstruct DeviceCreateSwapChainTransfer : CmdHeader {\n    static_assert(1 <= 1,\n                  \"Record must be at most one of is_cmd, extensible, and chained.\");\n    WireCmd commandId;\n\n    ObjectId self;\n    ObjectId surface;\n    ObjectHandle result;\n};\n\nstatic_assert(offsetof(DeviceCreateSwapChainTransfer, commandSize) == 0);\nstatic_assert(offsetof(DeviceCreateSwapChainTransfer, commandId) == sizeof(CmdHeader));\n\nDAWN_DECLARE_UNUSED size_t DeviceCreateSwapChainGetExtraRequiredSize(const DeviceCreateSwapChainCmd& record) {\n    DAWN_UNUSED(record);\n    size_t result = 0;\n\n    {\n        auto memberLength = 1u;\n        auto size = WireAlignSizeofN<WGPUSwapChainDescriptorTransfer>(memberLength);\n        ASSERT(size);\n        result += *size;\n        for (decltype(memberLength) i = 0; i < memberLength; ++i) {\n            result += WGPUSwapChainDescriptorGetExtraRequiredSize(record.descriptor[i]);\n        }\n    }\n    return result;\n}\n// GetExtraRequiredSize isn't used for structures that are value members of other structures\n// because we assume they cannot contain pointers themselves.\nDAWN_UNUSED_FUNC(DeviceCreateSwapChainGetExtraRequiredSize);\n\nDAWN_DECLARE_UNUSED WireResult DeviceCreateSwapChainSerialize(\n    const DeviceCreateSwapChainCmd& record,\n    DeviceCreateSwapChainTransfer* transfer,\n    SerializeBuffer* buffer, const ObjectIdProvider& provider) {\n    DAWN_UNUSED(buffer);\n    transfer->commandId = WireCmd::DeviceCreateSwapChain;\n\n\n    WIRE_TRY(provider.GetId(record.self, &transfer->self));\n    WIRE_TRY(provider.GetId(record.surface, &transfer->surface));\n    transfer->result = record.result;\n    {\n        auto memberLength = 1u;\n\n        WGPUSwapChainDescriptorTransfer* memberBuffer;\n        WIRE_TRY(buffer->NextN(memberLength, &memberBuffer));\n\n        for (decltype(memberLength) i = 0; i < memberLength; ++i) {\n            WIRE_TRY(WGPUSwapChainDescriptorSerialize(record.descriptor[i], &memberBuffer[i], buffer, provider));\n        }\n    }\n\n    return WireResult::Success;\n}\nDAWN_UNUSED_FUNC(DeviceCreateSwapChainSerialize);\n\nDAWN_DECLARE_UNUSED WireResult DeviceCreateSwapChainDeserialize(\n    DeviceCreateSwapChainCmd* record,\n    const volatile DeviceCreateSwapChainTransfer* transfer,\n    DeserializeBuffer* deserializeBuffer,\n    DeserializeAllocator* allocator, const ObjectIdResolver& resolver) {\n    DAWN_UNUSED(allocator);\n\n    ASSERT(transfer->commandId == WireCmd::DeviceCreateSwapChain);\n    record->selfId = transfer->self;\n\n\n    WIRE_TRY(resolver.GetFromId(transfer->self, &record->self));\n    WIRE_TRY(resolver.GetFromId(transfer->surface, &record->surface));\n    static_assert(sizeof(record->result) >= sizeof(transfer->result), \"Deserialize assignment may not narrow.\");\n    record->result = transfer->result;\n    {\n        auto memberLength = 1u;\n        const volatile WGPUSwapChainDescriptorTransfer* memberBuffer;\n        WIRE_TRY(deserializeBuffer->ReadN(memberLength, &memberBuffer));\n\n        WGPUSwapChainDescriptor* copiedMembers;\n        WIRE_TRY(GetSpace(allocator, memberLength, &copiedMembers));\n        record->descriptor = copiedMembers;\n\n        for (decltype(memberLength) i = 0; i < memberLength; ++i) {\n            WIRE_TRY(WGPUSwapChainDescriptorDeserialize(&copiedMembers[i], &memberBuffer[i], deserializeBuffer, allocator, resolver));\n        }\n    }\n\n    return WireResult::Success;\n}\nDAWN_UNUSED_FUNC(DeviceCreateSwapChainDeserialize);\n\nstruct DeviceCreateTextureTransfer : CmdHeader {\n    static_assert(1 <= 1,\n                  \"Record must be at most one of is_cmd, extensible, and chained.\");\n    WireCmd commandId;\n\n    ObjectId self;\n    ObjectHandle result;\n};\n\nstatic_assert(offsetof(DeviceCreateTextureTransfer, commandSize) == 0);\nstatic_assert(offsetof(DeviceCreateTextureTransfer, commandId) == sizeof(CmdHeader));\n\nDAWN_DECLARE_UNUSED size_t DeviceCreateTextureGetExtraRequiredSize(const DeviceCreateTextureCmd& record) {\n    DAWN_UNUSED(record);\n    size_t result = 0;\n\n    {\n        auto memberLength = 1u;\n        auto size = WireAlignSizeofN<WGPUTextureDescriptorTransfer>(memberLength);\n        ASSERT(size);\n        result += *size;\n        for (decltype(memberLength) i = 0; i < memberLength; ++i) {\n            result += WGPUTextureDescriptorGetExtraRequiredSize(record.descriptor[i]);\n        }\n    }\n    return result;\n}\n// GetExtraRequiredSize isn't used for structures that are value members of other structures\n// because we assume they cannot contain pointers themselves.\nDAWN_UNUSED_FUNC(DeviceCreateTextureGetExtraRequiredSize);\n\nDAWN_DECLARE_UNUSED WireResult DeviceCreateTextureSerialize(\n    const DeviceCreateTextureCmd& record,\n    DeviceCreateTextureTransfer* transfer,\n    SerializeBuffer* buffer, const ObjectIdProvider& provider) {\n    DAWN_UNUSED(buffer);\n    transfer->commandId = WireCmd::DeviceCreateTexture;\n\n\n    WIRE_TRY(provider.GetId(record.self, &transfer->self));\n    transfer->result = record.result;\n    {\n        auto memberLength = 1u;\n\n        WGPUTextureDescriptorTransfer* memberBuffer;\n        WIRE_TRY(buffer->NextN(memberLength, &memberBuffer));\n\n        for (decltype(memberLength) i = 0; i < memberLength; ++i) {\n            WIRE_TRY(WGPUTextureDescriptorSerialize(record.descriptor[i], &memberBuffer[i], buffer, provider));\n        }\n    }\n\n    return WireResult::Success;\n}\nDAWN_UNUSED_FUNC(DeviceCreateTextureSerialize);\n\nDAWN_DECLARE_UNUSED WireResult DeviceCreateTextureDeserialize(\n    DeviceCreateTextureCmd* record,\n    const volatile DeviceCreateTextureTransfer* transfer,\n    DeserializeBuffer* deserializeBuffer,\n    DeserializeAllocator* allocator, const ObjectIdResolver& resolver) {\n    DAWN_UNUSED(allocator);\n\n    ASSERT(transfer->commandId == WireCmd::DeviceCreateTexture);\n    record->selfId = transfer->self;\n\n\n    WIRE_TRY(resolver.GetFromId(transfer->self, &record->self));\n    static_assert(sizeof(record->result) >= sizeof(transfer->result), \"Deserialize assignment may not narrow.\");\n    record->result = transfer->result;\n    {\n        auto memberLength = 1u;\n        const volatile WGPUTextureDescriptorTransfer* memberBuffer;\n        WIRE_TRY(deserializeBuffer->ReadN(memberLength, &memberBuffer));\n\n        WGPUTextureDescriptor* copiedMembers;\n        WIRE_TRY(GetSpace(allocator, memberLength, &copiedMembers));\n        record->descriptor = copiedMembers;\n\n        for (decltype(memberLength) i = 0; i < memberLength; ++i) {\n            WIRE_TRY(WGPUTextureDescriptorDeserialize(&copiedMembers[i], &memberBuffer[i], deserializeBuffer, allocator, resolver));\n        }\n    }\n\n    return WireResult::Success;\n}\nDAWN_UNUSED_FUNC(DeviceCreateTextureDeserialize);\n\nstruct DeviceDestroyTransfer : CmdHeader {\n    static_assert(1 <= 1,\n                  \"Record must be at most one of is_cmd, extensible, and chained.\");\n    WireCmd commandId;\n\n    ObjectId self;\n};\n\nstatic_assert(offsetof(DeviceDestroyTransfer, commandSize) == 0);\nstatic_assert(offsetof(DeviceDestroyTransfer, commandId) == sizeof(CmdHeader));\n\nDAWN_DECLARE_UNUSED size_t DeviceDestroyGetExtraRequiredSize(const DeviceDestroyCmd& record) {\n    DAWN_UNUSED(record);\n    size_t result = 0;\n\n    return result;\n}\n// GetExtraRequiredSize isn't used for structures that are value members of other structures\n// because we assume they cannot contain pointers themselves.\nDAWN_UNUSED_FUNC(DeviceDestroyGetExtraRequiredSize);\n\nDAWN_DECLARE_UNUSED WireResult DeviceDestroySerialize(\n    const DeviceDestroyCmd& record,\n    DeviceDestroyTransfer* transfer,\n    SerializeBuffer* buffer, const ObjectIdProvider& provider) {\n    DAWN_UNUSED(buffer);\n    transfer->commandId = WireCmd::DeviceDestroy;\n\n\n    WIRE_TRY(provider.GetId(record.self, &transfer->self));\n\n    return WireResult::Success;\n}\nDAWN_UNUSED_FUNC(DeviceDestroySerialize);\n\nDAWN_DECLARE_UNUSED WireResult DeviceDestroyDeserialize(\n    DeviceDestroyCmd* record,\n    const volatile DeviceDestroyTransfer* transfer,\n    DeserializeBuffer* deserializeBuffer,\n    DeserializeAllocator* allocator, const ObjectIdResolver& resolver) {\n    DAWN_UNUSED(allocator);\n\n    ASSERT(transfer->commandId == WireCmd::DeviceDestroy);\n    record->selfId = transfer->self;\n\n\n    WIRE_TRY(resolver.GetFromId(transfer->self, &record->self));\n\n    return WireResult::Success;\n}\nDAWN_UNUSED_FUNC(DeviceDestroyDeserialize);\n\nstruct DeviceForceLossTransfer : CmdHeader {\n    static_assert(1 <= 1,\n                  \"Record must be at most one of is_cmd, extensible, and chained.\");\n    WireCmd commandId;\n\n    ObjectId self;\n    WGPUDeviceLostReason type;\n    uint64_t messageStrlen;\n};\n\nstatic_assert(offsetof(DeviceForceLossTransfer, commandSize) == 0);\nstatic_assert(offsetof(DeviceForceLossTransfer, commandId) == sizeof(CmdHeader));\n\nDAWN_DECLARE_UNUSED size_t DeviceForceLossGetExtraRequiredSize(const DeviceForceLossCmd& record) {\n    DAWN_UNUSED(record);\n    size_t result = 0;\n\n    ASSERT(record.message != nullptr);\n    result += Align(std::strlen(record.message), kWireBufferAlignment);\n    return result;\n}\n// GetExtraRequiredSize isn't used for structures that are value members of other structures\n// because we assume they cannot contain pointers themselves.\nDAWN_UNUSED_FUNC(DeviceForceLossGetExtraRequiredSize);\n\nDAWN_DECLARE_UNUSED WireResult DeviceForceLossSerialize(\n    const DeviceForceLossCmd& record,\n    DeviceForceLossTransfer* transfer,\n    SerializeBuffer* buffer, const ObjectIdProvider& provider) {\n    DAWN_UNUSED(buffer);\n    transfer->commandId = WireCmd::DeviceForceLoss;\n\n\n    WIRE_TRY(provider.GetId(record.self, &transfer->self));\n    transfer->type = record.type;\n    {\n        transfer->messageStrlen = std::strlen(record.message);\n\n        char* stringInBuffer;\n        WIRE_TRY(buffer->NextN(transfer->messageStrlen, &stringInBuffer));\n        memcpy(stringInBuffer, record.message, transfer->messageStrlen);\n    }\n\n    return WireResult::Success;\n}\nDAWN_UNUSED_FUNC(DeviceForceLossSerialize);\n\nDAWN_DECLARE_UNUSED WireResult DeviceForceLossDeserialize(\n    DeviceForceLossCmd* record,\n    const volatile DeviceForceLossTransfer* transfer,\n    DeserializeBuffer* deserializeBuffer,\n    DeserializeAllocator* allocator, const ObjectIdResolver& resolver) {\n    DAWN_UNUSED(allocator);\n\n    ASSERT(transfer->commandId == WireCmd::DeviceForceLoss);\n    record->selfId = transfer->self;\n\n\n    WIRE_TRY(resolver.GetFromId(transfer->self, &record->self));\n    static_assert(sizeof(record->type) >= sizeof(transfer->type), \"Deserialize assignment may not narrow.\");\n    record->type = transfer->type;\n    {\n        uint64_t stringLength64 = transfer->messageStrlen;\n        if (stringLength64 >= std::numeric_limits<size_t>::max()) {\n            return WireResult::FatalError;\n        }\n        size_t stringLength = static_cast<size_t>(stringLength64);\n\n        const volatile char* stringInBuffer;\n        WIRE_TRY(deserializeBuffer->ReadN(stringLength, &stringInBuffer));\n\n        char* copiedString;\n        WIRE_TRY(GetSpace(allocator, stringLength + 1, &copiedString));\n        memcpy(copiedString, const_cast<const char*>(stringInBuffer), stringLength);\n        copiedString[stringLength] = '\\0';\n        record->message = copiedString;\n    }\n\n    return WireResult::Success;\n}\nDAWN_UNUSED_FUNC(DeviceForceLossDeserialize);\n\nstruct DeviceGetAdapterTransfer : CmdHeader {\n    static_assert(1 <= 1,\n                  \"Record must be at most one of is_cmd, extensible, and chained.\");\n    WireCmd commandId;\n\n    ObjectId self;\n    ObjectHandle result;\n};\n\nstatic_assert(offsetof(DeviceGetAdapterTransfer, commandSize) == 0);\nstatic_assert(offsetof(DeviceGetAdapterTransfer, commandId) == sizeof(CmdHeader));\n\nDAWN_DECLARE_UNUSED size_t DeviceGetAdapterGetExtraRequiredSize(const DeviceGetAdapterCmd& record) {\n    DAWN_UNUSED(record);\n    size_t result = 0;\n\n    return result;\n}\n// GetExtraRequiredSize isn't used for structures that are value members of other structures\n// because we assume they cannot contain pointers themselves.\nDAWN_UNUSED_FUNC(DeviceGetAdapterGetExtraRequiredSize);\n\nDAWN_DECLARE_UNUSED WireResult DeviceGetAdapterSerialize(\n    const DeviceGetAdapterCmd& record,\n    DeviceGetAdapterTransfer* transfer,\n    SerializeBuffer* buffer, const ObjectIdProvider& provider) {\n    DAWN_UNUSED(buffer);\n    transfer->commandId = WireCmd::DeviceGetAdapter;\n\n\n    WIRE_TRY(provider.GetId(record.self, &transfer->self));\n    transfer->result = record.result;\n\n    return WireResult::Success;\n}\nDAWN_UNUSED_FUNC(DeviceGetAdapterSerialize);\n\nDAWN_DECLARE_UNUSED WireResult DeviceGetAdapterDeserialize(\n    DeviceGetAdapterCmd* record,\n    const volatile DeviceGetAdapterTransfer* transfer,\n    DeserializeBuffer* deserializeBuffer,\n    DeserializeAllocator* allocator, const ObjectIdResolver& resolver) {\n    DAWN_UNUSED(allocator);\n\n    ASSERT(transfer->commandId == WireCmd::DeviceGetAdapter);\n    record->selfId = transfer->self;\n\n\n    WIRE_TRY(resolver.GetFromId(transfer->self, &record->self));\n    static_assert(sizeof(record->result) >= sizeof(transfer->result), \"Deserialize assignment may not narrow.\");\n    record->result = transfer->result;\n\n    return WireResult::Success;\n}\nDAWN_UNUSED_FUNC(DeviceGetAdapterDeserialize);\n\nstruct DeviceGetQueueTransfer : CmdHeader {\n    static_assert(1 <= 1,\n                  \"Record must be at most one of is_cmd, extensible, and chained.\");\n    WireCmd commandId;\n\n    ObjectId self;\n    ObjectHandle result;\n};\n\nstatic_assert(offsetof(DeviceGetQueueTransfer, commandSize) == 0);\nstatic_assert(offsetof(DeviceGetQueueTransfer, commandId) == sizeof(CmdHeader));\n\nDAWN_DECLARE_UNUSED size_t DeviceGetQueueGetExtraRequiredSize(const DeviceGetQueueCmd& record) {\n    DAWN_UNUSED(record);\n    size_t result = 0;\n\n    return result;\n}\n// GetExtraRequiredSize isn't used for structures that are value members of other structures\n// because we assume they cannot contain pointers themselves.\nDAWN_UNUSED_FUNC(DeviceGetQueueGetExtraRequiredSize);\n\nDAWN_DECLARE_UNUSED WireResult DeviceGetQueueSerialize(\n    const DeviceGetQueueCmd& record,\n    DeviceGetQueueTransfer* transfer,\n    SerializeBuffer* buffer, const ObjectIdProvider& provider) {\n    DAWN_UNUSED(buffer);\n    transfer->commandId = WireCmd::DeviceGetQueue;\n\n\n    WIRE_TRY(provider.GetId(record.self, &transfer->self));\n    transfer->result = record.result;\n\n    return WireResult::Success;\n}\nDAWN_UNUSED_FUNC(DeviceGetQueueSerialize);\n\nDAWN_DECLARE_UNUSED WireResult DeviceGetQueueDeserialize(\n    DeviceGetQueueCmd* record,\n    const volatile DeviceGetQueueTransfer* transfer,\n    DeserializeBuffer* deserializeBuffer,\n    DeserializeAllocator* allocator, const ObjectIdResolver& resolver) {\n    DAWN_UNUSED(allocator);\n\n    ASSERT(transfer->commandId == WireCmd::DeviceGetQueue);\n    record->selfId = transfer->self;\n\n\n    WIRE_TRY(resolver.GetFromId(transfer->self, &record->self));\n    static_assert(sizeof(record->result) >= sizeof(transfer->result), \"Deserialize assignment may not narrow.\");\n    record->result = transfer->result;\n\n    return WireResult::Success;\n}\nDAWN_UNUSED_FUNC(DeviceGetQueueDeserialize);\n\nstruct DeviceInjectErrorTransfer : CmdHeader {\n    static_assert(1 <= 1,\n                  \"Record must be at most one of is_cmd, extensible, and chained.\");\n    WireCmd commandId;\n\n    ObjectId self;\n    WGPUErrorType type;\n    uint64_t messageStrlen;\n};\n\nstatic_assert(offsetof(DeviceInjectErrorTransfer, commandSize) == 0);\nstatic_assert(offsetof(DeviceInjectErrorTransfer, commandId) == sizeof(CmdHeader));\n\nDAWN_DECLARE_UNUSED size_t DeviceInjectErrorGetExtraRequiredSize(const DeviceInjectErrorCmd& record) {\n    DAWN_UNUSED(record);\n    size_t result = 0;\n\n    ASSERT(record.message != nullptr);\n    result += Align(std::strlen(record.message), kWireBufferAlignment);\n    return result;\n}\n// GetExtraRequiredSize isn't used for structures that are value members of other structures\n// because we assume they cannot contain pointers themselves.\nDAWN_UNUSED_FUNC(DeviceInjectErrorGetExtraRequiredSize);\n\nDAWN_DECLARE_UNUSED WireResult DeviceInjectErrorSerialize(\n    const DeviceInjectErrorCmd& record,\n    DeviceInjectErrorTransfer* transfer,\n    SerializeBuffer* buffer, const ObjectIdProvider& provider) {\n    DAWN_UNUSED(buffer);\n    transfer->commandId = WireCmd::DeviceInjectError;\n\n\n    WIRE_TRY(provider.GetId(record.self, &transfer->self));\n    transfer->type = record.type;\n    {\n        transfer->messageStrlen = std::strlen(record.message);\n\n        char* stringInBuffer;\n        WIRE_TRY(buffer->NextN(transfer->messageStrlen, &stringInBuffer));\n        memcpy(stringInBuffer, record.message, transfer->messageStrlen);\n    }\n\n    return WireResult::Success;\n}\nDAWN_UNUSED_FUNC(DeviceInjectErrorSerialize);\n\nDAWN_DECLARE_UNUSED WireResult DeviceInjectErrorDeserialize(\n    DeviceInjectErrorCmd* record,\n    const volatile DeviceInjectErrorTransfer* transfer,\n    DeserializeBuffer* deserializeBuffer,\n    DeserializeAllocator* allocator, const ObjectIdResolver& resolver) {\n    DAWN_UNUSED(allocator);\n\n    ASSERT(transfer->commandId == WireCmd::DeviceInjectError);\n    record->selfId = transfer->self;\n\n\n    WIRE_TRY(resolver.GetFromId(transfer->self, &record->self));\n    static_assert(sizeof(record->type) >= sizeof(transfer->type), \"Deserialize assignment may not narrow.\");\n    record->type = transfer->type;\n    {\n        uint64_t stringLength64 = transfer->messageStrlen;\n        if (stringLength64 >= std::numeric_limits<size_t>::max()) {\n            return WireResult::FatalError;\n        }\n        size_t stringLength = static_cast<size_t>(stringLength64);\n\n        const volatile char* stringInBuffer;\n        WIRE_TRY(deserializeBuffer->ReadN(stringLength, &stringInBuffer));\n\n        char* copiedString;\n        WIRE_TRY(GetSpace(allocator, stringLength + 1, &copiedString));\n        memcpy(copiedString, const_cast<const char*>(stringInBuffer), stringLength);\n        copiedString[stringLength] = '\\0';\n        record->message = copiedString;\n    }\n\n    return WireResult::Success;\n}\nDAWN_UNUSED_FUNC(DeviceInjectErrorDeserialize);\n\nstruct DevicePopErrorScopeTransfer : CmdHeader {\n    static_assert(1 <= 1,\n                  \"Record must be at most one of is_cmd, extensible, and chained.\");\n    WireCmd commandId;\n\n    ObjectId deviceId;\n    uint64_t requestSerial;\n};\n\nstatic_assert(offsetof(DevicePopErrorScopeTransfer, commandSize) == 0);\nstatic_assert(offsetof(DevicePopErrorScopeTransfer, commandId) == sizeof(CmdHeader));\n\nDAWN_DECLARE_UNUSED size_t DevicePopErrorScopeGetExtraRequiredSize(const DevicePopErrorScopeCmd& record) {\n    DAWN_UNUSED(record);\n    size_t result = 0;\n\n    return result;\n}\n// GetExtraRequiredSize isn't used for structures that are value members of other structures\n// because we assume they cannot contain pointers themselves.\nDAWN_UNUSED_FUNC(DevicePopErrorScopeGetExtraRequiredSize);\n\nDAWN_DECLARE_UNUSED WireResult DevicePopErrorScopeSerialize(\n    const DevicePopErrorScopeCmd& record,\n    DevicePopErrorScopeTransfer* transfer,\n    SerializeBuffer* buffer) {\n    DAWN_UNUSED(buffer);\n    transfer->commandId = WireCmd::DevicePopErrorScope;\n\n\n    transfer->deviceId = record.deviceId;\n    transfer->requestSerial = record.requestSerial;\n\n    return WireResult::Success;\n}\nDAWN_UNUSED_FUNC(DevicePopErrorScopeSerialize);\n\nDAWN_DECLARE_UNUSED WireResult DevicePopErrorScopeDeserialize(\n    DevicePopErrorScopeCmd* record,\n    const volatile DevicePopErrorScopeTransfer* transfer,\n    DeserializeBuffer* deserializeBuffer,\n    DeserializeAllocator* allocator) {\n    DAWN_UNUSED(allocator);\n\n    ASSERT(transfer->commandId == WireCmd::DevicePopErrorScope);\n\n\n    static_assert(sizeof(record->deviceId) >= sizeof(transfer->deviceId), \"Deserialize assignment may not narrow.\");\n    record->deviceId = transfer->deviceId;\n    static_assert(sizeof(record->requestSerial) >= sizeof(transfer->requestSerial), \"Deserialize assignment may not narrow.\");\n    record->requestSerial = transfer->requestSerial;\n\n    return WireResult::Success;\n}\nDAWN_UNUSED_FUNC(DevicePopErrorScopeDeserialize);\n\nstruct DevicePushErrorScopeTransfer : CmdHeader {\n    static_assert(1 <= 1,\n                  \"Record must be at most one of is_cmd, extensible, and chained.\");\n    WireCmd commandId;\n\n    ObjectId self;\n    WGPUErrorFilter filter;\n};\n\nstatic_assert(offsetof(DevicePushErrorScopeTransfer, commandSize) == 0);\nstatic_assert(offsetof(DevicePushErrorScopeTransfer, commandId) == sizeof(CmdHeader));\n\nDAWN_DECLARE_UNUSED size_t DevicePushErrorScopeGetExtraRequiredSize(const DevicePushErrorScopeCmd& record) {\n    DAWN_UNUSED(record);\n    size_t result = 0;\n\n    return result;\n}\n// GetExtraRequiredSize isn't used for structures that are value members of other structures\n// because we assume they cannot contain pointers themselves.\nDAWN_UNUSED_FUNC(DevicePushErrorScopeGetExtraRequiredSize);\n\nDAWN_DECLARE_UNUSED WireResult DevicePushErrorScopeSerialize(\n    const DevicePushErrorScopeCmd& record,\n    DevicePushErrorScopeTransfer* transfer,\n    SerializeBuffer* buffer, const ObjectIdProvider& provider) {\n    DAWN_UNUSED(buffer);\n    transfer->commandId = WireCmd::DevicePushErrorScope;\n\n\n    WIRE_TRY(provider.GetId(record.self, &transfer->self));\n    transfer->filter = record.filter;\n\n    return WireResult::Success;\n}\nDAWN_UNUSED_FUNC(DevicePushErrorScopeSerialize);\n\nDAWN_DECLARE_UNUSED WireResult DevicePushErrorScopeDeserialize(\n    DevicePushErrorScopeCmd* record,\n    const volatile DevicePushErrorScopeTransfer* transfer,\n    DeserializeBuffer* deserializeBuffer,\n    DeserializeAllocator* allocator, const ObjectIdResolver& resolver) {\n    DAWN_UNUSED(allocator);\n\n    ASSERT(transfer->commandId == WireCmd::DevicePushErrorScope);\n    record->selfId = transfer->self;\n\n\n    WIRE_TRY(resolver.GetFromId(transfer->self, &record->self));\n    static_assert(sizeof(record->filter) >= sizeof(transfer->filter), \"Deserialize assignment may not narrow.\");\n    record->filter = transfer->filter;\n\n    return WireResult::Success;\n}\nDAWN_UNUSED_FUNC(DevicePushErrorScopeDeserialize);\n\nstruct DeviceSetLabelTransfer : CmdHeader {\n    static_assert(1 <= 1,\n                  \"Record must be at most one of is_cmd, extensible, and chained.\");\n    WireCmd commandId;\n\n    ObjectId self;\n    uint64_t labelStrlen;\n};\n\nstatic_assert(offsetof(DeviceSetLabelTransfer, commandSize) == 0);\nstatic_assert(offsetof(DeviceSetLabelTransfer, commandId) == sizeof(CmdHeader));\n\nDAWN_DECLARE_UNUSED size_t DeviceSetLabelGetExtraRequiredSize(const DeviceSetLabelCmd& record) {\n    DAWN_UNUSED(record);\n    size_t result = 0;\n\n    ASSERT(record.label != nullptr);\n    result += Align(std::strlen(record.label), kWireBufferAlignment);\n    return result;\n}\n// GetExtraRequiredSize isn't used for structures that are value members of other structures\n// because we assume they cannot contain pointers themselves.\nDAWN_UNUSED_FUNC(DeviceSetLabelGetExtraRequiredSize);\n\nDAWN_DECLARE_UNUSED WireResult DeviceSetLabelSerialize(\n    const DeviceSetLabelCmd& record,\n    DeviceSetLabelTransfer* transfer,\n    SerializeBuffer* buffer, const ObjectIdProvider& provider) {\n    DAWN_UNUSED(buffer);\n    transfer->commandId = WireCmd::DeviceSetLabel;\n\n\n    WIRE_TRY(provider.GetId(record.self, &transfer->self));\n    {\n        transfer->labelStrlen = std::strlen(record.label);\n\n        char* stringInBuffer;\n        WIRE_TRY(buffer->NextN(transfer->labelStrlen, &stringInBuffer));\n        memcpy(stringInBuffer, record.label, transfer->labelStrlen);\n    }\n\n    return WireResult::Success;\n}\nDAWN_UNUSED_FUNC(DeviceSetLabelSerialize);\n\nDAWN_DECLARE_UNUSED WireResult DeviceSetLabelDeserialize(\n    DeviceSetLabelCmd* record,\n    const volatile DeviceSetLabelTransfer* transfer,\n    DeserializeBuffer* deserializeBuffer,\n    DeserializeAllocator* allocator, const ObjectIdResolver& resolver) {\n    DAWN_UNUSED(allocator);\n\n    ASSERT(transfer->commandId == WireCmd::DeviceSetLabel);\n    record->selfId = transfer->self;\n\n\n    WIRE_TRY(resolver.GetFromId(transfer->self, &record->self));\n    {\n        uint64_t stringLength64 = transfer->labelStrlen;\n        if (stringLength64 >= std::numeric_limits<size_t>::max()) {\n            return WireResult::FatalError;\n        }\n        size_t stringLength = static_cast<size_t>(stringLength64);\n\n        const volatile char* stringInBuffer;\n        WIRE_TRY(deserializeBuffer->ReadN(stringLength, &stringInBuffer));\n\n        char* copiedString;\n        WIRE_TRY(GetSpace(allocator, stringLength + 1, &copiedString));\n        memcpy(copiedString, const_cast<const char*>(stringInBuffer), stringLength);\n        copiedString[stringLength] = '\\0';\n        record->label = copiedString;\n    }\n\n    return WireResult::Success;\n}\nDAWN_UNUSED_FUNC(DeviceSetLabelDeserialize);\n\nstruct DeviceTickTransfer : CmdHeader {\n    static_assert(1 <= 1,\n                  \"Record must be at most one of is_cmd, extensible, and chained.\");\n    WireCmd commandId;\n\n    ObjectId self;\n};\n\nstatic_assert(offsetof(DeviceTickTransfer, commandSize) == 0);\nstatic_assert(offsetof(DeviceTickTransfer, commandId) == sizeof(CmdHeader));\n\nDAWN_DECLARE_UNUSED size_t DeviceTickGetExtraRequiredSize(const DeviceTickCmd& record) {\n    DAWN_UNUSED(record);\n    size_t result = 0;\n\n    return result;\n}\n// GetExtraRequiredSize isn't used for structures that are value members of other structures\n// because we assume they cannot contain pointers themselves.\nDAWN_UNUSED_FUNC(DeviceTickGetExtraRequiredSize);\n\nDAWN_DECLARE_UNUSED WireResult DeviceTickSerialize(\n    const DeviceTickCmd& record,\n    DeviceTickTransfer* transfer,\n    SerializeBuffer* buffer, const ObjectIdProvider& provider) {\n    DAWN_UNUSED(buffer);\n    transfer->commandId = WireCmd::DeviceTick;\n\n\n    WIRE_TRY(provider.GetId(record.self, &transfer->self));\n\n    return WireResult::Success;\n}\nDAWN_UNUSED_FUNC(DeviceTickSerialize);\n\nDAWN_DECLARE_UNUSED WireResult DeviceTickDeserialize(\n    DeviceTickCmd* record,\n    const volatile DeviceTickTransfer* transfer,\n    DeserializeBuffer* deserializeBuffer,\n    DeserializeAllocator* allocator, const ObjectIdResolver& resolver) {\n    DAWN_UNUSED(allocator);\n\n    ASSERT(transfer->commandId == WireCmd::DeviceTick);\n    record->selfId = transfer->self;\n\n\n    WIRE_TRY(resolver.GetFromId(transfer->self, &record->self));\n\n    return WireResult::Success;\n}\nDAWN_UNUSED_FUNC(DeviceTickDeserialize);\n\nstruct DeviceValidateTextureDescriptorTransfer : CmdHeader {\n    static_assert(1 <= 1,\n                  \"Record must be at most one of is_cmd, extensible, and chained.\");\n    WireCmd commandId;\n\n    ObjectId self;\n};\n\nstatic_assert(offsetof(DeviceValidateTextureDescriptorTransfer, commandSize) == 0);\nstatic_assert(offsetof(DeviceValidateTextureDescriptorTransfer, commandId) == sizeof(CmdHeader));\n\nDAWN_DECLARE_UNUSED size_t DeviceValidateTextureDescriptorGetExtraRequiredSize(const DeviceValidateTextureDescriptorCmd& record) {\n    DAWN_UNUSED(record);\n    size_t result = 0;\n\n    {\n        auto memberLength = 1u;\n        auto size = WireAlignSizeofN<WGPUTextureDescriptorTransfer>(memberLength);\n        ASSERT(size);\n        result += *size;\n        for (decltype(memberLength) i = 0; i < memberLength; ++i) {\n            result += WGPUTextureDescriptorGetExtraRequiredSize(record.descriptor[i]);\n        }\n    }\n    return result;\n}\n// GetExtraRequiredSize isn't used for structures that are value members of other structures\n// because we assume they cannot contain pointers themselves.\nDAWN_UNUSED_FUNC(DeviceValidateTextureDescriptorGetExtraRequiredSize);\n\nDAWN_DECLARE_UNUSED WireResult DeviceValidateTextureDescriptorSerialize(\n    const DeviceValidateTextureDescriptorCmd& record,\n    DeviceValidateTextureDescriptorTransfer* transfer,\n    SerializeBuffer* buffer, const ObjectIdProvider& provider) {\n    DAWN_UNUSED(buffer);\n    transfer->commandId = WireCmd::DeviceValidateTextureDescriptor;\n\n\n    WIRE_TRY(provider.GetId(record.self, &transfer->self));\n    {\n        auto memberLength = 1u;\n\n        WGPUTextureDescriptorTransfer* memberBuffer;\n        WIRE_TRY(buffer->NextN(memberLength, &memberBuffer));\n\n        for (decltype(memberLength) i = 0; i < memberLength; ++i) {\n            WIRE_TRY(WGPUTextureDescriptorSerialize(record.descriptor[i], &memberBuffer[i], buffer, provider));\n        }\n    }\n\n    return WireResult::Success;\n}\nDAWN_UNUSED_FUNC(DeviceValidateTextureDescriptorSerialize);\n\nDAWN_DECLARE_UNUSED WireResult DeviceValidateTextureDescriptorDeserialize(\n    DeviceValidateTextureDescriptorCmd* record,\n    const volatile DeviceValidateTextureDescriptorTransfer* transfer,\n    DeserializeBuffer* deserializeBuffer,\n    DeserializeAllocator* allocator, const ObjectIdResolver& resolver) {\n    DAWN_UNUSED(allocator);\n\n    ASSERT(transfer->commandId == WireCmd::DeviceValidateTextureDescriptor);\n    record->selfId = transfer->self;\n\n\n    WIRE_TRY(resolver.GetFromId(transfer->self, &record->self));\n    {\n        auto memberLength = 1u;\n        const volatile WGPUTextureDescriptorTransfer* memberBuffer;\n        WIRE_TRY(deserializeBuffer->ReadN(memberLength, &memberBuffer));\n\n        WGPUTextureDescriptor* copiedMembers;\n        WIRE_TRY(GetSpace(allocator, memberLength, &copiedMembers));\n        record->descriptor = copiedMembers;\n\n        for (decltype(memberLength) i = 0; i < memberLength; ++i) {\n            WIRE_TRY(WGPUTextureDescriptorDeserialize(&copiedMembers[i], &memberBuffer[i], deserializeBuffer, allocator, resolver));\n        }\n    }\n\n    return WireResult::Success;\n}\nDAWN_UNUSED_FUNC(DeviceValidateTextureDescriptorDeserialize);\n\nstruct ExternalTextureDestroyTransfer : CmdHeader {\n    static_assert(1 <= 1,\n                  \"Record must be at most one of is_cmd, extensible, and chained.\");\n    WireCmd commandId;\n\n    ObjectId self;\n};\n\nstatic_assert(offsetof(ExternalTextureDestroyTransfer, commandSize) == 0);\nstatic_assert(offsetof(ExternalTextureDestroyTransfer, commandId) == sizeof(CmdHeader));\n\nDAWN_DECLARE_UNUSED size_t ExternalTextureDestroyGetExtraRequiredSize(const ExternalTextureDestroyCmd& record) {\n    DAWN_UNUSED(record);\n    size_t result = 0;\n\n    return result;\n}\n// GetExtraRequiredSize isn't used for structures that are value members of other structures\n// because we assume they cannot contain pointers themselves.\nDAWN_UNUSED_FUNC(ExternalTextureDestroyGetExtraRequiredSize);\n\nDAWN_DECLARE_UNUSED WireResult ExternalTextureDestroySerialize(\n    const ExternalTextureDestroyCmd& record,\n    ExternalTextureDestroyTransfer* transfer,\n    SerializeBuffer* buffer, const ObjectIdProvider& provider) {\n    DAWN_UNUSED(buffer);\n    transfer->commandId = WireCmd::ExternalTextureDestroy;\n\n\n    WIRE_TRY(provider.GetId(record.self, &transfer->self));\n\n    return WireResult::Success;\n}\nDAWN_UNUSED_FUNC(ExternalTextureDestroySerialize);\n\nDAWN_DECLARE_UNUSED WireResult ExternalTextureDestroyDeserialize(\n    ExternalTextureDestroyCmd* record,\n    const volatile ExternalTextureDestroyTransfer* transfer,\n    DeserializeBuffer* deserializeBuffer,\n    DeserializeAllocator* allocator, const ObjectIdResolver& resolver) {\n    DAWN_UNUSED(allocator);\n\n    ASSERT(transfer->commandId == WireCmd::ExternalTextureDestroy);\n    record->selfId = transfer->self;\n\n\n    WIRE_TRY(resolver.GetFromId(transfer->self, &record->self));\n\n    return WireResult::Success;\n}\nDAWN_UNUSED_FUNC(ExternalTextureDestroyDeserialize);\n\nstruct ExternalTextureExpireTransfer : CmdHeader {\n    static_assert(1 <= 1,\n                  \"Record must be at most one of is_cmd, extensible, and chained.\");\n    WireCmd commandId;\n\n    ObjectId self;\n};\n\nstatic_assert(offsetof(ExternalTextureExpireTransfer, commandSize) == 0);\nstatic_assert(offsetof(ExternalTextureExpireTransfer, commandId) == sizeof(CmdHeader));\n\nDAWN_DECLARE_UNUSED size_t ExternalTextureExpireGetExtraRequiredSize(const ExternalTextureExpireCmd& record) {\n    DAWN_UNUSED(record);\n    size_t result = 0;\n\n    return result;\n}\n// GetExtraRequiredSize isn't used for structures that are value members of other structures\n// because we assume they cannot contain pointers themselves.\nDAWN_UNUSED_FUNC(ExternalTextureExpireGetExtraRequiredSize);\n\nDAWN_DECLARE_UNUSED WireResult ExternalTextureExpireSerialize(\n    const ExternalTextureExpireCmd& record,\n    ExternalTextureExpireTransfer* transfer,\n    SerializeBuffer* buffer, const ObjectIdProvider& provider) {\n    DAWN_UNUSED(buffer);\n    transfer->commandId = WireCmd::ExternalTextureExpire;\n\n\n    WIRE_TRY(provider.GetId(record.self, &transfer->self));\n\n    return WireResult::Success;\n}\nDAWN_UNUSED_FUNC(ExternalTextureExpireSerialize);\n\nDAWN_DECLARE_UNUSED WireResult ExternalTextureExpireDeserialize(\n    ExternalTextureExpireCmd* record,\n    const volatile ExternalTextureExpireTransfer* transfer,\n    DeserializeBuffer* deserializeBuffer,\n    DeserializeAllocator* allocator, const ObjectIdResolver& resolver) {\n    DAWN_UNUSED(allocator);\n\n    ASSERT(transfer->commandId == WireCmd::ExternalTextureExpire);\n    record->selfId = transfer->self;\n\n\n    WIRE_TRY(resolver.GetFromId(transfer->self, &record->self));\n\n    return WireResult::Success;\n}\nDAWN_UNUSED_FUNC(ExternalTextureExpireDeserialize);\n\nstruct ExternalTextureRefreshTransfer : CmdHeader {\n    static_assert(1 <= 1,\n                  \"Record must be at most one of is_cmd, extensible, and chained.\");\n    WireCmd commandId;\n\n    ObjectId self;\n};\n\nstatic_assert(offsetof(ExternalTextureRefreshTransfer, commandSize) == 0);\nstatic_assert(offsetof(ExternalTextureRefreshTransfer, commandId) == sizeof(CmdHeader));\n\nDAWN_DECLARE_UNUSED size_t ExternalTextureRefreshGetExtraRequiredSize(const ExternalTextureRefreshCmd& record) {\n    DAWN_UNUSED(record);\n    size_t result = 0;\n\n    return result;\n}\n// GetExtraRequiredSize isn't used for structures that are value members of other structures\n// because we assume they cannot contain pointers themselves.\nDAWN_UNUSED_FUNC(ExternalTextureRefreshGetExtraRequiredSize);\n\nDAWN_DECLARE_UNUSED WireResult ExternalTextureRefreshSerialize(\n    const ExternalTextureRefreshCmd& record,\n    ExternalTextureRefreshTransfer* transfer,\n    SerializeBuffer* buffer, const ObjectIdProvider& provider) {\n    DAWN_UNUSED(buffer);\n    transfer->commandId = WireCmd::ExternalTextureRefresh;\n\n\n    WIRE_TRY(provider.GetId(record.self, &transfer->self));\n\n    return WireResult::Success;\n}\nDAWN_UNUSED_FUNC(ExternalTextureRefreshSerialize);\n\nDAWN_DECLARE_UNUSED WireResult ExternalTextureRefreshDeserialize(\n    ExternalTextureRefreshCmd* record,\n    const volatile ExternalTextureRefreshTransfer* transfer,\n    DeserializeBuffer* deserializeBuffer,\n    DeserializeAllocator* allocator, const ObjectIdResolver& resolver) {\n    DAWN_UNUSED(allocator);\n\n    ASSERT(transfer->commandId == WireCmd::ExternalTextureRefresh);\n    record->selfId = transfer->self;\n\n\n    WIRE_TRY(resolver.GetFromId(transfer->self, &record->self));\n\n    return WireResult::Success;\n}\nDAWN_UNUSED_FUNC(ExternalTextureRefreshDeserialize);\n\nstruct ExternalTextureSetLabelTransfer : CmdHeader {\n    static_assert(1 <= 1,\n                  \"Record must be at most one of is_cmd, extensible, and chained.\");\n    WireCmd commandId;\n\n    ObjectId self;\n    uint64_t labelStrlen;\n};\n\nstatic_assert(offsetof(ExternalTextureSetLabelTransfer, commandSize) == 0);\nstatic_assert(offsetof(ExternalTextureSetLabelTransfer, commandId) == sizeof(CmdHeader));\n\nDAWN_DECLARE_UNUSED size_t ExternalTextureSetLabelGetExtraRequiredSize(const ExternalTextureSetLabelCmd& record) {\n    DAWN_UNUSED(record);\n    size_t result = 0;\n\n    ASSERT(record.label != nullptr);\n    result += Align(std::strlen(record.label), kWireBufferAlignment);\n    return result;\n}\n// GetExtraRequiredSize isn't used for structures that are value members of other structures\n// because we assume they cannot contain pointers themselves.\nDAWN_UNUSED_FUNC(ExternalTextureSetLabelGetExtraRequiredSize);\n\nDAWN_DECLARE_UNUSED WireResult ExternalTextureSetLabelSerialize(\n    const ExternalTextureSetLabelCmd& record,\n    ExternalTextureSetLabelTransfer* transfer,\n    SerializeBuffer* buffer, const ObjectIdProvider& provider) {\n    DAWN_UNUSED(buffer);\n    transfer->commandId = WireCmd::ExternalTextureSetLabel;\n\n\n    WIRE_TRY(provider.GetId(record.self, &transfer->self));\n    {\n        transfer->labelStrlen = std::strlen(record.label);\n\n        char* stringInBuffer;\n        WIRE_TRY(buffer->NextN(transfer->labelStrlen, &stringInBuffer));\n        memcpy(stringInBuffer, record.label, transfer->labelStrlen);\n    }\n\n    return WireResult::Success;\n}\nDAWN_UNUSED_FUNC(ExternalTextureSetLabelSerialize);\n\nDAWN_DECLARE_UNUSED WireResult ExternalTextureSetLabelDeserialize(\n    ExternalTextureSetLabelCmd* record,\n    const volatile ExternalTextureSetLabelTransfer* transfer,\n    DeserializeBuffer* deserializeBuffer,\n    DeserializeAllocator* allocator, const ObjectIdResolver& resolver) {\n    DAWN_UNUSED(allocator);\n\n    ASSERT(transfer->commandId == WireCmd::ExternalTextureSetLabel);\n    record->selfId = transfer->self;\n\n\n    WIRE_TRY(resolver.GetFromId(transfer->self, &record->self));\n    {\n        uint64_t stringLength64 = transfer->labelStrlen;\n        if (stringLength64 >= std::numeric_limits<size_t>::max()) {\n            return WireResult::FatalError;\n        }\n        size_t stringLength = static_cast<size_t>(stringLength64);\n\n        const volatile char* stringInBuffer;\n        WIRE_TRY(deserializeBuffer->ReadN(stringLength, &stringInBuffer));\n\n        char* copiedString;\n        WIRE_TRY(GetSpace(allocator, stringLength + 1, &copiedString));\n        memcpy(copiedString, const_cast<const char*>(stringInBuffer), stringLength);\n        copiedString[stringLength] = '\\0';\n        record->label = copiedString;\n    }\n\n    return WireResult::Success;\n}\nDAWN_UNUSED_FUNC(ExternalTextureSetLabelDeserialize);\n\nstruct InstanceCreateSurfaceTransfer : CmdHeader {\n    static_assert(1 <= 1,\n                  \"Record must be at most one of is_cmd, extensible, and chained.\");\n    WireCmd commandId;\n\n    ObjectId self;\n    ObjectHandle result;\n};\n\nstatic_assert(offsetof(InstanceCreateSurfaceTransfer, commandSize) == 0);\nstatic_assert(offsetof(InstanceCreateSurfaceTransfer, commandId) == sizeof(CmdHeader));\n\nDAWN_DECLARE_UNUSED size_t InstanceCreateSurfaceGetExtraRequiredSize(const InstanceCreateSurfaceCmd& record) {\n    DAWN_UNUSED(record);\n    size_t result = 0;\n\n    {\n        auto memberLength = 1u;\n        auto size = WireAlignSizeofN<WGPUSurfaceDescriptorTransfer>(memberLength);\n        ASSERT(size);\n        result += *size;\n        for (decltype(memberLength) i = 0; i < memberLength; ++i) {\n            result += WGPUSurfaceDescriptorGetExtraRequiredSize(record.descriptor[i]);\n        }\n    }\n    return result;\n}\n// GetExtraRequiredSize isn't used for structures that are value members of other structures\n// because we assume they cannot contain pointers themselves.\nDAWN_UNUSED_FUNC(InstanceCreateSurfaceGetExtraRequiredSize);\n\nDAWN_DECLARE_UNUSED WireResult InstanceCreateSurfaceSerialize(\n    const InstanceCreateSurfaceCmd& record,\n    InstanceCreateSurfaceTransfer* transfer,\n    SerializeBuffer* buffer, const ObjectIdProvider& provider) {\n    DAWN_UNUSED(buffer);\n    transfer->commandId = WireCmd::InstanceCreateSurface;\n\n\n    WIRE_TRY(provider.GetId(record.self, &transfer->self));\n    transfer->result = record.result;\n    {\n        auto memberLength = 1u;\n\n        WGPUSurfaceDescriptorTransfer* memberBuffer;\n        WIRE_TRY(buffer->NextN(memberLength, &memberBuffer));\n\n        for (decltype(memberLength) i = 0; i < memberLength; ++i) {\n            WIRE_TRY(WGPUSurfaceDescriptorSerialize(record.descriptor[i], &memberBuffer[i], buffer, provider));\n        }\n    }\n\n    return WireResult::Success;\n}\nDAWN_UNUSED_FUNC(InstanceCreateSurfaceSerialize);\n\nDAWN_DECLARE_UNUSED WireResult InstanceCreateSurfaceDeserialize(\n    InstanceCreateSurfaceCmd* record,\n    const volatile InstanceCreateSurfaceTransfer* transfer,\n    DeserializeBuffer* deserializeBuffer,\n    DeserializeAllocator* allocator, const ObjectIdResolver& resolver) {\n    DAWN_UNUSED(allocator);\n\n    ASSERT(transfer->commandId == WireCmd::InstanceCreateSurface);\n    record->selfId = transfer->self;\n\n\n    WIRE_TRY(resolver.GetFromId(transfer->self, &record->self));\n    static_assert(sizeof(record->result) >= sizeof(transfer->result), \"Deserialize assignment may not narrow.\");\n    record->result = transfer->result;\n    {\n        auto memberLength = 1u;\n        const volatile WGPUSurfaceDescriptorTransfer* memberBuffer;\n        WIRE_TRY(deserializeBuffer->ReadN(memberLength, &memberBuffer));\n\n        WGPUSurfaceDescriptor* copiedMembers;\n        WIRE_TRY(GetSpace(allocator, memberLength, &copiedMembers));\n        record->descriptor = copiedMembers;\n\n        for (decltype(memberLength) i = 0; i < memberLength; ++i) {\n            WIRE_TRY(WGPUSurfaceDescriptorDeserialize(&copiedMembers[i], &memberBuffer[i], deserializeBuffer, allocator, resolver));\n        }\n    }\n\n    return WireResult::Success;\n}\nDAWN_UNUSED_FUNC(InstanceCreateSurfaceDeserialize);\n\nstruct InstanceProcessEventsTransfer : CmdHeader {\n    static_assert(1 <= 1,\n                  \"Record must be at most one of is_cmd, extensible, and chained.\");\n    WireCmd commandId;\n\n    ObjectId self;\n};\n\nstatic_assert(offsetof(InstanceProcessEventsTransfer, commandSize) == 0);\nstatic_assert(offsetof(InstanceProcessEventsTransfer, commandId) == sizeof(CmdHeader));\n\nDAWN_DECLARE_UNUSED size_t InstanceProcessEventsGetExtraRequiredSize(const InstanceProcessEventsCmd& record) {\n    DAWN_UNUSED(record);\n    size_t result = 0;\n\n    return result;\n}\n// GetExtraRequiredSize isn't used for structures that are value members of other structures\n// because we assume they cannot contain pointers themselves.\nDAWN_UNUSED_FUNC(InstanceProcessEventsGetExtraRequiredSize);\n\nDAWN_DECLARE_UNUSED WireResult InstanceProcessEventsSerialize(\n    const InstanceProcessEventsCmd& record,\n    InstanceProcessEventsTransfer* transfer,\n    SerializeBuffer* buffer, const ObjectIdProvider& provider) {\n    DAWN_UNUSED(buffer);\n    transfer->commandId = WireCmd::InstanceProcessEvents;\n\n\n    WIRE_TRY(provider.GetId(record.self, &transfer->self));\n\n    return WireResult::Success;\n}\nDAWN_UNUSED_FUNC(InstanceProcessEventsSerialize);\n\nDAWN_DECLARE_UNUSED WireResult InstanceProcessEventsDeserialize(\n    InstanceProcessEventsCmd* record,\n    const volatile InstanceProcessEventsTransfer* transfer,\n    DeserializeBuffer* deserializeBuffer,\n    DeserializeAllocator* allocator, const ObjectIdResolver& resolver) {\n    DAWN_UNUSED(allocator);\n\n    ASSERT(transfer->commandId == WireCmd::InstanceProcessEvents);\n    record->selfId = transfer->self;\n\n\n    WIRE_TRY(resolver.GetFromId(transfer->self, &record->self));\n\n    return WireResult::Success;\n}\nDAWN_UNUSED_FUNC(InstanceProcessEventsDeserialize);\n\nstruct InstanceRequestAdapterTransfer : CmdHeader {\n    static_assert(1 <= 1,\n                  \"Record must be at most one of is_cmd, extensible, and chained.\");\n    WireCmd commandId;\n\n    ObjectId instanceId;\n    uint64_t requestSerial;\n    ObjectHandle adapterObjectHandle;\n    bool has_options;\n};\n\nstatic_assert(offsetof(InstanceRequestAdapterTransfer, commandSize) == 0);\nstatic_assert(offsetof(InstanceRequestAdapterTransfer, commandId) == sizeof(CmdHeader));\n\nDAWN_DECLARE_UNUSED size_t InstanceRequestAdapterGetExtraRequiredSize(const InstanceRequestAdapterCmd& record) {\n    DAWN_UNUSED(record);\n    size_t result = 0;\n\n    if (record.options != nullptr) {\n        auto memberLength = 1u;\n        auto size = WireAlignSizeofN<WGPURequestAdapterOptionsTransfer>(memberLength);\n        ASSERT(size);\n        result += *size;\n        for (decltype(memberLength) i = 0; i < memberLength; ++i) {\n            result += WGPURequestAdapterOptionsGetExtraRequiredSize(record.options[i]);\n        }\n    }\n    return result;\n}\n// GetExtraRequiredSize isn't used for structures that are value members of other structures\n// because we assume they cannot contain pointers themselves.\nDAWN_UNUSED_FUNC(InstanceRequestAdapterGetExtraRequiredSize);\n\nDAWN_DECLARE_UNUSED WireResult InstanceRequestAdapterSerialize(\n    const InstanceRequestAdapterCmd& record,\n    InstanceRequestAdapterTransfer* transfer,\n    SerializeBuffer* buffer, const ObjectIdProvider& provider) {\n    DAWN_UNUSED(buffer);\n    transfer->commandId = WireCmd::InstanceRequestAdapter;\n\n\n    transfer->instanceId = record.instanceId;\n    transfer->requestSerial = record.requestSerial;\n    transfer->adapterObjectHandle = record.adapterObjectHandle;\n    bool has_options = record.options != nullptr;\n    transfer->has_options = has_options;\n    if (has_options) {\n        auto memberLength = 1u;\n\n        WGPURequestAdapterOptionsTransfer* memberBuffer;\n        WIRE_TRY(buffer->NextN(memberLength, &memberBuffer));\n\n        for (decltype(memberLength) i = 0; i < memberLength; ++i) {\n            WIRE_TRY(WGPURequestAdapterOptionsSerialize(record.options[i], &memberBuffer[i], buffer, provider));\n        }\n    }\n\n    return WireResult::Success;\n}\nDAWN_UNUSED_FUNC(InstanceRequestAdapterSerialize);\n\nDAWN_DECLARE_UNUSED WireResult InstanceRequestAdapterDeserialize(\n    InstanceRequestAdapterCmd* record,\n    const volatile InstanceRequestAdapterTransfer* transfer,\n    DeserializeBuffer* deserializeBuffer,\n    DeserializeAllocator* allocator, const ObjectIdResolver& resolver) {\n    DAWN_UNUSED(allocator);\n\n    ASSERT(transfer->commandId == WireCmd::InstanceRequestAdapter);\n\n\n    static_assert(sizeof(record->instanceId) >= sizeof(transfer->instanceId), \"Deserialize assignment may not narrow.\");\n    record->instanceId = transfer->instanceId;\n    static_assert(sizeof(record->requestSerial) >= sizeof(transfer->requestSerial), \"Deserialize assignment may not narrow.\");\n    record->requestSerial = transfer->requestSerial;\n    static_assert(sizeof(record->adapterObjectHandle) >= sizeof(transfer->adapterObjectHandle), \"Deserialize assignment may not narrow.\");\n    record->adapterObjectHandle = transfer->adapterObjectHandle;\n    bool has_options = transfer->has_options;\n    record->options = nullptr;\n    if (has_options) {\n        auto memberLength = 1u;\n        const volatile WGPURequestAdapterOptionsTransfer* memberBuffer;\n        WIRE_TRY(deserializeBuffer->ReadN(memberLength, &memberBuffer));\n\n        WGPURequestAdapterOptions* copiedMembers;\n        WIRE_TRY(GetSpace(allocator, memberLength, &copiedMembers));\n        record->options = copiedMembers;\n\n        for (decltype(memberLength) i = 0; i < memberLength; ++i) {\n            WIRE_TRY(WGPURequestAdapterOptionsDeserialize(&copiedMembers[i], &memberBuffer[i], deserializeBuffer, allocator, resolver));\n        }\n    }\n\n    return WireResult::Success;\n}\nDAWN_UNUSED_FUNC(InstanceRequestAdapterDeserialize);\n\nstruct PipelineLayoutSetLabelTransfer : CmdHeader {\n    static_assert(1 <= 1,\n                  \"Record must be at most one of is_cmd, extensible, and chained.\");\n    WireCmd commandId;\n\n    ObjectId self;\n    uint64_t labelStrlen;\n};\n\nstatic_assert(offsetof(PipelineLayoutSetLabelTransfer, commandSize) == 0);\nstatic_assert(offsetof(PipelineLayoutSetLabelTransfer, commandId) == sizeof(CmdHeader));\n\nDAWN_DECLARE_UNUSED size_t PipelineLayoutSetLabelGetExtraRequiredSize(const PipelineLayoutSetLabelCmd& record) {\n    DAWN_UNUSED(record);\n    size_t result = 0;\n\n    ASSERT(record.label != nullptr);\n    result += Align(std::strlen(record.label), kWireBufferAlignment);\n    return result;\n}\n// GetExtraRequiredSize isn't used for structures that are value members of other structures\n// because we assume they cannot contain pointers themselves.\nDAWN_UNUSED_FUNC(PipelineLayoutSetLabelGetExtraRequiredSize);\n\nDAWN_DECLARE_UNUSED WireResult PipelineLayoutSetLabelSerialize(\n    const PipelineLayoutSetLabelCmd& record,\n    PipelineLayoutSetLabelTransfer* transfer,\n    SerializeBuffer* buffer, const ObjectIdProvider& provider) {\n    DAWN_UNUSED(buffer);\n    transfer->commandId = WireCmd::PipelineLayoutSetLabel;\n\n\n    WIRE_TRY(provider.GetId(record.self, &transfer->self));\n    {\n        transfer->labelStrlen = std::strlen(record.label);\n\n        char* stringInBuffer;\n        WIRE_TRY(buffer->NextN(transfer->labelStrlen, &stringInBuffer));\n        memcpy(stringInBuffer, record.label, transfer->labelStrlen);\n    }\n\n    return WireResult::Success;\n}\nDAWN_UNUSED_FUNC(PipelineLayoutSetLabelSerialize);\n\nDAWN_DECLARE_UNUSED WireResult PipelineLayoutSetLabelDeserialize(\n    PipelineLayoutSetLabelCmd* record,\n    const volatile PipelineLayoutSetLabelTransfer* transfer,\n    DeserializeBuffer* deserializeBuffer,\n    DeserializeAllocator* allocator, const ObjectIdResolver& resolver) {\n    DAWN_UNUSED(allocator);\n\n    ASSERT(transfer->commandId == WireCmd::PipelineLayoutSetLabel);\n    record->selfId = transfer->self;\n\n\n    WIRE_TRY(resolver.GetFromId(transfer->self, &record->self));\n    {\n        uint64_t stringLength64 = transfer->labelStrlen;\n        if (stringLength64 >= std::numeric_limits<size_t>::max()) {\n            return WireResult::FatalError;\n        }\n        size_t stringLength = static_cast<size_t>(stringLength64);\n\n        const volatile char* stringInBuffer;\n        WIRE_TRY(deserializeBuffer->ReadN(stringLength, &stringInBuffer));\n\n        char* copiedString;\n        WIRE_TRY(GetSpace(allocator, stringLength + 1, &copiedString));\n        memcpy(copiedString, const_cast<const char*>(stringInBuffer), stringLength);\n        copiedString[stringLength] = '\\0';\n        record->label = copiedString;\n    }\n\n    return WireResult::Success;\n}\nDAWN_UNUSED_FUNC(PipelineLayoutSetLabelDeserialize);\n\nstruct QuerySetDestroyTransfer : CmdHeader {\n    static_assert(1 <= 1,\n                  \"Record must be at most one of is_cmd, extensible, and chained.\");\n    WireCmd commandId;\n\n    ObjectId self;\n};\n\nstatic_assert(offsetof(QuerySetDestroyTransfer, commandSize) == 0);\nstatic_assert(offsetof(QuerySetDestroyTransfer, commandId) == sizeof(CmdHeader));\n\nDAWN_DECLARE_UNUSED size_t QuerySetDestroyGetExtraRequiredSize(const QuerySetDestroyCmd& record) {\n    DAWN_UNUSED(record);\n    size_t result = 0;\n\n    return result;\n}\n// GetExtraRequiredSize isn't used for structures that are value members of other structures\n// because we assume they cannot contain pointers themselves.\nDAWN_UNUSED_FUNC(QuerySetDestroyGetExtraRequiredSize);\n\nDAWN_DECLARE_UNUSED WireResult QuerySetDestroySerialize(\n    const QuerySetDestroyCmd& record,\n    QuerySetDestroyTransfer* transfer,\n    SerializeBuffer* buffer, const ObjectIdProvider& provider) {\n    DAWN_UNUSED(buffer);\n    transfer->commandId = WireCmd::QuerySetDestroy;\n\n\n    WIRE_TRY(provider.GetId(record.self, &transfer->self));\n\n    return WireResult::Success;\n}\nDAWN_UNUSED_FUNC(QuerySetDestroySerialize);\n\nDAWN_DECLARE_UNUSED WireResult QuerySetDestroyDeserialize(\n    QuerySetDestroyCmd* record,\n    const volatile QuerySetDestroyTransfer* transfer,\n    DeserializeBuffer* deserializeBuffer,\n    DeserializeAllocator* allocator, const ObjectIdResolver& resolver) {\n    DAWN_UNUSED(allocator);\n\n    ASSERT(transfer->commandId == WireCmd::QuerySetDestroy);\n    record->selfId = transfer->self;\n\n\n    WIRE_TRY(resolver.GetFromId(transfer->self, &record->self));\n\n    return WireResult::Success;\n}\nDAWN_UNUSED_FUNC(QuerySetDestroyDeserialize);\n\nstruct QuerySetSetLabelTransfer : CmdHeader {\n    static_assert(1 <= 1,\n                  \"Record must be at most one of is_cmd, extensible, and chained.\");\n    WireCmd commandId;\n\n    ObjectId self;\n    uint64_t labelStrlen;\n};\n\nstatic_assert(offsetof(QuerySetSetLabelTransfer, commandSize) == 0);\nstatic_assert(offsetof(QuerySetSetLabelTransfer, commandId) == sizeof(CmdHeader));\n\nDAWN_DECLARE_UNUSED size_t QuerySetSetLabelGetExtraRequiredSize(const QuerySetSetLabelCmd& record) {\n    DAWN_UNUSED(record);\n    size_t result = 0;\n\n    ASSERT(record.label != nullptr);\n    result += Align(std::strlen(record.label), kWireBufferAlignment);\n    return result;\n}\n// GetExtraRequiredSize isn't used for structures that are value members of other structures\n// because we assume they cannot contain pointers themselves.\nDAWN_UNUSED_FUNC(QuerySetSetLabelGetExtraRequiredSize);\n\nDAWN_DECLARE_UNUSED WireResult QuerySetSetLabelSerialize(\n    const QuerySetSetLabelCmd& record,\n    QuerySetSetLabelTransfer* transfer,\n    SerializeBuffer* buffer, const ObjectIdProvider& provider) {\n    DAWN_UNUSED(buffer);\n    transfer->commandId = WireCmd::QuerySetSetLabel;\n\n\n    WIRE_TRY(provider.GetId(record.self, &transfer->self));\n    {\n        transfer->labelStrlen = std::strlen(record.label);\n\n        char* stringInBuffer;\n        WIRE_TRY(buffer->NextN(transfer->labelStrlen, &stringInBuffer));\n        memcpy(stringInBuffer, record.label, transfer->labelStrlen);\n    }\n\n    return WireResult::Success;\n}\nDAWN_UNUSED_FUNC(QuerySetSetLabelSerialize);\n\nDAWN_DECLARE_UNUSED WireResult QuerySetSetLabelDeserialize(\n    QuerySetSetLabelCmd* record,\n    const volatile QuerySetSetLabelTransfer* transfer,\n    DeserializeBuffer* deserializeBuffer,\n    DeserializeAllocator* allocator, const ObjectIdResolver& resolver) {\n    DAWN_UNUSED(allocator);\n\n    ASSERT(transfer->commandId == WireCmd::QuerySetSetLabel);\n    record->selfId = transfer->self;\n\n\n    WIRE_TRY(resolver.GetFromId(transfer->self, &record->self));\n    {\n        uint64_t stringLength64 = transfer->labelStrlen;\n        if (stringLength64 >= std::numeric_limits<size_t>::max()) {\n            return WireResult::FatalError;\n        }\n        size_t stringLength = static_cast<size_t>(stringLength64);\n\n        const volatile char* stringInBuffer;\n        WIRE_TRY(deserializeBuffer->ReadN(stringLength, &stringInBuffer));\n\n        char* copiedString;\n        WIRE_TRY(GetSpace(allocator, stringLength + 1, &copiedString));\n        memcpy(copiedString, const_cast<const char*>(stringInBuffer), stringLength);\n        copiedString[stringLength] = '\\0';\n        record->label = copiedString;\n    }\n\n    return WireResult::Success;\n}\nDAWN_UNUSED_FUNC(QuerySetSetLabelDeserialize);\n\nstruct QueueCopyExternalTextureForBrowserTransfer : CmdHeader {\n    static_assert(1 <= 1,\n                  \"Record must be at most one of is_cmd, extensible, and chained.\");\n    WireCmd commandId;\n\n    ObjectId self;\n};\n\nstatic_assert(offsetof(QueueCopyExternalTextureForBrowserTransfer, commandSize) == 0);\nstatic_assert(offsetof(QueueCopyExternalTextureForBrowserTransfer, commandId) == sizeof(CmdHeader));\n\nDAWN_DECLARE_UNUSED size_t QueueCopyExternalTextureForBrowserGetExtraRequiredSize(const QueueCopyExternalTextureForBrowserCmd& record) {\n    DAWN_UNUSED(record);\n    size_t result = 0;\n\n    {\n        auto memberLength = 1u;\n        auto size = WireAlignSizeofN<WGPUImageCopyExternalTextureTransfer>(memberLength);\n        ASSERT(size);\n        result += *size;\n        for (decltype(memberLength) i = 0; i < memberLength; ++i) {\n            result += WGPUImageCopyExternalTextureGetExtraRequiredSize(record.source[i]);\n        }\n    }\n    {\n        auto memberLength = 1u;\n        auto size = WireAlignSizeofN<WGPUImageCopyTextureTransfer>(memberLength);\n        ASSERT(size);\n        result += *size;\n        for (decltype(memberLength) i = 0; i < memberLength; ++i) {\n            result += WGPUImageCopyTextureGetExtraRequiredSize(record.destination[i]);\n        }\n    }\n    {\n        auto memberLength = 1u;\n        auto size = WireAlignSizeofN<WGPUExtent3DTransfer>(memberLength);\n        ASSERT(size);\n        result += *size;\n        for (decltype(memberLength) i = 0; i < memberLength; ++i) {\n            result += WGPUExtent3DGetExtraRequiredSize(record.copySize[i]);\n        }\n    }\n    {\n        auto memberLength = 1u;\n        auto size = WireAlignSizeofN<WGPUCopyTextureForBrowserOptionsTransfer>(memberLength);\n        ASSERT(size);\n        result += *size;\n        for (decltype(memberLength) i = 0; i < memberLength; ++i) {\n            result += WGPUCopyTextureForBrowserOptionsGetExtraRequiredSize(record.options[i]);\n        }\n    }\n    return result;\n}\n// GetExtraRequiredSize isn't used for structures that are value members of other structures\n// because we assume they cannot contain pointers themselves.\nDAWN_UNUSED_FUNC(QueueCopyExternalTextureForBrowserGetExtraRequiredSize);\n\nDAWN_DECLARE_UNUSED WireResult QueueCopyExternalTextureForBrowserSerialize(\n    const QueueCopyExternalTextureForBrowserCmd& record,\n    QueueCopyExternalTextureForBrowserTransfer* transfer,\n    SerializeBuffer* buffer, const ObjectIdProvider& provider) {\n    DAWN_UNUSED(buffer);\n    transfer->commandId = WireCmd::QueueCopyExternalTextureForBrowser;\n\n\n    WIRE_TRY(provider.GetId(record.self, &transfer->self));\n    {\n        auto memberLength = 1u;\n\n        WGPUImageCopyExternalTextureTransfer* memberBuffer;\n        WIRE_TRY(buffer->NextN(memberLength, &memberBuffer));\n\n        for (decltype(memberLength) i = 0; i < memberLength; ++i) {\n            WIRE_TRY(WGPUImageCopyExternalTextureSerialize(record.source[i], &memberBuffer[i], buffer, provider));\n        }\n    }\n    {\n        auto memberLength = 1u;\n\n        WGPUImageCopyTextureTransfer* memberBuffer;\n        WIRE_TRY(buffer->NextN(memberLength, &memberBuffer));\n\n        for (decltype(memberLength) i = 0; i < memberLength; ++i) {\n            WIRE_TRY(WGPUImageCopyTextureSerialize(record.destination[i], &memberBuffer[i], buffer, provider));\n        }\n    }\n    {\n        auto memberLength = 1u;\n\n        WGPUExtent3DTransfer* memberBuffer;\n        WIRE_TRY(buffer->NextN(memberLength, &memberBuffer));\n\n        memcpy(\n            memberBuffer, record.copySize,\n            sizeof(WGPUExtent3DTransfer) * memberLength);\n    }\n    {\n        auto memberLength = 1u;\n\n        WGPUCopyTextureForBrowserOptionsTransfer* memberBuffer;\n        WIRE_TRY(buffer->NextN(memberLength, &memberBuffer));\n\n        for (decltype(memberLength) i = 0; i < memberLength; ++i) {\n            WIRE_TRY(WGPUCopyTextureForBrowserOptionsSerialize(record.options[i], &memberBuffer[i], buffer, provider));\n        }\n    }\n\n    return WireResult::Success;\n}\nDAWN_UNUSED_FUNC(QueueCopyExternalTextureForBrowserSerialize);\n\nDAWN_DECLARE_UNUSED WireResult QueueCopyExternalTextureForBrowserDeserialize(\n    QueueCopyExternalTextureForBrowserCmd* record,\n    const volatile QueueCopyExternalTextureForBrowserTransfer* transfer,\n    DeserializeBuffer* deserializeBuffer,\n    DeserializeAllocator* allocator, const ObjectIdResolver& resolver) {\n    DAWN_UNUSED(allocator);\n\n    ASSERT(transfer->commandId == WireCmd::QueueCopyExternalTextureForBrowser);\n    record->selfId = transfer->self;\n\n\n    WIRE_TRY(resolver.GetFromId(transfer->self, &record->self));\n    {\n        auto memberLength = 1u;\n        const volatile WGPUImageCopyExternalTextureTransfer* memberBuffer;\n        WIRE_TRY(deserializeBuffer->ReadN(memberLength, &memberBuffer));\n\n        WGPUImageCopyExternalTexture* copiedMembers;\n        WIRE_TRY(GetSpace(allocator, memberLength, &copiedMembers));\n        record->source = copiedMembers;\n\n        for (decltype(memberLength) i = 0; i < memberLength; ++i) {\n            WIRE_TRY(WGPUImageCopyExternalTextureDeserialize(&copiedMembers[i], &memberBuffer[i], deserializeBuffer, allocator, resolver));\n        }\n    }\n    {\n        auto memberLength = 1u;\n        const volatile WGPUImageCopyTextureTransfer* memberBuffer;\n        WIRE_TRY(deserializeBuffer->ReadN(memberLength, &memberBuffer));\n\n        WGPUImageCopyTexture* copiedMembers;\n        WIRE_TRY(GetSpace(allocator, memberLength, &copiedMembers));\n        record->destination = copiedMembers;\n\n        for (decltype(memberLength) i = 0; i < memberLength; ++i) {\n            WIRE_TRY(WGPUImageCopyTextureDeserialize(&copiedMembers[i], &memberBuffer[i], deserializeBuffer, allocator, resolver));\n        }\n    }\n    {\n        auto memberLength = 1u;\n        const volatile WGPUExtent3DTransfer* memberBuffer;\n        WIRE_TRY(deserializeBuffer->ReadN(memberLength, &memberBuffer));\n\n        WGPUExtent3D* copiedMembers;\n        WIRE_TRY(GetSpace(allocator, memberLength, &copiedMembers));\n        record->copySize = copiedMembers;\n\n        memcpy(\n            copiedMembers,\n            const_cast<const WGPUExtent3DTransfer*>(memberBuffer),\n           sizeof(WGPUExtent3DTransfer) * memberLength);\n    }\n    {\n        auto memberLength = 1u;\n        const volatile WGPUCopyTextureForBrowserOptionsTransfer* memberBuffer;\n        WIRE_TRY(deserializeBuffer->ReadN(memberLength, &memberBuffer));\n\n        WGPUCopyTextureForBrowserOptions* copiedMembers;\n        WIRE_TRY(GetSpace(allocator, memberLength, &copiedMembers));\n        record->options = copiedMembers;\n\n        for (decltype(memberLength) i = 0; i < memberLength; ++i) {\n            WIRE_TRY(WGPUCopyTextureForBrowserOptionsDeserialize(&copiedMembers[i], &memberBuffer[i], deserializeBuffer, allocator, resolver));\n        }\n    }\n\n    return WireResult::Success;\n}\nDAWN_UNUSED_FUNC(QueueCopyExternalTextureForBrowserDeserialize);\n\nstruct QueueCopyTextureForBrowserTransfer : CmdHeader {\n    static_assert(1 <= 1,\n                  \"Record must be at most one of is_cmd, extensible, and chained.\");\n    WireCmd commandId;\n\n    ObjectId self;\n};\n\nstatic_assert(offsetof(QueueCopyTextureForBrowserTransfer, commandSize) == 0);\nstatic_assert(offsetof(QueueCopyTextureForBrowserTransfer, commandId) == sizeof(CmdHeader));\n\nDAWN_DECLARE_UNUSED size_t QueueCopyTextureForBrowserGetExtraRequiredSize(const QueueCopyTextureForBrowserCmd& record) {\n    DAWN_UNUSED(record);\n    size_t result = 0;\n\n    {\n        auto memberLength = 1u;\n        auto size = WireAlignSizeofN<WGPUImageCopyTextureTransfer>(memberLength);\n        ASSERT(size);\n        result += *size;\n        for (decltype(memberLength) i = 0; i < memberLength; ++i) {\n            result += WGPUImageCopyTextureGetExtraRequiredSize(record.source[i]);\n        }\n    }\n    {\n        auto memberLength = 1u;\n        auto size = WireAlignSizeofN<WGPUImageCopyTextureTransfer>(memberLength);\n        ASSERT(size);\n        result += *size;\n        for (decltype(memberLength) i = 0; i < memberLength; ++i) {\n            result += WGPUImageCopyTextureGetExtraRequiredSize(record.destination[i]);\n        }\n    }\n    {\n        auto memberLength = 1u;\n        auto size = WireAlignSizeofN<WGPUExtent3DTransfer>(memberLength);\n        ASSERT(size);\n        result += *size;\n        for (decltype(memberLength) i = 0; i < memberLength; ++i) {\n            result += WGPUExtent3DGetExtraRequiredSize(record.copySize[i]);\n        }\n    }\n    {\n        auto memberLength = 1u;\n        auto size = WireAlignSizeofN<WGPUCopyTextureForBrowserOptionsTransfer>(memberLength);\n        ASSERT(size);\n        result += *size;\n        for (decltype(memberLength) i = 0; i < memberLength; ++i) {\n            result += WGPUCopyTextureForBrowserOptionsGetExtraRequiredSize(record.options[i]);\n        }\n    }\n    return result;\n}\n// GetExtraRequiredSize isn't used for structures that are value members of other structures\n// because we assume they cannot contain pointers themselves.\nDAWN_UNUSED_FUNC(QueueCopyTextureForBrowserGetExtraRequiredSize);\n\nDAWN_DECLARE_UNUSED WireResult QueueCopyTextureForBrowserSerialize(\n    const QueueCopyTextureForBrowserCmd& record,\n    QueueCopyTextureForBrowserTransfer* transfer,\n    SerializeBuffer* buffer, const ObjectIdProvider& provider) {\n    DAWN_UNUSED(buffer);\n    transfer->commandId = WireCmd::QueueCopyTextureForBrowser;\n\n\n    WIRE_TRY(provider.GetId(record.self, &transfer->self));\n    {\n        auto memberLength = 1u;\n\n        WGPUImageCopyTextureTransfer* memberBuffer;\n        WIRE_TRY(buffer->NextN(memberLength, &memberBuffer));\n\n        for (decltype(memberLength) i = 0; i < memberLength; ++i) {\n            WIRE_TRY(WGPUImageCopyTextureSerialize(record.source[i], &memberBuffer[i], buffer, provider));\n        }\n    }\n    {\n        auto memberLength = 1u;\n\n        WGPUImageCopyTextureTransfer* memberBuffer;\n        WIRE_TRY(buffer->NextN(memberLength, &memberBuffer));\n\n        for (decltype(memberLength) i = 0; i < memberLength; ++i) {\n            WIRE_TRY(WGPUImageCopyTextureSerialize(record.destination[i], &memberBuffer[i], buffer, provider));\n        }\n    }\n    {\n        auto memberLength = 1u;\n\n        WGPUExtent3DTransfer* memberBuffer;\n        WIRE_TRY(buffer->NextN(memberLength, &memberBuffer));\n\n        memcpy(\n            memberBuffer, record.copySize,\n            sizeof(WGPUExtent3DTransfer) * memberLength);\n    }\n    {\n        auto memberLength = 1u;\n\n        WGPUCopyTextureForBrowserOptionsTransfer* memberBuffer;\n        WIRE_TRY(buffer->NextN(memberLength, &memberBuffer));\n\n        for (decltype(memberLength) i = 0; i < memberLength; ++i) {\n            WIRE_TRY(WGPUCopyTextureForBrowserOptionsSerialize(record.options[i], &memberBuffer[i], buffer, provider));\n        }\n    }\n\n    return WireResult::Success;\n}\nDAWN_UNUSED_FUNC(QueueCopyTextureForBrowserSerialize);\n\nDAWN_DECLARE_UNUSED WireResult QueueCopyTextureForBrowserDeserialize(\n    QueueCopyTextureForBrowserCmd* record,\n    const volatile QueueCopyTextureForBrowserTransfer* transfer,\n    DeserializeBuffer* deserializeBuffer,\n    DeserializeAllocator* allocator, const ObjectIdResolver& resolver) {\n    DAWN_UNUSED(allocator);\n\n    ASSERT(transfer->commandId == WireCmd::QueueCopyTextureForBrowser);\n    record->selfId = transfer->self;\n\n\n    WIRE_TRY(resolver.GetFromId(transfer->self, &record->self));\n    {\n        auto memberLength = 1u;\n        const volatile WGPUImageCopyTextureTransfer* memberBuffer;\n        WIRE_TRY(deserializeBuffer->ReadN(memberLength, &memberBuffer));\n\n        WGPUImageCopyTexture* copiedMembers;\n        WIRE_TRY(GetSpace(allocator, memberLength, &copiedMembers));\n        record->source = copiedMembers;\n\n        for (decltype(memberLength) i = 0; i < memberLength; ++i) {\n            WIRE_TRY(WGPUImageCopyTextureDeserialize(&copiedMembers[i], &memberBuffer[i], deserializeBuffer, allocator, resolver));\n        }\n    }\n    {\n        auto memberLength = 1u;\n        const volatile WGPUImageCopyTextureTransfer* memberBuffer;\n        WIRE_TRY(deserializeBuffer->ReadN(memberLength, &memberBuffer));\n\n        WGPUImageCopyTexture* copiedMembers;\n        WIRE_TRY(GetSpace(allocator, memberLength, &copiedMembers));\n        record->destination = copiedMembers;\n\n        for (decltype(memberLength) i = 0; i < memberLength; ++i) {\n            WIRE_TRY(WGPUImageCopyTextureDeserialize(&copiedMembers[i], &memberBuffer[i], deserializeBuffer, allocator, resolver));\n        }\n    }\n    {\n        auto memberLength = 1u;\n        const volatile WGPUExtent3DTransfer* memberBuffer;\n        WIRE_TRY(deserializeBuffer->ReadN(memberLength, &memberBuffer));\n\n        WGPUExtent3D* copiedMembers;\n        WIRE_TRY(GetSpace(allocator, memberLength, &copiedMembers));\n        record->copySize = copiedMembers;\n\n        memcpy(\n            copiedMembers,\n            const_cast<const WGPUExtent3DTransfer*>(memberBuffer),\n           sizeof(WGPUExtent3DTransfer) * memberLength);\n    }\n    {\n        auto memberLength = 1u;\n        const volatile WGPUCopyTextureForBrowserOptionsTransfer* memberBuffer;\n        WIRE_TRY(deserializeBuffer->ReadN(memberLength, &memberBuffer));\n\n        WGPUCopyTextureForBrowserOptions* copiedMembers;\n        WIRE_TRY(GetSpace(allocator, memberLength, &copiedMembers));\n        record->options = copiedMembers;\n\n        for (decltype(memberLength) i = 0; i < memberLength; ++i) {\n            WIRE_TRY(WGPUCopyTextureForBrowserOptionsDeserialize(&copiedMembers[i], &memberBuffer[i], deserializeBuffer, allocator, resolver));\n        }\n    }\n\n    return WireResult::Success;\n}\nDAWN_UNUSED_FUNC(QueueCopyTextureForBrowserDeserialize);\n\nstruct QueueOnSubmittedWorkDoneTransfer : CmdHeader {\n    static_assert(1 <= 1,\n                  \"Record must be at most one of is_cmd, extensible, and chained.\");\n    WireCmd commandId;\n\n    ObjectId queueId;\n    uint64_t signalValue;\n    uint64_t requestSerial;\n};\n\nstatic_assert(offsetof(QueueOnSubmittedWorkDoneTransfer, commandSize) == 0);\nstatic_assert(offsetof(QueueOnSubmittedWorkDoneTransfer, commandId) == sizeof(CmdHeader));\n\nDAWN_DECLARE_UNUSED size_t QueueOnSubmittedWorkDoneGetExtraRequiredSize(const QueueOnSubmittedWorkDoneCmd& record) {\n    DAWN_UNUSED(record);\n    size_t result = 0;\n\n    return result;\n}\n// GetExtraRequiredSize isn't used for structures that are value members of other structures\n// because we assume they cannot contain pointers themselves.\nDAWN_UNUSED_FUNC(QueueOnSubmittedWorkDoneGetExtraRequiredSize);\n\nDAWN_DECLARE_UNUSED WireResult QueueOnSubmittedWorkDoneSerialize(\n    const QueueOnSubmittedWorkDoneCmd& record,\n    QueueOnSubmittedWorkDoneTransfer* transfer,\n    SerializeBuffer* buffer) {\n    DAWN_UNUSED(buffer);\n    transfer->commandId = WireCmd::QueueOnSubmittedWorkDone;\n\n\n    transfer->queueId = record.queueId;\n    transfer->signalValue = record.signalValue;\n    transfer->requestSerial = record.requestSerial;\n\n    return WireResult::Success;\n}\nDAWN_UNUSED_FUNC(QueueOnSubmittedWorkDoneSerialize);\n\nDAWN_DECLARE_UNUSED WireResult QueueOnSubmittedWorkDoneDeserialize(\n    QueueOnSubmittedWorkDoneCmd* record,\n    const volatile QueueOnSubmittedWorkDoneTransfer* transfer,\n    DeserializeBuffer* deserializeBuffer,\n    DeserializeAllocator* allocator) {\n    DAWN_UNUSED(allocator);\n\n    ASSERT(transfer->commandId == WireCmd::QueueOnSubmittedWorkDone);\n\n\n    static_assert(sizeof(record->queueId) >= sizeof(transfer->queueId), \"Deserialize assignment may not narrow.\");\n    record->queueId = transfer->queueId;\n    static_assert(sizeof(record->signalValue) >= sizeof(transfer->signalValue), \"Deserialize assignment may not narrow.\");\n    record->signalValue = transfer->signalValue;\n    static_assert(sizeof(record->requestSerial) >= sizeof(transfer->requestSerial), \"Deserialize assignment may not narrow.\");\n    record->requestSerial = transfer->requestSerial;\n\n    return WireResult::Success;\n}\nDAWN_UNUSED_FUNC(QueueOnSubmittedWorkDoneDeserialize);\n\nstruct QueueSetLabelTransfer : CmdHeader {\n    static_assert(1 <= 1,\n                  \"Record must be at most one of is_cmd, extensible, and chained.\");\n    WireCmd commandId;\n\n    ObjectId self;\n    uint64_t labelStrlen;\n};\n\nstatic_assert(offsetof(QueueSetLabelTransfer, commandSize) == 0);\nstatic_assert(offsetof(QueueSetLabelTransfer, commandId) == sizeof(CmdHeader));\n\nDAWN_DECLARE_UNUSED size_t QueueSetLabelGetExtraRequiredSize(const QueueSetLabelCmd& record) {\n    DAWN_UNUSED(record);\n    size_t result = 0;\n\n    ASSERT(record.label != nullptr);\n    result += Align(std::strlen(record.label), kWireBufferAlignment);\n    return result;\n}\n// GetExtraRequiredSize isn't used for structures that are value members of other structures\n// because we assume they cannot contain pointers themselves.\nDAWN_UNUSED_FUNC(QueueSetLabelGetExtraRequiredSize);\n\nDAWN_DECLARE_UNUSED WireResult QueueSetLabelSerialize(\n    const QueueSetLabelCmd& record,\n    QueueSetLabelTransfer* transfer,\n    SerializeBuffer* buffer, const ObjectIdProvider& provider) {\n    DAWN_UNUSED(buffer);\n    transfer->commandId = WireCmd::QueueSetLabel;\n\n\n    WIRE_TRY(provider.GetId(record.self, &transfer->self));\n    {\n        transfer->labelStrlen = std::strlen(record.label);\n\n        char* stringInBuffer;\n        WIRE_TRY(buffer->NextN(transfer->labelStrlen, &stringInBuffer));\n        memcpy(stringInBuffer, record.label, transfer->labelStrlen);\n    }\n\n    return WireResult::Success;\n}\nDAWN_UNUSED_FUNC(QueueSetLabelSerialize);\n\nDAWN_DECLARE_UNUSED WireResult QueueSetLabelDeserialize(\n    QueueSetLabelCmd* record,\n    const volatile QueueSetLabelTransfer* transfer,\n    DeserializeBuffer* deserializeBuffer,\n    DeserializeAllocator* allocator, const ObjectIdResolver& resolver) {\n    DAWN_UNUSED(allocator);\n\n    ASSERT(transfer->commandId == WireCmd::QueueSetLabel);\n    record->selfId = transfer->self;\n\n\n    WIRE_TRY(resolver.GetFromId(transfer->self, &record->self));\n    {\n        uint64_t stringLength64 = transfer->labelStrlen;\n        if (stringLength64 >= std::numeric_limits<size_t>::max()) {\n            return WireResult::FatalError;\n        }\n        size_t stringLength = static_cast<size_t>(stringLength64);\n\n        const volatile char* stringInBuffer;\n        WIRE_TRY(deserializeBuffer->ReadN(stringLength, &stringInBuffer));\n\n        char* copiedString;\n        WIRE_TRY(GetSpace(allocator, stringLength + 1, &copiedString));\n        memcpy(copiedString, const_cast<const char*>(stringInBuffer), stringLength);\n        copiedString[stringLength] = '\\0';\n        record->label = copiedString;\n    }\n\n    return WireResult::Success;\n}\nDAWN_UNUSED_FUNC(QueueSetLabelDeserialize);\n\nstruct QueueSubmitTransfer : CmdHeader {\n    static_assert(1 <= 1,\n                  \"Record must be at most one of is_cmd, extensible, and chained.\");\n    WireCmd commandId;\n\n    ObjectId self;\n    uint64_t commandCount;\n};\n\nstatic_assert(offsetof(QueueSubmitTransfer, commandSize) == 0);\nstatic_assert(offsetof(QueueSubmitTransfer, commandId) == sizeof(CmdHeader));\n\nDAWN_DECLARE_UNUSED size_t QueueSubmitGetExtraRequiredSize(const QueueSubmitCmd& record) {\n    DAWN_UNUSED(record);\n    size_t result = 0;\n\n    {\n        auto memberLength = record.commandCount;\n        auto size = WireAlignSizeofN<ObjectId>(memberLength);\n        ASSERT(size);\n        result += *size;\n    }\n    return result;\n}\n// GetExtraRequiredSize isn't used for structures that are value members of other structures\n// because we assume they cannot contain pointers themselves.\nDAWN_UNUSED_FUNC(QueueSubmitGetExtraRequiredSize);\n\nDAWN_DECLARE_UNUSED WireResult QueueSubmitSerialize(\n    const QueueSubmitCmd& record,\n    QueueSubmitTransfer* transfer,\n    SerializeBuffer* buffer, const ObjectIdProvider& provider) {\n    DAWN_UNUSED(buffer);\n    transfer->commandId = WireCmd::QueueSubmit;\n\n\n    WIRE_TRY(provider.GetId(record.self, &transfer->self));\n    transfer->commandCount = record.commandCount;\n    {\n        auto memberLength = record.commandCount;\n\n        ObjectId* memberBuffer;\n        WIRE_TRY(buffer->NextN(memberLength, &memberBuffer));\n\n        for (decltype(memberLength) i = 0; i < memberLength; ++i) {\n            WIRE_TRY(provider.GetId(record.commands[i], &memberBuffer[i]));\n        }\n    }\n\n    return WireResult::Success;\n}\nDAWN_UNUSED_FUNC(QueueSubmitSerialize);\n\nDAWN_DECLARE_UNUSED WireResult QueueSubmitDeserialize(\n    QueueSubmitCmd* record,\n    const volatile QueueSubmitTransfer* transfer,\n    DeserializeBuffer* deserializeBuffer,\n    DeserializeAllocator* allocator, const ObjectIdResolver& resolver) {\n    DAWN_UNUSED(allocator);\n\n    ASSERT(transfer->commandId == WireCmd::QueueSubmit);\n    record->selfId = transfer->self;\n\n\n    WIRE_TRY(resolver.GetFromId(transfer->self, &record->self));\n    if (transfer->commandCount > std::numeric_limits<size_t>::max()) return WireResult::FatalError;\n    record->commandCount = checked_cast<size_t>(transfer->commandCount);\n    {\n        auto memberLength = record->commandCount;\n        const volatile ObjectId* memberBuffer;\n        WIRE_TRY(deserializeBuffer->ReadN(memberLength, &memberBuffer));\n\n        WGPUCommandBuffer* copiedMembers;\n        WIRE_TRY(GetSpace(allocator, memberLength, &copiedMembers));\n        record->commands = copiedMembers;\n\n        for (decltype(memberLength) i = 0; i < memberLength; ++i) {\n            WIRE_TRY(resolver.GetFromId(memberBuffer[i], &copiedMembers[i]));\n        }\n    }\n\n    return WireResult::Success;\n}\nDAWN_UNUSED_FUNC(QueueSubmitDeserialize);\n\nstruct QueueWriteBufferTransfer : CmdHeader {\n    static_assert(1 <= 1,\n                  \"Record must be at most one of is_cmd, extensible, and chained.\");\n    WireCmd commandId;\n\n    ObjectId queueId;\n    ObjectId bufferId;\n    uint64_t bufferOffset;\n    uint64_t size;\n};\n\nstatic_assert(offsetof(QueueWriteBufferTransfer, commandSize) == 0);\nstatic_assert(offsetof(QueueWriteBufferTransfer, commandId) == sizeof(CmdHeader));\n\nDAWN_DECLARE_UNUSED size_t QueueWriteBufferGetExtraRequiredSize(const QueueWriteBufferCmd& record) {\n    DAWN_UNUSED(record);\n    size_t result = 0;\n\n    {\n        auto memberLength = record.size;\n        auto size = WireAlignSizeofN<uint8_t>(memberLength);\n        ASSERT(size);\n        result += *size;\n    }\n    return result;\n}\n// GetExtraRequiredSize isn't used for structures that are value members of other structures\n// because we assume they cannot contain pointers themselves.\nDAWN_UNUSED_FUNC(QueueWriteBufferGetExtraRequiredSize);\n\nDAWN_DECLARE_UNUSED WireResult QueueWriteBufferSerialize(\n    const QueueWriteBufferCmd& record,\n    QueueWriteBufferTransfer* transfer,\n    SerializeBuffer* buffer) {\n    DAWN_UNUSED(buffer);\n    transfer->commandId = WireCmd::QueueWriteBuffer;\n\n\n    transfer->queueId = record.queueId;\n    transfer->bufferId = record.bufferId;\n    transfer->bufferOffset = record.bufferOffset;\n    transfer->size = record.size;\n    {\n        auto memberLength = record.size;\n\n        uint8_t* memberBuffer;\n        WIRE_TRY(buffer->NextN(memberLength, &memberBuffer));\n\n        memcpy(\n            memberBuffer, record.data,\n            sizeof(uint8_t) * memberLength);\n    }\n\n    return WireResult::Success;\n}\nDAWN_UNUSED_FUNC(QueueWriteBufferSerialize);\n\nDAWN_DECLARE_UNUSED WireResult QueueWriteBufferDeserialize(\n    QueueWriteBufferCmd* record,\n    const volatile QueueWriteBufferTransfer* transfer,\n    DeserializeBuffer* deserializeBuffer,\n    DeserializeAllocator* allocator) {\n    DAWN_UNUSED(allocator);\n\n    ASSERT(transfer->commandId == WireCmd::QueueWriteBuffer);\n\n\n    static_assert(sizeof(record->queueId) >= sizeof(transfer->queueId), \"Deserialize assignment may not narrow.\");\n    record->queueId = transfer->queueId;\n    static_assert(sizeof(record->bufferId) >= sizeof(transfer->bufferId), \"Deserialize assignment may not narrow.\");\n    record->bufferId = transfer->bufferId;\n    static_assert(sizeof(record->bufferOffset) >= sizeof(transfer->bufferOffset), \"Deserialize assignment may not narrow.\");\n    record->bufferOffset = transfer->bufferOffset;\n    static_assert(sizeof(record->size) >= sizeof(transfer->size), \"Deserialize assignment may not narrow.\");\n    record->size = transfer->size;\n    {\n        auto memberLength = record->size;\n        const volatile uint8_t* memberBuffer;\n        WIRE_TRY(deserializeBuffer->ReadN(memberLength, &memberBuffer));\n\n        record->data =\n            const_cast<const uint8_t*>(memberBuffer);\n\n    }\n\n    return WireResult::Success;\n}\nDAWN_UNUSED_FUNC(QueueWriteBufferDeserialize);\n\nstruct QueueWriteTextureTransfer : CmdHeader {\n    static_assert(1 <= 1,\n                  \"Record must be at most one of is_cmd, extensible, and chained.\");\n    WireCmd commandId;\n\n    ObjectId queueId;\n    uint64_t dataSize;\n};\n\nstatic_assert(offsetof(QueueWriteTextureTransfer, commandSize) == 0);\nstatic_assert(offsetof(QueueWriteTextureTransfer, commandId) == sizeof(CmdHeader));\n\nDAWN_DECLARE_UNUSED size_t QueueWriteTextureGetExtraRequiredSize(const QueueWriteTextureCmd& record) {\n    DAWN_UNUSED(record);\n    size_t result = 0;\n\n    {\n        auto memberLength = 1u;\n        auto size = WireAlignSizeofN<WGPUImageCopyTextureTransfer>(memberLength);\n        ASSERT(size);\n        result += *size;\n        for (decltype(memberLength) i = 0; i < memberLength; ++i) {\n            result += WGPUImageCopyTextureGetExtraRequiredSize(record.destination[i]);\n        }\n    }\n    {\n        auto memberLength = record.dataSize;\n        auto size = WireAlignSizeofN<uint8_t>(memberLength);\n        ASSERT(size);\n        result += *size;\n    }\n    {\n        auto memberLength = 1u;\n        auto size = WireAlignSizeofN<WGPUTextureDataLayoutTransfer>(memberLength);\n        ASSERT(size);\n        result += *size;\n        for (decltype(memberLength) i = 0; i < memberLength; ++i) {\n            result += WGPUTextureDataLayoutGetExtraRequiredSize(record.dataLayout[i]);\n        }\n    }\n    {\n        auto memberLength = 1u;\n        auto size = WireAlignSizeofN<WGPUExtent3DTransfer>(memberLength);\n        ASSERT(size);\n        result += *size;\n        for (decltype(memberLength) i = 0; i < memberLength; ++i) {\n            result += WGPUExtent3DGetExtraRequiredSize(record.writeSize[i]);\n        }\n    }\n    return result;\n}\n// GetExtraRequiredSize isn't used for structures that are value members of other structures\n// because we assume they cannot contain pointers themselves.\nDAWN_UNUSED_FUNC(QueueWriteTextureGetExtraRequiredSize);\n\nDAWN_DECLARE_UNUSED WireResult QueueWriteTextureSerialize(\n    const QueueWriteTextureCmd& record,\n    QueueWriteTextureTransfer* transfer,\n    SerializeBuffer* buffer, const ObjectIdProvider& provider) {\n    DAWN_UNUSED(buffer);\n    transfer->commandId = WireCmd::QueueWriteTexture;\n\n\n    transfer->queueId = record.queueId;\n    transfer->dataSize = record.dataSize;\n    {\n        auto memberLength = 1u;\n\n        WGPUImageCopyTextureTransfer* memberBuffer;\n        WIRE_TRY(buffer->NextN(memberLength, &memberBuffer));\n\n        for (decltype(memberLength) i = 0; i < memberLength; ++i) {\n            WIRE_TRY(WGPUImageCopyTextureSerialize(record.destination[i], &memberBuffer[i], buffer, provider));\n        }\n    }\n    {\n        auto memberLength = record.dataSize;\n\n        uint8_t* memberBuffer;\n        WIRE_TRY(buffer->NextN(memberLength, &memberBuffer));\n\n        memcpy(\n            memberBuffer, record.data,\n            sizeof(uint8_t) * memberLength);\n    }\n    {\n        auto memberLength = 1u;\n\n        WGPUTextureDataLayoutTransfer* memberBuffer;\n        WIRE_TRY(buffer->NextN(memberLength, &memberBuffer));\n\n        for (decltype(memberLength) i = 0; i < memberLength; ++i) {\n            WIRE_TRY(WGPUTextureDataLayoutSerialize(record.dataLayout[i], &memberBuffer[i], buffer, provider));\n        }\n    }\n    {\n        auto memberLength = 1u;\n\n        WGPUExtent3DTransfer* memberBuffer;\n        WIRE_TRY(buffer->NextN(memberLength, &memberBuffer));\n\n        memcpy(\n            memberBuffer, record.writeSize,\n            sizeof(WGPUExtent3DTransfer) * memberLength);\n    }\n\n    return WireResult::Success;\n}\nDAWN_UNUSED_FUNC(QueueWriteTextureSerialize);\n\nDAWN_DECLARE_UNUSED WireResult QueueWriteTextureDeserialize(\n    QueueWriteTextureCmd* record,\n    const volatile QueueWriteTextureTransfer* transfer,\n    DeserializeBuffer* deserializeBuffer,\n    DeserializeAllocator* allocator, const ObjectIdResolver& resolver) {\n    DAWN_UNUSED(allocator);\n\n    ASSERT(transfer->commandId == WireCmd::QueueWriteTexture);\n\n\n    static_assert(sizeof(record->queueId) >= sizeof(transfer->queueId), \"Deserialize assignment may not narrow.\");\n    record->queueId = transfer->queueId;\n    static_assert(sizeof(record->dataSize) >= sizeof(transfer->dataSize), \"Deserialize assignment may not narrow.\");\n    record->dataSize = transfer->dataSize;\n    {\n        auto memberLength = 1u;\n        const volatile WGPUImageCopyTextureTransfer* memberBuffer;\n        WIRE_TRY(deserializeBuffer->ReadN(memberLength, &memberBuffer));\n\n        WGPUImageCopyTexture* copiedMembers;\n        WIRE_TRY(GetSpace(allocator, memberLength, &copiedMembers));\n        record->destination = copiedMembers;\n\n        for (decltype(memberLength) i = 0; i < memberLength; ++i) {\n            WIRE_TRY(WGPUImageCopyTextureDeserialize(&copiedMembers[i], &memberBuffer[i], deserializeBuffer, allocator, resolver));\n        }\n    }\n    {\n        auto memberLength = record->dataSize;\n        const volatile uint8_t* memberBuffer;\n        WIRE_TRY(deserializeBuffer->ReadN(memberLength, &memberBuffer));\n\n        record->data =\n            const_cast<const uint8_t*>(memberBuffer);\n\n    }\n    {\n        auto memberLength = 1u;\n        const volatile WGPUTextureDataLayoutTransfer* memberBuffer;\n        WIRE_TRY(deserializeBuffer->ReadN(memberLength, &memberBuffer));\n\n        WGPUTextureDataLayout* copiedMembers;\n        WIRE_TRY(GetSpace(allocator, memberLength, &copiedMembers));\n        record->dataLayout = copiedMembers;\n\n        for (decltype(memberLength) i = 0; i < memberLength; ++i) {\n            WIRE_TRY(WGPUTextureDataLayoutDeserialize(&copiedMembers[i], &memberBuffer[i], deserializeBuffer, allocator, resolver));\n        }\n    }\n    {\n        auto memberLength = 1u;\n        const volatile WGPUExtent3DTransfer* memberBuffer;\n        WIRE_TRY(deserializeBuffer->ReadN(memberLength, &memberBuffer));\n\n        WGPUExtent3D* copiedMembers;\n        WIRE_TRY(GetSpace(allocator, memberLength, &copiedMembers));\n        record->writeSize = copiedMembers;\n\n        memcpy(\n            copiedMembers,\n            const_cast<const WGPUExtent3DTransfer*>(memberBuffer),\n           sizeof(WGPUExtent3DTransfer) * memberLength);\n    }\n\n    return WireResult::Success;\n}\nDAWN_UNUSED_FUNC(QueueWriteTextureDeserialize);\n\nstruct RenderBundleEncoderDrawTransfer : CmdHeader {\n    static_assert(1 <= 1,\n                  \"Record must be at most one of is_cmd, extensible, and chained.\");\n    WireCmd commandId;\n\n    ObjectId self;\n    uint32_t vertexCount;\n    uint32_t instanceCount;\n    uint32_t firstVertex;\n    uint32_t firstInstance;\n};\n\nstatic_assert(offsetof(RenderBundleEncoderDrawTransfer, commandSize) == 0);\nstatic_assert(offsetof(RenderBundleEncoderDrawTransfer, commandId) == sizeof(CmdHeader));\n\nDAWN_DECLARE_UNUSED size_t RenderBundleEncoderDrawGetExtraRequiredSize(const RenderBundleEncoderDrawCmd& record) {\n    DAWN_UNUSED(record);\n    size_t result = 0;\n\n    return result;\n}\n// GetExtraRequiredSize isn't used for structures that are value members of other structures\n// because we assume they cannot contain pointers themselves.\nDAWN_UNUSED_FUNC(RenderBundleEncoderDrawGetExtraRequiredSize);\n\nDAWN_DECLARE_UNUSED WireResult RenderBundleEncoderDrawSerialize(\n    const RenderBundleEncoderDrawCmd& record,\n    RenderBundleEncoderDrawTransfer* transfer,\n    SerializeBuffer* buffer, const ObjectIdProvider& provider) {\n    DAWN_UNUSED(buffer);\n    transfer->commandId = WireCmd::RenderBundleEncoderDraw;\n\n\n    WIRE_TRY(provider.GetId(record.self, &transfer->self));\n    transfer->vertexCount = record.vertexCount;\n    transfer->instanceCount = record.instanceCount;\n    transfer->firstVertex = record.firstVertex;\n    transfer->firstInstance = record.firstInstance;\n\n    return WireResult::Success;\n}\nDAWN_UNUSED_FUNC(RenderBundleEncoderDrawSerialize);\n\nDAWN_DECLARE_UNUSED WireResult RenderBundleEncoderDrawDeserialize(\n    RenderBundleEncoderDrawCmd* record,\n    const volatile RenderBundleEncoderDrawTransfer* transfer,\n    DeserializeBuffer* deserializeBuffer,\n    DeserializeAllocator* allocator, const ObjectIdResolver& resolver) {\n    DAWN_UNUSED(allocator);\n\n    ASSERT(transfer->commandId == WireCmd::RenderBundleEncoderDraw);\n    record->selfId = transfer->self;\n\n\n    WIRE_TRY(resolver.GetFromId(transfer->self, &record->self));\n    static_assert(sizeof(record->vertexCount) >= sizeof(transfer->vertexCount), \"Deserialize assignment may not narrow.\");\n    record->vertexCount = transfer->vertexCount;\n    static_assert(sizeof(record->instanceCount) >= sizeof(transfer->instanceCount), \"Deserialize assignment may not narrow.\");\n    record->instanceCount = transfer->instanceCount;\n    static_assert(sizeof(record->firstVertex) >= sizeof(transfer->firstVertex), \"Deserialize assignment may not narrow.\");\n    record->firstVertex = transfer->firstVertex;\n    static_assert(sizeof(record->firstInstance) >= sizeof(transfer->firstInstance), \"Deserialize assignment may not narrow.\");\n    record->firstInstance = transfer->firstInstance;\n\n    return WireResult::Success;\n}\nDAWN_UNUSED_FUNC(RenderBundleEncoderDrawDeserialize);\n\nstruct RenderBundleEncoderDrawIndexedTransfer : CmdHeader {\n    static_assert(1 <= 1,\n                  \"Record must be at most one of is_cmd, extensible, and chained.\");\n    WireCmd commandId;\n\n    ObjectId self;\n    uint32_t indexCount;\n    uint32_t instanceCount;\n    uint32_t firstIndex;\n    int32_t baseVertex;\n    uint32_t firstInstance;\n};\n\nstatic_assert(offsetof(RenderBundleEncoderDrawIndexedTransfer, commandSize) == 0);\nstatic_assert(offsetof(RenderBundleEncoderDrawIndexedTransfer, commandId) == sizeof(CmdHeader));\n\nDAWN_DECLARE_UNUSED size_t RenderBundleEncoderDrawIndexedGetExtraRequiredSize(const RenderBundleEncoderDrawIndexedCmd& record) {\n    DAWN_UNUSED(record);\n    size_t result = 0;\n\n    return result;\n}\n// GetExtraRequiredSize isn't used for structures that are value members of other structures\n// because we assume they cannot contain pointers themselves.\nDAWN_UNUSED_FUNC(RenderBundleEncoderDrawIndexedGetExtraRequiredSize);\n\nDAWN_DECLARE_UNUSED WireResult RenderBundleEncoderDrawIndexedSerialize(\n    const RenderBundleEncoderDrawIndexedCmd& record,\n    RenderBundleEncoderDrawIndexedTransfer* transfer,\n    SerializeBuffer* buffer, const ObjectIdProvider& provider) {\n    DAWN_UNUSED(buffer);\n    transfer->commandId = WireCmd::RenderBundleEncoderDrawIndexed;\n\n\n    WIRE_TRY(provider.GetId(record.self, &transfer->self));\n    transfer->indexCount = record.indexCount;\n    transfer->instanceCount = record.instanceCount;\n    transfer->firstIndex = record.firstIndex;\n    transfer->baseVertex = record.baseVertex;\n    transfer->firstInstance = record.firstInstance;\n\n    return WireResult::Success;\n}\nDAWN_UNUSED_FUNC(RenderBundleEncoderDrawIndexedSerialize);\n\nDAWN_DECLARE_UNUSED WireResult RenderBundleEncoderDrawIndexedDeserialize(\n    RenderBundleEncoderDrawIndexedCmd* record,\n    const volatile RenderBundleEncoderDrawIndexedTransfer* transfer,\n    DeserializeBuffer* deserializeBuffer,\n    DeserializeAllocator* allocator, const ObjectIdResolver& resolver) {\n    DAWN_UNUSED(allocator);\n\n    ASSERT(transfer->commandId == WireCmd::RenderBundleEncoderDrawIndexed);\n    record->selfId = transfer->self;\n\n\n    WIRE_TRY(resolver.GetFromId(transfer->self, &record->self));\n    static_assert(sizeof(record->indexCount) >= sizeof(transfer->indexCount), \"Deserialize assignment may not narrow.\");\n    record->indexCount = transfer->indexCount;\n    static_assert(sizeof(record->instanceCount) >= sizeof(transfer->instanceCount), \"Deserialize assignment may not narrow.\");\n    record->instanceCount = transfer->instanceCount;\n    static_assert(sizeof(record->firstIndex) >= sizeof(transfer->firstIndex), \"Deserialize assignment may not narrow.\");\n    record->firstIndex = transfer->firstIndex;\n    static_assert(sizeof(record->baseVertex) >= sizeof(transfer->baseVertex), \"Deserialize assignment may not narrow.\");\n    record->baseVertex = transfer->baseVertex;\n    static_assert(sizeof(record->firstInstance) >= sizeof(transfer->firstInstance), \"Deserialize assignment may not narrow.\");\n    record->firstInstance = transfer->firstInstance;\n\n    return WireResult::Success;\n}\nDAWN_UNUSED_FUNC(RenderBundleEncoderDrawIndexedDeserialize);\n\nstruct RenderBundleEncoderDrawIndexedIndirectTransfer : CmdHeader {\n    static_assert(1 <= 1,\n                  \"Record must be at most one of is_cmd, extensible, and chained.\");\n    WireCmd commandId;\n\n    ObjectId self;\n    ObjectId indirectBuffer;\n    uint64_t indirectOffset;\n};\n\nstatic_assert(offsetof(RenderBundleEncoderDrawIndexedIndirectTransfer, commandSize) == 0);\nstatic_assert(offsetof(RenderBundleEncoderDrawIndexedIndirectTransfer, commandId) == sizeof(CmdHeader));\n\nDAWN_DECLARE_UNUSED size_t RenderBundleEncoderDrawIndexedIndirectGetExtraRequiredSize(const RenderBundleEncoderDrawIndexedIndirectCmd& record) {\n    DAWN_UNUSED(record);\n    size_t result = 0;\n\n    return result;\n}\n// GetExtraRequiredSize isn't used for structures that are value members of other structures\n// because we assume they cannot contain pointers themselves.\nDAWN_UNUSED_FUNC(RenderBundleEncoderDrawIndexedIndirectGetExtraRequiredSize);\n\nDAWN_DECLARE_UNUSED WireResult RenderBundleEncoderDrawIndexedIndirectSerialize(\n    const RenderBundleEncoderDrawIndexedIndirectCmd& record,\n    RenderBundleEncoderDrawIndexedIndirectTransfer* transfer,\n    SerializeBuffer* buffer, const ObjectIdProvider& provider) {\n    DAWN_UNUSED(buffer);\n    transfer->commandId = WireCmd::RenderBundleEncoderDrawIndexedIndirect;\n\n\n    WIRE_TRY(provider.GetId(record.self, &transfer->self));\n    WIRE_TRY(provider.GetId(record.indirectBuffer, &transfer->indirectBuffer));\n    transfer->indirectOffset = record.indirectOffset;\n\n    return WireResult::Success;\n}\nDAWN_UNUSED_FUNC(RenderBundleEncoderDrawIndexedIndirectSerialize);\n\nDAWN_DECLARE_UNUSED WireResult RenderBundleEncoderDrawIndexedIndirectDeserialize(\n    RenderBundleEncoderDrawIndexedIndirectCmd* record,\n    const volatile RenderBundleEncoderDrawIndexedIndirectTransfer* transfer,\n    DeserializeBuffer* deserializeBuffer,\n    DeserializeAllocator* allocator, const ObjectIdResolver& resolver) {\n    DAWN_UNUSED(allocator);\n\n    ASSERT(transfer->commandId == WireCmd::RenderBundleEncoderDrawIndexedIndirect);\n    record->selfId = transfer->self;\n\n\n    WIRE_TRY(resolver.GetFromId(transfer->self, &record->self));\n    WIRE_TRY(resolver.GetFromId(transfer->indirectBuffer, &record->indirectBuffer));\n    static_assert(sizeof(record->indirectOffset) >= sizeof(transfer->indirectOffset), \"Deserialize assignment may not narrow.\");\n    record->indirectOffset = transfer->indirectOffset;\n\n    return WireResult::Success;\n}\nDAWN_UNUSED_FUNC(RenderBundleEncoderDrawIndexedIndirectDeserialize);\n\nstruct RenderBundleEncoderDrawIndirectTransfer : CmdHeader {\n    static_assert(1 <= 1,\n                  \"Record must be at most one of is_cmd, extensible, and chained.\");\n    WireCmd commandId;\n\n    ObjectId self;\n    ObjectId indirectBuffer;\n    uint64_t indirectOffset;\n};\n\nstatic_assert(offsetof(RenderBundleEncoderDrawIndirectTransfer, commandSize) == 0);\nstatic_assert(offsetof(RenderBundleEncoderDrawIndirectTransfer, commandId) == sizeof(CmdHeader));\n\nDAWN_DECLARE_UNUSED size_t RenderBundleEncoderDrawIndirectGetExtraRequiredSize(const RenderBundleEncoderDrawIndirectCmd& record) {\n    DAWN_UNUSED(record);\n    size_t result = 0;\n\n    return result;\n}\n// GetExtraRequiredSize isn't used for structures that are value members of other structures\n// because we assume they cannot contain pointers themselves.\nDAWN_UNUSED_FUNC(RenderBundleEncoderDrawIndirectGetExtraRequiredSize);\n\nDAWN_DECLARE_UNUSED WireResult RenderBundleEncoderDrawIndirectSerialize(\n    const RenderBundleEncoderDrawIndirectCmd& record,\n    RenderBundleEncoderDrawIndirectTransfer* transfer,\n    SerializeBuffer* buffer, const ObjectIdProvider& provider) {\n    DAWN_UNUSED(buffer);\n    transfer->commandId = WireCmd::RenderBundleEncoderDrawIndirect;\n\n\n    WIRE_TRY(provider.GetId(record.self, &transfer->self));\n    WIRE_TRY(provider.GetId(record.indirectBuffer, &transfer->indirectBuffer));\n    transfer->indirectOffset = record.indirectOffset;\n\n    return WireResult::Success;\n}\nDAWN_UNUSED_FUNC(RenderBundleEncoderDrawIndirectSerialize);\n\nDAWN_DECLARE_UNUSED WireResult RenderBundleEncoderDrawIndirectDeserialize(\n    RenderBundleEncoderDrawIndirectCmd* record,\n    const volatile RenderBundleEncoderDrawIndirectTransfer* transfer,\n    DeserializeBuffer* deserializeBuffer,\n    DeserializeAllocator* allocator, const ObjectIdResolver& resolver) {\n    DAWN_UNUSED(allocator);\n\n    ASSERT(transfer->commandId == WireCmd::RenderBundleEncoderDrawIndirect);\n    record->selfId = transfer->self;\n\n\n    WIRE_TRY(resolver.GetFromId(transfer->self, &record->self));\n    WIRE_TRY(resolver.GetFromId(transfer->indirectBuffer, &record->indirectBuffer));\n    static_assert(sizeof(record->indirectOffset) >= sizeof(transfer->indirectOffset), \"Deserialize assignment may not narrow.\");\n    record->indirectOffset = transfer->indirectOffset;\n\n    return WireResult::Success;\n}\nDAWN_UNUSED_FUNC(RenderBundleEncoderDrawIndirectDeserialize);\n\nstruct RenderBundleEncoderFinishTransfer : CmdHeader {\n    static_assert(1 <= 1,\n                  \"Record must be at most one of is_cmd, extensible, and chained.\");\n    WireCmd commandId;\n\n    ObjectId self;\n    bool has_descriptor;\n    ObjectHandle result;\n};\n\nstatic_assert(offsetof(RenderBundleEncoderFinishTransfer, commandSize) == 0);\nstatic_assert(offsetof(RenderBundleEncoderFinishTransfer, commandId) == sizeof(CmdHeader));\n\nDAWN_DECLARE_UNUSED size_t RenderBundleEncoderFinishGetExtraRequiredSize(const RenderBundleEncoderFinishCmd& record) {\n    DAWN_UNUSED(record);\n    size_t result = 0;\n\n    if (record.descriptor != nullptr) {\n        auto memberLength = 1u;\n        auto size = WireAlignSizeofN<WGPURenderBundleDescriptorTransfer>(memberLength);\n        ASSERT(size);\n        result += *size;\n        for (decltype(memberLength) i = 0; i < memberLength; ++i) {\n            result += WGPURenderBundleDescriptorGetExtraRequiredSize(record.descriptor[i]);\n        }\n    }\n    return result;\n}\n// GetExtraRequiredSize isn't used for structures that are value members of other structures\n// because we assume they cannot contain pointers themselves.\nDAWN_UNUSED_FUNC(RenderBundleEncoderFinishGetExtraRequiredSize);\n\nDAWN_DECLARE_UNUSED WireResult RenderBundleEncoderFinishSerialize(\n    const RenderBundleEncoderFinishCmd& record,\n    RenderBundleEncoderFinishTransfer* transfer,\n    SerializeBuffer* buffer, const ObjectIdProvider& provider) {\n    DAWN_UNUSED(buffer);\n    transfer->commandId = WireCmd::RenderBundleEncoderFinish;\n\n\n    WIRE_TRY(provider.GetId(record.self, &transfer->self));\n    transfer->result = record.result;\n    bool has_descriptor = record.descriptor != nullptr;\n    transfer->has_descriptor = has_descriptor;\n    if (has_descriptor) {\n        auto memberLength = 1u;\n\n        WGPURenderBundleDescriptorTransfer* memberBuffer;\n        WIRE_TRY(buffer->NextN(memberLength, &memberBuffer));\n\n        for (decltype(memberLength) i = 0; i < memberLength; ++i) {\n            WIRE_TRY(WGPURenderBundleDescriptorSerialize(record.descriptor[i], &memberBuffer[i], buffer, provider));\n        }\n    }\n\n    return WireResult::Success;\n}\nDAWN_UNUSED_FUNC(RenderBundleEncoderFinishSerialize);\n\nDAWN_DECLARE_UNUSED WireResult RenderBundleEncoderFinishDeserialize(\n    RenderBundleEncoderFinishCmd* record,\n    const volatile RenderBundleEncoderFinishTransfer* transfer,\n    DeserializeBuffer* deserializeBuffer,\n    DeserializeAllocator* allocator, const ObjectIdResolver& resolver) {\n    DAWN_UNUSED(allocator);\n\n    ASSERT(transfer->commandId == WireCmd::RenderBundleEncoderFinish);\n    record->selfId = transfer->self;\n\n\n    WIRE_TRY(resolver.GetFromId(transfer->self, &record->self));\n    static_assert(sizeof(record->result) >= sizeof(transfer->result), \"Deserialize assignment may not narrow.\");\n    record->result = transfer->result;\n    bool has_descriptor = transfer->has_descriptor;\n    record->descriptor = nullptr;\n    if (has_descriptor) {\n        auto memberLength = 1u;\n        const volatile WGPURenderBundleDescriptorTransfer* memberBuffer;\n        WIRE_TRY(deserializeBuffer->ReadN(memberLength, &memberBuffer));\n\n        WGPURenderBundleDescriptor* copiedMembers;\n        WIRE_TRY(GetSpace(allocator, memberLength, &copiedMembers));\n        record->descriptor = copiedMembers;\n\n        for (decltype(memberLength) i = 0; i < memberLength; ++i) {\n            WIRE_TRY(WGPURenderBundleDescriptorDeserialize(&copiedMembers[i], &memberBuffer[i], deserializeBuffer, allocator, resolver));\n        }\n    }\n\n    return WireResult::Success;\n}\nDAWN_UNUSED_FUNC(RenderBundleEncoderFinishDeserialize);\n\nstruct RenderBundleEncoderInsertDebugMarkerTransfer : CmdHeader {\n    static_assert(1 <= 1,\n                  \"Record must be at most one of is_cmd, extensible, and chained.\");\n    WireCmd commandId;\n\n    ObjectId self;\n    uint64_t markerLabelStrlen;\n};\n\nstatic_assert(offsetof(RenderBundleEncoderInsertDebugMarkerTransfer, commandSize) == 0);\nstatic_assert(offsetof(RenderBundleEncoderInsertDebugMarkerTransfer, commandId) == sizeof(CmdHeader));\n\nDAWN_DECLARE_UNUSED size_t RenderBundleEncoderInsertDebugMarkerGetExtraRequiredSize(const RenderBundleEncoderInsertDebugMarkerCmd& record) {\n    DAWN_UNUSED(record);\n    size_t result = 0;\n\n    ASSERT(record.markerLabel != nullptr);\n    result += Align(std::strlen(record.markerLabel), kWireBufferAlignment);\n    return result;\n}\n// GetExtraRequiredSize isn't used for structures that are value members of other structures\n// because we assume they cannot contain pointers themselves.\nDAWN_UNUSED_FUNC(RenderBundleEncoderInsertDebugMarkerGetExtraRequiredSize);\n\nDAWN_DECLARE_UNUSED WireResult RenderBundleEncoderInsertDebugMarkerSerialize(\n    const RenderBundleEncoderInsertDebugMarkerCmd& record,\n    RenderBundleEncoderInsertDebugMarkerTransfer* transfer,\n    SerializeBuffer* buffer, const ObjectIdProvider& provider) {\n    DAWN_UNUSED(buffer);\n    transfer->commandId = WireCmd::RenderBundleEncoderInsertDebugMarker;\n\n\n    WIRE_TRY(provider.GetId(record.self, &transfer->self));\n    {\n        transfer->markerLabelStrlen = std::strlen(record.markerLabel);\n\n        char* stringInBuffer;\n        WIRE_TRY(buffer->NextN(transfer->markerLabelStrlen, &stringInBuffer));\n        memcpy(stringInBuffer, record.markerLabel, transfer->markerLabelStrlen);\n    }\n\n    return WireResult::Success;\n}\nDAWN_UNUSED_FUNC(RenderBundleEncoderInsertDebugMarkerSerialize);\n\nDAWN_DECLARE_UNUSED WireResult RenderBundleEncoderInsertDebugMarkerDeserialize(\n    RenderBundleEncoderInsertDebugMarkerCmd* record,\n    const volatile RenderBundleEncoderInsertDebugMarkerTransfer* transfer,\n    DeserializeBuffer* deserializeBuffer,\n    DeserializeAllocator* allocator, const ObjectIdResolver& resolver) {\n    DAWN_UNUSED(allocator);\n\n    ASSERT(transfer->commandId == WireCmd::RenderBundleEncoderInsertDebugMarker);\n    record->selfId = transfer->self;\n\n\n    WIRE_TRY(resolver.GetFromId(transfer->self, &record->self));\n    {\n        uint64_t stringLength64 = transfer->markerLabelStrlen;\n        if (stringLength64 >= std::numeric_limits<size_t>::max()) {\n            return WireResult::FatalError;\n        }\n        size_t stringLength = static_cast<size_t>(stringLength64);\n\n        const volatile char* stringInBuffer;\n        WIRE_TRY(deserializeBuffer->ReadN(stringLength, &stringInBuffer));\n\n        char* copiedString;\n        WIRE_TRY(GetSpace(allocator, stringLength + 1, &copiedString));\n        memcpy(copiedString, const_cast<const char*>(stringInBuffer), stringLength);\n        copiedString[stringLength] = '\\0';\n        record->markerLabel = copiedString;\n    }\n\n    return WireResult::Success;\n}\nDAWN_UNUSED_FUNC(RenderBundleEncoderInsertDebugMarkerDeserialize);\n\nstruct RenderBundleEncoderPopDebugGroupTransfer : CmdHeader {\n    static_assert(1 <= 1,\n                  \"Record must be at most one of is_cmd, extensible, and chained.\");\n    WireCmd commandId;\n\n    ObjectId self;\n};\n\nstatic_assert(offsetof(RenderBundleEncoderPopDebugGroupTransfer, commandSize) == 0);\nstatic_assert(offsetof(RenderBundleEncoderPopDebugGroupTransfer, commandId) == sizeof(CmdHeader));\n\nDAWN_DECLARE_UNUSED size_t RenderBundleEncoderPopDebugGroupGetExtraRequiredSize(const RenderBundleEncoderPopDebugGroupCmd& record) {\n    DAWN_UNUSED(record);\n    size_t result = 0;\n\n    return result;\n}\n// GetExtraRequiredSize isn't used for structures that are value members of other structures\n// because we assume they cannot contain pointers themselves.\nDAWN_UNUSED_FUNC(RenderBundleEncoderPopDebugGroupGetExtraRequiredSize);\n\nDAWN_DECLARE_UNUSED WireResult RenderBundleEncoderPopDebugGroupSerialize(\n    const RenderBundleEncoderPopDebugGroupCmd& record,\n    RenderBundleEncoderPopDebugGroupTransfer* transfer,\n    SerializeBuffer* buffer, const ObjectIdProvider& provider) {\n    DAWN_UNUSED(buffer);\n    transfer->commandId = WireCmd::RenderBundleEncoderPopDebugGroup;\n\n\n    WIRE_TRY(provider.GetId(record.self, &transfer->self));\n\n    return WireResult::Success;\n}\nDAWN_UNUSED_FUNC(RenderBundleEncoderPopDebugGroupSerialize);\n\nDAWN_DECLARE_UNUSED WireResult RenderBundleEncoderPopDebugGroupDeserialize(\n    RenderBundleEncoderPopDebugGroupCmd* record,\n    const volatile RenderBundleEncoderPopDebugGroupTransfer* transfer,\n    DeserializeBuffer* deserializeBuffer,\n    DeserializeAllocator* allocator, const ObjectIdResolver& resolver) {\n    DAWN_UNUSED(allocator);\n\n    ASSERT(transfer->commandId == WireCmd::RenderBundleEncoderPopDebugGroup);\n    record->selfId = transfer->self;\n\n\n    WIRE_TRY(resolver.GetFromId(transfer->self, &record->self));\n\n    return WireResult::Success;\n}\nDAWN_UNUSED_FUNC(RenderBundleEncoderPopDebugGroupDeserialize);\n\nstruct RenderBundleEncoderPushDebugGroupTransfer : CmdHeader {\n    static_assert(1 <= 1,\n                  \"Record must be at most one of is_cmd, extensible, and chained.\");\n    WireCmd commandId;\n\n    ObjectId self;\n    uint64_t groupLabelStrlen;\n};\n\nstatic_assert(offsetof(RenderBundleEncoderPushDebugGroupTransfer, commandSize) == 0);\nstatic_assert(offsetof(RenderBundleEncoderPushDebugGroupTransfer, commandId) == sizeof(CmdHeader));\n\nDAWN_DECLARE_UNUSED size_t RenderBundleEncoderPushDebugGroupGetExtraRequiredSize(const RenderBundleEncoderPushDebugGroupCmd& record) {\n    DAWN_UNUSED(record);\n    size_t result = 0;\n\n    ASSERT(record.groupLabel != nullptr);\n    result += Align(std::strlen(record.groupLabel), kWireBufferAlignment);\n    return result;\n}\n// GetExtraRequiredSize isn't used for structures that are value members of other structures\n// because we assume they cannot contain pointers themselves.\nDAWN_UNUSED_FUNC(RenderBundleEncoderPushDebugGroupGetExtraRequiredSize);\n\nDAWN_DECLARE_UNUSED WireResult RenderBundleEncoderPushDebugGroupSerialize(\n    const RenderBundleEncoderPushDebugGroupCmd& record,\n    RenderBundleEncoderPushDebugGroupTransfer* transfer,\n    SerializeBuffer* buffer, const ObjectIdProvider& provider) {\n    DAWN_UNUSED(buffer);\n    transfer->commandId = WireCmd::RenderBundleEncoderPushDebugGroup;\n\n\n    WIRE_TRY(provider.GetId(record.self, &transfer->self));\n    {\n        transfer->groupLabelStrlen = std::strlen(record.groupLabel);\n\n        char* stringInBuffer;\n        WIRE_TRY(buffer->NextN(transfer->groupLabelStrlen, &stringInBuffer));\n        memcpy(stringInBuffer, record.groupLabel, transfer->groupLabelStrlen);\n    }\n\n    return WireResult::Success;\n}\nDAWN_UNUSED_FUNC(RenderBundleEncoderPushDebugGroupSerialize);\n\nDAWN_DECLARE_UNUSED WireResult RenderBundleEncoderPushDebugGroupDeserialize(\n    RenderBundleEncoderPushDebugGroupCmd* record,\n    const volatile RenderBundleEncoderPushDebugGroupTransfer* transfer,\n    DeserializeBuffer* deserializeBuffer,\n    DeserializeAllocator* allocator, const ObjectIdResolver& resolver) {\n    DAWN_UNUSED(allocator);\n\n    ASSERT(transfer->commandId == WireCmd::RenderBundleEncoderPushDebugGroup);\n    record->selfId = transfer->self;\n\n\n    WIRE_TRY(resolver.GetFromId(transfer->self, &record->self));\n    {\n        uint64_t stringLength64 = transfer->groupLabelStrlen;\n        if (stringLength64 >= std::numeric_limits<size_t>::max()) {\n            return WireResult::FatalError;\n        }\n        size_t stringLength = static_cast<size_t>(stringLength64);\n\n        const volatile char* stringInBuffer;\n        WIRE_TRY(deserializeBuffer->ReadN(stringLength, &stringInBuffer));\n\n        char* copiedString;\n        WIRE_TRY(GetSpace(allocator, stringLength + 1, &copiedString));\n        memcpy(copiedString, const_cast<const char*>(stringInBuffer), stringLength);\n        copiedString[stringLength] = '\\0';\n        record->groupLabel = copiedString;\n    }\n\n    return WireResult::Success;\n}\nDAWN_UNUSED_FUNC(RenderBundleEncoderPushDebugGroupDeserialize);\n\nstruct RenderBundleEncoderSetBindGroupTransfer : CmdHeader {\n    static_assert(1 <= 1,\n                  \"Record must be at most one of is_cmd, extensible, and chained.\");\n    WireCmd commandId;\n\n    ObjectId self;\n    uint32_t groupIndex;\n    ObjectId group;\n    uint64_t dynamicOffsetCount;\n};\n\nstatic_assert(offsetof(RenderBundleEncoderSetBindGroupTransfer, commandSize) == 0);\nstatic_assert(offsetof(RenderBundleEncoderSetBindGroupTransfer, commandId) == sizeof(CmdHeader));\n\nDAWN_DECLARE_UNUSED size_t RenderBundleEncoderSetBindGroupGetExtraRequiredSize(const RenderBundleEncoderSetBindGroupCmd& record) {\n    DAWN_UNUSED(record);\n    size_t result = 0;\n\n    {\n        auto memberLength = record.dynamicOffsetCount;\n        auto size = WireAlignSizeofN<uint32_t>(memberLength);\n        ASSERT(size);\n        result += *size;\n    }\n    return result;\n}\n// GetExtraRequiredSize isn't used for structures that are value members of other structures\n// because we assume they cannot contain pointers themselves.\nDAWN_UNUSED_FUNC(RenderBundleEncoderSetBindGroupGetExtraRequiredSize);\n\nDAWN_DECLARE_UNUSED WireResult RenderBundleEncoderSetBindGroupSerialize(\n    const RenderBundleEncoderSetBindGroupCmd& record,\n    RenderBundleEncoderSetBindGroupTransfer* transfer,\n    SerializeBuffer* buffer, const ObjectIdProvider& provider) {\n    DAWN_UNUSED(buffer);\n    transfer->commandId = WireCmd::RenderBundleEncoderSetBindGroup;\n\n\n    WIRE_TRY(provider.GetId(record.self, &transfer->self));\n    transfer->groupIndex = record.groupIndex;\n    WIRE_TRY(provider.GetOptionalId(record.group, &transfer->group));\n    transfer->dynamicOffsetCount = record.dynamicOffsetCount;\n    {\n        auto memberLength = record.dynamicOffsetCount;\n\n        uint32_t* memberBuffer;\n        WIRE_TRY(buffer->NextN(memberLength, &memberBuffer));\n\n        memcpy(\n            memberBuffer, record.dynamicOffsets,\n            sizeof(uint32_t) * memberLength);\n    }\n\n    return WireResult::Success;\n}\nDAWN_UNUSED_FUNC(RenderBundleEncoderSetBindGroupSerialize);\n\nDAWN_DECLARE_UNUSED WireResult RenderBundleEncoderSetBindGroupDeserialize(\n    RenderBundleEncoderSetBindGroupCmd* record,\n    const volatile RenderBundleEncoderSetBindGroupTransfer* transfer,\n    DeserializeBuffer* deserializeBuffer,\n    DeserializeAllocator* allocator, const ObjectIdResolver& resolver) {\n    DAWN_UNUSED(allocator);\n\n    ASSERT(transfer->commandId == WireCmd::RenderBundleEncoderSetBindGroup);\n    record->selfId = transfer->self;\n\n\n    WIRE_TRY(resolver.GetFromId(transfer->self, &record->self));\n    static_assert(sizeof(record->groupIndex) >= sizeof(transfer->groupIndex), \"Deserialize assignment may not narrow.\");\n    record->groupIndex = transfer->groupIndex;\n    WIRE_TRY(resolver.GetOptionalFromId(transfer->group, &record->group));\n    if (transfer->dynamicOffsetCount > std::numeric_limits<size_t>::max()) return WireResult::FatalError;\n    record->dynamicOffsetCount = checked_cast<size_t>(transfer->dynamicOffsetCount);\n    {\n        auto memberLength = record->dynamicOffsetCount;\n        const volatile uint32_t* memberBuffer;\n        WIRE_TRY(deserializeBuffer->ReadN(memberLength, &memberBuffer));\n\n        uint32_t* copiedMembers;\n        WIRE_TRY(GetSpace(allocator, memberLength, &copiedMembers));\n        record->dynamicOffsets = copiedMembers;\n\n        memcpy(\n            copiedMembers,\n            const_cast<const uint32_t*>(memberBuffer),\n           sizeof(uint32_t) * memberLength);\n    }\n\n    return WireResult::Success;\n}\nDAWN_UNUSED_FUNC(RenderBundleEncoderSetBindGroupDeserialize);\n\nstruct RenderBundleEncoderSetIndexBufferTransfer : CmdHeader {\n    static_assert(1 <= 1,\n                  \"Record must be at most one of is_cmd, extensible, and chained.\");\n    WireCmd commandId;\n\n    ObjectId self;\n    ObjectId buffer;\n    WGPUIndexFormat format;\n    uint64_t offset;\n    uint64_t size;\n};\n\nstatic_assert(offsetof(RenderBundleEncoderSetIndexBufferTransfer, commandSize) == 0);\nstatic_assert(offsetof(RenderBundleEncoderSetIndexBufferTransfer, commandId) == sizeof(CmdHeader));\n\nDAWN_DECLARE_UNUSED size_t RenderBundleEncoderSetIndexBufferGetExtraRequiredSize(const RenderBundleEncoderSetIndexBufferCmd& record) {\n    DAWN_UNUSED(record);\n    size_t result = 0;\n\n    return result;\n}\n// GetExtraRequiredSize isn't used for structures that are value members of other structures\n// because we assume they cannot contain pointers themselves.\nDAWN_UNUSED_FUNC(RenderBundleEncoderSetIndexBufferGetExtraRequiredSize);\n\nDAWN_DECLARE_UNUSED WireResult RenderBundleEncoderSetIndexBufferSerialize(\n    const RenderBundleEncoderSetIndexBufferCmd& record,\n    RenderBundleEncoderSetIndexBufferTransfer* transfer,\n    SerializeBuffer* buffer, const ObjectIdProvider& provider) {\n    DAWN_UNUSED(buffer);\n    transfer->commandId = WireCmd::RenderBundleEncoderSetIndexBuffer;\n\n\n    WIRE_TRY(provider.GetId(record.self, &transfer->self));\n    WIRE_TRY(provider.GetId(record.buffer, &transfer->buffer));\n    transfer->format = record.format;\n    transfer->offset = record.offset;\n    transfer->size = record.size;\n\n    return WireResult::Success;\n}\nDAWN_UNUSED_FUNC(RenderBundleEncoderSetIndexBufferSerialize);\n\nDAWN_DECLARE_UNUSED WireResult RenderBundleEncoderSetIndexBufferDeserialize(\n    RenderBundleEncoderSetIndexBufferCmd* record,\n    const volatile RenderBundleEncoderSetIndexBufferTransfer* transfer,\n    DeserializeBuffer* deserializeBuffer,\n    DeserializeAllocator* allocator, const ObjectIdResolver& resolver) {\n    DAWN_UNUSED(allocator);\n\n    ASSERT(transfer->commandId == WireCmd::RenderBundleEncoderSetIndexBuffer);\n    record->selfId = transfer->self;\n\n\n    WIRE_TRY(resolver.GetFromId(transfer->self, &record->self));\n    WIRE_TRY(resolver.GetFromId(transfer->buffer, &record->buffer));\n    static_assert(sizeof(record->format) >= sizeof(transfer->format), \"Deserialize assignment may not narrow.\");\n    record->format = transfer->format;\n    static_assert(sizeof(record->offset) >= sizeof(transfer->offset), \"Deserialize assignment may not narrow.\");\n    record->offset = transfer->offset;\n    static_assert(sizeof(record->size) >= sizeof(transfer->size), \"Deserialize assignment may not narrow.\");\n    record->size = transfer->size;\n\n    return WireResult::Success;\n}\nDAWN_UNUSED_FUNC(RenderBundleEncoderSetIndexBufferDeserialize);\n\nstruct RenderBundleEncoderSetLabelTransfer : CmdHeader {\n    static_assert(1 <= 1,\n                  \"Record must be at most one of is_cmd, extensible, and chained.\");\n    WireCmd commandId;\n\n    ObjectId self;\n    uint64_t labelStrlen;\n};\n\nstatic_assert(offsetof(RenderBundleEncoderSetLabelTransfer, commandSize) == 0);\nstatic_assert(offsetof(RenderBundleEncoderSetLabelTransfer, commandId) == sizeof(CmdHeader));\n\nDAWN_DECLARE_UNUSED size_t RenderBundleEncoderSetLabelGetExtraRequiredSize(const RenderBundleEncoderSetLabelCmd& record) {\n    DAWN_UNUSED(record);\n    size_t result = 0;\n\n    ASSERT(record.label != nullptr);\n    result += Align(std::strlen(record.label), kWireBufferAlignment);\n    return result;\n}\n// GetExtraRequiredSize isn't used for structures that are value members of other structures\n// because we assume they cannot contain pointers themselves.\nDAWN_UNUSED_FUNC(RenderBundleEncoderSetLabelGetExtraRequiredSize);\n\nDAWN_DECLARE_UNUSED WireResult RenderBundleEncoderSetLabelSerialize(\n    const RenderBundleEncoderSetLabelCmd& record,\n    RenderBundleEncoderSetLabelTransfer* transfer,\n    SerializeBuffer* buffer, const ObjectIdProvider& provider) {\n    DAWN_UNUSED(buffer);\n    transfer->commandId = WireCmd::RenderBundleEncoderSetLabel;\n\n\n    WIRE_TRY(provider.GetId(record.self, &transfer->self));\n    {\n        transfer->labelStrlen = std::strlen(record.label);\n\n        char* stringInBuffer;\n        WIRE_TRY(buffer->NextN(transfer->labelStrlen, &stringInBuffer));\n        memcpy(stringInBuffer, record.label, transfer->labelStrlen);\n    }\n\n    return WireResult::Success;\n}\nDAWN_UNUSED_FUNC(RenderBundleEncoderSetLabelSerialize);\n\nDAWN_DECLARE_UNUSED WireResult RenderBundleEncoderSetLabelDeserialize(\n    RenderBundleEncoderSetLabelCmd* record,\n    const volatile RenderBundleEncoderSetLabelTransfer* transfer,\n    DeserializeBuffer* deserializeBuffer,\n    DeserializeAllocator* allocator, const ObjectIdResolver& resolver) {\n    DAWN_UNUSED(allocator);\n\n    ASSERT(transfer->commandId == WireCmd::RenderBundleEncoderSetLabel);\n    record->selfId = transfer->self;\n\n\n    WIRE_TRY(resolver.GetFromId(transfer->self, &record->self));\n    {\n        uint64_t stringLength64 = transfer->labelStrlen;\n        if (stringLength64 >= std::numeric_limits<size_t>::max()) {\n            return WireResult::FatalError;\n        }\n        size_t stringLength = static_cast<size_t>(stringLength64);\n\n        const volatile char* stringInBuffer;\n        WIRE_TRY(deserializeBuffer->ReadN(stringLength, &stringInBuffer));\n\n        char* copiedString;\n        WIRE_TRY(GetSpace(allocator, stringLength + 1, &copiedString));\n        memcpy(copiedString, const_cast<const char*>(stringInBuffer), stringLength);\n        copiedString[stringLength] = '\\0';\n        record->label = copiedString;\n    }\n\n    return WireResult::Success;\n}\nDAWN_UNUSED_FUNC(RenderBundleEncoderSetLabelDeserialize);\n\nstruct RenderBundleEncoderSetPipelineTransfer : CmdHeader {\n    static_assert(1 <= 1,\n                  \"Record must be at most one of is_cmd, extensible, and chained.\");\n    WireCmd commandId;\n\n    ObjectId self;\n    ObjectId pipeline;\n};\n\nstatic_assert(offsetof(RenderBundleEncoderSetPipelineTransfer, commandSize) == 0);\nstatic_assert(offsetof(RenderBundleEncoderSetPipelineTransfer, commandId) == sizeof(CmdHeader));\n\nDAWN_DECLARE_UNUSED size_t RenderBundleEncoderSetPipelineGetExtraRequiredSize(const RenderBundleEncoderSetPipelineCmd& record) {\n    DAWN_UNUSED(record);\n    size_t result = 0;\n\n    return result;\n}\n// GetExtraRequiredSize isn't used for structures that are value members of other structures\n// because we assume they cannot contain pointers themselves.\nDAWN_UNUSED_FUNC(RenderBundleEncoderSetPipelineGetExtraRequiredSize);\n\nDAWN_DECLARE_UNUSED WireResult RenderBundleEncoderSetPipelineSerialize(\n    const RenderBundleEncoderSetPipelineCmd& record,\n    RenderBundleEncoderSetPipelineTransfer* transfer,\n    SerializeBuffer* buffer, const ObjectIdProvider& provider) {\n    DAWN_UNUSED(buffer);\n    transfer->commandId = WireCmd::RenderBundleEncoderSetPipeline;\n\n\n    WIRE_TRY(provider.GetId(record.self, &transfer->self));\n    WIRE_TRY(provider.GetId(record.pipeline, &transfer->pipeline));\n\n    return WireResult::Success;\n}\nDAWN_UNUSED_FUNC(RenderBundleEncoderSetPipelineSerialize);\n\nDAWN_DECLARE_UNUSED WireResult RenderBundleEncoderSetPipelineDeserialize(\n    RenderBundleEncoderSetPipelineCmd* record,\n    const volatile RenderBundleEncoderSetPipelineTransfer* transfer,\n    DeserializeBuffer* deserializeBuffer,\n    DeserializeAllocator* allocator, const ObjectIdResolver& resolver) {\n    DAWN_UNUSED(allocator);\n\n    ASSERT(transfer->commandId == WireCmd::RenderBundleEncoderSetPipeline);\n    record->selfId = transfer->self;\n\n\n    WIRE_TRY(resolver.GetFromId(transfer->self, &record->self));\n    WIRE_TRY(resolver.GetFromId(transfer->pipeline, &record->pipeline));\n\n    return WireResult::Success;\n}\nDAWN_UNUSED_FUNC(RenderBundleEncoderSetPipelineDeserialize);\n\nstruct RenderBundleEncoderSetVertexBufferTransfer : CmdHeader {\n    static_assert(1 <= 1,\n                  \"Record must be at most one of is_cmd, extensible, and chained.\");\n    WireCmd commandId;\n\n    ObjectId self;\n    uint32_t slot;\n    ObjectId buffer;\n    uint64_t offset;\n    uint64_t size;\n};\n\nstatic_assert(offsetof(RenderBundleEncoderSetVertexBufferTransfer, commandSize) == 0);\nstatic_assert(offsetof(RenderBundleEncoderSetVertexBufferTransfer, commandId) == sizeof(CmdHeader));\n\nDAWN_DECLARE_UNUSED size_t RenderBundleEncoderSetVertexBufferGetExtraRequiredSize(const RenderBundleEncoderSetVertexBufferCmd& record) {\n    DAWN_UNUSED(record);\n    size_t result = 0;\n\n    return result;\n}\n// GetExtraRequiredSize isn't used for structures that are value members of other structures\n// because we assume they cannot contain pointers themselves.\nDAWN_UNUSED_FUNC(RenderBundleEncoderSetVertexBufferGetExtraRequiredSize);\n\nDAWN_DECLARE_UNUSED WireResult RenderBundleEncoderSetVertexBufferSerialize(\n    const RenderBundleEncoderSetVertexBufferCmd& record,\n    RenderBundleEncoderSetVertexBufferTransfer* transfer,\n    SerializeBuffer* buffer, const ObjectIdProvider& provider) {\n    DAWN_UNUSED(buffer);\n    transfer->commandId = WireCmd::RenderBundleEncoderSetVertexBuffer;\n\n\n    WIRE_TRY(provider.GetId(record.self, &transfer->self));\n    transfer->slot = record.slot;\n    WIRE_TRY(provider.GetOptionalId(record.buffer, &transfer->buffer));\n    transfer->offset = record.offset;\n    transfer->size = record.size;\n\n    return WireResult::Success;\n}\nDAWN_UNUSED_FUNC(RenderBundleEncoderSetVertexBufferSerialize);\n\nDAWN_DECLARE_UNUSED WireResult RenderBundleEncoderSetVertexBufferDeserialize(\n    RenderBundleEncoderSetVertexBufferCmd* record,\n    const volatile RenderBundleEncoderSetVertexBufferTransfer* transfer,\n    DeserializeBuffer* deserializeBuffer,\n    DeserializeAllocator* allocator, const ObjectIdResolver& resolver) {\n    DAWN_UNUSED(allocator);\n\n    ASSERT(transfer->commandId == WireCmd::RenderBundleEncoderSetVertexBuffer);\n    record->selfId = transfer->self;\n\n\n    WIRE_TRY(resolver.GetFromId(transfer->self, &record->self));\n    static_assert(sizeof(record->slot) >= sizeof(transfer->slot), \"Deserialize assignment may not narrow.\");\n    record->slot = transfer->slot;\n    WIRE_TRY(resolver.GetOptionalFromId(transfer->buffer, &record->buffer));\n    static_assert(sizeof(record->offset) >= sizeof(transfer->offset), \"Deserialize assignment may not narrow.\");\n    record->offset = transfer->offset;\n    static_assert(sizeof(record->size) >= sizeof(transfer->size), \"Deserialize assignment may not narrow.\");\n    record->size = transfer->size;\n\n    return WireResult::Success;\n}\nDAWN_UNUSED_FUNC(RenderBundleEncoderSetVertexBufferDeserialize);\n\nstruct RenderBundleSetLabelTransfer : CmdHeader {\n    static_assert(1 <= 1,\n                  \"Record must be at most one of is_cmd, extensible, and chained.\");\n    WireCmd commandId;\n\n    ObjectId self;\n    uint64_t labelStrlen;\n};\n\nstatic_assert(offsetof(RenderBundleSetLabelTransfer, commandSize) == 0);\nstatic_assert(offsetof(RenderBundleSetLabelTransfer, commandId) == sizeof(CmdHeader));\n\nDAWN_DECLARE_UNUSED size_t RenderBundleSetLabelGetExtraRequiredSize(const RenderBundleSetLabelCmd& record) {\n    DAWN_UNUSED(record);\n    size_t result = 0;\n\n    ASSERT(record.label != nullptr);\n    result += Align(std::strlen(record.label), kWireBufferAlignment);\n    return result;\n}\n// GetExtraRequiredSize isn't used for structures that are value members of other structures\n// because we assume they cannot contain pointers themselves.\nDAWN_UNUSED_FUNC(RenderBundleSetLabelGetExtraRequiredSize);\n\nDAWN_DECLARE_UNUSED WireResult RenderBundleSetLabelSerialize(\n    const RenderBundleSetLabelCmd& record,\n    RenderBundleSetLabelTransfer* transfer,\n    SerializeBuffer* buffer, const ObjectIdProvider& provider) {\n    DAWN_UNUSED(buffer);\n    transfer->commandId = WireCmd::RenderBundleSetLabel;\n\n\n    WIRE_TRY(provider.GetId(record.self, &transfer->self));\n    {\n        transfer->labelStrlen = std::strlen(record.label);\n\n        char* stringInBuffer;\n        WIRE_TRY(buffer->NextN(transfer->labelStrlen, &stringInBuffer));\n        memcpy(stringInBuffer, record.label, transfer->labelStrlen);\n    }\n\n    return WireResult::Success;\n}\nDAWN_UNUSED_FUNC(RenderBundleSetLabelSerialize);\n\nDAWN_DECLARE_UNUSED WireResult RenderBundleSetLabelDeserialize(\n    RenderBundleSetLabelCmd* record,\n    const volatile RenderBundleSetLabelTransfer* transfer,\n    DeserializeBuffer* deserializeBuffer,\n    DeserializeAllocator* allocator, const ObjectIdResolver& resolver) {\n    DAWN_UNUSED(allocator);\n\n    ASSERT(transfer->commandId == WireCmd::RenderBundleSetLabel);\n    record->selfId = transfer->self;\n\n\n    WIRE_TRY(resolver.GetFromId(transfer->self, &record->self));\n    {\n        uint64_t stringLength64 = transfer->labelStrlen;\n        if (stringLength64 >= std::numeric_limits<size_t>::max()) {\n            return WireResult::FatalError;\n        }\n        size_t stringLength = static_cast<size_t>(stringLength64);\n\n        const volatile char* stringInBuffer;\n        WIRE_TRY(deserializeBuffer->ReadN(stringLength, &stringInBuffer));\n\n        char* copiedString;\n        WIRE_TRY(GetSpace(allocator, stringLength + 1, &copiedString));\n        memcpy(copiedString, const_cast<const char*>(stringInBuffer), stringLength);\n        copiedString[stringLength] = '\\0';\n        record->label = copiedString;\n    }\n\n    return WireResult::Success;\n}\nDAWN_UNUSED_FUNC(RenderBundleSetLabelDeserialize);\n\nstruct RenderPassEncoderBeginOcclusionQueryTransfer : CmdHeader {\n    static_assert(1 <= 1,\n                  \"Record must be at most one of is_cmd, extensible, and chained.\");\n    WireCmd commandId;\n\n    ObjectId self;\n    uint32_t queryIndex;\n};\n\nstatic_assert(offsetof(RenderPassEncoderBeginOcclusionQueryTransfer, commandSize) == 0);\nstatic_assert(offsetof(RenderPassEncoderBeginOcclusionQueryTransfer, commandId) == sizeof(CmdHeader));\n\nDAWN_DECLARE_UNUSED size_t RenderPassEncoderBeginOcclusionQueryGetExtraRequiredSize(const RenderPassEncoderBeginOcclusionQueryCmd& record) {\n    DAWN_UNUSED(record);\n    size_t result = 0;\n\n    return result;\n}\n// GetExtraRequiredSize isn't used for structures that are value members of other structures\n// because we assume they cannot contain pointers themselves.\nDAWN_UNUSED_FUNC(RenderPassEncoderBeginOcclusionQueryGetExtraRequiredSize);\n\nDAWN_DECLARE_UNUSED WireResult RenderPassEncoderBeginOcclusionQuerySerialize(\n    const RenderPassEncoderBeginOcclusionQueryCmd& record,\n    RenderPassEncoderBeginOcclusionQueryTransfer* transfer,\n    SerializeBuffer* buffer, const ObjectIdProvider& provider) {\n    DAWN_UNUSED(buffer);\n    transfer->commandId = WireCmd::RenderPassEncoderBeginOcclusionQuery;\n\n\n    WIRE_TRY(provider.GetId(record.self, &transfer->self));\n    transfer->queryIndex = record.queryIndex;\n\n    return WireResult::Success;\n}\nDAWN_UNUSED_FUNC(RenderPassEncoderBeginOcclusionQuerySerialize);\n\nDAWN_DECLARE_UNUSED WireResult RenderPassEncoderBeginOcclusionQueryDeserialize(\n    RenderPassEncoderBeginOcclusionQueryCmd* record,\n    const volatile RenderPassEncoderBeginOcclusionQueryTransfer* transfer,\n    DeserializeBuffer* deserializeBuffer,\n    DeserializeAllocator* allocator, const ObjectIdResolver& resolver) {\n    DAWN_UNUSED(allocator);\n\n    ASSERT(transfer->commandId == WireCmd::RenderPassEncoderBeginOcclusionQuery);\n    record->selfId = transfer->self;\n\n\n    WIRE_TRY(resolver.GetFromId(transfer->self, &record->self));\n    static_assert(sizeof(record->queryIndex) >= sizeof(transfer->queryIndex), \"Deserialize assignment may not narrow.\");\n    record->queryIndex = transfer->queryIndex;\n\n    return WireResult::Success;\n}\nDAWN_UNUSED_FUNC(RenderPassEncoderBeginOcclusionQueryDeserialize);\n\nstruct RenderPassEncoderDrawTransfer : CmdHeader {\n    static_assert(1 <= 1,\n                  \"Record must be at most one of is_cmd, extensible, and chained.\");\n    WireCmd commandId;\n\n    ObjectId self;\n    uint32_t vertexCount;\n    uint32_t instanceCount;\n    uint32_t firstVertex;\n    uint32_t firstInstance;\n};\n\nstatic_assert(offsetof(RenderPassEncoderDrawTransfer, commandSize) == 0);\nstatic_assert(offsetof(RenderPassEncoderDrawTransfer, commandId) == sizeof(CmdHeader));\n\nDAWN_DECLARE_UNUSED size_t RenderPassEncoderDrawGetExtraRequiredSize(const RenderPassEncoderDrawCmd& record) {\n    DAWN_UNUSED(record);\n    size_t result = 0;\n\n    return result;\n}\n// GetExtraRequiredSize isn't used for structures that are value members of other structures\n// because we assume they cannot contain pointers themselves.\nDAWN_UNUSED_FUNC(RenderPassEncoderDrawGetExtraRequiredSize);\n\nDAWN_DECLARE_UNUSED WireResult RenderPassEncoderDrawSerialize(\n    const RenderPassEncoderDrawCmd& record,\n    RenderPassEncoderDrawTransfer* transfer,\n    SerializeBuffer* buffer, const ObjectIdProvider& provider) {\n    DAWN_UNUSED(buffer);\n    transfer->commandId = WireCmd::RenderPassEncoderDraw;\n\n\n    WIRE_TRY(provider.GetId(record.self, &transfer->self));\n    transfer->vertexCount = record.vertexCount;\n    transfer->instanceCount = record.instanceCount;\n    transfer->firstVertex = record.firstVertex;\n    transfer->firstInstance = record.firstInstance;\n\n    return WireResult::Success;\n}\nDAWN_UNUSED_FUNC(RenderPassEncoderDrawSerialize);\n\nDAWN_DECLARE_UNUSED WireResult RenderPassEncoderDrawDeserialize(\n    RenderPassEncoderDrawCmd* record,\n    const volatile RenderPassEncoderDrawTransfer* transfer,\n    DeserializeBuffer* deserializeBuffer,\n    DeserializeAllocator* allocator, const ObjectIdResolver& resolver) {\n    DAWN_UNUSED(allocator);\n\n    ASSERT(transfer->commandId == WireCmd::RenderPassEncoderDraw);\n    record->selfId = transfer->self;\n\n\n    WIRE_TRY(resolver.GetFromId(transfer->self, &record->self));\n    static_assert(sizeof(record->vertexCount) >= sizeof(transfer->vertexCount), \"Deserialize assignment may not narrow.\");\n    record->vertexCount = transfer->vertexCount;\n    static_assert(sizeof(record->instanceCount) >= sizeof(transfer->instanceCount), \"Deserialize assignment may not narrow.\");\n    record->instanceCount = transfer->instanceCount;\n    static_assert(sizeof(record->firstVertex) >= sizeof(transfer->firstVertex), \"Deserialize assignment may not narrow.\");\n    record->firstVertex = transfer->firstVertex;\n    static_assert(sizeof(record->firstInstance) >= sizeof(transfer->firstInstance), \"Deserialize assignment may not narrow.\");\n    record->firstInstance = transfer->firstInstance;\n\n    return WireResult::Success;\n}\nDAWN_UNUSED_FUNC(RenderPassEncoderDrawDeserialize);\n\nstruct RenderPassEncoderDrawIndexedTransfer : CmdHeader {\n    static_assert(1 <= 1,\n                  \"Record must be at most one of is_cmd, extensible, and chained.\");\n    WireCmd commandId;\n\n    ObjectId self;\n    uint32_t indexCount;\n    uint32_t instanceCount;\n    uint32_t firstIndex;\n    int32_t baseVertex;\n    uint32_t firstInstance;\n};\n\nstatic_assert(offsetof(RenderPassEncoderDrawIndexedTransfer, commandSize) == 0);\nstatic_assert(offsetof(RenderPassEncoderDrawIndexedTransfer, commandId) == sizeof(CmdHeader));\n\nDAWN_DECLARE_UNUSED size_t RenderPassEncoderDrawIndexedGetExtraRequiredSize(const RenderPassEncoderDrawIndexedCmd& record) {\n    DAWN_UNUSED(record);\n    size_t result = 0;\n\n    return result;\n}\n// GetExtraRequiredSize isn't used for structures that are value members of other structures\n// because we assume they cannot contain pointers themselves.\nDAWN_UNUSED_FUNC(RenderPassEncoderDrawIndexedGetExtraRequiredSize);\n\nDAWN_DECLARE_UNUSED WireResult RenderPassEncoderDrawIndexedSerialize(\n    const RenderPassEncoderDrawIndexedCmd& record,\n    RenderPassEncoderDrawIndexedTransfer* transfer,\n    SerializeBuffer* buffer, const ObjectIdProvider& provider) {\n    DAWN_UNUSED(buffer);\n    transfer->commandId = WireCmd::RenderPassEncoderDrawIndexed;\n\n\n    WIRE_TRY(provider.GetId(record.self, &transfer->self));\n    transfer->indexCount = record.indexCount;\n    transfer->instanceCount = record.instanceCount;\n    transfer->firstIndex = record.firstIndex;\n    transfer->baseVertex = record.baseVertex;\n    transfer->firstInstance = record.firstInstance;\n\n    return WireResult::Success;\n}\nDAWN_UNUSED_FUNC(RenderPassEncoderDrawIndexedSerialize);\n\nDAWN_DECLARE_UNUSED WireResult RenderPassEncoderDrawIndexedDeserialize(\n    RenderPassEncoderDrawIndexedCmd* record,\n    const volatile RenderPassEncoderDrawIndexedTransfer* transfer,\n    DeserializeBuffer* deserializeBuffer,\n    DeserializeAllocator* allocator, const ObjectIdResolver& resolver) {\n    DAWN_UNUSED(allocator);\n\n    ASSERT(transfer->commandId == WireCmd::RenderPassEncoderDrawIndexed);\n    record->selfId = transfer->self;\n\n\n    WIRE_TRY(resolver.GetFromId(transfer->self, &record->self));\n    static_assert(sizeof(record->indexCount) >= sizeof(transfer->indexCount), \"Deserialize assignment may not narrow.\");\n    record->indexCount = transfer->indexCount;\n    static_assert(sizeof(record->instanceCount) >= sizeof(transfer->instanceCount), \"Deserialize assignment may not narrow.\");\n    record->instanceCount = transfer->instanceCount;\n    static_assert(sizeof(record->firstIndex) >= sizeof(transfer->firstIndex), \"Deserialize assignment may not narrow.\");\n    record->firstIndex = transfer->firstIndex;\n    static_assert(sizeof(record->baseVertex) >= sizeof(transfer->baseVertex), \"Deserialize assignment may not narrow.\");\n    record->baseVertex = transfer->baseVertex;\n    static_assert(sizeof(record->firstInstance) >= sizeof(transfer->firstInstance), \"Deserialize assignment may not narrow.\");\n    record->firstInstance = transfer->firstInstance;\n\n    return WireResult::Success;\n}\nDAWN_UNUSED_FUNC(RenderPassEncoderDrawIndexedDeserialize);\n\nstruct RenderPassEncoderDrawIndexedIndirectTransfer : CmdHeader {\n    static_assert(1 <= 1,\n                  \"Record must be at most one of is_cmd, extensible, and chained.\");\n    WireCmd commandId;\n\n    ObjectId self;\n    ObjectId indirectBuffer;\n    uint64_t indirectOffset;\n};\n\nstatic_assert(offsetof(RenderPassEncoderDrawIndexedIndirectTransfer, commandSize) == 0);\nstatic_assert(offsetof(RenderPassEncoderDrawIndexedIndirectTransfer, commandId) == sizeof(CmdHeader));\n\nDAWN_DECLARE_UNUSED size_t RenderPassEncoderDrawIndexedIndirectGetExtraRequiredSize(const RenderPassEncoderDrawIndexedIndirectCmd& record) {\n    DAWN_UNUSED(record);\n    size_t result = 0;\n\n    return result;\n}\n// GetExtraRequiredSize isn't used for structures that are value members of other structures\n// because we assume they cannot contain pointers themselves.\nDAWN_UNUSED_FUNC(RenderPassEncoderDrawIndexedIndirectGetExtraRequiredSize);\n\nDAWN_DECLARE_UNUSED WireResult RenderPassEncoderDrawIndexedIndirectSerialize(\n    const RenderPassEncoderDrawIndexedIndirectCmd& record,\n    RenderPassEncoderDrawIndexedIndirectTransfer* transfer,\n    SerializeBuffer* buffer, const ObjectIdProvider& provider) {\n    DAWN_UNUSED(buffer);\n    transfer->commandId = WireCmd::RenderPassEncoderDrawIndexedIndirect;\n\n\n    WIRE_TRY(provider.GetId(record.self, &transfer->self));\n    WIRE_TRY(provider.GetId(record.indirectBuffer, &transfer->indirectBuffer));\n    transfer->indirectOffset = record.indirectOffset;\n\n    return WireResult::Success;\n}\nDAWN_UNUSED_FUNC(RenderPassEncoderDrawIndexedIndirectSerialize);\n\nDAWN_DECLARE_UNUSED WireResult RenderPassEncoderDrawIndexedIndirectDeserialize(\n    RenderPassEncoderDrawIndexedIndirectCmd* record,\n    const volatile RenderPassEncoderDrawIndexedIndirectTransfer* transfer,\n    DeserializeBuffer* deserializeBuffer,\n    DeserializeAllocator* allocator, const ObjectIdResolver& resolver) {\n    DAWN_UNUSED(allocator);\n\n    ASSERT(transfer->commandId == WireCmd::RenderPassEncoderDrawIndexedIndirect);\n    record->selfId = transfer->self;\n\n\n    WIRE_TRY(resolver.GetFromId(transfer->self, &record->self));\n    WIRE_TRY(resolver.GetFromId(transfer->indirectBuffer, &record->indirectBuffer));\n    static_assert(sizeof(record->indirectOffset) >= sizeof(transfer->indirectOffset), \"Deserialize assignment may not narrow.\");\n    record->indirectOffset = transfer->indirectOffset;\n\n    return WireResult::Success;\n}\nDAWN_UNUSED_FUNC(RenderPassEncoderDrawIndexedIndirectDeserialize);\n\nstruct RenderPassEncoderDrawIndirectTransfer : CmdHeader {\n    static_assert(1 <= 1,\n                  \"Record must be at most one of is_cmd, extensible, and chained.\");\n    WireCmd commandId;\n\n    ObjectId self;\n    ObjectId indirectBuffer;\n    uint64_t indirectOffset;\n};\n\nstatic_assert(offsetof(RenderPassEncoderDrawIndirectTransfer, commandSize) == 0);\nstatic_assert(offsetof(RenderPassEncoderDrawIndirectTransfer, commandId) == sizeof(CmdHeader));\n\nDAWN_DECLARE_UNUSED size_t RenderPassEncoderDrawIndirectGetExtraRequiredSize(const RenderPassEncoderDrawIndirectCmd& record) {\n    DAWN_UNUSED(record);\n    size_t result = 0;\n\n    return result;\n}\n// GetExtraRequiredSize isn't used for structures that are value members of other structures\n// because we assume they cannot contain pointers themselves.\nDAWN_UNUSED_FUNC(RenderPassEncoderDrawIndirectGetExtraRequiredSize);\n\nDAWN_DECLARE_UNUSED WireResult RenderPassEncoderDrawIndirectSerialize(\n    const RenderPassEncoderDrawIndirectCmd& record,\n    RenderPassEncoderDrawIndirectTransfer* transfer,\n    SerializeBuffer* buffer, const ObjectIdProvider& provider) {\n    DAWN_UNUSED(buffer);\n    transfer->commandId = WireCmd::RenderPassEncoderDrawIndirect;\n\n\n    WIRE_TRY(provider.GetId(record.self, &transfer->self));\n    WIRE_TRY(provider.GetId(record.indirectBuffer, &transfer->indirectBuffer));\n    transfer->indirectOffset = record.indirectOffset;\n\n    return WireResult::Success;\n}\nDAWN_UNUSED_FUNC(RenderPassEncoderDrawIndirectSerialize);\n\nDAWN_DECLARE_UNUSED WireResult RenderPassEncoderDrawIndirectDeserialize(\n    RenderPassEncoderDrawIndirectCmd* record,\n    const volatile RenderPassEncoderDrawIndirectTransfer* transfer,\n    DeserializeBuffer* deserializeBuffer,\n    DeserializeAllocator* allocator, const ObjectIdResolver& resolver) {\n    DAWN_UNUSED(allocator);\n\n    ASSERT(transfer->commandId == WireCmd::RenderPassEncoderDrawIndirect);\n    record->selfId = transfer->self;\n\n\n    WIRE_TRY(resolver.GetFromId(transfer->self, &record->self));\n    WIRE_TRY(resolver.GetFromId(transfer->indirectBuffer, &record->indirectBuffer));\n    static_assert(sizeof(record->indirectOffset) >= sizeof(transfer->indirectOffset), \"Deserialize assignment may not narrow.\");\n    record->indirectOffset = transfer->indirectOffset;\n\n    return WireResult::Success;\n}\nDAWN_UNUSED_FUNC(RenderPassEncoderDrawIndirectDeserialize);\n\nstruct RenderPassEncoderEndTransfer : CmdHeader {\n    static_assert(1 <= 1,\n                  \"Record must be at most one of is_cmd, extensible, and chained.\");\n    WireCmd commandId;\n\n    ObjectId self;\n};\n\nstatic_assert(offsetof(RenderPassEncoderEndTransfer, commandSize) == 0);\nstatic_assert(offsetof(RenderPassEncoderEndTransfer, commandId) == sizeof(CmdHeader));\n\nDAWN_DECLARE_UNUSED size_t RenderPassEncoderEndGetExtraRequiredSize(const RenderPassEncoderEndCmd& record) {\n    DAWN_UNUSED(record);\n    size_t result = 0;\n\n    return result;\n}\n// GetExtraRequiredSize isn't used for structures that are value members of other structures\n// because we assume they cannot contain pointers themselves.\nDAWN_UNUSED_FUNC(RenderPassEncoderEndGetExtraRequiredSize);\n\nDAWN_DECLARE_UNUSED WireResult RenderPassEncoderEndSerialize(\n    const RenderPassEncoderEndCmd& record,\n    RenderPassEncoderEndTransfer* transfer,\n    SerializeBuffer* buffer, const ObjectIdProvider& provider) {\n    DAWN_UNUSED(buffer);\n    transfer->commandId = WireCmd::RenderPassEncoderEnd;\n\n\n    WIRE_TRY(provider.GetId(record.self, &transfer->self));\n\n    return WireResult::Success;\n}\nDAWN_UNUSED_FUNC(RenderPassEncoderEndSerialize);\n\nDAWN_DECLARE_UNUSED WireResult RenderPassEncoderEndDeserialize(\n    RenderPassEncoderEndCmd* record,\n    const volatile RenderPassEncoderEndTransfer* transfer,\n    DeserializeBuffer* deserializeBuffer,\n    DeserializeAllocator* allocator, const ObjectIdResolver& resolver) {\n    DAWN_UNUSED(allocator);\n\n    ASSERT(transfer->commandId == WireCmd::RenderPassEncoderEnd);\n    record->selfId = transfer->self;\n\n\n    WIRE_TRY(resolver.GetFromId(transfer->self, &record->self));\n\n    return WireResult::Success;\n}\nDAWN_UNUSED_FUNC(RenderPassEncoderEndDeserialize);\n\nstruct RenderPassEncoderEndOcclusionQueryTransfer : CmdHeader {\n    static_assert(1 <= 1,\n                  \"Record must be at most one of is_cmd, extensible, and chained.\");\n    WireCmd commandId;\n\n    ObjectId self;\n};\n\nstatic_assert(offsetof(RenderPassEncoderEndOcclusionQueryTransfer, commandSize) == 0);\nstatic_assert(offsetof(RenderPassEncoderEndOcclusionQueryTransfer, commandId) == sizeof(CmdHeader));\n\nDAWN_DECLARE_UNUSED size_t RenderPassEncoderEndOcclusionQueryGetExtraRequiredSize(const RenderPassEncoderEndOcclusionQueryCmd& record) {\n    DAWN_UNUSED(record);\n    size_t result = 0;\n\n    return result;\n}\n// GetExtraRequiredSize isn't used for structures that are value members of other structures\n// because we assume they cannot contain pointers themselves.\nDAWN_UNUSED_FUNC(RenderPassEncoderEndOcclusionQueryGetExtraRequiredSize);\n\nDAWN_DECLARE_UNUSED WireResult RenderPassEncoderEndOcclusionQuerySerialize(\n    const RenderPassEncoderEndOcclusionQueryCmd& record,\n    RenderPassEncoderEndOcclusionQueryTransfer* transfer,\n    SerializeBuffer* buffer, const ObjectIdProvider& provider) {\n    DAWN_UNUSED(buffer);\n    transfer->commandId = WireCmd::RenderPassEncoderEndOcclusionQuery;\n\n\n    WIRE_TRY(provider.GetId(record.self, &transfer->self));\n\n    return WireResult::Success;\n}\nDAWN_UNUSED_FUNC(RenderPassEncoderEndOcclusionQuerySerialize);\n\nDAWN_DECLARE_UNUSED WireResult RenderPassEncoderEndOcclusionQueryDeserialize(\n    RenderPassEncoderEndOcclusionQueryCmd* record,\n    const volatile RenderPassEncoderEndOcclusionQueryTransfer* transfer,\n    DeserializeBuffer* deserializeBuffer,\n    DeserializeAllocator* allocator, const ObjectIdResolver& resolver) {\n    DAWN_UNUSED(allocator);\n\n    ASSERT(transfer->commandId == WireCmd::RenderPassEncoderEndOcclusionQuery);\n    record->selfId = transfer->self;\n\n\n    WIRE_TRY(resolver.GetFromId(transfer->self, &record->self));\n\n    return WireResult::Success;\n}\nDAWN_UNUSED_FUNC(RenderPassEncoderEndOcclusionQueryDeserialize);\n\nstruct RenderPassEncoderExecuteBundlesTransfer : CmdHeader {\n    static_assert(1 <= 1,\n                  \"Record must be at most one of is_cmd, extensible, and chained.\");\n    WireCmd commandId;\n\n    ObjectId self;\n    uint64_t bundleCount;\n};\n\nstatic_assert(offsetof(RenderPassEncoderExecuteBundlesTransfer, commandSize) == 0);\nstatic_assert(offsetof(RenderPassEncoderExecuteBundlesTransfer, commandId) == sizeof(CmdHeader));\n\nDAWN_DECLARE_UNUSED size_t RenderPassEncoderExecuteBundlesGetExtraRequiredSize(const RenderPassEncoderExecuteBundlesCmd& record) {\n    DAWN_UNUSED(record);\n    size_t result = 0;\n\n    {\n        auto memberLength = record.bundleCount;\n        auto size = WireAlignSizeofN<ObjectId>(memberLength);\n        ASSERT(size);\n        result += *size;\n    }\n    return result;\n}\n// GetExtraRequiredSize isn't used for structures that are value members of other structures\n// because we assume they cannot contain pointers themselves.\nDAWN_UNUSED_FUNC(RenderPassEncoderExecuteBundlesGetExtraRequiredSize);\n\nDAWN_DECLARE_UNUSED WireResult RenderPassEncoderExecuteBundlesSerialize(\n    const RenderPassEncoderExecuteBundlesCmd& record,\n    RenderPassEncoderExecuteBundlesTransfer* transfer,\n    SerializeBuffer* buffer, const ObjectIdProvider& provider) {\n    DAWN_UNUSED(buffer);\n    transfer->commandId = WireCmd::RenderPassEncoderExecuteBundles;\n\n\n    WIRE_TRY(provider.GetId(record.self, &transfer->self));\n    transfer->bundleCount = record.bundleCount;\n    {\n        auto memberLength = record.bundleCount;\n\n        ObjectId* memberBuffer;\n        WIRE_TRY(buffer->NextN(memberLength, &memberBuffer));\n\n        for (decltype(memberLength) i = 0; i < memberLength; ++i) {\n            WIRE_TRY(provider.GetId(record.bundles[i], &memberBuffer[i]));\n        }\n    }\n\n    return WireResult::Success;\n}\nDAWN_UNUSED_FUNC(RenderPassEncoderExecuteBundlesSerialize);\n\nDAWN_DECLARE_UNUSED WireResult RenderPassEncoderExecuteBundlesDeserialize(\n    RenderPassEncoderExecuteBundlesCmd* record,\n    const volatile RenderPassEncoderExecuteBundlesTransfer* transfer,\n    DeserializeBuffer* deserializeBuffer,\n    DeserializeAllocator* allocator, const ObjectIdResolver& resolver) {\n    DAWN_UNUSED(allocator);\n\n    ASSERT(transfer->commandId == WireCmd::RenderPassEncoderExecuteBundles);\n    record->selfId = transfer->self;\n\n\n    WIRE_TRY(resolver.GetFromId(transfer->self, &record->self));\n    if (transfer->bundleCount > std::numeric_limits<size_t>::max()) return WireResult::FatalError;\n    record->bundleCount = checked_cast<size_t>(transfer->bundleCount);\n    {\n        auto memberLength = record->bundleCount;\n        const volatile ObjectId* memberBuffer;\n        WIRE_TRY(deserializeBuffer->ReadN(memberLength, &memberBuffer));\n\n        WGPURenderBundle* copiedMembers;\n        WIRE_TRY(GetSpace(allocator, memberLength, &copiedMembers));\n        record->bundles = copiedMembers;\n\n        for (decltype(memberLength) i = 0; i < memberLength; ++i) {\n            WIRE_TRY(resolver.GetFromId(memberBuffer[i], &copiedMembers[i]));\n        }\n    }\n\n    return WireResult::Success;\n}\nDAWN_UNUSED_FUNC(RenderPassEncoderExecuteBundlesDeserialize);\n\nstruct RenderPassEncoderInsertDebugMarkerTransfer : CmdHeader {\n    static_assert(1 <= 1,\n                  \"Record must be at most one of is_cmd, extensible, and chained.\");\n    WireCmd commandId;\n\n    ObjectId self;\n    uint64_t markerLabelStrlen;\n};\n\nstatic_assert(offsetof(RenderPassEncoderInsertDebugMarkerTransfer, commandSize) == 0);\nstatic_assert(offsetof(RenderPassEncoderInsertDebugMarkerTransfer, commandId) == sizeof(CmdHeader));\n\nDAWN_DECLARE_UNUSED size_t RenderPassEncoderInsertDebugMarkerGetExtraRequiredSize(const RenderPassEncoderInsertDebugMarkerCmd& record) {\n    DAWN_UNUSED(record);\n    size_t result = 0;\n\n    ASSERT(record.markerLabel != nullptr);\n    result += Align(std::strlen(record.markerLabel), kWireBufferAlignment);\n    return result;\n}\n// GetExtraRequiredSize isn't used for structures that are value members of other structures\n// because we assume they cannot contain pointers themselves.\nDAWN_UNUSED_FUNC(RenderPassEncoderInsertDebugMarkerGetExtraRequiredSize);\n\nDAWN_DECLARE_UNUSED WireResult RenderPassEncoderInsertDebugMarkerSerialize(\n    const RenderPassEncoderInsertDebugMarkerCmd& record,\n    RenderPassEncoderInsertDebugMarkerTransfer* transfer,\n    SerializeBuffer* buffer, const ObjectIdProvider& provider) {\n    DAWN_UNUSED(buffer);\n    transfer->commandId = WireCmd::RenderPassEncoderInsertDebugMarker;\n\n\n    WIRE_TRY(provider.GetId(record.self, &transfer->self));\n    {\n        transfer->markerLabelStrlen = std::strlen(record.markerLabel);\n\n        char* stringInBuffer;\n        WIRE_TRY(buffer->NextN(transfer->markerLabelStrlen, &stringInBuffer));\n        memcpy(stringInBuffer, record.markerLabel, transfer->markerLabelStrlen);\n    }\n\n    return WireResult::Success;\n}\nDAWN_UNUSED_FUNC(RenderPassEncoderInsertDebugMarkerSerialize);\n\nDAWN_DECLARE_UNUSED WireResult RenderPassEncoderInsertDebugMarkerDeserialize(\n    RenderPassEncoderInsertDebugMarkerCmd* record,\n    const volatile RenderPassEncoderInsertDebugMarkerTransfer* transfer,\n    DeserializeBuffer* deserializeBuffer,\n    DeserializeAllocator* allocator, const ObjectIdResolver& resolver) {\n    DAWN_UNUSED(allocator);\n\n    ASSERT(transfer->commandId == WireCmd::RenderPassEncoderInsertDebugMarker);\n    record->selfId = transfer->self;\n\n\n    WIRE_TRY(resolver.GetFromId(transfer->self, &record->self));\n    {\n        uint64_t stringLength64 = transfer->markerLabelStrlen;\n        if (stringLength64 >= std::numeric_limits<size_t>::max()) {\n            return WireResult::FatalError;\n        }\n        size_t stringLength = static_cast<size_t>(stringLength64);\n\n        const volatile char* stringInBuffer;\n        WIRE_TRY(deserializeBuffer->ReadN(stringLength, &stringInBuffer));\n\n        char* copiedString;\n        WIRE_TRY(GetSpace(allocator, stringLength + 1, &copiedString));\n        memcpy(copiedString, const_cast<const char*>(stringInBuffer), stringLength);\n        copiedString[stringLength] = '\\0';\n        record->markerLabel = copiedString;\n    }\n\n    return WireResult::Success;\n}\nDAWN_UNUSED_FUNC(RenderPassEncoderInsertDebugMarkerDeserialize);\n\nstruct RenderPassEncoderPopDebugGroupTransfer : CmdHeader {\n    static_assert(1 <= 1,\n                  \"Record must be at most one of is_cmd, extensible, and chained.\");\n    WireCmd commandId;\n\n    ObjectId self;\n};\n\nstatic_assert(offsetof(RenderPassEncoderPopDebugGroupTransfer, commandSize) == 0);\nstatic_assert(offsetof(RenderPassEncoderPopDebugGroupTransfer, commandId) == sizeof(CmdHeader));\n\nDAWN_DECLARE_UNUSED size_t RenderPassEncoderPopDebugGroupGetExtraRequiredSize(const RenderPassEncoderPopDebugGroupCmd& record) {\n    DAWN_UNUSED(record);\n    size_t result = 0;\n\n    return result;\n}\n// GetExtraRequiredSize isn't used for structures that are value members of other structures\n// because we assume they cannot contain pointers themselves.\nDAWN_UNUSED_FUNC(RenderPassEncoderPopDebugGroupGetExtraRequiredSize);\n\nDAWN_DECLARE_UNUSED WireResult RenderPassEncoderPopDebugGroupSerialize(\n    const RenderPassEncoderPopDebugGroupCmd& record,\n    RenderPassEncoderPopDebugGroupTransfer* transfer,\n    SerializeBuffer* buffer, const ObjectIdProvider& provider) {\n    DAWN_UNUSED(buffer);\n    transfer->commandId = WireCmd::RenderPassEncoderPopDebugGroup;\n\n\n    WIRE_TRY(provider.GetId(record.self, &transfer->self));\n\n    return WireResult::Success;\n}\nDAWN_UNUSED_FUNC(RenderPassEncoderPopDebugGroupSerialize);\n\nDAWN_DECLARE_UNUSED WireResult RenderPassEncoderPopDebugGroupDeserialize(\n    RenderPassEncoderPopDebugGroupCmd* record,\n    const volatile RenderPassEncoderPopDebugGroupTransfer* transfer,\n    DeserializeBuffer* deserializeBuffer,\n    DeserializeAllocator* allocator, const ObjectIdResolver& resolver) {\n    DAWN_UNUSED(allocator);\n\n    ASSERT(transfer->commandId == WireCmd::RenderPassEncoderPopDebugGroup);\n    record->selfId = transfer->self;\n\n\n    WIRE_TRY(resolver.GetFromId(transfer->self, &record->self));\n\n    return WireResult::Success;\n}\nDAWN_UNUSED_FUNC(RenderPassEncoderPopDebugGroupDeserialize);\n\nstruct RenderPassEncoderPushDebugGroupTransfer : CmdHeader {\n    static_assert(1 <= 1,\n                  \"Record must be at most one of is_cmd, extensible, and chained.\");\n    WireCmd commandId;\n\n    ObjectId self;\n    uint64_t groupLabelStrlen;\n};\n\nstatic_assert(offsetof(RenderPassEncoderPushDebugGroupTransfer, commandSize) == 0);\nstatic_assert(offsetof(RenderPassEncoderPushDebugGroupTransfer, commandId) == sizeof(CmdHeader));\n\nDAWN_DECLARE_UNUSED size_t RenderPassEncoderPushDebugGroupGetExtraRequiredSize(const RenderPassEncoderPushDebugGroupCmd& record) {\n    DAWN_UNUSED(record);\n    size_t result = 0;\n\n    ASSERT(record.groupLabel != nullptr);\n    result += Align(std::strlen(record.groupLabel), kWireBufferAlignment);\n    return result;\n}\n// GetExtraRequiredSize isn't used for structures that are value members of other structures\n// because we assume they cannot contain pointers themselves.\nDAWN_UNUSED_FUNC(RenderPassEncoderPushDebugGroupGetExtraRequiredSize);\n\nDAWN_DECLARE_UNUSED WireResult RenderPassEncoderPushDebugGroupSerialize(\n    const RenderPassEncoderPushDebugGroupCmd& record,\n    RenderPassEncoderPushDebugGroupTransfer* transfer,\n    SerializeBuffer* buffer, const ObjectIdProvider& provider) {\n    DAWN_UNUSED(buffer);\n    transfer->commandId = WireCmd::RenderPassEncoderPushDebugGroup;\n\n\n    WIRE_TRY(provider.GetId(record.self, &transfer->self));\n    {\n        transfer->groupLabelStrlen = std::strlen(record.groupLabel);\n\n        char* stringInBuffer;\n        WIRE_TRY(buffer->NextN(transfer->groupLabelStrlen, &stringInBuffer));\n        memcpy(stringInBuffer, record.groupLabel, transfer->groupLabelStrlen);\n    }\n\n    return WireResult::Success;\n}\nDAWN_UNUSED_FUNC(RenderPassEncoderPushDebugGroupSerialize);\n\nDAWN_DECLARE_UNUSED WireResult RenderPassEncoderPushDebugGroupDeserialize(\n    RenderPassEncoderPushDebugGroupCmd* record,\n    const volatile RenderPassEncoderPushDebugGroupTransfer* transfer,\n    DeserializeBuffer* deserializeBuffer,\n    DeserializeAllocator* allocator, const ObjectIdResolver& resolver) {\n    DAWN_UNUSED(allocator);\n\n    ASSERT(transfer->commandId == WireCmd::RenderPassEncoderPushDebugGroup);\n    record->selfId = transfer->self;\n\n\n    WIRE_TRY(resolver.GetFromId(transfer->self, &record->self));\n    {\n        uint64_t stringLength64 = transfer->groupLabelStrlen;\n        if (stringLength64 >= std::numeric_limits<size_t>::max()) {\n            return WireResult::FatalError;\n        }\n        size_t stringLength = static_cast<size_t>(stringLength64);\n\n        const volatile char* stringInBuffer;\n        WIRE_TRY(deserializeBuffer->ReadN(stringLength, &stringInBuffer));\n\n        char* copiedString;\n        WIRE_TRY(GetSpace(allocator, stringLength + 1, &copiedString));\n        memcpy(copiedString, const_cast<const char*>(stringInBuffer), stringLength);\n        copiedString[stringLength] = '\\0';\n        record->groupLabel = copiedString;\n    }\n\n    return WireResult::Success;\n}\nDAWN_UNUSED_FUNC(RenderPassEncoderPushDebugGroupDeserialize);\n\nstruct RenderPassEncoderSetBindGroupTransfer : CmdHeader {\n    static_assert(1 <= 1,\n                  \"Record must be at most one of is_cmd, extensible, and chained.\");\n    WireCmd commandId;\n\n    ObjectId self;\n    uint32_t groupIndex;\n    ObjectId group;\n    uint64_t dynamicOffsetCount;\n};\n\nstatic_assert(offsetof(RenderPassEncoderSetBindGroupTransfer, commandSize) == 0);\nstatic_assert(offsetof(RenderPassEncoderSetBindGroupTransfer, commandId) == sizeof(CmdHeader));\n\nDAWN_DECLARE_UNUSED size_t RenderPassEncoderSetBindGroupGetExtraRequiredSize(const RenderPassEncoderSetBindGroupCmd& record) {\n    DAWN_UNUSED(record);\n    size_t result = 0;\n\n    {\n        auto memberLength = record.dynamicOffsetCount;\n        auto size = WireAlignSizeofN<uint32_t>(memberLength);\n        ASSERT(size);\n        result += *size;\n    }\n    return result;\n}\n// GetExtraRequiredSize isn't used for structures that are value members of other structures\n// because we assume they cannot contain pointers themselves.\nDAWN_UNUSED_FUNC(RenderPassEncoderSetBindGroupGetExtraRequiredSize);\n\nDAWN_DECLARE_UNUSED WireResult RenderPassEncoderSetBindGroupSerialize(\n    const RenderPassEncoderSetBindGroupCmd& record,\n    RenderPassEncoderSetBindGroupTransfer* transfer,\n    SerializeBuffer* buffer, const ObjectIdProvider& provider) {\n    DAWN_UNUSED(buffer);\n    transfer->commandId = WireCmd::RenderPassEncoderSetBindGroup;\n\n\n    WIRE_TRY(provider.GetId(record.self, &transfer->self));\n    transfer->groupIndex = record.groupIndex;\n    WIRE_TRY(provider.GetOptionalId(record.group, &transfer->group));\n    transfer->dynamicOffsetCount = record.dynamicOffsetCount;\n    {\n        auto memberLength = record.dynamicOffsetCount;\n\n        uint32_t* memberBuffer;\n        WIRE_TRY(buffer->NextN(memberLength, &memberBuffer));\n\n        memcpy(\n            memberBuffer, record.dynamicOffsets,\n            sizeof(uint32_t) * memberLength);\n    }\n\n    return WireResult::Success;\n}\nDAWN_UNUSED_FUNC(RenderPassEncoderSetBindGroupSerialize);\n\nDAWN_DECLARE_UNUSED WireResult RenderPassEncoderSetBindGroupDeserialize(\n    RenderPassEncoderSetBindGroupCmd* record,\n    const volatile RenderPassEncoderSetBindGroupTransfer* transfer,\n    DeserializeBuffer* deserializeBuffer,\n    DeserializeAllocator* allocator, const ObjectIdResolver& resolver) {\n    DAWN_UNUSED(allocator);\n\n    ASSERT(transfer->commandId == WireCmd::RenderPassEncoderSetBindGroup);\n    record->selfId = transfer->self;\n\n\n    WIRE_TRY(resolver.GetFromId(transfer->self, &record->self));\n    static_assert(sizeof(record->groupIndex) >= sizeof(transfer->groupIndex), \"Deserialize assignment may not narrow.\");\n    record->groupIndex = transfer->groupIndex;\n    WIRE_TRY(resolver.GetOptionalFromId(transfer->group, &record->group));\n    if (transfer->dynamicOffsetCount > std::numeric_limits<size_t>::max()) return WireResult::FatalError;\n    record->dynamicOffsetCount = checked_cast<size_t>(transfer->dynamicOffsetCount);\n    {\n        auto memberLength = record->dynamicOffsetCount;\n        const volatile uint32_t* memberBuffer;\n        WIRE_TRY(deserializeBuffer->ReadN(memberLength, &memberBuffer));\n\n        uint32_t* copiedMembers;\n        WIRE_TRY(GetSpace(allocator, memberLength, &copiedMembers));\n        record->dynamicOffsets = copiedMembers;\n\n        memcpy(\n            copiedMembers,\n            const_cast<const uint32_t*>(memberBuffer),\n           sizeof(uint32_t) * memberLength);\n    }\n\n    return WireResult::Success;\n}\nDAWN_UNUSED_FUNC(RenderPassEncoderSetBindGroupDeserialize);\n\nstruct RenderPassEncoderSetBlendConstantTransfer : CmdHeader {\n    static_assert(1 <= 1,\n                  \"Record must be at most one of is_cmd, extensible, and chained.\");\n    WireCmd commandId;\n\n    ObjectId self;\n};\n\nstatic_assert(offsetof(RenderPassEncoderSetBlendConstantTransfer, commandSize) == 0);\nstatic_assert(offsetof(RenderPassEncoderSetBlendConstantTransfer, commandId) == sizeof(CmdHeader));\n\nDAWN_DECLARE_UNUSED size_t RenderPassEncoderSetBlendConstantGetExtraRequiredSize(const RenderPassEncoderSetBlendConstantCmd& record) {\n    DAWN_UNUSED(record);\n    size_t result = 0;\n\n    {\n        auto memberLength = 1u;\n        auto size = WireAlignSizeofN<WGPUColorTransfer>(memberLength);\n        ASSERT(size);\n        result += *size;\n        for (decltype(memberLength) i = 0; i < memberLength; ++i) {\n            result += WGPUColorGetExtraRequiredSize(record.color[i]);\n        }\n    }\n    return result;\n}\n// GetExtraRequiredSize isn't used for structures that are value members of other structures\n// because we assume they cannot contain pointers themselves.\nDAWN_UNUSED_FUNC(RenderPassEncoderSetBlendConstantGetExtraRequiredSize);\n\nDAWN_DECLARE_UNUSED WireResult RenderPassEncoderSetBlendConstantSerialize(\n    const RenderPassEncoderSetBlendConstantCmd& record,\n    RenderPassEncoderSetBlendConstantTransfer* transfer,\n    SerializeBuffer* buffer, const ObjectIdProvider& provider) {\n    DAWN_UNUSED(buffer);\n    transfer->commandId = WireCmd::RenderPassEncoderSetBlendConstant;\n\n\n    WIRE_TRY(provider.GetId(record.self, &transfer->self));\n    {\n        auto memberLength = 1u;\n\n        WGPUColorTransfer* memberBuffer;\n        WIRE_TRY(buffer->NextN(memberLength, &memberBuffer));\n\n        memcpy(\n            memberBuffer, record.color,\n            sizeof(WGPUColorTransfer) * memberLength);\n    }\n\n    return WireResult::Success;\n}\nDAWN_UNUSED_FUNC(RenderPassEncoderSetBlendConstantSerialize);\n\nDAWN_DECLARE_UNUSED WireResult RenderPassEncoderSetBlendConstantDeserialize(\n    RenderPassEncoderSetBlendConstantCmd* record,\n    const volatile RenderPassEncoderSetBlendConstantTransfer* transfer,\n    DeserializeBuffer* deserializeBuffer,\n    DeserializeAllocator* allocator, const ObjectIdResolver& resolver) {\n    DAWN_UNUSED(allocator);\n\n    ASSERT(transfer->commandId == WireCmd::RenderPassEncoderSetBlendConstant);\n    record->selfId = transfer->self;\n\n\n    WIRE_TRY(resolver.GetFromId(transfer->self, &record->self));\n    {\n        auto memberLength = 1u;\n        const volatile WGPUColorTransfer* memberBuffer;\n        WIRE_TRY(deserializeBuffer->ReadN(memberLength, &memberBuffer));\n\n        WGPUColor* copiedMembers;\n        WIRE_TRY(GetSpace(allocator, memberLength, &copiedMembers));\n        record->color = copiedMembers;\n\n        memcpy(\n            copiedMembers,\n            const_cast<const WGPUColorTransfer*>(memberBuffer),\n           sizeof(WGPUColorTransfer) * memberLength);\n    }\n\n    return WireResult::Success;\n}\nDAWN_UNUSED_FUNC(RenderPassEncoderSetBlendConstantDeserialize);\n\nstruct RenderPassEncoderSetIndexBufferTransfer : CmdHeader {\n    static_assert(1 <= 1,\n                  \"Record must be at most one of is_cmd, extensible, and chained.\");\n    WireCmd commandId;\n\n    ObjectId self;\n    ObjectId buffer;\n    WGPUIndexFormat format;\n    uint64_t offset;\n    uint64_t size;\n};\n\nstatic_assert(offsetof(RenderPassEncoderSetIndexBufferTransfer, commandSize) == 0);\nstatic_assert(offsetof(RenderPassEncoderSetIndexBufferTransfer, commandId) == sizeof(CmdHeader));\n\nDAWN_DECLARE_UNUSED size_t RenderPassEncoderSetIndexBufferGetExtraRequiredSize(const RenderPassEncoderSetIndexBufferCmd& record) {\n    DAWN_UNUSED(record);\n    size_t result = 0;\n\n    return result;\n}\n// GetExtraRequiredSize isn't used for structures that are value members of other structures\n// because we assume they cannot contain pointers themselves.\nDAWN_UNUSED_FUNC(RenderPassEncoderSetIndexBufferGetExtraRequiredSize);\n\nDAWN_DECLARE_UNUSED WireResult RenderPassEncoderSetIndexBufferSerialize(\n    const RenderPassEncoderSetIndexBufferCmd& record,\n    RenderPassEncoderSetIndexBufferTransfer* transfer,\n    SerializeBuffer* buffer, const ObjectIdProvider& provider) {\n    DAWN_UNUSED(buffer);\n    transfer->commandId = WireCmd::RenderPassEncoderSetIndexBuffer;\n\n\n    WIRE_TRY(provider.GetId(record.self, &transfer->self));\n    WIRE_TRY(provider.GetId(record.buffer, &transfer->buffer));\n    transfer->format = record.format;\n    transfer->offset = record.offset;\n    transfer->size = record.size;\n\n    return WireResult::Success;\n}\nDAWN_UNUSED_FUNC(RenderPassEncoderSetIndexBufferSerialize);\n\nDAWN_DECLARE_UNUSED WireResult RenderPassEncoderSetIndexBufferDeserialize(\n    RenderPassEncoderSetIndexBufferCmd* record,\n    const volatile RenderPassEncoderSetIndexBufferTransfer* transfer,\n    DeserializeBuffer* deserializeBuffer,\n    DeserializeAllocator* allocator, const ObjectIdResolver& resolver) {\n    DAWN_UNUSED(allocator);\n\n    ASSERT(transfer->commandId == WireCmd::RenderPassEncoderSetIndexBuffer);\n    record->selfId = transfer->self;\n\n\n    WIRE_TRY(resolver.GetFromId(transfer->self, &record->self));\n    WIRE_TRY(resolver.GetFromId(transfer->buffer, &record->buffer));\n    static_assert(sizeof(record->format) >= sizeof(transfer->format), \"Deserialize assignment may not narrow.\");\n    record->format = transfer->format;\n    static_assert(sizeof(record->offset) >= sizeof(transfer->offset), \"Deserialize assignment may not narrow.\");\n    record->offset = transfer->offset;\n    static_assert(sizeof(record->size) >= sizeof(transfer->size), \"Deserialize assignment may not narrow.\");\n    record->size = transfer->size;\n\n    return WireResult::Success;\n}\nDAWN_UNUSED_FUNC(RenderPassEncoderSetIndexBufferDeserialize);\n\nstruct RenderPassEncoderSetLabelTransfer : CmdHeader {\n    static_assert(1 <= 1,\n                  \"Record must be at most one of is_cmd, extensible, and chained.\");\n    WireCmd commandId;\n\n    ObjectId self;\n    uint64_t labelStrlen;\n};\n\nstatic_assert(offsetof(RenderPassEncoderSetLabelTransfer, commandSize) == 0);\nstatic_assert(offsetof(RenderPassEncoderSetLabelTransfer, commandId) == sizeof(CmdHeader));\n\nDAWN_DECLARE_UNUSED size_t RenderPassEncoderSetLabelGetExtraRequiredSize(const RenderPassEncoderSetLabelCmd& record) {\n    DAWN_UNUSED(record);\n    size_t result = 0;\n\n    ASSERT(record.label != nullptr);\n    result += Align(std::strlen(record.label), kWireBufferAlignment);\n    return result;\n}\n// GetExtraRequiredSize isn't used for structures that are value members of other structures\n// because we assume they cannot contain pointers themselves.\nDAWN_UNUSED_FUNC(RenderPassEncoderSetLabelGetExtraRequiredSize);\n\nDAWN_DECLARE_UNUSED WireResult RenderPassEncoderSetLabelSerialize(\n    const RenderPassEncoderSetLabelCmd& record,\n    RenderPassEncoderSetLabelTransfer* transfer,\n    SerializeBuffer* buffer, const ObjectIdProvider& provider) {\n    DAWN_UNUSED(buffer);\n    transfer->commandId = WireCmd::RenderPassEncoderSetLabel;\n\n\n    WIRE_TRY(provider.GetId(record.self, &transfer->self));\n    {\n        transfer->labelStrlen = std::strlen(record.label);\n\n        char* stringInBuffer;\n        WIRE_TRY(buffer->NextN(transfer->labelStrlen, &stringInBuffer));\n        memcpy(stringInBuffer, record.label, transfer->labelStrlen);\n    }\n\n    return WireResult::Success;\n}\nDAWN_UNUSED_FUNC(RenderPassEncoderSetLabelSerialize);\n\nDAWN_DECLARE_UNUSED WireResult RenderPassEncoderSetLabelDeserialize(\n    RenderPassEncoderSetLabelCmd* record,\n    const volatile RenderPassEncoderSetLabelTransfer* transfer,\n    DeserializeBuffer* deserializeBuffer,\n    DeserializeAllocator* allocator, const ObjectIdResolver& resolver) {\n    DAWN_UNUSED(allocator);\n\n    ASSERT(transfer->commandId == WireCmd::RenderPassEncoderSetLabel);\n    record->selfId = transfer->self;\n\n\n    WIRE_TRY(resolver.GetFromId(transfer->self, &record->self));\n    {\n        uint64_t stringLength64 = transfer->labelStrlen;\n        if (stringLength64 >= std::numeric_limits<size_t>::max()) {\n            return WireResult::FatalError;\n        }\n        size_t stringLength = static_cast<size_t>(stringLength64);\n\n        const volatile char* stringInBuffer;\n        WIRE_TRY(deserializeBuffer->ReadN(stringLength, &stringInBuffer));\n\n        char* copiedString;\n        WIRE_TRY(GetSpace(allocator, stringLength + 1, &copiedString));\n        memcpy(copiedString, const_cast<const char*>(stringInBuffer), stringLength);\n        copiedString[stringLength] = '\\0';\n        record->label = copiedString;\n    }\n\n    return WireResult::Success;\n}\nDAWN_UNUSED_FUNC(RenderPassEncoderSetLabelDeserialize);\n\nstruct RenderPassEncoderSetPipelineTransfer : CmdHeader {\n    static_assert(1 <= 1,\n                  \"Record must be at most one of is_cmd, extensible, and chained.\");\n    WireCmd commandId;\n\n    ObjectId self;\n    ObjectId pipeline;\n};\n\nstatic_assert(offsetof(RenderPassEncoderSetPipelineTransfer, commandSize) == 0);\nstatic_assert(offsetof(RenderPassEncoderSetPipelineTransfer, commandId) == sizeof(CmdHeader));\n\nDAWN_DECLARE_UNUSED size_t RenderPassEncoderSetPipelineGetExtraRequiredSize(const RenderPassEncoderSetPipelineCmd& record) {\n    DAWN_UNUSED(record);\n    size_t result = 0;\n\n    return result;\n}\n// GetExtraRequiredSize isn't used for structures that are value members of other structures\n// because we assume they cannot contain pointers themselves.\nDAWN_UNUSED_FUNC(RenderPassEncoderSetPipelineGetExtraRequiredSize);\n\nDAWN_DECLARE_UNUSED WireResult RenderPassEncoderSetPipelineSerialize(\n    const RenderPassEncoderSetPipelineCmd& record,\n    RenderPassEncoderSetPipelineTransfer* transfer,\n    SerializeBuffer* buffer, const ObjectIdProvider& provider) {\n    DAWN_UNUSED(buffer);\n    transfer->commandId = WireCmd::RenderPassEncoderSetPipeline;\n\n\n    WIRE_TRY(provider.GetId(record.self, &transfer->self));\n    WIRE_TRY(provider.GetId(record.pipeline, &transfer->pipeline));\n\n    return WireResult::Success;\n}\nDAWN_UNUSED_FUNC(RenderPassEncoderSetPipelineSerialize);\n\nDAWN_DECLARE_UNUSED WireResult RenderPassEncoderSetPipelineDeserialize(\n    RenderPassEncoderSetPipelineCmd* record,\n    const volatile RenderPassEncoderSetPipelineTransfer* transfer,\n    DeserializeBuffer* deserializeBuffer,\n    DeserializeAllocator* allocator, const ObjectIdResolver& resolver) {\n    DAWN_UNUSED(allocator);\n\n    ASSERT(transfer->commandId == WireCmd::RenderPassEncoderSetPipeline);\n    record->selfId = transfer->self;\n\n\n    WIRE_TRY(resolver.GetFromId(transfer->self, &record->self));\n    WIRE_TRY(resolver.GetFromId(transfer->pipeline, &record->pipeline));\n\n    return WireResult::Success;\n}\nDAWN_UNUSED_FUNC(RenderPassEncoderSetPipelineDeserialize);\n\nstruct RenderPassEncoderSetScissorRectTransfer : CmdHeader {\n    static_assert(1 <= 1,\n                  \"Record must be at most one of is_cmd, extensible, and chained.\");\n    WireCmd commandId;\n\n    ObjectId self;\n    uint32_t x;\n    uint32_t y;\n    uint32_t width;\n    uint32_t height;\n};\n\nstatic_assert(offsetof(RenderPassEncoderSetScissorRectTransfer, commandSize) == 0);\nstatic_assert(offsetof(RenderPassEncoderSetScissorRectTransfer, commandId) == sizeof(CmdHeader));\n\nDAWN_DECLARE_UNUSED size_t RenderPassEncoderSetScissorRectGetExtraRequiredSize(const RenderPassEncoderSetScissorRectCmd& record) {\n    DAWN_UNUSED(record);\n    size_t result = 0;\n\n    return result;\n}\n// GetExtraRequiredSize isn't used for structures that are value members of other structures\n// because we assume they cannot contain pointers themselves.\nDAWN_UNUSED_FUNC(RenderPassEncoderSetScissorRectGetExtraRequiredSize);\n\nDAWN_DECLARE_UNUSED WireResult RenderPassEncoderSetScissorRectSerialize(\n    const RenderPassEncoderSetScissorRectCmd& record,\n    RenderPassEncoderSetScissorRectTransfer* transfer,\n    SerializeBuffer* buffer, const ObjectIdProvider& provider) {\n    DAWN_UNUSED(buffer);\n    transfer->commandId = WireCmd::RenderPassEncoderSetScissorRect;\n\n\n    WIRE_TRY(provider.GetId(record.self, &transfer->self));\n    transfer->x = record.x;\n    transfer->y = record.y;\n    transfer->width = record.width;\n    transfer->height = record.height;\n\n    return WireResult::Success;\n}\nDAWN_UNUSED_FUNC(RenderPassEncoderSetScissorRectSerialize);\n\nDAWN_DECLARE_UNUSED WireResult RenderPassEncoderSetScissorRectDeserialize(\n    RenderPassEncoderSetScissorRectCmd* record,\n    const volatile RenderPassEncoderSetScissorRectTransfer* transfer,\n    DeserializeBuffer* deserializeBuffer,\n    DeserializeAllocator* allocator, const ObjectIdResolver& resolver) {\n    DAWN_UNUSED(allocator);\n\n    ASSERT(transfer->commandId == WireCmd::RenderPassEncoderSetScissorRect);\n    record->selfId = transfer->self;\n\n\n    WIRE_TRY(resolver.GetFromId(transfer->self, &record->self));\n    static_assert(sizeof(record->x) >= sizeof(transfer->x), \"Deserialize assignment may not narrow.\");\n    record->x = transfer->x;\n    static_assert(sizeof(record->y) >= sizeof(transfer->y), \"Deserialize assignment may not narrow.\");\n    record->y = transfer->y;\n    static_assert(sizeof(record->width) >= sizeof(transfer->width), \"Deserialize assignment may not narrow.\");\n    record->width = transfer->width;\n    static_assert(sizeof(record->height) >= sizeof(transfer->height), \"Deserialize assignment may not narrow.\");\n    record->height = transfer->height;\n\n    return WireResult::Success;\n}\nDAWN_UNUSED_FUNC(RenderPassEncoderSetScissorRectDeserialize);\n\nstruct RenderPassEncoderSetStencilReferenceTransfer : CmdHeader {\n    static_assert(1 <= 1,\n                  \"Record must be at most one of is_cmd, extensible, and chained.\");\n    WireCmd commandId;\n\n    ObjectId self;\n    uint32_t reference;\n};\n\nstatic_assert(offsetof(RenderPassEncoderSetStencilReferenceTransfer, commandSize) == 0);\nstatic_assert(offsetof(RenderPassEncoderSetStencilReferenceTransfer, commandId) == sizeof(CmdHeader));\n\nDAWN_DECLARE_UNUSED size_t RenderPassEncoderSetStencilReferenceGetExtraRequiredSize(const RenderPassEncoderSetStencilReferenceCmd& record) {\n    DAWN_UNUSED(record);\n    size_t result = 0;\n\n    return result;\n}\n// GetExtraRequiredSize isn't used for structures that are value members of other structures\n// because we assume they cannot contain pointers themselves.\nDAWN_UNUSED_FUNC(RenderPassEncoderSetStencilReferenceGetExtraRequiredSize);\n\nDAWN_DECLARE_UNUSED WireResult RenderPassEncoderSetStencilReferenceSerialize(\n    const RenderPassEncoderSetStencilReferenceCmd& record,\n    RenderPassEncoderSetStencilReferenceTransfer* transfer,\n    SerializeBuffer* buffer, const ObjectIdProvider& provider) {\n    DAWN_UNUSED(buffer);\n    transfer->commandId = WireCmd::RenderPassEncoderSetStencilReference;\n\n\n    WIRE_TRY(provider.GetId(record.self, &transfer->self));\n    transfer->reference = record.reference;\n\n    return WireResult::Success;\n}\nDAWN_UNUSED_FUNC(RenderPassEncoderSetStencilReferenceSerialize);\n\nDAWN_DECLARE_UNUSED WireResult RenderPassEncoderSetStencilReferenceDeserialize(\n    RenderPassEncoderSetStencilReferenceCmd* record,\n    const volatile RenderPassEncoderSetStencilReferenceTransfer* transfer,\n    DeserializeBuffer* deserializeBuffer,\n    DeserializeAllocator* allocator, const ObjectIdResolver& resolver) {\n    DAWN_UNUSED(allocator);\n\n    ASSERT(transfer->commandId == WireCmd::RenderPassEncoderSetStencilReference);\n    record->selfId = transfer->self;\n\n\n    WIRE_TRY(resolver.GetFromId(transfer->self, &record->self));\n    static_assert(sizeof(record->reference) >= sizeof(transfer->reference), \"Deserialize assignment may not narrow.\");\n    record->reference = transfer->reference;\n\n    return WireResult::Success;\n}\nDAWN_UNUSED_FUNC(RenderPassEncoderSetStencilReferenceDeserialize);\n\nstruct RenderPassEncoderSetVertexBufferTransfer : CmdHeader {\n    static_assert(1 <= 1,\n                  \"Record must be at most one of is_cmd, extensible, and chained.\");\n    WireCmd commandId;\n\n    ObjectId self;\n    uint32_t slot;\n    ObjectId buffer;\n    uint64_t offset;\n    uint64_t size;\n};\n\nstatic_assert(offsetof(RenderPassEncoderSetVertexBufferTransfer, commandSize) == 0);\nstatic_assert(offsetof(RenderPassEncoderSetVertexBufferTransfer, commandId) == sizeof(CmdHeader));\n\nDAWN_DECLARE_UNUSED size_t RenderPassEncoderSetVertexBufferGetExtraRequiredSize(const RenderPassEncoderSetVertexBufferCmd& record) {\n    DAWN_UNUSED(record);\n    size_t result = 0;\n\n    return result;\n}\n// GetExtraRequiredSize isn't used for structures that are value members of other structures\n// because we assume they cannot contain pointers themselves.\nDAWN_UNUSED_FUNC(RenderPassEncoderSetVertexBufferGetExtraRequiredSize);\n\nDAWN_DECLARE_UNUSED WireResult RenderPassEncoderSetVertexBufferSerialize(\n    const RenderPassEncoderSetVertexBufferCmd& record,\n    RenderPassEncoderSetVertexBufferTransfer* transfer,\n    SerializeBuffer* buffer, const ObjectIdProvider& provider) {\n    DAWN_UNUSED(buffer);\n    transfer->commandId = WireCmd::RenderPassEncoderSetVertexBuffer;\n\n\n    WIRE_TRY(provider.GetId(record.self, &transfer->self));\n    transfer->slot = record.slot;\n    WIRE_TRY(provider.GetOptionalId(record.buffer, &transfer->buffer));\n    transfer->offset = record.offset;\n    transfer->size = record.size;\n\n    return WireResult::Success;\n}\nDAWN_UNUSED_FUNC(RenderPassEncoderSetVertexBufferSerialize);\n\nDAWN_DECLARE_UNUSED WireResult RenderPassEncoderSetVertexBufferDeserialize(\n    RenderPassEncoderSetVertexBufferCmd* record,\n    const volatile RenderPassEncoderSetVertexBufferTransfer* transfer,\n    DeserializeBuffer* deserializeBuffer,\n    DeserializeAllocator* allocator, const ObjectIdResolver& resolver) {\n    DAWN_UNUSED(allocator);\n\n    ASSERT(transfer->commandId == WireCmd::RenderPassEncoderSetVertexBuffer);\n    record->selfId = transfer->self;\n\n\n    WIRE_TRY(resolver.GetFromId(transfer->self, &record->self));\n    static_assert(sizeof(record->slot) >= sizeof(transfer->slot), \"Deserialize assignment may not narrow.\");\n    record->slot = transfer->slot;\n    WIRE_TRY(resolver.GetOptionalFromId(transfer->buffer, &record->buffer));\n    static_assert(sizeof(record->offset) >= sizeof(transfer->offset), \"Deserialize assignment may not narrow.\");\n    record->offset = transfer->offset;\n    static_assert(sizeof(record->size) >= sizeof(transfer->size), \"Deserialize assignment may not narrow.\");\n    record->size = transfer->size;\n\n    return WireResult::Success;\n}\nDAWN_UNUSED_FUNC(RenderPassEncoderSetVertexBufferDeserialize);\n\nstruct RenderPassEncoderSetViewportTransfer : CmdHeader {\n    static_assert(1 <= 1,\n                  \"Record must be at most one of is_cmd, extensible, and chained.\");\n    WireCmd commandId;\n\n    ObjectId self;\n    float x;\n    float y;\n    float width;\n    float height;\n    float minDepth;\n    float maxDepth;\n};\n\nstatic_assert(offsetof(RenderPassEncoderSetViewportTransfer, commandSize) == 0);\nstatic_assert(offsetof(RenderPassEncoderSetViewportTransfer, commandId) == sizeof(CmdHeader));\n\nDAWN_DECLARE_UNUSED size_t RenderPassEncoderSetViewportGetExtraRequiredSize(const RenderPassEncoderSetViewportCmd& record) {\n    DAWN_UNUSED(record);\n    size_t result = 0;\n\n    return result;\n}\n// GetExtraRequiredSize isn't used for structures that are value members of other structures\n// because we assume they cannot contain pointers themselves.\nDAWN_UNUSED_FUNC(RenderPassEncoderSetViewportGetExtraRequiredSize);\n\nDAWN_DECLARE_UNUSED WireResult RenderPassEncoderSetViewportSerialize(\n    const RenderPassEncoderSetViewportCmd& record,\n    RenderPassEncoderSetViewportTransfer* transfer,\n    SerializeBuffer* buffer, const ObjectIdProvider& provider) {\n    DAWN_UNUSED(buffer);\n    transfer->commandId = WireCmd::RenderPassEncoderSetViewport;\n\n\n    WIRE_TRY(provider.GetId(record.self, &transfer->self));\n    transfer->x = record.x;\n    transfer->y = record.y;\n    transfer->width = record.width;\n    transfer->height = record.height;\n    transfer->minDepth = record.minDepth;\n    transfer->maxDepth = record.maxDepth;\n\n    return WireResult::Success;\n}\nDAWN_UNUSED_FUNC(RenderPassEncoderSetViewportSerialize);\n\nDAWN_DECLARE_UNUSED WireResult RenderPassEncoderSetViewportDeserialize(\n    RenderPassEncoderSetViewportCmd* record,\n    const volatile RenderPassEncoderSetViewportTransfer* transfer,\n    DeserializeBuffer* deserializeBuffer,\n    DeserializeAllocator* allocator, const ObjectIdResolver& resolver) {\n    DAWN_UNUSED(allocator);\n\n    ASSERT(transfer->commandId == WireCmd::RenderPassEncoderSetViewport);\n    record->selfId = transfer->self;\n\n\n    WIRE_TRY(resolver.GetFromId(transfer->self, &record->self));\n    static_assert(sizeof(record->x) >= sizeof(transfer->x), \"Deserialize assignment may not narrow.\");\n    record->x = transfer->x;\n    static_assert(sizeof(record->y) >= sizeof(transfer->y), \"Deserialize assignment may not narrow.\");\n    record->y = transfer->y;\n    static_assert(sizeof(record->width) >= sizeof(transfer->width), \"Deserialize assignment may not narrow.\");\n    record->width = transfer->width;\n    static_assert(sizeof(record->height) >= sizeof(transfer->height), \"Deserialize assignment may not narrow.\");\n    record->height = transfer->height;\n    static_assert(sizeof(record->minDepth) >= sizeof(transfer->minDepth), \"Deserialize assignment may not narrow.\");\n    record->minDepth = transfer->minDepth;\n    static_assert(sizeof(record->maxDepth) >= sizeof(transfer->maxDepth), \"Deserialize assignment may not narrow.\");\n    record->maxDepth = transfer->maxDepth;\n\n    return WireResult::Success;\n}\nDAWN_UNUSED_FUNC(RenderPassEncoderSetViewportDeserialize);\n\nstruct RenderPassEncoderWriteTimestampTransfer : CmdHeader {\n    static_assert(1 <= 1,\n                  \"Record must be at most one of is_cmd, extensible, and chained.\");\n    WireCmd commandId;\n\n    ObjectId self;\n    ObjectId querySet;\n    uint32_t queryIndex;\n};\n\nstatic_assert(offsetof(RenderPassEncoderWriteTimestampTransfer, commandSize) == 0);\nstatic_assert(offsetof(RenderPassEncoderWriteTimestampTransfer, commandId) == sizeof(CmdHeader));\n\nDAWN_DECLARE_UNUSED size_t RenderPassEncoderWriteTimestampGetExtraRequiredSize(const RenderPassEncoderWriteTimestampCmd& record) {\n    DAWN_UNUSED(record);\n    size_t result = 0;\n\n    return result;\n}\n// GetExtraRequiredSize isn't used for structures that are value members of other structures\n// because we assume they cannot contain pointers themselves.\nDAWN_UNUSED_FUNC(RenderPassEncoderWriteTimestampGetExtraRequiredSize);\n\nDAWN_DECLARE_UNUSED WireResult RenderPassEncoderWriteTimestampSerialize(\n    const RenderPassEncoderWriteTimestampCmd& record,\n    RenderPassEncoderWriteTimestampTransfer* transfer,\n    SerializeBuffer* buffer, const ObjectIdProvider& provider) {\n    DAWN_UNUSED(buffer);\n    transfer->commandId = WireCmd::RenderPassEncoderWriteTimestamp;\n\n\n    WIRE_TRY(provider.GetId(record.self, &transfer->self));\n    WIRE_TRY(provider.GetId(record.querySet, &transfer->querySet));\n    transfer->queryIndex = record.queryIndex;\n\n    return WireResult::Success;\n}\nDAWN_UNUSED_FUNC(RenderPassEncoderWriteTimestampSerialize);\n\nDAWN_DECLARE_UNUSED WireResult RenderPassEncoderWriteTimestampDeserialize(\n    RenderPassEncoderWriteTimestampCmd* record,\n    const volatile RenderPassEncoderWriteTimestampTransfer* transfer,\n    DeserializeBuffer* deserializeBuffer,\n    DeserializeAllocator* allocator, const ObjectIdResolver& resolver) {\n    DAWN_UNUSED(allocator);\n\n    ASSERT(transfer->commandId == WireCmd::RenderPassEncoderWriteTimestamp);\n    record->selfId = transfer->self;\n\n\n    WIRE_TRY(resolver.GetFromId(transfer->self, &record->self));\n    WIRE_TRY(resolver.GetFromId(transfer->querySet, &record->querySet));\n    static_assert(sizeof(record->queryIndex) >= sizeof(transfer->queryIndex), \"Deserialize assignment may not narrow.\");\n    record->queryIndex = transfer->queryIndex;\n\n    return WireResult::Success;\n}\nDAWN_UNUSED_FUNC(RenderPassEncoderWriteTimestampDeserialize);\n\nstruct RenderPipelineGetBindGroupLayoutTransfer : CmdHeader {\n    static_assert(1 <= 1,\n                  \"Record must be at most one of is_cmd, extensible, and chained.\");\n    WireCmd commandId;\n\n    ObjectId self;\n    uint32_t groupIndex;\n    ObjectHandle result;\n};\n\nstatic_assert(offsetof(RenderPipelineGetBindGroupLayoutTransfer, commandSize) == 0);\nstatic_assert(offsetof(RenderPipelineGetBindGroupLayoutTransfer, commandId) == sizeof(CmdHeader));\n\nDAWN_DECLARE_UNUSED size_t RenderPipelineGetBindGroupLayoutGetExtraRequiredSize(const RenderPipelineGetBindGroupLayoutCmd& record) {\n    DAWN_UNUSED(record);\n    size_t result = 0;\n\n    return result;\n}\n// GetExtraRequiredSize isn't used for structures that are value members of other structures\n// because we assume they cannot contain pointers themselves.\nDAWN_UNUSED_FUNC(RenderPipelineGetBindGroupLayoutGetExtraRequiredSize);\n\nDAWN_DECLARE_UNUSED WireResult RenderPipelineGetBindGroupLayoutSerialize(\n    const RenderPipelineGetBindGroupLayoutCmd& record,\n    RenderPipelineGetBindGroupLayoutTransfer* transfer,\n    SerializeBuffer* buffer, const ObjectIdProvider& provider) {\n    DAWN_UNUSED(buffer);\n    transfer->commandId = WireCmd::RenderPipelineGetBindGroupLayout;\n\n\n    WIRE_TRY(provider.GetId(record.self, &transfer->self));\n    transfer->groupIndex = record.groupIndex;\n    transfer->result = record.result;\n\n    return WireResult::Success;\n}\nDAWN_UNUSED_FUNC(RenderPipelineGetBindGroupLayoutSerialize);\n\nDAWN_DECLARE_UNUSED WireResult RenderPipelineGetBindGroupLayoutDeserialize(\n    RenderPipelineGetBindGroupLayoutCmd* record,\n    const volatile RenderPipelineGetBindGroupLayoutTransfer* transfer,\n    DeserializeBuffer* deserializeBuffer,\n    DeserializeAllocator* allocator, const ObjectIdResolver& resolver) {\n    DAWN_UNUSED(allocator);\n\n    ASSERT(transfer->commandId == WireCmd::RenderPipelineGetBindGroupLayout);\n    record->selfId = transfer->self;\n\n\n    WIRE_TRY(resolver.GetFromId(transfer->self, &record->self));\n    static_assert(sizeof(record->groupIndex) >= sizeof(transfer->groupIndex), \"Deserialize assignment may not narrow.\");\n    record->groupIndex = transfer->groupIndex;\n    static_assert(sizeof(record->result) >= sizeof(transfer->result), \"Deserialize assignment may not narrow.\");\n    record->result = transfer->result;\n\n    return WireResult::Success;\n}\nDAWN_UNUSED_FUNC(RenderPipelineGetBindGroupLayoutDeserialize);\n\nstruct RenderPipelineSetLabelTransfer : CmdHeader {\n    static_assert(1 <= 1,\n                  \"Record must be at most one of is_cmd, extensible, and chained.\");\n    WireCmd commandId;\n\n    ObjectId self;\n    uint64_t labelStrlen;\n};\n\nstatic_assert(offsetof(RenderPipelineSetLabelTransfer, commandSize) == 0);\nstatic_assert(offsetof(RenderPipelineSetLabelTransfer, commandId) == sizeof(CmdHeader));\n\nDAWN_DECLARE_UNUSED size_t RenderPipelineSetLabelGetExtraRequiredSize(const RenderPipelineSetLabelCmd& record) {\n    DAWN_UNUSED(record);\n    size_t result = 0;\n\n    ASSERT(record.label != nullptr);\n    result += Align(std::strlen(record.label), kWireBufferAlignment);\n    return result;\n}\n// GetExtraRequiredSize isn't used for structures that are value members of other structures\n// because we assume they cannot contain pointers themselves.\nDAWN_UNUSED_FUNC(RenderPipelineSetLabelGetExtraRequiredSize);\n\nDAWN_DECLARE_UNUSED WireResult RenderPipelineSetLabelSerialize(\n    const RenderPipelineSetLabelCmd& record,\n    RenderPipelineSetLabelTransfer* transfer,\n    SerializeBuffer* buffer, const ObjectIdProvider& provider) {\n    DAWN_UNUSED(buffer);\n    transfer->commandId = WireCmd::RenderPipelineSetLabel;\n\n\n    WIRE_TRY(provider.GetId(record.self, &transfer->self));\n    {\n        transfer->labelStrlen = std::strlen(record.label);\n\n        char* stringInBuffer;\n        WIRE_TRY(buffer->NextN(transfer->labelStrlen, &stringInBuffer));\n        memcpy(stringInBuffer, record.label, transfer->labelStrlen);\n    }\n\n    return WireResult::Success;\n}\nDAWN_UNUSED_FUNC(RenderPipelineSetLabelSerialize);\n\nDAWN_DECLARE_UNUSED WireResult RenderPipelineSetLabelDeserialize(\n    RenderPipelineSetLabelCmd* record,\n    const volatile RenderPipelineSetLabelTransfer* transfer,\n    DeserializeBuffer* deserializeBuffer,\n    DeserializeAllocator* allocator, const ObjectIdResolver& resolver) {\n    DAWN_UNUSED(allocator);\n\n    ASSERT(transfer->commandId == WireCmd::RenderPipelineSetLabel);\n    record->selfId = transfer->self;\n\n\n    WIRE_TRY(resolver.GetFromId(transfer->self, &record->self));\n    {\n        uint64_t stringLength64 = transfer->labelStrlen;\n        if (stringLength64 >= std::numeric_limits<size_t>::max()) {\n            return WireResult::FatalError;\n        }\n        size_t stringLength = static_cast<size_t>(stringLength64);\n\n        const volatile char* stringInBuffer;\n        WIRE_TRY(deserializeBuffer->ReadN(stringLength, &stringInBuffer));\n\n        char* copiedString;\n        WIRE_TRY(GetSpace(allocator, stringLength + 1, &copiedString));\n        memcpy(copiedString, const_cast<const char*>(stringInBuffer), stringLength);\n        copiedString[stringLength] = '\\0';\n        record->label = copiedString;\n    }\n\n    return WireResult::Success;\n}\nDAWN_UNUSED_FUNC(RenderPipelineSetLabelDeserialize);\n\nstruct SamplerSetLabelTransfer : CmdHeader {\n    static_assert(1 <= 1,\n                  \"Record must be at most one of is_cmd, extensible, and chained.\");\n    WireCmd commandId;\n\n    ObjectId self;\n    uint64_t labelStrlen;\n};\n\nstatic_assert(offsetof(SamplerSetLabelTransfer, commandSize) == 0);\nstatic_assert(offsetof(SamplerSetLabelTransfer, commandId) == sizeof(CmdHeader));\n\nDAWN_DECLARE_UNUSED size_t SamplerSetLabelGetExtraRequiredSize(const SamplerSetLabelCmd& record) {\n    DAWN_UNUSED(record);\n    size_t result = 0;\n\n    ASSERT(record.label != nullptr);\n    result += Align(std::strlen(record.label), kWireBufferAlignment);\n    return result;\n}\n// GetExtraRequiredSize isn't used for structures that are value members of other structures\n// because we assume they cannot contain pointers themselves.\nDAWN_UNUSED_FUNC(SamplerSetLabelGetExtraRequiredSize);\n\nDAWN_DECLARE_UNUSED WireResult SamplerSetLabelSerialize(\n    const SamplerSetLabelCmd& record,\n    SamplerSetLabelTransfer* transfer,\n    SerializeBuffer* buffer, const ObjectIdProvider& provider) {\n    DAWN_UNUSED(buffer);\n    transfer->commandId = WireCmd::SamplerSetLabel;\n\n\n    WIRE_TRY(provider.GetId(record.self, &transfer->self));\n    {\n        transfer->labelStrlen = std::strlen(record.label);\n\n        char* stringInBuffer;\n        WIRE_TRY(buffer->NextN(transfer->labelStrlen, &stringInBuffer));\n        memcpy(stringInBuffer, record.label, transfer->labelStrlen);\n    }\n\n    return WireResult::Success;\n}\nDAWN_UNUSED_FUNC(SamplerSetLabelSerialize);\n\nDAWN_DECLARE_UNUSED WireResult SamplerSetLabelDeserialize(\n    SamplerSetLabelCmd* record,\n    const volatile SamplerSetLabelTransfer* transfer,\n    DeserializeBuffer* deserializeBuffer,\n    DeserializeAllocator* allocator, const ObjectIdResolver& resolver) {\n    DAWN_UNUSED(allocator);\n\n    ASSERT(transfer->commandId == WireCmd::SamplerSetLabel);\n    record->selfId = transfer->self;\n\n\n    WIRE_TRY(resolver.GetFromId(transfer->self, &record->self));\n    {\n        uint64_t stringLength64 = transfer->labelStrlen;\n        if (stringLength64 >= std::numeric_limits<size_t>::max()) {\n            return WireResult::FatalError;\n        }\n        size_t stringLength = static_cast<size_t>(stringLength64);\n\n        const volatile char* stringInBuffer;\n        WIRE_TRY(deserializeBuffer->ReadN(stringLength, &stringInBuffer));\n\n        char* copiedString;\n        WIRE_TRY(GetSpace(allocator, stringLength + 1, &copiedString));\n        memcpy(copiedString, const_cast<const char*>(stringInBuffer), stringLength);\n        copiedString[stringLength] = '\\0';\n        record->label = copiedString;\n    }\n\n    return WireResult::Success;\n}\nDAWN_UNUSED_FUNC(SamplerSetLabelDeserialize);\n\nstruct ShaderModuleGetCompilationInfoTransfer : CmdHeader {\n    static_assert(1 <= 1,\n                  \"Record must be at most one of is_cmd, extensible, and chained.\");\n    WireCmd commandId;\n\n    ObjectId shaderModuleId;\n    uint64_t requestSerial;\n};\n\nstatic_assert(offsetof(ShaderModuleGetCompilationInfoTransfer, commandSize) == 0);\nstatic_assert(offsetof(ShaderModuleGetCompilationInfoTransfer, commandId) == sizeof(CmdHeader));\n\nDAWN_DECLARE_UNUSED size_t ShaderModuleGetCompilationInfoGetExtraRequiredSize(const ShaderModuleGetCompilationInfoCmd& record) {\n    DAWN_UNUSED(record);\n    size_t result = 0;\n\n    return result;\n}\n// GetExtraRequiredSize isn't used for structures that are value members of other structures\n// because we assume they cannot contain pointers themselves.\nDAWN_UNUSED_FUNC(ShaderModuleGetCompilationInfoGetExtraRequiredSize);\n\nDAWN_DECLARE_UNUSED WireResult ShaderModuleGetCompilationInfoSerialize(\n    const ShaderModuleGetCompilationInfoCmd& record,\n    ShaderModuleGetCompilationInfoTransfer* transfer,\n    SerializeBuffer* buffer) {\n    DAWN_UNUSED(buffer);\n    transfer->commandId = WireCmd::ShaderModuleGetCompilationInfo;\n\n\n    transfer->shaderModuleId = record.shaderModuleId;\n    transfer->requestSerial = record.requestSerial;\n\n    return WireResult::Success;\n}\nDAWN_UNUSED_FUNC(ShaderModuleGetCompilationInfoSerialize);\n\nDAWN_DECLARE_UNUSED WireResult ShaderModuleGetCompilationInfoDeserialize(\n    ShaderModuleGetCompilationInfoCmd* record,\n    const volatile ShaderModuleGetCompilationInfoTransfer* transfer,\n    DeserializeBuffer* deserializeBuffer,\n    DeserializeAllocator* allocator) {\n    DAWN_UNUSED(allocator);\n\n    ASSERT(transfer->commandId == WireCmd::ShaderModuleGetCompilationInfo);\n\n\n    static_assert(sizeof(record->shaderModuleId) >= sizeof(transfer->shaderModuleId), \"Deserialize assignment may not narrow.\");\n    record->shaderModuleId = transfer->shaderModuleId;\n    static_assert(sizeof(record->requestSerial) >= sizeof(transfer->requestSerial), \"Deserialize assignment may not narrow.\");\n    record->requestSerial = transfer->requestSerial;\n\n    return WireResult::Success;\n}\nDAWN_UNUSED_FUNC(ShaderModuleGetCompilationInfoDeserialize);\n\nstruct ShaderModuleSetLabelTransfer : CmdHeader {\n    static_assert(1 <= 1,\n                  \"Record must be at most one of is_cmd, extensible, and chained.\");\n    WireCmd commandId;\n\n    ObjectId self;\n    uint64_t labelStrlen;\n};\n\nstatic_assert(offsetof(ShaderModuleSetLabelTransfer, commandSize) == 0);\nstatic_assert(offsetof(ShaderModuleSetLabelTransfer, commandId) == sizeof(CmdHeader));\n\nDAWN_DECLARE_UNUSED size_t ShaderModuleSetLabelGetExtraRequiredSize(const ShaderModuleSetLabelCmd& record) {\n    DAWN_UNUSED(record);\n    size_t result = 0;\n\n    ASSERT(record.label != nullptr);\n    result += Align(std::strlen(record.label), kWireBufferAlignment);\n    return result;\n}\n// GetExtraRequiredSize isn't used for structures that are value members of other structures\n// because we assume they cannot contain pointers themselves.\nDAWN_UNUSED_FUNC(ShaderModuleSetLabelGetExtraRequiredSize);\n\nDAWN_DECLARE_UNUSED WireResult ShaderModuleSetLabelSerialize(\n    const ShaderModuleSetLabelCmd& record,\n    ShaderModuleSetLabelTransfer* transfer,\n    SerializeBuffer* buffer, const ObjectIdProvider& provider) {\n    DAWN_UNUSED(buffer);\n    transfer->commandId = WireCmd::ShaderModuleSetLabel;\n\n\n    WIRE_TRY(provider.GetId(record.self, &transfer->self));\n    {\n        transfer->labelStrlen = std::strlen(record.label);\n\n        char* stringInBuffer;\n        WIRE_TRY(buffer->NextN(transfer->labelStrlen, &stringInBuffer));\n        memcpy(stringInBuffer, record.label, transfer->labelStrlen);\n    }\n\n    return WireResult::Success;\n}\nDAWN_UNUSED_FUNC(ShaderModuleSetLabelSerialize);\n\nDAWN_DECLARE_UNUSED WireResult ShaderModuleSetLabelDeserialize(\n    ShaderModuleSetLabelCmd* record,\n    const volatile ShaderModuleSetLabelTransfer* transfer,\n    DeserializeBuffer* deserializeBuffer,\n    DeserializeAllocator* allocator, const ObjectIdResolver& resolver) {\n    DAWN_UNUSED(allocator);\n\n    ASSERT(transfer->commandId == WireCmd::ShaderModuleSetLabel);\n    record->selfId = transfer->self;\n\n\n    WIRE_TRY(resolver.GetFromId(transfer->self, &record->self));\n    {\n        uint64_t stringLength64 = transfer->labelStrlen;\n        if (stringLength64 >= std::numeric_limits<size_t>::max()) {\n            return WireResult::FatalError;\n        }\n        size_t stringLength = static_cast<size_t>(stringLength64);\n\n        const volatile char* stringInBuffer;\n        WIRE_TRY(deserializeBuffer->ReadN(stringLength, &stringInBuffer));\n\n        char* copiedString;\n        WIRE_TRY(GetSpace(allocator, stringLength + 1, &copiedString));\n        memcpy(copiedString, const_cast<const char*>(stringInBuffer), stringLength);\n        copiedString[stringLength] = '\\0';\n        record->label = copiedString;\n    }\n\n    return WireResult::Success;\n}\nDAWN_UNUSED_FUNC(ShaderModuleSetLabelDeserialize);\n\nstruct SwapChainGetCurrentTextureTransfer : CmdHeader {\n    static_assert(1 <= 1,\n                  \"Record must be at most one of is_cmd, extensible, and chained.\");\n    WireCmd commandId;\n\n    ObjectId self;\n    ObjectHandle result;\n};\n\nstatic_assert(offsetof(SwapChainGetCurrentTextureTransfer, commandSize) == 0);\nstatic_assert(offsetof(SwapChainGetCurrentTextureTransfer, commandId) == sizeof(CmdHeader));\n\nDAWN_DECLARE_UNUSED size_t SwapChainGetCurrentTextureGetExtraRequiredSize(const SwapChainGetCurrentTextureCmd& record) {\n    DAWN_UNUSED(record);\n    size_t result = 0;\n\n    return result;\n}\n// GetExtraRequiredSize isn't used for structures that are value members of other structures\n// because we assume they cannot contain pointers themselves.\nDAWN_UNUSED_FUNC(SwapChainGetCurrentTextureGetExtraRequiredSize);\n\nDAWN_DECLARE_UNUSED WireResult SwapChainGetCurrentTextureSerialize(\n    const SwapChainGetCurrentTextureCmd& record,\n    SwapChainGetCurrentTextureTransfer* transfer,\n    SerializeBuffer* buffer, const ObjectIdProvider& provider) {\n    DAWN_UNUSED(buffer);\n    transfer->commandId = WireCmd::SwapChainGetCurrentTexture;\n\n\n    WIRE_TRY(provider.GetId(record.self, &transfer->self));\n    transfer->result = record.result;\n\n    return WireResult::Success;\n}\nDAWN_UNUSED_FUNC(SwapChainGetCurrentTextureSerialize);\n\nDAWN_DECLARE_UNUSED WireResult SwapChainGetCurrentTextureDeserialize(\n    SwapChainGetCurrentTextureCmd* record,\n    const volatile SwapChainGetCurrentTextureTransfer* transfer,\n    DeserializeBuffer* deserializeBuffer,\n    DeserializeAllocator* allocator, const ObjectIdResolver& resolver) {\n    DAWN_UNUSED(allocator);\n\n    ASSERT(transfer->commandId == WireCmd::SwapChainGetCurrentTexture);\n    record->selfId = transfer->self;\n\n\n    WIRE_TRY(resolver.GetFromId(transfer->self, &record->self));\n    static_assert(sizeof(record->result) >= sizeof(transfer->result), \"Deserialize assignment may not narrow.\");\n    record->result = transfer->result;\n\n    return WireResult::Success;\n}\nDAWN_UNUSED_FUNC(SwapChainGetCurrentTextureDeserialize);\n\nstruct SwapChainGetCurrentTextureViewTransfer : CmdHeader {\n    static_assert(1 <= 1,\n                  \"Record must be at most one of is_cmd, extensible, and chained.\");\n    WireCmd commandId;\n\n    ObjectId self;\n    ObjectHandle result;\n};\n\nstatic_assert(offsetof(SwapChainGetCurrentTextureViewTransfer, commandSize) == 0);\nstatic_assert(offsetof(SwapChainGetCurrentTextureViewTransfer, commandId) == sizeof(CmdHeader));\n\nDAWN_DECLARE_UNUSED size_t SwapChainGetCurrentTextureViewGetExtraRequiredSize(const SwapChainGetCurrentTextureViewCmd& record) {\n    DAWN_UNUSED(record);\n    size_t result = 0;\n\n    return result;\n}\n// GetExtraRequiredSize isn't used for structures that are value members of other structures\n// because we assume they cannot contain pointers themselves.\nDAWN_UNUSED_FUNC(SwapChainGetCurrentTextureViewGetExtraRequiredSize);\n\nDAWN_DECLARE_UNUSED WireResult SwapChainGetCurrentTextureViewSerialize(\n    const SwapChainGetCurrentTextureViewCmd& record,\n    SwapChainGetCurrentTextureViewTransfer* transfer,\n    SerializeBuffer* buffer, const ObjectIdProvider& provider) {\n    DAWN_UNUSED(buffer);\n    transfer->commandId = WireCmd::SwapChainGetCurrentTextureView;\n\n\n    WIRE_TRY(provider.GetId(record.self, &transfer->self));\n    transfer->result = record.result;\n\n    return WireResult::Success;\n}\nDAWN_UNUSED_FUNC(SwapChainGetCurrentTextureViewSerialize);\n\nDAWN_DECLARE_UNUSED WireResult SwapChainGetCurrentTextureViewDeserialize(\n    SwapChainGetCurrentTextureViewCmd* record,\n    const volatile SwapChainGetCurrentTextureViewTransfer* transfer,\n    DeserializeBuffer* deserializeBuffer,\n    DeserializeAllocator* allocator, const ObjectIdResolver& resolver) {\n    DAWN_UNUSED(allocator);\n\n    ASSERT(transfer->commandId == WireCmd::SwapChainGetCurrentTextureView);\n    record->selfId = transfer->self;\n\n\n    WIRE_TRY(resolver.GetFromId(transfer->self, &record->self));\n    static_assert(sizeof(record->result) >= sizeof(transfer->result), \"Deserialize assignment may not narrow.\");\n    record->result = transfer->result;\n\n    return WireResult::Success;\n}\nDAWN_UNUSED_FUNC(SwapChainGetCurrentTextureViewDeserialize);\n\nstruct SwapChainPresentTransfer : CmdHeader {\n    static_assert(1 <= 1,\n                  \"Record must be at most one of is_cmd, extensible, and chained.\");\n    WireCmd commandId;\n\n    ObjectId self;\n};\n\nstatic_assert(offsetof(SwapChainPresentTransfer, commandSize) == 0);\nstatic_assert(offsetof(SwapChainPresentTransfer, commandId) == sizeof(CmdHeader));\n\nDAWN_DECLARE_UNUSED size_t SwapChainPresentGetExtraRequiredSize(const SwapChainPresentCmd& record) {\n    DAWN_UNUSED(record);\n    size_t result = 0;\n\n    return result;\n}\n// GetExtraRequiredSize isn't used for structures that are value members of other structures\n// because we assume they cannot contain pointers themselves.\nDAWN_UNUSED_FUNC(SwapChainPresentGetExtraRequiredSize);\n\nDAWN_DECLARE_UNUSED WireResult SwapChainPresentSerialize(\n    const SwapChainPresentCmd& record,\n    SwapChainPresentTransfer* transfer,\n    SerializeBuffer* buffer, const ObjectIdProvider& provider) {\n    DAWN_UNUSED(buffer);\n    transfer->commandId = WireCmd::SwapChainPresent;\n\n\n    WIRE_TRY(provider.GetId(record.self, &transfer->self));\n\n    return WireResult::Success;\n}\nDAWN_UNUSED_FUNC(SwapChainPresentSerialize);\n\nDAWN_DECLARE_UNUSED WireResult SwapChainPresentDeserialize(\n    SwapChainPresentCmd* record,\n    const volatile SwapChainPresentTransfer* transfer,\n    DeserializeBuffer* deserializeBuffer,\n    DeserializeAllocator* allocator, const ObjectIdResolver& resolver) {\n    DAWN_UNUSED(allocator);\n\n    ASSERT(transfer->commandId == WireCmd::SwapChainPresent);\n    record->selfId = transfer->self;\n\n\n    WIRE_TRY(resolver.GetFromId(transfer->self, &record->self));\n\n    return WireResult::Success;\n}\nDAWN_UNUSED_FUNC(SwapChainPresentDeserialize);\n\nstruct TextureCreateViewTransfer : CmdHeader {\n    static_assert(1 <= 1,\n                  \"Record must be at most one of is_cmd, extensible, and chained.\");\n    WireCmd commandId;\n\n    ObjectId self;\n    bool has_descriptor;\n    ObjectHandle result;\n};\n\nstatic_assert(offsetof(TextureCreateViewTransfer, commandSize) == 0);\nstatic_assert(offsetof(TextureCreateViewTransfer, commandId) == sizeof(CmdHeader));\n\nDAWN_DECLARE_UNUSED size_t TextureCreateViewGetExtraRequiredSize(const TextureCreateViewCmd& record) {\n    DAWN_UNUSED(record);\n    size_t result = 0;\n\n    if (record.descriptor != nullptr) {\n        auto memberLength = 1u;\n        auto size = WireAlignSizeofN<WGPUTextureViewDescriptorTransfer>(memberLength);\n        ASSERT(size);\n        result += *size;\n        for (decltype(memberLength) i = 0; i < memberLength; ++i) {\n            result += WGPUTextureViewDescriptorGetExtraRequiredSize(record.descriptor[i]);\n        }\n    }\n    return result;\n}\n// GetExtraRequiredSize isn't used for structures that are value members of other structures\n// because we assume they cannot contain pointers themselves.\nDAWN_UNUSED_FUNC(TextureCreateViewGetExtraRequiredSize);\n\nDAWN_DECLARE_UNUSED WireResult TextureCreateViewSerialize(\n    const TextureCreateViewCmd& record,\n    TextureCreateViewTransfer* transfer,\n    SerializeBuffer* buffer, const ObjectIdProvider& provider) {\n    DAWN_UNUSED(buffer);\n    transfer->commandId = WireCmd::TextureCreateView;\n\n\n    WIRE_TRY(provider.GetId(record.self, &transfer->self));\n    transfer->result = record.result;\n    bool has_descriptor = record.descriptor != nullptr;\n    transfer->has_descriptor = has_descriptor;\n    if (has_descriptor) {\n        auto memberLength = 1u;\n\n        WGPUTextureViewDescriptorTransfer* memberBuffer;\n        WIRE_TRY(buffer->NextN(memberLength, &memberBuffer));\n\n        for (decltype(memberLength) i = 0; i < memberLength; ++i) {\n            WIRE_TRY(WGPUTextureViewDescriptorSerialize(record.descriptor[i], &memberBuffer[i], buffer, provider));\n        }\n    }\n\n    return WireResult::Success;\n}\nDAWN_UNUSED_FUNC(TextureCreateViewSerialize);\n\nDAWN_DECLARE_UNUSED WireResult TextureCreateViewDeserialize(\n    TextureCreateViewCmd* record,\n    const volatile TextureCreateViewTransfer* transfer,\n    DeserializeBuffer* deserializeBuffer,\n    DeserializeAllocator* allocator, const ObjectIdResolver& resolver) {\n    DAWN_UNUSED(allocator);\n\n    ASSERT(transfer->commandId == WireCmd::TextureCreateView);\n    record->selfId = transfer->self;\n\n\n    WIRE_TRY(resolver.GetFromId(transfer->self, &record->self));\n    static_assert(sizeof(record->result) >= sizeof(transfer->result), \"Deserialize assignment may not narrow.\");\n    record->result = transfer->result;\n    bool has_descriptor = transfer->has_descriptor;\n    record->descriptor = nullptr;\n    if (has_descriptor) {\n        auto memberLength = 1u;\n        const volatile WGPUTextureViewDescriptorTransfer* memberBuffer;\n        WIRE_TRY(deserializeBuffer->ReadN(memberLength, &memberBuffer));\n\n        WGPUTextureViewDescriptor* copiedMembers;\n        WIRE_TRY(GetSpace(allocator, memberLength, &copiedMembers));\n        record->descriptor = copiedMembers;\n\n        for (decltype(memberLength) i = 0; i < memberLength; ++i) {\n            WIRE_TRY(WGPUTextureViewDescriptorDeserialize(&copiedMembers[i], &memberBuffer[i], deserializeBuffer, allocator, resolver));\n        }\n    }\n\n    return WireResult::Success;\n}\nDAWN_UNUSED_FUNC(TextureCreateViewDeserialize);\n\nstruct TextureDestroyTransfer : CmdHeader {\n    static_assert(1 <= 1,\n                  \"Record must be at most one of is_cmd, extensible, and chained.\");\n    WireCmd commandId;\n\n    ObjectId self;\n};\n\nstatic_assert(offsetof(TextureDestroyTransfer, commandSize) == 0);\nstatic_assert(offsetof(TextureDestroyTransfer, commandId) == sizeof(CmdHeader));\n\nDAWN_DECLARE_UNUSED size_t TextureDestroyGetExtraRequiredSize(const TextureDestroyCmd& record) {\n    DAWN_UNUSED(record);\n    size_t result = 0;\n\n    return result;\n}\n// GetExtraRequiredSize isn't used for structures that are value members of other structures\n// because we assume they cannot contain pointers themselves.\nDAWN_UNUSED_FUNC(TextureDestroyGetExtraRequiredSize);\n\nDAWN_DECLARE_UNUSED WireResult TextureDestroySerialize(\n    const TextureDestroyCmd& record,\n    TextureDestroyTransfer* transfer,\n    SerializeBuffer* buffer, const ObjectIdProvider& provider) {\n    DAWN_UNUSED(buffer);\n    transfer->commandId = WireCmd::TextureDestroy;\n\n\n    WIRE_TRY(provider.GetId(record.self, &transfer->self));\n\n    return WireResult::Success;\n}\nDAWN_UNUSED_FUNC(TextureDestroySerialize);\n\nDAWN_DECLARE_UNUSED WireResult TextureDestroyDeserialize(\n    TextureDestroyCmd* record,\n    const volatile TextureDestroyTransfer* transfer,\n    DeserializeBuffer* deserializeBuffer,\n    DeserializeAllocator* allocator, const ObjectIdResolver& resolver) {\n    DAWN_UNUSED(allocator);\n\n    ASSERT(transfer->commandId == WireCmd::TextureDestroy);\n    record->selfId = transfer->self;\n\n\n    WIRE_TRY(resolver.GetFromId(transfer->self, &record->self));\n\n    return WireResult::Success;\n}\nDAWN_UNUSED_FUNC(TextureDestroyDeserialize);\n\nstruct TextureSetLabelTransfer : CmdHeader {\n    static_assert(1 <= 1,\n                  \"Record must be at most one of is_cmd, extensible, and chained.\");\n    WireCmd commandId;\n\n    ObjectId self;\n    uint64_t labelStrlen;\n};\n\nstatic_assert(offsetof(TextureSetLabelTransfer, commandSize) == 0);\nstatic_assert(offsetof(TextureSetLabelTransfer, commandId) == sizeof(CmdHeader));\n\nDAWN_DECLARE_UNUSED size_t TextureSetLabelGetExtraRequiredSize(const TextureSetLabelCmd& record) {\n    DAWN_UNUSED(record);\n    size_t result = 0;\n\n    ASSERT(record.label != nullptr);\n    result += Align(std::strlen(record.label), kWireBufferAlignment);\n    return result;\n}\n// GetExtraRequiredSize isn't used for structures that are value members of other structures\n// because we assume they cannot contain pointers themselves.\nDAWN_UNUSED_FUNC(TextureSetLabelGetExtraRequiredSize);\n\nDAWN_DECLARE_UNUSED WireResult TextureSetLabelSerialize(\n    const TextureSetLabelCmd& record,\n    TextureSetLabelTransfer* transfer,\n    SerializeBuffer* buffer, const ObjectIdProvider& provider) {\n    DAWN_UNUSED(buffer);\n    transfer->commandId = WireCmd::TextureSetLabel;\n\n\n    WIRE_TRY(provider.GetId(record.self, &transfer->self));\n    {\n        transfer->labelStrlen = std::strlen(record.label);\n\n        char* stringInBuffer;\n        WIRE_TRY(buffer->NextN(transfer->labelStrlen, &stringInBuffer));\n        memcpy(stringInBuffer, record.label, transfer->labelStrlen);\n    }\n\n    return WireResult::Success;\n}\nDAWN_UNUSED_FUNC(TextureSetLabelSerialize);\n\nDAWN_DECLARE_UNUSED WireResult TextureSetLabelDeserialize(\n    TextureSetLabelCmd* record,\n    const volatile TextureSetLabelTransfer* transfer,\n    DeserializeBuffer* deserializeBuffer,\n    DeserializeAllocator* allocator, const ObjectIdResolver& resolver) {\n    DAWN_UNUSED(allocator);\n\n    ASSERT(transfer->commandId == WireCmd::TextureSetLabel);\n    record->selfId = transfer->self;\n\n\n    WIRE_TRY(resolver.GetFromId(transfer->self, &record->self));\n    {\n        uint64_t stringLength64 = transfer->labelStrlen;\n        if (stringLength64 >= std::numeric_limits<size_t>::max()) {\n            return WireResult::FatalError;\n        }\n        size_t stringLength = static_cast<size_t>(stringLength64);\n\n        const volatile char* stringInBuffer;\n        WIRE_TRY(deserializeBuffer->ReadN(stringLength, &stringInBuffer));\n\n        char* copiedString;\n        WIRE_TRY(GetSpace(allocator, stringLength + 1, &copiedString));\n        memcpy(copiedString, const_cast<const char*>(stringInBuffer), stringLength);\n        copiedString[stringLength] = '\\0';\n        record->label = copiedString;\n    }\n\n    return WireResult::Success;\n}\nDAWN_UNUSED_FUNC(TextureSetLabelDeserialize);\n\nstruct TextureViewSetLabelTransfer : CmdHeader {\n    static_assert(1 <= 1,\n                  \"Record must be at most one of is_cmd, extensible, and chained.\");\n    WireCmd commandId;\n\n    ObjectId self;\n    uint64_t labelStrlen;\n};\n\nstatic_assert(offsetof(TextureViewSetLabelTransfer, commandSize) == 0);\nstatic_assert(offsetof(TextureViewSetLabelTransfer, commandId) == sizeof(CmdHeader));\n\nDAWN_DECLARE_UNUSED size_t TextureViewSetLabelGetExtraRequiredSize(const TextureViewSetLabelCmd& record) {\n    DAWN_UNUSED(record);\n    size_t result = 0;\n\n    ASSERT(record.label != nullptr);\n    result += Align(std::strlen(record.label), kWireBufferAlignment);\n    return result;\n}\n// GetExtraRequiredSize isn't used for structures that are value members of other structures\n// because we assume they cannot contain pointers themselves.\nDAWN_UNUSED_FUNC(TextureViewSetLabelGetExtraRequiredSize);\n\nDAWN_DECLARE_UNUSED WireResult TextureViewSetLabelSerialize(\n    const TextureViewSetLabelCmd& record,\n    TextureViewSetLabelTransfer* transfer,\n    SerializeBuffer* buffer, const ObjectIdProvider& provider) {\n    DAWN_UNUSED(buffer);\n    transfer->commandId = WireCmd::TextureViewSetLabel;\n\n\n    WIRE_TRY(provider.GetId(record.self, &transfer->self));\n    {\n        transfer->labelStrlen = std::strlen(record.label);\n\n        char* stringInBuffer;\n        WIRE_TRY(buffer->NextN(transfer->labelStrlen, &stringInBuffer));\n        memcpy(stringInBuffer, record.label, transfer->labelStrlen);\n    }\n\n    return WireResult::Success;\n}\nDAWN_UNUSED_FUNC(TextureViewSetLabelSerialize);\n\nDAWN_DECLARE_UNUSED WireResult TextureViewSetLabelDeserialize(\n    TextureViewSetLabelCmd* record,\n    const volatile TextureViewSetLabelTransfer* transfer,\n    DeserializeBuffer* deserializeBuffer,\n    DeserializeAllocator* allocator, const ObjectIdResolver& resolver) {\n    DAWN_UNUSED(allocator);\n\n    ASSERT(transfer->commandId == WireCmd::TextureViewSetLabel);\n    record->selfId = transfer->self;\n\n\n    WIRE_TRY(resolver.GetFromId(transfer->self, &record->self));\n    {\n        uint64_t stringLength64 = transfer->labelStrlen;\n        if (stringLength64 >= std::numeric_limits<size_t>::max()) {\n            return WireResult::FatalError;\n        }\n        size_t stringLength = static_cast<size_t>(stringLength64);\n\n        const volatile char* stringInBuffer;\n        WIRE_TRY(deserializeBuffer->ReadN(stringLength, &stringInBuffer));\n\n        char* copiedString;\n        WIRE_TRY(GetSpace(allocator, stringLength + 1, &copiedString));\n        memcpy(copiedString, const_cast<const char*>(stringInBuffer), stringLength);\n        copiedString[stringLength] = '\\0';\n        record->label = copiedString;\n    }\n\n    return WireResult::Success;\n}\nDAWN_UNUSED_FUNC(TextureViewSetLabelDeserialize);\n\n\nstruct ReturnAdapterRequestDeviceCallbackTransfer : CmdHeader {\n    static_assert(1 <= 1,\n                  \"Record must be at most one of is_cmd, extensible, and chained.\");\n    ReturnWireCmd commandId;\n\n    ObjectHandle adapter;\n    uint64_t requestSerial;\n    WGPURequestDeviceStatus status;\n    uint64_t messageStrlen;\n    bool has_message;\n    bool has_limits;\n    uint32_t featuresCount;\n};\n\nstatic_assert(offsetof(ReturnAdapterRequestDeviceCallbackTransfer, commandSize) == 0);\nstatic_assert(offsetof(ReturnAdapterRequestDeviceCallbackTransfer, commandId) == sizeof(CmdHeader));\n\nDAWN_DECLARE_UNUSED size_t ReturnAdapterRequestDeviceCallbackGetExtraRequiredSize(const ReturnAdapterRequestDeviceCallbackCmd& record) {\n    DAWN_UNUSED(record);\n    size_t result = 0;\n\n    if (record.message != nullptr) {\n        result += Align(std::strlen(record.message), kWireBufferAlignment);\n    }\n    if (record.limits != nullptr) {\n        auto memberLength = 1u;\n        auto size = WireAlignSizeofN<WGPUSupportedLimitsTransfer>(memberLength);\n        ASSERT(size);\n        result += *size;\n        for (decltype(memberLength) i = 0; i < memberLength; ++i) {\n            result += WGPUSupportedLimitsGetExtraRequiredSize(record.limits[i]);\n        }\n    }\n    {\n        auto memberLength = record.featuresCount;\n        auto size = WireAlignSizeofN<WGPUFeatureName>(memberLength);\n        ASSERT(size);\n        result += *size;\n    }\n    return result;\n}\n// GetExtraRequiredSize isn't used for structures that are value members of other structures\n// because we assume they cannot contain pointers themselves.\nDAWN_UNUSED_FUNC(ReturnAdapterRequestDeviceCallbackGetExtraRequiredSize);\n\nDAWN_DECLARE_UNUSED WireResult ReturnAdapterRequestDeviceCallbackSerialize(\n    const ReturnAdapterRequestDeviceCallbackCmd& record,\n    ReturnAdapterRequestDeviceCallbackTransfer* transfer,\n    SerializeBuffer* buffer, const ObjectIdProvider& provider) {\n    DAWN_UNUSED(buffer);\n    transfer->commandId = ReturnWireCmd::AdapterRequestDeviceCallback;\n\n\n    transfer->adapter = record.adapter;\n    transfer->requestSerial = record.requestSerial;\n    transfer->status = record.status;\n    transfer->featuresCount = record.featuresCount;\n    bool has_message = record.message != nullptr;\n    transfer->has_message = has_message;\n    if (has_message) {\n        transfer->messageStrlen = std::strlen(record.message);\n\n        char* stringInBuffer;\n        WIRE_TRY(buffer->NextN(transfer->messageStrlen, &stringInBuffer));\n        memcpy(stringInBuffer, record.message, transfer->messageStrlen);\n    }\n    bool has_limits = record.limits != nullptr;\n    transfer->has_limits = has_limits;\n    if (has_limits) {\n        auto memberLength = 1u;\n\n        WGPUSupportedLimitsTransfer* memberBuffer;\n        WIRE_TRY(buffer->NextN(memberLength, &memberBuffer));\n\n        for (decltype(memberLength) i = 0; i < memberLength; ++i) {\n            WIRE_TRY(WGPUSupportedLimitsSerialize(record.limits[i], &memberBuffer[i], buffer, provider));\n        }\n    }\n    {\n        auto memberLength = record.featuresCount;\n\n        WGPUFeatureName* memberBuffer;\n        WIRE_TRY(buffer->NextN(memberLength, &memberBuffer));\n\n        memcpy(\n            memberBuffer, record.features,\n            sizeof(WGPUFeatureName) * memberLength);\n    }\n\n    return WireResult::Success;\n}\nDAWN_UNUSED_FUNC(ReturnAdapterRequestDeviceCallbackSerialize);\n\nDAWN_DECLARE_UNUSED WireResult ReturnAdapterRequestDeviceCallbackDeserialize(\n    ReturnAdapterRequestDeviceCallbackCmd* record,\n    const volatile ReturnAdapterRequestDeviceCallbackTransfer* transfer,\n    DeserializeBuffer* deserializeBuffer,\n    DeserializeAllocator* allocator, const ObjectIdResolver& resolver) {\n    DAWN_UNUSED(allocator);\n\n    ASSERT(transfer->commandId == ReturnWireCmd::AdapterRequestDeviceCallback);\n\n\n    static_assert(sizeof(record->adapter) >= sizeof(transfer->adapter), \"Deserialize assignment may not narrow.\");\n    record->adapter = transfer->adapter;\n    static_assert(sizeof(record->requestSerial) >= sizeof(transfer->requestSerial), \"Deserialize assignment may not narrow.\");\n    record->requestSerial = transfer->requestSerial;\n    static_assert(sizeof(record->status) >= sizeof(transfer->status), \"Deserialize assignment may not narrow.\");\n    record->status = transfer->status;\n    static_assert(sizeof(record->featuresCount) >= sizeof(transfer->featuresCount), \"Deserialize assignment may not narrow.\");\n    record->featuresCount = transfer->featuresCount;\n    bool has_message = transfer->has_message;\n    record->message = nullptr;\n    if (has_message) {\n        uint64_t stringLength64 = transfer->messageStrlen;\n        if (stringLength64 >= std::numeric_limits<size_t>::max()) {\n            return WireResult::FatalError;\n        }\n        size_t stringLength = static_cast<size_t>(stringLength64);\n\n        const volatile char* stringInBuffer;\n        WIRE_TRY(deserializeBuffer->ReadN(stringLength, &stringInBuffer));\n\n        char* copiedString;\n        WIRE_TRY(GetSpace(allocator, stringLength + 1, &copiedString));\n        memcpy(copiedString, const_cast<const char*>(stringInBuffer), stringLength);\n        copiedString[stringLength] = '\\0';\n        record->message = copiedString;\n    }\n    bool has_limits = transfer->has_limits;\n    record->limits = nullptr;\n    if (has_limits) {\n        auto memberLength = 1u;\n        const volatile WGPUSupportedLimitsTransfer* memberBuffer;\n        WIRE_TRY(deserializeBuffer->ReadN(memberLength, &memberBuffer));\n\n        WGPUSupportedLimits* copiedMembers;\n        WIRE_TRY(GetSpace(allocator, memberLength, &copiedMembers));\n        record->limits = copiedMembers;\n\n        for (decltype(memberLength) i = 0; i < memberLength; ++i) {\n            WIRE_TRY(WGPUSupportedLimitsDeserialize(&copiedMembers[i], &memberBuffer[i], deserializeBuffer, allocator, resolver));\n        }\n    }\n    {\n        auto memberLength = record->featuresCount;\n        const volatile WGPUFeatureName* memberBuffer;\n        WIRE_TRY(deserializeBuffer->ReadN(memberLength, &memberBuffer));\n\n        WGPUFeatureName* copiedMembers;\n        WIRE_TRY(GetSpace(allocator, memberLength, &copiedMembers));\n        record->features = copiedMembers;\n\n        memcpy(\n            copiedMembers,\n            const_cast<const WGPUFeatureName*>(memberBuffer),\n           sizeof(WGPUFeatureName) * memberLength);\n    }\n\n    return WireResult::Success;\n}\nDAWN_UNUSED_FUNC(ReturnAdapterRequestDeviceCallbackDeserialize);\n\nstruct ReturnBufferMapAsyncCallbackTransfer : CmdHeader {\n    static_assert(1 <= 1,\n                  \"Record must be at most one of is_cmd, extensible, and chained.\");\n    ReturnWireCmd commandId;\n\n    ObjectHandle buffer;\n    uint64_t requestSerial;\n    uint32_t status;\n    uint64_t readDataUpdateInfoLength;\n};\n\nstatic_assert(offsetof(ReturnBufferMapAsyncCallbackTransfer, commandSize) == 0);\nstatic_assert(offsetof(ReturnBufferMapAsyncCallbackTransfer, commandId) == sizeof(CmdHeader));\n\nDAWN_DECLARE_UNUSED size_t ReturnBufferMapAsyncCallbackGetExtraRequiredSize(const ReturnBufferMapAsyncCallbackCmd& record) {\n    DAWN_UNUSED(record);\n    size_t result = 0;\n\n    return result;\n}\n// GetExtraRequiredSize isn't used for structures that are value members of other structures\n// because we assume they cannot contain pointers themselves.\nDAWN_UNUSED_FUNC(ReturnBufferMapAsyncCallbackGetExtraRequiredSize);\n\nDAWN_DECLARE_UNUSED WireResult ReturnBufferMapAsyncCallbackSerialize(\n    const ReturnBufferMapAsyncCallbackCmd& record,\n    ReturnBufferMapAsyncCallbackTransfer* transfer,\n    SerializeBuffer* buffer) {\n    DAWN_UNUSED(buffer);\n    transfer->commandId = ReturnWireCmd::BufferMapAsyncCallback;\n\n\n    transfer->buffer = record.buffer;\n    transfer->requestSerial = record.requestSerial;\n    transfer->status = record.status;\n    transfer->readDataUpdateInfoLength = record.readDataUpdateInfoLength;\n\n    return WireResult::Success;\n}\nDAWN_UNUSED_FUNC(ReturnBufferMapAsyncCallbackSerialize);\n\nDAWN_DECLARE_UNUSED WireResult ReturnBufferMapAsyncCallbackDeserialize(\n    ReturnBufferMapAsyncCallbackCmd* record,\n    const volatile ReturnBufferMapAsyncCallbackTransfer* transfer,\n    DeserializeBuffer* deserializeBuffer,\n    DeserializeAllocator* allocator) {\n    DAWN_UNUSED(allocator);\n\n    ASSERT(transfer->commandId == ReturnWireCmd::BufferMapAsyncCallback);\n\n\n    static_assert(sizeof(record->buffer) >= sizeof(transfer->buffer), \"Deserialize assignment may not narrow.\");\n    record->buffer = transfer->buffer;\n    static_assert(sizeof(record->requestSerial) >= sizeof(transfer->requestSerial), \"Deserialize assignment may not narrow.\");\n    record->requestSerial = transfer->requestSerial;\n    static_assert(sizeof(record->status) >= sizeof(transfer->status), \"Deserialize assignment may not narrow.\");\n    record->status = transfer->status;\n    static_assert(sizeof(record->readDataUpdateInfoLength) >= sizeof(transfer->readDataUpdateInfoLength), \"Deserialize assignment may not narrow.\");\n    record->readDataUpdateInfoLength = transfer->readDataUpdateInfoLength;\n    {\n        auto memberLength = record->readDataUpdateInfoLength;\n        const volatile uint8_t* memberBuffer;\n        WIRE_TRY(deserializeBuffer->ReadN(memberLength, &memberBuffer));\n\n        uint8_t* copiedMembers;\n        WIRE_TRY(GetSpace(allocator, memberLength, &copiedMembers));\n        record->readDataUpdateInfo = copiedMembers;\n\n        memcpy(\n            copiedMembers,\n            const_cast<const uint8_t*>(memberBuffer),\n           sizeof(uint8_t) * memberLength);\n    }\n\n    return WireResult::Success;\n}\nDAWN_UNUSED_FUNC(ReturnBufferMapAsyncCallbackDeserialize);\n\nstruct ReturnDeviceCreateComputePipelineAsyncCallbackTransfer : CmdHeader {\n    static_assert(1 <= 1,\n                  \"Record must be at most one of is_cmd, extensible, and chained.\");\n    ReturnWireCmd commandId;\n\n    ObjectHandle device;\n    uint64_t requestSerial;\n    WGPUCreatePipelineAsyncStatus status;\n    uint64_t messageStrlen;\n};\n\nstatic_assert(offsetof(ReturnDeviceCreateComputePipelineAsyncCallbackTransfer, commandSize) == 0);\nstatic_assert(offsetof(ReturnDeviceCreateComputePipelineAsyncCallbackTransfer, commandId) == sizeof(CmdHeader));\n\nDAWN_DECLARE_UNUSED size_t ReturnDeviceCreateComputePipelineAsyncCallbackGetExtraRequiredSize(const ReturnDeviceCreateComputePipelineAsyncCallbackCmd& record) {\n    DAWN_UNUSED(record);\n    size_t result = 0;\n\n    ASSERT(record.message != nullptr);\n    result += Align(std::strlen(record.message), kWireBufferAlignment);\n    return result;\n}\n// GetExtraRequiredSize isn't used for structures that are value members of other structures\n// because we assume they cannot contain pointers themselves.\nDAWN_UNUSED_FUNC(ReturnDeviceCreateComputePipelineAsyncCallbackGetExtraRequiredSize);\n\nDAWN_DECLARE_UNUSED WireResult ReturnDeviceCreateComputePipelineAsyncCallbackSerialize(\n    const ReturnDeviceCreateComputePipelineAsyncCallbackCmd& record,\n    ReturnDeviceCreateComputePipelineAsyncCallbackTransfer* transfer,\n    SerializeBuffer* buffer) {\n    DAWN_UNUSED(buffer);\n    transfer->commandId = ReturnWireCmd::DeviceCreateComputePipelineAsyncCallback;\n\n\n    transfer->device = record.device;\n    transfer->requestSerial = record.requestSerial;\n    transfer->status = record.status;\n    {\n        transfer->messageStrlen = std::strlen(record.message);\n\n        char* stringInBuffer;\n        WIRE_TRY(buffer->NextN(transfer->messageStrlen, &stringInBuffer));\n        memcpy(stringInBuffer, record.message, transfer->messageStrlen);\n    }\n\n    return WireResult::Success;\n}\nDAWN_UNUSED_FUNC(ReturnDeviceCreateComputePipelineAsyncCallbackSerialize);\n\nDAWN_DECLARE_UNUSED WireResult ReturnDeviceCreateComputePipelineAsyncCallbackDeserialize(\n    ReturnDeviceCreateComputePipelineAsyncCallbackCmd* record,\n    const volatile ReturnDeviceCreateComputePipelineAsyncCallbackTransfer* transfer,\n    DeserializeBuffer* deserializeBuffer,\n    DeserializeAllocator* allocator) {\n    DAWN_UNUSED(allocator);\n\n    ASSERT(transfer->commandId == ReturnWireCmd::DeviceCreateComputePipelineAsyncCallback);\n\n\n    static_assert(sizeof(record->device) >= sizeof(transfer->device), \"Deserialize assignment may not narrow.\");\n    record->device = transfer->device;\n    static_assert(sizeof(record->requestSerial) >= sizeof(transfer->requestSerial), \"Deserialize assignment may not narrow.\");\n    record->requestSerial = transfer->requestSerial;\n    static_assert(sizeof(record->status) >= sizeof(transfer->status), \"Deserialize assignment may not narrow.\");\n    record->status = transfer->status;\n    {\n        uint64_t stringLength64 = transfer->messageStrlen;\n        if (stringLength64 >= std::numeric_limits<size_t>::max()) {\n            return WireResult::FatalError;\n        }\n        size_t stringLength = static_cast<size_t>(stringLength64);\n\n        const volatile char* stringInBuffer;\n        WIRE_TRY(deserializeBuffer->ReadN(stringLength, &stringInBuffer));\n\n        char* copiedString;\n        WIRE_TRY(GetSpace(allocator, stringLength + 1, &copiedString));\n        memcpy(copiedString, const_cast<const char*>(stringInBuffer), stringLength);\n        copiedString[stringLength] = '\\0';\n        record->message = copiedString;\n    }\n\n    return WireResult::Success;\n}\nDAWN_UNUSED_FUNC(ReturnDeviceCreateComputePipelineAsyncCallbackDeserialize);\n\nstruct ReturnDeviceCreateRenderPipelineAsyncCallbackTransfer : CmdHeader {\n    static_assert(1 <= 1,\n                  \"Record must be at most one of is_cmd, extensible, and chained.\");\n    ReturnWireCmd commandId;\n\n    ObjectHandle device;\n    uint64_t requestSerial;\n    WGPUCreatePipelineAsyncStatus status;\n    uint64_t messageStrlen;\n};\n\nstatic_assert(offsetof(ReturnDeviceCreateRenderPipelineAsyncCallbackTransfer, commandSize) == 0);\nstatic_assert(offsetof(ReturnDeviceCreateRenderPipelineAsyncCallbackTransfer, commandId) == sizeof(CmdHeader));\n\nDAWN_DECLARE_UNUSED size_t ReturnDeviceCreateRenderPipelineAsyncCallbackGetExtraRequiredSize(const ReturnDeviceCreateRenderPipelineAsyncCallbackCmd& record) {\n    DAWN_UNUSED(record);\n    size_t result = 0;\n\n    ASSERT(record.message != nullptr);\n    result += Align(std::strlen(record.message), kWireBufferAlignment);\n    return result;\n}\n// GetExtraRequiredSize isn't used for structures that are value members of other structures\n// because we assume they cannot contain pointers themselves.\nDAWN_UNUSED_FUNC(ReturnDeviceCreateRenderPipelineAsyncCallbackGetExtraRequiredSize);\n\nDAWN_DECLARE_UNUSED WireResult ReturnDeviceCreateRenderPipelineAsyncCallbackSerialize(\n    const ReturnDeviceCreateRenderPipelineAsyncCallbackCmd& record,\n    ReturnDeviceCreateRenderPipelineAsyncCallbackTransfer* transfer,\n    SerializeBuffer* buffer) {\n    DAWN_UNUSED(buffer);\n    transfer->commandId = ReturnWireCmd::DeviceCreateRenderPipelineAsyncCallback;\n\n\n    transfer->device = record.device;\n    transfer->requestSerial = record.requestSerial;\n    transfer->status = record.status;\n    {\n        transfer->messageStrlen = std::strlen(record.message);\n\n        char* stringInBuffer;\n        WIRE_TRY(buffer->NextN(transfer->messageStrlen, &stringInBuffer));\n        memcpy(stringInBuffer, record.message, transfer->messageStrlen);\n    }\n\n    return WireResult::Success;\n}\nDAWN_UNUSED_FUNC(ReturnDeviceCreateRenderPipelineAsyncCallbackSerialize);\n\nDAWN_DECLARE_UNUSED WireResult ReturnDeviceCreateRenderPipelineAsyncCallbackDeserialize(\n    ReturnDeviceCreateRenderPipelineAsyncCallbackCmd* record,\n    const volatile ReturnDeviceCreateRenderPipelineAsyncCallbackTransfer* transfer,\n    DeserializeBuffer* deserializeBuffer,\n    DeserializeAllocator* allocator) {\n    DAWN_UNUSED(allocator);\n\n    ASSERT(transfer->commandId == ReturnWireCmd::DeviceCreateRenderPipelineAsyncCallback);\n\n\n    static_assert(sizeof(record->device) >= sizeof(transfer->device), \"Deserialize assignment may not narrow.\");\n    record->device = transfer->device;\n    static_assert(sizeof(record->requestSerial) >= sizeof(transfer->requestSerial), \"Deserialize assignment may not narrow.\");\n    record->requestSerial = transfer->requestSerial;\n    static_assert(sizeof(record->status) >= sizeof(transfer->status), \"Deserialize assignment may not narrow.\");\n    record->status = transfer->status;\n    {\n        uint64_t stringLength64 = transfer->messageStrlen;\n        if (stringLength64 >= std::numeric_limits<size_t>::max()) {\n            return WireResult::FatalError;\n        }\n        size_t stringLength = static_cast<size_t>(stringLength64);\n\n        const volatile char* stringInBuffer;\n        WIRE_TRY(deserializeBuffer->ReadN(stringLength, &stringInBuffer));\n\n        char* copiedString;\n        WIRE_TRY(GetSpace(allocator, stringLength + 1, &copiedString));\n        memcpy(copiedString, const_cast<const char*>(stringInBuffer), stringLength);\n        copiedString[stringLength] = '\\0';\n        record->message = copiedString;\n    }\n\n    return WireResult::Success;\n}\nDAWN_UNUSED_FUNC(ReturnDeviceCreateRenderPipelineAsyncCallbackDeserialize);\n\nstruct ReturnDeviceLoggingCallbackTransfer : CmdHeader {\n    static_assert(1 <= 1,\n                  \"Record must be at most one of is_cmd, extensible, and chained.\");\n    ReturnWireCmd commandId;\n\n    ObjectHandle device;\n    WGPULoggingType type;\n    uint64_t messageStrlen;\n};\n\nstatic_assert(offsetof(ReturnDeviceLoggingCallbackTransfer, commandSize) == 0);\nstatic_assert(offsetof(ReturnDeviceLoggingCallbackTransfer, commandId) == sizeof(CmdHeader));\n\nDAWN_DECLARE_UNUSED size_t ReturnDeviceLoggingCallbackGetExtraRequiredSize(const ReturnDeviceLoggingCallbackCmd& record) {\n    DAWN_UNUSED(record);\n    size_t result = 0;\n\n    ASSERT(record.message != nullptr);\n    result += Align(std::strlen(record.message), kWireBufferAlignment);\n    return result;\n}\n// GetExtraRequiredSize isn't used for structures that are value members of other structures\n// because we assume they cannot contain pointers themselves.\nDAWN_UNUSED_FUNC(ReturnDeviceLoggingCallbackGetExtraRequiredSize);\n\nDAWN_DECLARE_UNUSED WireResult ReturnDeviceLoggingCallbackSerialize(\n    const ReturnDeviceLoggingCallbackCmd& record,\n    ReturnDeviceLoggingCallbackTransfer* transfer,\n    SerializeBuffer* buffer) {\n    DAWN_UNUSED(buffer);\n    transfer->commandId = ReturnWireCmd::DeviceLoggingCallback;\n\n\n    transfer->device = record.device;\n    transfer->type = record.type;\n    {\n        transfer->messageStrlen = std::strlen(record.message);\n\n        char* stringInBuffer;\n        WIRE_TRY(buffer->NextN(transfer->messageStrlen, &stringInBuffer));\n        memcpy(stringInBuffer, record.message, transfer->messageStrlen);\n    }\n\n    return WireResult::Success;\n}\nDAWN_UNUSED_FUNC(ReturnDeviceLoggingCallbackSerialize);\n\nDAWN_DECLARE_UNUSED WireResult ReturnDeviceLoggingCallbackDeserialize(\n    ReturnDeviceLoggingCallbackCmd* record,\n    const volatile ReturnDeviceLoggingCallbackTransfer* transfer,\n    DeserializeBuffer* deserializeBuffer,\n    DeserializeAllocator* allocator) {\n    DAWN_UNUSED(allocator);\n\n    ASSERT(transfer->commandId == ReturnWireCmd::DeviceLoggingCallback);\n\n\n    static_assert(sizeof(record->device) >= sizeof(transfer->device), \"Deserialize assignment may not narrow.\");\n    record->device = transfer->device;\n    static_assert(sizeof(record->type) >= sizeof(transfer->type), \"Deserialize assignment may not narrow.\");\n    record->type = transfer->type;\n    {\n        uint64_t stringLength64 = transfer->messageStrlen;\n        if (stringLength64 >= std::numeric_limits<size_t>::max()) {\n            return WireResult::FatalError;\n        }\n        size_t stringLength = static_cast<size_t>(stringLength64);\n\n        const volatile char* stringInBuffer;\n        WIRE_TRY(deserializeBuffer->ReadN(stringLength, &stringInBuffer));\n\n        char* copiedString;\n        WIRE_TRY(GetSpace(allocator, stringLength + 1, &copiedString));\n        memcpy(copiedString, const_cast<const char*>(stringInBuffer), stringLength);\n        copiedString[stringLength] = '\\0';\n        record->message = copiedString;\n    }\n\n    return WireResult::Success;\n}\nDAWN_UNUSED_FUNC(ReturnDeviceLoggingCallbackDeserialize);\n\nstruct ReturnDeviceLostCallbackTransfer : CmdHeader {\n    static_assert(1 <= 1,\n                  \"Record must be at most one of is_cmd, extensible, and chained.\");\n    ReturnWireCmd commandId;\n\n    ObjectHandle device;\n    WGPUDeviceLostReason reason;\n    uint64_t messageStrlen;\n};\n\nstatic_assert(offsetof(ReturnDeviceLostCallbackTransfer, commandSize) == 0);\nstatic_assert(offsetof(ReturnDeviceLostCallbackTransfer, commandId) == sizeof(CmdHeader));\n\nDAWN_DECLARE_UNUSED size_t ReturnDeviceLostCallbackGetExtraRequiredSize(const ReturnDeviceLostCallbackCmd& record) {\n    DAWN_UNUSED(record);\n    size_t result = 0;\n\n    ASSERT(record.message != nullptr);\n    result += Align(std::strlen(record.message), kWireBufferAlignment);\n    return result;\n}\n// GetExtraRequiredSize isn't used for structures that are value members of other structures\n// because we assume they cannot contain pointers themselves.\nDAWN_UNUSED_FUNC(ReturnDeviceLostCallbackGetExtraRequiredSize);\n\nDAWN_DECLARE_UNUSED WireResult ReturnDeviceLostCallbackSerialize(\n    const ReturnDeviceLostCallbackCmd& record,\n    ReturnDeviceLostCallbackTransfer* transfer,\n    SerializeBuffer* buffer) {\n    DAWN_UNUSED(buffer);\n    transfer->commandId = ReturnWireCmd::DeviceLostCallback;\n\n\n    transfer->device = record.device;\n    transfer->reason = record.reason;\n    {\n        transfer->messageStrlen = std::strlen(record.message);\n\n        char* stringInBuffer;\n        WIRE_TRY(buffer->NextN(transfer->messageStrlen, &stringInBuffer));\n        memcpy(stringInBuffer, record.message, transfer->messageStrlen);\n    }\n\n    return WireResult::Success;\n}\nDAWN_UNUSED_FUNC(ReturnDeviceLostCallbackSerialize);\n\nDAWN_DECLARE_UNUSED WireResult ReturnDeviceLostCallbackDeserialize(\n    ReturnDeviceLostCallbackCmd* record,\n    const volatile ReturnDeviceLostCallbackTransfer* transfer,\n    DeserializeBuffer* deserializeBuffer,\n    DeserializeAllocator* allocator) {\n    DAWN_UNUSED(allocator);\n\n    ASSERT(transfer->commandId == ReturnWireCmd::DeviceLostCallback);\n\n\n    static_assert(sizeof(record->device) >= sizeof(transfer->device), \"Deserialize assignment may not narrow.\");\n    record->device = transfer->device;\n    static_assert(sizeof(record->reason) >= sizeof(transfer->reason), \"Deserialize assignment may not narrow.\");\n    record->reason = transfer->reason;\n    {\n        uint64_t stringLength64 = transfer->messageStrlen;\n        if (stringLength64 >= std::numeric_limits<size_t>::max()) {\n            return WireResult::FatalError;\n        }\n        size_t stringLength = static_cast<size_t>(stringLength64);\n\n        const volatile char* stringInBuffer;\n        WIRE_TRY(deserializeBuffer->ReadN(stringLength, &stringInBuffer));\n\n        char* copiedString;\n        WIRE_TRY(GetSpace(allocator, stringLength + 1, &copiedString));\n        memcpy(copiedString, const_cast<const char*>(stringInBuffer), stringLength);\n        copiedString[stringLength] = '\\0';\n        record->message = copiedString;\n    }\n\n    return WireResult::Success;\n}\nDAWN_UNUSED_FUNC(ReturnDeviceLostCallbackDeserialize);\n\nstruct ReturnDevicePopErrorScopeCallbackTransfer : CmdHeader {\n    static_assert(1 <= 1,\n                  \"Record must be at most one of is_cmd, extensible, and chained.\");\n    ReturnWireCmd commandId;\n\n    ObjectHandle device;\n    uint64_t requestSerial;\n    WGPUErrorType type;\n    uint64_t messageStrlen;\n};\n\nstatic_assert(offsetof(ReturnDevicePopErrorScopeCallbackTransfer, commandSize) == 0);\nstatic_assert(offsetof(ReturnDevicePopErrorScopeCallbackTransfer, commandId) == sizeof(CmdHeader));\n\nDAWN_DECLARE_UNUSED size_t ReturnDevicePopErrorScopeCallbackGetExtraRequiredSize(const ReturnDevicePopErrorScopeCallbackCmd& record) {\n    DAWN_UNUSED(record);\n    size_t result = 0;\n\n    ASSERT(record.message != nullptr);\n    result += Align(std::strlen(record.message), kWireBufferAlignment);\n    return result;\n}\n// GetExtraRequiredSize isn't used for structures that are value members of other structures\n// because we assume they cannot contain pointers themselves.\nDAWN_UNUSED_FUNC(ReturnDevicePopErrorScopeCallbackGetExtraRequiredSize);\n\nDAWN_DECLARE_UNUSED WireResult ReturnDevicePopErrorScopeCallbackSerialize(\n    const ReturnDevicePopErrorScopeCallbackCmd& record,\n    ReturnDevicePopErrorScopeCallbackTransfer* transfer,\n    SerializeBuffer* buffer) {\n    DAWN_UNUSED(buffer);\n    transfer->commandId = ReturnWireCmd::DevicePopErrorScopeCallback;\n\n\n    transfer->device = record.device;\n    transfer->requestSerial = record.requestSerial;\n    transfer->type = record.type;\n    {\n        transfer->messageStrlen = std::strlen(record.message);\n\n        char* stringInBuffer;\n        WIRE_TRY(buffer->NextN(transfer->messageStrlen, &stringInBuffer));\n        memcpy(stringInBuffer, record.message, transfer->messageStrlen);\n    }\n\n    return WireResult::Success;\n}\nDAWN_UNUSED_FUNC(ReturnDevicePopErrorScopeCallbackSerialize);\n\nDAWN_DECLARE_UNUSED WireResult ReturnDevicePopErrorScopeCallbackDeserialize(\n    ReturnDevicePopErrorScopeCallbackCmd* record,\n    const volatile ReturnDevicePopErrorScopeCallbackTransfer* transfer,\n    DeserializeBuffer* deserializeBuffer,\n    DeserializeAllocator* allocator) {\n    DAWN_UNUSED(allocator);\n\n    ASSERT(transfer->commandId == ReturnWireCmd::DevicePopErrorScopeCallback);\n\n\n    static_assert(sizeof(record->device) >= sizeof(transfer->device), \"Deserialize assignment may not narrow.\");\n    record->device = transfer->device;\n    static_assert(sizeof(record->requestSerial) >= sizeof(transfer->requestSerial), \"Deserialize assignment may not narrow.\");\n    record->requestSerial = transfer->requestSerial;\n    static_assert(sizeof(record->type) >= sizeof(transfer->type), \"Deserialize assignment may not narrow.\");\n    record->type = transfer->type;\n    {\n        uint64_t stringLength64 = transfer->messageStrlen;\n        if (stringLength64 >= std::numeric_limits<size_t>::max()) {\n            return WireResult::FatalError;\n        }\n        size_t stringLength = static_cast<size_t>(stringLength64);\n\n        const volatile char* stringInBuffer;\n        WIRE_TRY(deserializeBuffer->ReadN(stringLength, &stringInBuffer));\n\n        char* copiedString;\n        WIRE_TRY(GetSpace(allocator, stringLength + 1, &copiedString));\n        memcpy(copiedString, const_cast<const char*>(stringInBuffer), stringLength);\n        copiedString[stringLength] = '\\0';\n        record->message = copiedString;\n    }\n\n    return WireResult::Success;\n}\nDAWN_UNUSED_FUNC(ReturnDevicePopErrorScopeCallbackDeserialize);\n\nstruct ReturnDeviceUncapturedErrorCallbackTransfer : CmdHeader {\n    static_assert(1 <= 1,\n                  \"Record must be at most one of is_cmd, extensible, and chained.\");\n    ReturnWireCmd commandId;\n\n    ObjectHandle device;\n    WGPUErrorType type;\n    uint64_t messageStrlen;\n};\n\nstatic_assert(offsetof(ReturnDeviceUncapturedErrorCallbackTransfer, commandSize) == 0);\nstatic_assert(offsetof(ReturnDeviceUncapturedErrorCallbackTransfer, commandId) == sizeof(CmdHeader));\n\nDAWN_DECLARE_UNUSED size_t ReturnDeviceUncapturedErrorCallbackGetExtraRequiredSize(const ReturnDeviceUncapturedErrorCallbackCmd& record) {\n    DAWN_UNUSED(record);\n    size_t result = 0;\n\n    ASSERT(record.message != nullptr);\n    result += Align(std::strlen(record.message), kWireBufferAlignment);\n    return result;\n}\n// GetExtraRequiredSize isn't used for structures that are value members of other structures\n// because we assume they cannot contain pointers themselves.\nDAWN_UNUSED_FUNC(ReturnDeviceUncapturedErrorCallbackGetExtraRequiredSize);\n\nDAWN_DECLARE_UNUSED WireResult ReturnDeviceUncapturedErrorCallbackSerialize(\n    const ReturnDeviceUncapturedErrorCallbackCmd& record,\n    ReturnDeviceUncapturedErrorCallbackTransfer* transfer,\n    SerializeBuffer* buffer) {\n    DAWN_UNUSED(buffer);\n    transfer->commandId = ReturnWireCmd::DeviceUncapturedErrorCallback;\n\n\n    transfer->device = record.device;\n    transfer->type = record.type;\n    {\n        transfer->messageStrlen = std::strlen(record.message);\n\n        char* stringInBuffer;\n        WIRE_TRY(buffer->NextN(transfer->messageStrlen, &stringInBuffer));\n        memcpy(stringInBuffer, record.message, transfer->messageStrlen);\n    }\n\n    return WireResult::Success;\n}\nDAWN_UNUSED_FUNC(ReturnDeviceUncapturedErrorCallbackSerialize);\n\nDAWN_DECLARE_UNUSED WireResult ReturnDeviceUncapturedErrorCallbackDeserialize(\n    ReturnDeviceUncapturedErrorCallbackCmd* record,\n    const volatile ReturnDeviceUncapturedErrorCallbackTransfer* transfer,\n    DeserializeBuffer* deserializeBuffer,\n    DeserializeAllocator* allocator) {\n    DAWN_UNUSED(allocator);\n\n    ASSERT(transfer->commandId == ReturnWireCmd::DeviceUncapturedErrorCallback);\n\n\n    static_assert(sizeof(record->device) >= sizeof(transfer->device), \"Deserialize assignment may not narrow.\");\n    record->device = transfer->device;\n    static_assert(sizeof(record->type) >= sizeof(transfer->type), \"Deserialize assignment may not narrow.\");\n    record->type = transfer->type;\n    {\n        uint64_t stringLength64 = transfer->messageStrlen;\n        if (stringLength64 >= std::numeric_limits<size_t>::max()) {\n            return WireResult::FatalError;\n        }\n        size_t stringLength = static_cast<size_t>(stringLength64);\n\n        const volatile char* stringInBuffer;\n        WIRE_TRY(deserializeBuffer->ReadN(stringLength, &stringInBuffer));\n\n        char* copiedString;\n        WIRE_TRY(GetSpace(allocator, stringLength + 1, &copiedString));\n        memcpy(copiedString, const_cast<const char*>(stringInBuffer), stringLength);\n        copiedString[stringLength] = '\\0';\n        record->message = copiedString;\n    }\n\n    return WireResult::Success;\n}\nDAWN_UNUSED_FUNC(ReturnDeviceUncapturedErrorCallbackDeserialize);\n\nstruct ReturnInstanceRequestAdapterCallbackTransfer : CmdHeader {\n    static_assert(1 <= 1,\n                  \"Record must be at most one of is_cmd, extensible, and chained.\");\n    ReturnWireCmd commandId;\n\n    ObjectHandle instance;\n    uint64_t requestSerial;\n    WGPURequestAdapterStatus status;\n    uint64_t messageStrlen;\n    bool has_message;\n    bool has_properties;\n    bool has_limits;\n    uint32_t featuresCount;\n};\n\nstatic_assert(offsetof(ReturnInstanceRequestAdapterCallbackTransfer, commandSize) == 0);\nstatic_assert(offsetof(ReturnInstanceRequestAdapterCallbackTransfer, commandId) == sizeof(CmdHeader));\n\nDAWN_DECLARE_UNUSED size_t ReturnInstanceRequestAdapterCallbackGetExtraRequiredSize(const ReturnInstanceRequestAdapterCallbackCmd& record) {\n    DAWN_UNUSED(record);\n    size_t result = 0;\n\n    if (record.message != nullptr) {\n        result += Align(std::strlen(record.message), kWireBufferAlignment);\n    }\n    if (record.properties != nullptr) {\n        auto memberLength = 1u;\n        auto size = WireAlignSizeofN<WGPUAdapterPropertiesTransfer>(memberLength);\n        ASSERT(size);\n        result += *size;\n        for (decltype(memberLength) i = 0; i < memberLength; ++i) {\n            result += WGPUAdapterPropertiesGetExtraRequiredSize(record.properties[i]);\n        }\n    }\n    if (record.limits != nullptr) {\n        auto memberLength = 1u;\n        auto size = WireAlignSizeofN<WGPUSupportedLimitsTransfer>(memberLength);\n        ASSERT(size);\n        result += *size;\n        for (decltype(memberLength) i = 0; i < memberLength; ++i) {\n            result += WGPUSupportedLimitsGetExtraRequiredSize(record.limits[i]);\n        }\n    }\n    {\n        auto memberLength = record.featuresCount;\n        auto size = WireAlignSizeofN<WGPUFeatureName>(memberLength);\n        ASSERT(size);\n        result += *size;\n    }\n    return result;\n}\n// GetExtraRequiredSize isn't used for structures that are value members of other structures\n// because we assume they cannot contain pointers themselves.\nDAWN_UNUSED_FUNC(ReturnInstanceRequestAdapterCallbackGetExtraRequiredSize);\n\nDAWN_DECLARE_UNUSED WireResult ReturnInstanceRequestAdapterCallbackSerialize(\n    const ReturnInstanceRequestAdapterCallbackCmd& record,\n    ReturnInstanceRequestAdapterCallbackTransfer* transfer,\n    SerializeBuffer* buffer, const ObjectIdProvider& provider) {\n    DAWN_UNUSED(buffer);\n    transfer->commandId = ReturnWireCmd::InstanceRequestAdapterCallback;\n\n\n    transfer->instance = record.instance;\n    transfer->requestSerial = record.requestSerial;\n    transfer->status = record.status;\n    transfer->featuresCount = record.featuresCount;\n    bool has_message = record.message != nullptr;\n    transfer->has_message = has_message;\n    if (has_message) {\n        transfer->messageStrlen = std::strlen(record.message);\n\n        char* stringInBuffer;\n        WIRE_TRY(buffer->NextN(transfer->messageStrlen, &stringInBuffer));\n        memcpy(stringInBuffer, record.message, transfer->messageStrlen);\n    }\n    bool has_properties = record.properties != nullptr;\n    transfer->has_properties = has_properties;\n    if (has_properties) {\n        auto memberLength = 1u;\n\n        WGPUAdapterPropertiesTransfer* memberBuffer;\n        WIRE_TRY(buffer->NextN(memberLength, &memberBuffer));\n\n        for (decltype(memberLength) i = 0; i < memberLength; ++i) {\n            WIRE_TRY(WGPUAdapterPropertiesSerialize(record.properties[i], &memberBuffer[i], buffer, provider));\n        }\n    }\n    bool has_limits = record.limits != nullptr;\n    transfer->has_limits = has_limits;\n    if (has_limits) {\n        auto memberLength = 1u;\n\n        WGPUSupportedLimitsTransfer* memberBuffer;\n        WIRE_TRY(buffer->NextN(memberLength, &memberBuffer));\n\n        for (decltype(memberLength) i = 0; i < memberLength; ++i) {\n            WIRE_TRY(WGPUSupportedLimitsSerialize(record.limits[i], &memberBuffer[i], buffer, provider));\n        }\n    }\n    {\n        auto memberLength = record.featuresCount;\n\n        WGPUFeatureName* memberBuffer;\n        WIRE_TRY(buffer->NextN(memberLength, &memberBuffer));\n\n        memcpy(\n            memberBuffer, record.features,\n            sizeof(WGPUFeatureName) * memberLength);\n    }\n\n    return WireResult::Success;\n}\nDAWN_UNUSED_FUNC(ReturnInstanceRequestAdapterCallbackSerialize);\n\nDAWN_DECLARE_UNUSED WireResult ReturnInstanceRequestAdapterCallbackDeserialize(\n    ReturnInstanceRequestAdapterCallbackCmd* record,\n    const volatile ReturnInstanceRequestAdapterCallbackTransfer* transfer,\n    DeserializeBuffer* deserializeBuffer,\n    DeserializeAllocator* allocator, const ObjectIdResolver& resolver) {\n    DAWN_UNUSED(allocator);\n\n    ASSERT(transfer->commandId == ReturnWireCmd::InstanceRequestAdapterCallback);\n\n\n    static_assert(sizeof(record->instance) >= sizeof(transfer->instance), \"Deserialize assignment may not narrow.\");\n    record->instance = transfer->instance;\n    static_assert(sizeof(record->requestSerial) >= sizeof(transfer->requestSerial), \"Deserialize assignment may not narrow.\");\n    record->requestSerial = transfer->requestSerial;\n    static_assert(sizeof(record->status) >= sizeof(transfer->status), \"Deserialize assignment may not narrow.\");\n    record->status = transfer->status;\n    static_assert(sizeof(record->featuresCount) >= sizeof(transfer->featuresCount), \"Deserialize assignment may not narrow.\");\n    record->featuresCount = transfer->featuresCount;\n    bool has_message = transfer->has_message;\n    record->message = nullptr;\n    if (has_message) {\n        uint64_t stringLength64 = transfer->messageStrlen;\n        if (stringLength64 >= std::numeric_limits<size_t>::max()) {\n            return WireResult::FatalError;\n        }\n        size_t stringLength = static_cast<size_t>(stringLength64);\n\n        const volatile char* stringInBuffer;\n        WIRE_TRY(deserializeBuffer->ReadN(stringLength, &stringInBuffer));\n\n        char* copiedString;\n        WIRE_TRY(GetSpace(allocator, stringLength + 1, &copiedString));\n        memcpy(copiedString, const_cast<const char*>(stringInBuffer), stringLength);\n        copiedString[stringLength] = '\\0';\n        record->message = copiedString;\n    }\n    bool has_properties = transfer->has_properties;\n    record->properties = nullptr;\n    if (has_properties) {\n        auto memberLength = 1u;\n        const volatile WGPUAdapterPropertiesTransfer* memberBuffer;\n        WIRE_TRY(deserializeBuffer->ReadN(memberLength, &memberBuffer));\n\n        WGPUAdapterProperties* copiedMembers;\n        WIRE_TRY(GetSpace(allocator, memberLength, &copiedMembers));\n        record->properties = copiedMembers;\n\n        for (decltype(memberLength) i = 0; i < memberLength; ++i) {\n            WIRE_TRY(WGPUAdapterPropertiesDeserialize(&copiedMembers[i], &memberBuffer[i], deserializeBuffer, allocator, resolver));\n        }\n    }\n    bool has_limits = transfer->has_limits;\n    record->limits = nullptr;\n    if (has_limits) {\n        auto memberLength = 1u;\n        const volatile WGPUSupportedLimitsTransfer* memberBuffer;\n        WIRE_TRY(deserializeBuffer->ReadN(memberLength, &memberBuffer));\n\n        WGPUSupportedLimits* copiedMembers;\n        WIRE_TRY(GetSpace(allocator, memberLength, &copiedMembers));\n        record->limits = copiedMembers;\n\n        for (decltype(memberLength) i = 0; i < memberLength; ++i) {\n            WIRE_TRY(WGPUSupportedLimitsDeserialize(&copiedMembers[i], &memberBuffer[i], deserializeBuffer, allocator, resolver));\n        }\n    }\n    {\n        auto memberLength = record->featuresCount;\n        const volatile WGPUFeatureName* memberBuffer;\n        WIRE_TRY(deserializeBuffer->ReadN(memberLength, &memberBuffer));\n\n        WGPUFeatureName* copiedMembers;\n        WIRE_TRY(GetSpace(allocator, memberLength, &copiedMembers));\n        record->features = copiedMembers;\n\n        memcpy(\n            copiedMembers,\n            const_cast<const WGPUFeatureName*>(memberBuffer),\n           sizeof(WGPUFeatureName) * memberLength);\n    }\n\n    return WireResult::Success;\n}\nDAWN_UNUSED_FUNC(ReturnInstanceRequestAdapterCallbackDeserialize);\n\nstruct ReturnQueueWorkDoneCallbackTransfer : CmdHeader {\n    static_assert(1 <= 1,\n                  \"Record must be at most one of is_cmd, extensible, and chained.\");\n    ReturnWireCmd commandId;\n\n    ObjectHandle queue;\n    uint64_t requestSerial;\n    WGPUQueueWorkDoneStatus status;\n};\n\nstatic_assert(offsetof(ReturnQueueWorkDoneCallbackTransfer, commandSize) == 0);\nstatic_assert(offsetof(ReturnQueueWorkDoneCallbackTransfer, commandId) == sizeof(CmdHeader));\n\nDAWN_DECLARE_UNUSED size_t ReturnQueueWorkDoneCallbackGetExtraRequiredSize(const ReturnQueueWorkDoneCallbackCmd& record) {\n    DAWN_UNUSED(record);\n    size_t result = 0;\n\n    return result;\n}\n// GetExtraRequiredSize isn't used for structures that are value members of other structures\n// because we assume they cannot contain pointers themselves.\nDAWN_UNUSED_FUNC(ReturnQueueWorkDoneCallbackGetExtraRequiredSize);\n\nDAWN_DECLARE_UNUSED WireResult ReturnQueueWorkDoneCallbackSerialize(\n    const ReturnQueueWorkDoneCallbackCmd& record,\n    ReturnQueueWorkDoneCallbackTransfer* transfer,\n    SerializeBuffer* buffer) {\n    DAWN_UNUSED(buffer);\n    transfer->commandId = ReturnWireCmd::QueueWorkDoneCallback;\n\n\n    transfer->queue = record.queue;\n    transfer->requestSerial = record.requestSerial;\n    transfer->status = record.status;\n\n    return WireResult::Success;\n}\nDAWN_UNUSED_FUNC(ReturnQueueWorkDoneCallbackSerialize);\n\nDAWN_DECLARE_UNUSED WireResult ReturnQueueWorkDoneCallbackDeserialize(\n    ReturnQueueWorkDoneCallbackCmd* record,\n    const volatile ReturnQueueWorkDoneCallbackTransfer* transfer,\n    DeserializeBuffer* deserializeBuffer,\n    DeserializeAllocator* allocator) {\n    DAWN_UNUSED(allocator);\n\n    ASSERT(transfer->commandId == ReturnWireCmd::QueueWorkDoneCallback);\n\n\n    static_assert(sizeof(record->queue) >= sizeof(transfer->queue), \"Deserialize assignment may not narrow.\");\n    record->queue = transfer->queue;\n    static_assert(sizeof(record->requestSerial) >= sizeof(transfer->requestSerial), \"Deserialize assignment may not narrow.\");\n    record->requestSerial = transfer->requestSerial;\n    static_assert(sizeof(record->status) >= sizeof(transfer->status), \"Deserialize assignment may not narrow.\");\n    record->status = transfer->status;\n\n    return WireResult::Success;\n}\nDAWN_UNUSED_FUNC(ReturnQueueWorkDoneCallbackDeserialize);\n\nstruct ReturnShaderModuleGetCompilationInfoCallbackTransfer : CmdHeader {\n    static_assert(1 <= 1,\n                  \"Record must be at most one of is_cmd, extensible, and chained.\");\n    ReturnWireCmd commandId;\n\n    ObjectHandle shaderModule;\n    uint64_t requestSerial;\n    WGPUCompilationInfoRequestStatus status;\n    bool has_info;\n};\n\nstatic_assert(offsetof(ReturnShaderModuleGetCompilationInfoCallbackTransfer, commandSize) == 0);\nstatic_assert(offsetof(ReturnShaderModuleGetCompilationInfoCallbackTransfer, commandId) == sizeof(CmdHeader));\n\nDAWN_DECLARE_UNUSED size_t ReturnShaderModuleGetCompilationInfoCallbackGetExtraRequiredSize(const ReturnShaderModuleGetCompilationInfoCallbackCmd& record) {\n    DAWN_UNUSED(record);\n    size_t result = 0;\n\n    if (record.info != nullptr) {\n        auto memberLength = 1u;\n        auto size = WireAlignSizeofN<WGPUCompilationInfoTransfer>(memberLength);\n        ASSERT(size);\n        result += *size;\n        for (decltype(memberLength) i = 0; i < memberLength; ++i) {\n            result += WGPUCompilationInfoGetExtraRequiredSize(record.info[i]);\n        }\n    }\n    return result;\n}\n// GetExtraRequiredSize isn't used for structures that are value members of other structures\n// because we assume they cannot contain pointers themselves.\nDAWN_UNUSED_FUNC(ReturnShaderModuleGetCompilationInfoCallbackGetExtraRequiredSize);\n\nDAWN_DECLARE_UNUSED WireResult ReturnShaderModuleGetCompilationInfoCallbackSerialize(\n    const ReturnShaderModuleGetCompilationInfoCallbackCmd& record,\n    ReturnShaderModuleGetCompilationInfoCallbackTransfer* transfer,\n    SerializeBuffer* buffer, const ObjectIdProvider& provider) {\n    DAWN_UNUSED(buffer);\n    transfer->commandId = ReturnWireCmd::ShaderModuleGetCompilationInfoCallback;\n\n\n    transfer->shaderModule = record.shaderModule;\n    transfer->requestSerial = record.requestSerial;\n    transfer->status = record.status;\n    bool has_info = record.info != nullptr;\n    transfer->has_info = has_info;\n    if (has_info) {\n        auto memberLength = 1u;\n\n        WGPUCompilationInfoTransfer* memberBuffer;\n        WIRE_TRY(buffer->NextN(memberLength, &memberBuffer));\n\n        for (decltype(memberLength) i = 0; i < memberLength; ++i) {\n            WIRE_TRY(WGPUCompilationInfoSerialize(record.info[i], &memberBuffer[i], buffer, provider));\n        }\n    }\n\n    return WireResult::Success;\n}\nDAWN_UNUSED_FUNC(ReturnShaderModuleGetCompilationInfoCallbackSerialize);\n\nDAWN_DECLARE_UNUSED WireResult ReturnShaderModuleGetCompilationInfoCallbackDeserialize(\n    ReturnShaderModuleGetCompilationInfoCallbackCmd* record,\n    const volatile ReturnShaderModuleGetCompilationInfoCallbackTransfer* transfer,\n    DeserializeBuffer* deserializeBuffer,\n    DeserializeAllocator* allocator, const ObjectIdResolver& resolver) {\n    DAWN_UNUSED(allocator);\n\n    ASSERT(transfer->commandId == ReturnWireCmd::ShaderModuleGetCompilationInfoCallback);\n\n\n    static_assert(sizeof(record->shaderModule) >= sizeof(transfer->shaderModule), \"Deserialize assignment may not narrow.\");\n    record->shaderModule = transfer->shaderModule;\n    static_assert(sizeof(record->requestSerial) >= sizeof(transfer->requestSerial), \"Deserialize assignment may not narrow.\");\n    record->requestSerial = transfer->requestSerial;\n    static_assert(sizeof(record->status) >= sizeof(transfer->status), \"Deserialize assignment may not narrow.\");\n    record->status = transfer->status;\n    bool has_info = transfer->has_info;\n    record->info = nullptr;\n    if (has_info) {\n        auto memberLength = 1u;\n        const volatile WGPUCompilationInfoTransfer* memberBuffer;\n        WIRE_TRY(deserializeBuffer->ReadN(memberLength, &memberBuffer));\n\n        WGPUCompilationInfo* copiedMembers;\n        WIRE_TRY(GetSpace(allocator, memberLength, &copiedMembers));\n        record->info = copiedMembers;\n\n        for (decltype(memberLength) i = 0; i < memberLength; ++i) {\n            WIRE_TRY(WGPUCompilationInfoDeserialize(&copiedMembers[i], &memberBuffer[i], deserializeBuffer, allocator, resolver));\n        }\n    }\n\n    return WireResult::Success;\n}\nDAWN_UNUSED_FUNC(ReturnShaderModuleGetCompilationInfoCallbackDeserialize);\n\n// Implementation of ObjectIdResolver that always errors.\n// Used when the generator adds a provider argument because of a chained\n// struct, but in practice, a chained struct in that location is invalid.\nclass ErrorObjectIdResolver final : public ObjectIdResolver {\n    public:\n  WireResult GetFromId(ObjectId id, WGPUAdapter* out) const override {\n      return WireResult::FatalError;\n  }\n  WireResult GetOptionalFromId(ObjectId id, WGPUAdapter* out) const override {\n      return WireResult::FatalError;\n  }\n  WireResult GetFromId(ObjectId id, WGPUBindGroup* out) const override {\n      return WireResult::FatalError;\n  }\n  WireResult GetOptionalFromId(ObjectId id, WGPUBindGroup* out) const override {\n      return WireResult::FatalError;\n  }\n  WireResult GetFromId(ObjectId id, WGPUBindGroupLayout* out) const override {\n      return WireResult::FatalError;\n  }\n  WireResult GetOptionalFromId(ObjectId id, WGPUBindGroupLayout* out) const override {\n      return WireResult::FatalError;\n  }\n  WireResult GetFromId(ObjectId id, WGPUBuffer* out) const override {\n      return WireResult::FatalError;\n  }\n  WireResult GetOptionalFromId(ObjectId id, WGPUBuffer* out) const override {\n      return WireResult::FatalError;\n  }\n  WireResult GetFromId(ObjectId id, WGPUCommandBuffer* out) const override {\n      return WireResult::FatalError;\n  }\n  WireResult GetOptionalFromId(ObjectId id, WGPUCommandBuffer* out) const override {\n      return WireResult::FatalError;\n  }\n  WireResult GetFromId(ObjectId id, WGPUCommandEncoder* out) const override {\n      return WireResult::FatalError;\n  }\n  WireResult GetOptionalFromId(ObjectId id, WGPUCommandEncoder* out) const override {\n      return WireResult::FatalError;\n  }\n  WireResult GetFromId(ObjectId id, WGPUComputePassEncoder* out) const override {\n      return WireResult::FatalError;\n  }\n  WireResult GetOptionalFromId(ObjectId id, WGPUComputePassEncoder* out) const override {\n      return WireResult::FatalError;\n  }\n  WireResult GetFromId(ObjectId id, WGPUComputePipeline* out) const override {\n      return WireResult::FatalError;\n  }\n  WireResult GetOptionalFromId(ObjectId id, WGPUComputePipeline* out) const override {\n      return WireResult::FatalError;\n  }\n  WireResult GetFromId(ObjectId id, WGPUDevice* out) const override {\n      return WireResult::FatalError;\n  }\n  WireResult GetOptionalFromId(ObjectId id, WGPUDevice* out) const override {\n      return WireResult::FatalError;\n  }\n  WireResult GetFromId(ObjectId id, WGPUExternalTexture* out) const override {\n      return WireResult::FatalError;\n  }\n  WireResult GetOptionalFromId(ObjectId id, WGPUExternalTexture* out) const override {\n      return WireResult::FatalError;\n  }\n  WireResult GetFromId(ObjectId id, WGPUInstance* out) const override {\n      return WireResult::FatalError;\n  }\n  WireResult GetOptionalFromId(ObjectId id, WGPUInstance* out) const override {\n      return WireResult::FatalError;\n  }\n  WireResult GetFromId(ObjectId id, WGPUPipelineLayout* out) const override {\n      return WireResult::FatalError;\n  }\n  WireResult GetOptionalFromId(ObjectId id, WGPUPipelineLayout* out) const override {\n      return WireResult::FatalError;\n  }\n  WireResult GetFromId(ObjectId id, WGPUQuerySet* out) const override {\n      return WireResult::FatalError;\n  }\n  WireResult GetOptionalFromId(ObjectId id, WGPUQuerySet* out) const override {\n      return WireResult::FatalError;\n  }\n  WireResult GetFromId(ObjectId id, WGPUQueue* out) const override {\n      return WireResult::FatalError;\n  }\n  WireResult GetOptionalFromId(ObjectId id, WGPUQueue* out) const override {\n      return WireResult::FatalError;\n  }\n  WireResult GetFromId(ObjectId id, WGPURenderBundle* out) const override {\n      return WireResult::FatalError;\n  }\n  WireResult GetOptionalFromId(ObjectId id, WGPURenderBundle* out) const override {\n      return WireResult::FatalError;\n  }\n  WireResult GetFromId(ObjectId id, WGPURenderBundleEncoder* out) const override {\n      return WireResult::FatalError;\n  }\n  WireResult GetOptionalFromId(ObjectId id, WGPURenderBundleEncoder* out) const override {\n      return WireResult::FatalError;\n  }\n  WireResult GetFromId(ObjectId id, WGPURenderPassEncoder* out) const override {\n      return WireResult::FatalError;\n  }\n  WireResult GetOptionalFromId(ObjectId id, WGPURenderPassEncoder* out) const override {\n      return WireResult::FatalError;\n  }\n  WireResult GetFromId(ObjectId id, WGPURenderPipeline* out) const override {\n      return WireResult::FatalError;\n  }\n  WireResult GetOptionalFromId(ObjectId id, WGPURenderPipeline* out) const override {\n      return WireResult::FatalError;\n  }\n  WireResult GetFromId(ObjectId id, WGPUSampler* out) const override {\n      return WireResult::FatalError;\n  }\n  WireResult GetOptionalFromId(ObjectId id, WGPUSampler* out) const override {\n      return WireResult::FatalError;\n  }\n  WireResult GetFromId(ObjectId id, WGPUShaderModule* out) const override {\n      return WireResult::FatalError;\n  }\n  WireResult GetOptionalFromId(ObjectId id, WGPUShaderModule* out) const override {\n      return WireResult::FatalError;\n  }\n  WireResult GetFromId(ObjectId id, WGPUSurface* out) const override {\n      return WireResult::FatalError;\n  }\n  WireResult GetOptionalFromId(ObjectId id, WGPUSurface* out) const override {\n      return WireResult::FatalError;\n  }\n  WireResult GetFromId(ObjectId id, WGPUSwapChain* out) const override {\n      return WireResult::FatalError;\n  }\n  WireResult GetOptionalFromId(ObjectId id, WGPUSwapChain* out) const override {\n      return WireResult::FatalError;\n  }\n  WireResult GetFromId(ObjectId id, WGPUTexture* out) const override {\n      return WireResult::FatalError;\n  }\n  WireResult GetOptionalFromId(ObjectId id, WGPUTexture* out) const override {\n      return WireResult::FatalError;\n  }\n  WireResult GetFromId(ObjectId id, WGPUTextureView* out) const override {\n      return WireResult::FatalError;\n  }\n  WireResult GetOptionalFromId(ObjectId id, WGPUTextureView* out) const override {\n      return WireResult::FatalError;\n  }\n};\n\n// Implementation of ObjectIdProvider that always errors.\n// Used when the generator adds a provider argument because of a chained\n// struct, but in practice, a chained struct in that location is invalid.\nclass ErrorObjectIdProvider final : public ObjectIdProvider {\n    public:\n  WireResult GetId(WGPUAdapter object, ObjectId* out) const override {\n      return WireResult::FatalError;\n  }\n  WireResult GetOptionalId(WGPUAdapter object, ObjectId* out) const override {\n      return WireResult::FatalError;\n  }\n  WireResult GetId(WGPUBindGroup object, ObjectId* out) const override {\n      return WireResult::FatalError;\n  }\n  WireResult GetOptionalId(WGPUBindGroup object, ObjectId* out) const override {\n      return WireResult::FatalError;\n  }\n  WireResult GetId(WGPUBindGroupLayout object, ObjectId* out) const override {\n      return WireResult::FatalError;\n  }\n  WireResult GetOptionalId(WGPUBindGroupLayout object, ObjectId* out) const override {\n      return WireResult::FatalError;\n  }\n  WireResult GetId(WGPUBuffer object, ObjectId* out) const override {\n      return WireResult::FatalError;\n  }\n  WireResult GetOptionalId(WGPUBuffer object, ObjectId* out) const override {\n      return WireResult::FatalError;\n  }\n  WireResult GetId(WGPUCommandBuffer object, ObjectId* out) const override {\n      return WireResult::FatalError;\n  }\n  WireResult GetOptionalId(WGPUCommandBuffer object, ObjectId* out) const override {\n      return WireResult::FatalError;\n  }\n  WireResult GetId(WGPUCommandEncoder object, ObjectId* out) const override {\n      return WireResult::FatalError;\n  }\n  WireResult GetOptionalId(WGPUCommandEncoder object, ObjectId* out) const override {\n      return WireResult::FatalError;\n  }\n  WireResult GetId(WGPUComputePassEncoder object, ObjectId* out) const override {\n      return WireResult::FatalError;\n  }\n  WireResult GetOptionalId(WGPUComputePassEncoder object, ObjectId* out) const override {\n      return WireResult::FatalError;\n  }\n  WireResult GetId(WGPUComputePipeline object, ObjectId* out) const override {\n      return WireResult::FatalError;\n  }\n  WireResult GetOptionalId(WGPUComputePipeline object, ObjectId* out) const override {\n      return WireResult::FatalError;\n  }\n  WireResult GetId(WGPUDevice object, ObjectId* out) const override {\n      return WireResult::FatalError;\n  }\n  WireResult GetOptionalId(WGPUDevice object, ObjectId* out) const override {\n      return WireResult::FatalError;\n  }\n  WireResult GetId(WGPUExternalTexture object, ObjectId* out) const override {\n      return WireResult::FatalError;\n  }\n  WireResult GetOptionalId(WGPUExternalTexture object, ObjectId* out) const override {\n      return WireResult::FatalError;\n  }\n  WireResult GetId(WGPUInstance object, ObjectId* out) const override {\n      return WireResult::FatalError;\n  }\n  WireResult GetOptionalId(WGPUInstance object, ObjectId* out) const override {\n      return WireResult::FatalError;\n  }\n  WireResult GetId(WGPUPipelineLayout object, ObjectId* out) const override {\n      return WireResult::FatalError;\n  }\n  WireResult GetOptionalId(WGPUPipelineLayout object, ObjectId* out) const override {\n      return WireResult::FatalError;\n  }\n  WireResult GetId(WGPUQuerySet object, ObjectId* out) const override {\n      return WireResult::FatalError;\n  }\n  WireResult GetOptionalId(WGPUQuerySet object, ObjectId* out) const override {\n      return WireResult::FatalError;\n  }\n  WireResult GetId(WGPUQueue object, ObjectId* out) const override {\n      return WireResult::FatalError;\n  }\n  WireResult GetOptionalId(WGPUQueue object, ObjectId* out) const override {\n      return WireResult::FatalError;\n  }\n  WireResult GetId(WGPURenderBundle object, ObjectId* out) const override {\n      return WireResult::FatalError;\n  }\n  WireResult GetOptionalId(WGPURenderBundle object, ObjectId* out) const override {\n      return WireResult::FatalError;\n  }\n  WireResult GetId(WGPURenderBundleEncoder object, ObjectId* out) const override {\n      return WireResult::FatalError;\n  }\n  WireResult GetOptionalId(WGPURenderBundleEncoder object, ObjectId* out) const override {\n      return WireResult::FatalError;\n  }\n  WireResult GetId(WGPURenderPassEncoder object, ObjectId* out) const override {\n      return WireResult::FatalError;\n  }\n  WireResult GetOptionalId(WGPURenderPassEncoder object, ObjectId* out) const override {\n      return WireResult::FatalError;\n  }\n  WireResult GetId(WGPURenderPipeline object, ObjectId* out) const override {\n      return WireResult::FatalError;\n  }\n  WireResult GetOptionalId(WGPURenderPipeline object, ObjectId* out) const override {\n      return WireResult::FatalError;\n  }\n  WireResult GetId(WGPUSampler object, ObjectId* out) const override {\n      return WireResult::FatalError;\n  }\n  WireResult GetOptionalId(WGPUSampler object, ObjectId* out) const override {\n      return WireResult::FatalError;\n  }\n  WireResult GetId(WGPUShaderModule object, ObjectId* out) const override {\n      return WireResult::FatalError;\n  }\n  WireResult GetOptionalId(WGPUShaderModule object, ObjectId* out) const override {\n      return WireResult::FatalError;\n  }\n  WireResult GetId(WGPUSurface object, ObjectId* out) const override {\n      return WireResult::FatalError;\n  }\n  WireResult GetOptionalId(WGPUSurface object, ObjectId* out) const override {\n      return WireResult::FatalError;\n  }\n  WireResult GetId(WGPUSwapChain object, ObjectId* out) const override {\n      return WireResult::FatalError;\n  }\n  WireResult GetOptionalId(WGPUSwapChain object, ObjectId* out) const override {\n      return WireResult::FatalError;\n  }\n  WireResult GetId(WGPUTexture object, ObjectId* out) const override {\n      return WireResult::FatalError;\n  }\n  WireResult GetOptionalId(WGPUTexture object, ObjectId* out) const override {\n      return WireResult::FatalError;\n  }\n  WireResult GetId(WGPUTextureView object, ObjectId* out) const override {\n      return WireResult::FatalError;\n  }\n  WireResult GetOptionalId(WGPUTextureView object, ObjectId* out) const override {\n      return WireResult::FatalError;\n  }\n};\n\n}  // anonymous namespace\n\nsize_t AdapterGetInstanceCmd::GetRequiredSize() const {\n    return WireAlignSizeof<AdapterGetInstanceTransfer>() + AdapterGetInstanceGetExtraRequiredSize(*this);\n}\n\nWireResult AdapterGetInstanceCmd::Serialize(\n    size_t commandSize,\n    SerializeBuffer* serializeBuffer,\n    const ObjectIdProvider& provider) const {\n    AdapterGetInstanceTransfer* transfer;\n    WIRE_TRY(serializeBuffer->Next(&transfer));\n    transfer->commandSize = commandSize;\n    return (AdapterGetInstanceSerialize(*this, transfer, serializeBuffer, provider));\n}\nWireResult AdapterGetInstanceCmd::Serialize(size_t commandSize, SerializeBuffer* serializeBuffer) const {\n    ErrorObjectIdProvider provider;\n    return Serialize(commandSize, serializeBuffer, provider);\n}\n\nWireResult AdapterGetInstanceCmd::Deserialize(\n    DeserializeBuffer* deserializeBuffer,\n    DeserializeAllocator* allocator,\n    const ObjectIdResolver& resolver) {\n    const volatile AdapterGetInstanceTransfer* transfer;\n    WIRE_TRY(deserializeBuffer->Read(&transfer));\n    return AdapterGetInstanceDeserialize(this, transfer, deserializeBuffer, allocator, resolver);\n}\nWireResult AdapterGetInstanceCmd::Deserialize(DeserializeBuffer* deserializeBuffer, DeserializeAllocator* allocator) {\n    ErrorObjectIdResolver resolver;\n    return Deserialize(deserializeBuffer, allocator, resolver);\n}\n\nsize_t AdapterRequestDeviceCmd::GetRequiredSize() const {\n    return WireAlignSizeof<AdapterRequestDeviceTransfer>() + AdapterRequestDeviceGetExtraRequiredSize(*this);\n}\n\nWireResult AdapterRequestDeviceCmd::Serialize(\n    size_t commandSize,\n    SerializeBuffer* serializeBuffer,\n    const ObjectIdProvider& provider) const {\n    AdapterRequestDeviceTransfer* transfer;\n    WIRE_TRY(serializeBuffer->Next(&transfer));\n    transfer->commandSize = commandSize;\n    return (AdapterRequestDeviceSerialize(*this, transfer, serializeBuffer, provider));\n}\nWireResult AdapterRequestDeviceCmd::Serialize(size_t commandSize, SerializeBuffer* serializeBuffer) const {\n    ErrorObjectIdProvider provider;\n    return Serialize(commandSize, serializeBuffer, provider);\n}\n\nWireResult AdapterRequestDeviceCmd::Deserialize(\n    DeserializeBuffer* deserializeBuffer,\n    DeserializeAllocator* allocator,\n    const ObjectIdResolver& resolver) {\n    const volatile AdapterRequestDeviceTransfer* transfer;\n    WIRE_TRY(deserializeBuffer->Read(&transfer));\n    return AdapterRequestDeviceDeserialize(this, transfer, deserializeBuffer, allocator, resolver);\n}\nWireResult AdapterRequestDeviceCmd::Deserialize(DeserializeBuffer* deserializeBuffer, DeserializeAllocator* allocator) {\n    ErrorObjectIdResolver resolver;\n    return Deserialize(deserializeBuffer, allocator, resolver);\n}\n\nsize_t BindGroupLayoutSetLabelCmd::GetRequiredSize() const {\n    return WireAlignSizeof<BindGroupLayoutSetLabelTransfer>() + BindGroupLayoutSetLabelGetExtraRequiredSize(*this);\n}\n\nWireResult BindGroupLayoutSetLabelCmd::Serialize(\n    size_t commandSize,\n    SerializeBuffer* serializeBuffer,\n    const ObjectIdProvider& provider) const {\n    BindGroupLayoutSetLabelTransfer* transfer;\n    WIRE_TRY(serializeBuffer->Next(&transfer));\n    transfer->commandSize = commandSize;\n    return (BindGroupLayoutSetLabelSerialize(*this, transfer, serializeBuffer, provider));\n}\nWireResult BindGroupLayoutSetLabelCmd::Serialize(size_t commandSize, SerializeBuffer* serializeBuffer) const {\n    ErrorObjectIdProvider provider;\n    return Serialize(commandSize, serializeBuffer, provider);\n}\n\nWireResult BindGroupLayoutSetLabelCmd::Deserialize(\n    DeserializeBuffer* deserializeBuffer,\n    DeserializeAllocator* allocator,\n    const ObjectIdResolver& resolver) {\n    const volatile BindGroupLayoutSetLabelTransfer* transfer;\n    WIRE_TRY(deserializeBuffer->Read(&transfer));\n    return BindGroupLayoutSetLabelDeserialize(this, transfer, deserializeBuffer, allocator, resolver);\n}\nWireResult BindGroupLayoutSetLabelCmd::Deserialize(DeserializeBuffer* deserializeBuffer, DeserializeAllocator* allocator) {\n    ErrorObjectIdResolver resolver;\n    return Deserialize(deserializeBuffer, allocator, resolver);\n}\n\nsize_t BindGroupSetLabelCmd::GetRequiredSize() const {\n    return WireAlignSizeof<BindGroupSetLabelTransfer>() + BindGroupSetLabelGetExtraRequiredSize(*this);\n}\n\nWireResult BindGroupSetLabelCmd::Serialize(\n    size_t commandSize,\n    SerializeBuffer* serializeBuffer,\n    const ObjectIdProvider& provider) const {\n    BindGroupSetLabelTransfer* transfer;\n    WIRE_TRY(serializeBuffer->Next(&transfer));\n    transfer->commandSize = commandSize;\n    return (BindGroupSetLabelSerialize(*this, transfer, serializeBuffer, provider));\n}\nWireResult BindGroupSetLabelCmd::Serialize(size_t commandSize, SerializeBuffer* serializeBuffer) const {\n    ErrorObjectIdProvider provider;\n    return Serialize(commandSize, serializeBuffer, provider);\n}\n\nWireResult BindGroupSetLabelCmd::Deserialize(\n    DeserializeBuffer* deserializeBuffer,\n    DeserializeAllocator* allocator,\n    const ObjectIdResolver& resolver) {\n    const volatile BindGroupSetLabelTransfer* transfer;\n    WIRE_TRY(deserializeBuffer->Read(&transfer));\n    return BindGroupSetLabelDeserialize(this, transfer, deserializeBuffer, allocator, resolver);\n}\nWireResult BindGroupSetLabelCmd::Deserialize(DeserializeBuffer* deserializeBuffer, DeserializeAllocator* allocator) {\n    ErrorObjectIdResolver resolver;\n    return Deserialize(deserializeBuffer, allocator, resolver);\n}\n\nsize_t BufferDestroyCmd::GetRequiredSize() const {\n    return WireAlignSizeof<BufferDestroyTransfer>() + BufferDestroyGetExtraRequiredSize(*this);\n}\n\nWireResult BufferDestroyCmd::Serialize(\n    size_t commandSize,\n    SerializeBuffer* serializeBuffer,\n    const ObjectIdProvider& provider) const {\n    BufferDestroyTransfer* transfer;\n    WIRE_TRY(serializeBuffer->Next(&transfer));\n    transfer->commandSize = commandSize;\n    return (BufferDestroySerialize(*this, transfer, serializeBuffer, provider));\n}\nWireResult BufferDestroyCmd::Serialize(size_t commandSize, SerializeBuffer* serializeBuffer) const {\n    ErrorObjectIdProvider provider;\n    return Serialize(commandSize, serializeBuffer, provider);\n}\n\nWireResult BufferDestroyCmd::Deserialize(\n    DeserializeBuffer* deserializeBuffer,\n    DeserializeAllocator* allocator,\n    const ObjectIdResolver& resolver) {\n    const volatile BufferDestroyTransfer* transfer;\n    WIRE_TRY(deserializeBuffer->Read(&transfer));\n    return BufferDestroyDeserialize(this, transfer, deserializeBuffer, allocator, resolver);\n}\nWireResult BufferDestroyCmd::Deserialize(DeserializeBuffer* deserializeBuffer, DeserializeAllocator* allocator) {\n    ErrorObjectIdResolver resolver;\n    return Deserialize(deserializeBuffer, allocator, resolver);\n}\n\nsize_t BufferMapAsyncCmd::GetRequiredSize() const {\n    return WireAlignSizeof<BufferMapAsyncTransfer>() + BufferMapAsyncGetExtraRequiredSize(*this);\n}\n\nWireResult BufferMapAsyncCmd::Serialize(size_t commandSize, SerializeBuffer* serializeBuffer) const {\n    BufferMapAsyncTransfer* transfer;\n    WIRE_TRY(serializeBuffer->Next(&transfer));\n    transfer->commandSize = commandSize;\n    return (BufferMapAsyncSerialize(*this, transfer, serializeBuffer));\n}\nWireResult BufferMapAsyncCmd::Serialize(\n    size_t commandSize,\n    SerializeBuffer* serializeBuffer,\n    const ObjectIdProvider&) const {\n    return Serialize(commandSize, serializeBuffer);\n}\n\nWireResult BufferMapAsyncCmd::Deserialize(DeserializeBuffer* deserializeBuffer, DeserializeAllocator* allocator) {\n    const volatile BufferMapAsyncTransfer* transfer;\n    WIRE_TRY(deserializeBuffer->Read(&transfer));\n    return BufferMapAsyncDeserialize(this, transfer, deserializeBuffer, allocator);\n}\nWireResult BufferMapAsyncCmd::Deserialize(\n    DeserializeBuffer* deserializeBuffer,\n    DeserializeAllocator* allocator,\n    const ObjectIdResolver&) {\n    return Deserialize(deserializeBuffer, allocator);\n}\n\nsize_t BufferSetLabelCmd::GetRequiredSize() const {\n    return WireAlignSizeof<BufferSetLabelTransfer>() + BufferSetLabelGetExtraRequiredSize(*this);\n}\n\nWireResult BufferSetLabelCmd::Serialize(\n    size_t commandSize,\n    SerializeBuffer* serializeBuffer,\n    const ObjectIdProvider& provider) const {\n    BufferSetLabelTransfer* transfer;\n    WIRE_TRY(serializeBuffer->Next(&transfer));\n    transfer->commandSize = commandSize;\n    return (BufferSetLabelSerialize(*this, transfer, serializeBuffer, provider));\n}\nWireResult BufferSetLabelCmd::Serialize(size_t commandSize, SerializeBuffer* serializeBuffer) const {\n    ErrorObjectIdProvider provider;\n    return Serialize(commandSize, serializeBuffer, provider);\n}\n\nWireResult BufferSetLabelCmd::Deserialize(\n    DeserializeBuffer* deserializeBuffer,\n    DeserializeAllocator* allocator,\n    const ObjectIdResolver& resolver) {\n    const volatile BufferSetLabelTransfer* transfer;\n    WIRE_TRY(deserializeBuffer->Read(&transfer));\n    return BufferSetLabelDeserialize(this, transfer, deserializeBuffer, allocator, resolver);\n}\nWireResult BufferSetLabelCmd::Deserialize(DeserializeBuffer* deserializeBuffer, DeserializeAllocator* allocator) {\n    ErrorObjectIdResolver resolver;\n    return Deserialize(deserializeBuffer, allocator, resolver);\n}\n\nsize_t BufferUnmapCmd::GetRequiredSize() const {\n    return WireAlignSizeof<BufferUnmapTransfer>() + BufferUnmapGetExtraRequiredSize(*this);\n}\n\nWireResult BufferUnmapCmd::Serialize(\n    size_t commandSize,\n    SerializeBuffer* serializeBuffer,\n    const ObjectIdProvider& provider) const {\n    BufferUnmapTransfer* transfer;\n    WIRE_TRY(serializeBuffer->Next(&transfer));\n    transfer->commandSize = commandSize;\n    return (BufferUnmapSerialize(*this, transfer, serializeBuffer, provider));\n}\nWireResult BufferUnmapCmd::Serialize(size_t commandSize, SerializeBuffer* serializeBuffer) const {\n    ErrorObjectIdProvider provider;\n    return Serialize(commandSize, serializeBuffer, provider);\n}\n\nWireResult BufferUnmapCmd::Deserialize(\n    DeserializeBuffer* deserializeBuffer,\n    DeserializeAllocator* allocator,\n    const ObjectIdResolver& resolver) {\n    const volatile BufferUnmapTransfer* transfer;\n    WIRE_TRY(deserializeBuffer->Read(&transfer));\n    return BufferUnmapDeserialize(this, transfer, deserializeBuffer, allocator, resolver);\n}\nWireResult BufferUnmapCmd::Deserialize(DeserializeBuffer* deserializeBuffer, DeserializeAllocator* allocator) {\n    ErrorObjectIdResolver resolver;\n    return Deserialize(deserializeBuffer, allocator, resolver);\n}\n\nsize_t BufferUpdateMappedDataCmd::GetRequiredSize() const {\n    return WireAlignSizeof<BufferUpdateMappedDataTransfer>() + BufferUpdateMappedDataGetExtraRequiredSize(*this);\n}\n\nWireResult BufferUpdateMappedDataCmd::Serialize(size_t commandSize, SerializeBuffer* serializeBuffer) const {\n    BufferUpdateMappedDataTransfer* transfer;\n    WIRE_TRY(serializeBuffer->Next(&transfer));\n    transfer->commandSize = commandSize;\n    return (BufferUpdateMappedDataSerialize(*this, transfer, serializeBuffer));\n}\nWireResult BufferUpdateMappedDataCmd::Serialize(\n    size_t commandSize,\n    SerializeBuffer* serializeBuffer,\n    const ObjectIdProvider&) const {\n    return Serialize(commandSize, serializeBuffer);\n}\n\nWireResult BufferUpdateMappedDataCmd::Deserialize(DeserializeBuffer* deserializeBuffer, DeserializeAllocator* allocator) {\n    const volatile BufferUpdateMappedDataTransfer* transfer;\n    WIRE_TRY(deserializeBuffer->Read(&transfer));\n    return BufferUpdateMappedDataDeserialize(this, transfer, deserializeBuffer, allocator);\n}\nWireResult BufferUpdateMappedDataCmd::Deserialize(\n    DeserializeBuffer* deserializeBuffer,\n    DeserializeAllocator* allocator,\n    const ObjectIdResolver&) {\n    return Deserialize(deserializeBuffer, allocator);\n}\n\nsize_t CommandBufferSetLabelCmd::GetRequiredSize() const {\n    return WireAlignSizeof<CommandBufferSetLabelTransfer>() + CommandBufferSetLabelGetExtraRequiredSize(*this);\n}\n\nWireResult CommandBufferSetLabelCmd::Serialize(\n    size_t commandSize,\n    SerializeBuffer* serializeBuffer,\n    const ObjectIdProvider& provider) const {\n    CommandBufferSetLabelTransfer* transfer;\n    WIRE_TRY(serializeBuffer->Next(&transfer));\n    transfer->commandSize = commandSize;\n    return (CommandBufferSetLabelSerialize(*this, transfer, serializeBuffer, provider));\n}\nWireResult CommandBufferSetLabelCmd::Serialize(size_t commandSize, SerializeBuffer* serializeBuffer) const {\n    ErrorObjectIdProvider provider;\n    return Serialize(commandSize, serializeBuffer, provider);\n}\n\nWireResult CommandBufferSetLabelCmd::Deserialize(\n    DeserializeBuffer* deserializeBuffer,\n    DeserializeAllocator* allocator,\n    const ObjectIdResolver& resolver) {\n    const volatile CommandBufferSetLabelTransfer* transfer;\n    WIRE_TRY(deserializeBuffer->Read(&transfer));\n    return CommandBufferSetLabelDeserialize(this, transfer, deserializeBuffer, allocator, resolver);\n}\nWireResult CommandBufferSetLabelCmd::Deserialize(DeserializeBuffer* deserializeBuffer, DeserializeAllocator* allocator) {\n    ErrorObjectIdResolver resolver;\n    return Deserialize(deserializeBuffer, allocator, resolver);\n}\n\nsize_t CommandEncoderBeginComputePassCmd::GetRequiredSize() const {\n    return WireAlignSizeof<CommandEncoderBeginComputePassTransfer>() + CommandEncoderBeginComputePassGetExtraRequiredSize(*this);\n}\n\nWireResult CommandEncoderBeginComputePassCmd::Serialize(\n    size_t commandSize,\n    SerializeBuffer* serializeBuffer,\n    const ObjectIdProvider& provider) const {\n    CommandEncoderBeginComputePassTransfer* transfer;\n    WIRE_TRY(serializeBuffer->Next(&transfer));\n    transfer->commandSize = commandSize;\n    return (CommandEncoderBeginComputePassSerialize(*this, transfer, serializeBuffer, provider));\n}\nWireResult CommandEncoderBeginComputePassCmd::Serialize(size_t commandSize, SerializeBuffer* serializeBuffer) const {\n    ErrorObjectIdProvider provider;\n    return Serialize(commandSize, serializeBuffer, provider);\n}\n\nWireResult CommandEncoderBeginComputePassCmd::Deserialize(\n    DeserializeBuffer* deserializeBuffer,\n    DeserializeAllocator* allocator,\n    const ObjectIdResolver& resolver) {\n    const volatile CommandEncoderBeginComputePassTransfer* transfer;\n    WIRE_TRY(deserializeBuffer->Read(&transfer));\n    return CommandEncoderBeginComputePassDeserialize(this, transfer, deserializeBuffer, allocator, resolver);\n}\nWireResult CommandEncoderBeginComputePassCmd::Deserialize(DeserializeBuffer* deserializeBuffer, DeserializeAllocator* allocator) {\n    ErrorObjectIdResolver resolver;\n    return Deserialize(deserializeBuffer, allocator, resolver);\n}\n\nsize_t CommandEncoderBeginRenderPassCmd::GetRequiredSize() const {\n    return WireAlignSizeof<CommandEncoderBeginRenderPassTransfer>() + CommandEncoderBeginRenderPassGetExtraRequiredSize(*this);\n}\n\nWireResult CommandEncoderBeginRenderPassCmd::Serialize(\n    size_t commandSize,\n    SerializeBuffer* serializeBuffer,\n    const ObjectIdProvider& provider) const {\n    CommandEncoderBeginRenderPassTransfer* transfer;\n    WIRE_TRY(serializeBuffer->Next(&transfer));\n    transfer->commandSize = commandSize;\n    return (CommandEncoderBeginRenderPassSerialize(*this, transfer, serializeBuffer, provider));\n}\nWireResult CommandEncoderBeginRenderPassCmd::Serialize(size_t commandSize, SerializeBuffer* serializeBuffer) const {\n    ErrorObjectIdProvider provider;\n    return Serialize(commandSize, serializeBuffer, provider);\n}\n\nWireResult CommandEncoderBeginRenderPassCmd::Deserialize(\n    DeserializeBuffer* deserializeBuffer,\n    DeserializeAllocator* allocator,\n    const ObjectIdResolver& resolver) {\n    const volatile CommandEncoderBeginRenderPassTransfer* transfer;\n    WIRE_TRY(deserializeBuffer->Read(&transfer));\n    return CommandEncoderBeginRenderPassDeserialize(this, transfer, deserializeBuffer, allocator, resolver);\n}\nWireResult CommandEncoderBeginRenderPassCmd::Deserialize(DeserializeBuffer* deserializeBuffer, DeserializeAllocator* allocator) {\n    ErrorObjectIdResolver resolver;\n    return Deserialize(deserializeBuffer, allocator, resolver);\n}\n\nsize_t CommandEncoderClearBufferCmd::GetRequiredSize() const {\n    return WireAlignSizeof<CommandEncoderClearBufferTransfer>() + CommandEncoderClearBufferGetExtraRequiredSize(*this);\n}\n\nWireResult CommandEncoderClearBufferCmd::Serialize(\n    size_t commandSize,\n    SerializeBuffer* serializeBuffer,\n    const ObjectIdProvider& provider) const {\n    CommandEncoderClearBufferTransfer* transfer;\n    WIRE_TRY(serializeBuffer->Next(&transfer));\n    transfer->commandSize = commandSize;\n    return (CommandEncoderClearBufferSerialize(*this, transfer, serializeBuffer, provider));\n}\nWireResult CommandEncoderClearBufferCmd::Serialize(size_t commandSize, SerializeBuffer* serializeBuffer) const {\n    ErrorObjectIdProvider provider;\n    return Serialize(commandSize, serializeBuffer, provider);\n}\n\nWireResult CommandEncoderClearBufferCmd::Deserialize(\n    DeserializeBuffer* deserializeBuffer,\n    DeserializeAllocator* allocator,\n    const ObjectIdResolver& resolver) {\n    const volatile CommandEncoderClearBufferTransfer* transfer;\n    WIRE_TRY(deserializeBuffer->Read(&transfer));\n    return CommandEncoderClearBufferDeserialize(this, transfer, deserializeBuffer, allocator, resolver);\n}\nWireResult CommandEncoderClearBufferCmd::Deserialize(DeserializeBuffer* deserializeBuffer, DeserializeAllocator* allocator) {\n    ErrorObjectIdResolver resolver;\n    return Deserialize(deserializeBuffer, allocator, resolver);\n}\n\nsize_t CommandEncoderCopyBufferToBufferCmd::GetRequiredSize() const {\n    return WireAlignSizeof<CommandEncoderCopyBufferToBufferTransfer>() + CommandEncoderCopyBufferToBufferGetExtraRequiredSize(*this);\n}\n\nWireResult CommandEncoderCopyBufferToBufferCmd::Serialize(\n    size_t commandSize,\n    SerializeBuffer* serializeBuffer,\n    const ObjectIdProvider& provider) const {\n    CommandEncoderCopyBufferToBufferTransfer* transfer;\n    WIRE_TRY(serializeBuffer->Next(&transfer));\n    transfer->commandSize = commandSize;\n    return (CommandEncoderCopyBufferToBufferSerialize(*this, transfer, serializeBuffer, provider));\n}\nWireResult CommandEncoderCopyBufferToBufferCmd::Serialize(size_t commandSize, SerializeBuffer* serializeBuffer) const {\n    ErrorObjectIdProvider provider;\n    return Serialize(commandSize, serializeBuffer, provider);\n}\n\nWireResult CommandEncoderCopyBufferToBufferCmd::Deserialize(\n    DeserializeBuffer* deserializeBuffer,\n    DeserializeAllocator* allocator,\n    const ObjectIdResolver& resolver) {\n    const volatile CommandEncoderCopyBufferToBufferTransfer* transfer;\n    WIRE_TRY(deserializeBuffer->Read(&transfer));\n    return CommandEncoderCopyBufferToBufferDeserialize(this, transfer, deserializeBuffer, allocator, resolver);\n}\nWireResult CommandEncoderCopyBufferToBufferCmd::Deserialize(DeserializeBuffer* deserializeBuffer, DeserializeAllocator* allocator) {\n    ErrorObjectIdResolver resolver;\n    return Deserialize(deserializeBuffer, allocator, resolver);\n}\n\nsize_t CommandEncoderCopyBufferToTextureCmd::GetRequiredSize() const {\n    return WireAlignSizeof<CommandEncoderCopyBufferToTextureTransfer>() + CommandEncoderCopyBufferToTextureGetExtraRequiredSize(*this);\n}\n\nWireResult CommandEncoderCopyBufferToTextureCmd::Serialize(\n    size_t commandSize,\n    SerializeBuffer* serializeBuffer,\n    const ObjectIdProvider& provider) const {\n    CommandEncoderCopyBufferToTextureTransfer* transfer;\n    WIRE_TRY(serializeBuffer->Next(&transfer));\n    transfer->commandSize = commandSize;\n    return (CommandEncoderCopyBufferToTextureSerialize(*this, transfer, serializeBuffer, provider));\n}\nWireResult CommandEncoderCopyBufferToTextureCmd::Serialize(size_t commandSize, SerializeBuffer* serializeBuffer) const {\n    ErrorObjectIdProvider provider;\n    return Serialize(commandSize, serializeBuffer, provider);\n}\n\nWireResult CommandEncoderCopyBufferToTextureCmd::Deserialize(\n    DeserializeBuffer* deserializeBuffer,\n    DeserializeAllocator* allocator,\n    const ObjectIdResolver& resolver) {\n    const volatile CommandEncoderCopyBufferToTextureTransfer* transfer;\n    WIRE_TRY(deserializeBuffer->Read(&transfer));\n    return CommandEncoderCopyBufferToTextureDeserialize(this, transfer, deserializeBuffer, allocator, resolver);\n}\nWireResult CommandEncoderCopyBufferToTextureCmd::Deserialize(DeserializeBuffer* deserializeBuffer, DeserializeAllocator* allocator) {\n    ErrorObjectIdResolver resolver;\n    return Deserialize(deserializeBuffer, allocator, resolver);\n}\n\nsize_t CommandEncoderCopyTextureToBufferCmd::GetRequiredSize() const {\n    return WireAlignSizeof<CommandEncoderCopyTextureToBufferTransfer>() + CommandEncoderCopyTextureToBufferGetExtraRequiredSize(*this);\n}\n\nWireResult CommandEncoderCopyTextureToBufferCmd::Serialize(\n    size_t commandSize,\n    SerializeBuffer* serializeBuffer,\n    const ObjectIdProvider& provider) const {\n    CommandEncoderCopyTextureToBufferTransfer* transfer;\n    WIRE_TRY(serializeBuffer->Next(&transfer));\n    transfer->commandSize = commandSize;\n    return (CommandEncoderCopyTextureToBufferSerialize(*this, transfer, serializeBuffer, provider));\n}\nWireResult CommandEncoderCopyTextureToBufferCmd::Serialize(size_t commandSize, SerializeBuffer* serializeBuffer) const {\n    ErrorObjectIdProvider provider;\n    return Serialize(commandSize, serializeBuffer, provider);\n}\n\nWireResult CommandEncoderCopyTextureToBufferCmd::Deserialize(\n    DeserializeBuffer* deserializeBuffer,\n    DeserializeAllocator* allocator,\n    const ObjectIdResolver& resolver) {\n    const volatile CommandEncoderCopyTextureToBufferTransfer* transfer;\n    WIRE_TRY(deserializeBuffer->Read(&transfer));\n    return CommandEncoderCopyTextureToBufferDeserialize(this, transfer, deserializeBuffer, allocator, resolver);\n}\nWireResult CommandEncoderCopyTextureToBufferCmd::Deserialize(DeserializeBuffer* deserializeBuffer, DeserializeAllocator* allocator) {\n    ErrorObjectIdResolver resolver;\n    return Deserialize(deserializeBuffer, allocator, resolver);\n}\n\nsize_t CommandEncoderCopyTextureToTextureCmd::GetRequiredSize() const {\n    return WireAlignSizeof<CommandEncoderCopyTextureToTextureTransfer>() + CommandEncoderCopyTextureToTextureGetExtraRequiredSize(*this);\n}\n\nWireResult CommandEncoderCopyTextureToTextureCmd::Serialize(\n    size_t commandSize,\n    SerializeBuffer* serializeBuffer,\n    const ObjectIdProvider& provider) const {\n    CommandEncoderCopyTextureToTextureTransfer* transfer;\n    WIRE_TRY(serializeBuffer->Next(&transfer));\n    transfer->commandSize = commandSize;\n    return (CommandEncoderCopyTextureToTextureSerialize(*this, transfer, serializeBuffer, provider));\n}\nWireResult CommandEncoderCopyTextureToTextureCmd::Serialize(size_t commandSize, SerializeBuffer* serializeBuffer) const {\n    ErrorObjectIdProvider provider;\n    return Serialize(commandSize, serializeBuffer, provider);\n}\n\nWireResult CommandEncoderCopyTextureToTextureCmd::Deserialize(\n    DeserializeBuffer* deserializeBuffer,\n    DeserializeAllocator* allocator,\n    const ObjectIdResolver& resolver) {\n    const volatile CommandEncoderCopyTextureToTextureTransfer* transfer;\n    WIRE_TRY(deserializeBuffer->Read(&transfer));\n    return CommandEncoderCopyTextureToTextureDeserialize(this, transfer, deserializeBuffer, allocator, resolver);\n}\nWireResult CommandEncoderCopyTextureToTextureCmd::Deserialize(DeserializeBuffer* deserializeBuffer, DeserializeAllocator* allocator) {\n    ErrorObjectIdResolver resolver;\n    return Deserialize(deserializeBuffer, allocator, resolver);\n}\n\nsize_t CommandEncoderCopyTextureToTextureInternalCmd::GetRequiredSize() const {\n    return WireAlignSizeof<CommandEncoderCopyTextureToTextureInternalTransfer>() + CommandEncoderCopyTextureToTextureInternalGetExtraRequiredSize(*this);\n}\n\nWireResult CommandEncoderCopyTextureToTextureInternalCmd::Serialize(\n    size_t commandSize,\n    SerializeBuffer* serializeBuffer,\n    const ObjectIdProvider& provider) const {\n    CommandEncoderCopyTextureToTextureInternalTransfer* transfer;\n    WIRE_TRY(serializeBuffer->Next(&transfer));\n    transfer->commandSize = commandSize;\n    return (CommandEncoderCopyTextureToTextureInternalSerialize(*this, transfer, serializeBuffer, provider));\n}\nWireResult CommandEncoderCopyTextureToTextureInternalCmd::Serialize(size_t commandSize, SerializeBuffer* serializeBuffer) const {\n    ErrorObjectIdProvider provider;\n    return Serialize(commandSize, serializeBuffer, provider);\n}\n\nWireResult CommandEncoderCopyTextureToTextureInternalCmd::Deserialize(\n    DeserializeBuffer* deserializeBuffer,\n    DeserializeAllocator* allocator,\n    const ObjectIdResolver& resolver) {\n    const volatile CommandEncoderCopyTextureToTextureInternalTransfer* transfer;\n    WIRE_TRY(deserializeBuffer->Read(&transfer));\n    return CommandEncoderCopyTextureToTextureInternalDeserialize(this, transfer, deserializeBuffer, allocator, resolver);\n}\nWireResult CommandEncoderCopyTextureToTextureInternalCmd::Deserialize(DeserializeBuffer* deserializeBuffer, DeserializeAllocator* allocator) {\n    ErrorObjectIdResolver resolver;\n    return Deserialize(deserializeBuffer, allocator, resolver);\n}\n\nsize_t CommandEncoderFinishCmd::GetRequiredSize() const {\n    return WireAlignSizeof<CommandEncoderFinishTransfer>() + CommandEncoderFinishGetExtraRequiredSize(*this);\n}\n\nWireResult CommandEncoderFinishCmd::Serialize(\n    size_t commandSize,\n    SerializeBuffer* serializeBuffer,\n    const ObjectIdProvider& provider) const {\n    CommandEncoderFinishTransfer* transfer;\n    WIRE_TRY(serializeBuffer->Next(&transfer));\n    transfer->commandSize = commandSize;\n    return (CommandEncoderFinishSerialize(*this, transfer, serializeBuffer, provider));\n}\nWireResult CommandEncoderFinishCmd::Serialize(size_t commandSize, SerializeBuffer* serializeBuffer) const {\n    ErrorObjectIdProvider provider;\n    return Serialize(commandSize, serializeBuffer, provider);\n}\n\nWireResult CommandEncoderFinishCmd::Deserialize(\n    DeserializeBuffer* deserializeBuffer,\n    DeserializeAllocator* allocator,\n    const ObjectIdResolver& resolver) {\n    const volatile CommandEncoderFinishTransfer* transfer;\n    WIRE_TRY(deserializeBuffer->Read(&transfer));\n    return CommandEncoderFinishDeserialize(this, transfer, deserializeBuffer, allocator, resolver);\n}\nWireResult CommandEncoderFinishCmd::Deserialize(DeserializeBuffer* deserializeBuffer, DeserializeAllocator* allocator) {\n    ErrorObjectIdResolver resolver;\n    return Deserialize(deserializeBuffer, allocator, resolver);\n}\n\nsize_t CommandEncoderInjectValidationErrorCmd::GetRequiredSize() const {\n    return WireAlignSizeof<CommandEncoderInjectValidationErrorTransfer>() + CommandEncoderInjectValidationErrorGetExtraRequiredSize(*this);\n}\n\nWireResult CommandEncoderInjectValidationErrorCmd::Serialize(\n    size_t commandSize,\n    SerializeBuffer* serializeBuffer,\n    const ObjectIdProvider& provider) const {\n    CommandEncoderInjectValidationErrorTransfer* transfer;\n    WIRE_TRY(serializeBuffer->Next(&transfer));\n    transfer->commandSize = commandSize;\n    return (CommandEncoderInjectValidationErrorSerialize(*this, transfer, serializeBuffer, provider));\n}\nWireResult CommandEncoderInjectValidationErrorCmd::Serialize(size_t commandSize, SerializeBuffer* serializeBuffer) const {\n    ErrorObjectIdProvider provider;\n    return Serialize(commandSize, serializeBuffer, provider);\n}\n\nWireResult CommandEncoderInjectValidationErrorCmd::Deserialize(\n    DeserializeBuffer* deserializeBuffer,\n    DeserializeAllocator* allocator,\n    const ObjectIdResolver& resolver) {\n    const volatile CommandEncoderInjectValidationErrorTransfer* transfer;\n    WIRE_TRY(deserializeBuffer->Read(&transfer));\n    return CommandEncoderInjectValidationErrorDeserialize(this, transfer, deserializeBuffer, allocator, resolver);\n}\nWireResult CommandEncoderInjectValidationErrorCmd::Deserialize(DeserializeBuffer* deserializeBuffer, DeserializeAllocator* allocator) {\n    ErrorObjectIdResolver resolver;\n    return Deserialize(deserializeBuffer, allocator, resolver);\n}\n\nsize_t CommandEncoderInsertDebugMarkerCmd::GetRequiredSize() const {\n    return WireAlignSizeof<CommandEncoderInsertDebugMarkerTransfer>() + CommandEncoderInsertDebugMarkerGetExtraRequiredSize(*this);\n}\n\nWireResult CommandEncoderInsertDebugMarkerCmd::Serialize(\n    size_t commandSize,\n    SerializeBuffer* serializeBuffer,\n    const ObjectIdProvider& provider) const {\n    CommandEncoderInsertDebugMarkerTransfer* transfer;\n    WIRE_TRY(serializeBuffer->Next(&transfer));\n    transfer->commandSize = commandSize;\n    return (CommandEncoderInsertDebugMarkerSerialize(*this, transfer, serializeBuffer, provider));\n}\nWireResult CommandEncoderInsertDebugMarkerCmd::Serialize(size_t commandSize, SerializeBuffer* serializeBuffer) const {\n    ErrorObjectIdProvider provider;\n    return Serialize(commandSize, serializeBuffer, provider);\n}\n\nWireResult CommandEncoderInsertDebugMarkerCmd::Deserialize(\n    DeserializeBuffer* deserializeBuffer,\n    DeserializeAllocator* allocator,\n    const ObjectIdResolver& resolver) {\n    const volatile CommandEncoderInsertDebugMarkerTransfer* transfer;\n    WIRE_TRY(deserializeBuffer->Read(&transfer));\n    return CommandEncoderInsertDebugMarkerDeserialize(this, transfer, deserializeBuffer, allocator, resolver);\n}\nWireResult CommandEncoderInsertDebugMarkerCmd::Deserialize(DeserializeBuffer* deserializeBuffer, DeserializeAllocator* allocator) {\n    ErrorObjectIdResolver resolver;\n    return Deserialize(deserializeBuffer, allocator, resolver);\n}\n\nsize_t CommandEncoderPopDebugGroupCmd::GetRequiredSize() const {\n    return WireAlignSizeof<CommandEncoderPopDebugGroupTransfer>() + CommandEncoderPopDebugGroupGetExtraRequiredSize(*this);\n}\n\nWireResult CommandEncoderPopDebugGroupCmd::Serialize(\n    size_t commandSize,\n    SerializeBuffer* serializeBuffer,\n    const ObjectIdProvider& provider) const {\n    CommandEncoderPopDebugGroupTransfer* transfer;\n    WIRE_TRY(serializeBuffer->Next(&transfer));\n    transfer->commandSize = commandSize;\n    return (CommandEncoderPopDebugGroupSerialize(*this, transfer, serializeBuffer, provider));\n}\nWireResult CommandEncoderPopDebugGroupCmd::Serialize(size_t commandSize, SerializeBuffer* serializeBuffer) const {\n    ErrorObjectIdProvider provider;\n    return Serialize(commandSize, serializeBuffer, provider);\n}\n\nWireResult CommandEncoderPopDebugGroupCmd::Deserialize(\n    DeserializeBuffer* deserializeBuffer,\n    DeserializeAllocator* allocator,\n    const ObjectIdResolver& resolver) {\n    const volatile CommandEncoderPopDebugGroupTransfer* transfer;\n    WIRE_TRY(deserializeBuffer->Read(&transfer));\n    return CommandEncoderPopDebugGroupDeserialize(this, transfer, deserializeBuffer, allocator, resolver);\n}\nWireResult CommandEncoderPopDebugGroupCmd::Deserialize(DeserializeBuffer* deserializeBuffer, DeserializeAllocator* allocator) {\n    ErrorObjectIdResolver resolver;\n    return Deserialize(deserializeBuffer, allocator, resolver);\n}\n\nsize_t CommandEncoderPushDebugGroupCmd::GetRequiredSize() const {\n    return WireAlignSizeof<CommandEncoderPushDebugGroupTransfer>() + CommandEncoderPushDebugGroupGetExtraRequiredSize(*this);\n}\n\nWireResult CommandEncoderPushDebugGroupCmd::Serialize(\n    size_t commandSize,\n    SerializeBuffer* serializeBuffer,\n    const ObjectIdProvider& provider) const {\n    CommandEncoderPushDebugGroupTransfer* transfer;\n    WIRE_TRY(serializeBuffer->Next(&transfer));\n    transfer->commandSize = commandSize;\n    return (CommandEncoderPushDebugGroupSerialize(*this, transfer, serializeBuffer, provider));\n}\nWireResult CommandEncoderPushDebugGroupCmd::Serialize(size_t commandSize, SerializeBuffer* serializeBuffer) const {\n    ErrorObjectIdProvider provider;\n    return Serialize(commandSize, serializeBuffer, provider);\n}\n\nWireResult CommandEncoderPushDebugGroupCmd::Deserialize(\n    DeserializeBuffer* deserializeBuffer,\n    DeserializeAllocator* allocator,\n    const ObjectIdResolver& resolver) {\n    const volatile CommandEncoderPushDebugGroupTransfer* transfer;\n    WIRE_TRY(deserializeBuffer->Read(&transfer));\n    return CommandEncoderPushDebugGroupDeserialize(this, transfer, deserializeBuffer, allocator, resolver);\n}\nWireResult CommandEncoderPushDebugGroupCmd::Deserialize(DeserializeBuffer* deserializeBuffer, DeserializeAllocator* allocator) {\n    ErrorObjectIdResolver resolver;\n    return Deserialize(deserializeBuffer, allocator, resolver);\n}\n\nsize_t CommandEncoderResolveQuerySetCmd::GetRequiredSize() const {\n    return WireAlignSizeof<CommandEncoderResolveQuerySetTransfer>() + CommandEncoderResolveQuerySetGetExtraRequiredSize(*this);\n}\n\nWireResult CommandEncoderResolveQuerySetCmd::Serialize(\n    size_t commandSize,\n    SerializeBuffer* serializeBuffer,\n    const ObjectIdProvider& provider) const {\n    CommandEncoderResolveQuerySetTransfer* transfer;\n    WIRE_TRY(serializeBuffer->Next(&transfer));\n    transfer->commandSize = commandSize;\n    return (CommandEncoderResolveQuerySetSerialize(*this, transfer, serializeBuffer, provider));\n}\nWireResult CommandEncoderResolveQuerySetCmd::Serialize(size_t commandSize, SerializeBuffer* serializeBuffer) const {\n    ErrorObjectIdProvider provider;\n    return Serialize(commandSize, serializeBuffer, provider);\n}\n\nWireResult CommandEncoderResolveQuerySetCmd::Deserialize(\n    DeserializeBuffer* deserializeBuffer,\n    DeserializeAllocator* allocator,\n    const ObjectIdResolver& resolver) {\n    const volatile CommandEncoderResolveQuerySetTransfer* transfer;\n    WIRE_TRY(deserializeBuffer->Read(&transfer));\n    return CommandEncoderResolveQuerySetDeserialize(this, transfer, deserializeBuffer, allocator, resolver);\n}\nWireResult CommandEncoderResolveQuerySetCmd::Deserialize(DeserializeBuffer* deserializeBuffer, DeserializeAllocator* allocator) {\n    ErrorObjectIdResolver resolver;\n    return Deserialize(deserializeBuffer, allocator, resolver);\n}\n\nsize_t CommandEncoderSetLabelCmd::GetRequiredSize() const {\n    return WireAlignSizeof<CommandEncoderSetLabelTransfer>() + CommandEncoderSetLabelGetExtraRequiredSize(*this);\n}\n\nWireResult CommandEncoderSetLabelCmd::Serialize(\n    size_t commandSize,\n    SerializeBuffer* serializeBuffer,\n    const ObjectIdProvider& provider) const {\n    CommandEncoderSetLabelTransfer* transfer;\n    WIRE_TRY(serializeBuffer->Next(&transfer));\n    transfer->commandSize = commandSize;\n    return (CommandEncoderSetLabelSerialize(*this, transfer, serializeBuffer, provider));\n}\nWireResult CommandEncoderSetLabelCmd::Serialize(size_t commandSize, SerializeBuffer* serializeBuffer) const {\n    ErrorObjectIdProvider provider;\n    return Serialize(commandSize, serializeBuffer, provider);\n}\n\nWireResult CommandEncoderSetLabelCmd::Deserialize(\n    DeserializeBuffer* deserializeBuffer,\n    DeserializeAllocator* allocator,\n    const ObjectIdResolver& resolver) {\n    const volatile CommandEncoderSetLabelTransfer* transfer;\n    WIRE_TRY(deserializeBuffer->Read(&transfer));\n    return CommandEncoderSetLabelDeserialize(this, transfer, deserializeBuffer, allocator, resolver);\n}\nWireResult CommandEncoderSetLabelCmd::Deserialize(DeserializeBuffer* deserializeBuffer, DeserializeAllocator* allocator) {\n    ErrorObjectIdResolver resolver;\n    return Deserialize(deserializeBuffer, allocator, resolver);\n}\n\nsize_t CommandEncoderWriteBufferCmd::GetRequiredSize() const {\n    return WireAlignSizeof<CommandEncoderWriteBufferTransfer>() + CommandEncoderWriteBufferGetExtraRequiredSize(*this);\n}\n\nWireResult CommandEncoderWriteBufferCmd::Serialize(\n    size_t commandSize,\n    SerializeBuffer* serializeBuffer,\n    const ObjectIdProvider& provider) const {\n    CommandEncoderWriteBufferTransfer* transfer;\n    WIRE_TRY(serializeBuffer->Next(&transfer));\n    transfer->commandSize = commandSize;\n    return (CommandEncoderWriteBufferSerialize(*this, transfer, serializeBuffer, provider));\n}\nWireResult CommandEncoderWriteBufferCmd::Serialize(size_t commandSize, SerializeBuffer* serializeBuffer) const {\n    ErrorObjectIdProvider provider;\n    return Serialize(commandSize, serializeBuffer, provider);\n}\n\nWireResult CommandEncoderWriteBufferCmd::Deserialize(\n    DeserializeBuffer* deserializeBuffer,\n    DeserializeAllocator* allocator,\n    const ObjectIdResolver& resolver) {\n    const volatile CommandEncoderWriteBufferTransfer* transfer;\n    WIRE_TRY(deserializeBuffer->Read(&transfer));\n    return CommandEncoderWriteBufferDeserialize(this, transfer, deserializeBuffer, allocator, resolver);\n}\nWireResult CommandEncoderWriteBufferCmd::Deserialize(DeserializeBuffer* deserializeBuffer, DeserializeAllocator* allocator) {\n    ErrorObjectIdResolver resolver;\n    return Deserialize(deserializeBuffer, allocator, resolver);\n}\n\nsize_t CommandEncoderWriteTimestampCmd::GetRequiredSize() const {\n    return WireAlignSizeof<CommandEncoderWriteTimestampTransfer>() + CommandEncoderWriteTimestampGetExtraRequiredSize(*this);\n}\n\nWireResult CommandEncoderWriteTimestampCmd::Serialize(\n    size_t commandSize,\n    SerializeBuffer* serializeBuffer,\n    const ObjectIdProvider& provider) const {\n    CommandEncoderWriteTimestampTransfer* transfer;\n    WIRE_TRY(serializeBuffer->Next(&transfer));\n    transfer->commandSize = commandSize;\n    return (CommandEncoderWriteTimestampSerialize(*this, transfer, serializeBuffer, provider));\n}\nWireResult CommandEncoderWriteTimestampCmd::Serialize(size_t commandSize, SerializeBuffer* serializeBuffer) const {\n    ErrorObjectIdProvider provider;\n    return Serialize(commandSize, serializeBuffer, provider);\n}\n\nWireResult CommandEncoderWriteTimestampCmd::Deserialize(\n    DeserializeBuffer* deserializeBuffer,\n    DeserializeAllocator* allocator,\n    const ObjectIdResolver& resolver) {\n    const volatile CommandEncoderWriteTimestampTransfer* transfer;\n    WIRE_TRY(deserializeBuffer->Read(&transfer));\n    return CommandEncoderWriteTimestampDeserialize(this, transfer, deserializeBuffer, allocator, resolver);\n}\nWireResult CommandEncoderWriteTimestampCmd::Deserialize(DeserializeBuffer* deserializeBuffer, DeserializeAllocator* allocator) {\n    ErrorObjectIdResolver resolver;\n    return Deserialize(deserializeBuffer, allocator, resolver);\n}\n\nsize_t ComputePassEncoderDispatchWorkgroupsCmd::GetRequiredSize() const {\n    return WireAlignSizeof<ComputePassEncoderDispatchWorkgroupsTransfer>() + ComputePassEncoderDispatchWorkgroupsGetExtraRequiredSize(*this);\n}\n\nWireResult ComputePassEncoderDispatchWorkgroupsCmd::Serialize(\n    size_t commandSize,\n    SerializeBuffer* serializeBuffer,\n    const ObjectIdProvider& provider) const {\n    ComputePassEncoderDispatchWorkgroupsTransfer* transfer;\n    WIRE_TRY(serializeBuffer->Next(&transfer));\n    transfer->commandSize = commandSize;\n    return (ComputePassEncoderDispatchWorkgroupsSerialize(*this, transfer, serializeBuffer, provider));\n}\nWireResult ComputePassEncoderDispatchWorkgroupsCmd::Serialize(size_t commandSize, SerializeBuffer* serializeBuffer) const {\n    ErrorObjectIdProvider provider;\n    return Serialize(commandSize, serializeBuffer, provider);\n}\n\nWireResult ComputePassEncoderDispatchWorkgroupsCmd::Deserialize(\n    DeserializeBuffer* deserializeBuffer,\n    DeserializeAllocator* allocator,\n    const ObjectIdResolver& resolver) {\n    const volatile ComputePassEncoderDispatchWorkgroupsTransfer* transfer;\n    WIRE_TRY(deserializeBuffer->Read(&transfer));\n    return ComputePassEncoderDispatchWorkgroupsDeserialize(this, transfer, deserializeBuffer, allocator, resolver);\n}\nWireResult ComputePassEncoderDispatchWorkgroupsCmd::Deserialize(DeserializeBuffer* deserializeBuffer, DeserializeAllocator* allocator) {\n    ErrorObjectIdResolver resolver;\n    return Deserialize(deserializeBuffer, allocator, resolver);\n}\n\nsize_t ComputePassEncoderDispatchWorkgroupsIndirectCmd::GetRequiredSize() const {\n    return WireAlignSizeof<ComputePassEncoderDispatchWorkgroupsIndirectTransfer>() + ComputePassEncoderDispatchWorkgroupsIndirectGetExtraRequiredSize(*this);\n}\n\nWireResult ComputePassEncoderDispatchWorkgroupsIndirectCmd::Serialize(\n    size_t commandSize,\n    SerializeBuffer* serializeBuffer,\n    const ObjectIdProvider& provider) const {\n    ComputePassEncoderDispatchWorkgroupsIndirectTransfer* transfer;\n    WIRE_TRY(serializeBuffer->Next(&transfer));\n    transfer->commandSize = commandSize;\n    return (ComputePassEncoderDispatchWorkgroupsIndirectSerialize(*this, transfer, serializeBuffer, provider));\n}\nWireResult ComputePassEncoderDispatchWorkgroupsIndirectCmd::Serialize(size_t commandSize, SerializeBuffer* serializeBuffer) const {\n    ErrorObjectIdProvider provider;\n    return Serialize(commandSize, serializeBuffer, provider);\n}\n\nWireResult ComputePassEncoderDispatchWorkgroupsIndirectCmd::Deserialize(\n    DeserializeBuffer* deserializeBuffer,\n    DeserializeAllocator* allocator,\n    const ObjectIdResolver& resolver) {\n    const volatile ComputePassEncoderDispatchWorkgroupsIndirectTransfer* transfer;\n    WIRE_TRY(deserializeBuffer->Read(&transfer));\n    return ComputePassEncoderDispatchWorkgroupsIndirectDeserialize(this, transfer, deserializeBuffer, allocator, resolver);\n}\nWireResult ComputePassEncoderDispatchWorkgroupsIndirectCmd::Deserialize(DeserializeBuffer* deserializeBuffer, DeserializeAllocator* allocator) {\n    ErrorObjectIdResolver resolver;\n    return Deserialize(deserializeBuffer, allocator, resolver);\n}\n\nsize_t ComputePassEncoderEndCmd::GetRequiredSize() const {\n    return WireAlignSizeof<ComputePassEncoderEndTransfer>() + ComputePassEncoderEndGetExtraRequiredSize(*this);\n}\n\nWireResult ComputePassEncoderEndCmd::Serialize(\n    size_t commandSize,\n    SerializeBuffer* serializeBuffer,\n    const ObjectIdProvider& provider) const {\n    ComputePassEncoderEndTransfer* transfer;\n    WIRE_TRY(serializeBuffer->Next(&transfer));\n    transfer->commandSize = commandSize;\n    return (ComputePassEncoderEndSerialize(*this, transfer, serializeBuffer, provider));\n}\nWireResult ComputePassEncoderEndCmd::Serialize(size_t commandSize, SerializeBuffer* serializeBuffer) const {\n    ErrorObjectIdProvider provider;\n    return Serialize(commandSize, serializeBuffer, provider);\n}\n\nWireResult ComputePassEncoderEndCmd::Deserialize(\n    DeserializeBuffer* deserializeBuffer,\n    DeserializeAllocator* allocator,\n    const ObjectIdResolver& resolver) {\n    const volatile ComputePassEncoderEndTransfer* transfer;\n    WIRE_TRY(deserializeBuffer->Read(&transfer));\n    return ComputePassEncoderEndDeserialize(this, transfer, deserializeBuffer, allocator, resolver);\n}\nWireResult ComputePassEncoderEndCmd::Deserialize(DeserializeBuffer* deserializeBuffer, DeserializeAllocator* allocator) {\n    ErrorObjectIdResolver resolver;\n    return Deserialize(deserializeBuffer, allocator, resolver);\n}\n\nsize_t ComputePassEncoderInsertDebugMarkerCmd::GetRequiredSize() const {\n    return WireAlignSizeof<ComputePassEncoderInsertDebugMarkerTransfer>() + ComputePassEncoderInsertDebugMarkerGetExtraRequiredSize(*this);\n}\n\nWireResult ComputePassEncoderInsertDebugMarkerCmd::Serialize(\n    size_t commandSize,\n    SerializeBuffer* serializeBuffer,\n    const ObjectIdProvider& provider) const {\n    ComputePassEncoderInsertDebugMarkerTransfer* transfer;\n    WIRE_TRY(serializeBuffer->Next(&transfer));\n    transfer->commandSize = commandSize;\n    return (ComputePassEncoderInsertDebugMarkerSerialize(*this, transfer, serializeBuffer, provider));\n}\nWireResult ComputePassEncoderInsertDebugMarkerCmd::Serialize(size_t commandSize, SerializeBuffer* serializeBuffer) const {\n    ErrorObjectIdProvider provider;\n    return Serialize(commandSize, serializeBuffer, provider);\n}\n\nWireResult ComputePassEncoderInsertDebugMarkerCmd::Deserialize(\n    DeserializeBuffer* deserializeBuffer,\n    DeserializeAllocator* allocator,\n    const ObjectIdResolver& resolver) {\n    const volatile ComputePassEncoderInsertDebugMarkerTransfer* transfer;\n    WIRE_TRY(deserializeBuffer->Read(&transfer));\n    return ComputePassEncoderInsertDebugMarkerDeserialize(this, transfer, deserializeBuffer, allocator, resolver);\n}\nWireResult ComputePassEncoderInsertDebugMarkerCmd::Deserialize(DeserializeBuffer* deserializeBuffer, DeserializeAllocator* allocator) {\n    ErrorObjectIdResolver resolver;\n    return Deserialize(deserializeBuffer, allocator, resolver);\n}\n\nsize_t ComputePassEncoderPopDebugGroupCmd::GetRequiredSize() const {\n    return WireAlignSizeof<ComputePassEncoderPopDebugGroupTransfer>() + ComputePassEncoderPopDebugGroupGetExtraRequiredSize(*this);\n}\n\nWireResult ComputePassEncoderPopDebugGroupCmd::Serialize(\n    size_t commandSize,\n    SerializeBuffer* serializeBuffer,\n    const ObjectIdProvider& provider) const {\n    ComputePassEncoderPopDebugGroupTransfer* transfer;\n    WIRE_TRY(serializeBuffer->Next(&transfer));\n    transfer->commandSize = commandSize;\n    return (ComputePassEncoderPopDebugGroupSerialize(*this, transfer, serializeBuffer, provider));\n}\nWireResult ComputePassEncoderPopDebugGroupCmd::Serialize(size_t commandSize, SerializeBuffer* serializeBuffer) const {\n    ErrorObjectIdProvider provider;\n    return Serialize(commandSize, serializeBuffer, provider);\n}\n\nWireResult ComputePassEncoderPopDebugGroupCmd::Deserialize(\n    DeserializeBuffer* deserializeBuffer,\n    DeserializeAllocator* allocator,\n    const ObjectIdResolver& resolver) {\n    const volatile ComputePassEncoderPopDebugGroupTransfer* transfer;\n    WIRE_TRY(deserializeBuffer->Read(&transfer));\n    return ComputePassEncoderPopDebugGroupDeserialize(this, transfer, deserializeBuffer, allocator, resolver);\n}\nWireResult ComputePassEncoderPopDebugGroupCmd::Deserialize(DeserializeBuffer* deserializeBuffer, DeserializeAllocator* allocator) {\n    ErrorObjectIdResolver resolver;\n    return Deserialize(deserializeBuffer, allocator, resolver);\n}\n\nsize_t ComputePassEncoderPushDebugGroupCmd::GetRequiredSize() const {\n    return WireAlignSizeof<ComputePassEncoderPushDebugGroupTransfer>() + ComputePassEncoderPushDebugGroupGetExtraRequiredSize(*this);\n}\n\nWireResult ComputePassEncoderPushDebugGroupCmd::Serialize(\n    size_t commandSize,\n    SerializeBuffer* serializeBuffer,\n    const ObjectIdProvider& provider) const {\n    ComputePassEncoderPushDebugGroupTransfer* transfer;\n    WIRE_TRY(serializeBuffer->Next(&transfer));\n    transfer->commandSize = commandSize;\n    return (ComputePassEncoderPushDebugGroupSerialize(*this, transfer, serializeBuffer, provider));\n}\nWireResult ComputePassEncoderPushDebugGroupCmd::Serialize(size_t commandSize, SerializeBuffer* serializeBuffer) const {\n    ErrorObjectIdProvider provider;\n    return Serialize(commandSize, serializeBuffer, provider);\n}\n\nWireResult ComputePassEncoderPushDebugGroupCmd::Deserialize(\n    DeserializeBuffer* deserializeBuffer,\n    DeserializeAllocator* allocator,\n    const ObjectIdResolver& resolver) {\n    const volatile ComputePassEncoderPushDebugGroupTransfer* transfer;\n    WIRE_TRY(deserializeBuffer->Read(&transfer));\n    return ComputePassEncoderPushDebugGroupDeserialize(this, transfer, deserializeBuffer, allocator, resolver);\n}\nWireResult ComputePassEncoderPushDebugGroupCmd::Deserialize(DeserializeBuffer* deserializeBuffer, DeserializeAllocator* allocator) {\n    ErrorObjectIdResolver resolver;\n    return Deserialize(deserializeBuffer, allocator, resolver);\n}\n\nsize_t ComputePassEncoderSetBindGroupCmd::GetRequiredSize() const {\n    return WireAlignSizeof<ComputePassEncoderSetBindGroupTransfer>() + ComputePassEncoderSetBindGroupGetExtraRequiredSize(*this);\n}\n\nWireResult ComputePassEncoderSetBindGroupCmd::Serialize(\n    size_t commandSize,\n    SerializeBuffer* serializeBuffer,\n    const ObjectIdProvider& provider) const {\n    ComputePassEncoderSetBindGroupTransfer* transfer;\n    WIRE_TRY(serializeBuffer->Next(&transfer));\n    transfer->commandSize = commandSize;\n    return (ComputePassEncoderSetBindGroupSerialize(*this, transfer, serializeBuffer, provider));\n}\nWireResult ComputePassEncoderSetBindGroupCmd::Serialize(size_t commandSize, SerializeBuffer* serializeBuffer) const {\n    ErrorObjectIdProvider provider;\n    return Serialize(commandSize, serializeBuffer, provider);\n}\n\nWireResult ComputePassEncoderSetBindGroupCmd::Deserialize(\n    DeserializeBuffer* deserializeBuffer,\n    DeserializeAllocator* allocator,\n    const ObjectIdResolver& resolver) {\n    const volatile ComputePassEncoderSetBindGroupTransfer* transfer;\n    WIRE_TRY(deserializeBuffer->Read(&transfer));\n    return ComputePassEncoderSetBindGroupDeserialize(this, transfer, deserializeBuffer, allocator, resolver);\n}\nWireResult ComputePassEncoderSetBindGroupCmd::Deserialize(DeserializeBuffer* deserializeBuffer, DeserializeAllocator* allocator) {\n    ErrorObjectIdResolver resolver;\n    return Deserialize(deserializeBuffer, allocator, resolver);\n}\n\nsize_t ComputePassEncoderSetLabelCmd::GetRequiredSize() const {\n    return WireAlignSizeof<ComputePassEncoderSetLabelTransfer>() + ComputePassEncoderSetLabelGetExtraRequiredSize(*this);\n}\n\nWireResult ComputePassEncoderSetLabelCmd::Serialize(\n    size_t commandSize,\n    SerializeBuffer* serializeBuffer,\n    const ObjectIdProvider& provider) const {\n    ComputePassEncoderSetLabelTransfer* transfer;\n    WIRE_TRY(serializeBuffer->Next(&transfer));\n    transfer->commandSize = commandSize;\n    return (ComputePassEncoderSetLabelSerialize(*this, transfer, serializeBuffer, provider));\n}\nWireResult ComputePassEncoderSetLabelCmd::Serialize(size_t commandSize, SerializeBuffer* serializeBuffer) const {\n    ErrorObjectIdProvider provider;\n    return Serialize(commandSize, serializeBuffer, provider);\n}\n\nWireResult ComputePassEncoderSetLabelCmd::Deserialize(\n    DeserializeBuffer* deserializeBuffer,\n    DeserializeAllocator* allocator,\n    const ObjectIdResolver& resolver) {\n    const volatile ComputePassEncoderSetLabelTransfer* transfer;\n    WIRE_TRY(deserializeBuffer->Read(&transfer));\n    return ComputePassEncoderSetLabelDeserialize(this, transfer, deserializeBuffer, allocator, resolver);\n}\nWireResult ComputePassEncoderSetLabelCmd::Deserialize(DeserializeBuffer* deserializeBuffer, DeserializeAllocator* allocator) {\n    ErrorObjectIdResolver resolver;\n    return Deserialize(deserializeBuffer, allocator, resolver);\n}\n\nsize_t ComputePassEncoderSetPipelineCmd::GetRequiredSize() const {\n    return WireAlignSizeof<ComputePassEncoderSetPipelineTransfer>() + ComputePassEncoderSetPipelineGetExtraRequiredSize(*this);\n}\n\nWireResult ComputePassEncoderSetPipelineCmd::Serialize(\n    size_t commandSize,\n    SerializeBuffer* serializeBuffer,\n    const ObjectIdProvider& provider) const {\n    ComputePassEncoderSetPipelineTransfer* transfer;\n    WIRE_TRY(serializeBuffer->Next(&transfer));\n    transfer->commandSize = commandSize;\n    return (ComputePassEncoderSetPipelineSerialize(*this, transfer, serializeBuffer, provider));\n}\nWireResult ComputePassEncoderSetPipelineCmd::Serialize(size_t commandSize, SerializeBuffer* serializeBuffer) const {\n    ErrorObjectIdProvider provider;\n    return Serialize(commandSize, serializeBuffer, provider);\n}\n\nWireResult ComputePassEncoderSetPipelineCmd::Deserialize(\n    DeserializeBuffer* deserializeBuffer,\n    DeserializeAllocator* allocator,\n    const ObjectIdResolver& resolver) {\n    const volatile ComputePassEncoderSetPipelineTransfer* transfer;\n    WIRE_TRY(deserializeBuffer->Read(&transfer));\n    return ComputePassEncoderSetPipelineDeserialize(this, transfer, deserializeBuffer, allocator, resolver);\n}\nWireResult ComputePassEncoderSetPipelineCmd::Deserialize(DeserializeBuffer* deserializeBuffer, DeserializeAllocator* allocator) {\n    ErrorObjectIdResolver resolver;\n    return Deserialize(deserializeBuffer, allocator, resolver);\n}\n\nsize_t ComputePassEncoderWriteTimestampCmd::GetRequiredSize() const {\n    return WireAlignSizeof<ComputePassEncoderWriteTimestampTransfer>() + ComputePassEncoderWriteTimestampGetExtraRequiredSize(*this);\n}\n\nWireResult ComputePassEncoderWriteTimestampCmd::Serialize(\n    size_t commandSize,\n    SerializeBuffer* serializeBuffer,\n    const ObjectIdProvider& provider) const {\n    ComputePassEncoderWriteTimestampTransfer* transfer;\n    WIRE_TRY(serializeBuffer->Next(&transfer));\n    transfer->commandSize = commandSize;\n    return (ComputePassEncoderWriteTimestampSerialize(*this, transfer, serializeBuffer, provider));\n}\nWireResult ComputePassEncoderWriteTimestampCmd::Serialize(size_t commandSize, SerializeBuffer* serializeBuffer) const {\n    ErrorObjectIdProvider provider;\n    return Serialize(commandSize, serializeBuffer, provider);\n}\n\nWireResult ComputePassEncoderWriteTimestampCmd::Deserialize(\n    DeserializeBuffer* deserializeBuffer,\n    DeserializeAllocator* allocator,\n    const ObjectIdResolver& resolver) {\n    const volatile ComputePassEncoderWriteTimestampTransfer* transfer;\n    WIRE_TRY(deserializeBuffer->Read(&transfer));\n    return ComputePassEncoderWriteTimestampDeserialize(this, transfer, deserializeBuffer, allocator, resolver);\n}\nWireResult ComputePassEncoderWriteTimestampCmd::Deserialize(DeserializeBuffer* deserializeBuffer, DeserializeAllocator* allocator) {\n    ErrorObjectIdResolver resolver;\n    return Deserialize(deserializeBuffer, allocator, resolver);\n}\n\nsize_t ComputePipelineGetBindGroupLayoutCmd::GetRequiredSize() const {\n    return WireAlignSizeof<ComputePipelineGetBindGroupLayoutTransfer>() + ComputePipelineGetBindGroupLayoutGetExtraRequiredSize(*this);\n}\n\nWireResult ComputePipelineGetBindGroupLayoutCmd::Serialize(\n    size_t commandSize,\n    SerializeBuffer* serializeBuffer,\n    const ObjectIdProvider& provider) const {\n    ComputePipelineGetBindGroupLayoutTransfer* transfer;\n    WIRE_TRY(serializeBuffer->Next(&transfer));\n    transfer->commandSize = commandSize;\n    return (ComputePipelineGetBindGroupLayoutSerialize(*this, transfer, serializeBuffer, provider));\n}\nWireResult ComputePipelineGetBindGroupLayoutCmd::Serialize(size_t commandSize, SerializeBuffer* serializeBuffer) const {\n    ErrorObjectIdProvider provider;\n    return Serialize(commandSize, serializeBuffer, provider);\n}\n\nWireResult ComputePipelineGetBindGroupLayoutCmd::Deserialize(\n    DeserializeBuffer* deserializeBuffer,\n    DeserializeAllocator* allocator,\n    const ObjectIdResolver& resolver) {\n    const volatile ComputePipelineGetBindGroupLayoutTransfer* transfer;\n    WIRE_TRY(deserializeBuffer->Read(&transfer));\n    return ComputePipelineGetBindGroupLayoutDeserialize(this, transfer, deserializeBuffer, allocator, resolver);\n}\nWireResult ComputePipelineGetBindGroupLayoutCmd::Deserialize(DeserializeBuffer* deserializeBuffer, DeserializeAllocator* allocator) {\n    ErrorObjectIdResolver resolver;\n    return Deserialize(deserializeBuffer, allocator, resolver);\n}\n\nsize_t ComputePipelineSetLabelCmd::GetRequiredSize() const {\n    return WireAlignSizeof<ComputePipelineSetLabelTransfer>() + ComputePipelineSetLabelGetExtraRequiredSize(*this);\n}\n\nWireResult ComputePipelineSetLabelCmd::Serialize(\n    size_t commandSize,\n    SerializeBuffer* serializeBuffer,\n    const ObjectIdProvider& provider) const {\n    ComputePipelineSetLabelTransfer* transfer;\n    WIRE_TRY(serializeBuffer->Next(&transfer));\n    transfer->commandSize = commandSize;\n    return (ComputePipelineSetLabelSerialize(*this, transfer, serializeBuffer, provider));\n}\nWireResult ComputePipelineSetLabelCmd::Serialize(size_t commandSize, SerializeBuffer* serializeBuffer) const {\n    ErrorObjectIdProvider provider;\n    return Serialize(commandSize, serializeBuffer, provider);\n}\n\nWireResult ComputePipelineSetLabelCmd::Deserialize(\n    DeserializeBuffer* deserializeBuffer,\n    DeserializeAllocator* allocator,\n    const ObjectIdResolver& resolver) {\n    const volatile ComputePipelineSetLabelTransfer* transfer;\n    WIRE_TRY(deserializeBuffer->Read(&transfer));\n    return ComputePipelineSetLabelDeserialize(this, transfer, deserializeBuffer, allocator, resolver);\n}\nWireResult ComputePipelineSetLabelCmd::Deserialize(DeserializeBuffer* deserializeBuffer, DeserializeAllocator* allocator) {\n    ErrorObjectIdResolver resolver;\n    return Deserialize(deserializeBuffer, allocator, resolver);\n}\n\nsize_t DestroyObjectCmd::GetRequiredSize() const {\n    return WireAlignSizeof<DestroyObjectTransfer>() + DestroyObjectGetExtraRequiredSize(*this);\n}\n\nWireResult DestroyObjectCmd::Serialize(size_t commandSize, SerializeBuffer* serializeBuffer) const {\n    DestroyObjectTransfer* transfer;\n    WIRE_TRY(serializeBuffer->Next(&transfer));\n    transfer->commandSize = commandSize;\n    return (DestroyObjectSerialize(*this, transfer, serializeBuffer));\n}\nWireResult DestroyObjectCmd::Serialize(\n    size_t commandSize,\n    SerializeBuffer* serializeBuffer,\n    const ObjectIdProvider&) const {\n    return Serialize(commandSize, serializeBuffer);\n}\n\nWireResult DestroyObjectCmd::Deserialize(DeserializeBuffer* deserializeBuffer, DeserializeAllocator* allocator) {\n    const volatile DestroyObjectTransfer* transfer;\n    WIRE_TRY(deserializeBuffer->Read(&transfer));\n    return DestroyObjectDeserialize(this, transfer, deserializeBuffer, allocator);\n}\nWireResult DestroyObjectCmd::Deserialize(\n    DeserializeBuffer* deserializeBuffer,\n    DeserializeAllocator* allocator,\n    const ObjectIdResolver&) {\n    return Deserialize(deserializeBuffer, allocator);\n}\n\nsize_t DeviceCreateBindGroupCmd::GetRequiredSize() const {\n    return WireAlignSizeof<DeviceCreateBindGroupTransfer>() + DeviceCreateBindGroupGetExtraRequiredSize(*this);\n}\n\nWireResult DeviceCreateBindGroupCmd::Serialize(\n    size_t commandSize,\n    SerializeBuffer* serializeBuffer,\n    const ObjectIdProvider& provider) const {\n    DeviceCreateBindGroupTransfer* transfer;\n    WIRE_TRY(serializeBuffer->Next(&transfer));\n    transfer->commandSize = commandSize;\n    return (DeviceCreateBindGroupSerialize(*this, transfer, serializeBuffer, provider));\n}\nWireResult DeviceCreateBindGroupCmd::Serialize(size_t commandSize, SerializeBuffer* serializeBuffer) const {\n    ErrorObjectIdProvider provider;\n    return Serialize(commandSize, serializeBuffer, provider);\n}\n\nWireResult DeviceCreateBindGroupCmd::Deserialize(\n    DeserializeBuffer* deserializeBuffer,\n    DeserializeAllocator* allocator,\n    const ObjectIdResolver& resolver) {\n    const volatile DeviceCreateBindGroupTransfer* transfer;\n    WIRE_TRY(deserializeBuffer->Read(&transfer));\n    return DeviceCreateBindGroupDeserialize(this, transfer, deserializeBuffer, allocator, resolver);\n}\nWireResult DeviceCreateBindGroupCmd::Deserialize(DeserializeBuffer* deserializeBuffer, DeserializeAllocator* allocator) {\n    ErrorObjectIdResolver resolver;\n    return Deserialize(deserializeBuffer, allocator, resolver);\n}\n\nsize_t DeviceCreateBindGroupLayoutCmd::GetRequiredSize() const {\n    return WireAlignSizeof<DeviceCreateBindGroupLayoutTransfer>() + DeviceCreateBindGroupLayoutGetExtraRequiredSize(*this);\n}\n\nWireResult DeviceCreateBindGroupLayoutCmd::Serialize(\n    size_t commandSize,\n    SerializeBuffer* serializeBuffer,\n    const ObjectIdProvider& provider) const {\n    DeviceCreateBindGroupLayoutTransfer* transfer;\n    WIRE_TRY(serializeBuffer->Next(&transfer));\n    transfer->commandSize = commandSize;\n    return (DeviceCreateBindGroupLayoutSerialize(*this, transfer, serializeBuffer, provider));\n}\nWireResult DeviceCreateBindGroupLayoutCmd::Serialize(size_t commandSize, SerializeBuffer* serializeBuffer) const {\n    ErrorObjectIdProvider provider;\n    return Serialize(commandSize, serializeBuffer, provider);\n}\n\nWireResult DeviceCreateBindGroupLayoutCmd::Deserialize(\n    DeserializeBuffer* deserializeBuffer,\n    DeserializeAllocator* allocator,\n    const ObjectIdResolver& resolver) {\n    const volatile DeviceCreateBindGroupLayoutTransfer* transfer;\n    WIRE_TRY(deserializeBuffer->Read(&transfer));\n    return DeviceCreateBindGroupLayoutDeserialize(this, transfer, deserializeBuffer, allocator, resolver);\n}\nWireResult DeviceCreateBindGroupLayoutCmd::Deserialize(DeserializeBuffer* deserializeBuffer, DeserializeAllocator* allocator) {\n    ErrorObjectIdResolver resolver;\n    return Deserialize(deserializeBuffer, allocator, resolver);\n}\n\nsize_t DeviceCreateBufferCmd::GetRequiredSize() const {\n    return WireAlignSizeof<DeviceCreateBufferTransfer>() + DeviceCreateBufferGetExtraRequiredSize(*this);\n}\n\nWireResult DeviceCreateBufferCmd::Serialize(\n    size_t commandSize,\n    SerializeBuffer* serializeBuffer,\n    const ObjectIdProvider& provider) const {\n    DeviceCreateBufferTransfer* transfer;\n    WIRE_TRY(serializeBuffer->Next(&transfer));\n    transfer->commandSize = commandSize;\n    return (DeviceCreateBufferSerialize(*this, transfer, serializeBuffer, provider));\n}\nWireResult DeviceCreateBufferCmd::Serialize(size_t commandSize, SerializeBuffer* serializeBuffer) const {\n    ErrorObjectIdProvider provider;\n    return Serialize(commandSize, serializeBuffer, provider);\n}\n\nWireResult DeviceCreateBufferCmd::Deserialize(\n    DeserializeBuffer* deserializeBuffer,\n    DeserializeAllocator* allocator,\n    const ObjectIdResolver& resolver) {\n    const volatile DeviceCreateBufferTransfer* transfer;\n    WIRE_TRY(deserializeBuffer->Read(&transfer));\n    return DeviceCreateBufferDeserialize(this, transfer, deserializeBuffer, allocator, resolver);\n}\nWireResult DeviceCreateBufferCmd::Deserialize(DeserializeBuffer* deserializeBuffer, DeserializeAllocator* allocator) {\n    ErrorObjectIdResolver resolver;\n    return Deserialize(deserializeBuffer, allocator, resolver);\n}\n\nsize_t DeviceCreateCommandEncoderCmd::GetRequiredSize() const {\n    return WireAlignSizeof<DeviceCreateCommandEncoderTransfer>() + DeviceCreateCommandEncoderGetExtraRequiredSize(*this);\n}\n\nWireResult DeviceCreateCommandEncoderCmd::Serialize(\n    size_t commandSize,\n    SerializeBuffer* serializeBuffer,\n    const ObjectIdProvider& provider) const {\n    DeviceCreateCommandEncoderTransfer* transfer;\n    WIRE_TRY(serializeBuffer->Next(&transfer));\n    transfer->commandSize = commandSize;\n    return (DeviceCreateCommandEncoderSerialize(*this, transfer, serializeBuffer, provider));\n}\nWireResult DeviceCreateCommandEncoderCmd::Serialize(size_t commandSize, SerializeBuffer* serializeBuffer) const {\n    ErrorObjectIdProvider provider;\n    return Serialize(commandSize, serializeBuffer, provider);\n}\n\nWireResult DeviceCreateCommandEncoderCmd::Deserialize(\n    DeserializeBuffer* deserializeBuffer,\n    DeserializeAllocator* allocator,\n    const ObjectIdResolver& resolver) {\n    const volatile DeviceCreateCommandEncoderTransfer* transfer;\n    WIRE_TRY(deserializeBuffer->Read(&transfer));\n    return DeviceCreateCommandEncoderDeserialize(this, transfer, deserializeBuffer, allocator, resolver);\n}\nWireResult DeviceCreateCommandEncoderCmd::Deserialize(DeserializeBuffer* deserializeBuffer, DeserializeAllocator* allocator) {\n    ErrorObjectIdResolver resolver;\n    return Deserialize(deserializeBuffer, allocator, resolver);\n}\n\nsize_t DeviceCreateComputePipelineCmd::GetRequiredSize() const {\n    return WireAlignSizeof<DeviceCreateComputePipelineTransfer>() + DeviceCreateComputePipelineGetExtraRequiredSize(*this);\n}\n\nWireResult DeviceCreateComputePipelineCmd::Serialize(\n    size_t commandSize,\n    SerializeBuffer* serializeBuffer,\n    const ObjectIdProvider& provider) const {\n    DeviceCreateComputePipelineTransfer* transfer;\n    WIRE_TRY(serializeBuffer->Next(&transfer));\n    transfer->commandSize = commandSize;\n    return (DeviceCreateComputePipelineSerialize(*this, transfer, serializeBuffer, provider));\n}\nWireResult DeviceCreateComputePipelineCmd::Serialize(size_t commandSize, SerializeBuffer* serializeBuffer) const {\n    ErrorObjectIdProvider provider;\n    return Serialize(commandSize, serializeBuffer, provider);\n}\n\nWireResult DeviceCreateComputePipelineCmd::Deserialize(\n    DeserializeBuffer* deserializeBuffer,\n    DeserializeAllocator* allocator,\n    const ObjectIdResolver& resolver) {\n    const volatile DeviceCreateComputePipelineTransfer* transfer;\n    WIRE_TRY(deserializeBuffer->Read(&transfer));\n    return DeviceCreateComputePipelineDeserialize(this, transfer, deserializeBuffer, allocator, resolver);\n}\nWireResult DeviceCreateComputePipelineCmd::Deserialize(DeserializeBuffer* deserializeBuffer, DeserializeAllocator* allocator) {\n    ErrorObjectIdResolver resolver;\n    return Deserialize(deserializeBuffer, allocator, resolver);\n}\n\nsize_t DeviceCreateComputePipelineAsyncCmd::GetRequiredSize() const {\n    return WireAlignSizeof<DeviceCreateComputePipelineAsyncTransfer>() + DeviceCreateComputePipelineAsyncGetExtraRequiredSize(*this);\n}\n\nWireResult DeviceCreateComputePipelineAsyncCmd::Serialize(\n    size_t commandSize,\n    SerializeBuffer* serializeBuffer,\n    const ObjectIdProvider& provider) const {\n    DeviceCreateComputePipelineAsyncTransfer* transfer;\n    WIRE_TRY(serializeBuffer->Next(&transfer));\n    transfer->commandSize = commandSize;\n    return (DeviceCreateComputePipelineAsyncSerialize(*this, transfer, serializeBuffer, provider));\n}\nWireResult DeviceCreateComputePipelineAsyncCmd::Serialize(size_t commandSize, SerializeBuffer* serializeBuffer) const {\n    ErrorObjectIdProvider provider;\n    return Serialize(commandSize, serializeBuffer, provider);\n}\n\nWireResult DeviceCreateComputePipelineAsyncCmd::Deserialize(\n    DeserializeBuffer* deserializeBuffer,\n    DeserializeAllocator* allocator,\n    const ObjectIdResolver& resolver) {\n    const volatile DeviceCreateComputePipelineAsyncTransfer* transfer;\n    WIRE_TRY(deserializeBuffer->Read(&transfer));\n    return DeviceCreateComputePipelineAsyncDeserialize(this, transfer, deserializeBuffer, allocator, resolver);\n}\nWireResult DeviceCreateComputePipelineAsyncCmd::Deserialize(DeserializeBuffer* deserializeBuffer, DeserializeAllocator* allocator) {\n    ErrorObjectIdResolver resolver;\n    return Deserialize(deserializeBuffer, allocator, resolver);\n}\n\nsize_t DeviceCreateErrorBufferCmd::GetRequiredSize() const {\n    return WireAlignSizeof<DeviceCreateErrorBufferTransfer>() + DeviceCreateErrorBufferGetExtraRequiredSize(*this);\n}\n\nWireResult DeviceCreateErrorBufferCmd::Serialize(\n    size_t commandSize,\n    SerializeBuffer* serializeBuffer,\n    const ObjectIdProvider& provider) const {\n    DeviceCreateErrorBufferTransfer* transfer;\n    WIRE_TRY(serializeBuffer->Next(&transfer));\n    transfer->commandSize = commandSize;\n    return (DeviceCreateErrorBufferSerialize(*this, transfer, serializeBuffer, provider));\n}\nWireResult DeviceCreateErrorBufferCmd::Serialize(size_t commandSize, SerializeBuffer* serializeBuffer) const {\n    ErrorObjectIdProvider provider;\n    return Serialize(commandSize, serializeBuffer, provider);\n}\n\nWireResult DeviceCreateErrorBufferCmd::Deserialize(\n    DeserializeBuffer* deserializeBuffer,\n    DeserializeAllocator* allocator,\n    const ObjectIdResolver& resolver) {\n    const volatile DeviceCreateErrorBufferTransfer* transfer;\n    WIRE_TRY(deserializeBuffer->Read(&transfer));\n    return DeviceCreateErrorBufferDeserialize(this, transfer, deserializeBuffer, allocator, resolver);\n}\nWireResult DeviceCreateErrorBufferCmd::Deserialize(DeserializeBuffer* deserializeBuffer, DeserializeAllocator* allocator) {\n    ErrorObjectIdResolver resolver;\n    return Deserialize(deserializeBuffer, allocator, resolver);\n}\n\nsize_t DeviceCreateErrorExternalTextureCmd::GetRequiredSize() const {\n    return WireAlignSizeof<DeviceCreateErrorExternalTextureTransfer>() + DeviceCreateErrorExternalTextureGetExtraRequiredSize(*this);\n}\n\nWireResult DeviceCreateErrorExternalTextureCmd::Serialize(\n    size_t commandSize,\n    SerializeBuffer* serializeBuffer,\n    const ObjectIdProvider& provider) const {\n    DeviceCreateErrorExternalTextureTransfer* transfer;\n    WIRE_TRY(serializeBuffer->Next(&transfer));\n    transfer->commandSize = commandSize;\n    return (DeviceCreateErrorExternalTextureSerialize(*this, transfer, serializeBuffer, provider));\n}\nWireResult DeviceCreateErrorExternalTextureCmd::Serialize(size_t commandSize, SerializeBuffer* serializeBuffer) const {\n    ErrorObjectIdProvider provider;\n    return Serialize(commandSize, serializeBuffer, provider);\n}\n\nWireResult DeviceCreateErrorExternalTextureCmd::Deserialize(\n    DeserializeBuffer* deserializeBuffer,\n    DeserializeAllocator* allocator,\n    const ObjectIdResolver& resolver) {\n    const volatile DeviceCreateErrorExternalTextureTransfer* transfer;\n    WIRE_TRY(deserializeBuffer->Read(&transfer));\n    return DeviceCreateErrorExternalTextureDeserialize(this, transfer, deserializeBuffer, allocator, resolver);\n}\nWireResult DeviceCreateErrorExternalTextureCmd::Deserialize(DeserializeBuffer* deserializeBuffer, DeserializeAllocator* allocator) {\n    ErrorObjectIdResolver resolver;\n    return Deserialize(deserializeBuffer, allocator, resolver);\n}\n\nsize_t DeviceCreateErrorShaderModuleCmd::GetRequiredSize() const {\n    return WireAlignSizeof<DeviceCreateErrorShaderModuleTransfer>() + DeviceCreateErrorShaderModuleGetExtraRequiredSize(*this);\n}\n\nWireResult DeviceCreateErrorShaderModuleCmd::Serialize(\n    size_t commandSize,\n    SerializeBuffer* serializeBuffer,\n    const ObjectIdProvider& provider) const {\n    DeviceCreateErrorShaderModuleTransfer* transfer;\n    WIRE_TRY(serializeBuffer->Next(&transfer));\n    transfer->commandSize = commandSize;\n    return (DeviceCreateErrorShaderModuleSerialize(*this, transfer, serializeBuffer, provider));\n}\nWireResult DeviceCreateErrorShaderModuleCmd::Serialize(size_t commandSize, SerializeBuffer* serializeBuffer) const {\n    ErrorObjectIdProvider provider;\n    return Serialize(commandSize, serializeBuffer, provider);\n}\n\nWireResult DeviceCreateErrorShaderModuleCmd::Deserialize(\n    DeserializeBuffer* deserializeBuffer,\n    DeserializeAllocator* allocator,\n    const ObjectIdResolver& resolver) {\n    const volatile DeviceCreateErrorShaderModuleTransfer* transfer;\n    WIRE_TRY(deserializeBuffer->Read(&transfer));\n    return DeviceCreateErrorShaderModuleDeserialize(this, transfer, deserializeBuffer, allocator, resolver);\n}\nWireResult DeviceCreateErrorShaderModuleCmd::Deserialize(DeserializeBuffer* deserializeBuffer, DeserializeAllocator* allocator) {\n    ErrorObjectIdResolver resolver;\n    return Deserialize(deserializeBuffer, allocator, resolver);\n}\n\nsize_t DeviceCreateErrorTextureCmd::GetRequiredSize() const {\n    return WireAlignSizeof<DeviceCreateErrorTextureTransfer>() + DeviceCreateErrorTextureGetExtraRequiredSize(*this);\n}\n\nWireResult DeviceCreateErrorTextureCmd::Serialize(\n    size_t commandSize,\n    SerializeBuffer* serializeBuffer,\n    const ObjectIdProvider& provider) const {\n    DeviceCreateErrorTextureTransfer* transfer;\n    WIRE_TRY(serializeBuffer->Next(&transfer));\n    transfer->commandSize = commandSize;\n    return (DeviceCreateErrorTextureSerialize(*this, transfer, serializeBuffer, provider));\n}\nWireResult DeviceCreateErrorTextureCmd::Serialize(size_t commandSize, SerializeBuffer* serializeBuffer) const {\n    ErrorObjectIdProvider provider;\n    return Serialize(commandSize, serializeBuffer, provider);\n}\n\nWireResult DeviceCreateErrorTextureCmd::Deserialize(\n    DeserializeBuffer* deserializeBuffer,\n    DeserializeAllocator* allocator,\n    const ObjectIdResolver& resolver) {\n    const volatile DeviceCreateErrorTextureTransfer* transfer;\n    WIRE_TRY(deserializeBuffer->Read(&transfer));\n    return DeviceCreateErrorTextureDeserialize(this, transfer, deserializeBuffer, allocator, resolver);\n}\nWireResult DeviceCreateErrorTextureCmd::Deserialize(DeserializeBuffer* deserializeBuffer, DeserializeAllocator* allocator) {\n    ErrorObjectIdResolver resolver;\n    return Deserialize(deserializeBuffer, allocator, resolver);\n}\n\nsize_t DeviceCreateExternalTextureCmd::GetRequiredSize() const {\n    return WireAlignSizeof<DeviceCreateExternalTextureTransfer>() + DeviceCreateExternalTextureGetExtraRequiredSize(*this);\n}\n\nWireResult DeviceCreateExternalTextureCmd::Serialize(\n    size_t commandSize,\n    SerializeBuffer* serializeBuffer,\n    const ObjectIdProvider& provider) const {\n    DeviceCreateExternalTextureTransfer* transfer;\n    WIRE_TRY(serializeBuffer->Next(&transfer));\n    transfer->commandSize = commandSize;\n    return (DeviceCreateExternalTextureSerialize(*this, transfer, serializeBuffer, provider));\n}\nWireResult DeviceCreateExternalTextureCmd::Serialize(size_t commandSize, SerializeBuffer* serializeBuffer) const {\n    ErrorObjectIdProvider provider;\n    return Serialize(commandSize, serializeBuffer, provider);\n}\n\nWireResult DeviceCreateExternalTextureCmd::Deserialize(\n    DeserializeBuffer* deserializeBuffer,\n    DeserializeAllocator* allocator,\n    const ObjectIdResolver& resolver) {\n    const volatile DeviceCreateExternalTextureTransfer* transfer;\n    WIRE_TRY(deserializeBuffer->Read(&transfer));\n    return DeviceCreateExternalTextureDeserialize(this, transfer, deserializeBuffer, allocator, resolver);\n}\nWireResult DeviceCreateExternalTextureCmd::Deserialize(DeserializeBuffer* deserializeBuffer, DeserializeAllocator* allocator) {\n    ErrorObjectIdResolver resolver;\n    return Deserialize(deserializeBuffer, allocator, resolver);\n}\n\nsize_t DeviceCreatePipelineLayoutCmd::GetRequiredSize() const {\n    return WireAlignSizeof<DeviceCreatePipelineLayoutTransfer>() + DeviceCreatePipelineLayoutGetExtraRequiredSize(*this);\n}\n\nWireResult DeviceCreatePipelineLayoutCmd::Serialize(\n    size_t commandSize,\n    SerializeBuffer* serializeBuffer,\n    const ObjectIdProvider& provider) const {\n    DeviceCreatePipelineLayoutTransfer* transfer;\n    WIRE_TRY(serializeBuffer->Next(&transfer));\n    transfer->commandSize = commandSize;\n    return (DeviceCreatePipelineLayoutSerialize(*this, transfer, serializeBuffer, provider));\n}\nWireResult DeviceCreatePipelineLayoutCmd::Serialize(size_t commandSize, SerializeBuffer* serializeBuffer) const {\n    ErrorObjectIdProvider provider;\n    return Serialize(commandSize, serializeBuffer, provider);\n}\n\nWireResult DeviceCreatePipelineLayoutCmd::Deserialize(\n    DeserializeBuffer* deserializeBuffer,\n    DeserializeAllocator* allocator,\n    const ObjectIdResolver& resolver) {\n    const volatile DeviceCreatePipelineLayoutTransfer* transfer;\n    WIRE_TRY(deserializeBuffer->Read(&transfer));\n    return DeviceCreatePipelineLayoutDeserialize(this, transfer, deserializeBuffer, allocator, resolver);\n}\nWireResult DeviceCreatePipelineLayoutCmd::Deserialize(DeserializeBuffer* deserializeBuffer, DeserializeAllocator* allocator) {\n    ErrorObjectIdResolver resolver;\n    return Deserialize(deserializeBuffer, allocator, resolver);\n}\n\nsize_t DeviceCreateQuerySetCmd::GetRequiredSize() const {\n    return WireAlignSizeof<DeviceCreateQuerySetTransfer>() + DeviceCreateQuerySetGetExtraRequiredSize(*this);\n}\n\nWireResult DeviceCreateQuerySetCmd::Serialize(\n    size_t commandSize,\n    SerializeBuffer* serializeBuffer,\n    const ObjectIdProvider& provider) const {\n    DeviceCreateQuerySetTransfer* transfer;\n    WIRE_TRY(serializeBuffer->Next(&transfer));\n    transfer->commandSize = commandSize;\n    return (DeviceCreateQuerySetSerialize(*this, transfer, serializeBuffer, provider));\n}\nWireResult DeviceCreateQuerySetCmd::Serialize(size_t commandSize, SerializeBuffer* serializeBuffer) const {\n    ErrorObjectIdProvider provider;\n    return Serialize(commandSize, serializeBuffer, provider);\n}\n\nWireResult DeviceCreateQuerySetCmd::Deserialize(\n    DeserializeBuffer* deserializeBuffer,\n    DeserializeAllocator* allocator,\n    const ObjectIdResolver& resolver) {\n    const volatile DeviceCreateQuerySetTransfer* transfer;\n    WIRE_TRY(deserializeBuffer->Read(&transfer));\n    return DeviceCreateQuerySetDeserialize(this, transfer, deserializeBuffer, allocator, resolver);\n}\nWireResult DeviceCreateQuerySetCmd::Deserialize(DeserializeBuffer* deserializeBuffer, DeserializeAllocator* allocator) {\n    ErrorObjectIdResolver resolver;\n    return Deserialize(deserializeBuffer, allocator, resolver);\n}\n\nsize_t DeviceCreateRenderBundleEncoderCmd::GetRequiredSize() const {\n    return WireAlignSizeof<DeviceCreateRenderBundleEncoderTransfer>() + DeviceCreateRenderBundleEncoderGetExtraRequiredSize(*this);\n}\n\nWireResult DeviceCreateRenderBundleEncoderCmd::Serialize(\n    size_t commandSize,\n    SerializeBuffer* serializeBuffer,\n    const ObjectIdProvider& provider) const {\n    DeviceCreateRenderBundleEncoderTransfer* transfer;\n    WIRE_TRY(serializeBuffer->Next(&transfer));\n    transfer->commandSize = commandSize;\n    return (DeviceCreateRenderBundleEncoderSerialize(*this, transfer, serializeBuffer, provider));\n}\nWireResult DeviceCreateRenderBundleEncoderCmd::Serialize(size_t commandSize, SerializeBuffer* serializeBuffer) const {\n    ErrorObjectIdProvider provider;\n    return Serialize(commandSize, serializeBuffer, provider);\n}\n\nWireResult DeviceCreateRenderBundleEncoderCmd::Deserialize(\n    DeserializeBuffer* deserializeBuffer,\n    DeserializeAllocator* allocator,\n    const ObjectIdResolver& resolver) {\n    const volatile DeviceCreateRenderBundleEncoderTransfer* transfer;\n    WIRE_TRY(deserializeBuffer->Read(&transfer));\n    return DeviceCreateRenderBundleEncoderDeserialize(this, transfer, deserializeBuffer, allocator, resolver);\n}\nWireResult DeviceCreateRenderBundleEncoderCmd::Deserialize(DeserializeBuffer* deserializeBuffer, DeserializeAllocator* allocator) {\n    ErrorObjectIdResolver resolver;\n    return Deserialize(deserializeBuffer, allocator, resolver);\n}\n\nsize_t DeviceCreateRenderPipelineCmd::GetRequiredSize() const {\n    return WireAlignSizeof<DeviceCreateRenderPipelineTransfer>() + DeviceCreateRenderPipelineGetExtraRequiredSize(*this);\n}\n\nWireResult DeviceCreateRenderPipelineCmd::Serialize(\n    size_t commandSize,\n    SerializeBuffer* serializeBuffer,\n    const ObjectIdProvider& provider) const {\n    DeviceCreateRenderPipelineTransfer* transfer;\n    WIRE_TRY(serializeBuffer->Next(&transfer));\n    transfer->commandSize = commandSize;\n    return (DeviceCreateRenderPipelineSerialize(*this, transfer, serializeBuffer, provider));\n}\nWireResult DeviceCreateRenderPipelineCmd::Serialize(size_t commandSize, SerializeBuffer* serializeBuffer) const {\n    ErrorObjectIdProvider provider;\n    return Serialize(commandSize, serializeBuffer, provider);\n}\n\nWireResult DeviceCreateRenderPipelineCmd::Deserialize(\n    DeserializeBuffer* deserializeBuffer,\n    DeserializeAllocator* allocator,\n    const ObjectIdResolver& resolver) {\n    const volatile DeviceCreateRenderPipelineTransfer* transfer;\n    WIRE_TRY(deserializeBuffer->Read(&transfer));\n    return DeviceCreateRenderPipelineDeserialize(this, transfer, deserializeBuffer, allocator, resolver);\n}\nWireResult DeviceCreateRenderPipelineCmd::Deserialize(DeserializeBuffer* deserializeBuffer, DeserializeAllocator* allocator) {\n    ErrorObjectIdResolver resolver;\n    return Deserialize(deserializeBuffer, allocator, resolver);\n}\n\nsize_t DeviceCreateRenderPipelineAsyncCmd::GetRequiredSize() const {\n    return WireAlignSizeof<DeviceCreateRenderPipelineAsyncTransfer>() + DeviceCreateRenderPipelineAsyncGetExtraRequiredSize(*this);\n}\n\nWireResult DeviceCreateRenderPipelineAsyncCmd::Serialize(\n    size_t commandSize,\n    SerializeBuffer* serializeBuffer,\n    const ObjectIdProvider& provider) const {\n    DeviceCreateRenderPipelineAsyncTransfer* transfer;\n    WIRE_TRY(serializeBuffer->Next(&transfer));\n    transfer->commandSize = commandSize;\n    return (DeviceCreateRenderPipelineAsyncSerialize(*this, transfer, serializeBuffer, provider));\n}\nWireResult DeviceCreateRenderPipelineAsyncCmd::Serialize(size_t commandSize, SerializeBuffer* serializeBuffer) const {\n    ErrorObjectIdProvider provider;\n    return Serialize(commandSize, serializeBuffer, provider);\n}\n\nWireResult DeviceCreateRenderPipelineAsyncCmd::Deserialize(\n    DeserializeBuffer* deserializeBuffer,\n    DeserializeAllocator* allocator,\n    const ObjectIdResolver& resolver) {\n    const volatile DeviceCreateRenderPipelineAsyncTransfer* transfer;\n    WIRE_TRY(deserializeBuffer->Read(&transfer));\n    return DeviceCreateRenderPipelineAsyncDeserialize(this, transfer, deserializeBuffer, allocator, resolver);\n}\nWireResult DeviceCreateRenderPipelineAsyncCmd::Deserialize(DeserializeBuffer* deserializeBuffer, DeserializeAllocator* allocator) {\n    ErrorObjectIdResolver resolver;\n    return Deserialize(deserializeBuffer, allocator, resolver);\n}\n\nsize_t DeviceCreateSamplerCmd::GetRequiredSize() const {\n    return WireAlignSizeof<DeviceCreateSamplerTransfer>() + DeviceCreateSamplerGetExtraRequiredSize(*this);\n}\n\nWireResult DeviceCreateSamplerCmd::Serialize(\n    size_t commandSize,\n    SerializeBuffer* serializeBuffer,\n    const ObjectIdProvider& provider) const {\n    DeviceCreateSamplerTransfer* transfer;\n    WIRE_TRY(serializeBuffer->Next(&transfer));\n    transfer->commandSize = commandSize;\n    return (DeviceCreateSamplerSerialize(*this, transfer, serializeBuffer, provider));\n}\nWireResult DeviceCreateSamplerCmd::Serialize(size_t commandSize, SerializeBuffer* serializeBuffer) const {\n    ErrorObjectIdProvider provider;\n    return Serialize(commandSize, serializeBuffer, provider);\n}\n\nWireResult DeviceCreateSamplerCmd::Deserialize(\n    DeserializeBuffer* deserializeBuffer,\n    DeserializeAllocator* allocator,\n    const ObjectIdResolver& resolver) {\n    const volatile DeviceCreateSamplerTransfer* transfer;\n    WIRE_TRY(deserializeBuffer->Read(&transfer));\n    return DeviceCreateSamplerDeserialize(this, transfer, deserializeBuffer, allocator, resolver);\n}\nWireResult DeviceCreateSamplerCmd::Deserialize(DeserializeBuffer* deserializeBuffer, DeserializeAllocator* allocator) {\n    ErrorObjectIdResolver resolver;\n    return Deserialize(deserializeBuffer, allocator, resolver);\n}\n\nsize_t DeviceCreateShaderModuleCmd::GetRequiredSize() const {\n    return WireAlignSizeof<DeviceCreateShaderModuleTransfer>() + DeviceCreateShaderModuleGetExtraRequiredSize(*this);\n}\n\nWireResult DeviceCreateShaderModuleCmd::Serialize(\n    size_t commandSize,\n    SerializeBuffer* serializeBuffer,\n    const ObjectIdProvider& provider) const {\n    DeviceCreateShaderModuleTransfer* transfer;\n    WIRE_TRY(serializeBuffer->Next(&transfer));\n    transfer->commandSize = commandSize;\n    return (DeviceCreateShaderModuleSerialize(*this, transfer, serializeBuffer, provider));\n}\nWireResult DeviceCreateShaderModuleCmd::Serialize(size_t commandSize, SerializeBuffer* serializeBuffer) const {\n    ErrorObjectIdProvider provider;\n    return Serialize(commandSize, serializeBuffer, provider);\n}\n\nWireResult DeviceCreateShaderModuleCmd::Deserialize(\n    DeserializeBuffer* deserializeBuffer,\n    DeserializeAllocator* allocator,\n    const ObjectIdResolver& resolver) {\n    const volatile DeviceCreateShaderModuleTransfer* transfer;\n    WIRE_TRY(deserializeBuffer->Read(&transfer));\n    return DeviceCreateShaderModuleDeserialize(this, transfer, deserializeBuffer, allocator, resolver);\n}\nWireResult DeviceCreateShaderModuleCmd::Deserialize(DeserializeBuffer* deserializeBuffer, DeserializeAllocator* allocator) {\n    ErrorObjectIdResolver resolver;\n    return Deserialize(deserializeBuffer, allocator, resolver);\n}\n\nsize_t DeviceCreateSwapChainCmd::GetRequiredSize() const {\n    return WireAlignSizeof<DeviceCreateSwapChainTransfer>() + DeviceCreateSwapChainGetExtraRequiredSize(*this);\n}\n\nWireResult DeviceCreateSwapChainCmd::Serialize(\n    size_t commandSize,\n    SerializeBuffer* serializeBuffer,\n    const ObjectIdProvider& provider) const {\n    DeviceCreateSwapChainTransfer* transfer;\n    WIRE_TRY(serializeBuffer->Next(&transfer));\n    transfer->commandSize = commandSize;\n    return (DeviceCreateSwapChainSerialize(*this, transfer, serializeBuffer, provider));\n}\nWireResult DeviceCreateSwapChainCmd::Serialize(size_t commandSize, SerializeBuffer* serializeBuffer) const {\n    ErrorObjectIdProvider provider;\n    return Serialize(commandSize, serializeBuffer, provider);\n}\n\nWireResult DeviceCreateSwapChainCmd::Deserialize(\n    DeserializeBuffer* deserializeBuffer,\n    DeserializeAllocator* allocator,\n    const ObjectIdResolver& resolver) {\n    const volatile DeviceCreateSwapChainTransfer* transfer;\n    WIRE_TRY(deserializeBuffer->Read(&transfer));\n    return DeviceCreateSwapChainDeserialize(this, transfer, deserializeBuffer, allocator, resolver);\n}\nWireResult DeviceCreateSwapChainCmd::Deserialize(DeserializeBuffer* deserializeBuffer, DeserializeAllocator* allocator) {\n    ErrorObjectIdResolver resolver;\n    return Deserialize(deserializeBuffer, allocator, resolver);\n}\n\nsize_t DeviceCreateTextureCmd::GetRequiredSize() const {\n    return WireAlignSizeof<DeviceCreateTextureTransfer>() + DeviceCreateTextureGetExtraRequiredSize(*this);\n}\n\nWireResult DeviceCreateTextureCmd::Serialize(\n    size_t commandSize,\n    SerializeBuffer* serializeBuffer,\n    const ObjectIdProvider& provider) const {\n    DeviceCreateTextureTransfer* transfer;\n    WIRE_TRY(serializeBuffer->Next(&transfer));\n    transfer->commandSize = commandSize;\n    return (DeviceCreateTextureSerialize(*this, transfer, serializeBuffer, provider));\n}\nWireResult DeviceCreateTextureCmd::Serialize(size_t commandSize, SerializeBuffer* serializeBuffer) const {\n    ErrorObjectIdProvider provider;\n    return Serialize(commandSize, serializeBuffer, provider);\n}\n\nWireResult DeviceCreateTextureCmd::Deserialize(\n    DeserializeBuffer* deserializeBuffer,\n    DeserializeAllocator* allocator,\n    const ObjectIdResolver& resolver) {\n    const volatile DeviceCreateTextureTransfer* transfer;\n    WIRE_TRY(deserializeBuffer->Read(&transfer));\n    return DeviceCreateTextureDeserialize(this, transfer, deserializeBuffer, allocator, resolver);\n}\nWireResult DeviceCreateTextureCmd::Deserialize(DeserializeBuffer* deserializeBuffer, DeserializeAllocator* allocator) {\n    ErrorObjectIdResolver resolver;\n    return Deserialize(deserializeBuffer, allocator, resolver);\n}\n\nsize_t DeviceDestroyCmd::GetRequiredSize() const {\n    return WireAlignSizeof<DeviceDestroyTransfer>() + DeviceDestroyGetExtraRequiredSize(*this);\n}\n\nWireResult DeviceDestroyCmd::Serialize(\n    size_t commandSize,\n    SerializeBuffer* serializeBuffer,\n    const ObjectIdProvider& provider) const {\n    DeviceDestroyTransfer* transfer;\n    WIRE_TRY(serializeBuffer->Next(&transfer));\n    transfer->commandSize = commandSize;\n    return (DeviceDestroySerialize(*this, transfer, serializeBuffer, provider));\n}\nWireResult DeviceDestroyCmd::Serialize(size_t commandSize, SerializeBuffer* serializeBuffer) const {\n    ErrorObjectIdProvider provider;\n    return Serialize(commandSize, serializeBuffer, provider);\n}\n\nWireResult DeviceDestroyCmd::Deserialize(\n    DeserializeBuffer* deserializeBuffer,\n    DeserializeAllocator* allocator,\n    const ObjectIdResolver& resolver) {\n    const volatile DeviceDestroyTransfer* transfer;\n    WIRE_TRY(deserializeBuffer->Read(&transfer));\n    return DeviceDestroyDeserialize(this, transfer, deserializeBuffer, allocator, resolver);\n}\nWireResult DeviceDestroyCmd::Deserialize(DeserializeBuffer* deserializeBuffer, DeserializeAllocator* allocator) {\n    ErrorObjectIdResolver resolver;\n    return Deserialize(deserializeBuffer, allocator, resolver);\n}\n\nsize_t DeviceForceLossCmd::GetRequiredSize() const {\n    return WireAlignSizeof<DeviceForceLossTransfer>() + DeviceForceLossGetExtraRequiredSize(*this);\n}\n\nWireResult DeviceForceLossCmd::Serialize(\n    size_t commandSize,\n    SerializeBuffer* serializeBuffer,\n    const ObjectIdProvider& provider) const {\n    DeviceForceLossTransfer* transfer;\n    WIRE_TRY(serializeBuffer->Next(&transfer));\n    transfer->commandSize = commandSize;\n    return (DeviceForceLossSerialize(*this, transfer, serializeBuffer, provider));\n}\nWireResult DeviceForceLossCmd::Serialize(size_t commandSize, SerializeBuffer* serializeBuffer) const {\n    ErrorObjectIdProvider provider;\n    return Serialize(commandSize, serializeBuffer, provider);\n}\n\nWireResult DeviceForceLossCmd::Deserialize(\n    DeserializeBuffer* deserializeBuffer,\n    DeserializeAllocator* allocator,\n    const ObjectIdResolver& resolver) {\n    const volatile DeviceForceLossTransfer* transfer;\n    WIRE_TRY(deserializeBuffer->Read(&transfer));\n    return DeviceForceLossDeserialize(this, transfer, deserializeBuffer, allocator, resolver);\n}\nWireResult DeviceForceLossCmd::Deserialize(DeserializeBuffer* deserializeBuffer, DeserializeAllocator* allocator) {\n    ErrorObjectIdResolver resolver;\n    return Deserialize(deserializeBuffer, allocator, resolver);\n}\n\nsize_t DeviceGetAdapterCmd::GetRequiredSize() const {\n    return WireAlignSizeof<DeviceGetAdapterTransfer>() + DeviceGetAdapterGetExtraRequiredSize(*this);\n}\n\nWireResult DeviceGetAdapterCmd::Serialize(\n    size_t commandSize,\n    SerializeBuffer* serializeBuffer,\n    const ObjectIdProvider& provider) const {\n    DeviceGetAdapterTransfer* transfer;\n    WIRE_TRY(serializeBuffer->Next(&transfer));\n    transfer->commandSize = commandSize;\n    return (DeviceGetAdapterSerialize(*this, transfer, serializeBuffer, provider));\n}\nWireResult DeviceGetAdapterCmd::Serialize(size_t commandSize, SerializeBuffer* serializeBuffer) const {\n    ErrorObjectIdProvider provider;\n    return Serialize(commandSize, serializeBuffer, provider);\n}\n\nWireResult DeviceGetAdapterCmd::Deserialize(\n    DeserializeBuffer* deserializeBuffer,\n    DeserializeAllocator* allocator,\n    const ObjectIdResolver& resolver) {\n    const volatile DeviceGetAdapterTransfer* transfer;\n    WIRE_TRY(deserializeBuffer->Read(&transfer));\n    return DeviceGetAdapterDeserialize(this, transfer, deserializeBuffer, allocator, resolver);\n}\nWireResult DeviceGetAdapterCmd::Deserialize(DeserializeBuffer* deserializeBuffer, DeserializeAllocator* allocator) {\n    ErrorObjectIdResolver resolver;\n    return Deserialize(deserializeBuffer, allocator, resolver);\n}\n\nsize_t DeviceGetQueueCmd::GetRequiredSize() const {\n    return WireAlignSizeof<DeviceGetQueueTransfer>() + DeviceGetQueueGetExtraRequiredSize(*this);\n}\n\nWireResult DeviceGetQueueCmd::Serialize(\n    size_t commandSize,\n    SerializeBuffer* serializeBuffer,\n    const ObjectIdProvider& provider) const {\n    DeviceGetQueueTransfer* transfer;\n    WIRE_TRY(serializeBuffer->Next(&transfer));\n    transfer->commandSize = commandSize;\n    return (DeviceGetQueueSerialize(*this, transfer, serializeBuffer, provider));\n}\nWireResult DeviceGetQueueCmd::Serialize(size_t commandSize, SerializeBuffer* serializeBuffer) const {\n    ErrorObjectIdProvider provider;\n    return Serialize(commandSize, serializeBuffer, provider);\n}\n\nWireResult DeviceGetQueueCmd::Deserialize(\n    DeserializeBuffer* deserializeBuffer,\n    DeserializeAllocator* allocator,\n    const ObjectIdResolver& resolver) {\n    const volatile DeviceGetQueueTransfer* transfer;\n    WIRE_TRY(deserializeBuffer->Read(&transfer));\n    return DeviceGetQueueDeserialize(this, transfer, deserializeBuffer, allocator, resolver);\n}\nWireResult DeviceGetQueueCmd::Deserialize(DeserializeBuffer* deserializeBuffer, DeserializeAllocator* allocator) {\n    ErrorObjectIdResolver resolver;\n    return Deserialize(deserializeBuffer, allocator, resolver);\n}\n\nsize_t DeviceInjectErrorCmd::GetRequiredSize() const {\n    return WireAlignSizeof<DeviceInjectErrorTransfer>() + DeviceInjectErrorGetExtraRequiredSize(*this);\n}\n\nWireResult DeviceInjectErrorCmd::Serialize(\n    size_t commandSize,\n    SerializeBuffer* serializeBuffer,\n    const ObjectIdProvider& provider) const {\n    DeviceInjectErrorTransfer* transfer;\n    WIRE_TRY(serializeBuffer->Next(&transfer));\n    transfer->commandSize = commandSize;\n    return (DeviceInjectErrorSerialize(*this, transfer, serializeBuffer, provider));\n}\nWireResult DeviceInjectErrorCmd::Serialize(size_t commandSize, SerializeBuffer* serializeBuffer) const {\n    ErrorObjectIdProvider provider;\n    return Serialize(commandSize, serializeBuffer, provider);\n}\n\nWireResult DeviceInjectErrorCmd::Deserialize(\n    DeserializeBuffer* deserializeBuffer,\n    DeserializeAllocator* allocator,\n    const ObjectIdResolver& resolver) {\n    const volatile DeviceInjectErrorTransfer* transfer;\n    WIRE_TRY(deserializeBuffer->Read(&transfer));\n    return DeviceInjectErrorDeserialize(this, transfer, deserializeBuffer, allocator, resolver);\n}\nWireResult DeviceInjectErrorCmd::Deserialize(DeserializeBuffer* deserializeBuffer, DeserializeAllocator* allocator) {\n    ErrorObjectIdResolver resolver;\n    return Deserialize(deserializeBuffer, allocator, resolver);\n}\n\nsize_t DevicePopErrorScopeCmd::GetRequiredSize() const {\n    return WireAlignSizeof<DevicePopErrorScopeTransfer>() + DevicePopErrorScopeGetExtraRequiredSize(*this);\n}\n\nWireResult DevicePopErrorScopeCmd::Serialize(size_t commandSize, SerializeBuffer* serializeBuffer) const {\n    DevicePopErrorScopeTransfer* transfer;\n    WIRE_TRY(serializeBuffer->Next(&transfer));\n    transfer->commandSize = commandSize;\n    return (DevicePopErrorScopeSerialize(*this, transfer, serializeBuffer));\n}\nWireResult DevicePopErrorScopeCmd::Serialize(\n    size_t commandSize,\n    SerializeBuffer* serializeBuffer,\n    const ObjectIdProvider&) const {\n    return Serialize(commandSize, serializeBuffer);\n}\n\nWireResult DevicePopErrorScopeCmd::Deserialize(DeserializeBuffer* deserializeBuffer, DeserializeAllocator* allocator) {\n    const volatile DevicePopErrorScopeTransfer* transfer;\n    WIRE_TRY(deserializeBuffer->Read(&transfer));\n    return DevicePopErrorScopeDeserialize(this, transfer, deserializeBuffer, allocator);\n}\nWireResult DevicePopErrorScopeCmd::Deserialize(\n    DeserializeBuffer* deserializeBuffer,\n    DeserializeAllocator* allocator,\n    const ObjectIdResolver&) {\n    return Deserialize(deserializeBuffer, allocator);\n}\n\nsize_t DevicePushErrorScopeCmd::GetRequiredSize() const {\n    return WireAlignSizeof<DevicePushErrorScopeTransfer>() + DevicePushErrorScopeGetExtraRequiredSize(*this);\n}\n\nWireResult DevicePushErrorScopeCmd::Serialize(\n    size_t commandSize,\n    SerializeBuffer* serializeBuffer,\n    const ObjectIdProvider& provider) const {\n    DevicePushErrorScopeTransfer* transfer;\n    WIRE_TRY(serializeBuffer->Next(&transfer));\n    transfer->commandSize = commandSize;\n    return (DevicePushErrorScopeSerialize(*this, transfer, serializeBuffer, provider));\n}\nWireResult DevicePushErrorScopeCmd::Serialize(size_t commandSize, SerializeBuffer* serializeBuffer) const {\n    ErrorObjectIdProvider provider;\n    return Serialize(commandSize, serializeBuffer, provider);\n}\n\nWireResult DevicePushErrorScopeCmd::Deserialize(\n    DeserializeBuffer* deserializeBuffer,\n    DeserializeAllocator* allocator,\n    const ObjectIdResolver& resolver) {\n    const volatile DevicePushErrorScopeTransfer* transfer;\n    WIRE_TRY(deserializeBuffer->Read(&transfer));\n    return DevicePushErrorScopeDeserialize(this, transfer, deserializeBuffer, allocator, resolver);\n}\nWireResult DevicePushErrorScopeCmd::Deserialize(DeserializeBuffer* deserializeBuffer, DeserializeAllocator* allocator) {\n    ErrorObjectIdResolver resolver;\n    return Deserialize(deserializeBuffer, allocator, resolver);\n}\n\nsize_t DeviceSetLabelCmd::GetRequiredSize() const {\n    return WireAlignSizeof<DeviceSetLabelTransfer>() + DeviceSetLabelGetExtraRequiredSize(*this);\n}\n\nWireResult DeviceSetLabelCmd::Serialize(\n    size_t commandSize,\n    SerializeBuffer* serializeBuffer,\n    const ObjectIdProvider& provider) const {\n    DeviceSetLabelTransfer* transfer;\n    WIRE_TRY(serializeBuffer->Next(&transfer));\n    transfer->commandSize = commandSize;\n    return (DeviceSetLabelSerialize(*this, transfer, serializeBuffer, provider));\n}\nWireResult DeviceSetLabelCmd::Serialize(size_t commandSize, SerializeBuffer* serializeBuffer) const {\n    ErrorObjectIdProvider provider;\n    return Serialize(commandSize, serializeBuffer, provider);\n}\n\nWireResult DeviceSetLabelCmd::Deserialize(\n    DeserializeBuffer* deserializeBuffer,\n    DeserializeAllocator* allocator,\n    const ObjectIdResolver& resolver) {\n    const volatile DeviceSetLabelTransfer* transfer;\n    WIRE_TRY(deserializeBuffer->Read(&transfer));\n    return DeviceSetLabelDeserialize(this, transfer, deserializeBuffer, allocator, resolver);\n}\nWireResult DeviceSetLabelCmd::Deserialize(DeserializeBuffer* deserializeBuffer, DeserializeAllocator* allocator) {\n    ErrorObjectIdResolver resolver;\n    return Deserialize(deserializeBuffer, allocator, resolver);\n}\n\nsize_t DeviceTickCmd::GetRequiredSize() const {\n    return WireAlignSizeof<DeviceTickTransfer>() + DeviceTickGetExtraRequiredSize(*this);\n}\n\nWireResult DeviceTickCmd::Serialize(\n    size_t commandSize,\n    SerializeBuffer* serializeBuffer,\n    const ObjectIdProvider& provider) const {\n    DeviceTickTransfer* transfer;\n    WIRE_TRY(serializeBuffer->Next(&transfer));\n    transfer->commandSize = commandSize;\n    return (DeviceTickSerialize(*this, transfer, serializeBuffer, provider));\n}\nWireResult DeviceTickCmd::Serialize(size_t commandSize, SerializeBuffer* serializeBuffer) const {\n    ErrorObjectIdProvider provider;\n    return Serialize(commandSize, serializeBuffer, provider);\n}\n\nWireResult DeviceTickCmd::Deserialize(\n    DeserializeBuffer* deserializeBuffer,\n    DeserializeAllocator* allocator,\n    const ObjectIdResolver& resolver) {\n    const volatile DeviceTickTransfer* transfer;\n    WIRE_TRY(deserializeBuffer->Read(&transfer));\n    return DeviceTickDeserialize(this, transfer, deserializeBuffer, allocator, resolver);\n}\nWireResult DeviceTickCmd::Deserialize(DeserializeBuffer* deserializeBuffer, DeserializeAllocator* allocator) {\n    ErrorObjectIdResolver resolver;\n    return Deserialize(deserializeBuffer, allocator, resolver);\n}\n\nsize_t DeviceValidateTextureDescriptorCmd::GetRequiredSize() const {\n    return WireAlignSizeof<DeviceValidateTextureDescriptorTransfer>() + DeviceValidateTextureDescriptorGetExtraRequiredSize(*this);\n}\n\nWireResult DeviceValidateTextureDescriptorCmd::Serialize(\n    size_t commandSize,\n    SerializeBuffer* serializeBuffer,\n    const ObjectIdProvider& provider) const {\n    DeviceValidateTextureDescriptorTransfer* transfer;\n    WIRE_TRY(serializeBuffer->Next(&transfer));\n    transfer->commandSize = commandSize;\n    return (DeviceValidateTextureDescriptorSerialize(*this, transfer, serializeBuffer, provider));\n}\nWireResult DeviceValidateTextureDescriptorCmd::Serialize(size_t commandSize, SerializeBuffer* serializeBuffer) const {\n    ErrorObjectIdProvider provider;\n    return Serialize(commandSize, serializeBuffer, provider);\n}\n\nWireResult DeviceValidateTextureDescriptorCmd::Deserialize(\n    DeserializeBuffer* deserializeBuffer,\n    DeserializeAllocator* allocator,\n    const ObjectIdResolver& resolver) {\n    const volatile DeviceValidateTextureDescriptorTransfer* transfer;\n    WIRE_TRY(deserializeBuffer->Read(&transfer));\n    return DeviceValidateTextureDescriptorDeserialize(this, transfer, deserializeBuffer, allocator, resolver);\n}\nWireResult DeviceValidateTextureDescriptorCmd::Deserialize(DeserializeBuffer* deserializeBuffer, DeserializeAllocator* allocator) {\n    ErrorObjectIdResolver resolver;\n    return Deserialize(deserializeBuffer, allocator, resolver);\n}\n\nsize_t ExternalTextureDestroyCmd::GetRequiredSize() const {\n    return WireAlignSizeof<ExternalTextureDestroyTransfer>() + ExternalTextureDestroyGetExtraRequiredSize(*this);\n}\n\nWireResult ExternalTextureDestroyCmd::Serialize(\n    size_t commandSize,\n    SerializeBuffer* serializeBuffer,\n    const ObjectIdProvider& provider) const {\n    ExternalTextureDestroyTransfer* transfer;\n    WIRE_TRY(serializeBuffer->Next(&transfer));\n    transfer->commandSize = commandSize;\n    return (ExternalTextureDestroySerialize(*this, transfer, serializeBuffer, provider));\n}\nWireResult ExternalTextureDestroyCmd::Serialize(size_t commandSize, SerializeBuffer* serializeBuffer) const {\n    ErrorObjectIdProvider provider;\n    return Serialize(commandSize, serializeBuffer, provider);\n}\n\nWireResult ExternalTextureDestroyCmd::Deserialize(\n    DeserializeBuffer* deserializeBuffer,\n    DeserializeAllocator* allocator,\n    const ObjectIdResolver& resolver) {\n    const volatile ExternalTextureDestroyTransfer* transfer;\n    WIRE_TRY(deserializeBuffer->Read(&transfer));\n    return ExternalTextureDestroyDeserialize(this, transfer, deserializeBuffer, allocator, resolver);\n}\nWireResult ExternalTextureDestroyCmd::Deserialize(DeserializeBuffer* deserializeBuffer, DeserializeAllocator* allocator) {\n    ErrorObjectIdResolver resolver;\n    return Deserialize(deserializeBuffer, allocator, resolver);\n}\n\nsize_t ExternalTextureExpireCmd::GetRequiredSize() const {\n    return WireAlignSizeof<ExternalTextureExpireTransfer>() + ExternalTextureExpireGetExtraRequiredSize(*this);\n}\n\nWireResult ExternalTextureExpireCmd::Serialize(\n    size_t commandSize,\n    SerializeBuffer* serializeBuffer,\n    const ObjectIdProvider& provider) const {\n    ExternalTextureExpireTransfer* transfer;\n    WIRE_TRY(serializeBuffer->Next(&transfer));\n    transfer->commandSize = commandSize;\n    return (ExternalTextureExpireSerialize(*this, transfer, serializeBuffer, provider));\n}\nWireResult ExternalTextureExpireCmd::Serialize(size_t commandSize, SerializeBuffer* serializeBuffer) const {\n    ErrorObjectIdProvider provider;\n    return Serialize(commandSize, serializeBuffer, provider);\n}\n\nWireResult ExternalTextureExpireCmd::Deserialize(\n    DeserializeBuffer* deserializeBuffer,\n    DeserializeAllocator* allocator,\n    const ObjectIdResolver& resolver) {\n    const volatile ExternalTextureExpireTransfer* transfer;\n    WIRE_TRY(deserializeBuffer->Read(&transfer));\n    return ExternalTextureExpireDeserialize(this, transfer, deserializeBuffer, allocator, resolver);\n}\nWireResult ExternalTextureExpireCmd::Deserialize(DeserializeBuffer* deserializeBuffer, DeserializeAllocator* allocator) {\n    ErrorObjectIdResolver resolver;\n    return Deserialize(deserializeBuffer, allocator, resolver);\n}\n\nsize_t ExternalTextureRefreshCmd::GetRequiredSize() const {\n    return WireAlignSizeof<ExternalTextureRefreshTransfer>() + ExternalTextureRefreshGetExtraRequiredSize(*this);\n}\n\nWireResult ExternalTextureRefreshCmd::Serialize(\n    size_t commandSize,\n    SerializeBuffer* serializeBuffer,\n    const ObjectIdProvider& provider) const {\n    ExternalTextureRefreshTransfer* transfer;\n    WIRE_TRY(serializeBuffer->Next(&transfer));\n    transfer->commandSize = commandSize;\n    return (ExternalTextureRefreshSerialize(*this, transfer, serializeBuffer, provider));\n}\nWireResult ExternalTextureRefreshCmd::Serialize(size_t commandSize, SerializeBuffer* serializeBuffer) const {\n    ErrorObjectIdProvider provider;\n    return Serialize(commandSize, serializeBuffer, provider);\n}\n\nWireResult ExternalTextureRefreshCmd::Deserialize(\n    DeserializeBuffer* deserializeBuffer,\n    DeserializeAllocator* allocator,\n    const ObjectIdResolver& resolver) {\n    const volatile ExternalTextureRefreshTransfer* transfer;\n    WIRE_TRY(deserializeBuffer->Read(&transfer));\n    return ExternalTextureRefreshDeserialize(this, transfer, deserializeBuffer, allocator, resolver);\n}\nWireResult ExternalTextureRefreshCmd::Deserialize(DeserializeBuffer* deserializeBuffer, DeserializeAllocator* allocator) {\n    ErrorObjectIdResolver resolver;\n    return Deserialize(deserializeBuffer, allocator, resolver);\n}\n\nsize_t ExternalTextureSetLabelCmd::GetRequiredSize() const {\n    return WireAlignSizeof<ExternalTextureSetLabelTransfer>() + ExternalTextureSetLabelGetExtraRequiredSize(*this);\n}\n\nWireResult ExternalTextureSetLabelCmd::Serialize(\n    size_t commandSize,\n    SerializeBuffer* serializeBuffer,\n    const ObjectIdProvider& provider) const {\n    ExternalTextureSetLabelTransfer* transfer;\n    WIRE_TRY(serializeBuffer->Next(&transfer));\n    transfer->commandSize = commandSize;\n    return (ExternalTextureSetLabelSerialize(*this, transfer, serializeBuffer, provider));\n}\nWireResult ExternalTextureSetLabelCmd::Serialize(size_t commandSize, SerializeBuffer* serializeBuffer) const {\n    ErrorObjectIdProvider provider;\n    return Serialize(commandSize, serializeBuffer, provider);\n}\n\nWireResult ExternalTextureSetLabelCmd::Deserialize(\n    DeserializeBuffer* deserializeBuffer,\n    DeserializeAllocator* allocator,\n    const ObjectIdResolver& resolver) {\n    const volatile ExternalTextureSetLabelTransfer* transfer;\n    WIRE_TRY(deserializeBuffer->Read(&transfer));\n    return ExternalTextureSetLabelDeserialize(this, transfer, deserializeBuffer, allocator, resolver);\n}\nWireResult ExternalTextureSetLabelCmd::Deserialize(DeserializeBuffer* deserializeBuffer, DeserializeAllocator* allocator) {\n    ErrorObjectIdResolver resolver;\n    return Deserialize(deserializeBuffer, allocator, resolver);\n}\n\nsize_t InstanceCreateSurfaceCmd::GetRequiredSize() const {\n    return WireAlignSizeof<InstanceCreateSurfaceTransfer>() + InstanceCreateSurfaceGetExtraRequiredSize(*this);\n}\n\nWireResult InstanceCreateSurfaceCmd::Serialize(\n    size_t commandSize,\n    SerializeBuffer* serializeBuffer,\n    const ObjectIdProvider& provider) const {\n    InstanceCreateSurfaceTransfer* transfer;\n    WIRE_TRY(serializeBuffer->Next(&transfer));\n    transfer->commandSize = commandSize;\n    return (InstanceCreateSurfaceSerialize(*this, transfer, serializeBuffer, provider));\n}\nWireResult InstanceCreateSurfaceCmd::Serialize(size_t commandSize, SerializeBuffer* serializeBuffer) const {\n    ErrorObjectIdProvider provider;\n    return Serialize(commandSize, serializeBuffer, provider);\n}\n\nWireResult InstanceCreateSurfaceCmd::Deserialize(\n    DeserializeBuffer* deserializeBuffer,\n    DeserializeAllocator* allocator,\n    const ObjectIdResolver& resolver) {\n    const volatile InstanceCreateSurfaceTransfer* transfer;\n    WIRE_TRY(deserializeBuffer->Read(&transfer));\n    return InstanceCreateSurfaceDeserialize(this, transfer, deserializeBuffer, allocator, resolver);\n}\nWireResult InstanceCreateSurfaceCmd::Deserialize(DeserializeBuffer* deserializeBuffer, DeserializeAllocator* allocator) {\n    ErrorObjectIdResolver resolver;\n    return Deserialize(deserializeBuffer, allocator, resolver);\n}\n\nsize_t InstanceProcessEventsCmd::GetRequiredSize() const {\n    return WireAlignSizeof<InstanceProcessEventsTransfer>() + InstanceProcessEventsGetExtraRequiredSize(*this);\n}\n\nWireResult InstanceProcessEventsCmd::Serialize(\n    size_t commandSize,\n    SerializeBuffer* serializeBuffer,\n    const ObjectIdProvider& provider) const {\n    InstanceProcessEventsTransfer* transfer;\n    WIRE_TRY(serializeBuffer->Next(&transfer));\n    transfer->commandSize = commandSize;\n    return (InstanceProcessEventsSerialize(*this, transfer, serializeBuffer, provider));\n}\nWireResult InstanceProcessEventsCmd::Serialize(size_t commandSize, SerializeBuffer* serializeBuffer) const {\n    ErrorObjectIdProvider provider;\n    return Serialize(commandSize, serializeBuffer, provider);\n}\n\nWireResult InstanceProcessEventsCmd::Deserialize(\n    DeserializeBuffer* deserializeBuffer,\n    DeserializeAllocator* allocator,\n    const ObjectIdResolver& resolver) {\n    const volatile InstanceProcessEventsTransfer* transfer;\n    WIRE_TRY(deserializeBuffer->Read(&transfer));\n    return InstanceProcessEventsDeserialize(this, transfer, deserializeBuffer, allocator, resolver);\n}\nWireResult InstanceProcessEventsCmd::Deserialize(DeserializeBuffer* deserializeBuffer, DeserializeAllocator* allocator) {\n    ErrorObjectIdResolver resolver;\n    return Deserialize(deserializeBuffer, allocator, resolver);\n}\n\nsize_t InstanceRequestAdapterCmd::GetRequiredSize() const {\n    return WireAlignSizeof<InstanceRequestAdapterTransfer>() + InstanceRequestAdapterGetExtraRequiredSize(*this);\n}\n\nWireResult InstanceRequestAdapterCmd::Serialize(\n    size_t commandSize,\n    SerializeBuffer* serializeBuffer,\n    const ObjectIdProvider& provider) const {\n    InstanceRequestAdapterTransfer* transfer;\n    WIRE_TRY(serializeBuffer->Next(&transfer));\n    transfer->commandSize = commandSize;\n    return (InstanceRequestAdapterSerialize(*this, transfer, serializeBuffer, provider));\n}\nWireResult InstanceRequestAdapterCmd::Serialize(size_t commandSize, SerializeBuffer* serializeBuffer) const {\n    ErrorObjectIdProvider provider;\n    return Serialize(commandSize, serializeBuffer, provider);\n}\n\nWireResult InstanceRequestAdapterCmd::Deserialize(\n    DeserializeBuffer* deserializeBuffer,\n    DeserializeAllocator* allocator,\n    const ObjectIdResolver& resolver) {\n    const volatile InstanceRequestAdapterTransfer* transfer;\n    WIRE_TRY(deserializeBuffer->Read(&transfer));\n    return InstanceRequestAdapterDeserialize(this, transfer, deserializeBuffer, allocator, resolver);\n}\nWireResult InstanceRequestAdapterCmd::Deserialize(DeserializeBuffer* deserializeBuffer, DeserializeAllocator* allocator) {\n    ErrorObjectIdResolver resolver;\n    return Deserialize(deserializeBuffer, allocator, resolver);\n}\n\nsize_t PipelineLayoutSetLabelCmd::GetRequiredSize() const {\n    return WireAlignSizeof<PipelineLayoutSetLabelTransfer>() + PipelineLayoutSetLabelGetExtraRequiredSize(*this);\n}\n\nWireResult PipelineLayoutSetLabelCmd::Serialize(\n    size_t commandSize,\n    SerializeBuffer* serializeBuffer,\n    const ObjectIdProvider& provider) const {\n    PipelineLayoutSetLabelTransfer* transfer;\n    WIRE_TRY(serializeBuffer->Next(&transfer));\n    transfer->commandSize = commandSize;\n    return (PipelineLayoutSetLabelSerialize(*this, transfer, serializeBuffer, provider));\n}\nWireResult PipelineLayoutSetLabelCmd::Serialize(size_t commandSize, SerializeBuffer* serializeBuffer) const {\n    ErrorObjectIdProvider provider;\n    return Serialize(commandSize, serializeBuffer, provider);\n}\n\nWireResult PipelineLayoutSetLabelCmd::Deserialize(\n    DeserializeBuffer* deserializeBuffer,\n    DeserializeAllocator* allocator,\n    const ObjectIdResolver& resolver) {\n    const volatile PipelineLayoutSetLabelTransfer* transfer;\n    WIRE_TRY(deserializeBuffer->Read(&transfer));\n    return PipelineLayoutSetLabelDeserialize(this, transfer, deserializeBuffer, allocator, resolver);\n}\nWireResult PipelineLayoutSetLabelCmd::Deserialize(DeserializeBuffer* deserializeBuffer, DeserializeAllocator* allocator) {\n    ErrorObjectIdResolver resolver;\n    return Deserialize(deserializeBuffer, allocator, resolver);\n}\n\nsize_t QuerySetDestroyCmd::GetRequiredSize() const {\n    return WireAlignSizeof<QuerySetDestroyTransfer>() + QuerySetDestroyGetExtraRequiredSize(*this);\n}\n\nWireResult QuerySetDestroyCmd::Serialize(\n    size_t commandSize,\n    SerializeBuffer* serializeBuffer,\n    const ObjectIdProvider& provider) const {\n    QuerySetDestroyTransfer* transfer;\n    WIRE_TRY(serializeBuffer->Next(&transfer));\n    transfer->commandSize = commandSize;\n    return (QuerySetDestroySerialize(*this, transfer, serializeBuffer, provider));\n}\nWireResult QuerySetDestroyCmd::Serialize(size_t commandSize, SerializeBuffer* serializeBuffer) const {\n    ErrorObjectIdProvider provider;\n    return Serialize(commandSize, serializeBuffer, provider);\n}\n\nWireResult QuerySetDestroyCmd::Deserialize(\n    DeserializeBuffer* deserializeBuffer,\n    DeserializeAllocator* allocator,\n    const ObjectIdResolver& resolver) {\n    const volatile QuerySetDestroyTransfer* transfer;\n    WIRE_TRY(deserializeBuffer->Read(&transfer));\n    return QuerySetDestroyDeserialize(this, transfer, deserializeBuffer, allocator, resolver);\n}\nWireResult QuerySetDestroyCmd::Deserialize(DeserializeBuffer* deserializeBuffer, DeserializeAllocator* allocator) {\n    ErrorObjectIdResolver resolver;\n    return Deserialize(deserializeBuffer, allocator, resolver);\n}\n\nsize_t QuerySetSetLabelCmd::GetRequiredSize() const {\n    return WireAlignSizeof<QuerySetSetLabelTransfer>() + QuerySetSetLabelGetExtraRequiredSize(*this);\n}\n\nWireResult QuerySetSetLabelCmd::Serialize(\n    size_t commandSize,\n    SerializeBuffer* serializeBuffer,\n    const ObjectIdProvider& provider) const {\n    QuerySetSetLabelTransfer* transfer;\n    WIRE_TRY(serializeBuffer->Next(&transfer));\n    transfer->commandSize = commandSize;\n    return (QuerySetSetLabelSerialize(*this, transfer, serializeBuffer, provider));\n}\nWireResult QuerySetSetLabelCmd::Serialize(size_t commandSize, SerializeBuffer* serializeBuffer) const {\n    ErrorObjectIdProvider provider;\n    return Serialize(commandSize, serializeBuffer, provider);\n}\n\nWireResult QuerySetSetLabelCmd::Deserialize(\n    DeserializeBuffer* deserializeBuffer,\n    DeserializeAllocator* allocator,\n    const ObjectIdResolver& resolver) {\n    const volatile QuerySetSetLabelTransfer* transfer;\n    WIRE_TRY(deserializeBuffer->Read(&transfer));\n    return QuerySetSetLabelDeserialize(this, transfer, deserializeBuffer, allocator, resolver);\n}\nWireResult QuerySetSetLabelCmd::Deserialize(DeserializeBuffer* deserializeBuffer, DeserializeAllocator* allocator) {\n    ErrorObjectIdResolver resolver;\n    return Deserialize(deserializeBuffer, allocator, resolver);\n}\n\nsize_t QueueCopyExternalTextureForBrowserCmd::GetRequiredSize() const {\n    return WireAlignSizeof<QueueCopyExternalTextureForBrowserTransfer>() + QueueCopyExternalTextureForBrowserGetExtraRequiredSize(*this);\n}\n\nWireResult QueueCopyExternalTextureForBrowserCmd::Serialize(\n    size_t commandSize,\n    SerializeBuffer* serializeBuffer,\n    const ObjectIdProvider& provider) const {\n    QueueCopyExternalTextureForBrowserTransfer* transfer;\n    WIRE_TRY(serializeBuffer->Next(&transfer));\n    transfer->commandSize = commandSize;\n    return (QueueCopyExternalTextureForBrowserSerialize(*this, transfer, serializeBuffer, provider));\n}\nWireResult QueueCopyExternalTextureForBrowserCmd::Serialize(size_t commandSize, SerializeBuffer* serializeBuffer) const {\n    ErrorObjectIdProvider provider;\n    return Serialize(commandSize, serializeBuffer, provider);\n}\n\nWireResult QueueCopyExternalTextureForBrowserCmd::Deserialize(\n    DeserializeBuffer* deserializeBuffer,\n    DeserializeAllocator* allocator,\n    const ObjectIdResolver& resolver) {\n    const volatile QueueCopyExternalTextureForBrowserTransfer* transfer;\n    WIRE_TRY(deserializeBuffer->Read(&transfer));\n    return QueueCopyExternalTextureForBrowserDeserialize(this, transfer, deserializeBuffer, allocator, resolver);\n}\nWireResult QueueCopyExternalTextureForBrowserCmd::Deserialize(DeserializeBuffer* deserializeBuffer, DeserializeAllocator* allocator) {\n    ErrorObjectIdResolver resolver;\n    return Deserialize(deserializeBuffer, allocator, resolver);\n}\n\nsize_t QueueCopyTextureForBrowserCmd::GetRequiredSize() const {\n    return WireAlignSizeof<QueueCopyTextureForBrowserTransfer>() + QueueCopyTextureForBrowserGetExtraRequiredSize(*this);\n}\n\nWireResult QueueCopyTextureForBrowserCmd::Serialize(\n    size_t commandSize,\n    SerializeBuffer* serializeBuffer,\n    const ObjectIdProvider& provider) const {\n    QueueCopyTextureForBrowserTransfer* transfer;\n    WIRE_TRY(serializeBuffer->Next(&transfer));\n    transfer->commandSize = commandSize;\n    return (QueueCopyTextureForBrowserSerialize(*this, transfer, serializeBuffer, provider));\n}\nWireResult QueueCopyTextureForBrowserCmd::Serialize(size_t commandSize, SerializeBuffer* serializeBuffer) const {\n    ErrorObjectIdProvider provider;\n    return Serialize(commandSize, serializeBuffer, provider);\n}\n\nWireResult QueueCopyTextureForBrowserCmd::Deserialize(\n    DeserializeBuffer* deserializeBuffer,\n    DeserializeAllocator* allocator,\n    const ObjectIdResolver& resolver) {\n    const volatile QueueCopyTextureForBrowserTransfer* transfer;\n    WIRE_TRY(deserializeBuffer->Read(&transfer));\n    return QueueCopyTextureForBrowserDeserialize(this, transfer, deserializeBuffer, allocator, resolver);\n}\nWireResult QueueCopyTextureForBrowserCmd::Deserialize(DeserializeBuffer* deserializeBuffer, DeserializeAllocator* allocator) {\n    ErrorObjectIdResolver resolver;\n    return Deserialize(deserializeBuffer, allocator, resolver);\n}\n\nsize_t QueueOnSubmittedWorkDoneCmd::GetRequiredSize() const {\n    return WireAlignSizeof<QueueOnSubmittedWorkDoneTransfer>() + QueueOnSubmittedWorkDoneGetExtraRequiredSize(*this);\n}\n\nWireResult QueueOnSubmittedWorkDoneCmd::Serialize(size_t commandSize, SerializeBuffer* serializeBuffer) const {\n    QueueOnSubmittedWorkDoneTransfer* transfer;\n    WIRE_TRY(serializeBuffer->Next(&transfer));\n    transfer->commandSize = commandSize;\n    return (QueueOnSubmittedWorkDoneSerialize(*this, transfer, serializeBuffer));\n}\nWireResult QueueOnSubmittedWorkDoneCmd::Serialize(\n    size_t commandSize,\n    SerializeBuffer* serializeBuffer,\n    const ObjectIdProvider&) const {\n    return Serialize(commandSize, serializeBuffer);\n}\n\nWireResult QueueOnSubmittedWorkDoneCmd::Deserialize(DeserializeBuffer* deserializeBuffer, DeserializeAllocator* allocator) {\n    const volatile QueueOnSubmittedWorkDoneTransfer* transfer;\n    WIRE_TRY(deserializeBuffer->Read(&transfer));\n    return QueueOnSubmittedWorkDoneDeserialize(this, transfer, deserializeBuffer, allocator);\n}\nWireResult QueueOnSubmittedWorkDoneCmd::Deserialize(\n    DeserializeBuffer* deserializeBuffer,\n    DeserializeAllocator* allocator,\n    const ObjectIdResolver&) {\n    return Deserialize(deserializeBuffer, allocator);\n}\n\nsize_t QueueSetLabelCmd::GetRequiredSize() const {\n    return WireAlignSizeof<QueueSetLabelTransfer>() + QueueSetLabelGetExtraRequiredSize(*this);\n}\n\nWireResult QueueSetLabelCmd::Serialize(\n    size_t commandSize,\n    SerializeBuffer* serializeBuffer,\n    const ObjectIdProvider& provider) const {\n    QueueSetLabelTransfer* transfer;\n    WIRE_TRY(serializeBuffer->Next(&transfer));\n    transfer->commandSize = commandSize;\n    return (QueueSetLabelSerialize(*this, transfer, serializeBuffer, provider));\n}\nWireResult QueueSetLabelCmd::Serialize(size_t commandSize, SerializeBuffer* serializeBuffer) const {\n    ErrorObjectIdProvider provider;\n    return Serialize(commandSize, serializeBuffer, provider);\n}\n\nWireResult QueueSetLabelCmd::Deserialize(\n    DeserializeBuffer* deserializeBuffer,\n    DeserializeAllocator* allocator,\n    const ObjectIdResolver& resolver) {\n    const volatile QueueSetLabelTransfer* transfer;\n    WIRE_TRY(deserializeBuffer->Read(&transfer));\n    return QueueSetLabelDeserialize(this, transfer, deserializeBuffer, allocator, resolver);\n}\nWireResult QueueSetLabelCmd::Deserialize(DeserializeBuffer* deserializeBuffer, DeserializeAllocator* allocator) {\n    ErrorObjectIdResolver resolver;\n    return Deserialize(deserializeBuffer, allocator, resolver);\n}\n\nsize_t QueueSubmitCmd::GetRequiredSize() const {\n    return WireAlignSizeof<QueueSubmitTransfer>() + QueueSubmitGetExtraRequiredSize(*this);\n}\n\nWireResult QueueSubmitCmd::Serialize(\n    size_t commandSize,\n    SerializeBuffer* serializeBuffer,\n    const ObjectIdProvider& provider) const {\n    QueueSubmitTransfer* transfer;\n    WIRE_TRY(serializeBuffer->Next(&transfer));\n    transfer->commandSize = commandSize;\n    return (QueueSubmitSerialize(*this, transfer, serializeBuffer, provider));\n}\nWireResult QueueSubmitCmd::Serialize(size_t commandSize, SerializeBuffer* serializeBuffer) const {\n    ErrorObjectIdProvider provider;\n    return Serialize(commandSize, serializeBuffer, provider);\n}\n\nWireResult QueueSubmitCmd::Deserialize(\n    DeserializeBuffer* deserializeBuffer,\n    DeserializeAllocator* allocator,\n    const ObjectIdResolver& resolver) {\n    const volatile QueueSubmitTransfer* transfer;\n    WIRE_TRY(deserializeBuffer->Read(&transfer));\n    return QueueSubmitDeserialize(this, transfer, deserializeBuffer, allocator, resolver);\n}\nWireResult QueueSubmitCmd::Deserialize(DeserializeBuffer* deserializeBuffer, DeserializeAllocator* allocator) {\n    ErrorObjectIdResolver resolver;\n    return Deserialize(deserializeBuffer, allocator, resolver);\n}\n\nsize_t QueueWriteBufferCmd::GetRequiredSize() const {\n    return WireAlignSizeof<QueueWriteBufferTransfer>() + QueueWriteBufferGetExtraRequiredSize(*this);\n}\n\nWireResult QueueWriteBufferCmd::Serialize(size_t commandSize, SerializeBuffer* serializeBuffer) const {\n    QueueWriteBufferTransfer* transfer;\n    WIRE_TRY(serializeBuffer->Next(&transfer));\n    transfer->commandSize = commandSize;\n    return (QueueWriteBufferSerialize(*this, transfer, serializeBuffer));\n}\nWireResult QueueWriteBufferCmd::Serialize(\n    size_t commandSize,\n    SerializeBuffer* serializeBuffer,\n    const ObjectIdProvider&) const {\n    return Serialize(commandSize, serializeBuffer);\n}\n\nWireResult QueueWriteBufferCmd::Deserialize(DeserializeBuffer* deserializeBuffer, DeserializeAllocator* allocator) {\n    const volatile QueueWriteBufferTransfer* transfer;\n    WIRE_TRY(deserializeBuffer->Read(&transfer));\n    return QueueWriteBufferDeserialize(this, transfer, deserializeBuffer, allocator);\n}\nWireResult QueueWriteBufferCmd::Deserialize(\n    DeserializeBuffer* deserializeBuffer,\n    DeserializeAllocator* allocator,\n    const ObjectIdResolver&) {\n    return Deserialize(deserializeBuffer, allocator);\n}\n\nsize_t QueueWriteTextureCmd::GetRequiredSize() const {\n    return WireAlignSizeof<QueueWriteTextureTransfer>() + QueueWriteTextureGetExtraRequiredSize(*this);\n}\n\nWireResult QueueWriteTextureCmd::Serialize(\n    size_t commandSize,\n    SerializeBuffer* serializeBuffer,\n    const ObjectIdProvider& provider) const {\n    QueueWriteTextureTransfer* transfer;\n    WIRE_TRY(serializeBuffer->Next(&transfer));\n    transfer->commandSize = commandSize;\n    return (QueueWriteTextureSerialize(*this, transfer, serializeBuffer, provider));\n}\nWireResult QueueWriteTextureCmd::Serialize(size_t commandSize, SerializeBuffer* serializeBuffer) const {\n    ErrorObjectIdProvider provider;\n    return Serialize(commandSize, serializeBuffer, provider);\n}\n\nWireResult QueueWriteTextureCmd::Deserialize(\n    DeserializeBuffer* deserializeBuffer,\n    DeserializeAllocator* allocator,\n    const ObjectIdResolver& resolver) {\n    const volatile QueueWriteTextureTransfer* transfer;\n    WIRE_TRY(deserializeBuffer->Read(&transfer));\n    return QueueWriteTextureDeserialize(this, transfer, deserializeBuffer, allocator, resolver);\n}\nWireResult QueueWriteTextureCmd::Deserialize(DeserializeBuffer* deserializeBuffer, DeserializeAllocator* allocator) {\n    ErrorObjectIdResolver resolver;\n    return Deserialize(deserializeBuffer, allocator, resolver);\n}\n\nsize_t RenderBundleEncoderDrawCmd::GetRequiredSize() const {\n    return WireAlignSizeof<RenderBundleEncoderDrawTransfer>() + RenderBundleEncoderDrawGetExtraRequiredSize(*this);\n}\n\nWireResult RenderBundleEncoderDrawCmd::Serialize(\n    size_t commandSize,\n    SerializeBuffer* serializeBuffer,\n    const ObjectIdProvider& provider) const {\n    RenderBundleEncoderDrawTransfer* transfer;\n    WIRE_TRY(serializeBuffer->Next(&transfer));\n    transfer->commandSize = commandSize;\n    return (RenderBundleEncoderDrawSerialize(*this, transfer, serializeBuffer, provider));\n}\nWireResult RenderBundleEncoderDrawCmd::Serialize(size_t commandSize, SerializeBuffer* serializeBuffer) const {\n    ErrorObjectIdProvider provider;\n    return Serialize(commandSize, serializeBuffer, provider);\n}\n\nWireResult RenderBundleEncoderDrawCmd::Deserialize(\n    DeserializeBuffer* deserializeBuffer,\n    DeserializeAllocator* allocator,\n    const ObjectIdResolver& resolver) {\n    const volatile RenderBundleEncoderDrawTransfer* transfer;\n    WIRE_TRY(deserializeBuffer->Read(&transfer));\n    return RenderBundleEncoderDrawDeserialize(this, transfer, deserializeBuffer, allocator, resolver);\n}\nWireResult RenderBundleEncoderDrawCmd::Deserialize(DeserializeBuffer* deserializeBuffer, DeserializeAllocator* allocator) {\n    ErrorObjectIdResolver resolver;\n    return Deserialize(deserializeBuffer, allocator, resolver);\n}\n\nsize_t RenderBundleEncoderDrawIndexedCmd::GetRequiredSize() const {\n    return WireAlignSizeof<RenderBundleEncoderDrawIndexedTransfer>() + RenderBundleEncoderDrawIndexedGetExtraRequiredSize(*this);\n}\n\nWireResult RenderBundleEncoderDrawIndexedCmd::Serialize(\n    size_t commandSize,\n    SerializeBuffer* serializeBuffer,\n    const ObjectIdProvider& provider) const {\n    RenderBundleEncoderDrawIndexedTransfer* transfer;\n    WIRE_TRY(serializeBuffer->Next(&transfer));\n    transfer->commandSize = commandSize;\n    return (RenderBundleEncoderDrawIndexedSerialize(*this, transfer, serializeBuffer, provider));\n}\nWireResult RenderBundleEncoderDrawIndexedCmd::Serialize(size_t commandSize, SerializeBuffer* serializeBuffer) const {\n    ErrorObjectIdProvider provider;\n    return Serialize(commandSize, serializeBuffer, provider);\n}\n\nWireResult RenderBundleEncoderDrawIndexedCmd::Deserialize(\n    DeserializeBuffer* deserializeBuffer,\n    DeserializeAllocator* allocator,\n    const ObjectIdResolver& resolver) {\n    const volatile RenderBundleEncoderDrawIndexedTransfer* transfer;\n    WIRE_TRY(deserializeBuffer->Read(&transfer));\n    return RenderBundleEncoderDrawIndexedDeserialize(this, transfer, deserializeBuffer, allocator, resolver);\n}\nWireResult RenderBundleEncoderDrawIndexedCmd::Deserialize(DeserializeBuffer* deserializeBuffer, DeserializeAllocator* allocator) {\n    ErrorObjectIdResolver resolver;\n    return Deserialize(deserializeBuffer, allocator, resolver);\n}\n\nsize_t RenderBundleEncoderDrawIndexedIndirectCmd::GetRequiredSize() const {\n    return WireAlignSizeof<RenderBundleEncoderDrawIndexedIndirectTransfer>() + RenderBundleEncoderDrawIndexedIndirectGetExtraRequiredSize(*this);\n}\n\nWireResult RenderBundleEncoderDrawIndexedIndirectCmd::Serialize(\n    size_t commandSize,\n    SerializeBuffer* serializeBuffer,\n    const ObjectIdProvider& provider) const {\n    RenderBundleEncoderDrawIndexedIndirectTransfer* transfer;\n    WIRE_TRY(serializeBuffer->Next(&transfer));\n    transfer->commandSize = commandSize;\n    return (RenderBundleEncoderDrawIndexedIndirectSerialize(*this, transfer, serializeBuffer, provider));\n}\nWireResult RenderBundleEncoderDrawIndexedIndirectCmd::Serialize(size_t commandSize, SerializeBuffer* serializeBuffer) const {\n    ErrorObjectIdProvider provider;\n    return Serialize(commandSize, serializeBuffer, provider);\n}\n\nWireResult RenderBundleEncoderDrawIndexedIndirectCmd::Deserialize(\n    DeserializeBuffer* deserializeBuffer,\n    DeserializeAllocator* allocator,\n    const ObjectIdResolver& resolver) {\n    const volatile RenderBundleEncoderDrawIndexedIndirectTransfer* transfer;\n    WIRE_TRY(deserializeBuffer->Read(&transfer));\n    return RenderBundleEncoderDrawIndexedIndirectDeserialize(this, transfer, deserializeBuffer, allocator, resolver);\n}\nWireResult RenderBundleEncoderDrawIndexedIndirectCmd::Deserialize(DeserializeBuffer* deserializeBuffer, DeserializeAllocator* allocator) {\n    ErrorObjectIdResolver resolver;\n    return Deserialize(deserializeBuffer, allocator, resolver);\n}\n\nsize_t RenderBundleEncoderDrawIndirectCmd::GetRequiredSize() const {\n    return WireAlignSizeof<RenderBundleEncoderDrawIndirectTransfer>() + RenderBundleEncoderDrawIndirectGetExtraRequiredSize(*this);\n}\n\nWireResult RenderBundleEncoderDrawIndirectCmd::Serialize(\n    size_t commandSize,\n    SerializeBuffer* serializeBuffer,\n    const ObjectIdProvider& provider) const {\n    RenderBundleEncoderDrawIndirectTransfer* transfer;\n    WIRE_TRY(serializeBuffer->Next(&transfer));\n    transfer->commandSize = commandSize;\n    return (RenderBundleEncoderDrawIndirectSerialize(*this, transfer, serializeBuffer, provider));\n}\nWireResult RenderBundleEncoderDrawIndirectCmd::Serialize(size_t commandSize, SerializeBuffer* serializeBuffer) const {\n    ErrorObjectIdProvider provider;\n    return Serialize(commandSize, serializeBuffer, provider);\n}\n\nWireResult RenderBundleEncoderDrawIndirectCmd::Deserialize(\n    DeserializeBuffer* deserializeBuffer,\n    DeserializeAllocator* allocator,\n    const ObjectIdResolver& resolver) {\n    const volatile RenderBundleEncoderDrawIndirectTransfer* transfer;\n    WIRE_TRY(deserializeBuffer->Read(&transfer));\n    return RenderBundleEncoderDrawIndirectDeserialize(this, transfer, deserializeBuffer, allocator, resolver);\n}\nWireResult RenderBundleEncoderDrawIndirectCmd::Deserialize(DeserializeBuffer* deserializeBuffer, DeserializeAllocator* allocator) {\n    ErrorObjectIdResolver resolver;\n    return Deserialize(deserializeBuffer, allocator, resolver);\n}\n\nsize_t RenderBundleEncoderFinishCmd::GetRequiredSize() const {\n    return WireAlignSizeof<RenderBundleEncoderFinishTransfer>() + RenderBundleEncoderFinishGetExtraRequiredSize(*this);\n}\n\nWireResult RenderBundleEncoderFinishCmd::Serialize(\n    size_t commandSize,\n    SerializeBuffer* serializeBuffer,\n    const ObjectIdProvider& provider) const {\n    RenderBundleEncoderFinishTransfer* transfer;\n    WIRE_TRY(serializeBuffer->Next(&transfer));\n    transfer->commandSize = commandSize;\n    return (RenderBundleEncoderFinishSerialize(*this, transfer, serializeBuffer, provider));\n}\nWireResult RenderBundleEncoderFinishCmd::Serialize(size_t commandSize, SerializeBuffer* serializeBuffer) const {\n    ErrorObjectIdProvider provider;\n    return Serialize(commandSize, serializeBuffer, provider);\n}\n\nWireResult RenderBundleEncoderFinishCmd::Deserialize(\n    DeserializeBuffer* deserializeBuffer,\n    DeserializeAllocator* allocator,\n    const ObjectIdResolver& resolver) {\n    const volatile RenderBundleEncoderFinishTransfer* transfer;\n    WIRE_TRY(deserializeBuffer->Read(&transfer));\n    return RenderBundleEncoderFinishDeserialize(this, transfer, deserializeBuffer, allocator, resolver);\n}\nWireResult RenderBundleEncoderFinishCmd::Deserialize(DeserializeBuffer* deserializeBuffer, DeserializeAllocator* allocator) {\n    ErrorObjectIdResolver resolver;\n    return Deserialize(deserializeBuffer, allocator, resolver);\n}\n\nsize_t RenderBundleEncoderInsertDebugMarkerCmd::GetRequiredSize() const {\n    return WireAlignSizeof<RenderBundleEncoderInsertDebugMarkerTransfer>() + RenderBundleEncoderInsertDebugMarkerGetExtraRequiredSize(*this);\n}\n\nWireResult RenderBundleEncoderInsertDebugMarkerCmd::Serialize(\n    size_t commandSize,\n    SerializeBuffer* serializeBuffer,\n    const ObjectIdProvider& provider) const {\n    RenderBundleEncoderInsertDebugMarkerTransfer* transfer;\n    WIRE_TRY(serializeBuffer->Next(&transfer));\n    transfer->commandSize = commandSize;\n    return (RenderBundleEncoderInsertDebugMarkerSerialize(*this, transfer, serializeBuffer, provider));\n}\nWireResult RenderBundleEncoderInsertDebugMarkerCmd::Serialize(size_t commandSize, SerializeBuffer* serializeBuffer) const {\n    ErrorObjectIdProvider provider;\n    return Serialize(commandSize, serializeBuffer, provider);\n}\n\nWireResult RenderBundleEncoderInsertDebugMarkerCmd::Deserialize(\n    DeserializeBuffer* deserializeBuffer,\n    DeserializeAllocator* allocator,\n    const ObjectIdResolver& resolver) {\n    const volatile RenderBundleEncoderInsertDebugMarkerTransfer* transfer;\n    WIRE_TRY(deserializeBuffer->Read(&transfer));\n    return RenderBundleEncoderInsertDebugMarkerDeserialize(this, transfer, deserializeBuffer, allocator, resolver);\n}\nWireResult RenderBundleEncoderInsertDebugMarkerCmd::Deserialize(DeserializeBuffer* deserializeBuffer, DeserializeAllocator* allocator) {\n    ErrorObjectIdResolver resolver;\n    return Deserialize(deserializeBuffer, allocator, resolver);\n}\n\nsize_t RenderBundleEncoderPopDebugGroupCmd::GetRequiredSize() const {\n    return WireAlignSizeof<RenderBundleEncoderPopDebugGroupTransfer>() + RenderBundleEncoderPopDebugGroupGetExtraRequiredSize(*this);\n}\n\nWireResult RenderBundleEncoderPopDebugGroupCmd::Serialize(\n    size_t commandSize,\n    SerializeBuffer* serializeBuffer,\n    const ObjectIdProvider& provider) const {\n    RenderBundleEncoderPopDebugGroupTransfer* transfer;\n    WIRE_TRY(serializeBuffer->Next(&transfer));\n    transfer->commandSize = commandSize;\n    return (RenderBundleEncoderPopDebugGroupSerialize(*this, transfer, serializeBuffer, provider));\n}\nWireResult RenderBundleEncoderPopDebugGroupCmd::Serialize(size_t commandSize, SerializeBuffer* serializeBuffer) const {\n    ErrorObjectIdProvider provider;\n    return Serialize(commandSize, serializeBuffer, provider);\n}\n\nWireResult RenderBundleEncoderPopDebugGroupCmd::Deserialize(\n    DeserializeBuffer* deserializeBuffer,\n    DeserializeAllocator* allocator,\n    const ObjectIdResolver& resolver) {\n    const volatile RenderBundleEncoderPopDebugGroupTransfer* transfer;\n    WIRE_TRY(deserializeBuffer->Read(&transfer));\n    return RenderBundleEncoderPopDebugGroupDeserialize(this, transfer, deserializeBuffer, allocator, resolver);\n}\nWireResult RenderBundleEncoderPopDebugGroupCmd::Deserialize(DeserializeBuffer* deserializeBuffer, DeserializeAllocator* allocator) {\n    ErrorObjectIdResolver resolver;\n    return Deserialize(deserializeBuffer, allocator, resolver);\n}\n\nsize_t RenderBundleEncoderPushDebugGroupCmd::GetRequiredSize() const {\n    return WireAlignSizeof<RenderBundleEncoderPushDebugGroupTransfer>() + RenderBundleEncoderPushDebugGroupGetExtraRequiredSize(*this);\n}\n\nWireResult RenderBundleEncoderPushDebugGroupCmd::Serialize(\n    size_t commandSize,\n    SerializeBuffer* serializeBuffer,\n    const ObjectIdProvider& provider) const {\n    RenderBundleEncoderPushDebugGroupTransfer* transfer;\n    WIRE_TRY(serializeBuffer->Next(&transfer));\n    transfer->commandSize = commandSize;\n    return (RenderBundleEncoderPushDebugGroupSerialize(*this, transfer, serializeBuffer, provider));\n}\nWireResult RenderBundleEncoderPushDebugGroupCmd::Serialize(size_t commandSize, SerializeBuffer* serializeBuffer) const {\n    ErrorObjectIdProvider provider;\n    return Serialize(commandSize, serializeBuffer, provider);\n}\n\nWireResult RenderBundleEncoderPushDebugGroupCmd::Deserialize(\n    DeserializeBuffer* deserializeBuffer,\n    DeserializeAllocator* allocator,\n    const ObjectIdResolver& resolver) {\n    const volatile RenderBundleEncoderPushDebugGroupTransfer* transfer;\n    WIRE_TRY(deserializeBuffer->Read(&transfer));\n    return RenderBundleEncoderPushDebugGroupDeserialize(this, transfer, deserializeBuffer, allocator, resolver);\n}\nWireResult RenderBundleEncoderPushDebugGroupCmd::Deserialize(DeserializeBuffer* deserializeBuffer, DeserializeAllocator* allocator) {\n    ErrorObjectIdResolver resolver;\n    return Deserialize(deserializeBuffer, allocator, resolver);\n}\n\nsize_t RenderBundleEncoderSetBindGroupCmd::GetRequiredSize() const {\n    return WireAlignSizeof<RenderBundleEncoderSetBindGroupTransfer>() + RenderBundleEncoderSetBindGroupGetExtraRequiredSize(*this);\n}\n\nWireResult RenderBundleEncoderSetBindGroupCmd::Serialize(\n    size_t commandSize,\n    SerializeBuffer* serializeBuffer,\n    const ObjectIdProvider& provider) const {\n    RenderBundleEncoderSetBindGroupTransfer* transfer;\n    WIRE_TRY(serializeBuffer->Next(&transfer));\n    transfer->commandSize = commandSize;\n    return (RenderBundleEncoderSetBindGroupSerialize(*this, transfer, serializeBuffer, provider));\n}\nWireResult RenderBundleEncoderSetBindGroupCmd::Serialize(size_t commandSize, SerializeBuffer* serializeBuffer) const {\n    ErrorObjectIdProvider provider;\n    return Serialize(commandSize, serializeBuffer, provider);\n}\n\nWireResult RenderBundleEncoderSetBindGroupCmd::Deserialize(\n    DeserializeBuffer* deserializeBuffer,\n    DeserializeAllocator* allocator,\n    const ObjectIdResolver& resolver) {\n    const volatile RenderBundleEncoderSetBindGroupTransfer* transfer;\n    WIRE_TRY(deserializeBuffer->Read(&transfer));\n    return RenderBundleEncoderSetBindGroupDeserialize(this, transfer, deserializeBuffer, allocator, resolver);\n}\nWireResult RenderBundleEncoderSetBindGroupCmd::Deserialize(DeserializeBuffer* deserializeBuffer, DeserializeAllocator* allocator) {\n    ErrorObjectIdResolver resolver;\n    return Deserialize(deserializeBuffer, allocator, resolver);\n}\n\nsize_t RenderBundleEncoderSetIndexBufferCmd::GetRequiredSize() const {\n    return WireAlignSizeof<RenderBundleEncoderSetIndexBufferTransfer>() + RenderBundleEncoderSetIndexBufferGetExtraRequiredSize(*this);\n}\n\nWireResult RenderBundleEncoderSetIndexBufferCmd::Serialize(\n    size_t commandSize,\n    SerializeBuffer* serializeBuffer,\n    const ObjectIdProvider& provider) const {\n    RenderBundleEncoderSetIndexBufferTransfer* transfer;\n    WIRE_TRY(serializeBuffer->Next(&transfer));\n    transfer->commandSize = commandSize;\n    return (RenderBundleEncoderSetIndexBufferSerialize(*this, transfer, serializeBuffer, provider));\n}\nWireResult RenderBundleEncoderSetIndexBufferCmd::Serialize(size_t commandSize, SerializeBuffer* serializeBuffer) const {\n    ErrorObjectIdProvider provider;\n    return Serialize(commandSize, serializeBuffer, provider);\n}\n\nWireResult RenderBundleEncoderSetIndexBufferCmd::Deserialize(\n    DeserializeBuffer* deserializeBuffer,\n    DeserializeAllocator* allocator,\n    const ObjectIdResolver& resolver) {\n    const volatile RenderBundleEncoderSetIndexBufferTransfer* transfer;\n    WIRE_TRY(deserializeBuffer->Read(&transfer));\n    return RenderBundleEncoderSetIndexBufferDeserialize(this, transfer, deserializeBuffer, allocator, resolver);\n}\nWireResult RenderBundleEncoderSetIndexBufferCmd::Deserialize(DeserializeBuffer* deserializeBuffer, DeserializeAllocator* allocator) {\n    ErrorObjectIdResolver resolver;\n    return Deserialize(deserializeBuffer, allocator, resolver);\n}\n\nsize_t RenderBundleEncoderSetLabelCmd::GetRequiredSize() const {\n    return WireAlignSizeof<RenderBundleEncoderSetLabelTransfer>() + RenderBundleEncoderSetLabelGetExtraRequiredSize(*this);\n}\n\nWireResult RenderBundleEncoderSetLabelCmd::Serialize(\n    size_t commandSize,\n    SerializeBuffer* serializeBuffer,\n    const ObjectIdProvider& provider) const {\n    RenderBundleEncoderSetLabelTransfer* transfer;\n    WIRE_TRY(serializeBuffer->Next(&transfer));\n    transfer->commandSize = commandSize;\n    return (RenderBundleEncoderSetLabelSerialize(*this, transfer, serializeBuffer, provider));\n}\nWireResult RenderBundleEncoderSetLabelCmd::Serialize(size_t commandSize, SerializeBuffer* serializeBuffer) const {\n    ErrorObjectIdProvider provider;\n    return Serialize(commandSize, serializeBuffer, provider);\n}\n\nWireResult RenderBundleEncoderSetLabelCmd::Deserialize(\n    DeserializeBuffer* deserializeBuffer,\n    DeserializeAllocator* allocator,\n    const ObjectIdResolver& resolver) {\n    const volatile RenderBundleEncoderSetLabelTransfer* transfer;\n    WIRE_TRY(deserializeBuffer->Read(&transfer));\n    return RenderBundleEncoderSetLabelDeserialize(this, transfer, deserializeBuffer, allocator, resolver);\n}\nWireResult RenderBundleEncoderSetLabelCmd::Deserialize(DeserializeBuffer* deserializeBuffer, DeserializeAllocator* allocator) {\n    ErrorObjectIdResolver resolver;\n    return Deserialize(deserializeBuffer, allocator, resolver);\n}\n\nsize_t RenderBundleEncoderSetPipelineCmd::GetRequiredSize() const {\n    return WireAlignSizeof<RenderBundleEncoderSetPipelineTransfer>() + RenderBundleEncoderSetPipelineGetExtraRequiredSize(*this);\n}\n\nWireResult RenderBundleEncoderSetPipelineCmd::Serialize(\n    size_t commandSize,\n    SerializeBuffer* serializeBuffer,\n    const ObjectIdProvider& provider) const {\n    RenderBundleEncoderSetPipelineTransfer* transfer;\n    WIRE_TRY(serializeBuffer->Next(&transfer));\n    transfer->commandSize = commandSize;\n    return (RenderBundleEncoderSetPipelineSerialize(*this, transfer, serializeBuffer, provider));\n}\nWireResult RenderBundleEncoderSetPipelineCmd::Serialize(size_t commandSize, SerializeBuffer* serializeBuffer) const {\n    ErrorObjectIdProvider provider;\n    return Serialize(commandSize, serializeBuffer, provider);\n}\n\nWireResult RenderBundleEncoderSetPipelineCmd::Deserialize(\n    DeserializeBuffer* deserializeBuffer,\n    DeserializeAllocator* allocator,\n    const ObjectIdResolver& resolver) {\n    const volatile RenderBundleEncoderSetPipelineTransfer* transfer;\n    WIRE_TRY(deserializeBuffer->Read(&transfer));\n    return RenderBundleEncoderSetPipelineDeserialize(this, transfer, deserializeBuffer, allocator, resolver);\n}\nWireResult RenderBundleEncoderSetPipelineCmd::Deserialize(DeserializeBuffer* deserializeBuffer, DeserializeAllocator* allocator) {\n    ErrorObjectIdResolver resolver;\n    return Deserialize(deserializeBuffer, allocator, resolver);\n}\n\nsize_t RenderBundleEncoderSetVertexBufferCmd::GetRequiredSize() const {\n    return WireAlignSizeof<RenderBundleEncoderSetVertexBufferTransfer>() + RenderBundleEncoderSetVertexBufferGetExtraRequiredSize(*this);\n}\n\nWireResult RenderBundleEncoderSetVertexBufferCmd::Serialize(\n    size_t commandSize,\n    SerializeBuffer* serializeBuffer,\n    const ObjectIdProvider& provider) const {\n    RenderBundleEncoderSetVertexBufferTransfer* transfer;\n    WIRE_TRY(serializeBuffer->Next(&transfer));\n    transfer->commandSize = commandSize;\n    return (RenderBundleEncoderSetVertexBufferSerialize(*this, transfer, serializeBuffer, provider));\n}\nWireResult RenderBundleEncoderSetVertexBufferCmd::Serialize(size_t commandSize, SerializeBuffer* serializeBuffer) const {\n    ErrorObjectIdProvider provider;\n    return Serialize(commandSize, serializeBuffer, provider);\n}\n\nWireResult RenderBundleEncoderSetVertexBufferCmd::Deserialize(\n    DeserializeBuffer* deserializeBuffer,\n    DeserializeAllocator* allocator,\n    const ObjectIdResolver& resolver) {\n    const volatile RenderBundleEncoderSetVertexBufferTransfer* transfer;\n    WIRE_TRY(deserializeBuffer->Read(&transfer));\n    return RenderBundleEncoderSetVertexBufferDeserialize(this, transfer, deserializeBuffer, allocator, resolver);\n}\nWireResult RenderBundleEncoderSetVertexBufferCmd::Deserialize(DeserializeBuffer* deserializeBuffer, DeserializeAllocator* allocator) {\n    ErrorObjectIdResolver resolver;\n    return Deserialize(deserializeBuffer, allocator, resolver);\n}\n\nsize_t RenderBundleSetLabelCmd::GetRequiredSize() const {\n    return WireAlignSizeof<RenderBundleSetLabelTransfer>() + RenderBundleSetLabelGetExtraRequiredSize(*this);\n}\n\nWireResult RenderBundleSetLabelCmd::Serialize(\n    size_t commandSize,\n    SerializeBuffer* serializeBuffer,\n    const ObjectIdProvider& provider) const {\n    RenderBundleSetLabelTransfer* transfer;\n    WIRE_TRY(serializeBuffer->Next(&transfer));\n    transfer->commandSize = commandSize;\n    return (RenderBundleSetLabelSerialize(*this, transfer, serializeBuffer, provider));\n}\nWireResult RenderBundleSetLabelCmd::Serialize(size_t commandSize, SerializeBuffer* serializeBuffer) const {\n    ErrorObjectIdProvider provider;\n    return Serialize(commandSize, serializeBuffer, provider);\n}\n\nWireResult RenderBundleSetLabelCmd::Deserialize(\n    DeserializeBuffer* deserializeBuffer,\n    DeserializeAllocator* allocator,\n    const ObjectIdResolver& resolver) {\n    const volatile RenderBundleSetLabelTransfer* transfer;\n    WIRE_TRY(deserializeBuffer->Read(&transfer));\n    return RenderBundleSetLabelDeserialize(this, transfer, deserializeBuffer, allocator, resolver);\n}\nWireResult RenderBundleSetLabelCmd::Deserialize(DeserializeBuffer* deserializeBuffer, DeserializeAllocator* allocator) {\n    ErrorObjectIdResolver resolver;\n    return Deserialize(deserializeBuffer, allocator, resolver);\n}\n\nsize_t RenderPassEncoderBeginOcclusionQueryCmd::GetRequiredSize() const {\n    return WireAlignSizeof<RenderPassEncoderBeginOcclusionQueryTransfer>() + RenderPassEncoderBeginOcclusionQueryGetExtraRequiredSize(*this);\n}\n\nWireResult RenderPassEncoderBeginOcclusionQueryCmd::Serialize(\n    size_t commandSize,\n    SerializeBuffer* serializeBuffer,\n    const ObjectIdProvider& provider) const {\n    RenderPassEncoderBeginOcclusionQueryTransfer* transfer;\n    WIRE_TRY(serializeBuffer->Next(&transfer));\n    transfer->commandSize = commandSize;\n    return (RenderPassEncoderBeginOcclusionQuerySerialize(*this, transfer, serializeBuffer, provider));\n}\nWireResult RenderPassEncoderBeginOcclusionQueryCmd::Serialize(size_t commandSize, SerializeBuffer* serializeBuffer) const {\n    ErrorObjectIdProvider provider;\n    return Serialize(commandSize, serializeBuffer, provider);\n}\n\nWireResult RenderPassEncoderBeginOcclusionQueryCmd::Deserialize(\n    DeserializeBuffer* deserializeBuffer,\n    DeserializeAllocator* allocator,\n    const ObjectIdResolver& resolver) {\n    const volatile RenderPassEncoderBeginOcclusionQueryTransfer* transfer;\n    WIRE_TRY(deserializeBuffer->Read(&transfer));\n    return RenderPassEncoderBeginOcclusionQueryDeserialize(this, transfer, deserializeBuffer, allocator, resolver);\n}\nWireResult RenderPassEncoderBeginOcclusionQueryCmd::Deserialize(DeserializeBuffer* deserializeBuffer, DeserializeAllocator* allocator) {\n    ErrorObjectIdResolver resolver;\n    return Deserialize(deserializeBuffer, allocator, resolver);\n}\n\nsize_t RenderPassEncoderDrawCmd::GetRequiredSize() const {\n    return WireAlignSizeof<RenderPassEncoderDrawTransfer>() + RenderPassEncoderDrawGetExtraRequiredSize(*this);\n}\n\nWireResult RenderPassEncoderDrawCmd::Serialize(\n    size_t commandSize,\n    SerializeBuffer* serializeBuffer,\n    const ObjectIdProvider& provider) const {\n    RenderPassEncoderDrawTransfer* transfer;\n    WIRE_TRY(serializeBuffer->Next(&transfer));\n    transfer->commandSize = commandSize;\n    return (RenderPassEncoderDrawSerialize(*this, transfer, serializeBuffer, provider));\n}\nWireResult RenderPassEncoderDrawCmd::Serialize(size_t commandSize, SerializeBuffer* serializeBuffer) const {\n    ErrorObjectIdProvider provider;\n    return Serialize(commandSize, serializeBuffer, provider);\n}\n\nWireResult RenderPassEncoderDrawCmd::Deserialize(\n    DeserializeBuffer* deserializeBuffer,\n    DeserializeAllocator* allocator,\n    const ObjectIdResolver& resolver) {\n    const volatile RenderPassEncoderDrawTransfer* transfer;\n    WIRE_TRY(deserializeBuffer->Read(&transfer));\n    return RenderPassEncoderDrawDeserialize(this, transfer, deserializeBuffer, allocator, resolver);\n}\nWireResult RenderPassEncoderDrawCmd::Deserialize(DeserializeBuffer* deserializeBuffer, DeserializeAllocator* allocator) {\n    ErrorObjectIdResolver resolver;\n    return Deserialize(deserializeBuffer, allocator, resolver);\n}\n\nsize_t RenderPassEncoderDrawIndexedCmd::GetRequiredSize() const {\n    return WireAlignSizeof<RenderPassEncoderDrawIndexedTransfer>() + RenderPassEncoderDrawIndexedGetExtraRequiredSize(*this);\n}\n\nWireResult RenderPassEncoderDrawIndexedCmd::Serialize(\n    size_t commandSize,\n    SerializeBuffer* serializeBuffer,\n    const ObjectIdProvider& provider) const {\n    RenderPassEncoderDrawIndexedTransfer* transfer;\n    WIRE_TRY(serializeBuffer->Next(&transfer));\n    transfer->commandSize = commandSize;\n    return (RenderPassEncoderDrawIndexedSerialize(*this, transfer, serializeBuffer, provider));\n}\nWireResult RenderPassEncoderDrawIndexedCmd::Serialize(size_t commandSize, SerializeBuffer* serializeBuffer) const {\n    ErrorObjectIdProvider provider;\n    return Serialize(commandSize, serializeBuffer, provider);\n}\n\nWireResult RenderPassEncoderDrawIndexedCmd::Deserialize(\n    DeserializeBuffer* deserializeBuffer,\n    DeserializeAllocator* allocator,\n    const ObjectIdResolver& resolver) {\n    const volatile RenderPassEncoderDrawIndexedTransfer* transfer;\n    WIRE_TRY(deserializeBuffer->Read(&transfer));\n    return RenderPassEncoderDrawIndexedDeserialize(this, transfer, deserializeBuffer, allocator, resolver);\n}\nWireResult RenderPassEncoderDrawIndexedCmd::Deserialize(DeserializeBuffer* deserializeBuffer, DeserializeAllocator* allocator) {\n    ErrorObjectIdResolver resolver;\n    return Deserialize(deserializeBuffer, allocator, resolver);\n}\n\nsize_t RenderPassEncoderDrawIndexedIndirectCmd::GetRequiredSize() const {\n    return WireAlignSizeof<RenderPassEncoderDrawIndexedIndirectTransfer>() + RenderPassEncoderDrawIndexedIndirectGetExtraRequiredSize(*this);\n}\n\nWireResult RenderPassEncoderDrawIndexedIndirectCmd::Serialize(\n    size_t commandSize,\n    SerializeBuffer* serializeBuffer,\n    const ObjectIdProvider& provider) const {\n    RenderPassEncoderDrawIndexedIndirectTransfer* transfer;\n    WIRE_TRY(serializeBuffer->Next(&transfer));\n    transfer->commandSize = commandSize;\n    return (RenderPassEncoderDrawIndexedIndirectSerialize(*this, transfer, serializeBuffer, provider));\n}\nWireResult RenderPassEncoderDrawIndexedIndirectCmd::Serialize(size_t commandSize, SerializeBuffer* serializeBuffer) const {\n    ErrorObjectIdProvider provider;\n    return Serialize(commandSize, serializeBuffer, provider);\n}\n\nWireResult RenderPassEncoderDrawIndexedIndirectCmd::Deserialize(\n    DeserializeBuffer* deserializeBuffer,\n    DeserializeAllocator* allocator,\n    const ObjectIdResolver& resolver) {\n    const volatile RenderPassEncoderDrawIndexedIndirectTransfer* transfer;\n    WIRE_TRY(deserializeBuffer->Read(&transfer));\n    return RenderPassEncoderDrawIndexedIndirectDeserialize(this, transfer, deserializeBuffer, allocator, resolver);\n}\nWireResult RenderPassEncoderDrawIndexedIndirectCmd::Deserialize(DeserializeBuffer* deserializeBuffer, DeserializeAllocator* allocator) {\n    ErrorObjectIdResolver resolver;\n    return Deserialize(deserializeBuffer, allocator, resolver);\n}\n\nsize_t RenderPassEncoderDrawIndirectCmd::GetRequiredSize() const {\n    return WireAlignSizeof<RenderPassEncoderDrawIndirectTransfer>() + RenderPassEncoderDrawIndirectGetExtraRequiredSize(*this);\n}\n\nWireResult RenderPassEncoderDrawIndirectCmd::Serialize(\n    size_t commandSize,\n    SerializeBuffer* serializeBuffer,\n    const ObjectIdProvider& provider) const {\n    RenderPassEncoderDrawIndirectTransfer* transfer;\n    WIRE_TRY(serializeBuffer->Next(&transfer));\n    transfer->commandSize = commandSize;\n    return (RenderPassEncoderDrawIndirectSerialize(*this, transfer, serializeBuffer, provider));\n}\nWireResult RenderPassEncoderDrawIndirectCmd::Serialize(size_t commandSize, SerializeBuffer* serializeBuffer) const {\n    ErrorObjectIdProvider provider;\n    return Serialize(commandSize, serializeBuffer, provider);\n}\n\nWireResult RenderPassEncoderDrawIndirectCmd::Deserialize(\n    DeserializeBuffer* deserializeBuffer,\n    DeserializeAllocator* allocator,\n    const ObjectIdResolver& resolver) {\n    const volatile RenderPassEncoderDrawIndirectTransfer* transfer;\n    WIRE_TRY(deserializeBuffer->Read(&transfer));\n    return RenderPassEncoderDrawIndirectDeserialize(this, transfer, deserializeBuffer, allocator, resolver);\n}\nWireResult RenderPassEncoderDrawIndirectCmd::Deserialize(DeserializeBuffer* deserializeBuffer, DeserializeAllocator* allocator) {\n    ErrorObjectIdResolver resolver;\n    return Deserialize(deserializeBuffer, allocator, resolver);\n}\n\nsize_t RenderPassEncoderEndCmd::GetRequiredSize() const {\n    return WireAlignSizeof<RenderPassEncoderEndTransfer>() + RenderPassEncoderEndGetExtraRequiredSize(*this);\n}\n\nWireResult RenderPassEncoderEndCmd::Serialize(\n    size_t commandSize,\n    SerializeBuffer* serializeBuffer,\n    const ObjectIdProvider& provider) const {\n    RenderPassEncoderEndTransfer* transfer;\n    WIRE_TRY(serializeBuffer->Next(&transfer));\n    transfer->commandSize = commandSize;\n    return (RenderPassEncoderEndSerialize(*this, transfer, serializeBuffer, provider));\n}\nWireResult RenderPassEncoderEndCmd::Serialize(size_t commandSize, SerializeBuffer* serializeBuffer) const {\n    ErrorObjectIdProvider provider;\n    return Serialize(commandSize, serializeBuffer, provider);\n}\n\nWireResult RenderPassEncoderEndCmd::Deserialize(\n    DeserializeBuffer* deserializeBuffer,\n    DeserializeAllocator* allocator,\n    const ObjectIdResolver& resolver) {\n    const volatile RenderPassEncoderEndTransfer* transfer;\n    WIRE_TRY(deserializeBuffer->Read(&transfer));\n    return RenderPassEncoderEndDeserialize(this, transfer, deserializeBuffer, allocator, resolver);\n}\nWireResult RenderPassEncoderEndCmd::Deserialize(DeserializeBuffer* deserializeBuffer, DeserializeAllocator* allocator) {\n    ErrorObjectIdResolver resolver;\n    return Deserialize(deserializeBuffer, allocator, resolver);\n}\n\nsize_t RenderPassEncoderEndOcclusionQueryCmd::GetRequiredSize() const {\n    return WireAlignSizeof<RenderPassEncoderEndOcclusionQueryTransfer>() + RenderPassEncoderEndOcclusionQueryGetExtraRequiredSize(*this);\n}\n\nWireResult RenderPassEncoderEndOcclusionQueryCmd::Serialize(\n    size_t commandSize,\n    SerializeBuffer* serializeBuffer,\n    const ObjectIdProvider& provider) const {\n    RenderPassEncoderEndOcclusionQueryTransfer* transfer;\n    WIRE_TRY(serializeBuffer->Next(&transfer));\n    transfer->commandSize = commandSize;\n    return (RenderPassEncoderEndOcclusionQuerySerialize(*this, transfer, serializeBuffer, provider));\n}\nWireResult RenderPassEncoderEndOcclusionQueryCmd::Serialize(size_t commandSize, SerializeBuffer* serializeBuffer) const {\n    ErrorObjectIdProvider provider;\n    return Serialize(commandSize, serializeBuffer, provider);\n}\n\nWireResult RenderPassEncoderEndOcclusionQueryCmd::Deserialize(\n    DeserializeBuffer* deserializeBuffer,\n    DeserializeAllocator* allocator,\n    const ObjectIdResolver& resolver) {\n    const volatile RenderPassEncoderEndOcclusionQueryTransfer* transfer;\n    WIRE_TRY(deserializeBuffer->Read(&transfer));\n    return RenderPassEncoderEndOcclusionQueryDeserialize(this, transfer, deserializeBuffer, allocator, resolver);\n}\nWireResult RenderPassEncoderEndOcclusionQueryCmd::Deserialize(DeserializeBuffer* deserializeBuffer, DeserializeAllocator* allocator) {\n    ErrorObjectIdResolver resolver;\n    return Deserialize(deserializeBuffer, allocator, resolver);\n}\n\nsize_t RenderPassEncoderExecuteBundlesCmd::GetRequiredSize() const {\n    return WireAlignSizeof<RenderPassEncoderExecuteBundlesTransfer>() + RenderPassEncoderExecuteBundlesGetExtraRequiredSize(*this);\n}\n\nWireResult RenderPassEncoderExecuteBundlesCmd::Serialize(\n    size_t commandSize,\n    SerializeBuffer* serializeBuffer,\n    const ObjectIdProvider& provider) const {\n    RenderPassEncoderExecuteBundlesTransfer* transfer;\n    WIRE_TRY(serializeBuffer->Next(&transfer));\n    transfer->commandSize = commandSize;\n    return (RenderPassEncoderExecuteBundlesSerialize(*this, transfer, serializeBuffer, provider));\n}\nWireResult RenderPassEncoderExecuteBundlesCmd::Serialize(size_t commandSize, SerializeBuffer* serializeBuffer) const {\n    ErrorObjectIdProvider provider;\n    return Serialize(commandSize, serializeBuffer, provider);\n}\n\nWireResult RenderPassEncoderExecuteBundlesCmd::Deserialize(\n    DeserializeBuffer* deserializeBuffer,\n    DeserializeAllocator* allocator,\n    const ObjectIdResolver& resolver) {\n    const volatile RenderPassEncoderExecuteBundlesTransfer* transfer;\n    WIRE_TRY(deserializeBuffer->Read(&transfer));\n    return RenderPassEncoderExecuteBundlesDeserialize(this, transfer, deserializeBuffer, allocator, resolver);\n}\nWireResult RenderPassEncoderExecuteBundlesCmd::Deserialize(DeserializeBuffer* deserializeBuffer, DeserializeAllocator* allocator) {\n    ErrorObjectIdResolver resolver;\n    return Deserialize(deserializeBuffer, allocator, resolver);\n}\n\nsize_t RenderPassEncoderInsertDebugMarkerCmd::GetRequiredSize() const {\n    return WireAlignSizeof<RenderPassEncoderInsertDebugMarkerTransfer>() + RenderPassEncoderInsertDebugMarkerGetExtraRequiredSize(*this);\n}\n\nWireResult RenderPassEncoderInsertDebugMarkerCmd::Serialize(\n    size_t commandSize,\n    SerializeBuffer* serializeBuffer,\n    const ObjectIdProvider& provider) const {\n    RenderPassEncoderInsertDebugMarkerTransfer* transfer;\n    WIRE_TRY(serializeBuffer->Next(&transfer));\n    transfer->commandSize = commandSize;\n    return (RenderPassEncoderInsertDebugMarkerSerialize(*this, transfer, serializeBuffer, provider));\n}\nWireResult RenderPassEncoderInsertDebugMarkerCmd::Serialize(size_t commandSize, SerializeBuffer* serializeBuffer) const {\n    ErrorObjectIdProvider provider;\n    return Serialize(commandSize, serializeBuffer, provider);\n}\n\nWireResult RenderPassEncoderInsertDebugMarkerCmd::Deserialize(\n    DeserializeBuffer* deserializeBuffer,\n    DeserializeAllocator* allocator,\n    const ObjectIdResolver& resolver) {\n    const volatile RenderPassEncoderInsertDebugMarkerTransfer* transfer;\n    WIRE_TRY(deserializeBuffer->Read(&transfer));\n    return RenderPassEncoderInsertDebugMarkerDeserialize(this, transfer, deserializeBuffer, allocator, resolver);\n}\nWireResult RenderPassEncoderInsertDebugMarkerCmd::Deserialize(DeserializeBuffer* deserializeBuffer, DeserializeAllocator* allocator) {\n    ErrorObjectIdResolver resolver;\n    return Deserialize(deserializeBuffer, allocator, resolver);\n}\n\nsize_t RenderPassEncoderPopDebugGroupCmd::GetRequiredSize() const {\n    return WireAlignSizeof<RenderPassEncoderPopDebugGroupTransfer>() + RenderPassEncoderPopDebugGroupGetExtraRequiredSize(*this);\n}\n\nWireResult RenderPassEncoderPopDebugGroupCmd::Serialize(\n    size_t commandSize,\n    SerializeBuffer* serializeBuffer,\n    const ObjectIdProvider& provider) const {\n    RenderPassEncoderPopDebugGroupTransfer* transfer;\n    WIRE_TRY(serializeBuffer->Next(&transfer));\n    transfer->commandSize = commandSize;\n    return (RenderPassEncoderPopDebugGroupSerialize(*this, transfer, serializeBuffer, provider));\n}\nWireResult RenderPassEncoderPopDebugGroupCmd::Serialize(size_t commandSize, SerializeBuffer* serializeBuffer) const {\n    ErrorObjectIdProvider provider;\n    return Serialize(commandSize, serializeBuffer, provider);\n}\n\nWireResult RenderPassEncoderPopDebugGroupCmd::Deserialize(\n    DeserializeBuffer* deserializeBuffer,\n    DeserializeAllocator* allocator,\n    const ObjectIdResolver& resolver) {\n    const volatile RenderPassEncoderPopDebugGroupTransfer* transfer;\n    WIRE_TRY(deserializeBuffer->Read(&transfer));\n    return RenderPassEncoderPopDebugGroupDeserialize(this, transfer, deserializeBuffer, allocator, resolver);\n}\nWireResult RenderPassEncoderPopDebugGroupCmd::Deserialize(DeserializeBuffer* deserializeBuffer, DeserializeAllocator* allocator) {\n    ErrorObjectIdResolver resolver;\n    return Deserialize(deserializeBuffer, allocator, resolver);\n}\n\nsize_t RenderPassEncoderPushDebugGroupCmd::GetRequiredSize() const {\n    return WireAlignSizeof<RenderPassEncoderPushDebugGroupTransfer>() + RenderPassEncoderPushDebugGroupGetExtraRequiredSize(*this);\n}\n\nWireResult RenderPassEncoderPushDebugGroupCmd::Serialize(\n    size_t commandSize,\n    SerializeBuffer* serializeBuffer,\n    const ObjectIdProvider& provider) const {\n    RenderPassEncoderPushDebugGroupTransfer* transfer;\n    WIRE_TRY(serializeBuffer->Next(&transfer));\n    transfer->commandSize = commandSize;\n    return (RenderPassEncoderPushDebugGroupSerialize(*this, transfer, serializeBuffer, provider));\n}\nWireResult RenderPassEncoderPushDebugGroupCmd::Serialize(size_t commandSize, SerializeBuffer* serializeBuffer) const {\n    ErrorObjectIdProvider provider;\n    return Serialize(commandSize, serializeBuffer, provider);\n}\n\nWireResult RenderPassEncoderPushDebugGroupCmd::Deserialize(\n    DeserializeBuffer* deserializeBuffer,\n    DeserializeAllocator* allocator,\n    const ObjectIdResolver& resolver) {\n    const volatile RenderPassEncoderPushDebugGroupTransfer* transfer;\n    WIRE_TRY(deserializeBuffer->Read(&transfer));\n    return RenderPassEncoderPushDebugGroupDeserialize(this, transfer, deserializeBuffer, allocator, resolver);\n}\nWireResult RenderPassEncoderPushDebugGroupCmd::Deserialize(DeserializeBuffer* deserializeBuffer, DeserializeAllocator* allocator) {\n    ErrorObjectIdResolver resolver;\n    return Deserialize(deserializeBuffer, allocator, resolver);\n}\n\nsize_t RenderPassEncoderSetBindGroupCmd::GetRequiredSize() const {\n    return WireAlignSizeof<RenderPassEncoderSetBindGroupTransfer>() + RenderPassEncoderSetBindGroupGetExtraRequiredSize(*this);\n}\n\nWireResult RenderPassEncoderSetBindGroupCmd::Serialize(\n    size_t commandSize,\n    SerializeBuffer* serializeBuffer,\n    const ObjectIdProvider& provider) const {\n    RenderPassEncoderSetBindGroupTransfer* transfer;\n    WIRE_TRY(serializeBuffer->Next(&transfer));\n    transfer->commandSize = commandSize;\n    return (RenderPassEncoderSetBindGroupSerialize(*this, transfer, serializeBuffer, provider));\n}\nWireResult RenderPassEncoderSetBindGroupCmd::Serialize(size_t commandSize, SerializeBuffer* serializeBuffer) const {\n    ErrorObjectIdProvider provider;\n    return Serialize(commandSize, serializeBuffer, provider);\n}\n\nWireResult RenderPassEncoderSetBindGroupCmd::Deserialize(\n    DeserializeBuffer* deserializeBuffer,\n    DeserializeAllocator* allocator,\n    const ObjectIdResolver& resolver) {\n    const volatile RenderPassEncoderSetBindGroupTransfer* transfer;\n    WIRE_TRY(deserializeBuffer->Read(&transfer));\n    return RenderPassEncoderSetBindGroupDeserialize(this, transfer, deserializeBuffer, allocator, resolver);\n}\nWireResult RenderPassEncoderSetBindGroupCmd::Deserialize(DeserializeBuffer* deserializeBuffer, DeserializeAllocator* allocator) {\n    ErrorObjectIdResolver resolver;\n    return Deserialize(deserializeBuffer, allocator, resolver);\n}\n\nsize_t RenderPassEncoderSetBlendConstantCmd::GetRequiredSize() const {\n    return WireAlignSizeof<RenderPassEncoderSetBlendConstantTransfer>() + RenderPassEncoderSetBlendConstantGetExtraRequiredSize(*this);\n}\n\nWireResult RenderPassEncoderSetBlendConstantCmd::Serialize(\n    size_t commandSize,\n    SerializeBuffer* serializeBuffer,\n    const ObjectIdProvider& provider) const {\n    RenderPassEncoderSetBlendConstantTransfer* transfer;\n    WIRE_TRY(serializeBuffer->Next(&transfer));\n    transfer->commandSize = commandSize;\n    return (RenderPassEncoderSetBlendConstantSerialize(*this, transfer, serializeBuffer, provider));\n}\nWireResult RenderPassEncoderSetBlendConstantCmd::Serialize(size_t commandSize, SerializeBuffer* serializeBuffer) const {\n    ErrorObjectIdProvider provider;\n    return Serialize(commandSize, serializeBuffer, provider);\n}\n\nWireResult RenderPassEncoderSetBlendConstantCmd::Deserialize(\n    DeserializeBuffer* deserializeBuffer,\n    DeserializeAllocator* allocator,\n    const ObjectIdResolver& resolver) {\n    const volatile RenderPassEncoderSetBlendConstantTransfer* transfer;\n    WIRE_TRY(deserializeBuffer->Read(&transfer));\n    return RenderPassEncoderSetBlendConstantDeserialize(this, transfer, deserializeBuffer, allocator, resolver);\n}\nWireResult RenderPassEncoderSetBlendConstantCmd::Deserialize(DeserializeBuffer* deserializeBuffer, DeserializeAllocator* allocator) {\n    ErrorObjectIdResolver resolver;\n    return Deserialize(deserializeBuffer, allocator, resolver);\n}\n\nsize_t RenderPassEncoderSetIndexBufferCmd::GetRequiredSize() const {\n    return WireAlignSizeof<RenderPassEncoderSetIndexBufferTransfer>() + RenderPassEncoderSetIndexBufferGetExtraRequiredSize(*this);\n}\n\nWireResult RenderPassEncoderSetIndexBufferCmd::Serialize(\n    size_t commandSize,\n    SerializeBuffer* serializeBuffer,\n    const ObjectIdProvider& provider) const {\n    RenderPassEncoderSetIndexBufferTransfer* transfer;\n    WIRE_TRY(serializeBuffer->Next(&transfer));\n    transfer->commandSize = commandSize;\n    return (RenderPassEncoderSetIndexBufferSerialize(*this, transfer, serializeBuffer, provider));\n}\nWireResult RenderPassEncoderSetIndexBufferCmd::Serialize(size_t commandSize, SerializeBuffer* serializeBuffer) const {\n    ErrorObjectIdProvider provider;\n    return Serialize(commandSize, serializeBuffer, provider);\n}\n\nWireResult RenderPassEncoderSetIndexBufferCmd::Deserialize(\n    DeserializeBuffer* deserializeBuffer,\n    DeserializeAllocator* allocator,\n    const ObjectIdResolver& resolver) {\n    const volatile RenderPassEncoderSetIndexBufferTransfer* transfer;\n    WIRE_TRY(deserializeBuffer->Read(&transfer));\n    return RenderPassEncoderSetIndexBufferDeserialize(this, transfer, deserializeBuffer, allocator, resolver);\n}\nWireResult RenderPassEncoderSetIndexBufferCmd::Deserialize(DeserializeBuffer* deserializeBuffer, DeserializeAllocator* allocator) {\n    ErrorObjectIdResolver resolver;\n    return Deserialize(deserializeBuffer, allocator, resolver);\n}\n\nsize_t RenderPassEncoderSetLabelCmd::GetRequiredSize() const {\n    return WireAlignSizeof<RenderPassEncoderSetLabelTransfer>() + RenderPassEncoderSetLabelGetExtraRequiredSize(*this);\n}\n\nWireResult RenderPassEncoderSetLabelCmd::Serialize(\n    size_t commandSize,\n    SerializeBuffer* serializeBuffer,\n    const ObjectIdProvider& provider) const {\n    RenderPassEncoderSetLabelTransfer* transfer;\n    WIRE_TRY(serializeBuffer->Next(&transfer));\n    transfer->commandSize = commandSize;\n    return (RenderPassEncoderSetLabelSerialize(*this, transfer, serializeBuffer, provider));\n}\nWireResult RenderPassEncoderSetLabelCmd::Serialize(size_t commandSize, SerializeBuffer* serializeBuffer) const {\n    ErrorObjectIdProvider provider;\n    return Serialize(commandSize, serializeBuffer, provider);\n}\n\nWireResult RenderPassEncoderSetLabelCmd::Deserialize(\n    DeserializeBuffer* deserializeBuffer,\n    DeserializeAllocator* allocator,\n    const ObjectIdResolver& resolver) {\n    const volatile RenderPassEncoderSetLabelTransfer* transfer;\n    WIRE_TRY(deserializeBuffer->Read(&transfer));\n    return RenderPassEncoderSetLabelDeserialize(this, transfer, deserializeBuffer, allocator, resolver);\n}\nWireResult RenderPassEncoderSetLabelCmd::Deserialize(DeserializeBuffer* deserializeBuffer, DeserializeAllocator* allocator) {\n    ErrorObjectIdResolver resolver;\n    return Deserialize(deserializeBuffer, allocator, resolver);\n}\n\nsize_t RenderPassEncoderSetPipelineCmd::GetRequiredSize() const {\n    return WireAlignSizeof<RenderPassEncoderSetPipelineTransfer>() + RenderPassEncoderSetPipelineGetExtraRequiredSize(*this);\n}\n\nWireResult RenderPassEncoderSetPipelineCmd::Serialize(\n    size_t commandSize,\n    SerializeBuffer* serializeBuffer,\n    const ObjectIdProvider& provider) const {\n    RenderPassEncoderSetPipelineTransfer* transfer;\n    WIRE_TRY(serializeBuffer->Next(&transfer));\n    transfer->commandSize = commandSize;\n    return (RenderPassEncoderSetPipelineSerialize(*this, transfer, serializeBuffer, provider));\n}\nWireResult RenderPassEncoderSetPipelineCmd::Serialize(size_t commandSize, SerializeBuffer* serializeBuffer) const {\n    ErrorObjectIdProvider provider;\n    return Serialize(commandSize, serializeBuffer, provider);\n}\n\nWireResult RenderPassEncoderSetPipelineCmd::Deserialize(\n    DeserializeBuffer* deserializeBuffer,\n    DeserializeAllocator* allocator,\n    const ObjectIdResolver& resolver) {\n    const volatile RenderPassEncoderSetPipelineTransfer* transfer;\n    WIRE_TRY(deserializeBuffer->Read(&transfer));\n    return RenderPassEncoderSetPipelineDeserialize(this, transfer, deserializeBuffer, allocator, resolver);\n}\nWireResult RenderPassEncoderSetPipelineCmd::Deserialize(DeserializeBuffer* deserializeBuffer, DeserializeAllocator* allocator) {\n    ErrorObjectIdResolver resolver;\n    return Deserialize(deserializeBuffer, allocator, resolver);\n}\n\nsize_t RenderPassEncoderSetScissorRectCmd::GetRequiredSize() const {\n    return WireAlignSizeof<RenderPassEncoderSetScissorRectTransfer>() + RenderPassEncoderSetScissorRectGetExtraRequiredSize(*this);\n}\n\nWireResult RenderPassEncoderSetScissorRectCmd::Serialize(\n    size_t commandSize,\n    SerializeBuffer* serializeBuffer,\n    const ObjectIdProvider& provider) const {\n    RenderPassEncoderSetScissorRectTransfer* transfer;\n    WIRE_TRY(serializeBuffer->Next(&transfer));\n    transfer->commandSize = commandSize;\n    return (RenderPassEncoderSetScissorRectSerialize(*this, transfer, serializeBuffer, provider));\n}\nWireResult RenderPassEncoderSetScissorRectCmd::Serialize(size_t commandSize, SerializeBuffer* serializeBuffer) const {\n    ErrorObjectIdProvider provider;\n    return Serialize(commandSize, serializeBuffer, provider);\n}\n\nWireResult RenderPassEncoderSetScissorRectCmd::Deserialize(\n    DeserializeBuffer* deserializeBuffer,\n    DeserializeAllocator* allocator,\n    const ObjectIdResolver& resolver) {\n    const volatile RenderPassEncoderSetScissorRectTransfer* transfer;\n    WIRE_TRY(deserializeBuffer->Read(&transfer));\n    return RenderPassEncoderSetScissorRectDeserialize(this, transfer, deserializeBuffer, allocator, resolver);\n}\nWireResult RenderPassEncoderSetScissorRectCmd::Deserialize(DeserializeBuffer* deserializeBuffer, DeserializeAllocator* allocator) {\n    ErrorObjectIdResolver resolver;\n    return Deserialize(deserializeBuffer, allocator, resolver);\n}\n\nsize_t RenderPassEncoderSetStencilReferenceCmd::GetRequiredSize() const {\n    return WireAlignSizeof<RenderPassEncoderSetStencilReferenceTransfer>() + RenderPassEncoderSetStencilReferenceGetExtraRequiredSize(*this);\n}\n\nWireResult RenderPassEncoderSetStencilReferenceCmd::Serialize(\n    size_t commandSize,\n    SerializeBuffer* serializeBuffer,\n    const ObjectIdProvider& provider) const {\n    RenderPassEncoderSetStencilReferenceTransfer* transfer;\n    WIRE_TRY(serializeBuffer->Next(&transfer));\n    transfer->commandSize = commandSize;\n    return (RenderPassEncoderSetStencilReferenceSerialize(*this, transfer, serializeBuffer, provider));\n}\nWireResult RenderPassEncoderSetStencilReferenceCmd::Serialize(size_t commandSize, SerializeBuffer* serializeBuffer) const {\n    ErrorObjectIdProvider provider;\n    return Serialize(commandSize, serializeBuffer, provider);\n}\n\nWireResult RenderPassEncoderSetStencilReferenceCmd::Deserialize(\n    DeserializeBuffer* deserializeBuffer,\n    DeserializeAllocator* allocator,\n    const ObjectIdResolver& resolver) {\n    const volatile RenderPassEncoderSetStencilReferenceTransfer* transfer;\n    WIRE_TRY(deserializeBuffer->Read(&transfer));\n    return RenderPassEncoderSetStencilReferenceDeserialize(this, transfer, deserializeBuffer, allocator, resolver);\n}\nWireResult RenderPassEncoderSetStencilReferenceCmd::Deserialize(DeserializeBuffer* deserializeBuffer, DeserializeAllocator* allocator) {\n    ErrorObjectIdResolver resolver;\n    return Deserialize(deserializeBuffer, allocator, resolver);\n}\n\nsize_t RenderPassEncoderSetVertexBufferCmd::GetRequiredSize() const {\n    return WireAlignSizeof<RenderPassEncoderSetVertexBufferTransfer>() + RenderPassEncoderSetVertexBufferGetExtraRequiredSize(*this);\n}\n\nWireResult RenderPassEncoderSetVertexBufferCmd::Serialize(\n    size_t commandSize,\n    SerializeBuffer* serializeBuffer,\n    const ObjectIdProvider& provider) const {\n    RenderPassEncoderSetVertexBufferTransfer* transfer;\n    WIRE_TRY(serializeBuffer->Next(&transfer));\n    transfer->commandSize = commandSize;\n    return (RenderPassEncoderSetVertexBufferSerialize(*this, transfer, serializeBuffer, provider));\n}\nWireResult RenderPassEncoderSetVertexBufferCmd::Serialize(size_t commandSize, SerializeBuffer* serializeBuffer) const {\n    ErrorObjectIdProvider provider;\n    return Serialize(commandSize, serializeBuffer, provider);\n}\n\nWireResult RenderPassEncoderSetVertexBufferCmd::Deserialize(\n    DeserializeBuffer* deserializeBuffer,\n    DeserializeAllocator* allocator,\n    const ObjectIdResolver& resolver) {\n    const volatile RenderPassEncoderSetVertexBufferTransfer* transfer;\n    WIRE_TRY(deserializeBuffer->Read(&transfer));\n    return RenderPassEncoderSetVertexBufferDeserialize(this, transfer, deserializeBuffer, allocator, resolver);\n}\nWireResult RenderPassEncoderSetVertexBufferCmd::Deserialize(DeserializeBuffer* deserializeBuffer, DeserializeAllocator* allocator) {\n    ErrorObjectIdResolver resolver;\n    return Deserialize(deserializeBuffer, allocator, resolver);\n}\n\nsize_t RenderPassEncoderSetViewportCmd::GetRequiredSize() const {\n    return WireAlignSizeof<RenderPassEncoderSetViewportTransfer>() + RenderPassEncoderSetViewportGetExtraRequiredSize(*this);\n}\n\nWireResult RenderPassEncoderSetViewportCmd::Serialize(\n    size_t commandSize,\n    SerializeBuffer* serializeBuffer,\n    const ObjectIdProvider& provider) const {\n    RenderPassEncoderSetViewportTransfer* transfer;\n    WIRE_TRY(serializeBuffer->Next(&transfer));\n    transfer->commandSize = commandSize;\n    return (RenderPassEncoderSetViewportSerialize(*this, transfer, serializeBuffer, provider));\n}\nWireResult RenderPassEncoderSetViewportCmd::Serialize(size_t commandSize, SerializeBuffer* serializeBuffer) const {\n    ErrorObjectIdProvider provider;\n    return Serialize(commandSize, serializeBuffer, provider);\n}\n\nWireResult RenderPassEncoderSetViewportCmd::Deserialize(\n    DeserializeBuffer* deserializeBuffer,\n    DeserializeAllocator* allocator,\n    const ObjectIdResolver& resolver) {\n    const volatile RenderPassEncoderSetViewportTransfer* transfer;\n    WIRE_TRY(deserializeBuffer->Read(&transfer));\n    return RenderPassEncoderSetViewportDeserialize(this, transfer, deserializeBuffer, allocator, resolver);\n}\nWireResult RenderPassEncoderSetViewportCmd::Deserialize(DeserializeBuffer* deserializeBuffer, DeserializeAllocator* allocator) {\n    ErrorObjectIdResolver resolver;\n    return Deserialize(deserializeBuffer, allocator, resolver);\n}\n\nsize_t RenderPassEncoderWriteTimestampCmd::GetRequiredSize() const {\n    return WireAlignSizeof<RenderPassEncoderWriteTimestampTransfer>() + RenderPassEncoderWriteTimestampGetExtraRequiredSize(*this);\n}\n\nWireResult RenderPassEncoderWriteTimestampCmd::Serialize(\n    size_t commandSize,\n    SerializeBuffer* serializeBuffer,\n    const ObjectIdProvider& provider) const {\n    RenderPassEncoderWriteTimestampTransfer* transfer;\n    WIRE_TRY(serializeBuffer->Next(&transfer));\n    transfer->commandSize = commandSize;\n    return (RenderPassEncoderWriteTimestampSerialize(*this, transfer, serializeBuffer, provider));\n}\nWireResult RenderPassEncoderWriteTimestampCmd::Serialize(size_t commandSize, SerializeBuffer* serializeBuffer) const {\n    ErrorObjectIdProvider provider;\n    return Serialize(commandSize, serializeBuffer, provider);\n}\n\nWireResult RenderPassEncoderWriteTimestampCmd::Deserialize(\n    DeserializeBuffer* deserializeBuffer,\n    DeserializeAllocator* allocator,\n    const ObjectIdResolver& resolver) {\n    const volatile RenderPassEncoderWriteTimestampTransfer* transfer;\n    WIRE_TRY(deserializeBuffer->Read(&transfer));\n    return RenderPassEncoderWriteTimestampDeserialize(this, transfer, deserializeBuffer, allocator, resolver);\n}\nWireResult RenderPassEncoderWriteTimestampCmd::Deserialize(DeserializeBuffer* deserializeBuffer, DeserializeAllocator* allocator) {\n    ErrorObjectIdResolver resolver;\n    return Deserialize(deserializeBuffer, allocator, resolver);\n}\n\nsize_t RenderPipelineGetBindGroupLayoutCmd::GetRequiredSize() const {\n    return WireAlignSizeof<RenderPipelineGetBindGroupLayoutTransfer>() + RenderPipelineGetBindGroupLayoutGetExtraRequiredSize(*this);\n}\n\nWireResult RenderPipelineGetBindGroupLayoutCmd::Serialize(\n    size_t commandSize,\n    SerializeBuffer* serializeBuffer,\n    const ObjectIdProvider& provider) const {\n    RenderPipelineGetBindGroupLayoutTransfer* transfer;\n    WIRE_TRY(serializeBuffer->Next(&transfer));\n    transfer->commandSize = commandSize;\n    return (RenderPipelineGetBindGroupLayoutSerialize(*this, transfer, serializeBuffer, provider));\n}\nWireResult RenderPipelineGetBindGroupLayoutCmd::Serialize(size_t commandSize, SerializeBuffer* serializeBuffer) const {\n    ErrorObjectIdProvider provider;\n    return Serialize(commandSize, serializeBuffer, provider);\n}\n\nWireResult RenderPipelineGetBindGroupLayoutCmd::Deserialize(\n    DeserializeBuffer* deserializeBuffer,\n    DeserializeAllocator* allocator,\n    const ObjectIdResolver& resolver) {\n    const volatile RenderPipelineGetBindGroupLayoutTransfer* transfer;\n    WIRE_TRY(deserializeBuffer->Read(&transfer));\n    return RenderPipelineGetBindGroupLayoutDeserialize(this, transfer, deserializeBuffer, allocator, resolver);\n}\nWireResult RenderPipelineGetBindGroupLayoutCmd::Deserialize(DeserializeBuffer* deserializeBuffer, DeserializeAllocator* allocator) {\n    ErrorObjectIdResolver resolver;\n    return Deserialize(deserializeBuffer, allocator, resolver);\n}\n\nsize_t RenderPipelineSetLabelCmd::GetRequiredSize() const {\n    return WireAlignSizeof<RenderPipelineSetLabelTransfer>() + RenderPipelineSetLabelGetExtraRequiredSize(*this);\n}\n\nWireResult RenderPipelineSetLabelCmd::Serialize(\n    size_t commandSize,\n    SerializeBuffer* serializeBuffer,\n    const ObjectIdProvider& provider) const {\n    RenderPipelineSetLabelTransfer* transfer;\n    WIRE_TRY(serializeBuffer->Next(&transfer));\n    transfer->commandSize = commandSize;\n    return (RenderPipelineSetLabelSerialize(*this, transfer, serializeBuffer, provider));\n}\nWireResult RenderPipelineSetLabelCmd::Serialize(size_t commandSize, SerializeBuffer* serializeBuffer) const {\n    ErrorObjectIdProvider provider;\n    return Serialize(commandSize, serializeBuffer, provider);\n}\n\nWireResult RenderPipelineSetLabelCmd::Deserialize(\n    DeserializeBuffer* deserializeBuffer,\n    DeserializeAllocator* allocator,\n    const ObjectIdResolver& resolver) {\n    const volatile RenderPipelineSetLabelTransfer* transfer;\n    WIRE_TRY(deserializeBuffer->Read(&transfer));\n    return RenderPipelineSetLabelDeserialize(this, transfer, deserializeBuffer, allocator, resolver);\n}\nWireResult RenderPipelineSetLabelCmd::Deserialize(DeserializeBuffer* deserializeBuffer, DeserializeAllocator* allocator) {\n    ErrorObjectIdResolver resolver;\n    return Deserialize(deserializeBuffer, allocator, resolver);\n}\n\nsize_t SamplerSetLabelCmd::GetRequiredSize() const {\n    return WireAlignSizeof<SamplerSetLabelTransfer>() + SamplerSetLabelGetExtraRequiredSize(*this);\n}\n\nWireResult SamplerSetLabelCmd::Serialize(\n    size_t commandSize,\n    SerializeBuffer* serializeBuffer,\n    const ObjectIdProvider& provider) const {\n    SamplerSetLabelTransfer* transfer;\n    WIRE_TRY(serializeBuffer->Next(&transfer));\n    transfer->commandSize = commandSize;\n    return (SamplerSetLabelSerialize(*this, transfer, serializeBuffer, provider));\n}\nWireResult SamplerSetLabelCmd::Serialize(size_t commandSize, SerializeBuffer* serializeBuffer) const {\n    ErrorObjectIdProvider provider;\n    return Serialize(commandSize, serializeBuffer, provider);\n}\n\nWireResult SamplerSetLabelCmd::Deserialize(\n    DeserializeBuffer* deserializeBuffer,\n    DeserializeAllocator* allocator,\n    const ObjectIdResolver& resolver) {\n    const volatile SamplerSetLabelTransfer* transfer;\n    WIRE_TRY(deserializeBuffer->Read(&transfer));\n    return SamplerSetLabelDeserialize(this, transfer, deserializeBuffer, allocator, resolver);\n}\nWireResult SamplerSetLabelCmd::Deserialize(DeserializeBuffer* deserializeBuffer, DeserializeAllocator* allocator) {\n    ErrorObjectIdResolver resolver;\n    return Deserialize(deserializeBuffer, allocator, resolver);\n}\n\nsize_t ShaderModuleGetCompilationInfoCmd::GetRequiredSize() const {\n    return WireAlignSizeof<ShaderModuleGetCompilationInfoTransfer>() + ShaderModuleGetCompilationInfoGetExtraRequiredSize(*this);\n}\n\nWireResult ShaderModuleGetCompilationInfoCmd::Serialize(size_t commandSize, SerializeBuffer* serializeBuffer) const {\n    ShaderModuleGetCompilationInfoTransfer* transfer;\n    WIRE_TRY(serializeBuffer->Next(&transfer));\n    transfer->commandSize = commandSize;\n    return (ShaderModuleGetCompilationInfoSerialize(*this, transfer, serializeBuffer));\n}\nWireResult ShaderModuleGetCompilationInfoCmd::Serialize(\n    size_t commandSize,\n    SerializeBuffer* serializeBuffer,\n    const ObjectIdProvider&) const {\n    return Serialize(commandSize, serializeBuffer);\n}\n\nWireResult ShaderModuleGetCompilationInfoCmd::Deserialize(DeserializeBuffer* deserializeBuffer, DeserializeAllocator* allocator) {\n    const volatile ShaderModuleGetCompilationInfoTransfer* transfer;\n    WIRE_TRY(deserializeBuffer->Read(&transfer));\n    return ShaderModuleGetCompilationInfoDeserialize(this, transfer, deserializeBuffer, allocator);\n}\nWireResult ShaderModuleGetCompilationInfoCmd::Deserialize(\n    DeserializeBuffer* deserializeBuffer,\n    DeserializeAllocator* allocator,\n    const ObjectIdResolver&) {\n    return Deserialize(deserializeBuffer, allocator);\n}\n\nsize_t ShaderModuleSetLabelCmd::GetRequiredSize() const {\n    return WireAlignSizeof<ShaderModuleSetLabelTransfer>() + ShaderModuleSetLabelGetExtraRequiredSize(*this);\n}\n\nWireResult ShaderModuleSetLabelCmd::Serialize(\n    size_t commandSize,\n    SerializeBuffer* serializeBuffer,\n    const ObjectIdProvider& provider) const {\n    ShaderModuleSetLabelTransfer* transfer;\n    WIRE_TRY(serializeBuffer->Next(&transfer));\n    transfer->commandSize = commandSize;\n    return (ShaderModuleSetLabelSerialize(*this, transfer, serializeBuffer, provider));\n}\nWireResult ShaderModuleSetLabelCmd::Serialize(size_t commandSize, SerializeBuffer* serializeBuffer) const {\n    ErrorObjectIdProvider provider;\n    return Serialize(commandSize, serializeBuffer, provider);\n}\n\nWireResult ShaderModuleSetLabelCmd::Deserialize(\n    DeserializeBuffer* deserializeBuffer,\n    DeserializeAllocator* allocator,\n    const ObjectIdResolver& resolver) {\n    const volatile ShaderModuleSetLabelTransfer* transfer;\n    WIRE_TRY(deserializeBuffer->Read(&transfer));\n    return ShaderModuleSetLabelDeserialize(this, transfer, deserializeBuffer, allocator, resolver);\n}\nWireResult ShaderModuleSetLabelCmd::Deserialize(DeserializeBuffer* deserializeBuffer, DeserializeAllocator* allocator) {\n    ErrorObjectIdResolver resolver;\n    return Deserialize(deserializeBuffer, allocator, resolver);\n}\n\nsize_t SwapChainGetCurrentTextureCmd::GetRequiredSize() const {\n    return WireAlignSizeof<SwapChainGetCurrentTextureTransfer>() + SwapChainGetCurrentTextureGetExtraRequiredSize(*this);\n}\n\nWireResult SwapChainGetCurrentTextureCmd::Serialize(\n    size_t commandSize,\n    SerializeBuffer* serializeBuffer,\n    const ObjectIdProvider& provider) const {\n    SwapChainGetCurrentTextureTransfer* transfer;\n    WIRE_TRY(serializeBuffer->Next(&transfer));\n    transfer->commandSize = commandSize;\n    return (SwapChainGetCurrentTextureSerialize(*this, transfer, serializeBuffer, provider));\n}\nWireResult SwapChainGetCurrentTextureCmd::Serialize(size_t commandSize, SerializeBuffer* serializeBuffer) const {\n    ErrorObjectIdProvider provider;\n    return Serialize(commandSize, serializeBuffer, provider);\n}\n\nWireResult SwapChainGetCurrentTextureCmd::Deserialize(\n    DeserializeBuffer* deserializeBuffer,\n    DeserializeAllocator* allocator,\n    const ObjectIdResolver& resolver) {\n    const volatile SwapChainGetCurrentTextureTransfer* transfer;\n    WIRE_TRY(deserializeBuffer->Read(&transfer));\n    return SwapChainGetCurrentTextureDeserialize(this, transfer, deserializeBuffer, allocator, resolver);\n}\nWireResult SwapChainGetCurrentTextureCmd::Deserialize(DeserializeBuffer* deserializeBuffer, DeserializeAllocator* allocator) {\n    ErrorObjectIdResolver resolver;\n    return Deserialize(deserializeBuffer, allocator, resolver);\n}\n\nsize_t SwapChainGetCurrentTextureViewCmd::GetRequiredSize() const {\n    return WireAlignSizeof<SwapChainGetCurrentTextureViewTransfer>() + SwapChainGetCurrentTextureViewGetExtraRequiredSize(*this);\n}\n\nWireResult SwapChainGetCurrentTextureViewCmd::Serialize(\n    size_t commandSize,\n    SerializeBuffer* serializeBuffer,\n    const ObjectIdProvider& provider) const {\n    SwapChainGetCurrentTextureViewTransfer* transfer;\n    WIRE_TRY(serializeBuffer->Next(&transfer));\n    transfer->commandSize = commandSize;\n    return (SwapChainGetCurrentTextureViewSerialize(*this, transfer, serializeBuffer, provider));\n}\nWireResult SwapChainGetCurrentTextureViewCmd::Serialize(size_t commandSize, SerializeBuffer* serializeBuffer) const {\n    ErrorObjectIdProvider provider;\n    return Serialize(commandSize, serializeBuffer, provider);\n}\n\nWireResult SwapChainGetCurrentTextureViewCmd::Deserialize(\n    DeserializeBuffer* deserializeBuffer,\n    DeserializeAllocator* allocator,\n    const ObjectIdResolver& resolver) {\n    const volatile SwapChainGetCurrentTextureViewTransfer* transfer;\n    WIRE_TRY(deserializeBuffer->Read(&transfer));\n    return SwapChainGetCurrentTextureViewDeserialize(this, transfer, deserializeBuffer, allocator, resolver);\n}\nWireResult SwapChainGetCurrentTextureViewCmd::Deserialize(DeserializeBuffer* deserializeBuffer, DeserializeAllocator* allocator) {\n    ErrorObjectIdResolver resolver;\n    return Deserialize(deserializeBuffer, allocator, resolver);\n}\n\nsize_t SwapChainPresentCmd::GetRequiredSize() const {\n    return WireAlignSizeof<SwapChainPresentTransfer>() + SwapChainPresentGetExtraRequiredSize(*this);\n}\n\nWireResult SwapChainPresentCmd::Serialize(\n    size_t commandSize,\n    SerializeBuffer* serializeBuffer,\n    const ObjectIdProvider& provider) const {\n    SwapChainPresentTransfer* transfer;\n    WIRE_TRY(serializeBuffer->Next(&transfer));\n    transfer->commandSize = commandSize;\n    return (SwapChainPresentSerialize(*this, transfer, serializeBuffer, provider));\n}\nWireResult SwapChainPresentCmd::Serialize(size_t commandSize, SerializeBuffer* serializeBuffer) const {\n    ErrorObjectIdProvider provider;\n    return Serialize(commandSize, serializeBuffer, provider);\n}\n\nWireResult SwapChainPresentCmd::Deserialize(\n    DeserializeBuffer* deserializeBuffer,\n    DeserializeAllocator* allocator,\n    const ObjectIdResolver& resolver) {\n    const volatile SwapChainPresentTransfer* transfer;\n    WIRE_TRY(deserializeBuffer->Read(&transfer));\n    return SwapChainPresentDeserialize(this, transfer, deserializeBuffer, allocator, resolver);\n}\nWireResult SwapChainPresentCmd::Deserialize(DeserializeBuffer* deserializeBuffer, DeserializeAllocator* allocator) {\n    ErrorObjectIdResolver resolver;\n    return Deserialize(deserializeBuffer, allocator, resolver);\n}\n\nsize_t TextureCreateViewCmd::GetRequiredSize() const {\n    return WireAlignSizeof<TextureCreateViewTransfer>() + TextureCreateViewGetExtraRequiredSize(*this);\n}\n\nWireResult TextureCreateViewCmd::Serialize(\n    size_t commandSize,\n    SerializeBuffer* serializeBuffer,\n    const ObjectIdProvider& provider) const {\n    TextureCreateViewTransfer* transfer;\n    WIRE_TRY(serializeBuffer->Next(&transfer));\n    transfer->commandSize = commandSize;\n    return (TextureCreateViewSerialize(*this, transfer, serializeBuffer, provider));\n}\nWireResult TextureCreateViewCmd::Serialize(size_t commandSize, SerializeBuffer* serializeBuffer) const {\n    ErrorObjectIdProvider provider;\n    return Serialize(commandSize, serializeBuffer, provider);\n}\n\nWireResult TextureCreateViewCmd::Deserialize(\n    DeserializeBuffer* deserializeBuffer,\n    DeserializeAllocator* allocator,\n    const ObjectIdResolver& resolver) {\n    const volatile TextureCreateViewTransfer* transfer;\n    WIRE_TRY(deserializeBuffer->Read(&transfer));\n    return TextureCreateViewDeserialize(this, transfer, deserializeBuffer, allocator, resolver);\n}\nWireResult TextureCreateViewCmd::Deserialize(DeserializeBuffer* deserializeBuffer, DeserializeAllocator* allocator) {\n    ErrorObjectIdResolver resolver;\n    return Deserialize(deserializeBuffer, allocator, resolver);\n}\n\nsize_t TextureDestroyCmd::GetRequiredSize() const {\n    return WireAlignSizeof<TextureDestroyTransfer>() + TextureDestroyGetExtraRequiredSize(*this);\n}\n\nWireResult TextureDestroyCmd::Serialize(\n    size_t commandSize,\n    SerializeBuffer* serializeBuffer,\n    const ObjectIdProvider& provider) const {\n    TextureDestroyTransfer* transfer;\n    WIRE_TRY(serializeBuffer->Next(&transfer));\n    transfer->commandSize = commandSize;\n    return (TextureDestroySerialize(*this, transfer, serializeBuffer, provider));\n}\nWireResult TextureDestroyCmd::Serialize(size_t commandSize, SerializeBuffer* serializeBuffer) const {\n    ErrorObjectIdProvider provider;\n    return Serialize(commandSize, serializeBuffer, provider);\n}\n\nWireResult TextureDestroyCmd::Deserialize(\n    DeserializeBuffer* deserializeBuffer,\n    DeserializeAllocator* allocator,\n    const ObjectIdResolver& resolver) {\n    const volatile TextureDestroyTransfer* transfer;\n    WIRE_TRY(deserializeBuffer->Read(&transfer));\n    return TextureDestroyDeserialize(this, transfer, deserializeBuffer, allocator, resolver);\n}\nWireResult TextureDestroyCmd::Deserialize(DeserializeBuffer* deserializeBuffer, DeserializeAllocator* allocator) {\n    ErrorObjectIdResolver resolver;\n    return Deserialize(deserializeBuffer, allocator, resolver);\n}\n\nsize_t TextureSetLabelCmd::GetRequiredSize() const {\n    return WireAlignSizeof<TextureSetLabelTransfer>() + TextureSetLabelGetExtraRequiredSize(*this);\n}\n\nWireResult TextureSetLabelCmd::Serialize(\n    size_t commandSize,\n    SerializeBuffer* serializeBuffer,\n    const ObjectIdProvider& provider) const {\n    TextureSetLabelTransfer* transfer;\n    WIRE_TRY(serializeBuffer->Next(&transfer));\n    transfer->commandSize = commandSize;\n    return (TextureSetLabelSerialize(*this, transfer, serializeBuffer, provider));\n}\nWireResult TextureSetLabelCmd::Serialize(size_t commandSize, SerializeBuffer* serializeBuffer) const {\n    ErrorObjectIdProvider provider;\n    return Serialize(commandSize, serializeBuffer, provider);\n}\n\nWireResult TextureSetLabelCmd::Deserialize(\n    DeserializeBuffer* deserializeBuffer,\n    DeserializeAllocator* allocator,\n    const ObjectIdResolver& resolver) {\n    const volatile TextureSetLabelTransfer* transfer;\n    WIRE_TRY(deserializeBuffer->Read(&transfer));\n    return TextureSetLabelDeserialize(this, transfer, deserializeBuffer, allocator, resolver);\n}\nWireResult TextureSetLabelCmd::Deserialize(DeserializeBuffer* deserializeBuffer, DeserializeAllocator* allocator) {\n    ErrorObjectIdResolver resolver;\n    return Deserialize(deserializeBuffer, allocator, resolver);\n}\n\nsize_t TextureViewSetLabelCmd::GetRequiredSize() const {\n    return WireAlignSizeof<TextureViewSetLabelTransfer>() + TextureViewSetLabelGetExtraRequiredSize(*this);\n}\n\nWireResult TextureViewSetLabelCmd::Serialize(\n    size_t commandSize,\n    SerializeBuffer* serializeBuffer,\n    const ObjectIdProvider& provider) const {\n    TextureViewSetLabelTransfer* transfer;\n    WIRE_TRY(serializeBuffer->Next(&transfer));\n    transfer->commandSize = commandSize;\n    return (TextureViewSetLabelSerialize(*this, transfer, serializeBuffer, provider));\n}\nWireResult TextureViewSetLabelCmd::Serialize(size_t commandSize, SerializeBuffer* serializeBuffer) const {\n    ErrorObjectIdProvider provider;\n    return Serialize(commandSize, serializeBuffer, provider);\n}\n\nWireResult TextureViewSetLabelCmd::Deserialize(\n    DeserializeBuffer* deserializeBuffer,\n    DeserializeAllocator* allocator,\n    const ObjectIdResolver& resolver) {\n    const volatile TextureViewSetLabelTransfer* transfer;\n    WIRE_TRY(deserializeBuffer->Read(&transfer));\n    return TextureViewSetLabelDeserialize(this, transfer, deserializeBuffer, allocator, resolver);\n}\nWireResult TextureViewSetLabelCmd::Deserialize(DeserializeBuffer* deserializeBuffer, DeserializeAllocator* allocator) {\n    ErrorObjectIdResolver resolver;\n    return Deserialize(deserializeBuffer, allocator, resolver);\n}\n\n\nsize_t ReturnAdapterRequestDeviceCallbackCmd::GetRequiredSize() const {\n    return WireAlignSizeof<ReturnAdapterRequestDeviceCallbackTransfer>() + ReturnAdapterRequestDeviceCallbackGetExtraRequiredSize(*this);\n}\n\nWireResult ReturnAdapterRequestDeviceCallbackCmd::Serialize(\n    size_t commandSize,\n    SerializeBuffer* serializeBuffer,\n    const ObjectIdProvider& provider) const {\n    ReturnAdapterRequestDeviceCallbackTransfer* transfer;\n    WIRE_TRY(serializeBuffer->Next(&transfer));\n    transfer->commandSize = commandSize;\n    return (ReturnAdapterRequestDeviceCallbackSerialize(*this, transfer, serializeBuffer, provider));\n}\nWireResult ReturnAdapterRequestDeviceCallbackCmd::Serialize(size_t commandSize, SerializeBuffer* serializeBuffer) const {\n    ErrorObjectIdProvider provider;\n    return Serialize(commandSize, serializeBuffer, provider);\n}\n\nWireResult ReturnAdapterRequestDeviceCallbackCmd::Deserialize(\n    DeserializeBuffer* deserializeBuffer,\n    DeserializeAllocator* allocator,\n    const ObjectIdResolver& resolver) {\n    const volatile ReturnAdapterRequestDeviceCallbackTransfer* transfer;\n    WIRE_TRY(deserializeBuffer->Read(&transfer));\n    return ReturnAdapterRequestDeviceCallbackDeserialize(this, transfer, deserializeBuffer, allocator, resolver);\n}\nWireResult ReturnAdapterRequestDeviceCallbackCmd::Deserialize(DeserializeBuffer* deserializeBuffer, DeserializeAllocator* allocator) {\n    ErrorObjectIdResolver resolver;\n    return Deserialize(deserializeBuffer, allocator, resolver);\n}\n\nsize_t ReturnBufferMapAsyncCallbackCmd::GetRequiredSize() const {\n    return WireAlignSizeof<ReturnBufferMapAsyncCallbackTransfer>() + ReturnBufferMapAsyncCallbackGetExtraRequiredSize(*this);\n}\n\nWireResult ReturnBufferMapAsyncCallbackCmd::Serialize(size_t commandSize, SerializeBuffer* serializeBuffer) const {\n    ReturnBufferMapAsyncCallbackTransfer* transfer;\n    WIRE_TRY(serializeBuffer->Next(&transfer));\n    transfer->commandSize = commandSize;\n    return (ReturnBufferMapAsyncCallbackSerialize(*this, transfer, serializeBuffer));\n}\nWireResult ReturnBufferMapAsyncCallbackCmd::Serialize(\n    size_t commandSize,\n    SerializeBuffer* serializeBuffer,\n    const ObjectIdProvider&) const {\n    return Serialize(commandSize, serializeBuffer);\n}\n\nWireResult ReturnBufferMapAsyncCallbackCmd::Deserialize(DeserializeBuffer* deserializeBuffer, DeserializeAllocator* allocator) {\n    const volatile ReturnBufferMapAsyncCallbackTransfer* transfer;\n    WIRE_TRY(deserializeBuffer->Read(&transfer));\n    return ReturnBufferMapAsyncCallbackDeserialize(this, transfer, deserializeBuffer, allocator);\n}\nWireResult ReturnBufferMapAsyncCallbackCmd::Deserialize(\n    DeserializeBuffer* deserializeBuffer,\n    DeserializeAllocator* allocator,\n    const ObjectIdResolver&) {\n    return Deserialize(deserializeBuffer, allocator);\n}\n\nsize_t ReturnDeviceCreateComputePipelineAsyncCallbackCmd::GetRequiredSize() const {\n    return WireAlignSizeof<ReturnDeviceCreateComputePipelineAsyncCallbackTransfer>() + ReturnDeviceCreateComputePipelineAsyncCallbackGetExtraRequiredSize(*this);\n}\n\nWireResult ReturnDeviceCreateComputePipelineAsyncCallbackCmd::Serialize(size_t commandSize, SerializeBuffer* serializeBuffer) const {\n    ReturnDeviceCreateComputePipelineAsyncCallbackTransfer* transfer;\n    WIRE_TRY(serializeBuffer->Next(&transfer));\n    transfer->commandSize = commandSize;\n    return (ReturnDeviceCreateComputePipelineAsyncCallbackSerialize(*this, transfer, serializeBuffer));\n}\nWireResult ReturnDeviceCreateComputePipelineAsyncCallbackCmd::Serialize(\n    size_t commandSize,\n    SerializeBuffer* serializeBuffer,\n    const ObjectIdProvider&) const {\n    return Serialize(commandSize, serializeBuffer);\n}\n\nWireResult ReturnDeviceCreateComputePipelineAsyncCallbackCmd::Deserialize(DeserializeBuffer* deserializeBuffer, DeserializeAllocator* allocator) {\n    const volatile ReturnDeviceCreateComputePipelineAsyncCallbackTransfer* transfer;\n    WIRE_TRY(deserializeBuffer->Read(&transfer));\n    return ReturnDeviceCreateComputePipelineAsyncCallbackDeserialize(this, transfer, deserializeBuffer, allocator);\n}\nWireResult ReturnDeviceCreateComputePipelineAsyncCallbackCmd::Deserialize(\n    DeserializeBuffer* deserializeBuffer,\n    DeserializeAllocator* allocator,\n    const ObjectIdResolver&) {\n    return Deserialize(deserializeBuffer, allocator);\n}\n\nsize_t ReturnDeviceCreateRenderPipelineAsyncCallbackCmd::GetRequiredSize() const {\n    return WireAlignSizeof<ReturnDeviceCreateRenderPipelineAsyncCallbackTransfer>() + ReturnDeviceCreateRenderPipelineAsyncCallbackGetExtraRequiredSize(*this);\n}\n\nWireResult ReturnDeviceCreateRenderPipelineAsyncCallbackCmd::Serialize(size_t commandSize, SerializeBuffer* serializeBuffer) const {\n    ReturnDeviceCreateRenderPipelineAsyncCallbackTransfer* transfer;\n    WIRE_TRY(serializeBuffer->Next(&transfer));\n    transfer->commandSize = commandSize;\n    return (ReturnDeviceCreateRenderPipelineAsyncCallbackSerialize(*this, transfer, serializeBuffer));\n}\nWireResult ReturnDeviceCreateRenderPipelineAsyncCallbackCmd::Serialize(\n    size_t commandSize,\n    SerializeBuffer* serializeBuffer,\n    const ObjectIdProvider&) const {\n    return Serialize(commandSize, serializeBuffer);\n}\n\nWireResult ReturnDeviceCreateRenderPipelineAsyncCallbackCmd::Deserialize(DeserializeBuffer* deserializeBuffer, DeserializeAllocator* allocator) {\n    const volatile ReturnDeviceCreateRenderPipelineAsyncCallbackTransfer* transfer;\n    WIRE_TRY(deserializeBuffer->Read(&transfer));\n    return ReturnDeviceCreateRenderPipelineAsyncCallbackDeserialize(this, transfer, deserializeBuffer, allocator);\n}\nWireResult ReturnDeviceCreateRenderPipelineAsyncCallbackCmd::Deserialize(\n    DeserializeBuffer* deserializeBuffer,\n    DeserializeAllocator* allocator,\n    const ObjectIdResolver&) {\n    return Deserialize(deserializeBuffer, allocator);\n}\n\nsize_t ReturnDeviceLoggingCallbackCmd::GetRequiredSize() const {\n    return WireAlignSizeof<ReturnDeviceLoggingCallbackTransfer>() + ReturnDeviceLoggingCallbackGetExtraRequiredSize(*this);\n}\n\nWireResult ReturnDeviceLoggingCallbackCmd::Serialize(size_t commandSize, SerializeBuffer* serializeBuffer) const {\n    ReturnDeviceLoggingCallbackTransfer* transfer;\n    WIRE_TRY(serializeBuffer->Next(&transfer));\n    transfer->commandSize = commandSize;\n    return (ReturnDeviceLoggingCallbackSerialize(*this, transfer, serializeBuffer));\n}\nWireResult ReturnDeviceLoggingCallbackCmd::Serialize(\n    size_t commandSize,\n    SerializeBuffer* serializeBuffer,\n    const ObjectIdProvider&) const {\n    return Serialize(commandSize, serializeBuffer);\n}\n\nWireResult ReturnDeviceLoggingCallbackCmd::Deserialize(DeserializeBuffer* deserializeBuffer, DeserializeAllocator* allocator) {\n    const volatile ReturnDeviceLoggingCallbackTransfer* transfer;\n    WIRE_TRY(deserializeBuffer->Read(&transfer));\n    return ReturnDeviceLoggingCallbackDeserialize(this, transfer, deserializeBuffer, allocator);\n}\nWireResult ReturnDeviceLoggingCallbackCmd::Deserialize(\n    DeserializeBuffer* deserializeBuffer,\n    DeserializeAllocator* allocator,\n    const ObjectIdResolver&) {\n    return Deserialize(deserializeBuffer, allocator);\n}\n\nsize_t ReturnDeviceLostCallbackCmd::GetRequiredSize() const {\n    return WireAlignSizeof<ReturnDeviceLostCallbackTransfer>() + ReturnDeviceLostCallbackGetExtraRequiredSize(*this);\n}\n\nWireResult ReturnDeviceLostCallbackCmd::Serialize(size_t commandSize, SerializeBuffer* serializeBuffer) const {\n    ReturnDeviceLostCallbackTransfer* transfer;\n    WIRE_TRY(serializeBuffer->Next(&transfer));\n    transfer->commandSize = commandSize;\n    return (ReturnDeviceLostCallbackSerialize(*this, transfer, serializeBuffer));\n}\nWireResult ReturnDeviceLostCallbackCmd::Serialize(\n    size_t commandSize,\n    SerializeBuffer* serializeBuffer,\n    const ObjectIdProvider&) const {\n    return Serialize(commandSize, serializeBuffer);\n}\n\nWireResult ReturnDeviceLostCallbackCmd::Deserialize(DeserializeBuffer* deserializeBuffer, DeserializeAllocator* allocator) {\n    const volatile ReturnDeviceLostCallbackTransfer* transfer;\n    WIRE_TRY(deserializeBuffer->Read(&transfer));\n    return ReturnDeviceLostCallbackDeserialize(this, transfer, deserializeBuffer, allocator);\n}\nWireResult ReturnDeviceLostCallbackCmd::Deserialize(\n    DeserializeBuffer* deserializeBuffer,\n    DeserializeAllocator* allocator,\n    const ObjectIdResolver&) {\n    return Deserialize(deserializeBuffer, allocator);\n}\n\nsize_t ReturnDevicePopErrorScopeCallbackCmd::GetRequiredSize() const {\n    return WireAlignSizeof<ReturnDevicePopErrorScopeCallbackTransfer>() + ReturnDevicePopErrorScopeCallbackGetExtraRequiredSize(*this);\n}\n\nWireResult ReturnDevicePopErrorScopeCallbackCmd::Serialize(size_t commandSize, SerializeBuffer* serializeBuffer) const {\n    ReturnDevicePopErrorScopeCallbackTransfer* transfer;\n    WIRE_TRY(serializeBuffer->Next(&transfer));\n    transfer->commandSize = commandSize;\n    return (ReturnDevicePopErrorScopeCallbackSerialize(*this, transfer, serializeBuffer));\n}\nWireResult ReturnDevicePopErrorScopeCallbackCmd::Serialize(\n    size_t commandSize,\n    SerializeBuffer* serializeBuffer,\n    const ObjectIdProvider&) const {\n    return Serialize(commandSize, serializeBuffer);\n}\n\nWireResult ReturnDevicePopErrorScopeCallbackCmd::Deserialize(DeserializeBuffer* deserializeBuffer, DeserializeAllocator* allocator) {\n    const volatile ReturnDevicePopErrorScopeCallbackTransfer* transfer;\n    WIRE_TRY(deserializeBuffer->Read(&transfer));\n    return ReturnDevicePopErrorScopeCallbackDeserialize(this, transfer, deserializeBuffer, allocator);\n}\nWireResult ReturnDevicePopErrorScopeCallbackCmd::Deserialize(\n    DeserializeBuffer* deserializeBuffer,\n    DeserializeAllocator* allocator,\n    const ObjectIdResolver&) {\n    return Deserialize(deserializeBuffer, allocator);\n}\n\nsize_t ReturnDeviceUncapturedErrorCallbackCmd::GetRequiredSize() const {\n    return WireAlignSizeof<ReturnDeviceUncapturedErrorCallbackTransfer>() + ReturnDeviceUncapturedErrorCallbackGetExtraRequiredSize(*this);\n}\n\nWireResult ReturnDeviceUncapturedErrorCallbackCmd::Serialize(size_t commandSize, SerializeBuffer* serializeBuffer) const {\n    ReturnDeviceUncapturedErrorCallbackTransfer* transfer;\n    WIRE_TRY(serializeBuffer->Next(&transfer));\n    transfer->commandSize = commandSize;\n    return (ReturnDeviceUncapturedErrorCallbackSerialize(*this, transfer, serializeBuffer));\n}\nWireResult ReturnDeviceUncapturedErrorCallbackCmd::Serialize(\n    size_t commandSize,\n    SerializeBuffer* serializeBuffer,\n    const ObjectIdProvider&) const {\n    return Serialize(commandSize, serializeBuffer);\n}\n\nWireResult ReturnDeviceUncapturedErrorCallbackCmd::Deserialize(DeserializeBuffer* deserializeBuffer, DeserializeAllocator* allocator) {\n    const volatile ReturnDeviceUncapturedErrorCallbackTransfer* transfer;\n    WIRE_TRY(deserializeBuffer->Read(&transfer));\n    return ReturnDeviceUncapturedErrorCallbackDeserialize(this, transfer, deserializeBuffer, allocator);\n}\nWireResult ReturnDeviceUncapturedErrorCallbackCmd::Deserialize(\n    DeserializeBuffer* deserializeBuffer,\n    DeserializeAllocator* allocator,\n    const ObjectIdResolver&) {\n    return Deserialize(deserializeBuffer, allocator);\n}\n\nsize_t ReturnInstanceRequestAdapterCallbackCmd::GetRequiredSize() const {\n    return WireAlignSizeof<ReturnInstanceRequestAdapterCallbackTransfer>() + ReturnInstanceRequestAdapterCallbackGetExtraRequiredSize(*this);\n}\n\nWireResult ReturnInstanceRequestAdapterCallbackCmd::Serialize(\n    size_t commandSize,\n    SerializeBuffer* serializeBuffer,\n    const ObjectIdProvider& provider) const {\n    ReturnInstanceRequestAdapterCallbackTransfer* transfer;\n    WIRE_TRY(serializeBuffer->Next(&transfer));\n    transfer->commandSize = commandSize;\n    return (ReturnInstanceRequestAdapterCallbackSerialize(*this, transfer, serializeBuffer, provider));\n}\nWireResult ReturnInstanceRequestAdapterCallbackCmd::Serialize(size_t commandSize, SerializeBuffer* serializeBuffer) const {\n    ErrorObjectIdProvider provider;\n    return Serialize(commandSize, serializeBuffer, provider);\n}\n\nWireResult ReturnInstanceRequestAdapterCallbackCmd::Deserialize(\n    DeserializeBuffer* deserializeBuffer,\n    DeserializeAllocator* allocator,\n    const ObjectIdResolver& resolver) {\n    const volatile ReturnInstanceRequestAdapterCallbackTransfer* transfer;\n    WIRE_TRY(deserializeBuffer->Read(&transfer));\n    return ReturnInstanceRequestAdapterCallbackDeserialize(this, transfer, deserializeBuffer, allocator, resolver);\n}\nWireResult ReturnInstanceRequestAdapterCallbackCmd::Deserialize(DeserializeBuffer* deserializeBuffer, DeserializeAllocator* allocator) {\n    ErrorObjectIdResolver resolver;\n    return Deserialize(deserializeBuffer, allocator, resolver);\n}\n\nsize_t ReturnQueueWorkDoneCallbackCmd::GetRequiredSize() const {\n    return WireAlignSizeof<ReturnQueueWorkDoneCallbackTransfer>() + ReturnQueueWorkDoneCallbackGetExtraRequiredSize(*this);\n}\n\nWireResult ReturnQueueWorkDoneCallbackCmd::Serialize(size_t commandSize, SerializeBuffer* serializeBuffer) const {\n    ReturnQueueWorkDoneCallbackTransfer* transfer;\n    WIRE_TRY(serializeBuffer->Next(&transfer));\n    transfer->commandSize = commandSize;\n    return (ReturnQueueWorkDoneCallbackSerialize(*this, transfer, serializeBuffer));\n}\nWireResult ReturnQueueWorkDoneCallbackCmd::Serialize(\n    size_t commandSize,\n    SerializeBuffer* serializeBuffer,\n    const ObjectIdProvider&) const {\n    return Serialize(commandSize, serializeBuffer);\n}\n\nWireResult ReturnQueueWorkDoneCallbackCmd::Deserialize(DeserializeBuffer* deserializeBuffer, DeserializeAllocator* allocator) {\n    const volatile ReturnQueueWorkDoneCallbackTransfer* transfer;\n    WIRE_TRY(deserializeBuffer->Read(&transfer));\n    return ReturnQueueWorkDoneCallbackDeserialize(this, transfer, deserializeBuffer, allocator);\n}\nWireResult ReturnQueueWorkDoneCallbackCmd::Deserialize(\n    DeserializeBuffer* deserializeBuffer,\n    DeserializeAllocator* allocator,\n    const ObjectIdResolver&) {\n    return Deserialize(deserializeBuffer, allocator);\n}\n\nsize_t ReturnShaderModuleGetCompilationInfoCallbackCmd::GetRequiredSize() const {\n    return WireAlignSizeof<ReturnShaderModuleGetCompilationInfoCallbackTransfer>() + ReturnShaderModuleGetCompilationInfoCallbackGetExtraRequiredSize(*this);\n}\n\nWireResult ReturnShaderModuleGetCompilationInfoCallbackCmd::Serialize(\n    size_t commandSize,\n    SerializeBuffer* serializeBuffer,\n    const ObjectIdProvider& provider) const {\n    ReturnShaderModuleGetCompilationInfoCallbackTransfer* transfer;\n    WIRE_TRY(serializeBuffer->Next(&transfer));\n    transfer->commandSize = commandSize;\n    return (ReturnShaderModuleGetCompilationInfoCallbackSerialize(*this, transfer, serializeBuffer, provider));\n}\nWireResult ReturnShaderModuleGetCompilationInfoCallbackCmd::Serialize(size_t commandSize, SerializeBuffer* serializeBuffer) const {\n    ErrorObjectIdProvider provider;\n    return Serialize(commandSize, serializeBuffer, provider);\n}\n\nWireResult ReturnShaderModuleGetCompilationInfoCallbackCmd::Deserialize(\n    DeserializeBuffer* deserializeBuffer,\n    DeserializeAllocator* allocator,\n    const ObjectIdResolver& resolver) {\n    const volatile ReturnShaderModuleGetCompilationInfoCallbackTransfer* transfer;\n    WIRE_TRY(deserializeBuffer->Read(&transfer));\n    return ReturnShaderModuleGetCompilationInfoCallbackDeserialize(this, transfer, deserializeBuffer, allocator, resolver);\n}\nWireResult ReturnShaderModuleGetCompilationInfoCallbackCmd::Deserialize(DeserializeBuffer* deserializeBuffer, DeserializeAllocator* allocator) {\n    ErrorObjectIdResolver resolver;\n    return Deserialize(deserializeBuffer, allocator, resolver);\n}\n\n\n}  // namespace dawn::wire\n", "src/dawn/wire/client/ApiObjects_autogen.h": "\n#ifndef DAWNWIRE_CLIENT_APIOBJECTS_AUTOGEN_H_\n#define DAWNWIRE_CLIENT_APIOBJECTS_AUTOGEN_H_\n\n#include \"dawn/wire/ObjectType_autogen.h\"\n#include \"dawn/wire/client/ObjectBase.h\"\n\nnamespace dawn::wire::client {\n\n    template<typename T>\n    inline constexpr ObjectType ObjectTypeToTypeEnum = static_cast<ObjectType>(-1);\n\n    class Adapter;\n\n    inline Adapter* FromAPI(WGPUAdapter obj) {\n        return reinterpret_cast<Adapter*>(obj);\n    }\n    inline WGPUAdapter ToAPI(Adapter* obj) {\n        return reinterpret_cast<WGPUAdapter>(obj);\n    }\n\n    template <>\n    inline constexpr ObjectType ObjectTypeToTypeEnum<Adapter> = ObjectType::Adapter;\n\n    struct BindGroup final : ObjectBase {\n        using ObjectBase::ObjectBase;\n    };\n\n    inline BindGroup* FromAPI(WGPUBindGroup obj) {\n        return reinterpret_cast<BindGroup*>(obj);\n    }\n    inline WGPUBindGroup ToAPI(BindGroup* obj) {\n        return reinterpret_cast<WGPUBindGroup>(obj);\n    }\n\n    template <>\n    inline constexpr ObjectType ObjectTypeToTypeEnum<BindGroup> = ObjectType::BindGroup;\n\n    struct BindGroupLayout final : ObjectBase {\n        using ObjectBase::ObjectBase;\n    };\n\n    inline BindGroupLayout* FromAPI(WGPUBindGroupLayout obj) {\n        return reinterpret_cast<BindGroupLayout*>(obj);\n    }\n    inline WGPUBindGroupLayout ToAPI(BindGroupLayout* obj) {\n        return reinterpret_cast<WGPUBindGroupLayout>(obj);\n    }\n\n    template <>\n    inline constexpr ObjectType ObjectTypeToTypeEnum<BindGroupLayout> = ObjectType::BindGroupLayout;\n\n    class Buffer;\n\n    inline Buffer* FromAPI(WGPUBuffer obj) {\n        return reinterpret_cast<Buffer*>(obj);\n    }\n    inline WGPUBuffer ToAPI(Buffer* obj) {\n        return reinterpret_cast<WGPUBuffer>(obj);\n    }\n\n    template <>\n    inline constexpr ObjectType ObjectTypeToTypeEnum<Buffer> = ObjectType::Buffer;\n\n    struct CommandBuffer final : ObjectBase {\n        using ObjectBase::ObjectBase;\n    };\n\n    inline CommandBuffer* FromAPI(WGPUCommandBuffer obj) {\n        return reinterpret_cast<CommandBuffer*>(obj);\n    }\n    inline WGPUCommandBuffer ToAPI(CommandBuffer* obj) {\n        return reinterpret_cast<WGPUCommandBuffer>(obj);\n    }\n\n    template <>\n    inline constexpr ObjectType ObjectTypeToTypeEnum<CommandBuffer> = ObjectType::CommandBuffer;\n\n    struct CommandEncoder final : ObjectBase {\n        using ObjectBase::ObjectBase;\n    };\n\n    inline CommandEncoder* FromAPI(WGPUCommandEncoder obj) {\n        return reinterpret_cast<CommandEncoder*>(obj);\n    }\n    inline WGPUCommandEncoder ToAPI(CommandEncoder* obj) {\n        return reinterpret_cast<WGPUCommandEncoder>(obj);\n    }\n\n    template <>\n    inline constexpr ObjectType ObjectTypeToTypeEnum<CommandEncoder> = ObjectType::CommandEncoder;\n\n    struct ComputePassEncoder final : ObjectBase {\n        using ObjectBase::ObjectBase;\n    };\n\n    inline ComputePassEncoder* FromAPI(WGPUComputePassEncoder obj) {\n        return reinterpret_cast<ComputePassEncoder*>(obj);\n    }\n    inline WGPUComputePassEncoder ToAPI(ComputePassEncoder* obj) {\n        return reinterpret_cast<WGPUComputePassEncoder>(obj);\n    }\n\n    template <>\n    inline constexpr ObjectType ObjectTypeToTypeEnum<ComputePassEncoder> = ObjectType::ComputePassEncoder;\n\n    struct ComputePipeline final : ObjectBase {\n        using ObjectBase::ObjectBase;\n    };\n\n    inline ComputePipeline* FromAPI(WGPUComputePipeline obj) {\n        return reinterpret_cast<ComputePipeline*>(obj);\n    }\n    inline WGPUComputePipeline ToAPI(ComputePipeline* obj) {\n        return reinterpret_cast<WGPUComputePipeline>(obj);\n    }\n\n    template <>\n    inline constexpr ObjectType ObjectTypeToTypeEnum<ComputePipeline> = ObjectType::ComputePipeline;\n\n    class Device;\n\n    inline Device* FromAPI(WGPUDevice obj) {\n        return reinterpret_cast<Device*>(obj);\n    }\n    inline WGPUDevice ToAPI(Device* obj) {\n        return reinterpret_cast<WGPUDevice>(obj);\n    }\n\n    template <>\n    inline constexpr ObjectType ObjectTypeToTypeEnum<Device> = ObjectType::Device;\n\n    struct ExternalTexture final : ObjectBase {\n        using ObjectBase::ObjectBase;\n    };\n\n    inline ExternalTexture* FromAPI(WGPUExternalTexture obj) {\n        return reinterpret_cast<ExternalTexture*>(obj);\n    }\n    inline WGPUExternalTexture ToAPI(ExternalTexture* obj) {\n        return reinterpret_cast<WGPUExternalTexture>(obj);\n    }\n\n    template <>\n    inline constexpr ObjectType ObjectTypeToTypeEnum<ExternalTexture> = ObjectType::ExternalTexture;\n\n    class Instance;\n\n    inline Instance* FromAPI(WGPUInstance obj) {\n        return reinterpret_cast<Instance*>(obj);\n    }\n    inline WGPUInstance ToAPI(Instance* obj) {\n        return reinterpret_cast<WGPUInstance>(obj);\n    }\n\n    template <>\n    inline constexpr ObjectType ObjectTypeToTypeEnum<Instance> = ObjectType::Instance;\n\n    struct PipelineLayout final : ObjectBase {\n        using ObjectBase::ObjectBase;\n    };\n\n    inline PipelineLayout* FromAPI(WGPUPipelineLayout obj) {\n        return reinterpret_cast<PipelineLayout*>(obj);\n    }\n    inline WGPUPipelineLayout ToAPI(PipelineLayout* obj) {\n        return reinterpret_cast<WGPUPipelineLayout>(obj);\n    }\n\n    template <>\n    inline constexpr ObjectType ObjectTypeToTypeEnum<PipelineLayout> = ObjectType::PipelineLayout;\n\n    class QuerySet;\n\n    inline QuerySet* FromAPI(WGPUQuerySet obj) {\n        return reinterpret_cast<QuerySet*>(obj);\n    }\n    inline WGPUQuerySet ToAPI(QuerySet* obj) {\n        return reinterpret_cast<WGPUQuerySet>(obj);\n    }\n\n    template <>\n    inline constexpr ObjectType ObjectTypeToTypeEnum<QuerySet> = ObjectType::QuerySet;\n\n    class Queue;\n\n    inline Queue* FromAPI(WGPUQueue obj) {\n        return reinterpret_cast<Queue*>(obj);\n    }\n    inline WGPUQueue ToAPI(Queue* obj) {\n        return reinterpret_cast<WGPUQueue>(obj);\n    }\n\n    template <>\n    inline constexpr ObjectType ObjectTypeToTypeEnum<Queue> = ObjectType::Queue;\n\n    struct RenderBundle final : ObjectBase {\n        using ObjectBase::ObjectBase;\n    };\n\n    inline RenderBundle* FromAPI(WGPURenderBundle obj) {\n        return reinterpret_cast<RenderBundle*>(obj);\n    }\n    inline WGPURenderBundle ToAPI(RenderBundle* obj) {\n        return reinterpret_cast<WGPURenderBundle>(obj);\n    }\n\n    template <>\n    inline constexpr ObjectType ObjectTypeToTypeEnum<RenderBundle> = ObjectType::RenderBundle;\n\n    struct RenderBundleEncoder final : ObjectBase {\n        using ObjectBase::ObjectBase;\n    };\n\n    inline RenderBundleEncoder* FromAPI(WGPURenderBundleEncoder obj) {\n        return reinterpret_cast<RenderBundleEncoder*>(obj);\n    }\n    inline WGPURenderBundleEncoder ToAPI(RenderBundleEncoder* obj) {\n        return reinterpret_cast<WGPURenderBundleEncoder>(obj);\n    }\n\n    template <>\n    inline constexpr ObjectType ObjectTypeToTypeEnum<RenderBundleEncoder> = ObjectType::RenderBundleEncoder;\n\n    struct RenderPassEncoder final : ObjectBase {\n        using ObjectBase::ObjectBase;\n    };\n\n    inline RenderPassEncoder* FromAPI(WGPURenderPassEncoder obj) {\n        return reinterpret_cast<RenderPassEncoder*>(obj);\n    }\n    inline WGPURenderPassEncoder ToAPI(RenderPassEncoder* obj) {\n        return reinterpret_cast<WGPURenderPassEncoder>(obj);\n    }\n\n    template <>\n    inline constexpr ObjectType ObjectTypeToTypeEnum<RenderPassEncoder> = ObjectType::RenderPassEncoder;\n\n    struct RenderPipeline final : ObjectBase {\n        using ObjectBase::ObjectBase;\n    };\n\n    inline RenderPipeline* FromAPI(WGPURenderPipeline obj) {\n        return reinterpret_cast<RenderPipeline*>(obj);\n    }\n    inline WGPURenderPipeline ToAPI(RenderPipeline* obj) {\n        return reinterpret_cast<WGPURenderPipeline>(obj);\n    }\n\n    template <>\n    inline constexpr ObjectType ObjectTypeToTypeEnum<RenderPipeline> = ObjectType::RenderPipeline;\n\n    struct Sampler final : ObjectBase {\n        using ObjectBase::ObjectBase;\n    };\n\n    inline Sampler* FromAPI(WGPUSampler obj) {\n        return reinterpret_cast<Sampler*>(obj);\n    }\n    inline WGPUSampler ToAPI(Sampler* obj) {\n        return reinterpret_cast<WGPUSampler>(obj);\n    }\n\n    template <>\n    inline constexpr ObjectType ObjectTypeToTypeEnum<Sampler> = ObjectType::Sampler;\n\n    class ShaderModule;\n\n    inline ShaderModule* FromAPI(WGPUShaderModule obj) {\n        return reinterpret_cast<ShaderModule*>(obj);\n    }\n    inline WGPUShaderModule ToAPI(ShaderModule* obj) {\n        return reinterpret_cast<WGPUShaderModule>(obj);\n    }\n\n    template <>\n    inline constexpr ObjectType ObjectTypeToTypeEnum<ShaderModule> = ObjectType::ShaderModule;\n\n    struct Surface final : ObjectBase {\n        using ObjectBase::ObjectBase;\n    };\n\n    inline Surface* FromAPI(WGPUSurface obj) {\n        return reinterpret_cast<Surface*>(obj);\n    }\n    inline WGPUSurface ToAPI(Surface* obj) {\n        return reinterpret_cast<WGPUSurface>(obj);\n    }\n\n    template <>\n    inline constexpr ObjectType ObjectTypeToTypeEnum<Surface> = ObjectType::Surface;\n\n    class SwapChain;\n\n    inline SwapChain* FromAPI(WGPUSwapChain obj) {\n        return reinterpret_cast<SwapChain*>(obj);\n    }\n    inline WGPUSwapChain ToAPI(SwapChain* obj) {\n        return reinterpret_cast<WGPUSwapChain>(obj);\n    }\n\n    template <>\n    inline constexpr ObjectType ObjectTypeToTypeEnum<SwapChain> = ObjectType::SwapChain;\n\n    class Texture;\n\n    inline Texture* FromAPI(WGPUTexture obj) {\n        return reinterpret_cast<Texture*>(obj);\n    }\n    inline WGPUTexture ToAPI(Texture* obj) {\n        return reinterpret_cast<WGPUTexture>(obj);\n    }\n\n    template <>\n    inline constexpr ObjectType ObjectTypeToTypeEnum<Texture> = ObjectType::Texture;\n\n    struct TextureView final : ObjectBase {\n        using ObjectBase::ObjectBase;\n    };\n\n    inline TextureView* FromAPI(WGPUTextureView obj) {\n        return reinterpret_cast<TextureView*>(obj);\n    }\n    inline WGPUTextureView ToAPI(TextureView* obj) {\n        return reinterpret_cast<WGPUTextureView>(obj);\n    }\n\n    template <>\n    inline constexpr ObjectType ObjectTypeToTypeEnum<TextureView> = ObjectType::TextureView;\n\n}  // namespace dawn::wire::client\n\n#endif  // DAWNWIRE_CLIENT_APIOBJECTS_AUTOGEN_H_\n", "src/dawn/wire/client/ApiProcs_autogen.cpp": "\n#include \"dawn/wire/client/ApiObjects.h\"\n#include \"dawn/wire/client/Client.h\"\n\n#include <algorithm>\n#include <cstring>\n#include <string>\n#include <vector>\n\nnamespace dawn::wire::client {\n\n\n\n\n    static\n    WGPUDevice ClientAdapterCreateDevice(WGPUAdapter cSelf, WGPUDeviceDescriptor const * descriptor) {\n        auto self = reinterpret_cast<Adapter*>(cSelf);\n        return self->CreateDevice( descriptor);\n    }\n\n    static\n    size_t ClientAdapterEnumerateFeatures(WGPUAdapter cSelf, WGPUFeatureName * features) {\n        auto self = reinterpret_cast<Adapter*>(cSelf);\n        return self->EnumerateFeatures( features);\n    }\n\n    static\n    WGPUInstance ClientAdapterGetInstance(WGPUAdapter cSelf) {\n        auto self = reinterpret_cast<Adapter*>(cSelf);\n        return self->GetInstance();\n    }\n\n    static\n    bool ClientAdapterGetLimits(WGPUAdapter cSelf, WGPUSupportedLimits * limits) {\n        auto self = reinterpret_cast<Adapter*>(cSelf);\n        return self->GetLimits( limits);\n    }\n\n    static\n    void ClientAdapterGetProperties(WGPUAdapter cSelf, WGPUAdapterProperties * properties) {\n        auto self = reinterpret_cast<Adapter*>(cSelf);\n        return self->GetProperties( properties);\n    }\n\n    static\n    bool ClientAdapterHasFeature(WGPUAdapter cSelf, WGPUFeatureName feature) {\n        auto self = reinterpret_cast<Adapter*>(cSelf);\n        return self->HasFeature( feature);\n    }\n\n    static\n    void ClientAdapterRequestDevice(WGPUAdapter cSelf, WGPUDeviceDescriptor const * descriptor, WGPURequestDeviceCallback callback, void * userdata) {\n        auto self = reinterpret_cast<Adapter*>(cSelf);\n        return self->RequestDevice( descriptor,  callback,  userdata);\n    }\n\n    void ClientAdapterRelease(WGPUAdapter cObj) {\n        Adapter* obj = reinterpret_cast<Adapter*>(cObj);\n\n        if (!obj->Release()) {\n            return;\n        }\n\n        DestroyObjectCmd cmd;\n        cmd.objectType = ObjectType::Adapter;\n        cmd.objectId = obj->GetWireId();\n\n        Client* client = obj->GetClient();\n        client->SerializeCommand(cmd);\n        client->Free(obj);\n    }\n\n    void ClientAdapterReference(WGPUAdapter cObj) {\n        reinterpret_cast<Adapter*>(cObj)->Reference();\n    }\n\n\n    void ClientBindGroupSetLabel(WGPUBindGroup cSelf, char const * label) {\n        auto self = reinterpret_cast<BindGroup*>(cSelf);\n        BindGroupSetLabelCmd cmd;\n\n        cmd.self = cSelf;\n\n\n        \n        cmd.label = label;\n\n        self->GetClient()->SerializeCommand(cmd);\n\n    }\n\n    void ClientBindGroupRelease(WGPUBindGroup cObj) {\n        BindGroup* obj = reinterpret_cast<BindGroup*>(cObj);\n\n        if (!obj->Release()) {\n            return;\n        }\n\n        DestroyObjectCmd cmd;\n        cmd.objectType = ObjectType::BindGroup;\n        cmd.objectId = obj->GetWireId();\n\n        Client* client = obj->GetClient();\n        client->SerializeCommand(cmd);\n        client->Free(obj);\n    }\n\n    void ClientBindGroupReference(WGPUBindGroup cObj) {\n        reinterpret_cast<BindGroup*>(cObj)->Reference();\n    }\n\n\n    void ClientBindGroupLayoutSetLabel(WGPUBindGroupLayout cSelf, char const * label) {\n        auto self = reinterpret_cast<BindGroupLayout*>(cSelf);\n        BindGroupLayoutSetLabelCmd cmd;\n\n        cmd.self = cSelf;\n\n\n        \n        cmd.label = label;\n\n        self->GetClient()->SerializeCommand(cmd);\n\n    }\n\n    void ClientBindGroupLayoutRelease(WGPUBindGroupLayout cObj) {\n        BindGroupLayout* obj = reinterpret_cast<BindGroupLayout*>(cObj);\n\n        if (!obj->Release()) {\n            return;\n        }\n\n        DestroyObjectCmd cmd;\n        cmd.objectType = ObjectType::BindGroupLayout;\n        cmd.objectId = obj->GetWireId();\n\n        Client* client = obj->GetClient();\n        client->SerializeCommand(cmd);\n        client->Free(obj);\n    }\n\n    void ClientBindGroupLayoutReference(WGPUBindGroupLayout cObj) {\n        reinterpret_cast<BindGroupLayout*>(cObj)->Reference();\n    }\n\n\n    static\n    void ClientBufferDestroy(WGPUBuffer cSelf) {\n        auto self = reinterpret_cast<Buffer*>(cSelf);\n        return self->Destroy();\n    }\n\n    static\n    void const * ClientBufferGetConstMappedRange(WGPUBuffer cSelf, size_t offset, size_t size) {\n        auto self = reinterpret_cast<Buffer*>(cSelf);\n        return self->GetConstMappedRange( offset,  size);\n    }\n\n    static\n    WGPUBufferMapState ClientBufferGetMapState(WGPUBuffer cSelf) {\n        auto self = reinterpret_cast<Buffer*>(cSelf);\n        return self->GetMapState();\n    }\n\n    static\n    void * ClientBufferGetMappedRange(WGPUBuffer cSelf, size_t offset, size_t size) {\n        auto self = reinterpret_cast<Buffer*>(cSelf);\n        return self->GetMappedRange( offset,  size);\n    }\n\n    static\n    uint64_t ClientBufferGetSize(WGPUBuffer cSelf) {\n        auto self = reinterpret_cast<Buffer*>(cSelf);\n        return self->GetSize();\n    }\n\n    static\n    WGPUBufferUsageFlags ClientBufferGetUsage(WGPUBuffer cSelf) {\n        auto self = reinterpret_cast<Buffer*>(cSelf);\n        return self->GetUsage();\n    }\n\n    static\n    void ClientBufferMapAsync(WGPUBuffer cSelf, WGPUMapModeFlags mode, size_t offset, size_t size, WGPUBufferMapCallback callback, void * userdata) {\n        auto self = reinterpret_cast<Buffer*>(cSelf);\n        return self->MapAsync( mode,  offset,  size,  callback,  userdata);\n    }\n\n    void ClientBufferSetLabel(WGPUBuffer cSelf, char const * label) {\n        auto self = reinterpret_cast<Buffer*>(cSelf);\n        BufferSetLabelCmd cmd;\n\n        cmd.self = cSelf;\n\n\n        \n        cmd.label = label;\n\n        self->GetClient()->SerializeCommand(cmd);\n\n    }\n\n    static\n    void ClientBufferUnmap(WGPUBuffer cSelf) {\n        auto self = reinterpret_cast<Buffer*>(cSelf);\n        return self->Unmap();\n    }\n\n    void ClientBufferRelease(WGPUBuffer cObj) {\n        Buffer* obj = reinterpret_cast<Buffer*>(cObj);\n\n        if (!obj->Release()) {\n            return;\n        }\n\n        DestroyObjectCmd cmd;\n        cmd.objectType = ObjectType::Buffer;\n        cmd.objectId = obj->GetWireId();\n\n        Client* client = obj->GetClient();\n        client->SerializeCommand(cmd);\n        client->Free(obj);\n    }\n\n    void ClientBufferReference(WGPUBuffer cObj) {\n        reinterpret_cast<Buffer*>(cObj)->Reference();\n    }\n\n\n    void ClientCommandBufferSetLabel(WGPUCommandBuffer cSelf, char const * label) {\n        auto self = reinterpret_cast<CommandBuffer*>(cSelf);\n        CommandBufferSetLabelCmd cmd;\n\n        cmd.self = cSelf;\n\n\n        \n        cmd.label = label;\n\n        self->GetClient()->SerializeCommand(cmd);\n\n    }\n\n    void ClientCommandBufferRelease(WGPUCommandBuffer cObj) {\n        CommandBuffer* obj = reinterpret_cast<CommandBuffer*>(cObj);\n\n        if (!obj->Release()) {\n            return;\n        }\n\n        DestroyObjectCmd cmd;\n        cmd.objectType = ObjectType::CommandBuffer;\n        cmd.objectId = obj->GetWireId();\n\n        Client* client = obj->GetClient();\n        client->SerializeCommand(cmd);\n        client->Free(obj);\n    }\n\n    void ClientCommandBufferReference(WGPUCommandBuffer cObj) {\n        reinterpret_cast<CommandBuffer*>(cObj)->Reference();\n    }\n\n\n    WGPUComputePassEncoder ClientCommandEncoderBeginComputePass(WGPUCommandEncoder cSelf, WGPUComputePassDescriptor const * descriptor) {\n        auto self = reinterpret_cast<CommandEncoder*>(cSelf);\n        CommandEncoderBeginComputePassCmd cmd;\n\n        cmd.self = cSelf;\n\n\n        ComputePassEncoder* returnObject;\n        if constexpr (std::is_constructible_v<ComputePassEncoder, const ObjectBaseParams&, decltype(descriptor)>) {\n            returnObject = self->GetClient()->Make<ComputePassEncoder>(descriptor);\n        } else {\n            returnObject = self->GetClient()->Make<ComputePassEncoder>();\n        }\n        cmd.result = returnObject->GetWireHandle();\n\n        \n        cmd.descriptor = descriptor;\n\n        self->GetClient()->SerializeCommand(cmd);\n\n        return ToAPI(returnObject);\n    }\n\n    WGPURenderPassEncoder ClientCommandEncoderBeginRenderPass(WGPUCommandEncoder cSelf, WGPURenderPassDescriptor const * descriptor) {\n        auto self = reinterpret_cast<CommandEncoder*>(cSelf);\n        CommandEncoderBeginRenderPassCmd cmd;\n\n        cmd.self = cSelf;\n\n\n        RenderPassEncoder* returnObject;\n        if constexpr (std::is_constructible_v<RenderPassEncoder, const ObjectBaseParams&, decltype(descriptor)>) {\n            returnObject = self->GetClient()->Make<RenderPassEncoder>(descriptor);\n        } else {\n            returnObject = self->GetClient()->Make<RenderPassEncoder>();\n        }\n        cmd.result = returnObject->GetWireHandle();\n\n        \n        cmd.descriptor = descriptor;\n\n        self->GetClient()->SerializeCommand(cmd);\n\n        return ToAPI(returnObject);\n    }\n\n    void ClientCommandEncoderClearBuffer(WGPUCommandEncoder cSelf, WGPUBuffer buffer, uint64_t offset, uint64_t size) {\n        auto self = reinterpret_cast<CommandEncoder*>(cSelf);\n        CommandEncoderClearBufferCmd cmd;\n\n        cmd.self = cSelf;\n\n\n        \n        cmd.buffer = buffer;\n        \n        cmd.offset = offset;\n        \n        cmd.size = size;\n\n        self->GetClient()->SerializeCommand(cmd);\n\n    }\n\n    void ClientCommandEncoderCopyBufferToBuffer(WGPUCommandEncoder cSelf, WGPUBuffer source, uint64_t sourceOffset, WGPUBuffer destination, uint64_t destinationOffset, uint64_t size) {\n        auto self = reinterpret_cast<CommandEncoder*>(cSelf);\n        CommandEncoderCopyBufferToBufferCmd cmd;\n\n        cmd.self = cSelf;\n\n\n        \n        cmd.source = source;\n        \n        cmd.sourceOffset = sourceOffset;\n        \n        cmd.destination = destination;\n        \n        cmd.destinationOffset = destinationOffset;\n        \n        cmd.size = size;\n\n        self->GetClient()->SerializeCommand(cmd);\n\n    }\n\n    void ClientCommandEncoderCopyBufferToTexture(WGPUCommandEncoder cSelf, WGPUImageCopyBuffer const * source, WGPUImageCopyTexture const * destination, WGPUExtent3D const * copySize) {\n        auto self = reinterpret_cast<CommandEncoder*>(cSelf);\n        CommandEncoderCopyBufferToTextureCmd cmd;\n\n        cmd.self = cSelf;\n\n\n        \n        cmd.source = source;\n        \n        cmd.destination = destination;\n        \n        cmd.copySize = copySize;\n\n        self->GetClient()->SerializeCommand(cmd);\n\n    }\n\n    void ClientCommandEncoderCopyTextureToBuffer(WGPUCommandEncoder cSelf, WGPUImageCopyTexture const * source, WGPUImageCopyBuffer const * destination, WGPUExtent3D const * copySize) {\n        auto self = reinterpret_cast<CommandEncoder*>(cSelf);\n        CommandEncoderCopyTextureToBufferCmd cmd;\n\n        cmd.self = cSelf;\n\n\n        \n        cmd.source = source;\n        \n        cmd.destination = destination;\n        \n        cmd.copySize = copySize;\n\n        self->GetClient()->SerializeCommand(cmd);\n\n    }\n\n    void ClientCommandEncoderCopyTextureToTexture(WGPUCommandEncoder cSelf, WGPUImageCopyTexture const * source, WGPUImageCopyTexture const * destination, WGPUExtent3D const * copySize) {\n        auto self = reinterpret_cast<CommandEncoder*>(cSelf);\n        CommandEncoderCopyTextureToTextureCmd cmd;\n\n        cmd.self = cSelf;\n\n\n        \n        cmd.source = source;\n        \n        cmd.destination = destination;\n        \n        cmd.copySize = copySize;\n\n        self->GetClient()->SerializeCommand(cmd);\n\n    }\n\n    void ClientCommandEncoderCopyTextureToTextureInternal(WGPUCommandEncoder cSelf, WGPUImageCopyTexture const * source, WGPUImageCopyTexture const * destination, WGPUExtent3D const * copySize) {\n        auto self = reinterpret_cast<CommandEncoder*>(cSelf);\n        CommandEncoderCopyTextureToTextureInternalCmd cmd;\n\n        cmd.self = cSelf;\n\n\n        \n        cmd.source = source;\n        \n        cmd.destination = destination;\n        \n        cmd.copySize = copySize;\n\n        self->GetClient()->SerializeCommand(cmd);\n\n    }\n\n    WGPUCommandBuffer ClientCommandEncoderFinish(WGPUCommandEncoder cSelf, WGPUCommandBufferDescriptor const * descriptor) {\n        auto self = reinterpret_cast<CommandEncoder*>(cSelf);\n        CommandEncoderFinishCmd cmd;\n\n        cmd.self = cSelf;\n\n\n        CommandBuffer* returnObject;\n        if constexpr (std::is_constructible_v<CommandBuffer, const ObjectBaseParams&, decltype(descriptor)>) {\n            returnObject = self->GetClient()->Make<CommandBuffer>(descriptor);\n        } else {\n            returnObject = self->GetClient()->Make<CommandBuffer>();\n        }\n        cmd.result = returnObject->GetWireHandle();\n\n        \n        cmd.descriptor = descriptor;\n\n        self->GetClient()->SerializeCommand(cmd);\n\n        return ToAPI(returnObject);\n    }\n\n    void ClientCommandEncoderInjectValidationError(WGPUCommandEncoder cSelf, char const * message) {\n        auto self = reinterpret_cast<CommandEncoder*>(cSelf);\n        CommandEncoderInjectValidationErrorCmd cmd;\n\n        cmd.self = cSelf;\n\n\n        \n        cmd.message = message;\n\n        self->GetClient()->SerializeCommand(cmd);\n\n    }\n\n    void ClientCommandEncoderInsertDebugMarker(WGPUCommandEncoder cSelf, char const * markerLabel) {\n        auto self = reinterpret_cast<CommandEncoder*>(cSelf);\n        CommandEncoderInsertDebugMarkerCmd cmd;\n\n        cmd.self = cSelf;\n\n\n        \n        cmd.markerLabel = markerLabel;\n\n        self->GetClient()->SerializeCommand(cmd);\n\n    }\n\n    void ClientCommandEncoderPopDebugGroup(WGPUCommandEncoder cSelf) {\n        auto self = reinterpret_cast<CommandEncoder*>(cSelf);\n        CommandEncoderPopDebugGroupCmd cmd;\n\n        cmd.self = cSelf;\n\n\n\n        self->GetClient()->SerializeCommand(cmd);\n\n    }\n\n    void ClientCommandEncoderPushDebugGroup(WGPUCommandEncoder cSelf, char const * groupLabel) {\n        auto self = reinterpret_cast<CommandEncoder*>(cSelf);\n        CommandEncoderPushDebugGroupCmd cmd;\n\n        cmd.self = cSelf;\n\n\n        \n        cmd.groupLabel = groupLabel;\n\n        self->GetClient()->SerializeCommand(cmd);\n\n    }\n\n    void ClientCommandEncoderResolveQuerySet(WGPUCommandEncoder cSelf, WGPUQuerySet querySet, uint32_t firstQuery, uint32_t queryCount, WGPUBuffer destination, uint64_t destinationOffset) {\n        auto self = reinterpret_cast<CommandEncoder*>(cSelf);\n        CommandEncoderResolveQuerySetCmd cmd;\n\n        cmd.self = cSelf;\n\n\n        \n        cmd.querySet = querySet;\n        \n        cmd.firstQuery = firstQuery;\n        \n        cmd.queryCount = queryCount;\n        \n        cmd.destination = destination;\n        \n        cmd.destinationOffset = destinationOffset;\n\n        self->GetClient()->SerializeCommand(cmd);\n\n    }\n\n    void ClientCommandEncoderSetLabel(WGPUCommandEncoder cSelf, char const * label) {\n        auto self = reinterpret_cast<CommandEncoder*>(cSelf);\n        CommandEncoderSetLabelCmd cmd;\n\n        cmd.self = cSelf;\n\n\n        \n        cmd.label = label;\n\n        self->GetClient()->SerializeCommand(cmd);\n\n    }\n\n    void ClientCommandEncoderWriteBuffer(WGPUCommandEncoder cSelf, WGPUBuffer buffer, uint64_t bufferOffset, uint8_t const * data, uint64_t size) {\n        auto self = reinterpret_cast<CommandEncoder*>(cSelf);\n        CommandEncoderWriteBufferCmd cmd;\n\n        cmd.self = cSelf;\n\n\n        \n        cmd.buffer = buffer;\n        \n        cmd.bufferOffset = bufferOffset;\n        \n        cmd.data = data;\n        \n        cmd.size = size;\n\n        self->GetClient()->SerializeCommand(cmd);\n\n    }\n\n    void ClientCommandEncoderWriteTimestamp(WGPUCommandEncoder cSelf, WGPUQuerySet querySet, uint32_t queryIndex) {\n        auto self = reinterpret_cast<CommandEncoder*>(cSelf);\n        CommandEncoderWriteTimestampCmd cmd;\n\n        cmd.self = cSelf;\n\n\n        \n        cmd.querySet = querySet;\n        \n        cmd.queryIndex = queryIndex;\n\n        self->GetClient()->SerializeCommand(cmd);\n\n    }\n\n    void ClientCommandEncoderRelease(WGPUCommandEncoder cObj) {\n        CommandEncoder* obj = reinterpret_cast<CommandEncoder*>(cObj);\n\n        if (!obj->Release()) {\n            return;\n        }\n\n        DestroyObjectCmd cmd;\n        cmd.objectType = ObjectType::CommandEncoder;\n        cmd.objectId = obj->GetWireId();\n\n        Client* client = obj->GetClient();\n        client->SerializeCommand(cmd);\n        client->Free(obj);\n    }\n\n    void ClientCommandEncoderReference(WGPUCommandEncoder cObj) {\n        reinterpret_cast<CommandEncoder*>(cObj)->Reference();\n    }\n\n\n    void ClientComputePassEncoderDispatchWorkgroups(WGPUComputePassEncoder cSelf, uint32_t workgroupCountX, uint32_t workgroupCountY, uint32_t workgroupCountZ) {\n        auto self = reinterpret_cast<ComputePassEncoder*>(cSelf);\n        ComputePassEncoderDispatchWorkgroupsCmd cmd;\n\n        cmd.self = cSelf;\n\n\n        \n        cmd.workgroupCountX = workgroupCountX;\n        \n        cmd.workgroupCountY = workgroupCountY;\n        \n        cmd.workgroupCountZ = workgroupCountZ;\n\n        self->GetClient()->SerializeCommand(cmd);\n\n    }\n\n    void ClientComputePassEncoderDispatchWorkgroupsIndirect(WGPUComputePassEncoder cSelf, WGPUBuffer indirectBuffer, uint64_t indirectOffset) {\n        auto self = reinterpret_cast<ComputePassEncoder*>(cSelf);\n        ComputePassEncoderDispatchWorkgroupsIndirectCmd cmd;\n\n        cmd.self = cSelf;\n\n\n        \n        cmd.indirectBuffer = indirectBuffer;\n        \n        cmd.indirectOffset = indirectOffset;\n\n        self->GetClient()->SerializeCommand(cmd);\n\n    }\n\n    void ClientComputePassEncoderEnd(WGPUComputePassEncoder cSelf) {\n        auto self = reinterpret_cast<ComputePassEncoder*>(cSelf);\n        ComputePassEncoderEndCmd cmd;\n\n        cmd.self = cSelf;\n\n\n\n        self->GetClient()->SerializeCommand(cmd);\n\n    }\n\n    void ClientComputePassEncoderInsertDebugMarker(WGPUComputePassEncoder cSelf, char const * markerLabel) {\n        auto self = reinterpret_cast<ComputePassEncoder*>(cSelf);\n        ComputePassEncoderInsertDebugMarkerCmd cmd;\n\n        cmd.self = cSelf;\n\n\n        \n        cmd.markerLabel = markerLabel;\n\n        self->GetClient()->SerializeCommand(cmd);\n\n    }\n\n    void ClientComputePassEncoderPopDebugGroup(WGPUComputePassEncoder cSelf) {\n        auto self = reinterpret_cast<ComputePassEncoder*>(cSelf);\n        ComputePassEncoderPopDebugGroupCmd cmd;\n\n        cmd.self = cSelf;\n\n\n\n        self->GetClient()->SerializeCommand(cmd);\n\n    }\n\n    void ClientComputePassEncoderPushDebugGroup(WGPUComputePassEncoder cSelf, char const * groupLabel) {\n        auto self = reinterpret_cast<ComputePassEncoder*>(cSelf);\n        ComputePassEncoderPushDebugGroupCmd cmd;\n\n        cmd.self = cSelf;\n\n\n        \n        cmd.groupLabel = groupLabel;\n\n        self->GetClient()->SerializeCommand(cmd);\n\n    }\n\n    void ClientComputePassEncoderSetBindGroup(WGPUComputePassEncoder cSelf, uint32_t groupIndex, WGPUBindGroup group, size_t dynamicOffsetCount, uint32_t const * dynamicOffsets) {\n        auto self = reinterpret_cast<ComputePassEncoder*>(cSelf);\n        ComputePassEncoderSetBindGroupCmd cmd;\n\n        cmd.self = cSelf;\n\n\n        \n        cmd.groupIndex = groupIndex;\n        \n        cmd.group = group;\n        \n        cmd.dynamicOffsetCount = dynamicOffsetCount;\n        \n        cmd.dynamicOffsets = dynamicOffsets;\n\n        self->GetClient()->SerializeCommand(cmd);\n\n    }\n\n    void ClientComputePassEncoderSetLabel(WGPUComputePassEncoder cSelf, char const * label) {\n        auto self = reinterpret_cast<ComputePassEncoder*>(cSelf);\n        ComputePassEncoderSetLabelCmd cmd;\n\n        cmd.self = cSelf;\n\n\n        \n        cmd.label = label;\n\n        self->GetClient()->SerializeCommand(cmd);\n\n    }\n\n    void ClientComputePassEncoderSetPipeline(WGPUComputePassEncoder cSelf, WGPUComputePipeline pipeline) {\n        auto self = reinterpret_cast<ComputePassEncoder*>(cSelf);\n        ComputePassEncoderSetPipelineCmd cmd;\n\n        cmd.self = cSelf;\n\n\n        \n        cmd.pipeline = pipeline;\n\n        self->GetClient()->SerializeCommand(cmd);\n\n    }\n\n    void ClientComputePassEncoderWriteTimestamp(WGPUComputePassEncoder cSelf, WGPUQuerySet querySet, uint32_t queryIndex) {\n        auto self = reinterpret_cast<ComputePassEncoder*>(cSelf);\n        ComputePassEncoderWriteTimestampCmd cmd;\n\n        cmd.self = cSelf;\n\n\n        \n        cmd.querySet = querySet;\n        \n        cmd.queryIndex = queryIndex;\n\n        self->GetClient()->SerializeCommand(cmd);\n\n    }\n\n    void ClientComputePassEncoderRelease(WGPUComputePassEncoder cObj) {\n        ComputePassEncoder* obj = reinterpret_cast<ComputePassEncoder*>(cObj);\n\n        if (!obj->Release()) {\n            return;\n        }\n\n        DestroyObjectCmd cmd;\n        cmd.objectType = ObjectType::ComputePassEncoder;\n        cmd.objectId = obj->GetWireId();\n\n        Client* client = obj->GetClient();\n        client->SerializeCommand(cmd);\n        client->Free(obj);\n    }\n\n    void ClientComputePassEncoderReference(WGPUComputePassEncoder cObj) {\n        reinterpret_cast<ComputePassEncoder*>(cObj)->Reference();\n    }\n\n\n    WGPUBindGroupLayout ClientComputePipelineGetBindGroupLayout(WGPUComputePipeline cSelf, uint32_t groupIndex) {\n        auto self = reinterpret_cast<ComputePipeline*>(cSelf);\n        ComputePipelineGetBindGroupLayoutCmd cmd;\n\n        cmd.self = cSelf;\n\n\n        BindGroupLayout* returnObject;\n        if constexpr (std::is_constructible_v<BindGroupLayout, const ObjectBaseParams&, decltype(groupIndex)>) {\n            returnObject = self->GetClient()->Make<BindGroupLayout>(groupIndex);\n        } else {\n            returnObject = self->GetClient()->Make<BindGroupLayout>();\n        }\n        cmd.result = returnObject->GetWireHandle();\n\n        \n        cmd.groupIndex = groupIndex;\n\n        self->GetClient()->SerializeCommand(cmd);\n\n        return ToAPI(returnObject);\n    }\n\n    void ClientComputePipelineSetLabel(WGPUComputePipeline cSelf, char const * label) {\n        auto self = reinterpret_cast<ComputePipeline*>(cSelf);\n        ComputePipelineSetLabelCmd cmd;\n\n        cmd.self = cSelf;\n\n\n        \n        cmd.label = label;\n\n        self->GetClient()->SerializeCommand(cmd);\n\n    }\n\n    void ClientComputePipelineRelease(WGPUComputePipeline cObj) {\n        ComputePipeline* obj = reinterpret_cast<ComputePipeline*>(cObj);\n\n        if (!obj->Release()) {\n            return;\n        }\n\n        DestroyObjectCmd cmd;\n        cmd.objectType = ObjectType::ComputePipeline;\n        cmd.objectId = obj->GetWireId();\n\n        Client* client = obj->GetClient();\n        client->SerializeCommand(cmd);\n        client->Free(obj);\n    }\n\n    void ClientComputePipelineReference(WGPUComputePipeline cObj) {\n        reinterpret_cast<ComputePipeline*>(cObj)->Reference();\n    }\n\n\n    WGPUBindGroup ClientDeviceCreateBindGroup(WGPUDevice cSelf, WGPUBindGroupDescriptor const * descriptor) {\n        auto self = reinterpret_cast<Device*>(cSelf);\n        DeviceCreateBindGroupCmd cmd;\n\n        cmd.self = cSelf;\n\n\n        BindGroup* returnObject;\n        if constexpr (std::is_constructible_v<BindGroup, const ObjectBaseParams&, decltype(descriptor)>) {\n            returnObject = self->GetClient()->Make<BindGroup>(descriptor);\n        } else {\n            returnObject = self->GetClient()->Make<BindGroup>();\n        }\n        cmd.result = returnObject->GetWireHandle();\n\n        \n        cmd.descriptor = descriptor;\n\n        self->GetClient()->SerializeCommand(cmd);\n\n        return ToAPI(returnObject);\n    }\n\n    WGPUBindGroupLayout ClientDeviceCreateBindGroupLayout(WGPUDevice cSelf, WGPUBindGroupLayoutDescriptor const * descriptor) {\n        auto self = reinterpret_cast<Device*>(cSelf);\n        DeviceCreateBindGroupLayoutCmd cmd;\n\n        cmd.self = cSelf;\n\n\n        BindGroupLayout* returnObject;\n        if constexpr (std::is_constructible_v<BindGroupLayout, const ObjectBaseParams&, decltype(descriptor)>) {\n            returnObject = self->GetClient()->Make<BindGroupLayout>(descriptor);\n        } else {\n            returnObject = self->GetClient()->Make<BindGroupLayout>();\n        }\n        cmd.result = returnObject->GetWireHandle();\n\n        \n        cmd.descriptor = descriptor;\n\n        self->GetClient()->SerializeCommand(cmd);\n\n        return ToAPI(returnObject);\n    }\n\n    static\n    WGPUBuffer ClientDeviceCreateBuffer(WGPUDevice cSelf, WGPUBufferDescriptor const * descriptor) {\n        auto self = reinterpret_cast<Device*>(cSelf);\n        return self->CreateBuffer( descriptor);\n    }\n\n    WGPUCommandEncoder ClientDeviceCreateCommandEncoder(WGPUDevice cSelf, WGPUCommandEncoderDescriptor const * descriptor) {\n        auto self = reinterpret_cast<Device*>(cSelf);\n        DeviceCreateCommandEncoderCmd cmd;\n\n        cmd.self = cSelf;\n\n\n        CommandEncoder* returnObject;\n        if constexpr (std::is_constructible_v<CommandEncoder, const ObjectBaseParams&, decltype(descriptor)>) {\n            returnObject = self->GetClient()->Make<CommandEncoder>(descriptor);\n        } else {\n            returnObject = self->GetClient()->Make<CommandEncoder>();\n        }\n        cmd.result = returnObject->GetWireHandle();\n\n        \n        cmd.descriptor = descriptor;\n\n        self->GetClient()->SerializeCommand(cmd);\n\n        return ToAPI(returnObject);\n    }\n\n    WGPUComputePipeline ClientDeviceCreateComputePipeline(WGPUDevice cSelf, WGPUComputePipelineDescriptor const * descriptor) {\n        auto self = reinterpret_cast<Device*>(cSelf);\n        DeviceCreateComputePipelineCmd cmd;\n\n        cmd.self = cSelf;\n\n\n        ComputePipeline* returnObject;\n        if constexpr (std::is_constructible_v<ComputePipeline, const ObjectBaseParams&, decltype(descriptor)>) {\n            returnObject = self->GetClient()->Make<ComputePipeline>(descriptor);\n        } else {\n            returnObject = self->GetClient()->Make<ComputePipeline>();\n        }\n        cmd.result = returnObject->GetWireHandle();\n\n        \n        cmd.descriptor = descriptor;\n\n        self->GetClient()->SerializeCommand(cmd);\n\n        return ToAPI(returnObject);\n    }\n\n    static\n    void ClientDeviceCreateComputePipelineAsync(WGPUDevice cSelf, WGPUComputePipelineDescriptor const * descriptor, WGPUCreateComputePipelineAsyncCallback callback, void * userdata) {\n        auto self = reinterpret_cast<Device*>(cSelf);\n        return self->CreateComputePipelineAsync( descriptor,  callback,  userdata);\n    }\n\n    WGPUBuffer ClientDeviceCreateErrorBuffer(WGPUDevice cSelf, WGPUBufferDescriptor const * descriptor) {\n        auto self = reinterpret_cast<Device*>(cSelf);\n        DeviceCreateErrorBufferCmd cmd;\n\n        cmd.self = cSelf;\n\n\n        Buffer* returnObject;\n        if constexpr (std::is_constructible_v<Buffer, const ObjectBaseParams&, decltype(descriptor)>) {\n            returnObject = self->GetClient()->Make<Buffer>(descriptor);\n        } else {\n            returnObject = self->GetClient()->Make<Buffer>();\n        }\n        cmd.result = returnObject->GetWireHandle();\n\n        \n        cmd.descriptor = descriptor;\n\n        self->GetClient()->SerializeCommand(cmd);\n\n        return ToAPI(returnObject);\n    }\n\n    WGPUExternalTexture ClientDeviceCreateErrorExternalTexture(WGPUDevice cSelf) {\n        auto self = reinterpret_cast<Device*>(cSelf);\n        DeviceCreateErrorExternalTextureCmd cmd;\n\n        cmd.self = cSelf;\n\n\n        ExternalTexture* returnObject;\n        if constexpr (std::is_constructible_v<ExternalTexture, const ObjectBaseParams&>) {\n            returnObject = self->GetClient()->Make<ExternalTexture>();\n        } else {\n            returnObject = self->GetClient()->Make<ExternalTexture>();\n        }\n        cmd.result = returnObject->GetWireHandle();\n\n\n        self->GetClient()->SerializeCommand(cmd);\n\n        return ToAPI(returnObject);\n    }\n\n    WGPUShaderModule ClientDeviceCreateErrorShaderModule(WGPUDevice cSelf, WGPUShaderModuleDescriptor const * descriptor, char const * errorMessage) {\n        auto self = reinterpret_cast<Device*>(cSelf);\n        DeviceCreateErrorShaderModuleCmd cmd;\n\n        cmd.self = cSelf;\n\n\n        ShaderModule* returnObject;\n        if constexpr (std::is_constructible_v<ShaderModule, const ObjectBaseParams&, decltype(descriptor), decltype(errorMessage)>) {\n            returnObject = self->GetClient()->Make<ShaderModule>(descriptor, errorMessage);\n        } else {\n            returnObject = self->GetClient()->Make<ShaderModule>();\n        }\n        cmd.result = returnObject->GetWireHandle();\n\n        \n        cmd.descriptor = descriptor;\n        \n        cmd.errorMessage = errorMessage;\n\n        self->GetClient()->SerializeCommand(cmd);\n\n        return ToAPI(returnObject);\n    }\n\n    WGPUTexture ClientDeviceCreateErrorTexture(WGPUDevice cSelf, WGPUTextureDescriptor const * descriptor) {\n        auto self = reinterpret_cast<Device*>(cSelf);\n        DeviceCreateErrorTextureCmd cmd;\n\n        cmd.self = cSelf;\n\n\n        Texture* returnObject;\n        if constexpr (std::is_constructible_v<Texture, const ObjectBaseParams&, decltype(descriptor)>) {\n            returnObject = self->GetClient()->Make<Texture>(descriptor);\n        } else {\n            returnObject = self->GetClient()->Make<Texture>();\n        }\n        cmd.result = returnObject->GetWireHandle();\n\n        \n        cmd.descriptor = descriptor;\n\n        self->GetClient()->SerializeCommand(cmd);\n\n        return ToAPI(returnObject);\n    }\n\n    WGPUExternalTexture ClientDeviceCreateExternalTexture(WGPUDevice cSelf, WGPUExternalTextureDescriptor const * externalTextureDescriptor) {\n        auto self = reinterpret_cast<Device*>(cSelf);\n        DeviceCreateExternalTextureCmd cmd;\n\n        cmd.self = cSelf;\n\n\n        ExternalTexture* returnObject;\n        if constexpr (std::is_constructible_v<ExternalTexture, const ObjectBaseParams&, decltype(externalTextureDescriptor)>) {\n            returnObject = self->GetClient()->Make<ExternalTexture>(externalTextureDescriptor);\n        } else {\n            returnObject = self->GetClient()->Make<ExternalTexture>();\n        }\n        cmd.result = returnObject->GetWireHandle();\n\n        \n        cmd.externalTextureDescriptor = externalTextureDescriptor;\n\n        self->GetClient()->SerializeCommand(cmd);\n\n        return ToAPI(returnObject);\n    }\n\n    WGPUPipelineLayout ClientDeviceCreatePipelineLayout(WGPUDevice cSelf, WGPUPipelineLayoutDescriptor const * descriptor) {\n        auto self = reinterpret_cast<Device*>(cSelf);\n        DeviceCreatePipelineLayoutCmd cmd;\n\n        cmd.self = cSelf;\n\n\n        PipelineLayout* returnObject;\n        if constexpr (std::is_constructible_v<PipelineLayout, const ObjectBaseParams&, decltype(descriptor)>) {\n            returnObject = self->GetClient()->Make<PipelineLayout>(descriptor);\n        } else {\n            returnObject = self->GetClient()->Make<PipelineLayout>();\n        }\n        cmd.result = returnObject->GetWireHandle();\n\n        \n        cmd.descriptor = descriptor;\n\n        self->GetClient()->SerializeCommand(cmd);\n\n        return ToAPI(returnObject);\n    }\n\n    WGPUQuerySet ClientDeviceCreateQuerySet(WGPUDevice cSelf, WGPUQuerySetDescriptor const * descriptor) {\n        auto self = reinterpret_cast<Device*>(cSelf);\n        DeviceCreateQuerySetCmd cmd;\n\n        cmd.self = cSelf;\n\n\n        QuerySet* returnObject;\n        if constexpr (std::is_constructible_v<QuerySet, const ObjectBaseParams&, decltype(descriptor)>) {\n            returnObject = self->GetClient()->Make<QuerySet>(descriptor);\n        } else {\n            returnObject = self->GetClient()->Make<QuerySet>();\n        }\n        cmd.result = returnObject->GetWireHandle();\n\n        \n        cmd.descriptor = descriptor;\n\n        self->GetClient()->SerializeCommand(cmd);\n\n        return ToAPI(returnObject);\n    }\n\n    WGPURenderBundleEncoder ClientDeviceCreateRenderBundleEncoder(WGPUDevice cSelf, WGPURenderBundleEncoderDescriptor const * descriptor) {\n        auto self = reinterpret_cast<Device*>(cSelf);\n        DeviceCreateRenderBundleEncoderCmd cmd;\n\n        cmd.self = cSelf;\n\n\n        RenderBundleEncoder* returnObject;\n        if constexpr (std::is_constructible_v<RenderBundleEncoder, const ObjectBaseParams&, decltype(descriptor)>) {\n            returnObject = self->GetClient()->Make<RenderBundleEncoder>(descriptor);\n        } else {\n            returnObject = self->GetClient()->Make<RenderBundleEncoder>();\n        }\n        cmd.result = returnObject->GetWireHandle();\n\n        \n        cmd.descriptor = descriptor;\n\n        self->GetClient()->SerializeCommand(cmd);\n\n        return ToAPI(returnObject);\n    }\n\n    WGPURenderPipeline ClientDeviceCreateRenderPipeline(WGPUDevice cSelf, WGPURenderPipelineDescriptor const * descriptor) {\n        auto self = reinterpret_cast<Device*>(cSelf);\n        DeviceCreateRenderPipelineCmd cmd;\n\n        cmd.self = cSelf;\n\n\n        RenderPipeline* returnObject;\n        if constexpr (std::is_constructible_v<RenderPipeline, const ObjectBaseParams&, decltype(descriptor)>) {\n            returnObject = self->GetClient()->Make<RenderPipeline>(descriptor);\n        } else {\n            returnObject = self->GetClient()->Make<RenderPipeline>();\n        }\n        cmd.result = returnObject->GetWireHandle();\n\n        \n        cmd.descriptor = descriptor;\n\n        self->GetClient()->SerializeCommand(cmd);\n\n        return ToAPI(returnObject);\n    }\n\n    static\n    void ClientDeviceCreateRenderPipelineAsync(WGPUDevice cSelf, WGPURenderPipelineDescriptor const * descriptor, WGPUCreateRenderPipelineAsyncCallback callback, void * userdata) {\n        auto self = reinterpret_cast<Device*>(cSelf);\n        return self->CreateRenderPipelineAsync( descriptor,  callback,  userdata);\n    }\n\n    WGPUSampler ClientDeviceCreateSampler(WGPUDevice cSelf, WGPUSamplerDescriptor const * descriptor) {\n        auto self = reinterpret_cast<Device*>(cSelf);\n        DeviceCreateSamplerCmd cmd;\n\n        cmd.self = cSelf;\n\n\n        Sampler* returnObject;\n        if constexpr (std::is_constructible_v<Sampler, const ObjectBaseParams&, decltype(descriptor)>) {\n            returnObject = self->GetClient()->Make<Sampler>(descriptor);\n        } else {\n            returnObject = self->GetClient()->Make<Sampler>();\n        }\n        cmd.result = returnObject->GetWireHandle();\n\n        \n        cmd.descriptor = descriptor;\n\n        self->GetClient()->SerializeCommand(cmd);\n\n        return ToAPI(returnObject);\n    }\n\n    WGPUShaderModule ClientDeviceCreateShaderModule(WGPUDevice cSelf, WGPUShaderModuleDescriptor const * descriptor) {\n        auto self = reinterpret_cast<Device*>(cSelf);\n        DeviceCreateShaderModuleCmd cmd;\n\n        cmd.self = cSelf;\n\n\n        ShaderModule* returnObject;\n        if constexpr (std::is_constructible_v<ShaderModule, const ObjectBaseParams&, decltype(descriptor)>) {\n            returnObject = self->GetClient()->Make<ShaderModule>(descriptor);\n        } else {\n            returnObject = self->GetClient()->Make<ShaderModule>();\n        }\n        cmd.result = returnObject->GetWireHandle();\n\n        \n        cmd.descriptor = descriptor;\n\n        self->GetClient()->SerializeCommand(cmd);\n\n        return ToAPI(returnObject);\n    }\n\n    WGPUSwapChain ClientDeviceCreateSwapChain(WGPUDevice cSelf, WGPUSurface surface, WGPUSwapChainDescriptor const * descriptor) {\n        auto self = reinterpret_cast<Device*>(cSelf);\n        DeviceCreateSwapChainCmd cmd;\n\n        cmd.self = cSelf;\n\n\n        SwapChain* returnObject;\n        if constexpr (std::is_constructible_v<SwapChain, const ObjectBaseParams&, decltype(surface), decltype(descriptor)>) {\n            returnObject = self->GetClient()->Make<SwapChain>(surface, descriptor);\n        } else {\n            returnObject = self->GetClient()->Make<SwapChain>();\n        }\n        cmd.result = returnObject->GetWireHandle();\n\n        \n        cmd.surface = surface;\n        \n        cmd.descriptor = descriptor;\n\n        self->GetClient()->SerializeCommand(cmd);\n\n        return ToAPI(returnObject);\n    }\n\n    WGPUTexture ClientDeviceCreateTexture(WGPUDevice cSelf, WGPUTextureDescriptor const * descriptor) {\n        auto self = reinterpret_cast<Device*>(cSelf);\n        DeviceCreateTextureCmd cmd;\n\n        cmd.self = cSelf;\n\n\n        Texture* returnObject;\n        if constexpr (std::is_constructible_v<Texture, const ObjectBaseParams&, decltype(descriptor)>) {\n            returnObject = self->GetClient()->Make<Texture>(descriptor);\n        } else {\n            returnObject = self->GetClient()->Make<Texture>();\n        }\n        cmd.result = returnObject->GetWireHandle();\n\n        \n        cmd.descriptor = descriptor;\n\n        self->GetClient()->SerializeCommand(cmd);\n\n        return ToAPI(returnObject);\n    }\n\n    void ClientDeviceDestroy(WGPUDevice cSelf) {\n        auto self = reinterpret_cast<Device*>(cSelf);\n        DeviceDestroyCmd cmd;\n\n        cmd.self = cSelf;\n\n\n\n        self->GetClient()->SerializeCommand(cmd);\n\n    }\n\n    static\n    size_t ClientDeviceEnumerateFeatures(WGPUDevice cSelf, WGPUFeatureName * features) {\n        auto self = reinterpret_cast<Device*>(cSelf);\n        return self->EnumerateFeatures( features);\n    }\n\n    void ClientDeviceForceLoss(WGPUDevice cSelf, WGPUDeviceLostReason type, char const * message) {\n        auto self = reinterpret_cast<Device*>(cSelf);\n        DeviceForceLossCmd cmd;\n\n        cmd.self = cSelf;\n\n\n        \n        cmd.type = type;\n        \n        cmd.message = message;\n\n        self->GetClient()->SerializeCommand(cmd);\n\n    }\n\n    static\n    WGPUAdapter ClientDeviceGetAdapter(WGPUDevice cSelf) {\n        auto self = reinterpret_cast<Device*>(cSelf);\n        return self->GetAdapter();\n    }\n\n    static\n    bool ClientDeviceGetLimits(WGPUDevice cSelf, WGPUSupportedLimits * limits) {\n        auto self = reinterpret_cast<Device*>(cSelf);\n        return self->GetLimits( limits);\n    }\n\n    static\n    WGPUQueue ClientDeviceGetQueue(WGPUDevice cSelf) {\n        auto self = reinterpret_cast<Device*>(cSelf);\n        return self->GetQueue();\n    }\n\n    static\n    WGPUTextureUsageFlags ClientDeviceGetSupportedSurfaceUsage(WGPUDevice cSelf, WGPUSurface surface) {\n        auto self = reinterpret_cast<Device*>(cSelf);\n        return self->GetSupportedSurfaceUsage( surface);\n    }\n\n    static\n    bool ClientDeviceHasFeature(WGPUDevice cSelf, WGPUFeatureName feature) {\n        auto self = reinterpret_cast<Device*>(cSelf);\n        return self->HasFeature( feature);\n    }\n\n    static\n    void ClientDeviceInjectError(WGPUDevice cSelf, WGPUErrorType type, char const * message) {\n        auto self = reinterpret_cast<Device*>(cSelf);\n        return self->InjectError( type,  message);\n    }\n\n    static\n    void ClientDevicePopErrorScope(WGPUDevice cSelf, WGPUErrorCallback callback, void * userdata) {\n        auto self = reinterpret_cast<Device*>(cSelf);\n        return self->PopErrorScope( callback,  userdata);\n    }\n\n    void ClientDevicePushErrorScope(WGPUDevice cSelf, WGPUErrorFilter filter) {\n        auto self = reinterpret_cast<Device*>(cSelf);\n        DevicePushErrorScopeCmd cmd;\n\n        cmd.self = cSelf;\n\n\n        \n        cmd.filter = filter;\n\n        self->GetClient()->SerializeCommand(cmd);\n\n    }\n\n    static\n    void ClientDeviceSetDeviceLostCallback(WGPUDevice cSelf, WGPUDeviceLostCallback callback, void * userdata) {\n        auto self = reinterpret_cast<Device*>(cSelf);\n        return self->SetDeviceLostCallback( callback,  userdata);\n    }\n\n    void ClientDeviceSetLabel(WGPUDevice cSelf, char const * label) {\n        auto self = reinterpret_cast<Device*>(cSelf);\n        DeviceSetLabelCmd cmd;\n\n        cmd.self = cSelf;\n\n\n        \n        cmd.label = label;\n\n        self->GetClient()->SerializeCommand(cmd);\n\n    }\n\n    static\n    void ClientDeviceSetLoggingCallback(WGPUDevice cSelf, WGPULoggingCallback callback, void * userdata) {\n        auto self = reinterpret_cast<Device*>(cSelf);\n        return self->SetLoggingCallback( callback,  userdata);\n    }\n\n    static\n    void ClientDeviceSetUncapturedErrorCallback(WGPUDevice cSelf, WGPUErrorCallback callback, void * userdata) {\n        auto self = reinterpret_cast<Device*>(cSelf);\n        return self->SetUncapturedErrorCallback( callback,  userdata);\n    }\n\n    void ClientDeviceTick(WGPUDevice cSelf) {\n        auto self = reinterpret_cast<Device*>(cSelf);\n        DeviceTickCmd cmd;\n\n        cmd.self = cSelf;\n\n\n\n        self->GetClient()->SerializeCommand(cmd);\n\n    }\n\n    void ClientDeviceValidateTextureDescriptor(WGPUDevice cSelf, WGPUTextureDescriptor const * descriptor) {\n        auto self = reinterpret_cast<Device*>(cSelf);\n        DeviceValidateTextureDescriptorCmd cmd;\n\n        cmd.self = cSelf;\n\n\n        \n        cmd.descriptor = descriptor;\n\n        self->GetClient()->SerializeCommand(cmd);\n\n    }\n\n    void ClientDeviceRelease(WGPUDevice cObj) {\n        Device* obj = reinterpret_cast<Device*>(cObj);\n\n        if (!obj->Release()) {\n            return;\n        }\n\n        DestroyObjectCmd cmd;\n        cmd.objectType = ObjectType::Device;\n        cmd.objectId = obj->GetWireId();\n\n        Client* client = obj->GetClient();\n        client->SerializeCommand(cmd);\n        client->Free(obj);\n    }\n\n    void ClientDeviceReference(WGPUDevice cObj) {\n        reinterpret_cast<Device*>(cObj)->Reference();\n    }\n\n\n    void ClientExternalTextureDestroy(WGPUExternalTexture cSelf) {\n        auto self = reinterpret_cast<ExternalTexture*>(cSelf);\n        ExternalTextureDestroyCmd cmd;\n\n        cmd.self = cSelf;\n\n\n\n        self->GetClient()->SerializeCommand(cmd);\n\n    }\n\n    void ClientExternalTextureExpire(WGPUExternalTexture cSelf) {\n        auto self = reinterpret_cast<ExternalTexture*>(cSelf);\n        ExternalTextureExpireCmd cmd;\n\n        cmd.self = cSelf;\n\n\n\n        self->GetClient()->SerializeCommand(cmd);\n\n    }\n\n    void ClientExternalTextureRefresh(WGPUExternalTexture cSelf) {\n        auto self = reinterpret_cast<ExternalTexture*>(cSelf);\n        ExternalTextureRefreshCmd cmd;\n\n        cmd.self = cSelf;\n\n\n\n        self->GetClient()->SerializeCommand(cmd);\n\n    }\n\n    void ClientExternalTextureSetLabel(WGPUExternalTexture cSelf, char const * label) {\n        auto self = reinterpret_cast<ExternalTexture*>(cSelf);\n        ExternalTextureSetLabelCmd cmd;\n\n        cmd.self = cSelf;\n\n\n        \n        cmd.label = label;\n\n        self->GetClient()->SerializeCommand(cmd);\n\n    }\n\n    void ClientExternalTextureRelease(WGPUExternalTexture cObj) {\n        ExternalTexture* obj = reinterpret_cast<ExternalTexture*>(cObj);\n\n        if (!obj->Release()) {\n            return;\n        }\n\n        DestroyObjectCmd cmd;\n        cmd.objectType = ObjectType::ExternalTexture;\n        cmd.objectId = obj->GetWireId();\n\n        Client* client = obj->GetClient();\n        client->SerializeCommand(cmd);\n        client->Free(obj);\n    }\n\n    void ClientExternalTextureReference(WGPUExternalTexture cObj) {\n        reinterpret_cast<ExternalTexture*>(cObj)->Reference();\n    }\n\n\n    WGPUSurface ClientInstanceCreateSurface(WGPUInstance cSelf, WGPUSurfaceDescriptor const * descriptor) {\n        auto self = reinterpret_cast<Instance*>(cSelf);\n        InstanceCreateSurfaceCmd cmd;\n\n        cmd.self = cSelf;\n\n\n        Surface* returnObject;\n        if constexpr (std::is_constructible_v<Surface, const ObjectBaseParams&, decltype(descriptor)>) {\n            returnObject = self->GetClient()->Make<Surface>(descriptor);\n        } else {\n            returnObject = self->GetClient()->Make<Surface>();\n        }\n        cmd.result = returnObject->GetWireHandle();\n\n        \n        cmd.descriptor = descriptor;\n\n        self->GetClient()->SerializeCommand(cmd);\n\n        return ToAPI(returnObject);\n    }\n\n    void ClientInstanceProcessEvents(WGPUInstance cSelf) {\n        auto self = reinterpret_cast<Instance*>(cSelf);\n        InstanceProcessEventsCmd cmd;\n\n        cmd.self = cSelf;\n\n\n\n        self->GetClient()->SerializeCommand(cmd);\n\n    }\n\n    static\n    void ClientInstanceRequestAdapter(WGPUInstance cSelf, WGPURequestAdapterOptions const * options, WGPURequestAdapterCallback callback, void * userdata) {\n        auto self = reinterpret_cast<Instance*>(cSelf);\n        return self->RequestAdapter( options,  callback,  userdata);\n    }\n\n    void ClientInstanceRelease(WGPUInstance cObj) {\n        Instance* obj = reinterpret_cast<Instance*>(cObj);\n\n        if (!obj->Release()) {\n            return;\n        }\n\n        DestroyObjectCmd cmd;\n        cmd.objectType = ObjectType::Instance;\n        cmd.objectId = obj->GetWireId();\n\n        Client* client = obj->GetClient();\n        client->SerializeCommand(cmd);\n        client->Free(obj);\n    }\n\n    void ClientInstanceReference(WGPUInstance cObj) {\n        reinterpret_cast<Instance*>(cObj)->Reference();\n    }\n\n\n    void ClientPipelineLayoutSetLabel(WGPUPipelineLayout cSelf, char const * label) {\n        auto self = reinterpret_cast<PipelineLayout*>(cSelf);\n        PipelineLayoutSetLabelCmd cmd;\n\n        cmd.self = cSelf;\n\n\n        \n        cmd.label = label;\n\n        self->GetClient()->SerializeCommand(cmd);\n\n    }\n\n    void ClientPipelineLayoutRelease(WGPUPipelineLayout cObj) {\n        PipelineLayout* obj = reinterpret_cast<PipelineLayout*>(cObj);\n\n        if (!obj->Release()) {\n            return;\n        }\n\n        DestroyObjectCmd cmd;\n        cmd.objectType = ObjectType::PipelineLayout;\n        cmd.objectId = obj->GetWireId();\n\n        Client* client = obj->GetClient();\n        client->SerializeCommand(cmd);\n        client->Free(obj);\n    }\n\n    void ClientPipelineLayoutReference(WGPUPipelineLayout cObj) {\n        reinterpret_cast<PipelineLayout*>(cObj)->Reference();\n    }\n\n\n    void ClientQuerySetDestroy(WGPUQuerySet cSelf) {\n        auto self = reinterpret_cast<QuerySet*>(cSelf);\n        QuerySetDestroyCmd cmd;\n\n        cmd.self = cSelf;\n\n\n\n        self->GetClient()->SerializeCommand(cmd);\n\n    }\n\n    static\n    uint32_t ClientQuerySetGetCount(WGPUQuerySet cSelf) {\n        auto self = reinterpret_cast<QuerySet*>(cSelf);\n        return self->GetCount();\n    }\n\n    static\n    WGPUQueryType ClientQuerySetGetType(WGPUQuerySet cSelf) {\n        auto self = reinterpret_cast<QuerySet*>(cSelf);\n        return self->GetType();\n    }\n\n    void ClientQuerySetSetLabel(WGPUQuerySet cSelf, char const * label) {\n        auto self = reinterpret_cast<QuerySet*>(cSelf);\n        QuerySetSetLabelCmd cmd;\n\n        cmd.self = cSelf;\n\n\n        \n        cmd.label = label;\n\n        self->GetClient()->SerializeCommand(cmd);\n\n    }\n\n    void ClientQuerySetRelease(WGPUQuerySet cObj) {\n        QuerySet* obj = reinterpret_cast<QuerySet*>(cObj);\n\n        if (!obj->Release()) {\n            return;\n        }\n\n        DestroyObjectCmd cmd;\n        cmd.objectType = ObjectType::QuerySet;\n        cmd.objectId = obj->GetWireId();\n\n        Client* client = obj->GetClient();\n        client->SerializeCommand(cmd);\n        client->Free(obj);\n    }\n\n    void ClientQuerySetReference(WGPUQuerySet cObj) {\n        reinterpret_cast<QuerySet*>(cObj)->Reference();\n    }\n\n\n    void ClientQueueCopyExternalTextureForBrowser(WGPUQueue cSelf, WGPUImageCopyExternalTexture const * source, WGPUImageCopyTexture const * destination, WGPUExtent3D const * copySize, WGPUCopyTextureForBrowserOptions const * options) {\n        auto self = reinterpret_cast<Queue*>(cSelf);\n        QueueCopyExternalTextureForBrowserCmd cmd;\n\n        cmd.self = cSelf;\n\n\n        \n        cmd.source = source;\n        \n        cmd.destination = destination;\n        \n        cmd.copySize = copySize;\n        \n        cmd.options = options;\n\n        self->GetClient()->SerializeCommand(cmd);\n\n    }\n\n    void ClientQueueCopyTextureForBrowser(WGPUQueue cSelf, WGPUImageCopyTexture const * source, WGPUImageCopyTexture const * destination, WGPUExtent3D const * copySize, WGPUCopyTextureForBrowserOptions const * options) {\n        auto self = reinterpret_cast<Queue*>(cSelf);\n        QueueCopyTextureForBrowserCmd cmd;\n\n        cmd.self = cSelf;\n\n\n        \n        cmd.source = source;\n        \n        cmd.destination = destination;\n        \n        cmd.copySize = copySize;\n        \n        cmd.options = options;\n\n        self->GetClient()->SerializeCommand(cmd);\n\n    }\n\n    static\n    void ClientQueueOnSubmittedWorkDone(WGPUQueue cSelf, uint64_t signalValue, WGPUQueueWorkDoneCallback callback, void * userdata) {\n        auto self = reinterpret_cast<Queue*>(cSelf);\n        return self->OnSubmittedWorkDone( signalValue,  callback,  userdata);\n    }\n\n    void ClientQueueSetLabel(WGPUQueue cSelf, char const * label) {\n        auto self = reinterpret_cast<Queue*>(cSelf);\n        QueueSetLabelCmd cmd;\n\n        cmd.self = cSelf;\n\n\n        \n        cmd.label = label;\n\n        self->GetClient()->SerializeCommand(cmd);\n\n    }\n\n    void ClientQueueSubmit(WGPUQueue cSelf, size_t commandCount, WGPUCommandBuffer const * commands) {\n        auto self = reinterpret_cast<Queue*>(cSelf);\n        QueueSubmitCmd cmd;\n\n        cmd.self = cSelf;\n\n\n        \n        cmd.commandCount = commandCount;\n        \n        cmd.commands = commands;\n\n        self->GetClient()->SerializeCommand(cmd);\n\n    }\n\n    static\n    void ClientQueueWriteBuffer(WGPUQueue cSelf, WGPUBuffer buffer, uint64_t bufferOffset, void const * data, size_t size) {\n        auto self = reinterpret_cast<Queue*>(cSelf);\n        return self->WriteBuffer( buffer,  bufferOffset,  data,  size);\n    }\n\n    static\n    void ClientQueueWriteTexture(WGPUQueue cSelf, WGPUImageCopyTexture const * destination, void const * data, size_t dataSize, WGPUTextureDataLayout const * dataLayout, WGPUExtent3D const * writeSize) {\n        auto self = reinterpret_cast<Queue*>(cSelf);\n        return self->WriteTexture( destination,  data,  dataSize,  dataLayout,  writeSize);\n    }\n\n    void ClientQueueRelease(WGPUQueue cObj) {\n        Queue* obj = reinterpret_cast<Queue*>(cObj);\n\n        if (!obj->Release()) {\n            return;\n        }\n\n        DestroyObjectCmd cmd;\n        cmd.objectType = ObjectType::Queue;\n        cmd.objectId = obj->GetWireId();\n\n        Client* client = obj->GetClient();\n        client->SerializeCommand(cmd);\n        client->Free(obj);\n    }\n\n    void ClientQueueReference(WGPUQueue cObj) {\n        reinterpret_cast<Queue*>(cObj)->Reference();\n    }\n\n\n    void ClientRenderBundleSetLabel(WGPURenderBundle cSelf, char const * label) {\n        auto self = reinterpret_cast<RenderBundle*>(cSelf);\n        RenderBundleSetLabelCmd cmd;\n\n        cmd.self = cSelf;\n\n\n        \n        cmd.label = label;\n\n        self->GetClient()->SerializeCommand(cmd);\n\n    }\n\n    void ClientRenderBundleRelease(WGPURenderBundle cObj) {\n        RenderBundle* obj = reinterpret_cast<RenderBundle*>(cObj);\n\n        if (!obj->Release()) {\n            return;\n        }\n\n        DestroyObjectCmd cmd;\n        cmd.objectType = ObjectType::RenderBundle;\n        cmd.objectId = obj->GetWireId();\n\n        Client* client = obj->GetClient();\n        client->SerializeCommand(cmd);\n        client->Free(obj);\n    }\n\n    void ClientRenderBundleReference(WGPURenderBundle cObj) {\n        reinterpret_cast<RenderBundle*>(cObj)->Reference();\n    }\n\n\n    void ClientRenderBundleEncoderDraw(WGPURenderBundleEncoder cSelf, uint32_t vertexCount, uint32_t instanceCount, uint32_t firstVertex, uint32_t firstInstance) {\n        auto self = reinterpret_cast<RenderBundleEncoder*>(cSelf);\n        RenderBundleEncoderDrawCmd cmd;\n\n        cmd.self = cSelf;\n\n\n        \n        cmd.vertexCount = vertexCount;\n        \n        cmd.instanceCount = instanceCount;\n        \n        cmd.firstVertex = firstVertex;\n        \n        cmd.firstInstance = firstInstance;\n\n        self->GetClient()->SerializeCommand(cmd);\n\n    }\n\n    void ClientRenderBundleEncoderDrawIndexed(WGPURenderBundleEncoder cSelf, uint32_t indexCount, uint32_t instanceCount, uint32_t firstIndex, int32_t baseVertex, uint32_t firstInstance) {\n        auto self = reinterpret_cast<RenderBundleEncoder*>(cSelf);\n        RenderBundleEncoderDrawIndexedCmd cmd;\n\n        cmd.self = cSelf;\n\n\n        \n        cmd.indexCount = indexCount;\n        \n        cmd.instanceCount = instanceCount;\n        \n        cmd.firstIndex = firstIndex;\n        \n        cmd.baseVertex = baseVertex;\n        \n        cmd.firstInstance = firstInstance;\n\n        self->GetClient()->SerializeCommand(cmd);\n\n    }\n\n    void ClientRenderBundleEncoderDrawIndexedIndirect(WGPURenderBundleEncoder cSelf, WGPUBuffer indirectBuffer, uint64_t indirectOffset) {\n        auto self = reinterpret_cast<RenderBundleEncoder*>(cSelf);\n        RenderBundleEncoderDrawIndexedIndirectCmd cmd;\n\n        cmd.self = cSelf;\n\n\n        \n        cmd.indirectBuffer = indirectBuffer;\n        \n        cmd.indirectOffset = indirectOffset;\n\n        self->GetClient()->SerializeCommand(cmd);\n\n    }\n\n    void ClientRenderBundleEncoderDrawIndirect(WGPURenderBundleEncoder cSelf, WGPUBuffer indirectBuffer, uint64_t indirectOffset) {\n        auto self = reinterpret_cast<RenderBundleEncoder*>(cSelf);\n        RenderBundleEncoderDrawIndirectCmd cmd;\n\n        cmd.self = cSelf;\n\n\n        \n        cmd.indirectBuffer = indirectBuffer;\n        \n        cmd.indirectOffset = indirectOffset;\n\n        self->GetClient()->SerializeCommand(cmd);\n\n    }\n\n    WGPURenderBundle ClientRenderBundleEncoderFinish(WGPURenderBundleEncoder cSelf, WGPURenderBundleDescriptor const * descriptor) {\n        auto self = reinterpret_cast<RenderBundleEncoder*>(cSelf);\n        RenderBundleEncoderFinishCmd cmd;\n\n        cmd.self = cSelf;\n\n\n        RenderBundle* returnObject;\n        if constexpr (std::is_constructible_v<RenderBundle, const ObjectBaseParams&, decltype(descriptor)>) {\n            returnObject = self->GetClient()->Make<RenderBundle>(descriptor);\n        } else {\n            returnObject = self->GetClient()->Make<RenderBundle>();\n        }\n        cmd.result = returnObject->GetWireHandle();\n\n        \n        cmd.descriptor = descriptor;\n\n        self->GetClient()->SerializeCommand(cmd);\n\n        return ToAPI(returnObject);\n    }\n\n    void ClientRenderBundleEncoderInsertDebugMarker(WGPURenderBundleEncoder cSelf, char const * markerLabel) {\n        auto self = reinterpret_cast<RenderBundleEncoder*>(cSelf);\n        RenderBundleEncoderInsertDebugMarkerCmd cmd;\n\n        cmd.self = cSelf;\n\n\n        \n        cmd.markerLabel = markerLabel;\n\n        self->GetClient()->SerializeCommand(cmd);\n\n    }\n\n    void ClientRenderBundleEncoderPopDebugGroup(WGPURenderBundleEncoder cSelf) {\n        auto self = reinterpret_cast<RenderBundleEncoder*>(cSelf);\n        RenderBundleEncoderPopDebugGroupCmd cmd;\n\n        cmd.self = cSelf;\n\n\n\n        self->GetClient()->SerializeCommand(cmd);\n\n    }\n\n    void ClientRenderBundleEncoderPushDebugGroup(WGPURenderBundleEncoder cSelf, char const * groupLabel) {\n        auto self = reinterpret_cast<RenderBundleEncoder*>(cSelf);\n        RenderBundleEncoderPushDebugGroupCmd cmd;\n\n        cmd.self = cSelf;\n\n\n        \n        cmd.groupLabel = groupLabel;\n\n        self->GetClient()->SerializeCommand(cmd);\n\n    }\n\n    void ClientRenderBundleEncoderSetBindGroup(WGPURenderBundleEncoder cSelf, uint32_t groupIndex, WGPUBindGroup group, size_t dynamicOffsetCount, uint32_t const * dynamicOffsets) {\n        auto self = reinterpret_cast<RenderBundleEncoder*>(cSelf);\n        RenderBundleEncoderSetBindGroupCmd cmd;\n\n        cmd.self = cSelf;\n\n\n        \n        cmd.groupIndex = groupIndex;\n        \n        cmd.group = group;\n        \n        cmd.dynamicOffsetCount = dynamicOffsetCount;\n        \n        cmd.dynamicOffsets = dynamicOffsets;\n\n        self->GetClient()->SerializeCommand(cmd);\n\n    }\n\n    void ClientRenderBundleEncoderSetIndexBuffer(WGPURenderBundleEncoder cSelf, WGPUBuffer buffer, WGPUIndexFormat format, uint64_t offset, uint64_t size) {\n        auto self = reinterpret_cast<RenderBundleEncoder*>(cSelf);\n        RenderBundleEncoderSetIndexBufferCmd cmd;\n\n        cmd.self = cSelf;\n\n\n        \n        cmd.buffer = buffer;\n        \n        cmd.format = format;\n        \n        cmd.offset = offset;\n        \n        cmd.size = size;\n\n        self->GetClient()->SerializeCommand(cmd);\n\n    }\n\n    void ClientRenderBundleEncoderSetLabel(WGPURenderBundleEncoder cSelf, char const * label) {\n        auto self = reinterpret_cast<RenderBundleEncoder*>(cSelf);\n        RenderBundleEncoderSetLabelCmd cmd;\n\n        cmd.self = cSelf;\n\n\n        \n        cmd.label = label;\n\n        self->GetClient()->SerializeCommand(cmd);\n\n    }\n\n    void ClientRenderBundleEncoderSetPipeline(WGPURenderBundleEncoder cSelf, WGPURenderPipeline pipeline) {\n        auto self = reinterpret_cast<RenderBundleEncoder*>(cSelf);\n        RenderBundleEncoderSetPipelineCmd cmd;\n\n        cmd.self = cSelf;\n\n\n        \n        cmd.pipeline = pipeline;\n\n        self->GetClient()->SerializeCommand(cmd);\n\n    }\n\n    void ClientRenderBundleEncoderSetVertexBuffer(WGPURenderBundleEncoder cSelf, uint32_t slot, WGPUBuffer buffer, uint64_t offset, uint64_t size) {\n        auto self = reinterpret_cast<RenderBundleEncoder*>(cSelf);\n        RenderBundleEncoderSetVertexBufferCmd cmd;\n\n        cmd.self = cSelf;\n\n\n        \n        cmd.slot = slot;\n        \n        cmd.buffer = buffer;\n        \n        cmd.offset = offset;\n        \n        cmd.size = size;\n\n        self->GetClient()->SerializeCommand(cmd);\n\n    }\n\n    void ClientRenderBundleEncoderRelease(WGPURenderBundleEncoder cObj) {\n        RenderBundleEncoder* obj = reinterpret_cast<RenderBundleEncoder*>(cObj);\n\n        if (!obj->Release()) {\n            return;\n        }\n\n        DestroyObjectCmd cmd;\n        cmd.objectType = ObjectType::RenderBundleEncoder;\n        cmd.objectId = obj->GetWireId();\n\n        Client* client = obj->GetClient();\n        client->SerializeCommand(cmd);\n        client->Free(obj);\n    }\n\n    void ClientRenderBundleEncoderReference(WGPURenderBundleEncoder cObj) {\n        reinterpret_cast<RenderBundleEncoder*>(cObj)->Reference();\n    }\n\n\n    void ClientRenderPassEncoderBeginOcclusionQuery(WGPURenderPassEncoder cSelf, uint32_t queryIndex) {\n        auto self = reinterpret_cast<RenderPassEncoder*>(cSelf);\n        RenderPassEncoderBeginOcclusionQueryCmd cmd;\n\n        cmd.self = cSelf;\n\n\n        \n        cmd.queryIndex = queryIndex;\n\n        self->GetClient()->SerializeCommand(cmd);\n\n    }\n\n    void ClientRenderPassEncoderDraw(WGPURenderPassEncoder cSelf, uint32_t vertexCount, uint32_t instanceCount, uint32_t firstVertex, uint32_t firstInstance) {\n        auto self = reinterpret_cast<RenderPassEncoder*>(cSelf);\n        RenderPassEncoderDrawCmd cmd;\n\n        cmd.self = cSelf;\n\n\n        \n        cmd.vertexCount = vertexCount;\n        \n        cmd.instanceCount = instanceCount;\n        \n        cmd.firstVertex = firstVertex;\n        \n        cmd.firstInstance = firstInstance;\n\n        self->GetClient()->SerializeCommand(cmd);\n\n    }\n\n    void ClientRenderPassEncoderDrawIndexed(WGPURenderPassEncoder cSelf, uint32_t indexCount, uint32_t instanceCount, uint32_t firstIndex, int32_t baseVertex, uint32_t firstInstance) {\n        auto self = reinterpret_cast<RenderPassEncoder*>(cSelf);\n        RenderPassEncoderDrawIndexedCmd cmd;\n\n        cmd.self = cSelf;\n\n\n        \n        cmd.indexCount = indexCount;\n        \n        cmd.instanceCount = instanceCount;\n        \n        cmd.firstIndex = firstIndex;\n        \n        cmd.baseVertex = baseVertex;\n        \n        cmd.firstInstance = firstInstance;\n\n        self->GetClient()->SerializeCommand(cmd);\n\n    }\n\n    void ClientRenderPassEncoderDrawIndexedIndirect(WGPURenderPassEncoder cSelf, WGPUBuffer indirectBuffer, uint64_t indirectOffset) {\n        auto self = reinterpret_cast<RenderPassEncoder*>(cSelf);\n        RenderPassEncoderDrawIndexedIndirectCmd cmd;\n\n        cmd.self = cSelf;\n\n\n        \n        cmd.indirectBuffer = indirectBuffer;\n        \n        cmd.indirectOffset = indirectOffset;\n\n        self->GetClient()->SerializeCommand(cmd);\n\n    }\n\n    void ClientRenderPassEncoderDrawIndirect(WGPURenderPassEncoder cSelf, WGPUBuffer indirectBuffer, uint64_t indirectOffset) {\n        auto self = reinterpret_cast<RenderPassEncoder*>(cSelf);\n        RenderPassEncoderDrawIndirectCmd cmd;\n\n        cmd.self = cSelf;\n\n\n        \n        cmd.indirectBuffer = indirectBuffer;\n        \n        cmd.indirectOffset = indirectOffset;\n\n        self->GetClient()->SerializeCommand(cmd);\n\n    }\n\n    void ClientRenderPassEncoderEnd(WGPURenderPassEncoder cSelf) {\n        auto self = reinterpret_cast<RenderPassEncoder*>(cSelf);\n        RenderPassEncoderEndCmd cmd;\n\n        cmd.self = cSelf;\n\n\n\n        self->GetClient()->SerializeCommand(cmd);\n\n    }\n\n    void ClientRenderPassEncoderEndOcclusionQuery(WGPURenderPassEncoder cSelf) {\n        auto self = reinterpret_cast<RenderPassEncoder*>(cSelf);\n        RenderPassEncoderEndOcclusionQueryCmd cmd;\n\n        cmd.self = cSelf;\n\n\n\n        self->GetClient()->SerializeCommand(cmd);\n\n    }\n\n    void ClientRenderPassEncoderExecuteBundles(WGPURenderPassEncoder cSelf, size_t bundleCount, WGPURenderBundle const * bundles) {\n        auto self = reinterpret_cast<RenderPassEncoder*>(cSelf);\n        RenderPassEncoderExecuteBundlesCmd cmd;\n\n        cmd.self = cSelf;\n\n\n        \n        cmd.bundleCount = bundleCount;\n        \n        cmd.bundles = bundles;\n\n        self->GetClient()->SerializeCommand(cmd);\n\n    }\n\n    void ClientRenderPassEncoderInsertDebugMarker(WGPURenderPassEncoder cSelf, char const * markerLabel) {\n        auto self = reinterpret_cast<RenderPassEncoder*>(cSelf);\n        RenderPassEncoderInsertDebugMarkerCmd cmd;\n\n        cmd.self = cSelf;\n\n\n        \n        cmd.markerLabel = markerLabel;\n\n        self->GetClient()->SerializeCommand(cmd);\n\n    }\n\n    void ClientRenderPassEncoderPopDebugGroup(WGPURenderPassEncoder cSelf) {\n        auto self = reinterpret_cast<RenderPassEncoder*>(cSelf);\n        RenderPassEncoderPopDebugGroupCmd cmd;\n\n        cmd.self = cSelf;\n\n\n\n        self->GetClient()->SerializeCommand(cmd);\n\n    }\n\n    void ClientRenderPassEncoderPushDebugGroup(WGPURenderPassEncoder cSelf, char const * groupLabel) {\n        auto self = reinterpret_cast<RenderPassEncoder*>(cSelf);\n        RenderPassEncoderPushDebugGroupCmd cmd;\n\n        cmd.self = cSelf;\n\n\n        \n        cmd.groupLabel = groupLabel;\n\n        self->GetClient()->SerializeCommand(cmd);\n\n    }\n\n    void ClientRenderPassEncoderSetBindGroup(WGPURenderPassEncoder cSelf, uint32_t groupIndex, WGPUBindGroup group, size_t dynamicOffsetCount, uint32_t const * dynamicOffsets) {\n        auto self = reinterpret_cast<RenderPassEncoder*>(cSelf);\n        RenderPassEncoderSetBindGroupCmd cmd;\n\n        cmd.self = cSelf;\n\n\n        \n        cmd.groupIndex = groupIndex;\n        \n        cmd.group = group;\n        \n        cmd.dynamicOffsetCount = dynamicOffsetCount;\n        \n        cmd.dynamicOffsets = dynamicOffsets;\n\n        self->GetClient()->SerializeCommand(cmd);\n\n    }\n\n    void ClientRenderPassEncoderSetBlendConstant(WGPURenderPassEncoder cSelf, WGPUColor const * color) {\n        auto self = reinterpret_cast<RenderPassEncoder*>(cSelf);\n        RenderPassEncoderSetBlendConstantCmd cmd;\n\n        cmd.self = cSelf;\n\n\n        \n        cmd.color = color;\n\n        self->GetClient()->SerializeCommand(cmd);\n\n    }\n\n    void ClientRenderPassEncoderSetIndexBuffer(WGPURenderPassEncoder cSelf, WGPUBuffer buffer, WGPUIndexFormat format, uint64_t offset, uint64_t size) {\n        auto self = reinterpret_cast<RenderPassEncoder*>(cSelf);\n        RenderPassEncoderSetIndexBufferCmd cmd;\n\n        cmd.self = cSelf;\n\n\n        \n        cmd.buffer = buffer;\n        \n        cmd.format = format;\n        \n        cmd.offset = offset;\n        \n        cmd.size = size;\n\n        self->GetClient()->SerializeCommand(cmd);\n\n    }\n\n    void ClientRenderPassEncoderSetLabel(WGPURenderPassEncoder cSelf, char const * label) {\n        auto self = reinterpret_cast<RenderPassEncoder*>(cSelf);\n        RenderPassEncoderSetLabelCmd cmd;\n\n        cmd.self = cSelf;\n\n\n        \n        cmd.label = label;\n\n        self->GetClient()->SerializeCommand(cmd);\n\n    }\n\n    void ClientRenderPassEncoderSetPipeline(WGPURenderPassEncoder cSelf, WGPURenderPipeline pipeline) {\n        auto self = reinterpret_cast<RenderPassEncoder*>(cSelf);\n        RenderPassEncoderSetPipelineCmd cmd;\n\n        cmd.self = cSelf;\n\n\n        \n        cmd.pipeline = pipeline;\n\n        self->GetClient()->SerializeCommand(cmd);\n\n    }\n\n    void ClientRenderPassEncoderSetScissorRect(WGPURenderPassEncoder cSelf, uint32_t x, uint32_t y, uint32_t width, uint32_t height) {\n        auto self = reinterpret_cast<RenderPassEncoder*>(cSelf);\n        RenderPassEncoderSetScissorRectCmd cmd;\n\n        cmd.self = cSelf;\n\n\n        \n        cmd.x = x;\n        \n        cmd.y = y;\n        \n        cmd.width = width;\n        \n        cmd.height = height;\n\n        self->GetClient()->SerializeCommand(cmd);\n\n    }\n\n    void ClientRenderPassEncoderSetStencilReference(WGPURenderPassEncoder cSelf, uint32_t reference) {\n        auto self = reinterpret_cast<RenderPassEncoder*>(cSelf);\n        RenderPassEncoderSetStencilReferenceCmd cmd;\n\n        cmd.self = cSelf;\n\n\n        \n        cmd.reference = reference;\n\n        self->GetClient()->SerializeCommand(cmd);\n\n    }\n\n    void ClientRenderPassEncoderSetVertexBuffer(WGPURenderPassEncoder cSelf, uint32_t slot, WGPUBuffer buffer, uint64_t offset, uint64_t size) {\n        auto self = reinterpret_cast<RenderPassEncoder*>(cSelf);\n        RenderPassEncoderSetVertexBufferCmd cmd;\n\n        cmd.self = cSelf;\n\n\n        \n        cmd.slot = slot;\n        \n        cmd.buffer = buffer;\n        \n        cmd.offset = offset;\n        \n        cmd.size = size;\n\n        self->GetClient()->SerializeCommand(cmd);\n\n    }\n\n    void ClientRenderPassEncoderSetViewport(WGPURenderPassEncoder cSelf, float x, float y, float width, float height, float minDepth, float maxDepth) {\n        auto self = reinterpret_cast<RenderPassEncoder*>(cSelf);\n        RenderPassEncoderSetViewportCmd cmd;\n\n        cmd.self = cSelf;\n\n\n        \n        cmd.x = x;\n        \n        cmd.y = y;\n        \n        cmd.width = width;\n        \n        cmd.height = height;\n        \n        cmd.minDepth = minDepth;\n        \n        cmd.maxDepth = maxDepth;\n\n        self->GetClient()->SerializeCommand(cmd);\n\n    }\n\n    void ClientRenderPassEncoderWriteTimestamp(WGPURenderPassEncoder cSelf, WGPUQuerySet querySet, uint32_t queryIndex) {\n        auto self = reinterpret_cast<RenderPassEncoder*>(cSelf);\n        RenderPassEncoderWriteTimestampCmd cmd;\n\n        cmd.self = cSelf;\n\n\n        \n        cmd.querySet = querySet;\n        \n        cmd.queryIndex = queryIndex;\n\n        self->GetClient()->SerializeCommand(cmd);\n\n    }\n\n    void ClientRenderPassEncoderRelease(WGPURenderPassEncoder cObj) {\n        RenderPassEncoder* obj = reinterpret_cast<RenderPassEncoder*>(cObj);\n\n        if (!obj->Release()) {\n            return;\n        }\n\n        DestroyObjectCmd cmd;\n        cmd.objectType = ObjectType::RenderPassEncoder;\n        cmd.objectId = obj->GetWireId();\n\n        Client* client = obj->GetClient();\n        client->SerializeCommand(cmd);\n        client->Free(obj);\n    }\n\n    void ClientRenderPassEncoderReference(WGPURenderPassEncoder cObj) {\n        reinterpret_cast<RenderPassEncoder*>(cObj)->Reference();\n    }\n\n\n    WGPUBindGroupLayout ClientRenderPipelineGetBindGroupLayout(WGPURenderPipeline cSelf, uint32_t groupIndex) {\n        auto self = reinterpret_cast<RenderPipeline*>(cSelf);\n        RenderPipelineGetBindGroupLayoutCmd cmd;\n\n        cmd.self = cSelf;\n\n\n        BindGroupLayout* returnObject;\n        if constexpr (std::is_constructible_v<BindGroupLayout, const ObjectBaseParams&, decltype(groupIndex)>) {\n            returnObject = self->GetClient()->Make<BindGroupLayout>(groupIndex);\n        } else {\n            returnObject = self->GetClient()->Make<BindGroupLayout>();\n        }\n        cmd.result = returnObject->GetWireHandle();\n\n        \n        cmd.groupIndex = groupIndex;\n\n        self->GetClient()->SerializeCommand(cmd);\n\n        return ToAPI(returnObject);\n    }\n\n    void ClientRenderPipelineSetLabel(WGPURenderPipeline cSelf, char const * label) {\n        auto self = reinterpret_cast<RenderPipeline*>(cSelf);\n        RenderPipelineSetLabelCmd cmd;\n\n        cmd.self = cSelf;\n\n\n        \n        cmd.label = label;\n\n        self->GetClient()->SerializeCommand(cmd);\n\n    }\n\n    void ClientRenderPipelineRelease(WGPURenderPipeline cObj) {\n        RenderPipeline* obj = reinterpret_cast<RenderPipeline*>(cObj);\n\n        if (!obj->Release()) {\n            return;\n        }\n\n        DestroyObjectCmd cmd;\n        cmd.objectType = ObjectType::RenderPipeline;\n        cmd.objectId = obj->GetWireId();\n\n        Client* client = obj->GetClient();\n        client->SerializeCommand(cmd);\n        client->Free(obj);\n    }\n\n    void ClientRenderPipelineReference(WGPURenderPipeline cObj) {\n        reinterpret_cast<RenderPipeline*>(cObj)->Reference();\n    }\n\n\n    void ClientSamplerSetLabel(WGPUSampler cSelf, char const * label) {\n        auto self = reinterpret_cast<Sampler*>(cSelf);\n        SamplerSetLabelCmd cmd;\n\n        cmd.self = cSelf;\n\n\n        \n        cmd.label = label;\n\n        self->GetClient()->SerializeCommand(cmd);\n\n    }\n\n    void ClientSamplerRelease(WGPUSampler cObj) {\n        Sampler* obj = reinterpret_cast<Sampler*>(cObj);\n\n        if (!obj->Release()) {\n            return;\n        }\n\n        DestroyObjectCmd cmd;\n        cmd.objectType = ObjectType::Sampler;\n        cmd.objectId = obj->GetWireId();\n\n        Client* client = obj->GetClient();\n        client->SerializeCommand(cmd);\n        client->Free(obj);\n    }\n\n    void ClientSamplerReference(WGPUSampler cObj) {\n        reinterpret_cast<Sampler*>(cObj)->Reference();\n    }\n\n\n    static\n    void ClientShaderModuleGetCompilationInfo(WGPUShaderModule cSelf, WGPUCompilationInfoCallback callback, void * userdata) {\n        auto self = reinterpret_cast<ShaderModule*>(cSelf);\n        return self->GetCompilationInfo( callback,  userdata);\n    }\n\n    void ClientShaderModuleSetLabel(WGPUShaderModule cSelf, char const * label) {\n        auto self = reinterpret_cast<ShaderModule*>(cSelf);\n        ShaderModuleSetLabelCmd cmd;\n\n        cmd.self = cSelf;\n\n\n        \n        cmd.label = label;\n\n        self->GetClient()->SerializeCommand(cmd);\n\n    }\n\n    void ClientShaderModuleRelease(WGPUShaderModule cObj) {\n        ShaderModule* obj = reinterpret_cast<ShaderModule*>(cObj);\n\n        if (!obj->Release()) {\n            return;\n        }\n\n        DestroyObjectCmd cmd;\n        cmd.objectType = ObjectType::ShaderModule;\n        cmd.objectId = obj->GetWireId();\n\n        Client* client = obj->GetClient();\n        client->SerializeCommand(cmd);\n        client->Free(obj);\n    }\n\n    void ClientShaderModuleReference(WGPUShaderModule cObj) {\n        reinterpret_cast<ShaderModule*>(cObj)->Reference();\n    }\n\n\n    void ClientSurfaceRelease(WGPUSurface cObj) {\n        Surface* obj = reinterpret_cast<Surface*>(cObj);\n\n        if (!obj->Release()) {\n            return;\n        }\n\n        DestroyObjectCmd cmd;\n        cmd.objectType = ObjectType::Surface;\n        cmd.objectId = obj->GetWireId();\n\n        Client* client = obj->GetClient();\n        client->SerializeCommand(cmd);\n        client->Free(obj);\n    }\n\n    void ClientSurfaceReference(WGPUSurface cObj) {\n        reinterpret_cast<Surface*>(cObj)->Reference();\n    }\n\n\n    static\n    WGPUTexture ClientSwapChainGetCurrentTexture(WGPUSwapChain cSelf) {\n        auto self = reinterpret_cast<SwapChain*>(cSelf);\n        return self->GetCurrentTexture();\n    }\n\n    WGPUTextureView ClientSwapChainGetCurrentTextureView(WGPUSwapChain cSelf) {\n        auto self = reinterpret_cast<SwapChain*>(cSelf);\n        SwapChainGetCurrentTextureViewCmd cmd;\n\n        cmd.self = cSelf;\n\n\n        TextureView* returnObject;\n        if constexpr (std::is_constructible_v<TextureView, const ObjectBaseParams&>) {\n            returnObject = self->GetClient()->Make<TextureView>();\n        } else {\n            returnObject = self->GetClient()->Make<TextureView>();\n        }\n        cmd.result = returnObject->GetWireHandle();\n\n\n        self->GetClient()->SerializeCommand(cmd);\n\n        return ToAPI(returnObject);\n    }\n\n    void ClientSwapChainPresent(WGPUSwapChain cSelf) {\n        auto self = reinterpret_cast<SwapChain*>(cSelf);\n        SwapChainPresentCmd cmd;\n\n        cmd.self = cSelf;\n\n\n\n        self->GetClient()->SerializeCommand(cmd);\n\n    }\n\n    void ClientSwapChainRelease(WGPUSwapChain cObj) {\n        SwapChain* obj = reinterpret_cast<SwapChain*>(cObj);\n\n        if (!obj->Release()) {\n            return;\n        }\n\n        DestroyObjectCmd cmd;\n        cmd.objectType = ObjectType::SwapChain;\n        cmd.objectId = obj->GetWireId();\n\n        Client* client = obj->GetClient();\n        client->SerializeCommand(cmd);\n        client->Free(obj);\n    }\n\n    void ClientSwapChainReference(WGPUSwapChain cObj) {\n        reinterpret_cast<SwapChain*>(cObj)->Reference();\n    }\n\n\n    WGPUTextureView ClientTextureCreateView(WGPUTexture cSelf, WGPUTextureViewDescriptor const * descriptor) {\n        auto self = reinterpret_cast<Texture*>(cSelf);\n        TextureCreateViewCmd cmd;\n\n        cmd.self = cSelf;\n\n\n        TextureView* returnObject;\n        if constexpr (std::is_constructible_v<TextureView, const ObjectBaseParams&, decltype(descriptor)>) {\n            returnObject = self->GetClient()->Make<TextureView>(descriptor);\n        } else {\n            returnObject = self->GetClient()->Make<TextureView>();\n        }\n        cmd.result = returnObject->GetWireHandle();\n\n        \n        cmd.descriptor = descriptor;\n\n        self->GetClient()->SerializeCommand(cmd);\n\n        return ToAPI(returnObject);\n    }\n\n    void ClientTextureDestroy(WGPUTexture cSelf) {\n        auto self = reinterpret_cast<Texture*>(cSelf);\n        TextureDestroyCmd cmd;\n\n        cmd.self = cSelf;\n\n\n\n        self->GetClient()->SerializeCommand(cmd);\n\n    }\n\n    static\n    uint32_t ClientTextureGetDepthOrArrayLayers(WGPUTexture cSelf) {\n        auto self = reinterpret_cast<Texture*>(cSelf);\n        return self->GetDepthOrArrayLayers();\n    }\n\n    static\n    WGPUTextureDimension ClientTextureGetDimension(WGPUTexture cSelf) {\n        auto self = reinterpret_cast<Texture*>(cSelf);\n        return self->GetDimension();\n    }\n\n    static\n    WGPUTextureFormat ClientTextureGetFormat(WGPUTexture cSelf) {\n        auto self = reinterpret_cast<Texture*>(cSelf);\n        return self->GetFormat();\n    }\n\n    static\n    uint32_t ClientTextureGetHeight(WGPUTexture cSelf) {\n        auto self = reinterpret_cast<Texture*>(cSelf);\n        return self->GetHeight();\n    }\n\n    static\n    uint32_t ClientTextureGetMipLevelCount(WGPUTexture cSelf) {\n        auto self = reinterpret_cast<Texture*>(cSelf);\n        return self->GetMipLevelCount();\n    }\n\n    static\n    uint32_t ClientTextureGetSampleCount(WGPUTexture cSelf) {\n        auto self = reinterpret_cast<Texture*>(cSelf);\n        return self->GetSampleCount();\n    }\n\n    static\n    WGPUTextureUsageFlags ClientTextureGetUsage(WGPUTexture cSelf) {\n        auto self = reinterpret_cast<Texture*>(cSelf);\n        return self->GetUsage();\n    }\n\n    static\n    uint32_t ClientTextureGetWidth(WGPUTexture cSelf) {\n        auto self = reinterpret_cast<Texture*>(cSelf);\n        return self->GetWidth();\n    }\n\n    void ClientTextureSetLabel(WGPUTexture cSelf, char const * label) {\n        auto self = reinterpret_cast<Texture*>(cSelf);\n        TextureSetLabelCmd cmd;\n\n        cmd.self = cSelf;\n\n\n        \n        cmd.label = label;\n\n        self->GetClient()->SerializeCommand(cmd);\n\n    }\n\n    void ClientTextureRelease(WGPUTexture cObj) {\n        Texture* obj = reinterpret_cast<Texture*>(cObj);\n\n        if (!obj->Release()) {\n            return;\n        }\n\n        DestroyObjectCmd cmd;\n        cmd.objectType = ObjectType::Texture;\n        cmd.objectId = obj->GetWireId();\n\n        Client* client = obj->GetClient();\n        client->SerializeCommand(cmd);\n        client->Free(obj);\n    }\n\n    void ClientTextureReference(WGPUTexture cObj) {\n        reinterpret_cast<Texture*>(cObj)->Reference();\n    }\n\n\n    void ClientTextureViewSetLabel(WGPUTextureView cSelf, char const * label) {\n        auto self = reinterpret_cast<TextureView*>(cSelf);\n        TextureViewSetLabelCmd cmd;\n\n        cmd.self = cSelf;\n\n\n        \n        cmd.label = label;\n\n        self->GetClient()->SerializeCommand(cmd);\n\n    }\n\n    void ClientTextureViewRelease(WGPUTextureView cObj) {\n        TextureView* obj = reinterpret_cast<TextureView*>(cObj);\n\n        if (!obj->Release()) {\n            return;\n        }\n\n        DestroyObjectCmd cmd;\n        cmd.objectType = ObjectType::TextureView;\n        cmd.objectId = obj->GetWireId();\n\n        Client* client = obj->GetClient();\n        client->SerializeCommand(cmd);\n        client->Free(obj);\n    }\n\n    void ClientTextureViewReference(WGPUTextureView cObj) {\n        reinterpret_cast<TextureView*>(cObj)->Reference();\n    }\n\n    namespace {\n        WGPUInstance ClientCreateInstance(WGPUInstanceDescriptor const* descriptor) {\n            UNREACHABLE();\n            return nullptr;\n        }\n\n        struct ProcEntry {\n            WGPUProc proc;\n            const char* name;\n        };\n        static const ProcEntry sProcMap[] = {\n            { reinterpret_cast<WGPUProc>(ClientAdapterCreateDevice), \"wgpuAdapterCreateDevice\" },\n            { reinterpret_cast<WGPUProc>(ClientAdapterEnumerateFeatures), \"wgpuAdapterEnumerateFeatures\" },\n            { reinterpret_cast<WGPUProc>(ClientAdapterGetInstance), \"wgpuAdapterGetInstance\" },\n            { reinterpret_cast<WGPUProc>(ClientAdapterGetLimits), \"wgpuAdapterGetLimits\" },\n            { reinterpret_cast<WGPUProc>(ClientAdapterGetProperties), \"wgpuAdapterGetProperties\" },\n            { reinterpret_cast<WGPUProc>(ClientAdapterHasFeature), \"wgpuAdapterHasFeature\" },\n            { reinterpret_cast<WGPUProc>(ClientAdapterReference), \"wgpuAdapterReference\" },\n            { reinterpret_cast<WGPUProc>(ClientAdapterRelease), \"wgpuAdapterRelease\" },\n            { reinterpret_cast<WGPUProc>(ClientAdapterRequestDevice), \"wgpuAdapterRequestDevice\" },\n            { reinterpret_cast<WGPUProc>(ClientBindGroupLayoutReference), \"wgpuBindGroupLayoutReference\" },\n            { reinterpret_cast<WGPUProc>(ClientBindGroupLayoutRelease), \"wgpuBindGroupLayoutRelease\" },\n            { reinterpret_cast<WGPUProc>(ClientBindGroupLayoutSetLabel), \"wgpuBindGroupLayoutSetLabel\" },\n            { reinterpret_cast<WGPUProc>(ClientBindGroupReference), \"wgpuBindGroupReference\" },\n            { reinterpret_cast<WGPUProc>(ClientBindGroupRelease), \"wgpuBindGroupRelease\" },\n            { reinterpret_cast<WGPUProc>(ClientBindGroupSetLabel), \"wgpuBindGroupSetLabel\" },\n            { reinterpret_cast<WGPUProc>(ClientBufferDestroy), \"wgpuBufferDestroy\" },\n            { reinterpret_cast<WGPUProc>(ClientBufferGetConstMappedRange), \"wgpuBufferGetConstMappedRange\" },\n            { reinterpret_cast<WGPUProc>(ClientBufferGetMapState), \"wgpuBufferGetMapState\" },\n            { reinterpret_cast<WGPUProc>(ClientBufferGetMappedRange), \"wgpuBufferGetMappedRange\" },\n            { reinterpret_cast<WGPUProc>(ClientBufferGetSize), \"wgpuBufferGetSize\" },\n            { reinterpret_cast<WGPUProc>(ClientBufferGetUsage), \"wgpuBufferGetUsage\" },\n            { reinterpret_cast<WGPUProc>(ClientBufferMapAsync), \"wgpuBufferMapAsync\" },\n            { reinterpret_cast<WGPUProc>(ClientBufferReference), \"wgpuBufferReference\" },\n            { reinterpret_cast<WGPUProc>(ClientBufferRelease), \"wgpuBufferRelease\" },\n            { reinterpret_cast<WGPUProc>(ClientBufferSetLabel), \"wgpuBufferSetLabel\" },\n            { reinterpret_cast<WGPUProc>(ClientBufferUnmap), \"wgpuBufferUnmap\" },\n            { reinterpret_cast<WGPUProc>(ClientCommandBufferReference), \"wgpuCommandBufferReference\" },\n            { reinterpret_cast<WGPUProc>(ClientCommandBufferRelease), \"wgpuCommandBufferRelease\" },\n            { reinterpret_cast<WGPUProc>(ClientCommandBufferSetLabel), \"wgpuCommandBufferSetLabel\" },\n            { reinterpret_cast<WGPUProc>(ClientCommandEncoderBeginComputePass), \"wgpuCommandEncoderBeginComputePass\" },\n            { reinterpret_cast<WGPUProc>(ClientCommandEncoderBeginRenderPass), \"wgpuCommandEncoderBeginRenderPass\" },\n            { reinterpret_cast<WGPUProc>(ClientCommandEncoderClearBuffer), \"wgpuCommandEncoderClearBuffer\" },\n            { reinterpret_cast<WGPUProc>(ClientCommandEncoderCopyBufferToBuffer), \"wgpuCommandEncoderCopyBufferToBuffer\" },\n            { reinterpret_cast<WGPUProc>(ClientCommandEncoderCopyBufferToTexture), \"wgpuCommandEncoderCopyBufferToTexture\" },\n            { reinterpret_cast<WGPUProc>(ClientCommandEncoderCopyTextureToBuffer), \"wgpuCommandEncoderCopyTextureToBuffer\" },\n            { reinterpret_cast<WGPUProc>(ClientCommandEncoderCopyTextureToTexture), \"wgpuCommandEncoderCopyTextureToTexture\" },\n            { reinterpret_cast<WGPUProc>(ClientCommandEncoderCopyTextureToTextureInternal), \"wgpuCommandEncoderCopyTextureToTextureInternal\" },\n            { reinterpret_cast<WGPUProc>(ClientCommandEncoderFinish), \"wgpuCommandEncoderFinish\" },\n            { reinterpret_cast<WGPUProc>(ClientCommandEncoderInjectValidationError), \"wgpuCommandEncoderInjectValidationError\" },\n            { reinterpret_cast<WGPUProc>(ClientCommandEncoderInsertDebugMarker), \"wgpuCommandEncoderInsertDebugMarker\" },\n            { reinterpret_cast<WGPUProc>(ClientCommandEncoderPopDebugGroup), \"wgpuCommandEncoderPopDebugGroup\" },\n            { reinterpret_cast<WGPUProc>(ClientCommandEncoderPushDebugGroup), \"wgpuCommandEncoderPushDebugGroup\" },\n            { reinterpret_cast<WGPUProc>(ClientCommandEncoderReference), \"wgpuCommandEncoderReference\" },\n            { reinterpret_cast<WGPUProc>(ClientCommandEncoderRelease), \"wgpuCommandEncoderRelease\" },\n            { reinterpret_cast<WGPUProc>(ClientCommandEncoderResolveQuerySet), \"wgpuCommandEncoderResolveQuerySet\" },\n            { reinterpret_cast<WGPUProc>(ClientCommandEncoderSetLabel), \"wgpuCommandEncoderSetLabel\" },\n            { reinterpret_cast<WGPUProc>(ClientCommandEncoderWriteBuffer), \"wgpuCommandEncoderWriteBuffer\" },\n            { reinterpret_cast<WGPUProc>(ClientCommandEncoderWriteTimestamp), \"wgpuCommandEncoderWriteTimestamp\" },\n            { reinterpret_cast<WGPUProc>(ClientComputePassEncoderDispatchWorkgroups), \"wgpuComputePassEncoderDispatchWorkgroups\" },\n            { reinterpret_cast<WGPUProc>(ClientComputePassEncoderDispatchWorkgroupsIndirect), \"wgpuComputePassEncoderDispatchWorkgroupsIndirect\" },\n            { reinterpret_cast<WGPUProc>(ClientComputePassEncoderEnd), \"wgpuComputePassEncoderEnd\" },\n            { reinterpret_cast<WGPUProc>(ClientComputePassEncoderInsertDebugMarker), \"wgpuComputePassEncoderInsertDebugMarker\" },\n            { reinterpret_cast<WGPUProc>(ClientComputePassEncoderPopDebugGroup), \"wgpuComputePassEncoderPopDebugGroup\" },\n            { reinterpret_cast<WGPUProc>(ClientComputePassEncoderPushDebugGroup), \"wgpuComputePassEncoderPushDebugGroup\" },\n            { reinterpret_cast<WGPUProc>(ClientComputePassEncoderReference), \"wgpuComputePassEncoderReference\" },\n            { reinterpret_cast<WGPUProc>(ClientComputePassEncoderRelease), \"wgpuComputePassEncoderRelease\" },\n            { reinterpret_cast<WGPUProc>(ClientComputePassEncoderSetBindGroup), \"wgpuComputePassEncoderSetBindGroup\" },\n            { reinterpret_cast<WGPUProc>(ClientComputePassEncoderSetLabel), \"wgpuComputePassEncoderSetLabel\" },\n            { reinterpret_cast<WGPUProc>(ClientComputePassEncoderSetPipeline), \"wgpuComputePassEncoderSetPipeline\" },\n            { reinterpret_cast<WGPUProc>(ClientComputePassEncoderWriteTimestamp), \"wgpuComputePassEncoderWriteTimestamp\" },\n            { reinterpret_cast<WGPUProc>(ClientComputePipelineGetBindGroupLayout), \"wgpuComputePipelineGetBindGroupLayout\" },\n            { reinterpret_cast<WGPUProc>(ClientComputePipelineReference), \"wgpuComputePipelineReference\" },\n            { reinterpret_cast<WGPUProc>(ClientComputePipelineRelease), \"wgpuComputePipelineRelease\" },\n            { reinterpret_cast<WGPUProc>(ClientComputePipelineSetLabel), \"wgpuComputePipelineSetLabel\" },\n            { reinterpret_cast<WGPUProc>(ClientDeviceCreateBindGroup), \"wgpuDeviceCreateBindGroup\" },\n            { reinterpret_cast<WGPUProc>(ClientDeviceCreateBindGroupLayout), \"wgpuDeviceCreateBindGroupLayout\" },\n            { reinterpret_cast<WGPUProc>(ClientDeviceCreateBuffer), \"wgpuDeviceCreateBuffer\" },\n            { reinterpret_cast<WGPUProc>(ClientDeviceCreateCommandEncoder), \"wgpuDeviceCreateCommandEncoder\" },\n            { reinterpret_cast<WGPUProc>(ClientDeviceCreateComputePipeline), \"wgpuDeviceCreateComputePipeline\" },\n            { reinterpret_cast<WGPUProc>(ClientDeviceCreateComputePipelineAsync), \"wgpuDeviceCreateComputePipelineAsync\" },\n            { reinterpret_cast<WGPUProc>(ClientDeviceCreateErrorBuffer), \"wgpuDeviceCreateErrorBuffer\" },\n            { reinterpret_cast<WGPUProc>(ClientDeviceCreateErrorExternalTexture), \"wgpuDeviceCreateErrorExternalTexture\" },\n            { reinterpret_cast<WGPUProc>(ClientDeviceCreateErrorShaderModule), \"wgpuDeviceCreateErrorShaderModule\" },\n            { reinterpret_cast<WGPUProc>(ClientDeviceCreateErrorTexture), \"wgpuDeviceCreateErrorTexture\" },\n            { reinterpret_cast<WGPUProc>(ClientDeviceCreateExternalTexture), \"wgpuDeviceCreateExternalTexture\" },\n            { reinterpret_cast<WGPUProc>(ClientDeviceCreatePipelineLayout), \"wgpuDeviceCreatePipelineLayout\" },\n            { reinterpret_cast<WGPUProc>(ClientDeviceCreateQuerySet), \"wgpuDeviceCreateQuerySet\" },\n            { reinterpret_cast<WGPUProc>(ClientDeviceCreateRenderBundleEncoder), \"wgpuDeviceCreateRenderBundleEncoder\" },\n            { reinterpret_cast<WGPUProc>(ClientDeviceCreateRenderPipeline), \"wgpuDeviceCreateRenderPipeline\" },\n            { reinterpret_cast<WGPUProc>(ClientDeviceCreateRenderPipelineAsync), \"wgpuDeviceCreateRenderPipelineAsync\" },\n            { reinterpret_cast<WGPUProc>(ClientDeviceCreateSampler), \"wgpuDeviceCreateSampler\" },\n            { reinterpret_cast<WGPUProc>(ClientDeviceCreateShaderModule), \"wgpuDeviceCreateShaderModule\" },\n            { reinterpret_cast<WGPUProc>(ClientDeviceCreateSwapChain), \"wgpuDeviceCreateSwapChain\" },\n            { reinterpret_cast<WGPUProc>(ClientDeviceCreateTexture), \"wgpuDeviceCreateTexture\" },\n            { reinterpret_cast<WGPUProc>(ClientDeviceDestroy), \"wgpuDeviceDestroy\" },\n            { reinterpret_cast<WGPUProc>(ClientDeviceEnumerateFeatures), \"wgpuDeviceEnumerateFeatures\" },\n            { reinterpret_cast<WGPUProc>(ClientDeviceForceLoss), \"wgpuDeviceForceLoss\" },\n            { reinterpret_cast<WGPUProc>(ClientDeviceGetAdapter), \"wgpuDeviceGetAdapter\" },\n            { reinterpret_cast<WGPUProc>(ClientDeviceGetLimits), \"wgpuDeviceGetLimits\" },\n            { reinterpret_cast<WGPUProc>(ClientDeviceGetQueue), \"wgpuDeviceGetQueue\" },\n            { reinterpret_cast<WGPUProc>(ClientDeviceGetSupportedSurfaceUsage), \"wgpuDeviceGetSupportedSurfaceUsage\" },\n            { reinterpret_cast<WGPUProc>(ClientDeviceHasFeature), \"wgpuDeviceHasFeature\" },\n            { reinterpret_cast<WGPUProc>(ClientDeviceInjectError), \"wgpuDeviceInjectError\" },\n            { reinterpret_cast<WGPUProc>(ClientDevicePopErrorScope), \"wgpuDevicePopErrorScope\" },\n            { reinterpret_cast<WGPUProc>(ClientDevicePushErrorScope), \"wgpuDevicePushErrorScope\" },\n            { reinterpret_cast<WGPUProc>(ClientDeviceReference), \"wgpuDeviceReference\" },\n            { reinterpret_cast<WGPUProc>(ClientDeviceRelease), \"wgpuDeviceRelease\" },\n            { reinterpret_cast<WGPUProc>(ClientDeviceSetDeviceLostCallback), \"wgpuDeviceSetDeviceLostCallback\" },\n            { reinterpret_cast<WGPUProc>(ClientDeviceSetLabel), \"wgpuDeviceSetLabel\" },\n            { reinterpret_cast<WGPUProc>(ClientDeviceSetLoggingCallback), \"wgpuDeviceSetLoggingCallback\" },\n            { reinterpret_cast<WGPUProc>(ClientDeviceSetUncapturedErrorCallback), \"wgpuDeviceSetUncapturedErrorCallback\" },\n            { reinterpret_cast<WGPUProc>(ClientDeviceTick), \"wgpuDeviceTick\" },\n            { reinterpret_cast<WGPUProc>(ClientDeviceValidateTextureDescriptor), \"wgpuDeviceValidateTextureDescriptor\" },\n            { reinterpret_cast<WGPUProc>(ClientExternalTextureDestroy), \"wgpuExternalTextureDestroy\" },\n            { reinterpret_cast<WGPUProc>(ClientExternalTextureExpire), \"wgpuExternalTextureExpire\" },\n            { reinterpret_cast<WGPUProc>(ClientExternalTextureReference), \"wgpuExternalTextureReference\" },\n            { reinterpret_cast<WGPUProc>(ClientExternalTextureRefresh), \"wgpuExternalTextureRefresh\" },\n            { reinterpret_cast<WGPUProc>(ClientExternalTextureRelease), \"wgpuExternalTextureRelease\" },\n            { reinterpret_cast<WGPUProc>(ClientExternalTextureSetLabel), \"wgpuExternalTextureSetLabel\" },\n            { reinterpret_cast<WGPUProc>(ClientInstanceCreateSurface), \"wgpuInstanceCreateSurface\" },\n            { reinterpret_cast<WGPUProc>(ClientInstanceProcessEvents), \"wgpuInstanceProcessEvents\" },\n            { reinterpret_cast<WGPUProc>(ClientInstanceReference), \"wgpuInstanceReference\" },\n            { reinterpret_cast<WGPUProc>(ClientInstanceRelease), \"wgpuInstanceRelease\" },\n            { reinterpret_cast<WGPUProc>(ClientInstanceRequestAdapter), \"wgpuInstanceRequestAdapter\" },\n            { reinterpret_cast<WGPUProc>(ClientPipelineLayoutReference), \"wgpuPipelineLayoutReference\" },\n            { reinterpret_cast<WGPUProc>(ClientPipelineLayoutRelease), \"wgpuPipelineLayoutRelease\" },\n            { reinterpret_cast<WGPUProc>(ClientPipelineLayoutSetLabel), \"wgpuPipelineLayoutSetLabel\" },\n            { reinterpret_cast<WGPUProc>(ClientQuerySetDestroy), \"wgpuQuerySetDestroy\" },\n            { reinterpret_cast<WGPUProc>(ClientQuerySetGetCount), \"wgpuQuerySetGetCount\" },\n            { reinterpret_cast<WGPUProc>(ClientQuerySetGetType), \"wgpuQuerySetGetType\" },\n            { reinterpret_cast<WGPUProc>(ClientQuerySetReference), \"wgpuQuerySetReference\" },\n            { reinterpret_cast<WGPUProc>(ClientQuerySetRelease), \"wgpuQuerySetRelease\" },\n            { reinterpret_cast<WGPUProc>(ClientQuerySetSetLabel), \"wgpuQuerySetSetLabel\" },\n            { reinterpret_cast<WGPUProc>(ClientQueueCopyExternalTextureForBrowser), \"wgpuQueueCopyExternalTextureForBrowser\" },\n            { reinterpret_cast<WGPUProc>(ClientQueueCopyTextureForBrowser), \"wgpuQueueCopyTextureForBrowser\" },\n            { reinterpret_cast<WGPUProc>(ClientQueueOnSubmittedWorkDone), \"wgpuQueueOnSubmittedWorkDone\" },\n            { reinterpret_cast<WGPUProc>(ClientQueueReference), \"wgpuQueueReference\" },\n            { reinterpret_cast<WGPUProc>(ClientQueueRelease), \"wgpuQueueRelease\" },\n            { reinterpret_cast<WGPUProc>(ClientQueueSetLabel), \"wgpuQueueSetLabel\" },\n            { reinterpret_cast<WGPUProc>(ClientQueueSubmit), \"wgpuQueueSubmit\" },\n            { reinterpret_cast<WGPUProc>(ClientQueueWriteBuffer), \"wgpuQueueWriteBuffer\" },\n            { reinterpret_cast<WGPUProc>(ClientQueueWriteTexture), \"wgpuQueueWriteTexture\" },\n            { reinterpret_cast<WGPUProc>(ClientRenderBundleEncoderDraw), \"wgpuRenderBundleEncoderDraw\" },\n            { reinterpret_cast<WGPUProc>(ClientRenderBundleEncoderDrawIndexed), \"wgpuRenderBundleEncoderDrawIndexed\" },\n            { reinterpret_cast<WGPUProc>(ClientRenderBundleEncoderDrawIndexedIndirect), \"wgpuRenderBundleEncoderDrawIndexedIndirect\" },\n            { reinterpret_cast<WGPUProc>(ClientRenderBundleEncoderDrawIndirect), \"wgpuRenderBundleEncoderDrawIndirect\" },\n            { reinterpret_cast<WGPUProc>(ClientRenderBundleEncoderFinish), \"wgpuRenderBundleEncoderFinish\" },\n            { reinterpret_cast<WGPUProc>(ClientRenderBundleEncoderInsertDebugMarker), \"wgpuRenderBundleEncoderInsertDebugMarker\" },\n            { reinterpret_cast<WGPUProc>(ClientRenderBundleEncoderPopDebugGroup), \"wgpuRenderBundleEncoderPopDebugGroup\" },\n            { reinterpret_cast<WGPUProc>(ClientRenderBundleEncoderPushDebugGroup), \"wgpuRenderBundleEncoderPushDebugGroup\" },\n            { reinterpret_cast<WGPUProc>(ClientRenderBundleEncoderReference), \"wgpuRenderBundleEncoderReference\" },\n            { reinterpret_cast<WGPUProc>(ClientRenderBundleEncoderRelease), \"wgpuRenderBundleEncoderRelease\" },\n            { reinterpret_cast<WGPUProc>(ClientRenderBundleEncoderSetBindGroup), \"wgpuRenderBundleEncoderSetBindGroup\" },\n            { reinterpret_cast<WGPUProc>(ClientRenderBundleEncoderSetIndexBuffer), \"wgpuRenderBundleEncoderSetIndexBuffer\" },\n            { reinterpret_cast<WGPUProc>(ClientRenderBundleEncoderSetLabel), \"wgpuRenderBundleEncoderSetLabel\" },\n            { reinterpret_cast<WGPUProc>(ClientRenderBundleEncoderSetPipeline), \"wgpuRenderBundleEncoderSetPipeline\" },\n            { reinterpret_cast<WGPUProc>(ClientRenderBundleEncoderSetVertexBuffer), \"wgpuRenderBundleEncoderSetVertexBuffer\" },\n            { reinterpret_cast<WGPUProc>(ClientRenderBundleReference), \"wgpuRenderBundleReference\" },\n            { reinterpret_cast<WGPUProc>(ClientRenderBundleRelease), \"wgpuRenderBundleRelease\" },\n            { reinterpret_cast<WGPUProc>(ClientRenderBundleSetLabel), \"wgpuRenderBundleSetLabel\" },\n            { reinterpret_cast<WGPUProc>(ClientRenderPassEncoderBeginOcclusionQuery), \"wgpuRenderPassEncoderBeginOcclusionQuery\" },\n            { reinterpret_cast<WGPUProc>(ClientRenderPassEncoderDraw), \"wgpuRenderPassEncoderDraw\" },\n            { reinterpret_cast<WGPUProc>(ClientRenderPassEncoderDrawIndexed), \"wgpuRenderPassEncoderDrawIndexed\" },\n            { reinterpret_cast<WGPUProc>(ClientRenderPassEncoderDrawIndexedIndirect), \"wgpuRenderPassEncoderDrawIndexedIndirect\" },\n            { reinterpret_cast<WGPUProc>(ClientRenderPassEncoderDrawIndirect), \"wgpuRenderPassEncoderDrawIndirect\" },\n            { reinterpret_cast<WGPUProc>(ClientRenderPassEncoderEnd), \"wgpuRenderPassEncoderEnd\" },\n            { reinterpret_cast<WGPUProc>(ClientRenderPassEncoderEndOcclusionQuery), \"wgpuRenderPassEncoderEndOcclusionQuery\" },\n            { reinterpret_cast<WGPUProc>(ClientRenderPassEncoderExecuteBundles), \"wgpuRenderPassEncoderExecuteBundles\" },\n            { reinterpret_cast<WGPUProc>(ClientRenderPassEncoderInsertDebugMarker), \"wgpuRenderPassEncoderInsertDebugMarker\" },\n            { reinterpret_cast<WGPUProc>(ClientRenderPassEncoderPopDebugGroup), \"wgpuRenderPassEncoderPopDebugGroup\" },\n            { reinterpret_cast<WGPUProc>(ClientRenderPassEncoderPushDebugGroup), \"wgpuRenderPassEncoderPushDebugGroup\" },\n            { reinterpret_cast<WGPUProc>(ClientRenderPassEncoderReference), \"wgpuRenderPassEncoderReference\" },\n            { reinterpret_cast<WGPUProc>(ClientRenderPassEncoderRelease), \"wgpuRenderPassEncoderRelease\" },\n            { reinterpret_cast<WGPUProc>(ClientRenderPassEncoderSetBindGroup), \"wgpuRenderPassEncoderSetBindGroup\" },\n            { reinterpret_cast<WGPUProc>(ClientRenderPassEncoderSetBlendConstant), \"wgpuRenderPassEncoderSetBlendConstant\" },\n            { reinterpret_cast<WGPUProc>(ClientRenderPassEncoderSetIndexBuffer), \"wgpuRenderPassEncoderSetIndexBuffer\" },\n            { reinterpret_cast<WGPUProc>(ClientRenderPassEncoderSetLabel), \"wgpuRenderPassEncoderSetLabel\" },\n            { reinterpret_cast<WGPUProc>(ClientRenderPassEncoderSetPipeline), \"wgpuRenderPassEncoderSetPipeline\" },\n            { reinterpret_cast<WGPUProc>(ClientRenderPassEncoderSetScissorRect), \"wgpuRenderPassEncoderSetScissorRect\" },\n            { reinterpret_cast<WGPUProc>(ClientRenderPassEncoderSetStencilReference), \"wgpuRenderPassEncoderSetStencilReference\" },\n            { reinterpret_cast<WGPUProc>(ClientRenderPassEncoderSetVertexBuffer), \"wgpuRenderPassEncoderSetVertexBuffer\" },\n            { reinterpret_cast<WGPUProc>(ClientRenderPassEncoderSetViewport), \"wgpuRenderPassEncoderSetViewport\" },\n            { reinterpret_cast<WGPUProc>(ClientRenderPassEncoderWriteTimestamp), \"wgpuRenderPassEncoderWriteTimestamp\" },\n            { reinterpret_cast<WGPUProc>(ClientRenderPipelineGetBindGroupLayout), \"wgpuRenderPipelineGetBindGroupLayout\" },\n            { reinterpret_cast<WGPUProc>(ClientRenderPipelineReference), \"wgpuRenderPipelineReference\" },\n            { reinterpret_cast<WGPUProc>(ClientRenderPipelineRelease), \"wgpuRenderPipelineRelease\" },\n            { reinterpret_cast<WGPUProc>(ClientRenderPipelineSetLabel), \"wgpuRenderPipelineSetLabel\" },\n            { reinterpret_cast<WGPUProc>(ClientSamplerReference), \"wgpuSamplerReference\" },\n            { reinterpret_cast<WGPUProc>(ClientSamplerRelease), \"wgpuSamplerRelease\" },\n            { reinterpret_cast<WGPUProc>(ClientSamplerSetLabel), \"wgpuSamplerSetLabel\" },\n            { reinterpret_cast<WGPUProc>(ClientShaderModuleGetCompilationInfo), \"wgpuShaderModuleGetCompilationInfo\" },\n            { reinterpret_cast<WGPUProc>(ClientShaderModuleReference), \"wgpuShaderModuleReference\" },\n            { reinterpret_cast<WGPUProc>(ClientShaderModuleRelease), \"wgpuShaderModuleRelease\" },\n            { reinterpret_cast<WGPUProc>(ClientShaderModuleSetLabel), \"wgpuShaderModuleSetLabel\" },\n            { reinterpret_cast<WGPUProc>(ClientSurfaceReference), \"wgpuSurfaceReference\" },\n            { reinterpret_cast<WGPUProc>(ClientSurfaceRelease), \"wgpuSurfaceRelease\" },\n            { reinterpret_cast<WGPUProc>(ClientSwapChainGetCurrentTexture), \"wgpuSwapChainGetCurrentTexture\" },\n            { reinterpret_cast<WGPUProc>(ClientSwapChainGetCurrentTextureView), \"wgpuSwapChainGetCurrentTextureView\" },\n            { reinterpret_cast<WGPUProc>(ClientSwapChainPresent), \"wgpuSwapChainPresent\" },\n            { reinterpret_cast<WGPUProc>(ClientSwapChainReference), \"wgpuSwapChainReference\" },\n            { reinterpret_cast<WGPUProc>(ClientSwapChainRelease), \"wgpuSwapChainRelease\" },\n            { reinterpret_cast<WGPUProc>(ClientTextureCreateView), \"wgpuTextureCreateView\" },\n            { reinterpret_cast<WGPUProc>(ClientTextureDestroy), \"wgpuTextureDestroy\" },\n            { reinterpret_cast<WGPUProc>(ClientTextureGetDepthOrArrayLayers), \"wgpuTextureGetDepthOrArrayLayers\" },\n            { reinterpret_cast<WGPUProc>(ClientTextureGetDimension), \"wgpuTextureGetDimension\" },\n            { reinterpret_cast<WGPUProc>(ClientTextureGetFormat), \"wgpuTextureGetFormat\" },\n            { reinterpret_cast<WGPUProc>(ClientTextureGetHeight), \"wgpuTextureGetHeight\" },\n            { reinterpret_cast<WGPUProc>(ClientTextureGetMipLevelCount), \"wgpuTextureGetMipLevelCount\" },\n            { reinterpret_cast<WGPUProc>(ClientTextureGetSampleCount), \"wgpuTextureGetSampleCount\" },\n            { reinterpret_cast<WGPUProc>(ClientTextureGetUsage), \"wgpuTextureGetUsage\" },\n            { reinterpret_cast<WGPUProc>(ClientTextureGetWidth), \"wgpuTextureGetWidth\" },\n            { reinterpret_cast<WGPUProc>(ClientTextureReference), \"wgpuTextureReference\" },\n            { reinterpret_cast<WGPUProc>(ClientTextureRelease), \"wgpuTextureRelease\" },\n            { reinterpret_cast<WGPUProc>(ClientTextureSetLabel), \"wgpuTextureSetLabel\" },\n            { reinterpret_cast<WGPUProc>(ClientTextureViewReference), \"wgpuTextureViewReference\" },\n            { reinterpret_cast<WGPUProc>(ClientTextureViewRelease), \"wgpuTextureViewRelease\" },\n            { reinterpret_cast<WGPUProc>(ClientTextureViewSetLabel), \"wgpuTextureViewSetLabel\" },\n        };\n        static constexpr size_t sProcMapSize = sizeof(sProcMap) / sizeof(sProcMap[0]);\n    }  // anonymous namespace\n\n    WGPUProc ClientGetProcAddress(WGPUDevice, const char* procName) {\n        if (procName == nullptr) {\n            return nullptr;\n        }\n\n        const ProcEntry* entry = std::lower_bound(&sProcMap[0], &sProcMap[sProcMapSize], procName,\n            [](const ProcEntry &a, const char *b) -> bool {\n                return strcmp(a.name, b) < 0;\n            }\n        );\n\n        if (entry != &sProcMap[sProcMapSize] && strcmp(entry->name, procName) == 0) {\n            return entry->proc;\n        }\n\n        // Special case the two free-standing functions of the API.\n        if (strcmp(procName, \"wgpuGetProcAddress\") == 0) {\n            return reinterpret_cast<WGPUProc>(ClientGetProcAddress);\n        }\n\n        if (strcmp(procName, \"wgpuCreateInstance\") == 0) {\n            return reinterpret_cast<WGPUProc>(ClientCreateInstance);\n        }\n\n        return nullptr;\n    }\n\n    std::vector<const char*> GetProcMapNamesForTesting() {\n        std::vector<const char*> result;\n        result.reserve(sProcMapSize);\n        for (const ProcEntry& entry : sProcMap) {\n            result.push_back(entry.name);\n        }\n        return result;\n    }\n\n    static DawnProcTable gProcTable = {\n        ClientCreateInstance,\n        ClientGetProcAddress,\n        ClientAdapterCreateDevice,\n        ClientAdapterEnumerateFeatures,\n        ClientAdapterGetInstance,\n        ClientAdapterGetLimits,\n        ClientAdapterGetProperties,\n        ClientAdapterHasFeature,\n        ClientAdapterRequestDevice,\n        ClientAdapterReference,\n        ClientAdapterRelease,\n        ClientBindGroupSetLabel,\n        ClientBindGroupReference,\n        ClientBindGroupRelease,\n        ClientBindGroupLayoutSetLabel,\n        ClientBindGroupLayoutReference,\n        ClientBindGroupLayoutRelease,\n        ClientBufferDestroy,\n        ClientBufferGetConstMappedRange,\n        ClientBufferGetMapState,\n        ClientBufferGetMappedRange,\n        ClientBufferGetSize,\n        ClientBufferGetUsage,\n        ClientBufferMapAsync,\n        ClientBufferSetLabel,\n        ClientBufferUnmap,\n        ClientBufferReference,\n        ClientBufferRelease,\n        ClientCommandBufferSetLabel,\n        ClientCommandBufferReference,\n        ClientCommandBufferRelease,\n        ClientCommandEncoderBeginComputePass,\n        ClientCommandEncoderBeginRenderPass,\n        ClientCommandEncoderClearBuffer,\n        ClientCommandEncoderCopyBufferToBuffer,\n        ClientCommandEncoderCopyBufferToTexture,\n        ClientCommandEncoderCopyTextureToBuffer,\n        ClientCommandEncoderCopyTextureToTexture,\n        ClientCommandEncoderCopyTextureToTextureInternal,\n        ClientCommandEncoderFinish,\n        ClientCommandEncoderInjectValidationError,\n        ClientCommandEncoderInsertDebugMarker,\n        ClientCommandEncoderPopDebugGroup,\n        ClientCommandEncoderPushDebugGroup,\n        ClientCommandEncoderResolveQuerySet,\n        ClientCommandEncoderSetLabel,\n        ClientCommandEncoderWriteBuffer,\n        ClientCommandEncoderWriteTimestamp,\n        ClientCommandEncoderReference,\n        ClientCommandEncoderRelease,\n        ClientComputePassEncoderDispatchWorkgroups,\n        ClientComputePassEncoderDispatchWorkgroupsIndirect,\n        ClientComputePassEncoderEnd,\n        ClientComputePassEncoderInsertDebugMarker,\n        ClientComputePassEncoderPopDebugGroup,\n        ClientComputePassEncoderPushDebugGroup,\n        ClientComputePassEncoderSetBindGroup,\n        ClientComputePassEncoderSetLabel,\n        ClientComputePassEncoderSetPipeline,\n        ClientComputePassEncoderWriteTimestamp,\n        ClientComputePassEncoderReference,\n        ClientComputePassEncoderRelease,\n        ClientComputePipelineGetBindGroupLayout,\n        ClientComputePipelineSetLabel,\n        ClientComputePipelineReference,\n        ClientComputePipelineRelease,\n        ClientDeviceCreateBindGroup,\n        ClientDeviceCreateBindGroupLayout,\n        ClientDeviceCreateBuffer,\n        ClientDeviceCreateCommandEncoder,\n        ClientDeviceCreateComputePipeline,\n        ClientDeviceCreateComputePipelineAsync,\n        ClientDeviceCreateErrorBuffer,\n        ClientDeviceCreateErrorExternalTexture,\n        ClientDeviceCreateErrorShaderModule,\n        ClientDeviceCreateErrorTexture,\n        ClientDeviceCreateExternalTexture,\n        ClientDeviceCreatePipelineLayout,\n        ClientDeviceCreateQuerySet,\n        ClientDeviceCreateRenderBundleEncoder,\n        ClientDeviceCreateRenderPipeline,\n        ClientDeviceCreateRenderPipelineAsync,\n        ClientDeviceCreateSampler,\n        ClientDeviceCreateShaderModule,\n        ClientDeviceCreateSwapChain,\n        ClientDeviceCreateTexture,\n        ClientDeviceDestroy,\n        ClientDeviceEnumerateFeatures,\n        ClientDeviceForceLoss,\n        ClientDeviceGetAdapter,\n        ClientDeviceGetLimits,\n        ClientDeviceGetQueue,\n        ClientDeviceGetSupportedSurfaceUsage,\n        ClientDeviceHasFeature,\n        ClientDeviceInjectError,\n        ClientDevicePopErrorScope,\n        ClientDevicePushErrorScope,\n        ClientDeviceSetDeviceLostCallback,\n        ClientDeviceSetLabel,\n        ClientDeviceSetLoggingCallback,\n        ClientDeviceSetUncapturedErrorCallback,\n        ClientDeviceTick,\n        ClientDeviceValidateTextureDescriptor,\n        ClientDeviceReference,\n        ClientDeviceRelease,\n        ClientExternalTextureDestroy,\n        ClientExternalTextureExpire,\n        ClientExternalTextureRefresh,\n        ClientExternalTextureSetLabel,\n        ClientExternalTextureReference,\n        ClientExternalTextureRelease,\n        ClientInstanceCreateSurface,\n        ClientInstanceProcessEvents,\n        ClientInstanceRequestAdapter,\n        ClientInstanceReference,\n        ClientInstanceRelease,\n        ClientPipelineLayoutSetLabel,\n        ClientPipelineLayoutReference,\n        ClientPipelineLayoutRelease,\n        ClientQuerySetDestroy,\n        ClientQuerySetGetCount,\n        ClientQuerySetGetType,\n        ClientQuerySetSetLabel,\n        ClientQuerySetReference,\n        ClientQuerySetRelease,\n        ClientQueueCopyExternalTextureForBrowser,\n        ClientQueueCopyTextureForBrowser,\n        ClientQueueOnSubmittedWorkDone,\n        ClientQueueSetLabel,\n        ClientQueueSubmit,\n        ClientQueueWriteBuffer,\n        ClientQueueWriteTexture,\n        ClientQueueReference,\n        ClientQueueRelease,\n        ClientRenderBundleSetLabel,\n        ClientRenderBundleReference,\n        ClientRenderBundleRelease,\n        ClientRenderBundleEncoderDraw,\n        ClientRenderBundleEncoderDrawIndexed,\n        ClientRenderBundleEncoderDrawIndexedIndirect,\n        ClientRenderBundleEncoderDrawIndirect,\n        ClientRenderBundleEncoderFinish,\n        ClientRenderBundleEncoderInsertDebugMarker,\n        ClientRenderBundleEncoderPopDebugGroup,\n        ClientRenderBundleEncoderPushDebugGroup,\n        ClientRenderBundleEncoderSetBindGroup,\n        ClientRenderBundleEncoderSetIndexBuffer,\n        ClientRenderBundleEncoderSetLabel,\n        ClientRenderBundleEncoderSetPipeline,\n        ClientRenderBundleEncoderSetVertexBuffer,\n        ClientRenderBundleEncoderReference,\n        ClientRenderBundleEncoderRelease,\n        ClientRenderPassEncoderBeginOcclusionQuery,\n        ClientRenderPassEncoderDraw,\n        ClientRenderPassEncoderDrawIndexed,\n        ClientRenderPassEncoderDrawIndexedIndirect,\n        ClientRenderPassEncoderDrawIndirect,\n        ClientRenderPassEncoderEnd,\n        ClientRenderPassEncoderEndOcclusionQuery,\n        ClientRenderPassEncoderExecuteBundles,\n        ClientRenderPassEncoderInsertDebugMarker,\n        ClientRenderPassEncoderPopDebugGroup,\n        ClientRenderPassEncoderPushDebugGroup,\n        ClientRenderPassEncoderSetBindGroup,\n        ClientRenderPassEncoderSetBlendConstant,\n        ClientRenderPassEncoderSetIndexBuffer,\n        ClientRenderPassEncoderSetLabel,\n        ClientRenderPassEncoderSetPipeline,\n        ClientRenderPassEncoderSetScissorRect,\n        ClientRenderPassEncoderSetStencilReference,\n        ClientRenderPassEncoderSetVertexBuffer,\n        ClientRenderPassEncoderSetViewport,\n        ClientRenderPassEncoderWriteTimestamp,\n        ClientRenderPassEncoderReference,\n        ClientRenderPassEncoderRelease,\n        ClientRenderPipelineGetBindGroupLayout,\n        ClientRenderPipelineSetLabel,\n        ClientRenderPipelineReference,\n        ClientRenderPipelineRelease,\n        ClientSamplerSetLabel,\n        ClientSamplerReference,\n        ClientSamplerRelease,\n        ClientShaderModuleGetCompilationInfo,\n        ClientShaderModuleSetLabel,\n        ClientShaderModuleReference,\n        ClientShaderModuleRelease,\n        ClientSurfaceReference,\n        ClientSurfaceRelease,\n        ClientSwapChainGetCurrentTexture,\n        ClientSwapChainGetCurrentTextureView,\n        ClientSwapChainPresent,\n        ClientSwapChainReference,\n        ClientSwapChainRelease,\n        ClientTextureCreateView,\n        ClientTextureDestroy,\n        ClientTextureGetDepthOrArrayLayers,\n        ClientTextureGetDimension,\n        ClientTextureGetFormat,\n        ClientTextureGetHeight,\n        ClientTextureGetMipLevelCount,\n        ClientTextureGetSampleCount,\n        ClientTextureGetUsage,\n        ClientTextureGetWidth,\n        ClientTextureSetLabel,\n        ClientTextureReference,\n        ClientTextureRelease,\n        ClientTextureViewSetLabel,\n        ClientTextureViewReference,\n        ClientTextureViewRelease,\n    };\n\n    const DawnProcTable& GetProcs() {\n        return gProcTable;\n    }\n}  // namespace dawn::wire::client\n", "src/dawn/wire/client/ClientBase_autogen.h": "\n#ifndef DAWNWIRE_CLIENT_CLIENTBASE_AUTOGEN_H_\n#define DAWNWIRE_CLIENT_CLIENTBASE_AUTOGEN_H_\n\n#include \"dawn/wire/ChunkedCommandHandler.h\"\n#include \"dawn/wire/WireCmd_autogen.h\"\n#include \"dawn/wire/client/ApiObjects.h\"\n\nnamespace dawn::wire::client {\n\n    class ClientBase : public ChunkedCommandHandler, public ObjectIdProvider {\n      public:\n        ClientBase() = default;\n        ~ClientBase() override = default;\n\n      private:\n        // Implementation of the ObjectIdProvider interface\n        WireResult GetId(WGPUAdapter object, ObjectId* out) const final {\n            ASSERT(out != nullptr);\n            if (object == nullptr) {\n                return WireResult::FatalError;\n            }\n            *out = reinterpret_cast<Adapter*>(object)->GetWireId();\n            return WireResult::Success;\n        }\n        WireResult GetOptionalId(WGPUAdapter object, ObjectId* out) const final {\n            ASSERT(out != nullptr);\n            *out = (object == nullptr ? 0 : reinterpret_cast<Adapter*>(object)->GetWireId());\n            return WireResult::Success;\n        }\n        WireResult GetId(WGPUBindGroup object, ObjectId* out) const final {\n            ASSERT(out != nullptr);\n            if (object == nullptr) {\n                return WireResult::FatalError;\n            }\n            *out = reinterpret_cast<BindGroup*>(object)->GetWireId();\n            return WireResult::Success;\n        }\n        WireResult GetOptionalId(WGPUBindGroup object, ObjectId* out) const final {\n            ASSERT(out != nullptr);\n            *out = (object == nullptr ? 0 : reinterpret_cast<BindGroup*>(object)->GetWireId());\n            return WireResult::Success;\n        }\n        WireResult GetId(WGPUBindGroupLayout object, ObjectId* out) const final {\n            ASSERT(out != nullptr);\n            if (object == nullptr) {\n                return WireResult::FatalError;\n            }\n            *out = reinterpret_cast<BindGroupLayout*>(object)->GetWireId();\n            return WireResult::Success;\n        }\n        WireResult GetOptionalId(WGPUBindGroupLayout object, ObjectId* out) const final {\n            ASSERT(out != nullptr);\n            *out = (object == nullptr ? 0 : reinterpret_cast<BindGroupLayout*>(object)->GetWireId());\n            return WireResult::Success;\n        }\n        WireResult GetId(WGPUBuffer object, ObjectId* out) const final {\n            ASSERT(out != nullptr);\n            if (object == nullptr) {\n                return WireResult::FatalError;\n            }\n            *out = reinterpret_cast<Buffer*>(object)->GetWireId();\n            return WireResult::Success;\n        }\n        WireResult GetOptionalId(WGPUBuffer object, ObjectId* out) const final {\n            ASSERT(out != nullptr);\n            *out = (object == nullptr ? 0 : reinterpret_cast<Buffer*>(object)->GetWireId());\n            return WireResult::Success;\n        }\n        WireResult GetId(WGPUCommandBuffer object, ObjectId* out) const final {\n            ASSERT(out != nullptr);\n            if (object == nullptr) {\n                return WireResult::FatalError;\n            }\n            *out = reinterpret_cast<CommandBuffer*>(object)->GetWireId();\n            return WireResult::Success;\n        }\n        WireResult GetOptionalId(WGPUCommandBuffer object, ObjectId* out) const final {\n            ASSERT(out != nullptr);\n            *out = (object == nullptr ? 0 : reinterpret_cast<CommandBuffer*>(object)->GetWireId());\n            return WireResult::Success;\n        }\n        WireResult GetId(WGPUCommandEncoder object, ObjectId* out) const final {\n            ASSERT(out != nullptr);\n            if (object == nullptr) {\n                return WireResult::FatalError;\n            }\n            *out = reinterpret_cast<CommandEncoder*>(object)->GetWireId();\n            return WireResult::Success;\n        }\n        WireResult GetOptionalId(WGPUCommandEncoder object, ObjectId* out) const final {\n            ASSERT(out != nullptr);\n            *out = (object == nullptr ? 0 : reinterpret_cast<CommandEncoder*>(object)->GetWireId());\n            return WireResult::Success;\n        }\n        WireResult GetId(WGPUComputePassEncoder object, ObjectId* out) const final {\n            ASSERT(out != nullptr);\n            if (object == nullptr) {\n                return WireResult::FatalError;\n            }\n            *out = reinterpret_cast<ComputePassEncoder*>(object)->GetWireId();\n            return WireResult::Success;\n        }\n        WireResult GetOptionalId(WGPUComputePassEncoder object, ObjectId* out) const final {\n            ASSERT(out != nullptr);\n            *out = (object == nullptr ? 0 : reinterpret_cast<ComputePassEncoder*>(object)->GetWireId());\n            return WireResult::Success;\n        }\n        WireResult GetId(WGPUComputePipeline object, ObjectId* out) const final {\n            ASSERT(out != nullptr);\n            if (object == nullptr) {\n                return WireResult::FatalError;\n            }\n            *out = reinterpret_cast<ComputePipeline*>(object)->GetWireId();\n            return WireResult::Success;\n        }\n        WireResult GetOptionalId(WGPUComputePipeline object, ObjectId* out) const final {\n            ASSERT(out != nullptr);\n            *out = (object == nullptr ? 0 : reinterpret_cast<ComputePipeline*>(object)->GetWireId());\n            return WireResult::Success;\n        }\n        WireResult GetId(WGPUDevice object, ObjectId* out) const final {\n            ASSERT(out != nullptr);\n            if (object == nullptr) {\n                return WireResult::FatalError;\n            }\n            *out = reinterpret_cast<Device*>(object)->GetWireId();\n            return WireResult::Success;\n        }\n        WireResult GetOptionalId(WGPUDevice object, ObjectId* out) const final {\n            ASSERT(out != nullptr);\n            *out = (object == nullptr ? 0 : reinterpret_cast<Device*>(object)->GetWireId());\n            return WireResult::Success;\n        }\n        WireResult GetId(WGPUExternalTexture object, ObjectId* out) const final {\n            ASSERT(out != nullptr);\n            if (object == nullptr) {\n                return WireResult::FatalError;\n            }\n            *out = reinterpret_cast<ExternalTexture*>(object)->GetWireId();\n            return WireResult::Success;\n        }\n        WireResult GetOptionalId(WGPUExternalTexture object, ObjectId* out) const final {\n            ASSERT(out != nullptr);\n            *out = (object == nullptr ? 0 : reinterpret_cast<ExternalTexture*>(object)->GetWireId());\n            return WireResult::Success;\n        }\n        WireResult GetId(WGPUInstance object, ObjectId* out) const final {\n            ASSERT(out != nullptr);\n            if (object == nullptr) {\n                return WireResult::FatalError;\n            }\n            *out = reinterpret_cast<Instance*>(object)->GetWireId();\n            return WireResult::Success;\n        }\n        WireResult GetOptionalId(WGPUInstance object, ObjectId* out) const final {\n            ASSERT(out != nullptr);\n            *out = (object == nullptr ? 0 : reinterpret_cast<Instance*>(object)->GetWireId());\n            return WireResult::Success;\n        }\n        WireResult GetId(WGPUPipelineLayout object, ObjectId* out) const final {\n            ASSERT(out != nullptr);\n            if (object == nullptr) {\n                return WireResult::FatalError;\n            }\n            *out = reinterpret_cast<PipelineLayout*>(object)->GetWireId();\n            return WireResult::Success;\n        }\n        WireResult GetOptionalId(WGPUPipelineLayout object, ObjectId* out) const final {\n            ASSERT(out != nullptr);\n            *out = (object == nullptr ? 0 : reinterpret_cast<PipelineLayout*>(object)->GetWireId());\n            return WireResult::Success;\n        }\n        WireResult GetId(WGPUQuerySet object, ObjectId* out) const final {\n            ASSERT(out != nullptr);\n            if (object == nullptr) {\n                return WireResult::FatalError;\n            }\n            *out = reinterpret_cast<QuerySet*>(object)->GetWireId();\n            return WireResult::Success;\n        }\n        WireResult GetOptionalId(WGPUQuerySet object, ObjectId* out) const final {\n            ASSERT(out != nullptr);\n            *out = (object == nullptr ? 0 : reinterpret_cast<QuerySet*>(object)->GetWireId());\n            return WireResult::Success;\n        }\n        WireResult GetId(WGPUQueue object, ObjectId* out) const final {\n            ASSERT(out != nullptr);\n            if (object == nullptr) {\n                return WireResult::FatalError;\n            }\n            *out = reinterpret_cast<Queue*>(object)->GetWireId();\n            return WireResult::Success;\n        }\n        WireResult GetOptionalId(WGPUQueue object, ObjectId* out) const final {\n            ASSERT(out != nullptr);\n            *out = (object == nullptr ? 0 : reinterpret_cast<Queue*>(object)->GetWireId());\n            return WireResult::Success;\n        }\n        WireResult GetId(WGPURenderBundle object, ObjectId* out) const final {\n            ASSERT(out != nullptr);\n            if (object == nullptr) {\n                return WireResult::FatalError;\n            }\n            *out = reinterpret_cast<RenderBundle*>(object)->GetWireId();\n            return WireResult::Success;\n        }\n        WireResult GetOptionalId(WGPURenderBundle object, ObjectId* out) const final {\n            ASSERT(out != nullptr);\n            *out = (object == nullptr ? 0 : reinterpret_cast<RenderBundle*>(object)->GetWireId());\n            return WireResult::Success;\n        }\n        WireResult GetId(WGPURenderBundleEncoder object, ObjectId* out) const final {\n            ASSERT(out != nullptr);\n            if (object == nullptr) {\n                return WireResult::FatalError;\n            }\n            *out = reinterpret_cast<RenderBundleEncoder*>(object)->GetWireId();\n            return WireResult::Success;\n        }\n        WireResult GetOptionalId(WGPURenderBundleEncoder object, ObjectId* out) const final {\n            ASSERT(out != nullptr);\n            *out = (object == nullptr ? 0 : reinterpret_cast<RenderBundleEncoder*>(object)->GetWireId());\n            return WireResult::Success;\n        }\n        WireResult GetId(WGPURenderPassEncoder object, ObjectId* out) const final {\n            ASSERT(out != nullptr);\n            if (object == nullptr) {\n                return WireResult::FatalError;\n            }\n            *out = reinterpret_cast<RenderPassEncoder*>(object)->GetWireId();\n            return WireResult::Success;\n        }\n        WireResult GetOptionalId(WGPURenderPassEncoder object, ObjectId* out) const final {\n            ASSERT(out != nullptr);\n            *out = (object == nullptr ? 0 : reinterpret_cast<RenderPassEncoder*>(object)->GetWireId());\n            return WireResult::Success;\n        }\n        WireResult GetId(WGPURenderPipeline object, ObjectId* out) const final {\n            ASSERT(out != nullptr);\n            if (object == nullptr) {\n                return WireResult::FatalError;\n            }\n            *out = reinterpret_cast<RenderPipeline*>(object)->GetWireId();\n            return WireResult::Success;\n        }\n        WireResult GetOptionalId(WGPURenderPipeline object, ObjectId* out) const final {\n            ASSERT(out != nullptr);\n            *out = (object == nullptr ? 0 : reinterpret_cast<RenderPipeline*>(object)->GetWireId());\n            return WireResult::Success;\n        }\n        WireResult GetId(WGPUSampler object, ObjectId* out) const final {\n            ASSERT(out != nullptr);\n            if (object == nullptr) {\n                return WireResult::FatalError;\n            }\n            *out = reinterpret_cast<Sampler*>(object)->GetWireId();\n            return WireResult::Success;\n        }\n        WireResult GetOptionalId(WGPUSampler object, ObjectId* out) const final {\n            ASSERT(out != nullptr);\n            *out = (object == nullptr ? 0 : reinterpret_cast<Sampler*>(object)->GetWireId());\n            return WireResult::Success;\n        }\n        WireResult GetId(WGPUShaderModule object, ObjectId* out) const final {\n            ASSERT(out != nullptr);\n            if (object == nullptr) {\n                return WireResult::FatalError;\n            }\n            *out = reinterpret_cast<ShaderModule*>(object)->GetWireId();\n            return WireResult::Success;\n        }\n        WireResult GetOptionalId(WGPUShaderModule object, ObjectId* out) const final {\n            ASSERT(out != nullptr);\n            *out = (object == nullptr ? 0 : reinterpret_cast<ShaderModule*>(object)->GetWireId());\n            return WireResult::Success;\n        }\n        WireResult GetId(WGPUSurface object, ObjectId* out) const final {\n            ASSERT(out != nullptr);\n            if (object == nullptr) {\n                return WireResult::FatalError;\n            }\n            *out = reinterpret_cast<Surface*>(object)->GetWireId();\n            return WireResult::Success;\n        }\n        WireResult GetOptionalId(WGPUSurface object, ObjectId* out) const final {\n            ASSERT(out != nullptr);\n            *out = (object == nullptr ? 0 : reinterpret_cast<Surface*>(object)->GetWireId());\n            return WireResult::Success;\n        }\n        WireResult GetId(WGPUSwapChain object, ObjectId* out) const final {\n            ASSERT(out != nullptr);\n            if (object == nullptr) {\n                return WireResult::FatalError;\n            }\n            *out = reinterpret_cast<SwapChain*>(object)->GetWireId();\n            return WireResult::Success;\n        }\n        WireResult GetOptionalId(WGPUSwapChain object, ObjectId* out) const final {\n            ASSERT(out != nullptr);\n            *out = (object == nullptr ? 0 : reinterpret_cast<SwapChain*>(object)->GetWireId());\n            return WireResult::Success;\n        }\n        WireResult GetId(WGPUTexture object, ObjectId* out) const final {\n            ASSERT(out != nullptr);\n            if (object == nullptr) {\n                return WireResult::FatalError;\n            }\n            *out = reinterpret_cast<Texture*>(object)->GetWireId();\n            return WireResult::Success;\n        }\n        WireResult GetOptionalId(WGPUTexture object, ObjectId* out) const final {\n            ASSERT(out != nullptr);\n            *out = (object == nullptr ? 0 : reinterpret_cast<Texture*>(object)->GetWireId());\n            return WireResult::Success;\n        }\n        WireResult GetId(WGPUTextureView object, ObjectId* out) const final {\n            ASSERT(out != nullptr);\n            if (object == nullptr) {\n                return WireResult::FatalError;\n            }\n            *out = reinterpret_cast<TextureView*>(object)->GetWireId();\n            return WireResult::Success;\n        }\n        WireResult GetOptionalId(WGPUTextureView object, ObjectId* out) const final {\n            ASSERT(out != nullptr);\n            *out = (object == nullptr ? 0 : reinterpret_cast<TextureView*>(object)->GetWireId());\n            return WireResult::Success;\n        }\n    };\n\n}  // namespace dawn::wire::client\n\n#endif  // DAWNWIRE_CLIENT_CLIENTBASE_AUTOGEN_H_\n", "src/dawn/wire/client/ClientHandlers_autogen.cpp": "\n#include \"dawn/common/Assert.h\"\n#include \"dawn/wire/client/Client.h\"\n\n#include <string>\n\nnamespace dawn::wire::client {\n    bool Client::HandleAdapterRequestDeviceCallback(DeserializeBuffer* deserializeBuffer) {\n        ReturnAdapterRequestDeviceCallbackCmd cmd;\n        WireResult deserializeResult = cmd.Deserialize(deserializeBuffer, &mWireCommandAllocator);\n\n        if (deserializeResult == WireResult::FatalError) {\n            return false;\n        }\n\n\n        Adapter* adapter = Get<Adapter>(cmd.adapter.id);\n        if (adapter != nullptr && adapter->GetWireGeneration() != cmd.adapter.generation) {\n            adapter = nullptr;\n        }\n\n        return DoAdapterRequestDeviceCallback(adapter, cmd.requestSerial, cmd.status, cmd.message, cmd.limits, cmd.featuresCount, cmd.features);\n    }\n    bool Client::HandleBufferMapAsyncCallback(DeserializeBuffer* deserializeBuffer) {\n        ReturnBufferMapAsyncCallbackCmd cmd;\n        WireResult deserializeResult = cmd.Deserialize(deserializeBuffer, &mWireCommandAllocator);\n\n        if (deserializeResult == WireResult::FatalError) {\n            return false;\n        }\n\n\n        Buffer* buffer = Get<Buffer>(cmd.buffer.id);\n        if (buffer != nullptr && buffer->GetWireGeneration() != cmd.buffer.generation) {\n            buffer = nullptr;\n        }\n\n        return DoBufferMapAsyncCallback(buffer, cmd.requestSerial, cmd.status, cmd.readDataUpdateInfoLength, cmd.readDataUpdateInfo);\n    }\n    bool Client::HandleDeviceCreateComputePipelineAsyncCallback(DeserializeBuffer* deserializeBuffer) {\n        ReturnDeviceCreateComputePipelineAsyncCallbackCmd cmd;\n        WireResult deserializeResult = cmd.Deserialize(deserializeBuffer, &mWireCommandAllocator);\n\n        if (deserializeResult == WireResult::FatalError) {\n            return false;\n        }\n\n\n        Device* device = Get<Device>(cmd.device.id);\n        if (device != nullptr && device->GetWireGeneration() != cmd.device.generation) {\n            device = nullptr;\n        }\n\n        return DoDeviceCreateComputePipelineAsyncCallback(device, cmd.requestSerial, cmd.status, cmd.message);\n    }\n    bool Client::HandleDeviceCreateRenderPipelineAsyncCallback(DeserializeBuffer* deserializeBuffer) {\n        ReturnDeviceCreateRenderPipelineAsyncCallbackCmd cmd;\n        WireResult deserializeResult = cmd.Deserialize(deserializeBuffer, &mWireCommandAllocator);\n\n        if (deserializeResult == WireResult::FatalError) {\n            return false;\n        }\n\n\n        Device* device = Get<Device>(cmd.device.id);\n        if (device != nullptr && device->GetWireGeneration() != cmd.device.generation) {\n            device = nullptr;\n        }\n\n        return DoDeviceCreateRenderPipelineAsyncCallback(device, cmd.requestSerial, cmd.status, cmd.message);\n    }\n    bool Client::HandleDeviceLoggingCallback(DeserializeBuffer* deserializeBuffer) {\n        ReturnDeviceLoggingCallbackCmd cmd;\n        WireResult deserializeResult = cmd.Deserialize(deserializeBuffer, &mWireCommandAllocator);\n\n        if (deserializeResult == WireResult::FatalError) {\n            return false;\n        }\n\n\n        Device* device = Get<Device>(cmd.device.id);\n        if (device != nullptr && device->GetWireGeneration() != cmd.device.generation) {\n            device = nullptr;\n        }\n\n        return DoDeviceLoggingCallback(device, cmd.type, cmd.message);\n    }\n    bool Client::HandleDeviceLostCallback(DeserializeBuffer* deserializeBuffer) {\n        ReturnDeviceLostCallbackCmd cmd;\n        WireResult deserializeResult = cmd.Deserialize(deserializeBuffer, &mWireCommandAllocator);\n\n        if (deserializeResult == WireResult::FatalError) {\n            return false;\n        }\n\n\n        Device* device = Get<Device>(cmd.device.id);\n        if (device != nullptr && device->GetWireGeneration() != cmd.device.generation) {\n            device = nullptr;\n        }\n\n        return DoDeviceLostCallback(device, cmd.reason, cmd.message);\n    }\n    bool Client::HandleDevicePopErrorScopeCallback(DeserializeBuffer* deserializeBuffer) {\n        ReturnDevicePopErrorScopeCallbackCmd cmd;\n        WireResult deserializeResult = cmd.Deserialize(deserializeBuffer, &mWireCommandAllocator);\n\n        if (deserializeResult == WireResult::FatalError) {\n            return false;\n        }\n\n\n        Device* device = Get<Device>(cmd.device.id);\n        if (device != nullptr && device->GetWireGeneration() != cmd.device.generation) {\n            device = nullptr;\n        }\n\n        return DoDevicePopErrorScopeCallback(device, cmd.requestSerial, cmd.type, cmd.message);\n    }\n    bool Client::HandleDeviceUncapturedErrorCallback(DeserializeBuffer* deserializeBuffer) {\n        ReturnDeviceUncapturedErrorCallbackCmd cmd;\n        WireResult deserializeResult = cmd.Deserialize(deserializeBuffer, &mWireCommandAllocator);\n\n        if (deserializeResult == WireResult::FatalError) {\n            return false;\n        }\n\n\n        Device* device = Get<Device>(cmd.device.id);\n        if (device != nullptr && device->GetWireGeneration() != cmd.device.generation) {\n            device = nullptr;\n        }\n\n        return DoDeviceUncapturedErrorCallback(device, cmd.type, cmd.message);\n    }\n    bool Client::HandleInstanceRequestAdapterCallback(DeserializeBuffer* deserializeBuffer) {\n        ReturnInstanceRequestAdapterCallbackCmd cmd;\n        WireResult deserializeResult = cmd.Deserialize(deserializeBuffer, &mWireCommandAllocator);\n\n        if (deserializeResult == WireResult::FatalError) {\n            return false;\n        }\n\n\n        Instance* instance = Get<Instance>(cmd.instance.id);\n        if (instance != nullptr && instance->GetWireGeneration() != cmd.instance.generation) {\n            instance = nullptr;\n        }\n\n        return DoInstanceRequestAdapterCallback(instance, cmd.requestSerial, cmd.status, cmd.message, cmd.properties, cmd.limits, cmd.featuresCount, cmd.features);\n    }\n    bool Client::HandleQueueWorkDoneCallback(DeserializeBuffer* deserializeBuffer) {\n        ReturnQueueWorkDoneCallbackCmd cmd;\n        WireResult deserializeResult = cmd.Deserialize(deserializeBuffer, &mWireCommandAllocator);\n\n        if (deserializeResult == WireResult::FatalError) {\n            return false;\n        }\n\n\n        Queue* queue = Get<Queue>(cmd.queue.id);\n        if (queue != nullptr && queue->GetWireGeneration() != cmd.queue.generation) {\n            queue = nullptr;\n        }\n\n        return DoQueueWorkDoneCallback(queue, cmd.requestSerial, cmd.status);\n    }\n    bool Client::HandleShaderModuleGetCompilationInfoCallback(DeserializeBuffer* deserializeBuffer) {\n        ReturnShaderModuleGetCompilationInfoCallbackCmd cmd;\n        WireResult deserializeResult = cmd.Deserialize(deserializeBuffer, &mWireCommandAllocator);\n\n        if (deserializeResult == WireResult::FatalError) {\n            return false;\n        }\n\n\n        ShaderModule* shaderModule = Get<ShaderModule>(cmd.shaderModule.id);\n        if (shaderModule != nullptr && shaderModule->GetWireGeneration() != cmd.shaderModule.generation) {\n            shaderModule = nullptr;\n        }\n\n        return DoShaderModuleGetCompilationInfoCallback(shaderModule, cmd.requestSerial, cmd.status, cmd.info);\n    }\n\n    const volatile char* Client::HandleCommandsImpl(const volatile char* commands, size_t size) {\n        DeserializeBuffer deserializeBuffer(commands, size);\n\n        while (deserializeBuffer.AvailableSize() >= sizeof(CmdHeader) + sizeof(ReturnWireCmd)) {\n            // Start by chunked command handling, if it is done, then it means the whole buffer\n            // was consumed by it, so we return a pointer to the end of the commands.\n            switch (HandleChunkedCommands(deserializeBuffer.Buffer(), deserializeBuffer.AvailableSize())) {\n                case ChunkedCommandsResult::Consumed:\n                    return commands + size;\n                case ChunkedCommandsResult::Error:\n                    return nullptr;\n                case ChunkedCommandsResult::Passthrough:\n                    break;\n            }\n\n            ReturnWireCmd cmdId = *static_cast<const volatile ReturnWireCmd*>(static_cast<const volatile void*>(\n                deserializeBuffer.Buffer() + sizeof(CmdHeader)));\n            bool success = false;\n            switch (cmdId) {\n                case ReturnWireCmd::AdapterRequestDeviceCallback:\n                    success = HandleAdapterRequestDeviceCallback(&deserializeBuffer);\n                    break;\n                case ReturnWireCmd::BufferMapAsyncCallback:\n                    success = HandleBufferMapAsyncCallback(&deserializeBuffer);\n                    break;\n                case ReturnWireCmd::DeviceCreateComputePipelineAsyncCallback:\n                    success = HandleDeviceCreateComputePipelineAsyncCallback(&deserializeBuffer);\n                    break;\n                case ReturnWireCmd::DeviceCreateRenderPipelineAsyncCallback:\n                    success = HandleDeviceCreateRenderPipelineAsyncCallback(&deserializeBuffer);\n                    break;\n                case ReturnWireCmd::DeviceLoggingCallback:\n                    success = HandleDeviceLoggingCallback(&deserializeBuffer);\n                    break;\n                case ReturnWireCmd::DeviceLostCallback:\n                    success = HandleDeviceLostCallback(&deserializeBuffer);\n                    break;\n                case ReturnWireCmd::DevicePopErrorScopeCallback:\n                    success = HandleDevicePopErrorScopeCallback(&deserializeBuffer);\n                    break;\n                case ReturnWireCmd::DeviceUncapturedErrorCallback:\n                    success = HandleDeviceUncapturedErrorCallback(&deserializeBuffer);\n                    break;\n                case ReturnWireCmd::InstanceRequestAdapterCallback:\n                    success = HandleInstanceRequestAdapterCallback(&deserializeBuffer);\n                    break;\n                case ReturnWireCmd::QueueWorkDoneCallback:\n                    success = HandleQueueWorkDoneCallback(&deserializeBuffer);\n                    break;\n                case ReturnWireCmd::ShaderModuleGetCompilationInfoCallback:\n                    success = HandleShaderModuleGetCompilationInfoCallback(&deserializeBuffer);\n                    break;\n                default:\n                    success = false;\n            }\n\n            if (!success) {\n                return nullptr;\n            }\n            mWireCommandAllocator.Reset();\n        }\n\n        if (deserializeBuffer.AvailableSize() != 0) {\n            return nullptr;\n        }\n\n        return commands;\n    }\n}  // namespace dawn::wire::client\n", "src/dawn/wire/client/ClientPrototypes_autogen.inc": "\nbool HandleAdapterRequestDeviceCallback(DeserializeBuffer* deserializeBuffer);\nbool HandleBufferMapAsyncCallback(DeserializeBuffer* deserializeBuffer);\nbool HandleDeviceCreateComputePipelineAsyncCallback(DeserializeBuffer* deserializeBuffer);\nbool HandleDeviceCreateRenderPipelineAsyncCallback(DeserializeBuffer* deserializeBuffer);\nbool HandleDeviceLoggingCallback(DeserializeBuffer* deserializeBuffer);\nbool HandleDeviceLostCallback(DeserializeBuffer* deserializeBuffer);\nbool HandleDevicePopErrorScopeCallback(DeserializeBuffer* deserializeBuffer);\nbool HandleDeviceUncapturedErrorCallback(DeserializeBuffer* deserializeBuffer);\nbool HandleInstanceRequestAdapterCallback(DeserializeBuffer* deserializeBuffer);\nbool HandleQueueWorkDoneCallback(DeserializeBuffer* deserializeBuffer);\nbool HandleShaderModuleGetCompilationInfoCallback(DeserializeBuffer* deserializeBuffer);\n\nbool DoAdapterRequestDeviceCallback(Adapter* adapter, uint64_t requestSerial, WGPURequestDeviceStatus status, char const * message, WGPUSupportedLimits const * limits, uint32_t featuresCount, WGPUFeatureName const * features);\nbool DoBufferMapAsyncCallback(Buffer* buffer, uint64_t requestSerial, uint32_t status, uint64_t readDataUpdateInfoLength, uint8_t const * readDataUpdateInfo);\nbool DoDeviceCreateComputePipelineAsyncCallback(Device* device, uint64_t requestSerial, WGPUCreatePipelineAsyncStatus status, char const * message);\nbool DoDeviceCreateRenderPipelineAsyncCallback(Device* device, uint64_t requestSerial, WGPUCreatePipelineAsyncStatus status, char const * message);\nbool DoDeviceLoggingCallback(Device* device, WGPULoggingType type, char const * message);\nbool DoDeviceLostCallback(Device* device, WGPUDeviceLostReason reason, char const * message);\nbool DoDevicePopErrorScopeCallback(Device* device, uint64_t requestSerial, WGPUErrorType type, char const * message);\nbool DoDeviceUncapturedErrorCallback(Device* device, WGPUErrorType type, char const * message);\nbool DoInstanceRequestAdapterCallback(Instance* instance, uint64_t requestSerial, WGPURequestAdapterStatus status, char const * message, WGPUAdapterProperties const * properties, WGPUSupportedLimits const * limits, uint32_t featuresCount, WGPUFeatureName const * features);\nbool DoQueueWorkDoneCallback(Queue* queue, uint64_t requestSerial, WGPUQueueWorkDoneStatus status);\nbool DoShaderModuleGetCompilationInfoCallback(ShaderModule* shaderModule, uint64_t requestSerial, WGPUCompilationInfoRequestStatus status, WGPUCompilationInfo const * info);\n", "src/dawn/wire/server/ServerBase_autogen.h": "\n#ifndef DAWNWIRE_SERVER_SERVERBASE_H_\n#define DAWNWIRE_SERVER_SERVERBASE_H_\n\n#include \"dawn/dawn_proc_table.h\"\n#include \"dawn/wire/ChunkedCommandHandler.h\"\n#include \"dawn/wire/Wire.h\"\n#include \"dawn/wire/WireCmd_autogen.h\"\n#include \"dawn/wire/WireDeserializeAllocator.h\"\n#include \"dawn/wire/server/ObjectStorage.h\"\n\nnamespace dawn::wire::server {\n\n    class ServerBase : public ChunkedCommandHandler, public ObjectIdResolver {\n      public:\n        ServerBase() = default;\n        ~ServerBase() override = default;\n\n      protected:\n        void DestroyAllObjects(const DawnProcTable& procs) {\n            {\n                std::vector<WGPUDevice> handles = mKnownDevice.AcquireAllHandles();\n                for (WGPUDevice handle : handles) {\n                    procs.deviceRelease(handle);\n                }\n            }\n            {\n                std::vector<WGPUAdapter> handles = mKnownAdapter.AcquireAllHandles();\n                for (WGPUAdapter handle : handles) {\n                    procs.adapterRelease(handle);\n                }\n            }\n            {\n                std::vector<WGPUBindGroup> handles = mKnownBindGroup.AcquireAllHandles();\n                for (WGPUBindGroup handle : handles) {\n                    procs.bindGroupRelease(handle);\n                }\n            }\n            {\n                std::vector<WGPUBindGroupLayout> handles = mKnownBindGroupLayout.AcquireAllHandles();\n                for (WGPUBindGroupLayout handle : handles) {\n                    procs.bindGroupLayoutRelease(handle);\n                }\n            }\n            {\n                std::vector<WGPUBuffer> handles = mKnownBuffer.AcquireAllHandles();\n                for (WGPUBuffer handle : handles) {\n                    procs.bufferRelease(handle);\n                }\n            }\n            {\n                std::vector<WGPUCommandBuffer> handles = mKnownCommandBuffer.AcquireAllHandles();\n                for (WGPUCommandBuffer handle : handles) {\n                    procs.commandBufferRelease(handle);\n                }\n            }\n            {\n                std::vector<WGPUCommandEncoder> handles = mKnownCommandEncoder.AcquireAllHandles();\n                for (WGPUCommandEncoder handle : handles) {\n                    procs.commandEncoderRelease(handle);\n                }\n            }\n            {\n                std::vector<WGPUComputePassEncoder> handles = mKnownComputePassEncoder.AcquireAllHandles();\n                for (WGPUComputePassEncoder handle : handles) {\n                    procs.computePassEncoderRelease(handle);\n                }\n            }\n            {\n                std::vector<WGPUComputePipeline> handles = mKnownComputePipeline.AcquireAllHandles();\n                for (WGPUComputePipeline handle : handles) {\n                    procs.computePipelineRelease(handle);\n                }\n            }\n            {\n                std::vector<WGPUExternalTexture> handles = mKnownExternalTexture.AcquireAllHandles();\n                for (WGPUExternalTexture handle : handles) {\n                    procs.externalTextureRelease(handle);\n                }\n            }\n            {\n                std::vector<WGPUInstance> handles = mKnownInstance.AcquireAllHandles();\n                for (WGPUInstance handle : handles) {\n                    procs.instanceRelease(handle);\n                }\n            }\n            {\n                std::vector<WGPUPipelineLayout> handles = mKnownPipelineLayout.AcquireAllHandles();\n                for (WGPUPipelineLayout handle : handles) {\n                    procs.pipelineLayoutRelease(handle);\n                }\n            }\n            {\n                std::vector<WGPUQuerySet> handles = mKnownQuerySet.AcquireAllHandles();\n                for (WGPUQuerySet handle : handles) {\n                    procs.querySetRelease(handle);\n                }\n            }\n            {\n                std::vector<WGPUQueue> handles = mKnownQueue.AcquireAllHandles();\n                for (WGPUQueue handle : handles) {\n                    procs.queueRelease(handle);\n                }\n            }\n            {\n                std::vector<WGPURenderBundle> handles = mKnownRenderBundle.AcquireAllHandles();\n                for (WGPURenderBundle handle : handles) {\n                    procs.renderBundleRelease(handle);\n                }\n            }\n            {\n                std::vector<WGPURenderBundleEncoder> handles = mKnownRenderBundleEncoder.AcquireAllHandles();\n                for (WGPURenderBundleEncoder handle : handles) {\n                    procs.renderBundleEncoderRelease(handle);\n                }\n            }\n            {\n                std::vector<WGPURenderPassEncoder> handles = mKnownRenderPassEncoder.AcquireAllHandles();\n                for (WGPURenderPassEncoder handle : handles) {\n                    procs.renderPassEncoderRelease(handle);\n                }\n            }\n            {\n                std::vector<WGPURenderPipeline> handles = mKnownRenderPipeline.AcquireAllHandles();\n                for (WGPURenderPipeline handle : handles) {\n                    procs.renderPipelineRelease(handle);\n                }\n            }\n            {\n                std::vector<WGPUSampler> handles = mKnownSampler.AcquireAllHandles();\n                for (WGPUSampler handle : handles) {\n                    procs.samplerRelease(handle);\n                }\n            }\n            {\n                std::vector<WGPUShaderModule> handles = mKnownShaderModule.AcquireAllHandles();\n                for (WGPUShaderModule handle : handles) {\n                    procs.shaderModuleRelease(handle);\n                }\n            }\n            {\n                std::vector<WGPUSurface> handles = mKnownSurface.AcquireAllHandles();\n                for (WGPUSurface handle : handles) {\n                    procs.surfaceRelease(handle);\n                }\n            }\n            {\n                std::vector<WGPUSwapChain> handles = mKnownSwapChain.AcquireAllHandles();\n                for (WGPUSwapChain handle : handles) {\n                    procs.swapChainRelease(handle);\n                }\n            }\n            {\n                std::vector<WGPUTexture> handles = mKnownTexture.AcquireAllHandles();\n                for (WGPUTexture handle : handles) {\n                    procs.textureRelease(handle);\n                }\n            }\n            {\n                std::vector<WGPUTextureView> handles = mKnownTextureView.AcquireAllHandles();\n                for (WGPUTextureView handle : handles) {\n                    procs.textureViewRelease(handle);\n                }\n            }\n        }\n\n        const KnownObjects<WGPUAdapter>& AdapterObjects() const {\n            return mKnownAdapter;\n        }\n        KnownObjects<WGPUAdapter>& AdapterObjects() {\n            return mKnownAdapter;\n        }\n        const KnownObjects<WGPUBindGroup>& BindGroupObjects() const {\n            return mKnownBindGroup;\n        }\n        KnownObjects<WGPUBindGroup>& BindGroupObjects() {\n            return mKnownBindGroup;\n        }\n        const KnownObjects<WGPUBindGroupLayout>& BindGroupLayoutObjects() const {\n            return mKnownBindGroupLayout;\n        }\n        KnownObjects<WGPUBindGroupLayout>& BindGroupLayoutObjects() {\n            return mKnownBindGroupLayout;\n        }\n        const KnownObjects<WGPUBuffer>& BufferObjects() const {\n            return mKnownBuffer;\n        }\n        KnownObjects<WGPUBuffer>& BufferObjects() {\n            return mKnownBuffer;\n        }\n        const KnownObjects<WGPUCommandBuffer>& CommandBufferObjects() const {\n            return mKnownCommandBuffer;\n        }\n        KnownObjects<WGPUCommandBuffer>& CommandBufferObjects() {\n            return mKnownCommandBuffer;\n        }\n        const KnownObjects<WGPUCommandEncoder>& CommandEncoderObjects() const {\n            return mKnownCommandEncoder;\n        }\n        KnownObjects<WGPUCommandEncoder>& CommandEncoderObjects() {\n            return mKnownCommandEncoder;\n        }\n        const KnownObjects<WGPUComputePassEncoder>& ComputePassEncoderObjects() const {\n            return mKnownComputePassEncoder;\n        }\n        KnownObjects<WGPUComputePassEncoder>& ComputePassEncoderObjects() {\n            return mKnownComputePassEncoder;\n        }\n        const KnownObjects<WGPUComputePipeline>& ComputePipelineObjects() const {\n            return mKnownComputePipeline;\n        }\n        KnownObjects<WGPUComputePipeline>& ComputePipelineObjects() {\n            return mKnownComputePipeline;\n        }\n        const KnownObjects<WGPUDevice>& DeviceObjects() const {\n            return mKnownDevice;\n        }\n        KnownObjects<WGPUDevice>& DeviceObjects() {\n            return mKnownDevice;\n        }\n        const KnownObjects<WGPUExternalTexture>& ExternalTextureObjects() const {\n            return mKnownExternalTexture;\n        }\n        KnownObjects<WGPUExternalTexture>& ExternalTextureObjects() {\n            return mKnownExternalTexture;\n        }\n        const KnownObjects<WGPUInstance>& InstanceObjects() const {\n            return mKnownInstance;\n        }\n        KnownObjects<WGPUInstance>& InstanceObjects() {\n            return mKnownInstance;\n        }\n        const KnownObjects<WGPUPipelineLayout>& PipelineLayoutObjects() const {\n            return mKnownPipelineLayout;\n        }\n        KnownObjects<WGPUPipelineLayout>& PipelineLayoutObjects() {\n            return mKnownPipelineLayout;\n        }\n        const KnownObjects<WGPUQuerySet>& QuerySetObjects() const {\n            return mKnownQuerySet;\n        }\n        KnownObjects<WGPUQuerySet>& QuerySetObjects() {\n            return mKnownQuerySet;\n        }\n        const KnownObjects<WGPUQueue>& QueueObjects() const {\n            return mKnownQueue;\n        }\n        KnownObjects<WGPUQueue>& QueueObjects() {\n            return mKnownQueue;\n        }\n        const KnownObjects<WGPURenderBundle>& RenderBundleObjects() const {\n            return mKnownRenderBundle;\n        }\n        KnownObjects<WGPURenderBundle>& RenderBundleObjects() {\n            return mKnownRenderBundle;\n        }\n        const KnownObjects<WGPURenderBundleEncoder>& RenderBundleEncoderObjects() const {\n            return mKnownRenderBundleEncoder;\n        }\n        KnownObjects<WGPURenderBundleEncoder>& RenderBundleEncoderObjects() {\n            return mKnownRenderBundleEncoder;\n        }\n        const KnownObjects<WGPURenderPassEncoder>& RenderPassEncoderObjects() const {\n            return mKnownRenderPassEncoder;\n        }\n        KnownObjects<WGPURenderPassEncoder>& RenderPassEncoderObjects() {\n            return mKnownRenderPassEncoder;\n        }\n        const KnownObjects<WGPURenderPipeline>& RenderPipelineObjects() const {\n            return mKnownRenderPipeline;\n        }\n        KnownObjects<WGPURenderPipeline>& RenderPipelineObjects() {\n            return mKnownRenderPipeline;\n        }\n        const KnownObjects<WGPUSampler>& SamplerObjects() const {\n            return mKnownSampler;\n        }\n        KnownObjects<WGPUSampler>& SamplerObjects() {\n            return mKnownSampler;\n        }\n        const KnownObjects<WGPUShaderModule>& ShaderModuleObjects() const {\n            return mKnownShaderModule;\n        }\n        KnownObjects<WGPUShaderModule>& ShaderModuleObjects() {\n            return mKnownShaderModule;\n        }\n        const KnownObjects<WGPUSurface>& SurfaceObjects() const {\n            return mKnownSurface;\n        }\n        KnownObjects<WGPUSurface>& SurfaceObjects() {\n            return mKnownSurface;\n        }\n        const KnownObjects<WGPUSwapChain>& SwapChainObjects() const {\n            return mKnownSwapChain;\n        }\n        KnownObjects<WGPUSwapChain>& SwapChainObjects() {\n            return mKnownSwapChain;\n        }\n        const KnownObjects<WGPUTexture>& TextureObjects() const {\n            return mKnownTexture;\n        }\n        KnownObjects<WGPUTexture>& TextureObjects() {\n            return mKnownTexture;\n        }\n        const KnownObjects<WGPUTextureView>& TextureViewObjects() const {\n            return mKnownTextureView;\n        }\n        KnownObjects<WGPUTextureView>& TextureViewObjects() {\n            return mKnownTextureView;\n        }\n\n\n      private:\n        // Implementation of the ObjectIdResolver interface\n        WireResult GetFromId(ObjectId id, WGPUAdapter* out) const final {\n            return mKnownAdapter.GetNativeHandle(id, out);\n        }\n\n        WireResult GetOptionalFromId(ObjectId id, WGPUAdapter* out) const final {\n            if (id == 0) {\n                *out = nullptr;\n                return WireResult::Success;\n            }\n\n            return GetFromId(id, out);\n        }\n        WireResult GetFromId(ObjectId id, WGPUBindGroup* out) const final {\n            return mKnownBindGroup.GetNativeHandle(id, out);\n        }\n\n        WireResult GetOptionalFromId(ObjectId id, WGPUBindGroup* out) const final {\n            if (id == 0) {\n                *out = nullptr;\n                return WireResult::Success;\n            }\n\n            return GetFromId(id, out);\n        }\n        WireResult GetFromId(ObjectId id, WGPUBindGroupLayout* out) const final {\n            return mKnownBindGroupLayout.GetNativeHandle(id, out);\n        }\n\n        WireResult GetOptionalFromId(ObjectId id, WGPUBindGroupLayout* out) const final {\n            if (id == 0) {\n                *out = nullptr;\n                return WireResult::Success;\n            }\n\n            return GetFromId(id, out);\n        }\n        WireResult GetFromId(ObjectId id, WGPUBuffer* out) const final {\n            return mKnownBuffer.GetNativeHandle(id, out);\n        }\n\n        WireResult GetOptionalFromId(ObjectId id, WGPUBuffer* out) const final {\n            if (id == 0) {\n                *out = nullptr;\n                return WireResult::Success;\n            }\n\n            return GetFromId(id, out);\n        }\n        WireResult GetFromId(ObjectId id, WGPUCommandBuffer* out) const final {\n            return mKnownCommandBuffer.GetNativeHandle(id, out);\n        }\n\n        WireResult GetOptionalFromId(ObjectId id, WGPUCommandBuffer* out) const final {\n            if (id == 0) {\n                *out = nullptr;\n                return WireResult::Success;\n            }\n\n            return GetFromId(id, out);\n        }\n        WireResult GetFromId(ObjectId id, WGPUCommandEncoder* out) const final {\n            return mKnownCommandEncoder.GetNativeHandle(id, out);\n        }\n\n        WireResult GetOptionalFromId(ObjectId id, WGPUCommandEncoder* out) const final {\n            if (id == 0) {\n                *out = nullptr;\n                return WireResult::Success;\n            }\n\n            return GetFromId(id, out);\n        }\n        WireResult GetFromId(ObjectId id, WGPUComputePassEncoder* out) const final {\n            return mKnownComputePassEncoder.GetNativeHandle(id, out);\n        }\n\n        WireResult GetOptionalFromId(ObjectId id, WGPUComputePassEncoder* out) const final {\n            if (id == 0) {\n                *out = nullptr;\n                return WireResult::Success;\n            }\n\n            return GetFromId(id, out);\n        }\n        WireResult GetFromId(ObjectId id, WGPUComputePipeline* out) const final {\n            return mKnownComputePipeline.GetNativeHandle(id, out);\n        }\n\n        WireResult GetOptionalFromId(ObjectId id, WGPUComputePipeline* out) const final {\n            if (id == 0) {\n                *out = nullptr;\n                return WireResult::Success;\n            }\n\n            return GetFromId(id, out);\n        }\n        WireResult GetFromId(ObjectId id, WGPUDevice* out) const final {\n            return mKnownDevice.GetNativeHandle(id, out);\n        }\n\n        WireResult GetOptionalFromId(ObjectId id, WGPUDevice* out) const final {\n            if (id == 0) {\n                *out = nullptr;\n                return WireResult::Success;\n            }\n\n            return GetFromId(id, out);\n        }\n        WireResult GetFromId(ObjectId id, WGPUExternalTexture* out) const final {\n            return mKnownExternalTexture.GetNativeHandle(id, out);\n        }\n\n        WireResult GetOptionalFromId(ObjectId id, WGPUExternalTexture* out) const final {\n            if (id == 0) {\n                *out = nullptr;\n                return WireResult::Success;\n            }\n\n            return GetFromId(id, out);\n        }\n        WireResult GetFromId(ObjectId id, WGPUInstance* out) const final {\n            return mKnownInstance.GetNativeHandle(id, out);\n        }\n\n        WireResult GetOptionalFromId(ObjectId id, WGPUInstance* out) const final {\n            if (id == 0) {\n                *out = nullptr;\n                return WireResult::Success;\n            }\n\n            return GetFromId(id, out);\n        }\n        WireResult GetFromId(ObjectId id, WGPUPipelineLayout* out) const final {\n            return mKnownPipelineLayout.GetNativeHandle(id, out);\n        }\n\n        WireResult GetOptionalFromId(ObjectId id, WGPUPipelineLayout* out) const final {\n            if (id == 0) {\n                *out = nullptr;\n                return WireResult::Success;\n            }\n\n            return GetFromId(id, out);\n        }\n        WireResult GetFromId(ObjectId id, WGPUQuerySet* out) const final {\n            return mKnownQuerySet.GetNativeHandle(id, out);\n        }\n\n        WireResult GetOptionalFromId(ObjectId id, WGPUQuerySet* out) const final {\n            if (id == 0) {\n                *out = nullptr;\n                return WireResult::Success;\n            }\n\n            return GetFromId(id, out);\n        }\n        WireResult GetFromId(ObjectId id, WGPUQueue* out) const final {\n            return mKnownQueue.GetNativeHandle(id, out);\n        }\n\n        WireResult GetOptionalFromId(ObjectId id, WGPUQueue* out) const final {\n            if (id == 0) {\n                *out = nullptr;\n                return WireResult::Success;\n            }\n\n            return GetFromId(id, out);\n        }\n        WireResult GetFromId(ObjectId id, WGPURenderBundle* out) const final {\n            return mKnownRenderBundle.GetNativeHandle(id, out);\n        }\n\n        WireResult GetOptionalFromId(ObjectId id, WGPURenderBundle* out) const final {\n            if (id == 0) {\n                *out = nullptr;\n                return WireResult::Success;\n            }\n\n            return GetFromId(id, out);\n        }\n        WireResult GetFromId(ObjectId id, WGPURenderBundleEncoder* out) const final {\n            return mKnownRenderBundleEncoder.GetNativeHandle(id, out);\n        }\n\n        WireResult GetOptionalFromId(ObjectId id, WGPURenderBundleEncoder* out) const final {\n            if (id == 0) {\n                *out = nullptr;\n                return WireResult::Success;\n            }\n\n            return GetFromId(id, out);\n        }\n        WireResult GetFromId(ObjectId id, WGPURenderPassEncoder* out) const final {\n            return mKnownRenderPassEncoder.GetNativeHandle(id, out);\n        }\n\n        WireResult GetOptionalFromId(ObjectId id, WGPURenderPassEncoder* out) const final {\n            if (id == 0) {\n                *out = nullptr;\n                return WireResult::Success;\n            }\n\n            return GetFromId(id, out);\n        }\n        WireResult GetFromId(ObjectId id, WGPURenderPipeline* out) const final {\n            return mKnownRenderPipeline.GetNativeHandle(id, out);\n        }\n\n        WireResult GetOptionalFromId(ObjectId id, WGPURenderPipeline* out) const final {\n            if (id == 0) {\n                *out = nullptr;\n                return WireResult::Success;\n            }\n\n            return GetFromId(id, out);\n        }\n        WireResult GetFromId(ObjectId id, WGPUSampler* out) const final {\n            return mKnownSampler.GetNativeHandle(id, out);\n        }\n\n        WireResult GetOptionalFromId(ObjectId id, WGPUSampler* out) const final {\n            if (id == 0) {\n                *out = nullptr;\n                return WireResult::Success;\n            }\n\n            return GetFromId(id, out);\n        }\n        WireResult GetFromId(ObjectId id, WGPUShaderModule* out) const final {\n            return mKnownShaderModule.GetNativeHandle(id, out);\n        }\n\n        WireResult GetOptionalFromId(ObjectId id, WGPUShaderModule* out) const final {\n            if (id == 0) {\n                *out = nullptr;\n                return WireResult::Success;\n            }\n\n            return GetFromId(id, out);\n        }\n        WireResult GetFromId(ObjectId id, WGPUSurface* out) const final {\n            return mKnownSurface.GetNativeHandle(id, out);\n        }\n\n        WireResult GetOptionalFromId(ObjectId id, WGPUSurface* out) const final {\n            if (id == 0) {\n                *out = nullptr;\n                return WireResult::Success;\n            }\n\n            return GetFromId(id, out);\n        }\n        WireResult GetFromId(ObjectId id, WGPUSwapChain* out) const final {\n            return mKnownSwapChain.GetNativeHandle(id, out);\n        }\n\n        WireResult GetOptionalFromId(ObjectId id, WGPUSwapChain* out) const final {\n            if (id == 0) {\n                *out = nullptr;\n                return WireResult::Success;\n            }\n\n            return GetFromId(id, out);\n        }\n        WireResult GetFromId(ObjectId id, WGPUTexture* out) const final {\n            return mKnownTexture.GetNativeHandle(id, out);\n        }\n\n        WireResult GetOptionalFromId(ObjectId id, WGPUTexture* out) const final {\n            if (id == 0) {\n                *out = nullptr;\n                return WireResult::Success;\n            }\n\n            return GetFromId(id, out);\n        }\n        WireResult GetFromId(ObjectId id, WGPUTextureView* out) const final {\n            return mKnownTextureView.GetNativeHandle(id, out);\n        }\n\n        WireResult GetOptionalFromId(ObjectId id, WGPUTextureView* out) const final {\n            if (id == 0) {\n                *out = nullptr;\n                return WireResult::Success;\n            }\n\n            return GetFromId(id, out);\n        }\n\n        KnownObjects<WGPUAdapter> mKnownAdapter;\n        KnownObjects<WGPUBindGroup> mKnownBindGroup;\n        KnownObjects<WGPUBindGroupLayout> mKnownBindGroupLayout;\n        KnownObjects<WGPUBuffer> mKnownBuffer;\n        KnownObjects<WGPUCommandBuffer> mKnownCommandBuffer;\n        KnownObjects<WGPUCommandEncoder> mKnownCommandEncoder;\n        KnownObjects<WGPUComputePassEncoder> mKnownComputePassEncoder;\n        KnownObjects<WGPUComputePipeline> mKnownComputePipeline;\n        KnownObjects<WGPUDevice> mKnownDevice;\n        KnownObjects<WGPUExternalTexture> mKnownExternalTexture;\n        KnownObjects<WGPUInstance> mKnownInstance;\n        KnownObjects<WGPUPipelineLayout> mKnownPipelineLayout;\n        KnownObjects<WGPUQuerySet> mKnownQuerySet;\n        KnownObjects<WGPUQueue> mKnownQueue;\n        KnownObjects<WGPURenderBundle> mKnownRenderBundle;\n        KnownObjects<WGPURenderBundleEncoder> mKnownRenderBundleEncoder;\n        KnownObjects<WGPURenderPassEncoder> mKnownRenderPassEncoder;\n        KnownObjects<WGPURenderPipeline> mKnownRenderPipeline;\n        KnownObjects<WGPUSampler> mKnownSampler;\n        KnownObjects<WGPUShaderModule> mKnownShaderModule;\n        KnownObjects<WGPUSurface> mKnownSurface;\n        KnownObjects<WGPUSwapChain> mKnownSwapChain;\n        KnownObjects<WGPUTexture> mKnownTexture;\n        KnownObjects<WGPUTextureView> mKnownTextureView;\n\n    };\n\n}  // namespace dawn::wire::server\n\n#endif  // DAWNWIRE_SERVER_SERVERBASE_H_\n", "src/dawn/wire/server/ServerDoers_autogen.cpp": "\n#include \"dawn/common/Assert.h\"\n#include \"dawn/wire/server/Server.h\"\n\nnamespace dawn::wire::server {\n\n    WireResult Server::DoAdapterGetInstance(WGPUAdapter self, WGPUInstance* result) {\n        *result =\n        mProcs.adapterGetInstance(self);\n        ASSERT(*result != nullptr);\n        return WireResult::Success;\n    }\n\n\n    WireResult Server::DoBindGroupLayoutSetLabel(WGPUBindGroupLayout self, char const * label) {\n        \n        mProcs.bindGroupLayoutSetLabel(self, label);\n        return WireResult::Success;\n    }\n\n    WireResult Server::DoBindGroupSetLabel(WGPUBindGroup self, char const * label) {\n        \n        mProcs.bindGroupSetLabel(self, label);\n        return WireResult::Success;\n    }\n\n    WireResult Server::DoBufferDestroy(WGPUBuffer self) {\n        \n        mProcs.bufferDestroy(self);\n        return WireResult::Success;\n    }\n\n\n    WireResult Server::DoBufferSetLabel(WGPUBuffer self, char const * label) {\n        \n        mProcs.bufferSetLabel(self, label);\n        return WireResult::Success;\n    }\n\n    WireResult Server::DoBufferUnmap(WGPUBuffer self) {\n        \n        mProcs.bufferUnmap(self);\n        return WireResult::Success;\n    }\n\n\n    WireResult Server::DoCommandBufferSetLabel(WGPUCommandBuffer self, char const * label) {\n        \n        mProcs.commandBufferSetLabel(self, label);\n        return WireResult::Success;\n    }\n\n    WireResult Server::DoCommandEncoderBeginComputePass(WGPUCommandEncoder self, WGPUComputePassDescriptor const * descriptor, WGPUComputePassEncoder* result) {\n        *result =\n        mProcs.commandEncoderBeginComputePass(self, descriptor);\n        ASSERT(*result != nullptr);\n        return WireResult::Success;\n    }\n\n    WireResult Server::DoCommandEncoderBeginRenderPass(WGPUCommandEncoder self, WGPURenderPassDescriptor const * descriptor, WGPURenderPassEncoder* result) {\n        *result =\n        mProcs.commandEncoderBeginRenderPass(self, descriptor);\n        ASSERT(*result != nullptr);\n        return WireResult::Success;\n    }\n\n    WireResult Server::DoCommandEncoderClearBuffer(WGPUCommandEncoder self, WGPUBuffer buffer, uint64_t offset, uint64_t size) {\n        \n        mProcs.commandEncoderClearBuffer(self, buffer, offset, size);\n        return WireResult::Success;\n    }\n\n    WireResult Server::DoCommandEncoderCopyBufferToBuffer(WGPUCommandEncoder self, WGPUBuffer source, uint64_t sourceOffset, WGPUBuffer destination, uint64_t destinationOffset, uint64_t size) {\n        \n        mProcs.commandEncoderCopyBufferToBuffer(self, source, sourceOffset, destination, destinationOffset, size);\n        return WireResult::Success;\n    }\n\n    WireResult Server::DoCommandEncoderCopyBufferToTexture(WGPUCommandEncoder self, WGPUImageCopyBuffer const * source, WGPUImageCopyTexture const * destination, WGPUExtent3D const * copySize) {\n        \n        mProcs.commandEncoderCopyBufferToTexture(self, source, destination, copySize);\n        return WireResult::Success;\n    }\n\n    WireResult Server::DoCommandEncoderCopyTextureToBuffer(WGPUCommandEncoder self, WGPUImageCopyTexture const * source, WGPUImageCopyBuffer const * destination, WGPUExtent3D const * copySize) {\n        \n        mProcs.commandEncoderCopyTextureToBuffer(self, source, destination, copySize);\n        return WireResult::Success;\n    }\n\n    WireResult Server::DoCommandEncoderCopyTextureToTexture(WGPUCommandEncoder self, WGPUImageCopyTexture const * source, WGPUImageCopyTexture const * destination, WGPUExtent3D const * copySize) {\n        \n        mProcs.commandEncoderCopyTextureToTexture(self, source, destination, copySize);\n        return WireResult::Success;\n    }\n\n    WireResult Server::DoCommandEncoderCopyTextureToTextureInternal(WGPUCommandEncoder self, WGPUImageCopyTexture const * source, WGPUImageCopyTexture const * destination, WGPUExtent3D const * copySize) {\n        \n        mProcs.commandEncoderCopyTextureToTextureInternal(self, source, destination, copySize);\n        return WireResult::Success;\n    }\n\n    WireResult Server::DoCommandEncoderFinish(WGPUCommandEncoder self, WGPUCommandBufferDescriptor const * descriptor, WGPUCommandBuffer* result) {\n        *result =\n        mProcs.commandEncoderFinish(self, descriptor);\n        ASSERT(*result != nullptr);\n        return WireResult::Success;\n    }\n\n    WireResult Server::DoCommandEncoderInjectValidationError(WGPUCommandEncoder self, char const * message) {\n        \n        mProcs.commandEncoderInjectValidationError(self, message);\n        return WireResult::Success;\n    }\n\n    WireResult Server::DoCommandEncoderInsertDebugMarker(WGPUCommandEncoder self, char const * markerLabel) {\n        \n        mProcs.commandEncoderInsertDebugMarker(self, markerLabel);\n        return WireResult::Success;\n    }\n\n    WireResult Server::DoCommandEncoderPopDebugGroup(WGPUCommandEncoder self) {\n        \n        mProcs.commandEncoderPopDebugGroup(self);\n        return WireResult::Success;\n    }\n\n    WireResult Server::DoCommandEncoderPushDebugGroup(WGPUCommandEncoder self, char const * groupLabel) {\n        \n        mProcs.commandEncoderPushDebugGroup(self, groupLabel);\n        return WireResult::Success;\n    }\n\n    WireResult Server::DoCommandEncoderResolveQuerySet(WGPUCommandEncoder self, WGPUQuerySet querySet, uint32_t firstQuery, uint32_t queryCount, WGPUBuffer destination, uint64_t destinationOffset) {\n        \n        mProcs.commandEncoderResolveQuerySet(self, querySet, firstQuery, queryCount, destination, destinationOffset);\n        return WireResult::Success;\n    }\n\n    WireResult Server::DoCommandEncoderSetLabel(WGPUCommandEncoder self, char const * label) {\n        \n        mProcs.commandEncoderSetLabel(self, label);\n        return WireResult::Success;\n    }\n\n    WireResult Server::DoCommandEncoderWriteBuffer(WGPUCommandEncoder self, WGPUBuffer buffer, uint64_t bufferOffset, uint8_t const * data, uint64_t size) {\n        \n        mProcs.commandEncoderWriteBuffer(self, buffer, bufferOffset, data, size);\n        return WireResult::Success;\n    }\n\n    WireResult Server::DoCommandEncoderWriteTimestamp(WGPUCommandEncoder self, WGPUQuerySet querySet, uint32_t queryIndex) {\n        \n        mProcs.commandEncoderWriteTimestamp(self, querySet, queryIndex);\n        return WireResult::Success;\n    }\n\n    WireResult Server::DoComputePassEncoderDispatchWorkgroups(WGPUComputePassEncoder self, uint32_t workgroupCountX, uint32_t workgroupCountY, uint32_t workgroupCountZ) {\n        \n        mProcs.computePassEncoderDispatchWorkgroups(self, workgroupCountX, workgroupCountY, workgroupCountZ);\n        return WireResult::Success;\n    }\n\n    WireResult Server::DoComputePassEncoderDispatchWorkgroupsIndirect(WGPUComputePassEncoder self, WGPUBuffer indirectBuffer, uint64_t indirectOffset) {\n        \n        mProcs.computePassEncoderDispatchWorkgroupsIndirect(self, indirectBuffer, indirectOffset);\n        return WireResult::Success;\n    }\n\n    WireResult Server::DoComputePassEncoderEnd(WGPUComputePassEncoder self) {\n        \n        mProcs.computePassEncoderEnd(self);\n        return WireResult::Success;\n    }\n\n    WireResult Server::DoComputePassEncoderInsertDebugMarker(WGPUComputePassEncoder self, char const * markerLabel) {\n        \n        mProcs.computePassEncoderInsertDebugMarker(self, markerLabel);\n        return WireResult::Success;\n    }\n\n    WireResult Server::DoComputePassEncoderPopDebugGroup(WGPUComputePassEncoder self) {\n        \n        mProcs.computePassEncoderPopDebugGroup(self);\n        return WireResult::Success;\n    }\n\n    WireResult Server::DoComputePassEncoderPushDebugGroup(WGPUComputePassEncoder self, char const * groupLabel) {\n        \n        mProcs.computePassEncoderPushDebugGroup(self, groupLabel);\n        return WireResult::Success;\n    }\n\n    WireResult Server::DoComputePassEncoderSetBindGroup(WGPUComputePassEncoder self, uint32_t groupIndex, WGPUBindGroup group, size_t dynamicOffsetCount, uint32_t const * dynamicOffsets) {\n        \n        mProcs.computePassEncoderSetBindGroup(self, groupIndex, group, dynamicOffsetCount, dynamicOffsets);\n        return WireResult::Success;\n    }\n\n    WireResult Server::DoComputePassEncoderSetLabel(WGPUComputePassEncoder self, char const * label) {\n        \n        mProcs.computePassEncoderSetLabel(self, label);\n        return WireResult::Success;\n    }\n\n    WireResult Server::DoComputePassEncoderSetPipeline(WGPUComputePassEncoder self, WGPUComputePipeline pipeline) {\n        \n        mProcs.computePassEncoderSetPipeline(self, pipeline);\n        return WireResult::Success;\n    }\n\n    WireResult Server::DoComputePassEncoderWriteTimestamp(WGPUComputePassEncoder self, WGPUQuerySet querySet, uint32_t queryIndex) {\n        \n        mProcs.computePassEncoderWriteTimestamp(self, querySet, queryIndex);\n        return WireResult::Success;\n    }\n\n    WireResult Server::DoComputePipelineGetBindGroupLayout(WGPUComputePipeline self, uint32_t groupIndex, WGPUBindGroupLayout* result) {\n        *result =\n        mProcs.computePipelineGetBindGroupLayout(self, groupIndex);\n        ASSERT(*result != nullptr);\n        return WireResult::Success;\n    }\n\n    WireResult Server::DoComputePipelineSetLabel(WGPUComputePipeline self, char const * label) {\n        \n        mProcs.computePipelineSetLabel(self, label);\n        return WireResult::Success;\n    }\n\n\n    WireResult Server::DoDeviceCreateBindGroup(WGPUDevice self, WGPUBindGroupDescriptor const * descriptor, WGPUBindGroup* result) {\n        *result =\n        mProcs.deviceCreateBindGroup(self, descriptor);\n        ASSERT(*result != nullptr);\n        return WireResult::Success;\n    }\n\n    WireResult Server::DoDeviceCreateBindGroupLayout(WGPUDevice self, WGPUBindGroupLayoutDescriptor const * descriptor, WGPUBindGroupLayout* result) {\n        *result =\n        mProcs.deviceCreateBindGroupLayout(self, descriptor);\n        ASSERT(*result != nullptr);\n        return WireResult::Success;\n    }\n\n\n    WireResult Server::DoDeviceCreateCommandEncoder(WGPUDevice self, WGPUCommandEncoderDescriptor const * descriptor, WGPUCommandEncoder* result) {\n        *result =\n        mProcs.deviceCreateCommandEncoder(self, descriptor);\n        ASSERT(*result != nullptr);\n        return WireResult::Success;\n    }\n\n    WireResult Server::DoDeviceCreateComputePipeline(WGPUDevice self, WGPUComputePipelineDescriptor const * descriptor, WGPUComputePipeline* result) {\n        *result =\n        mProcs.deviceCreateComputePipeline(self, descriptor);\n        ASSERT(*result != nullptr);\n        return WireResult::Success;\n    }\n\n\n    WireResult Server::DoDeviceCreateErrorBuffer(WGPUDevice self, WGPUBufferDescriptor const * descriptor, WGPUBuffer* result) {\n        *result =\n        mProcs.deviceCreateErrorBuffer(self, descriptor);\n        ASSERT(*result != nullptr);\n        return WireResult::Success;\n    }\n\n    WireResult Server::DoDeviceCreateErrorExternalTexture(WGPUDevice self, WGPUExternalTexture* result) {\n        *result =\n        mProcs.deviceCreateErrorExternalTexture(self);\n        ASSERT(*result != nullptr);\n        return WireResult::Success;\n    }\n\n    WireResult Server::DoDeviceCreateErrorShaderModule(WGPUDevice self, WGPUShaderModuleDescriptor const * descriptor, char const * errorMessage, WGPUShaderModule* result) {\n        *result =\n        mProcs.deviceCreateErrorShaderModule(self, descriptor, errorMessage);\n        ASSERT(*result != nullptr);\n        return WireResult::Success;\n    }\n\n    WireResult Server::DoDeviceCreateErrorTexture(WGPUDevice self, WGPUTextureDescriptor const * descriptor, WGPUTexture* result) {\n        *result =\n        mProcs.deviceCreateErrorTexture(self, descriptor);\n        ASSERT(*result != nullptr);\n        return WireResult::Success;\n    }\n\n    WireResult Server::DoDeviceCreateExternalTexture(WGPUDevice self, WGPUExternalTextureDescriptor const * externalTextureDescriptor, WGPUExternalTexture* result) {\n        *result =\n        mProcs.deviceCreateExternalTexture(self, externalTextureDescriptor);\n        ASSERT(*result != nullptr);\n        return WireResult::Success;\n    }\n\n    WireResult Server::DoDeviceCreatePipelineLayout(WGPUDevice self, WGPUPipelineLayoutDescriptor const * descriptor, WGPUPipelineLayout* result) {\n        *result =\n        mProcs.deviceCreatePipelineLayout(self, descriptor);\n        ASSERT(*result != nullptr);\n        return WireResult::Success;\n    }\n\n    WireResult Server::DoDeviceCreateQuerySet(WGPUDevice self, WGPUQuerySetDescriptor const * descriptor, WGPUQuerySet* result) {\n        *result =\n        mProcs.deviceCreateQuerySet(self, descriptor);\n        ASSERT(*result != nullptr);\n        return WireResult::Success;\n    }\n\n    WireResult Server::DoDeviceCreateRenderBundleEncoder(WGPUDevice self, WGPURenderBundleEncoderDescriptor const * descriptor, WGPURenderBundleEncoder* result) {\n        *result =\n        mProcs.deviceCreateRenderBundleEncoder(self, descriptor);\n        ASSERT(*result != nullptr);\n        return WireResult::Success;\n    }\n\n    WireResult Server::DoDeviceCreateRenderPipeline(WGPUDevice self, WGPURenderPipelineDescriptor const * descriptor, WGPURenderPipeline* result) {\n        *result =\n        mProcs.deviceCreateRenderPipeline(self, descriptor);\n        ASSERT(*result != nullptr);\n        return WireResult::Success;\n    }\n\n\n    WireResult Server::DoDeviceCreateSampler(WGPUDevice self, WGPUSamplerDescriptor const * descriptor, WGPUSampler* result) {\n        *result =\n        mProcs.deviceCreateSampler(self, descriptor);\n        ASSERT(*result != nullptr);\n        return WireResult::Success;\n    }\n\n    WireResult Server::DoDeviceCreateShaderModule(WGPUDevice self, WGPUShaderModuleDescriptor const * descriptor, WGPUShaderModule* result) {\n        *result =\n        mProcs.deviceCreateShaderModule(self, descriptor);\n        ASSERT(*result != nullptr);\n        return WireResult::Success;\n    }\n\n    WireResult Server::DoDeviceCreateSwapChain(WGPUDevice self, WGPUSurface surface, WGPUSwapChainDescriptor const * descriptor, WGPUSwapChain* result) {\n        *result =\n        mProcs.deviceCreateSwapChain(self, surface, descriptor);\n        ASSERT(*result != nullptr);\n        return WireResult::Success;\n    }\n\n    WireResult Server::DoDeviceCreateTexture(WGPUDevice self, WGPUTextureDescriptor const * descriptor, WGPUTexture* result) {\n        *result =\n        mProcs.deviceCreateTexture(self, descriptor);\n        ASSERT(*result != nullptr);\n        return WireResult::Success;\n    }\n\n    WireResult Server::DoDeviceDestroy(WGPUDevice self) {\n        \n        mProcs.deviceDestroy(self);\n        return WireResult::Success;\n    }\n\n    WireResult Server::DoDeviceForceLoss(WGPUDevice self, WGPUDeviceLostReason type, char const * message) {\n        \n        mProcs.deviceForceLoss(self, type, message);\n        return WireResult::Success;\n    }\n\n    WireResult Server::DoDeviceGetAdapter(WGPUDevice self, WGPUAdapter* result) {\n        *result =\n        mProcs.deviceGetAdapter(self);\n        ASSERT(*result != nullptr);\n        return WireResult::Success;\n    }\n\n    WireResult Server::DoDeviceGetQueue(WGPUDevice self, WGPUQueue* result) {\n        *result =\n        mProcs.deviceGetQueue(self);\n        ASSERT(*result != nullptr);\n        return WireResult::Success;\n    }\n\n    WireResult Server::DoDeviceInjectError(WGPUDevice self, WGPUErrorType type, char const * message) {\n        \n        mProcs.deviceInjectError(self, type, message);\n        return WireResult::Success;\n    }\n\n\n    WireResult Server::DoDevicePushErrorScope(WGPUDevice self, WGPUErrorFilter filter) {\n        \n        mProcs.devicePushErrorScope(self, filter);\n        return WireResult::Success;\n    }\n\n    WireResult Server::DoDeviceSetLabel(WGPUDevice self, char const * label) {\n        \n        mProcs.deviceSetLabel(self, label);\n        return WireResult::Success;\n    }\n\n    WireResult Server::DoDeviceTick(WGPUDevice self) {\n        \n        mProcs.deviceTick(self);\n        return WireResult::Success;\n    }\n\n    WireResult Server::DoDeviceValidateTextureDescriptor(WGPUDevice self, WGPUTextureDescriptor const * descriptor) {\n        \n        mProcs.deviceValidateTextureDescriptor(self, descriptor);\n        return WireResult::Success;\n    }\n\n    WireResult Server::DoExternalTextureDestroy(WGPUExternalTexture self) {\n        \n        mProcs.externalTextureDestroy(self);\n        return WireResult::Success;\n    }\n\n    WireResult Server::DoExternalTextureExpire(WGPUExternalTexture self) {\n        \n        mProcs.externalTextureExpire(self);\n        return WireResult::Success;\n    }\n\n    WireResult Server::DoExternalTextureRefresh(WGPUExternalTexture self) {\n        \n        mProcs.externalTextureRefresh(self);\n        return WireResult::Success;\n    }\n\n    WireResult Server::DoExternalTextureSetLabel(WGPUExternalTexture self, char const * label) {\n        \n        mProcs.externalTextureSetLabel(self, label);\n        return WireResult::Success;\n    }\n\n    WireResult Server::DoInstanceCreateSurface(WGPUInstance self, WGPUSurfaceDescriptor const * descriptor, WGPUSurface* result) {\n        *result =\n        mProcs.instanceCreateSurface(self, descriptor);\n        ASSERT(*result != nullptr);\n        return WireResult::Success;\n    }\n\n    WireResult Server::DoInstanceProcessEvents(WGPUInstance self) {\n        \n        mProcs.instanceProcessEvents(self);\n        return WireResult::Success;\n    }\n\n\n    WireResult Server::DoPipelineLayoutSetLabel(WGPUPipelineLayout self, char const * label) {\n        \n        mProcs.pipelineLayoutSetLabel(self, label);\n        return WireResult::Success;\n    }\n\n    WireResult Server::DoQuerySetDestroy(WGPUQuerySet self) {\n        \n        mProcs.querySetDestroy(self);\n        return WireResult::Success;\n    }\n\n    WireResult Server::DoQuerySetSetLabel(WGPUQuerySet self, char const * label) {\n        \n        mProcs.querySetSetLabel(self, label);\n        return WireResult::Success;\n    }\n\n    WireResult Server::DoQueueCopyExternalTextureForBrowser(WGPUQueue self, WGPUImageCopyExternalTexture const * source, WGPUImageCopyTexture const * destination, WGPUExtent3D const * copySize, WGPUCopyTextureForBrowserOptions const * options) {\n        \n        mProcs.queueCopyExternalTextureForBrowser(self, source, destination, copySize, options);\n        return WireResult::Success;\n    }\n\n    WireResult Server::DoQueueCopyTextureForBrowser(WGPUQueue self, WGPUImageCopyTexture const * source, WGPUImageCopyTexture const * destination, WGPUExtent3D const * copySize, WGPUCopyTextureForBrowserOptions const * options) {\n        \n        mProcs.queueCopyTextureForBrowser(self, source, destination, copySize, options);\n        return WireResult::Success;\n    }\n\n\n    WireResult Server::DoQueueSetLabel(WGPUQueue self, char const * label) {\n        \n        mProcs.queueSetLabel(self, label);\n        return WireResult::Success;\n    }\n\n    WireResult Server::DoQueueSubmit(WGPUQueue self, size_t commandCount, WGPUCommandBuffer const * commands) {\n        \n        mProcs.queueSubmit(self, commandCount, commands);\n        return WireResult::Success;\n    }\n\n\n\n    WireResult Server::DoRenderBundleEncoderDraw(WGPURenderBundleEncoder self, uint32_t vertexCount, uint32_t instanceCount, uint32_t firstVertex, uint32_t firstInstance) {\n        \n        mProcs.renderBundleEncoderDraw(self, vertexCount, instanceCount, firstVertex, firstInstance);\n        return WireResult::Success;\n    }\n\n    WireResult Server::DoRenderBundleEncoderDrawIndexed(WGPURenderBundleEncoder self, uint32_t indexCount, uint32_t instanceCount, uint32_t firstIndex, int32_t baseVertex, uint32_t firstInstance) {\n        \n        mProcs.renderBundleEncoderDrawIndexed(self, indexCount, instanceCount, firstIndex, baseVertex, firstInstance);\n        return WireResult::Success;\n    }\n\n    WireResult Server::DoRenderBundleEncoderDrawIndexedIndirect(WGPURenderBundleEncoder self, WGPUBuffer indirectBuffer, uint64_t indirectOffset) {\n        \n        mProcs.renderBundleEncoderDrawIndexedIndirect(self, indirectBuffer, indirectOffset);\n        return WireResult::Success;\n    }\n\n    WireResult Server::DoRenderBundleEncoderDrawIndirect(WGPURenderBundleEncoder self, WGPUBuffer indirectBuffer, uint64_t indirectOffset) {\n        \n        mProcs.renderBundleEncoderDrawIndirect(self, indirectBuffer, indirectOffset);\n        return WireResult::Success;\n    }\n\n    WireResult Server::DoRenderBundleEncoderFinish(WGPURenderBundleEncoder self, WGPURenderBundleDescriptor const * descriptor, WGPURenderBundle* result) {\n        *result =\n        mProcs.renderBundleEncoderFinish(self, descriptor);\n        ASSERT(*result != nullptr);\n        return WireResult::Success;\n    }\n\n    WireResult Server::DoRenderBundleEncoderInsertDebugMarker(WGPURenderBundleEncoder self, char const * markerLabel) {\n        \n        mProcs.renderBundleEncoderInsertDebugMarker(self, markerLabel);\n        return WireResult::Success;\n    }\n\n    WireResult Server::DoRenderBundleEncoderPopDebugGroup(WGPURenderBundleEncoder self) {\n        \n        mProcs.renderBundleEncoderPopDebugGroup(self);\n        return WireResult::Success;\n    }\n\n    WireResult Server::DoRenderBundleEncoderPushDebugGroup(WGPURenderBundleEncoder self, char const * groupLabel) {\n        \n        mProcs.renderBundleEncoderPushDebugGroup(self, groupLabel);\n        return WireResult::Success;\n    }\n\n    WireResult Server::DoRenderBundleEncoderSetBindGroup(WGPURenderBundleEncoder self, uint32_t groupIndex, WGPUBindGroup group, size_t dynamicOffsetCount, uint32_t const * dynamicOffsets) {\n        \n        mProcs.renderBundleEncoderSetBindGroup(self, groupIndex, group, dynamicOffsetCount, dynamicOffsets);\n        return WireResult::Success;\n    }\n\n    WireResult Server::DoRenderBundleEncoderSetIndexBuffer(WGPURenderBundleEncoder self, WGPUBuffer buffer, WGPUIndexFormat format, uint64_t offset, uint64_t size) {\n        \n        mProcs.renderBundleEncoderSetIndexBuffer(self, buffer, format, offset, size);\n        return WireResult::Success;\n    }\n\n    WireResult Server::DoRenderBundleEncoderSetLabel(WGPURenderBundleEncoder self, char const * label) {\n        \n        mProcs.renderBundleEncoderSetLabel(self, label);\n        return WireResult::Success;\n    }\n\n    WireResult Server::DoRenderBundleEncoderSetPipeline(WGPURenderBundleEncoder self, WGPURenderPipeline pipeline) {\n        \n        mProcs.renderBundleEncoderSetPipeline(self, pipeline);\n        return WireResult::Success;\n    }\n\n    WireResult Server::DoRenderBundleEncoderSetVertexBuffer(WGPURenderBundleEncoder self, uint32_t slot, WGPUBuffer buffer, uint64_t offset, uint64_t size) {\n        \n        mProcs.renderBundleEncoderSetVertexBuffer(self, slot, buffer, offset, size);\n        return WireResult::Success;\n    }\n\n    WireResult Server::DoRenderBundleSetLabel(WGPURenderBundle self, char const * label) {\n        \n        mProcs.renderBundleSetLabel(self, label);\n        return WireResult::Success;\n    }\n\n    WireResult Server::DoRenderPassEncoderBeginOcclusionQuery(WGPURenderPassEncoder self, uint32_t queryIndex) {\n        \n        mProcs.renderPassEncoderBeginOcclusionQuery(self, queryIndex);\n        return WireResult::Success;\n    }\n\n    WireResult Server::DoRenderPassEncoderDraw(WGPURenderPassEncoder self, uint32_t vertexCount, uint32_t instanceCount, uint32_t firstVertex, uint32_t firstInstance) {\n        \n        mProcs.renderPassEncoderDraw(self, vertexCount, instanceCount, firstVertex, firstInstance);\n        return WireResult::Success;\n    }\n\n    WireResult Server::DoRenderPassEncoderDrawIndexed(WGPURenderPassEncoder self, uint32_t indexCount, uint32_t instanceCount, uint32_t firstIndex, int32_t baseVertex, uint32_t firstInstance) {\n        \n        mProcs.renderPassEncoderDrawIndexed(self, indexCount, instanceCount, firstIndex, baseVertex, firstInstance);\n        return WireResult::Success;\n    }\n\n    WireResult Server::DoRenderPassEncoderDrawIndexedIndirect(WGPURenderPassEncoder self, WGPUBuffer indirectBuffer, uint64_t indirectOffset) {\n        \n        mProcs.renderPassEncoderDrawIndexedIndirect(self, indirectBuffer, indirectOffset);\n        return WireResult::Success;\n    }\n\n    WireResult Server::DoRenderPassEncoderDrawIndirect(WGPURenderPassEncoder self, WGPUBuffer indirectBuffer, uint64_t indirectOffset) {\n        \n        mProcs.renderPassEncoderDrawIndirect(self, indirectBuffer, indirectOffset);\n        return WireResult::Success;\n    }\n\n    WireResult Server::DoRenderPassEncoderEnd(WGPURenderPassEncoder self) {\n        \n        mProcs.renderPassEncoderEnd(self);\n        return WireResult::Success;\n    }\n\n    WireResult Server::DoRenderPassEncoderEndOcclusionQuery(WGPURenderPassEncoder self) {\n        \n        mProcs.renderPassEncoderEndOcclusionQuery(self);\n        return WireResult::Success;\n    }\n\n    WireResult Server::DoRenderPassEncoderExecuteBundles(WGPURenderPassEncoder self, size_t bundleCount, WGPURenderBundle const * bundles) {\n        \n        mProcs.renderPassEncoderExecuteBundles(self, bundleCount, bundles);\n        return WireResult::Success;\n    }\n\n    WireResult Server::DoRenderPassEncoderInsertDebugMarker(WGPURenderPassEncoder self, char const * markerLabel) {\n        \n        mProcs.renderPassEncoderInsertDebugMarker(self, markerLabel);\n        return WireResult::Success;\n    }\n\n    WireResult Server::DoRenderPassEncoderPopDebugGroup(WGPURenderPassEncoder self) {\n        \n        mProcs.renderPassEncoderPopDebugGroup(self);\n        return WireResult::Success;\n    }\n\n    WireResult Server::DoRenderPassEncoderPushDebugGroup(WGPURenderPassEncoder self, char const * groupLabel) {\n        \n        mProcs.renderPassEncoderPushDebugGroup(self, groupLabel);\n        return WireResult::Success;\n    }\n\n    WireResult Server::DoRenderPassEncoderSetBindGroup(WGPURenderPassEncoder self, uint32_t groupIndex, WGPUBindGroup group, size_t dynamicOffsetCount, uint32_t const * dynamicOffsets) {\n        \n        mProcs.renderPassEncoderSetBindGroup(self, groupIndex, group, dynamicOffsetCount, dynamicOffsets);\n        return WireResult::Success;\n    }\n\n    WireResult Server::DoRenderPassEncoderSetBlendConstant(WGPURenderPassEncoder self, WGPUColor const * color) {\n        \n        mProcs.renderPassEncoderSetBlendConstant(self, color);\n        return WireResult::Success;\n    }\n\n    WireResult Server::DoRenderPassEncoderSetIndexBuffer(WGPURenderPassEncoder self, WGPUBuffer buffer, WGPUIndexFormat format, uint64_t offset, uint64_t size) {\n        \n        mProcs.renderPassEncoderSetIndexBuffer(self, buffer, format, offset, size);\n        return WireResult::Success;\n    }\n\n    WireResult Server::DoRenderPassEncoderSetLabel(WGPURenderPassEncoder self, char const * label) {\n        \n        mProcs.renderPassEncoderSetLabel(self, label);\n        return WireResult::Success;\n    }\n\n    WireResult Server::DoRenderPassEncoderSetPipeline(WGPURenderPassEncoder self, WGPURenderPipeline pipeline) {\n        \n        mProcs.renderPassEncoderSetPipeline(self, pipeline);\n        return WireResult::Success;\n    }\n\n    WireResult Server::DoRenderPassEncoderSetScissorRect(WGPURenderPassEncoder self, uint32_t x, uint32_t y, uint32_t width, uint32_t height) {\n        \n        mProcs.renderPassEncoderSetScissorRect(self, x, y, width, height);\n        return WireResult::Success;\n    }\n\n    WireResult Server::DoRenderPassEncoderSetStencilReference(WGPURenderPassEncoder self, uint32_t reference) {\n        \n        mProcs.renderPassEncoderSetStencilReference(self, reference);\n        return WireResult::Success;\n    }\n\n    WireResult Server::DoRenderPassEncoderSetVertexBuffer(WGPURenderPassEncoder self, uint32_t slot, WGPUBuffer buffer, uint64_t offset, uint64_t size) {\n        \n        mProcs.renderPassEncoderSetVertexBuffer(self, slot, buffer, offset, size);\n        return WireResult::Success;\n    }\n\n    WireResult Server::DoRenderPassEncoderSetViewport(WGPURenderPassEncoder self, float x, float y, float width, float height, float minDepth, float maxDepth) {\n        \n        mProcs.renderPassEncoderSetViewport(self, x, y, width, height, minDepth, maxDepth);\n        return WireResult::Success;\n    }\n\n    WireResult Server::DoRenderPassEncoderWriteTimestamp(WGPURenderPassEncoder self, WGPUQuerySet querySet, uint32_t queryIndex) {\n        \n        mProcs.renderPassEncoderWriteTimestamp(self, querySet, queryIndex);\n        return WireResult::Success;\n    }\n\n    WireResult Server::DoRenderPipelineGetBindGroupLayout(WGPURenderPipeline self, uint32_t groupIndex, WGPUBindGroupLayout* result) {\n        *result =\n        mProcs.renderPipelineGetBindGroupLayout(self, groupIndex);\n        ASSERT(*result != nullptr);\n        return WireResult::Success;\n    }\n\n    WireResult Server::DoRenderPipelineSetLabel(WGPURenderPipeline self, char const * label) {\n        \n        mProcs.renderPipelineSetLabel(self, label);\n        return WireResult::Success;\n    }\n\n    WireResult Server::DoSamplerSetLabel(WGPUSampler self, char const * label) {\n        \n        mProcs.samplerSetLabel(self, label);\n        return WireResult::Success;\n    }\n\n\n    WireResult Server::DoShaderModuleSetLabel(WGPUShaderModule self, char const * label) {\n        \n        mProcs.shaderModuleSetLabel(self, label);\n        return WireResult::Success;\n    }\n\n    WireResult Server::DoSwapChainGetCurrentTexture(WGPUSwapChain self, WGPUTexture* result) {\n        *result =\n        mProcs.swapChainGetCurrentTexture(self);\n        ASSERT(*result != nullptr);\n        return WireResult::Success;\n    }\n\n    WireResult Server::DoSwapChainGetCurrentTextureView(WGPUSwapChain self, WGPUTextureView* result) {\n        *result =\n        mProcs.swapChainGetCurrentTextureView(self);\n        ASSERT(*result != nullptr);\n        return WireResult::Success;\n    }\n\n    WireResult Server::DoSwapChainPresent(WGPUSwapChain self) {\n        \n        mProcs.swapChainPresent(self);\n        return WireResult::Success;\n    }\n\n    WireResult Server::DoTextureCreateView(WGPUTexture self, WGPUTextureViewDescriptor const * descriptor, WGPUTextureView* result) {\n        *result =\n        mProcs.textureCreateView(self, descriptor);\n        ASSERT(*result != nullptr);\n        return WireResult::Success;\n    }\n\n    WireResult Server::DoTextureDestroy(WGPUTexture self) {\n        \n        mProcs.textureDestroy(self);\n        return WireResult::Success;\n    }\n\n    WireResult Server::DoTextureSetLabel(WGPUTexture self, char const * label) {\n        \n        mProcs.textureSetLabel(self, label);\n        return WireResult::Success;\n    }\n\n    WireResult Server::DoTextureViewSetLabel(WGPUTextureView self, char const * label) {\n        \n        mProcs.textureViewSetLabel(self, label);\n        return WireResult::Success;\n    }\n\n    WireResult Server::DoDestroyObject(ObjectType objectType, ObjectId objectId) {\n        switch(objectType) {\n            case ObjectType::Adapter: {\n                Known<WGPUAdapter> obj;\n                WIRE_TRY(AdapterObjects().Get(objectId, &obj));\n\n                if (obj->state == AllocationState::Allocated) {\n                    ASSERT(obj->handle != nullptr);\n\n\n                    mProcs.adapterRelease(obj->handle);\n                }\n                AdapterObjects().Free(objectId);\n                return WireResult::Success;\n            }\n            case ObjectType::BindGroup: {\n                Known<WGPUBindGroup> obj;\n                WIRE_TRY(BindGroupObjects().Get(objectId, &obj));\n\n                if (obj->state == AllocationState::Allocated) {\n                    ASSERT(obj->handle != nullptr);\n\n\n                    mProcs.bindGroupRelease(obj->handle);\n                }\n                BindGroupObjects().Free(objectId);\n                return WireResult::Success;\n            }\n            case ObjectType::BindGroupLayout: {\n                Known<WGPUBindGroupLayout> obj;\n                WIRE_TRY(BindGroupLayoutObjects().Get(objectId, &obj));\n\n                if (obj->state == AllocationState::Allocated) {\n                    ASSERT(obj->handle != nullptr);\n\n\n                    mProcs.bindGroupLayoutRelease(obj->handle);\n                }\n                BindGroupLayoutObjects().Free(objectId);\n                return WireResult::Success;\n            }\n            case ObjectType::Buffer: {\n                Known<WGPUBuffer> obj;\n                WIRE_TRY(BufferObjects().Get(objectId, &obj));\n\n                if (obj->state == AllocationState::Allocated) {\n                    ASSERT(obj->handle != nullptr);\n\n\n                    mProcs.bufferRelease(obj->handle);\n                }\n                BufferObjects().Free(objectId);\n                return WireResult::Success;\n            }\n            case ObjectType::CommandBuffer: {\n                Known<WGPUCommandBuffer> obj;\n                WIRE_TRY(CommandBufferObjects().Get(objectId, &obj));\n\n                if (obj->state == AllocationState::Allocated) {\n                    ASSERT(obj->handle != nullptr);\n\n\n                    mProcs.commandBufferRelease(obj->handle);\n                }\n                CommandBufferObjects().Free(objectId);\n                return WireResult::Success;\n            }\n            case ObjectType::CommandEncoder: {\n                Known<WGPUCommandEncoder> obj;\n                WIRE_TRY(CommandEncoderObjects().Get(objectId, &obj));\n\n                if (obj->state == AllocationState::Allocated) {\n                    ASSERT(obj->handle != nullptr);\n\n\n                    mProcs.commandEncoderRelease(obj->handle);\n                }\n                CommandEncoderObjects().Free(objectId);\n                return WireResult::Success;\n            }\n            case ObjectType::ComputePassEncoder: {\n                Known<WGPUComputePassEncoder> obj;\n                WIRE_TRY(ComputePassEncoderObjects().Get(objectId, &obj));\n\n                if (obj->state == AllocationState::Allocated) {\n                    ASSERT(obj->handle != nullptr);\n\n\n                    mProcs.computePassEncoderRelease(obj->handle);\n                }\n                ComputePassEncoderObjects().Free(objectId);\n                return WireResult::Success;\n            }\n            case ObjectType::ComputePipeline: {\n                Known<WGPUComputePipeline> obj;\n                WIRE_TRY(ComputePipelineObjects().Get(objectId, &obj));\n\n                if (obj->state == AllocationState::Allocated) {\n                    ASSERT(obj->handle != nullptr);\n\n\n                    mProcs.computePipelineRelease(obj->handle);\n                }\n                ComputePipelineObjects().Free(objectId);\n                return WireResult::Success;\n            }\n            case ObjectType::Device: {\n                Known<WGPUDevice> obj;\n                WIRE_TRY(DeviceObjects().Get(objectId, &obj));\n\n                if (obj->state == AllocationState::Allocated) {\n                    ASSERT(obj->handle != nullptr);\n\n                    if (obj->handle != nullptr) {\n                        ClearDeviceCallbacks(obj->handle);\n                    }\n\n                    mProcs.deviceRelease(obj->handle);\n                }\n                DeviceObjects().Free(objectId);\n                return WireResult::Success;\n            }\n            case ObjectType::ExternalTexture: {\n                Known<WGPUExternalTexture> obj;\n                WIRE_TRY(ExternalTextureObjects().Get(objectId, &obj));\n\n                if (obj->state == AllocationState::Allocated) {\n                    ASSERT(obj->handle != nullptr);\n\n\n                    mProcs.externalTextureRelease(obj->handle);\n                }\n                ExternalTextureObjects().Free(objectId);\n                return WireResult::Success;\n            }\n            case ObjectType::Instance: {\n                Known<WGPUInstance> obj;\n                WIRE_TRY(InstanceObjects().Get(objectId, &obj));\n\n                if (obj->state == AllocationState::Allocated) {\n                    ASSERT(obj->handle != nullptr);\n\n\n                    mProcs.instanceRelease(obj->handle);\n                }\n                InstanceObjects().Free(objectId);\n                return WireResult::Success;\n            }\n            case ObjectType::PipelineLayout: {\n                Known<WGPUPipelineLayout> obj;\n                WIRE_TRY(PipelineLayoutObjects().Get(objectId, &obj));\n\n                if (obj->state == AllocationState::Allocated) {\n                    ASSERT(obj->handle != nullptr);\n\n\n                    mProcs.pipelineLayoutRelease(obj->handle);\n                }\n                PipelineLayoutObjects().Free(objectId);\n                return WireResult::Success;\n            }\n            case ObjectType::QuerySet: {\n                Known<WGPUQuerySet> obj;\n                WIRE_TRY(QuerySetObjects().Get(objectId, &obj));\n\n                if (obj->state == AllocationState::Allocated) {\n                    ASSERT(obj->handle != nullptr);\n\n\n                    mProcs.querySetRelease(obj->handle);\n                }\n                QuerySetObjects().Free(objectId);\n                return WireResult::Success;\n            }\n            case ObjectType::Queue: {\n                Known<WGPUQueue> obj;\n                WIRE_TRY(QueueObjects().Get(objectId, &obj));\n\n                if (obj->state == AllocationState::Allocated) {\n                    ASSERT(obj->handle != nullptr);\n\n\n                    mProcs.queueRelease(obj->handle);\n                }\n                QueueObjects().Free(objectId);\n                return WireResult::Success;\n            }\n            case ObjectType::RenderBundle: {\n                Known<WGPURenderBundle> obj;\n                WIRE_TRY(RenderBundleObjects().Get(objectId, &obj));\n\n                if (obj->state == AllocationState::Allocated) {\n                    ASSERT(obj->handle != nullptr);\n\n\n                    mProcs.renderBundleRelease(obj->handle);\n                }\n                RenderBundleObjects().Free(objectId);\n                return WireResult::Success;\n            }\n            case ObjectType::RenderBundleEncoder: {\n                Known<WGPURenderBundleEncoder> obj;\n                WIRE_TRY(RenderBundleEncoderObjects().Get(objectId, &obj));\n\n                if (obj->state == AllocationState::Allocated) {\n                    ASSERT(obj->handle != nullptr);\n\n\n                    mProcs.renderBundleEncoderRelease(obj->handle);\n                }\n                RenderBundleEncoderObjects().Free(objectId);\n                return WireResult::Success;\n            }\n            case ObjectType::RenderPassEncoder: {\n                Known<WGPURenderPassEncoder> obj;\n                WIRE_TRY(RenderPassEncoderObjects().Get(objectId, &obj));\n\n                if (obj->state == AllocationState::Allocated) {\n                    ASSERT(obj->handle != nullptr);\n\n\n                    mProcs.renderPassEncoderRelease(obj->handle);\n                }\n                RenderPassEncoderObjects().Free(objectId);\n                return WireResult::Success;\n            }\n            case ObjectType::RenderPipeline: {\n                Known<WGPURenderPipeline> obj;\n                WIRE_TRY(RenderPipelineObjects().Get(objectId, &obj));\n\n                if (obj->state == AllocationState::Allocated) {\n                    ASSERT(obj->handle != nullptr);\n\n\n                    mProcs.renderPipelineRelease(obj->handle);\n                }\n                RenderPipelineObjects().Free(objectId);\n                return WireResult::Success;\n            }\n            case ObjectType::Sampler: {\n                Known<WGPUSampler> obj;\n                WIRE_TRY(SamplerObjects().Get(objectId, &obj));\n\n                if (obj->state == AllocationState::Allocated) {\n                    ASSERT(obj->handle != nullptr);\n\n\n                    mProcs.samplerRelease(obj->handle);\n                }\n                SamplerObjects().Free(objectId);\n                return WireResult::Success;\n            }\n            case ObjectType::ShaderModule: {\n                Known<WGPUShaderModule> obj;\n                WIRE_TRY(ShaderModuleObjects().Get(objectId, &obj));\n\n                if (obj->state == AllocationState::Allocated) {\n                    ASSERT(obj->handle != nullptr);\n\n\n                    mProcs.shaderModuleRelease(obj->handle);\n                }\n                ShaderModuleObjects().Free(objectId);\n                return WireResult::Success;\n            }\n            case ObjectType::Surface: {\n                Known<WGPUSurface> obj;\n                WIRE_TRY(SurfaceObjects().Get(objectId, &obj));\n\n                if (obj->state == AllocationState::Allocated) {\n                    ASSERT(obj->handle != nullptr);\n\n\n                    mProcs.surfaceRelease(obj->handle);\n                }\n                SurfaceObjects().Free(objectId);\n                return WireResult::Success;\n            }\n            case ObjectType::SwapChain: {\n                Known<WGPUSwapChain> obj;\n                WIRE_TRY(SwapChainObjects().Get(objectId, &obj));\n\n                if (obj->state == AllocationState::Allocated) {\n                    ASSERT(obj->handle != nullptr);\n\n\n                    mProcs.swapChainRelease(obj->handle);\n                }\n                SwapChainObjects().Free(objectId);\n                return WireResult::Success;\n            }\n            case ObjectType::Texture: {\n                Known<WGPUTexture> obj;\n                WIRE_TRY(TextureObjects().Get(objectId, &obj));\n\n                if (obj->state == AllocationState::Allocated) {\n                    ASSERT(obj->handle != nullptr);\n\n\n                    mProcs.textureRelease(obj->handle);\n                }\n                TextureObjects().Free(objectId);\n                return WireResult::Success;\n            }\n            case ObjectType::TextureView: {\n                Known<WGPUTextureView> obj;\n                WIRE_TRY(TextureViewObjects().Get(objectId, &obj));\n\n                if (obj->state == AllocationState::Allocated) {\n                    ASSERT(obj->handle != nullptr);\n\n\n                    mProcs.textureViewRelease(obj->handle);\n                }\n                TextureViewObjects().Free(objectId);\n                return WireResult::Success;\n            }\n            default:\n                return WireResult::FatalError;\n        }\n    }\n\n}  // namespace dawn::wire::server\n", "src/dawn/wire/server/ServerHandlers_autogen.cpp": "\n#include \"dawn/common/Assert.h\"\n#include \"dawn/wire/server/Server.h\"\n\nnamespace dawn::wire::server {\n\n    WireResult Server::HandleAdapterGetInstance(DeserializeBuffer* deserializeBuffer) {\n        AdapterGetInstanceCmd cmd;\n        WIRE_TRY(cmd.Deserialize(deserializeBuffer, &mAllocator, *this));\n\n\n\n        Known<WGPUInstance> resultData;\n        WIRE_TRY(InstanceObjects().Allocate(&resultData, cmd.result));\n        resultData->generation = cmd.result.generation;\nWIRE_TRY(DoAdapterGetInstance(cmd.self, &resultData->handle));\n\n        return WireResult::Success;\n    }\n\n    WireResult Server::HandleAdapterRequestDevice(DeserializeBuffer* deserializeBuffer) {\n        AdapterRequestDeviceCmd cmd;\n        WIRE_TRY(cmd.Deserialize(deserializeBuffer, &mAllocator, *this));\n\n        Known<WGPUAdapter> adapterIdHandle;\n        WIRE_TRY(AdapterObjects().Get(cmd.adapterId, &adapterIdHandle));WIRE_TRY(DoAdapterRequestDevice(adapterIdHandle, cmd.requestSerial, cmd.deviceObjectHandle, cmd.descriptor));\n        return WireResult::Success;\n    }\n\n    WireResult Server::HandleBindGroupLayoutSetLabel(DeserializeBuffer* deserializeBuffer) {\n        BindGroupLayoutSetLabelCmd cmd;\n        WIRE_TRY(cmd.Deserialize(deserializeBuffer, &mAllocator, *this));\n\nWIRE_TRY(DoBindGroupLayoutSetLabel(cmd.self, cmd.label));\n        return WireResult::Success;\n    }\n\n    WireResult Server::HandleBindGroupSetLabel(DeserializeBuffer* deserializeBuffer) {\n        BindGroupSetLabelCmd cmd;\n        WIRE_TRY(cmd.Deserialize(deserializeBuffer, &mAllocator, *this));\n\nWIRE_TRY(DoBindGroupSetLabel(cmd.self, cmd.label));\n        return WireResult::Success;\n    }\n\n    WireResult Server::HandleBufferDestroy(DeserializeBuffer* deserializeBuffer) {\n        BufferDestroyCmd cmd;\n        WIRE_TRY(cmd.Deserialize(deserializeBuffer, &mAllocator, *this));\n\n        WIRE_TRY(PreHandleBufferDestroy(cmd));\nWIRE_TRY(DoBufferDestroy(cmd.self));\n        return WireResult::Success;\n    }\n\n    WireResult Server::HandleBufferMapAsync(DeserializeBuffer* deserializeBuffer) {\n        BufferMapAsyncCmd cmd;\n        WIRE_TRY(cmd.Deserialize(deserializeBuffer, &mAllocator));\n\n        Known<WGPUBuffer> bufferIdHandle;\n        WIRE_TRY(BufferObjects().Get(cmd.bufferId, &bufferIdHandle));WIRE_TRY(DoBufferMapAsync(bufferIdHandle, cmd.requestSerial, cmd.mode, cmd.offset, cmd.size));\n        return WireResult::Success;\n    }\n\n    WireResult Server::HandleBufferSetLabel(DeserializeBuffer* deserializeBuffer) {\n        BufferSetLabelCmd cmd;\n        WIRE_TRY(cmd.Deserialize(deserializeBuffer, &mAllocator, *this));\n\nWIRE_TRY(DoBufferSetLabel(cmd.self, cmd.label));\n        return WireResult::Success;\n    }\n\n    WireResult Server::HandleBufferUnmap(DeserializeBuffer* deserializeBuffer) {\n        BufferUnmapCmd cmd;\n        WIRE_TRY(cmd.Deserialize(deserializeBuffer, &mAllocator, *this));\n\n        WIRE_TRY(PreHandleBufferUnmap(cmd));\nWIRE_TRY(DoBufferUnmap(cmd.self));\n        return WireResult::Success;\n    }\n\n    WireResult Server::HandleBufferUpdateMappedData(DeserializeBuffer* deserializeBuffer) {\n        BufferUpdateMappedDataCmd cmd;\n        WIRE_TRY(cmd.Deserialize(deserializeBuffer, &mAllocator));\n\n        Known<WGPUBuffer> bufferIdHandle;\n        WIRE_TRY(BufferObjects().Get(cmd.bufferId, &bufferIdHandle));WIRE_TRY(DoBufferUpdateMappedData(bufferIdHandle, cmd.writeDataUpdateInfoLength, cmd.writeDataUpdateInfo, cmd.offset, cmd.size));\n        return WireResult::Success;\n    }\n\n    WireResult Server::HandleCommandBufferSetLabel(DeserializeBuffer* deserializeBuffer) {\n        CommandBufferSetLabelCmd cmd;\n        WIRE_TRY(cmd.Deserialize(deserializeBuffer, &mAllocator, *this));\n\nWIRE_TRY(DoCommandBufferSetLabel(cmd.self, cmd.label));\n        return WireResult::Success;\n    }\n\n    WireResult Server::HandleCommandEncoderBeginComputePass(DeserializeBuffer* deserializeBuffer) {\n        CommandEncoderBeginComputePassCmd cmd;\n        WIRE_TRY(cmd.Deserialize(deserializeBuffer, &mAllocator, *this));\n\n\n\n        Known<WGPUComputePassEncoder> resultData;\n        WIRE_TRY(ComputePassEncoderObjects().Allocate(&resultData, cmd.result));\n        resultData->generation = cmd.result.generation;\nWIRE_TRY(DoCommandEncoderBeginComputePass(cmd.self, cmd.descriptor, &resultData->handle));\n\n        return WireResult::Success;\n    }\n\n    WireResult Server::HandleCommandEncoderBeginRenderPass(DeserializeBuffer* deserializeBuffer) {\n        CommandEncoderBeginRenderPassCmd cmd;\n        WIRE_TRY(cmd.Deserialize(deserializeBuffer, &mAllocator, *this));\n\n\n\n        Known<WGPURenderPassEncoder> resultData;\n        WIRE_TRY(RenderPassEncoderObjects().Allocate(&resultData, cmd.result));\n        resultData->generation = cmd.result.generation;\nWIRE_TRY(DoCommandEncoderBeginRenderPass(cmd.self, cmd.descriptor, &resultData->handle));\n\n        return WireResult::Success;\n    }\n\n    WireResult Server::HandleCommandEncoderClearBuffer(DeserializeBuffer* deserializeBuffer) {\n        CommandEncoderClearBufferCmd cmd;\n        WIRE_TRY(cmd.Deserialize(deserializeBuffer, &mAllocator, *this));\n\nWIRE_TRY(DoCommandEncoderClearBuffer(cmd.self, cmd.buffer, cmd.offset, cmd.size));\n        return WireResult::Success;\n    }\n\n    WireResult Server::HandleCommandEncoderCopyBufferToBuffer(DeserializeBuffer* deserializeBuffer) {\n        CommandEncoderCopyBufferToBufferCmd cmd;\n        WIRE_TRY(cmd.Deserialize(deserializeBuffer, &mAllocator, *this));\n\nWIRE_TRY(DoCommandEncoderCopyBufferToBuffer(cmd.self, cmd.source, cmd.sourceOffset, cmd.destination, cmd.destinationOffset, cmd.size));\n        return WireResult::Success;\n    }\n\n    WireResult Server::HandleCommandEncoderCopyBufferToTexture(DeserializeBuffer* deserializeBuffer) {\n        CommandEncoderCopyBufferToTextureCmd cmd;\n        WIRE_TRY(cmd.Deserialize(deserializeBuffer, &mAllocator, *this));\n\nWIRE_TRY(DoCommandEncoderCopyBufferToTexture(cmd.self, cmd.source, cmd.destination, cmd.copySize));\n        return WireResult::Success;\n    }\n\n    WireResult Server::HandleCommandEncoderCopyTextureToBuffer(DeserializeBuffer* deserializeBuffer) {\n        CommandEncoderCopyTextureToBufferCmd cmd;\n        WIRE_TRY(cmd.Deserialize(deserializeBuffer, &mAllocator, *this));\n\nWIRE_TRY(DoCommandEncoderCopyTextureToBuffer(cmd.self, cmd.source, cmd.destination, cmd.copySize));\n        return WireResult::Success;\n    }\n\n    WireResult Server::HandleCommandEncoderCopyTextureToTexture(DeserializeBuffer* deserializeBuffer) {\n        CommandEncoderCopyTextureToTextureCmd cmd;\n        WIRE_TRY(cmd.Deserialize(deserializeBuffer, &mAllocator, *this));\n\nWIRE_TRY(DoCommandEncoderCopyTextureToTexture(cmd.self, cmd.source, cmd.destination, cmd.copySize));\n        return WireResult::Success;\n    }\n\n    WireResult Server::HandleCommandEncoderCopyTextureToTextureInternal(DeserializeBuffer* deserializeBuffer) {\n        CommandEncoderCopyTextureToTextureInternalCmd cmd;\n        WIRE_TRY(cmd.Deserialize(deserializeBuffer, &mAllocator, *this));\n\nWIRE_TRY(DoCommandEncoderCopyTextureToTextureInternal(cmd.self, cmd.source, cmd.destination, cmd.copySize));\n        return WireResult::Success;\n    }\n\n    WireResult Server::HandleCommandEncoderFinish(DeserializeBuffer* deserializeBuffer) {\n        CommandEncoderFinishCmd cmd;\n        WIRE_TRY(cmd.Deserialize(deserializeBuffer, &mAllocator, *this));\n\n\n\n        Known<WGPUCommandBuffer> resultData;\n        WIRE_TRY(CommandBufferObjects().Allocate(&resultData, cmd.result));\n        resultData->generation = cmd.result.generation;\nWIRE_TRY(DoCommandEncoderFinish(cmd.self, cmd.descriptor, &resultData->handle));\n\n        return WireResult::Success;\n    }\n\n    WireResult Server::HandleCommandEncoderInjectValidationError(DeserializeBuffer* deserializeBuffer) {\n        CommandEncoderInjectValidationErrorCmd cmd;\n        WIRE_TRY(cmd.Deserialize(deserializeBuffer, &mAllocator, *this));\n\nWIRE_TRY(DoCommandEncoderInjectValidationError(cmd.self, cmd.message));\n        return WireResult::Success;\n    }\n\n    WireResult Server::HandleCommandEncoderInsertDebugMarker(DeserializeBuffer* deserializeBuffer) {\n        CommandEncoderInsertDebugMarkerCmd cmd;\n        WIRE_TRY(cmd.Deserialize(deserializeBuffer, &mAllocator, *this));\n\nWIRE_TRY(DoCommandEncoderInsertDebugMarker(cmd.self, cmd.markerLabel));\n        return WireResult::Success;\n    }\n\n    WireResult Server::HandleCommandEncoderPopDebugGroup(DeserializeBuffer* deserializeBuffer) {\n        CommandEncoderPopDebugGroupCmd cmd;\n        WIRE_TRY(cmd.Deserialize(deserializeBuffer, &mAllocator, *this));\n\nWIRE_TRY(DoCommandEncoderPopDebugGroup(cmd.self));\n        return WireResult::Success;\n    }\n\n    WireResult Server::HandleCommandEncoderPushDebugGroup(DeserializeBuffer* deserializeBuffer) {\n        CommandEncoderPushDebugGroupCmd cmd;\n        WIRE_TRY(cmd.Deserialize(deserializeBuffer, &mAllocator, *this));\n\nWIRE_TRY(DoCommandEncoderPushDebugGroup(cmd.self, cmd.groupLabel));\n        return WireResult::Success;\n    }\n\n    WireResult Server::HandleCommandEncoderResolveQuerySet(DeserializeBuffer* deserializeBuffer) {\n        CommandEncoderResolveQuerySetCmd cmd;\n        WIRE_TRY(cmd.Deserialize(deserializeBuffer, &mAllocator, *this));\n\nWIRE_TRY(DoCommandEncoderResolveQuerySet(cmd.self, cmd.querySet, cmd.firstQuery, cmd.queryCount, cmd.destination, cmd.destinationOffset));\n        return WireResult::Success;\n    }\n\n    WireResult Server::HandleCommandEncoderSetLabel(DeserializeBuffer* deserializeBuffer) {\n        CommandEncoderSetLabelCmd cmd;\n        WIRE_TRY(cmd.Deserialize(deserializeBuffer, &mAllocator, *this));\n\nWIRE_TRY(DoCommandEncoderSetLabel(cmd.self, cmd.label));\n        return WireResult::Success;\n    }\n\n    WireResult Server::HandleCommandEncoderWriteBuffer(DeserializeBuffer* deserializeBuffer) {\n        CommandEncoderWriteBufferCmd cmd;\n        WIRE_TRY(cmd.Deserialize(deserializeBuffer, &mAllocator, *this));\n\nWIRE_TRY(DoCommandEncoderWriteBuffer(cmd.self, cmd.buffer, cmd.bufferOffset, cmd.data, cmd.size));\n        return WireResult::Success;\n    }\n\n    WireResult Server::HandleCommandEncoderWriteTimestamp(DeserializeBuffer* deserializeBuffer) {\n        CommandEncoderWriteTimestampCmd cmd;\n        WIRE_TRY(cmd.Deserialize(deserializeBuffer, &mAllocator, *this));\n\nWIRE_TRY(DoCommandEncoderWriteTimestamp(cmd.self, cmd.querySet, cmd.queryIndex));\n        return WireResult::Success;\n    }\n\n    WireResult Server::HandleComputePassEncoderDispatchWorkgroups(DeserializeBuffer* deserializeBuffer) {\n        ComputePassEncoderDispatchWorkgroupsCmd cmd;\n        WIRE_TRY(cmd.Deserialize(deserializeBuffer, &mAllocator, *this));\n\nWIRE_TRY(DoComputePassEncoderDispatchWorkgroups(cmd.self, cmd.workgroupCountX, cmd.workgroupCountY, cmd.workgroupCountZ));\n        return WireResult::Success;\n    }\n\n    WireResult Server::HandleComputePassEncoderDispatchWorkgroupsIndirect(DeserializeBuffer* deserializeBuffer) {\n        ComputePassEncoderDispatchWorkgroupsIndirectCmd cmd;\n        WIRE_TRY(cmd.Deserialize(deserializeBuffer, &mAllocator, *this));\n\nWIRE_TRY(DoComputePassEncoderDispatchWorkgroupsIndirect(cmd.self, cmd.indirectBuffer, cmd.indirectOffset));\n        return WireResult::Success;\n    }\n\n    WireResult Server::HandleComputePassEncoderEnd(DeserializeBuffer* deserializeBuffer) {\n        ComputePassEncoderEndCmd cmd;\n        WIRE_TRY(cmd.Deserialize(deserializeBuffer, &mAllocator, *this));\n\nWIRE_TRY(DoComputePassEncoderEnd(cmd.self));\n        return WireResult::Success;\n    }\n\n    WireResult Server::HandleComputePassEncoderInsertDebugMarker(DeserializeBuffer* deserializeBuffer) {\n        ComputePassEncoderInsertDebugMarkerCmd cmd;\n        WIRE_TRY(cmd.Deserialize(deserializeBuffer, &mAllocator, *this));\n\nWIRE_TRY(DoComputePassEncoderInsertDebugMarker(cmd.self, cmd.markerLabel));\n        return WireResult::Success;\n    }\n\n    WireResult Server::HandleComputePassEncoderPopDebugGroup(DeserializeBuffer* deserializeBuffer) {\n        ComputePassEncoderPopDebugGroupCmd cmd;\n        WIRE_TRY(cmd.Deserialize(deserializeBuffer, &mAllocator, *this));\n\nWIRE_TRY(DoComputePassEncoderPopDebugGroup(cmd.self));\n        return WireResult::Success;\n    }\n\n    WireResult Server::HandleComputePassEncoderPushDebugGroup(DeserializeBuffer* deserializeBuffer) {\n        ComputePassEncoderPushDebugGroupCmd cmd;\n        WIRE_TRY(cmd.Deserialize(deserializeBuffer, &mAllocator, *this));\n\nWIRE_TRY(DoComputePassEncoderPushDebugGroup(cmd.self, cmd.groupLabel));\n        return WireResult::Success;\n    }\n\n    WireResult Server::HandleComputePassEncoderSetBindGroup(DeserializeBuffer* deserializeBuffer) {\n        ComputePassEncoderSetBindGroupCmd cmd;\n        WIRE_TRY(cmd.Deserialize(deserializeBuffer, &mAllocator, *this));\n\nWIRE_TRY(DoComputePassEncoderSetBindGroup(cmd.self, cmd.groupIndex, cmd.group, cmd.dynamicOffsetCount, cmd.dynamicOffsets));\n        return WireResult::Success;\n    }\n\n    WireResult Server::HandleComputePassEncoderSetLabel(DeserializeBuffer* deserializeBuffer) {\n        ComputePassEncoderSetLabelCmd cmd;\n        WIRE_TRY(cmd.Deserialize(deserializeBuffer, &mAllocator, *this));\n\nWIRE_TRY(DoComputePassEncoderSetLabel(cmd.self, cmd.label));\n        return WireResult::Success;\n    }\n\n    WireResult Server::HandleComputePassEncoderSetPipeline(DeserializeBuffer* deserializeBuffer) {\n        ComputePassEncoderSetPipelineCmd cmd;\n        WIRE_TRY(cmd.Deserialize(deserializeBuffer, &mAllocator, *this));\n\nWIRE_TRY(DoComputePassEncoderSetPipeline(cmd.self, cmd.pipeline));\n        return WireResult::Success;\n    }\n\n    WireResult Server::HandleComputePassEncoderWriteTimestamp(DeserializeBuffer* deserializeBuffer) {\n        ComputePassEncoderWriteTimestampCmd cmd;\n        WIRE_TRY(cmd.Deserialize(deserializeBuffer, &mAllocator, *this));\n\nWIRE_TRY(DoComputePassEncoderWriteTimestamp(cmd.self, cmd.querySet, cmd.queryIndex));\n        return WireResult::Success;\n    }\n\n    WireResult Server::HandleComputePipelineGetBindGroupLayout(DeserializeBuffer* deserializeBuffer) {\n        ComputePipelineGetBindGroupLayoutCmd cmd;\n        WIRE_TRY(cmd.Deserialize(deserializeBuffer, &mAllocator, *this));\n\n\n\n        Known<WGPUBindGroupLayout> resultData;\n        WIRE_TRY(BindGroupLayoutObjects().Allocate(&resultData, cmd.result));\n        resultData->generation = cmd.result.generation;\nWIRE_TRY(DoComputePipelineGetBindGroupLayout(cmd.self, cmd.groupIndex, &resultData->handle));\n\n        return WireResult::Success;\n    }\n\n    WireResult Server::HandleComputePipelineSetLabel(DeserializeBuffer* deserializeBuffer) {\n        ComputePipelineSetLabelCmd cmd;\n        WIRE_TRY(cmd.Deserialize(deserializeBuffer, &mAllocator, *this));\n\nWIRE_TRY(DoComputePipelineSetLabel(cmd.self, cmd.label));\n        return WireResult::Success;\n    }\n\n    WireResult Server::HandleDestroyObject(DeserializeBuffer* deserializeBuffer) {\n        DestroyObjectCmd cmd;\n        WIRE_TRY(cmd.Deserialize(deserializeBuffer, &mAllocator));\n\nWIRE_TRY(DoDestroyObject(cmd.objectType, cmd.objectId));\n        return WireResult::Success;\n    }\n\n    WireResult Server::HandleDeviceCreateBindGroup(DeserializeBuffer* deserializeBuffer) {\n        DeviceCreateBindGroupCmd cmd;\n        WIRE_TRY(cmd.Deserialize(deserializeBuffer, &mAllocator, *this));\n\n\n\n        Known<WGPUBindGroup> resultData;\n        WIRE_TRY(BindGroupObjects().Allocate(&resultData, cmd.result));\n        resultData->generation = cmd.result.generation;\nWIRE_TRY(DoDeviceCreateBindGroup(cmd.self, cmd.descriptor, &resultData->handle));\n\n        return WireResult::Success;\n    }\n\n    WireResult Server::HandleDeviceCreateBindGroupLayout(DeserializeBuffer* deserializeBuffer) {\n        DeviceCreateBindGroupLayoutCmd cmd;\n        WIRE_TRY(cmd.Deserialize(deserializeBuffer, &mAllocator, *this));\n\n\n\n        Known<WGPUBindGroupLayout> resultData;\n        WIRE_TRY(BindGroupLayoutObjects().Allocate(&resultData, cmd.result));\n        resultData->generation = cmd.result.generation;\nWIRE_TRY(DoDeviceCreateBindGroupLayout(cmd.self, cmd.descriptor, &resultData->handle));\n\n        return WireResult::Success;\n    }\n\n    WireResult Server::HandleDeviceCreateBuffer(DeserializeBuffer* deserializeBuffer) {\n        DeviceCreateBufferCmd cmd;\n        WIRE_TRY(cmd.Deserialize(deserializeBuffer, &mAllocator, *this));\n\n        Known<WGPUDevice> deviceIdHandle;\n        WIRE_TRY(DeviceObjects().Get(cmd.deviceId, &deviceIdHandle));WIRE_TRY(DoDeviceCreateBuffer(deviceIdHandle, cmd.descriptor, cmd.result, cmd.readHandleCreateInfoLength, cmd.readHandleCreateInfo, cmd.writeHandleCreateInfoLength, cmd.writeHandleCreateInfo));\n        return WireResult::Success;\n    }\n\n    WireResult Server::HandleDeviceCreateCommandEncoder(DeserializeBuffer* deserializeBuffer) {\n        DeviceCreateCommandEncoderCmd cmd;\n        WIRE_TRY(cmd.Deserialize(deserializeBuffer, &mAllocator, *this));\n\n\n\n        Known<WGPUCommandEncoder> resultData;\n        WIRE_TRY(CommandEncoderObjects().Allocate(&resultData, cmd.result));\n        resultData->generation = cmd.result.generation;\nWIRE_TRY(DoDeviceCreateCommandEncoder(cmd.self, cmd.descriptor, &resultData->handle));\n\n        return WireResult::Success;\n    }\n\n    WireResult Server::HandleDeviceCreateComputePipeline(DeserializeBuffer* deserializeBuffer) {\n        DeviceCreateComputePipelineCmd cmd;\n        WIRE_TRY(cmd.Deserialize(deserializeBuffer, &mAllocator, *this));\n\n\n\n        Known<WGPUComputePipeline> resultData;\n        WIRE_TRY(ComputePipelineObjects().Allocate(&resultData, cmd.result));\n        resultData->generation = cmd.result.generation;\nWIRE_TRY(DoDeviceCreateComputePipeline(cmd.self, cmd.descriptor, &resultData->handle));\n\n        return WireResult::Success;\n    }\n\n    WireResult Server::HandleDeviceCreateComputePipelineAsync(DeserializeBuffer* deserializeBuffer) {\n        DeviceCreateComputePipelineAsyncCmd cmd;\n        WIRE_TRY(cmd.Deserialize(deserializeBuffer, &mAllocator, *this));\n\n        Known<WGPUDevice> deviceIdHandle;\n        WIRE_TRY(DeviceObjects().Get(cmd.deviceId, &deviceIdHandle));WIRE_TRY(DoDeviceCreateComputePipelineAsync(deviceIdHandle, cmd.requestSerial, cmd.pipelineObjectHandle, cmd.descriptor));\n        return WireResult::Success;\n    }\n\n    WireResult Server::HandleDeviceCreateErrorBuffer(DeserializeBuffer* deserializeBuffer) {\n        DeviceCreateErrorBufferCmd cmd;\n        WIRE_TRY(cmd.Deserialize(deserializeBuffer, &mAllocator, *this));\n\n\n\n        Known<WGPUBuffer> resultData;\n        WIRE_TRY(BufferObjects().Allocate(&resultData, cmd.result));\n        resultData->generation = cmd.result.generation;\nWIRE_TRY(DoDeviceCreateErrorBuffer(cmd.self, cmd.descriptor, &resultData->handle));\n\n        return WireResult::Success;\n    }\n\n    WireResult Server::HandleDeviceCreateErrorExternalTexture(DeserializeBuffer* deserializeBuffer) {\n        DeviceCreateErrorExternalTextureCmd cmd;\n        WIRE_TRY(cmd.Deserialize(deserializeBuffer, &mAllocator, *this));\n\n\n\n        Known<WGPUExternalTexture> resultData;\n        WIRE_TRY(ExternalTextureObjects().Allocate(&resultData, cmd.result));\n        resultData->generation = cmd.result.generation;\nWIRE_TRY(DoDeviceCreateErrorExternalTexture(cmd.self, &resultData->handle));\n\n        return WireResult::Success;\n    }\n\n    WireResult Server::HandleDeviceCreateErrorShaderModule(DeserializeBuffer* deserializeBuffer) {\n        DeviceCreateErrorShaderModuleCmd cmd;\n        WIRE_TRY(cmd.Deserialize(deserializeBuffer, &mAllocator, *this));\n\n\n\n        Known<WGPUShaderModule> resultData;\n        WIRE_TRY(ShaderModuleObjects().Allocate(&resultData, cmd.result));\n        resultData->generation = cmd.result.generation;\nWIRE_TRY(DoDeviceCreateErrorShaderModule(cmd.self, cmd.descriptor, cmd.errorMessage, &resultData->handle));\n\n        return WireResult::Success;\n    }\n\n    WireResult Server::HandleDeviceCreateErrorTexture(DeserializeBuffer* deserializeBuffer) {\n        DeviceCreateErrorTextureCmd cmd;\n        WIRE_TRY(cmd.Deserialize(deserializeBuffer, &mAllocator, *this));\n\n\n\n        Known<WGPUTexture> resultData;\n        WIRE_TRY(TextureObjects().Allocate(&resultData, cmd.result));\n        resultData->generation = cmd.result.generation;\nWIRE_TRY(DoDeviceCreateErrorTexture(cmd.self, cmd.descriptor, &resultData->handle));\n\n        return WireResult::Success;\n    }\n\n    WireResult Server::HandleDeviceCreateExternalTexture(DeserializeBuffer* deserializeBuffer) {\n        DeviceCreateExternalTextureCmd cmd;\n        WIRE_TRY(cmd.Deserialize(deserializeBuffer, &mAllocator, *this));\n\n\n\n        Known<WGPUExternalTexture> resultData;\n        WIRE_TRY(ExternalTextureObjects().Allocate(&resultData, cmd.result));\n        resultData->generation = cmd.result.generation;\nWIRE_TRY(DoDeviceCreateExternalTexture(cmd.self, cmd.externalTextureDescriptor, &resultData->handle));\n\n        return WireResult::Success;\n    }\n\n    WireResult Server::HandleDeviceCreatePipelineLayout(DeserializeBuffer* deserializeBuffer) {\n        DeviceCreatePipelineLayoutCmd cmd;\n        WIRE_TRY(cmd.Deserialize(deserializeBuffer, &mAllocator, *this));\n\n\n\n        Known<WGPUPipelineLayout> resultData;\n        WIRE_TRY(PipelineLayoutObjects().Allocate(&resultData, cmd.result));\n        resultData->generation = cmd.result.generation;\nWIRE_TRY(DoDeviceCreatePipelineLayout(cmd.self, cmd.descriptor, &resultData->handle));\n\n        return WireResult::Success;\n    }\n\n    WireResult Server::HandleDeviceCreateQuerySet(DeserializeBuffer* deserializeBuffer) {\n        DeviceCreateQuerySetCmd cmd;\n        WIRE_TRY(cmd.Deserialize(deserializeBuffer, &mAllocator, *this));\n\n\n\n        Known<WGPUQuerySet> resultData;\n        WIRE_TRY(QuerySetObjects().Allocate(&resultData, cmd.result));\n        resultData->generation = cmd.result.generation;\nWIRE_TRY(DoDeviceCreateQuerySet(cmd.self, cmd.descriptor, &resultData->handle));\n\n        return WireResult::Success;\n    }\n\n    WireResult Server::HandleDeviceCreateRenderBundleEncoder(DeserializeBuffer* deserializeBuffer) {\n        DeviceCreateRenderBundleEncoderCmd cmd;\n        WIRE_TRY(cmd.Deserialize(deserializeBuffer, &mAllocator, *this));\n\n\n\n        Known<WGPURenderBundleEncoder> resultData;\n        WIRE_TRY(RenderBundleEncoderObjects().Allocate(&resultData, cmd.result));\n        resultData->generation = cmd.result.generation;\nWIRE_TRY(DoDeviceCreateRenderBundleEncoder(cmd.self, cmd.descriptor, &resultData->handle));\n\n        return WireResult::Success;\n    }\n\n    WireResult Server::HandleDeviceCreateRenderPipeline(DeserializeBuffer* deserializeBuffer) {\n        DeviceCreateRenderPipelineCmd cmd;\n        WIRE_TRY(cmd.Deserialize(deserializeBuffer, &mAllocator, *this));\n\n\n\n        Known<WGPURenderPipeline> resultData;\n        WIRE_TRY(RenderPipelineObjects().Allocate(&resultData, cmd.result));\n        resultData->generation = cmd.result.generation;\nWIRE_TRY(DoDeviceCreateRenderPipeline(cmd.self, cmd.descriptor, &resultData->handle));\n\n        return WireResult::Success;\n    }\n\n    WireResult Server::HandleDeviceCreateRenderPipelineAsync(DeserializeBuffer* deserializeBuffer) {\n        DeviceCreateRenderPipelineAsyncCmd cmd;\n        WIRE_TRY(cmd.Deserialize(deserializeBuffer, &mAllocator, *this));\n\n        Known<WGPUDevice> deviceIdHandle;\n        WIRE_TRY(DeviceObjects().Get(cmd.deviceId, &deviceIdHandle));WIRE_TRY(DoDeviceCreateRenderPipelineAsync(deviceIdHandle, cmd.requestSerial, cmd.pipelineObjectHandle, cmd.descriptor));\n        return WireResult::Success;\n    }\n\n    WireResult Server::HandleDeviceCreateSampler(DeserializeBuffer* deserializeBuffer) {\n        DeviceCreateSamplerCmd cmd;\n        WIRE_TRY(cmd.Deserialize(deserializeBuffer, &mAllocator, *this));\n\n\n\n        Known<WGPUSampler> resultData;\n        WIRE_TRY(SamplerObjects().Allocate(&resultData, cmd.result));\n        resultData->generation = cmd.result.generation;\nWIRE_TRY(DoDeviceCreateSampler(cmd.self, cmd.descriptor, &resultData->handle));\n\n        return WireResult::Success;\n    }\n\n    WireResult Server::HandleDeviceCreateShaderModule(DeserializeBuffer* deserializeBuffer) {\n        DeviceCreateShaderModuleCmd cmd;\n        WIRE_TRY(cmd.Deserialize(deserializeBuffer, &mAllocator, *this));\n\n\n\n        Known<WGPUShaderModule> resultData;\n        WIRE_TRY(ShaderModuleObjects().Allocate(&resultData, cmd.result));\n        resultData->generation = cmd.result.generation;\nWIRE_TRY(DoDeviceCreateShaderModule(cmd.self, cmd.descriptor, &resultData->handle));\n\n        return WireResult::Success;\n    }\n\n    WireResult Server::HandleDeviceCreateSwapChain(DeserializeBuffer* deserializeBuffer) {\n        DeviceCreateSwapChainCmd cmd;\n        WIRE_TRY(cmd.Deserialize(deserializeBuffer, &mAllocator, *this));\n\n\n\n        Known<WGPUSwapChain> resultData;\n        WIRE_TRY(SwapChainObjects().Allocate(&resultData, cmd.result));\n        resultData->generation = cmd.result.generation;\nWIRE_TRY(DoDeviceCreateSwapChain(cmd.self, cmd.surface, cmd.descriptor, &resultData->handle));\n\n        return WireResult::Success;\n    }\n\n    WireResult Server::HandleDeviceCreateTexture(DeserializeBuffer* deserializeBuffer) {\n        DeviceCreateTextureCmd cmd;\n        WIRE_TRY(cmd.Deserialize(deserializeBuffer, &mAllocator, *this));\n\n\n\n        Known<WGPUTexture> resultData;\n        WIRE_TRY(TextureObjects().Allocate(&resultData, cmd.result));\n        resultData->generation = cmd.result.generation;\nWIRE_TRY(DoDeviceCreateTexture(cmd.self, cmd.descriptor, &resultData->handle));\n\n        return WireResult::Success;\n    }\n\n    WireResult Server::HandleDeviceDestroy(DeserializeBuffer* deserializeBuffer) {\n        DeviceDestroyCmd cmd;\n        WIRE_TRY(cmd.Deserialize(deserializeBuffer, &mAllocator, *this));\n\nWIRE_TRY(DoDeviceDestroy(cmd.self));\n        return WireResult::Success;\n    }\n\n    WireResult Server::HandleDeviceForceLoss(DeserializeBuffer* deserializeBuffer) {\n        DeviceForceLossCmd cmd;\n        WIRE_TRY(cmd.Deserialize(deserializeBuffer, &mAllocator, *this));\n\nWIRE_TRY(DoDeviceForceLoss(cmd.self, cmd.type, cmd.message));\n        return WireResult::Success;\n    }\n\n    WireResult Server::HandleDeviceGetAdapter(DeserializeBuffer* deserializeBuffer) {\n        DeviceGetAdapterCmd cmd;\n        WIRE_TRY(cmd.Deserialize(deserializeBuffer, &mAllocator, *this));\n\n\n\n        Known<WGPUAdapter> resultData;\n        WIRE_TRY(AdapterObjects().Allocate(&resultData, cmd.result));\n        resultData->generation = cmd.result.generation;\nWIRE_TRY(DoDeviceGetAdapter(cmd.self, &resultData->handle));\n\n        return WireResult::Success;\n    }\n\n    WireResult Server::HandleDeviceGetQueue(DeserializeBuffer* deserializeBuffer) {\n        DeviceGetQueueCmd cmd;\n        WIRE_TRY(cmd.Deserialize(deserializeBuffer, &mAllocator, *this));\n\n\n\n        Known<WGPUQueue> resultData;\n        WIRE_TRY(QueueObjects().Allocate(&resultData, cmd.result));\n        resultData->generation = cmd.result.generation;\nWIRE_TRY(DoDeviceGetQueue(cmd.self, &resultData->handle));\n\n        return WireResult::Success;\n    }\n\n    WireResult Server::HandleDeviceInjectError(DeserializeBuffer* deserializeBuffer) {\n        DeviceInjectErrorCmd cmd;\n        WIRE_TRY(cmd.Deserialize(deserializeBuffer, &mAllocator, *this));\n\nWIRE_TRY(DoDeviceInjectError(cmd.self, cmd.type, cmd.message));\n        return WireResult::Success;\n    }\n\n    WireResult Server::HandleDevicePopErrorScope(DeserializeBuffer* deserializeBuffer) {\n        DevicePopErrorScopeCmd cmd;\n        WIRE_TRY(cmd.Deserialize(deserializeBuffer, &mAllocator));\n\n        Known<WGPUDevice> deviceIdHandle;\n        WIRE_TRY(DeviceObjects().Get(cmd.deviceId, &deviceIdHandle));WIRE_TRY(DoDevicePopErrorScope(deviceIdHandle, cmd.requestSerial));\n        return WireResult::Success;\n    }\n\n    WireResult Server::HandleDevicePushErrorScope(DeserializeBuffer* deserializeBuffer) {\n        DevicePushErrorScopeCmd cmd;\n        WIRE_TRY(cmd.Deserialize(deserializeBuffer, &mAllocator, *this));\n\nWIRE_TRY(DoDevicePushErrorScope(cmd.self, cmd.filter));\n        return WireResult::Success;\n    }\n\n    WireResult Server::HandleDeviceSetLabel(DeserializeBuffer* deserializeBuffer) {\n        DeviceSetLabelCmd cmd;\n        WIRE_TRY(cmd.Deserialize(deserializeBuffer, &mAllocator, *this));\n\nWIRE_TRY(DoDeviceSetLabel(cmd.self, cmd.label));\n        return WireResult::Success;\n    }\n\n    WireResult Server::HandleDeviceTick(DeserializeBuffer* deserializeBuffer) {\n        DeviceTickCmd cmd;\n        WIRE_TRY(cmd.Deserialize(deserializeBuffer, &mAllocator, *this));\n\nWIRE_TRY(DoDeviceTick(cmd.self));\n        return WireResult::Success;\n    }\n\n    WireResult Server::HandleDeviceValidateTextureDescriptor(DeserializeBuffer* deserializeBuffer) {\n        DeviceValidateTextureDescriptorCmd cmd;\n        WIRE_TRY(cmd.Deserialize(deserializeBuffer, &mAllocator, *this));\n\nWIRE_TRY(DoDeviceValidateTextureDescriptor(cmd.self, cmd.descriptor));\n        return WireResult::Success;\n    }\n\n    WireResult Server::HandleExternalTextureDestroy(DeserializeBuffer* deserializeBuffer) {\n        ExternalTextureDestroyCmd cmd;\n        WIRE_TRY(cmd.Deserialize(deserializeBuffer, &mAllocator, *this));\n\nWIRE_TRY(DoExternalTextureDestroy(cmd.self));\n        return WireResult::Success;\n    }\n\n    WireResult Server::HandleExternalTextureExpire(DeserializeBuffer* deserializeBuffer) {\n        ExternalTextureExpireCmd cmd;\n        WIRE_TRY(cmd.Deserialize(deserializeBuffer, &mAllocator, *this));\n\nWIRE_TRY(DoExternalTextureExpire(cmd.self));\n        return WireResult::Success;\n    }\n\n    WireResult Server::HandleExternalTextureRefresh(DeserializeBuffer* deserializeBuffer) {\n        ExternalTextureRefreshCmd cmd;\n        WIRE_TRY(cmd.Deserialize(deserializeBuffer, &mAllocator, *this));\n\nWIRE_TRY(DoExternalTextureRefresh(cmd.self));\n        return WireResult::Success;\n    }\n\n    WireResult Server::HandleExternalTextureSetLabel(DeserializeBuffer* deserializeBuffer) {\n        ExternalTextureSetLabelCmd cmd;\n        WIRE_TRY(cmd.Deserialize(deserializeBuffer, &mAllocator, *this));\n\nWIRE_TRY(DoExternalTextureSetLabel(cmd.self, cmd.label));\n        return WireResult::Success;\n    }\n\n    WireResult Server::HandleInstanceCreateSurface(DeserializeBuffer* deserializeBuffer) {\n        InstanceCreateSurfaceCmd cmd;\n        WIRE_TRY(cmd.Deserialize(deserializeBuffer, &mAllocator, *this));\n\n\n\n        Known<WGPUSurface> resultData;\n        WIRE_TRY(SurfaceObjects().Allocate(&resultData, cmd.result));\n        resultData->generation = cmd.result.generation;\nWIRE_TRY(DoInstanceCreateSurface(cmd.self, cmd.descriptor, &resultData->handle));\n\n        return WireResult::Success;\n    }\n\n    WireResult Server::HandleInstanceProcessEvents(DeserializeBuffer* deserializeBuffer) {\n        InstanceProcessEventsCmd cmd;\n        WIRE_TRY(cmd.Deserialize(deserializeBuffer, &mAllocator, *this));\n\nWIRE_TRY(DoInstanceProcessEvents(cmd.self));\n        return WireResult::Success;\n    }\n\n    WireResult Server::HandleInstanceRequestAdapter(DeserializeBuffer* deserializeBuffer) {\n        InstanceRequestAdapterCmd cmd;\n        WIRE_TRY(cmd.Deserialize(deserializeBuffer, &mAllocator, *this));\n\n        Known<WGPUInstance> instanceIdHandle;\n        WIRE_TRY(InstanceObjects().Get(cmd.instanceId, &instanceIdHandle));WIRE_TRY(DoInstanceRequestAdapter(instanceIdHandle, cmd.requestSerial, cmd.adapterObjectHandle, cmd.options));\n        return WireResult::Success;\n    }\n\n    WireResult Server::HandlePipelineLayoutSetLabel(DeserializeBuffer* deserializeBuffer) {\n        PipelineLayoutSetLabelCmd cmd;\n        WIRE_TRY(cmd.Deserialize(deserializeBuffer, &mAllocator, *this));\n\nWIRE_TRY(DoPipelineLayoutSetLabel(cmd.self, cmd.label));\n        return WireResult::Success;\n    }\n\n    WireResult Server::HandleQuerySetDestroy(DeserializeBuffer* deserializeBuffer) {\n        QuerySetDestroyCmd cmd;\n        WIRE_TRY(cmd.Deserialize(deserializeBuffer, &mAllocator, *this));\n\nWIRE_TRY(DoQuerySetDestroy(cmd.self));\n        return WireResult::Success;\n    }\n\n    WireResult Server::HandleQuerySetSetLabel(DeserializeBuffer* deserializeBuffer) {\n        QuerySetSetLabelCmd cmd;\n        WIRE_TRY(cmd.Deserialize(deserializeBuffer, &mAllocator, *this));\n\nWIRE_TRY(DoQuerySetSetLabel(cmd.self, cmd.label));\n        return WireResult::Success;\n    }\n\n    WireResult Server::HandleQueueCopyExternalTextureForBrowser(DeserializeBuffer* deserializeBuffer) {\n        QueueCopyExternalTextureForBrowserCmd cmd;\n        WIRE_TRY(cmd.Deserialize(deserializeBuffer, &mAllocator, *this));\n\nWIRE_TRY(DoQueueCopyExternalTextureForBrowser(cmd.self, cmd.source, cmd.destination, cmd.copySize, cmd.options));\n        return WireResult::Success;\n    }\n\n    WireResult Server::HandleQueueCopyTextureForBrowser(DeserializeBuffer* deserializeBuffer) {\n        QueueCopyTextureForBrowserCmd cmd;\n        WIRE_TRY(cmd.Deserialize(deserializeBuffer, &mAllocator, *this));\n\nWIRE_TRY(DoQueueCopyTextureForBrowser(cmd.self, cmd.source, cmd.destination, cmd.copySize, cmd.options));\n        return WireResult::Success;\n    }\n\n    WireResult Server::HandleQueueOnSubmittedWorkDone(DeserializeBuffer* deserializeBuffer) {\n        QueueOnSubmittedWorkDoneCmd cmd;\n        WIRE_TRY(cmd.Deserialize(deserializeBuffer, &mAllocator));\n\n        Known<WGPUQueue> queueIdHandle;\n        WIRE_TRY(QueueObjects().Get(cmd.queueId, &queueIdHandle));WIRE_TRY(DoQueueOnSubmittedWorkDone(queueIdHandle, cmd.signalValue, cmd.requestSerial));\n        return WireResult::Success;\n    }\n\n    WireResult Server::HandleQueueSetLabel(DeserializeBuffer* deserializeBuffer) {\n        QueueSetLabelCmd cmd;\n        WIRE_TRY(cmd.Deserialize(deserializeBuffer, &mAllocator, *this));\n\nWIRE_TRY(DoQueueSetLabel(cmd.self, cmd.label));\n        return WireResult::Success;\n    }\n\n    WireResult Server::HandleQueueSubmit(DeserializeBuffer* deserializeBuffer) {\n        QueueSubmitCmd cmd;\n        WIRE_TRY(cmd.Deserialize(deserializeBuffer, &mAllocator, *this));\n\nWIRE_TRY(DoQueueSubmit(cmd.self, cmd.commandCount, cmd.commands));\n        return WireResult::Success;\n    }\n\n    WireResult Server::HandleQueueWriteBuffer(DeserializeBuffer* deserializeBuffer) {\n        QueueWriteBufferCmd cmd;\n        WIRE_TRY(cmd.Deserialize(deserializeBuffer, &mAllocator));\n\n        Known<WGPUQueue> queueIdHandle;\n        WIRE_TRY(QueueObjects().Get(cmd.queueId, &queueIdHandle));        Known<WGPUBuffer> bufferIdHandle;\n        WIRE_TRY(BufferObjects().Get(cmd.bufferId, &bufferIdHandle));WIRE_TRY(DoQueueWriteBuffer(queueIdHandle, bufferIdHandle, cmd.bufferOffset, cmd.data, cmd.size));\n        return WireResult::Success;\n    }\n\n    WireResult Server::HandleQueueWriteTexture(DeserializeBuffer* deserializeBuffer) {\n        QueueWriteTextureCmd cmd;\n        WIRE_TRY(cmd.Deserialize(deserializeBuffer, &mAllocator, *this));\n\n        Known<WGPUQueue> queueIdHandle;\n        WIRE_TRY(QueueObjects().Get(cmd.queueId, &queueIdHandle));WIRE_TRY(DoQueueWriteTexture(queueIdHandle, cmd.destination, cmd.data, cmd.dataSize, cmd.dataLayout, cmd.writeSize));\n        return WireResult::Success;\n    }\n\n    WireResult Server::HandleRenderBundleEncoderDraw(DeserializeBuffer* deserializeBuffer) {\n        RenderBundleEncoderDrawCmd cmd;\n        WIRE_TRY(cmd.Deserialize(deserializeBuffer, &mAllocator, *this));\n\nWIRE_TRY(DoRenderBundleEncoderDraw(cmd.self, cmd.vertexCount, cmd.instanceCount, cmd.firstVertex, cmd.firstInstance));\n        return WireResult::Success;\n    }\n\n    WireResult Server::HandleRenderBundleEncoderDrawIndexed(DeserializeBuffer* deserializeBuffer) {\n        RenderBundleEncoderDrawIndexedCmd cmd;\n        WIRE_TRY(cmd.Deserialize(deserializeBuffer, &mAllocator, *this));\n\nWIRE_TRY(DoRenderBundleEncoderDrawIndexed(cmd.self, cmd.indexCount, cmd.instanceCount, cmd.firstIndex, cmd.baseVertex, cmd.firstInstance));\n        return WireResult::Success;\n    }\n\n    WireResult Server::HandleRenderBundleEncoderDrawIndexedIndirect(DeserializeBuffer* deserializeBuffer) {\n        RenderBundleEncoderDrawIndexedIndirectCmd cmd;\n        WIRE_TRY(cmd.Deserialize(deserializeBuffer, &mAllocator, *this));\n\nWIRE_TRY(DoRenderBundleEncoderDrawIndexedIndirect(cmd.self, cmd.indirectBuffer, cmd.indirectOffset));\n        return WireResult::Success;\n    }\n\n    WireResult Server::HandleRenderBundleEncoderDrawIndirect(DeserializeBuffer* deserializeBuffer) {\n        RenderBundleEncoderDrawIndirectCmd cmd;\n        WIRE_TRY(cmd.Deserialize(deserializeBuffer, &mAllocator, *this));\n\nWIRE_TRY(DoRenderBundleEncoderDrawIndirect(cmd.self, cmd.indirectBuffer, cmd.indirectOffset));\n        return WireResult::Success;\n    }\n\n    WireResult Server::HandleRenderBundleEncoderFinish(DeserializeBuffer* deserializeBuffer) {\n        RenderBundleEncoderFinishCmd cmd;\n        WIRE_TRY(cmd.Deserialize(deserializeBuffer, &mAllocator, *this));\n\n\n\n        Known<WGPURenderBundle> resultData;\n        WIRE_TRY(RenderBundleObjects().Allocate(&resultData, cmd.result));\n        resultData->generation = cmd.result.generation;\nWIRE_TRY(DoRenderBundleEncoderFinish(cmd.self, cmd.descriptor, &resultData->handle));\n\n        return WireResult::Success;\n    }\n\n    WireResult Server::HandleRenderBundleEncoderInsertDebugMarker(DeserializeBuffer* deserializeBuffer) {\n        RenderBundleEncoderInsertDebugMarkerCmd cmd;\n        WIRE_TRY(cmd.Deserialize(deserializeBuffer, &mAllocator, *this));\n\nWIRE_TRY(DoRenderBundleEncoderInsertDebugMarker(cmd.self, cmd.markerLabel));\n        return WireResult::Success;\n    }\n\n    WireResult Server::HandleRenderBundleEncoderPopDebugGroup(DeserializeBuffer* deserializeBuffer) {\n        RenderBundleEncoderPopDebugGroupCmd cmd;\n        WIRE_TRY(cmd.Deserialize(deserializeBuffer, &mAllocator, *this));\n\nWIRE_TRY(DoRenderBundleEncoderPopDebugGroup(cmd.self));\n        return WireResult::Success;\n    }\n\n    WireResult Server::HandleRenderBundleEncoderPushDebugGroup(DeserializeBuffer* deserializeBuffer) {\n        RenderBundleEncoderPushDebugGroupCmd cmd;\n        WIRE_TRY(cmd.Deserialize(deserializeBuffer, &mAllocator, *this));\n\nWIRE_TRY(DoRenderBundleEncoderPushDebugGroup(cmd.self, cmd.groupLabel));\n        return WireResult::Success;\n    }\n\n    WireResult Server::HandleRenderBundleEncoderSetBindGroup(DeserializeBuffer* deserializeBuffer) {\n        RenderBundleEncoderSetBindGroupCmd cmd;\n        WIRE_TRY(cmd.Deserialize(deserializeBuffer, &mAllocator, *this));\n\nWIRE_TRY(DoRenderBundleEncoderSetBindGroup(cmd.self, cmd.groupIndex, cmd.group, cmd.dynamicOffsetCount, cmd.dynamicOffsets));\n        return WireResult::Success;\n    }\n\n    WireResult Server::HandleRenderBundleEncoderSetIndexBuffer(DeserializeBuffer* deserializeBuffer) {\n        RenderBundleEncoderSetIndexBufferCmd cmd;\n        WIRE_TRY(cmd.Deserialize(deserializeBuffer, &mAllocator, *this));\n\nWIRE_TRY(DoRenderBundleEncoderSetIndexBuffer(cmd.self, cmd.buffer, cmd.format, cmd.offset, cmd.size));\n        return WireResult::Success;\n    }\n\n    WireResult Server::HandleRenderBundleEncoderSetLabel(DeserializeBuffer* deserializeBuffer) {\n        RenderBundleEncoderSetLabelCmd cmd;\n        WIRE_TRY(cmd.Deserialize(deserializeBuffer, &mAllocator, *this));\n\nWIRE_TRY(DoRenderBundleEncoderSetLabel(cmd.self, cmd.label));\n        return WireResult::Success;\n    }\n\n    WireResult Server::HandleRenderBundleEncoderSetPipeline(DeserializeBuffer* deserializeBuffer) {\n        RenderBundleEncoderSetPipelineCmd cmd;\n        WIRE_TRY(cmd.Deserialize(deserializeBuffer, &mAllocator, *this));\n\nWIRE_TRY(DoRenderBundleEncoderSetPipeline(cmd.self, cmd.pipeline));\n        return WireResult::Success;\n    }\n\n    WireResult Server::HandleRenderBundleEncoderSetVertexBuffer(DeserializeBuffer* deserializeBuffer) {\n        RenderBundleEncoderSetVertexBufferCmd cmd;\n        WIRE_TRY(cmd.Deserialize(deserializeBuffer, &mAllocator, *this));\n\nWIRE_TRY(DoRenderBundleEncoderSetVertexBuffer(cmd.self, cmd.slot, cmd.buffer, cmd.offset, cmd.size));\n        return WireResult::Success;\n    }\n\n    WireResult Server::HandleRenderBundleSetLabel(DeserializeBuffer* deserializeBuffer) {\n        RenderBundleSetLabelCmd cmd;\n        WIRE_TRY(cmd.Deserialize(deserializeBuffer, &mAllocator, *this));\n\nWIRE_TRY(DoRenderBundleSetLabel(cmd.self, cmd.label));\n        return WireResult::Success;\n    }\n\n    WireResult Server::HandleRenderPassEncoderBeginOcclusionQuery(DeserializeBuffer* deserializeBuffer) {\n        RenderPassEncoderBeginOcclusionQueryCmd cmd;\n        WIRE_TRY(cmd.Deserialize(deserializeBuffer, &mAllocator, *this));\n\nWIRE_TRY(DoRenderPassEncoderBeginOcclusionQuery(cmd.self, cmd.queryIndex));\n        return WireResult::Success;\n    }\n\n    WireResult Server::HandleRenderPassEncoderDraw(DeserializeBuffer* deserializeBuffer) {\n        RenderPassEncoderDrawCmd cmd;\n        WIRE_TRY(cmd.Deserialize(deserializeBuffer, &mAllocator, *this));\n\nWIRE_TRY(DoRenderPassEncoderDraw(cmd.self, cmd.vertexCount, cmd.instanceCount, cmd.firstVertex, cmd.firstInstance));\n        return WireResult::Success;\n    }\n\n    WireResult Server::HandleRenderPassEncoderDrawIndexed(DeserializeBuffer* deserializeBuffer) {\n        RenderPassEncoderDrawIndexedCmd cmd;\n        WIRE_TRY(cmd.Deserialize(deserializeBuffer, &mAllocator, *this));\n\nWIRE_TRY(DoRenderPassEncoderDrawIndexed(cmd.self, cmd.indexCount, cmd.instanceCount, cmd.firstIndex, cmd.baseVertex, cmd.firstInstance));\n        return WireResult::Success;\n    }\n\n    WireResult Server::HandleRenderPassEncoderDrawIndexedIndirect(DeserializeBuffer* deserializeBuffer) {\n        RenderPassEncoderDrawIndexedIndirectCmd cmd;\n        WIRE_TRY(cmd.Deserialize(deserializeBuffer, &mAllocator, *this));\n\nWIRE_TRY(DoRenderPassEncoderDrawIndexedIndirect(cmd.self, cmd.indirectBuffer, cmd.indirectOffset));\n        return WireResult::Success;\n    }\n\n    WireResult Server::HandleRenderPassEncoderDrawIndirect(DeserializeBuffer* deserializeBuffer) {\n        RenderPassEncoderDrawIndirectCmd cmd;\n        WIRE_TRY(cmd.Deserialize(deserializeBuffer, &mAllocator, *this));\n\nWIRE_TRY(DoRenderPassEncoderDrawIndirect(cmd.self, cmd.indirectBuffer, cmd.indirectOffset));\n        return WireResult::Success;\n    }\n\n    WireResult Server::HandleRenderPassEncoderEnd(DeserializeBuffer* deserializeBuffer) {\n        RenderPassEncoderEndCmd cmd;\n        WIRE_TRY(cmd.Deserialize(deserializeBuffer, &mAllocator, *this));\n\nWIRE_TRY(DoRenderPassEncoderEnd(cmd.self));\n        return WireResult::Success;\n    }\n\n    WireResult Server::HandleRenderPassEncoderEndOcclusionQuery(DeserializeBuffer* deserializeBuffer) {\n        RenderPassEncoderEndOcclusionQueryCmd cmd;\n        WIRE_TRY(cmd.Deserialize(deserializeBuffer, &mAllocator, *this));\n\nWIRE_TRY(DoRenderPassEncoderEndOcclusionQuery(cmd.self));\n        return WireResult::Success;\n    }\n\n    WireResult Server::HandleRenderPassEncoderExecuteBundles(DeserializeBuffer* deserializeBuffer) {\n        RenderPassEncoderExecuteBundlesCmd cmd;\n        WIRE_TRY(cmd.Deserialize(deserializeBuffer, &mAllocator, *this));\n\nWIRE_TRY(DoRenderPassEncoderExecuteBundles(cmd.self, cmd.bundleCount, cmd.bundles));\n        return WireResult::Success;\n    }\n\n    WireResult Server::HandleRenderPassEncoderInsertDebugMarker(DeserializeBuffer* deserializeBuffer) {\n        RenderPassEncoderInsertDebugMarkerCmd cmd;\n        WIRE_TRY(cmd.Deserialize(deserializeBuffer, &mAllocator, *this));\n\nWIRE_TRY(DoRenderPassEncoderInsertDebugMarker(cmd.self, cmd.markerLabel));\n        return WireResult::Success;\n    }\n\n    WireResult Server::HandleRenderPassEncoderPopDebugGroup(DeserializeBuffer* deserializeBuffer) {\n        RenderPassEncoderPopDebugGroupCmd cmd;\n        WIRE_TRY(cmd.Deserialize(deserializeBuffer, &mAllocator, *this));\n\nWIRE_TRY(DoRenderPassEncoderPopDebugGroup(cmd.self));\n        return WireResult::Success;\n    }\n\n    WireResult Server::HandleRenderPassEncoderPushDebugGroup(DeserializeBuffer* deserializeBuffer) {\n        RenderPassEncoderPushDebugGroupCmd cmd;\n        WIRE_TRY(cmd.Deserialize(deserializeBuffer, &mAllocator, *this));\n\nWIRE_TRY(DoRenderPassEncoderPushDebugGroup(cmd.self, cmd.groupLabel));\n        return WireResult::Success;\n    }\n\n    WireResult Server::HandleRenderPassEncoderSetBindGroup(DeserializeBuffer* deserializeBuffer) {\n        RenderPassEncoderSetBindGroupCmd cmd;\n        WIRE_TRY(cmd.Deserialize(deserializeBuffer, &mAllocator, *this));\n\nWIRE_TRY(DoRenderPassEncoderSetBindGroup(cmd.self, cmd.groupIndex, cmd.group, cmd.dynamicOffsetCount, cmd.dynamicOffsets));\n        return WireResult::Success;\n    }\n\n    WireResult Server::HandleRenderPassEncoderSetBlendConstant(DeserializeBuffer* deserializeBuffer) {\n        RenderPassEncoderSetBlendConstantCmd cmd;\n        WIRE_TRY(cmd.Deserialize(deserializeBuffer, &mAllocator, *this));\n\nWIRE_TRY(DoRenderPassEncoderSetBlendConstant(cmd.self, cmd.color));\n        return WireResult::Success;\n    }\n\n    WireResult Server::HandleRenderPassEncoderSetIndexBuffer(DeserializeBuffer* deserializeBuffer) {\n        RenderPassEncoderSetIndexBufferCmd cmd;\n        WIRE_TRY(cmd.Deserialize(deserializeBuffer, &mAllocator, *this));\n\nWIRE_TRY(DoRenderPassEncoderSetIndexBuffer(cmd.self, cmd.buffer, cmd.format, cmd.offset, cmd.size));\n        return WireResult::Success;\n    }\n\n    WireResult Server::HandleRenderPassEncoderSetLabel(DeserializeBuffer* deserializeBuffer) {\n        RenderPassEncoderSetLabelCmd cmd;\n        WIRE_TRY(cmd.Deserialize(deserializeBuffer, &mAllocator, *this));\n\nWIRE_TRY(DoRenderPassEncoderSetLabel(cmd.self, cmd.label));\n        return WireResult::Success;\n    }\n\n    WireResult Server::HandleRenderPassEncoderSetPipeline(DeserializeBuffer* deserializeBuffer) {\n        RenderPassEncoderSetPipelineCmd cmd;\n        WIRE_TRY(cmd.Deserialize(deserializeBuffer, &mAllocator, *this));\n\nWIRE_TRY(DoRenderPassEncoderSetPipeline(cmd.self, cmd.pipeline));\n        return WireResult::Success;\n    }\n\n    WireResult Server::HandleRenderPassEncoderSetScissorRect(DeserializeBuffer* deserializeBuffer) {\n        RenderPassEncoderSetScissorRectCmd cmd;\n        WIRE_TRY(cmd.Deserialize(deserializeBuffer, &mAllocator, *this));\n\nWIRE_TRY(DoRenderPassEncoderSetScissorRect(cmd.self, cmd.x, cmd.y, cmd.width, cmd.height));\n        return WireResult::Success;\n    }\n\n    WireResult Server::HandleRenderPassEncoderSetStencilReference(DeserializeBuffer* deserializeBuffer) {\n        RenderPassEncoderSetStencilReferenceCmd cmd;\n        WIRE_TRY(cmd.Deserialize(deserializeBuffer, &mAllocator, *this));\n\nWIRE_TRY(DoRenderPassEncoderSetStencilReference(cmd.self, cmd.reference));\n        return WireResult::Success;\n    }\n\n    WireResult Server::HandleRenderPassEncoderSetVertexBuffer(DeserializeBuffer* deserializeBuffer) {\n        RenderPassEncoderSetVertexBufferCmd cmd;\n        WIRE_TRY(cmd.Deserialize(deserializeBuffer, &mAllocator, *this));\n\nWIRE_TRY(DoRenderPassEncoderSetVertexBuffer(cmd.self, cmd.slot, cmd.buffer, cmd.offset, cmd.size));\n        return WireResult::Success;\n    }\n\n    WireResult Server::HandleRenderPassEncoderSetViewport(DeserializeBuffer* deserializeBuffer) {\n        RenderPassEncoderSetViewportCmd cmd;\n        WIRE_TRY(cmd.Deserialize(deserializeBuffer, &mAllocator, *this));\n\nWIRE_TRY(DoRenderPassEncoderSetViewport(cmd.self, cmd.x, cmd.y, cmd.width, cmd.height, cmd.minDepth, cmd.maxDepth));\n        return WireResult::Success;\n    }\n\n    WireResult Server::HandleRenderPassEncoderWriteTimestamp(DeserializeBuffer* deserializeBuffer) {\n        RenderPassEncoderWriteTimestampCmd cmd;\n        WIRE_TRY(cmd.Deserialize(deserializeBuffer, &mAllocator, *this));\n\nWIRE_TRY(DoRenderPassEncoderWriteTimestamp(cmd.self, cmd.querySet, cmd.queryIndex));\n        return WireResult::Success;\n    }\n\n    WireResult Server::HandleRenderPipelineGetBindGroupLayout(DeserializeBuffer* deserializeBuffer) {\n        RenderPipelineGetBindGroupLayoutCmd cmd;\n        WIRE_TRY(cmd.Deserialize(deserializeBuffer, &mAllocator, *this));\n\n\n\n        Known<WGPUBindGroupLayout> resultData;\n        WIRE_TRY(BindGroupLayoutObjects().Allocate(&resultData, cmd.result));\n        resultData->generation = cmd.result.generation;\nWIRE_TRY(DoRenderPipelineGetBindGroupLayout(cmd.self, cmd.groupIndex, &resultData->handle));\n\n        return WireResult::Success;\n    }\n\n    WireResult Server::HandleRenderPipelineSetLabel(DeserializeBuffer* deserializeBuffer) {\n        RenderPipelineSetLabelCmd cmd;\n        WIRE_TRY(cmd.Deserialize(deserializeBuffer, &mAllocator, *this));\n\nWIRE_TRY(DoRenderPipelineSetLabel(cmd.self, cmd.label));\n        return WireResult::Success;\n    }\n\n    WireResult Server::HandleSamplerSetLabel(DeserializeBuffer* deserializeBuffer) {\n        SamplerSetLabelCmd cmd;\n        WIRE_TRY(cmd.Deserialize(deserializeBuffer, &mAllocator, *this));\n\nWIRE_TRY(DoSamplerSetLabel(cmd.self, cmd.label));\n        return WireResult::Success;\n    }\n\n    WireResult Server::HandleShaderModuleGetCompilationInfo(DeserializeBuffer* deserializeBuffer) {\n        ShaderModuleGetCompilationInfoCmd cmd;\n        WIRE_TRY(cmd.Deserialize(deserializeBuffer, &mAllocator));\n\n        Known<WGPUShaderModule> shaderModuleIdHandle;\n        WIRE_TRY(ShaderModuleObjects().Get(cmd.shaderModuleId, &shaderModuleIdHandle));WIRE_TRY(DoShaderModuleGetCompilationInfo(shaderModuleIdHandle, cmd.requestSerial));\n        return WireResult::Success;\n    }\n\n    WireResult Server::HandleShaderModuleSetLabel(DeserializeBuffer* deserializeBuffer) {\n        ShaderModuleSetLabelCmd cmd;\n        WIRE_TRY(cmd.Deserialize(deserializeBuffer, &mAllocator, *this));\n\nWIRE_TRY(DoShaderModuleSetLabel(cmd.self, cmd.label));\n        return WireResult::Success;\n    }\n\n    WireResult Server::HandleSwapChainGetCurrentTexture(DeserializeBuffer* deserializeBuffer) {\n        SwapChainGetCurrentTextureCmd cmd;\n        WIRE_TRY(cmd.Deserialize(deserializeBuffer, &mAllocator, *this));\n\n\n\n        Known<WGPUTexture> resultData;\n        WIRE_TRY(TextureObjects().Allocate(&resultData, cmd.result));\n        resultData->generation = cmd.result.generation;\nWIRE_TRY(DoSwapChainGetCurrentTexture(cmd.self, &resultData->handle));\n\n        return WireResult::Success;\n    }\n\n    WireResult Server::HandleSwapChainGetCurrentTextureView(DeserializeBuffer* deserializeBuffer) {\n        SwapChainGetCurrentTextureViewCmd cmd;\n        WIRE_TRY(cmd.Deserialize(deserializeBuffer, &mAllocator, *this));\n\n\n\n        Known<WGPUTextureView> resultData;\n        WIRE_TRY(TextureViewObjects().Allocate(&resultData, cmd.result));\n        resultData->generation = cmd.result.generation;\nWIRE_TRY(DoSwapChainGetCurrentTextureView(cmd.self, &resultData->handle));\n\n        return WireResult::Success;\n    }\n\n    WireResult Server::HandleSwapChainPresent(DeserializeBuffer* deserializeBuffer) {\n        SwapChainPresentCmd cmd;\n        WIRE_TRY(cmd.Deserialize(deserializeBuffer, &mAllocator, *this));\n\nWIRE_TRY(DoSwapChainPresent(cmd.self));\n        return WireResult::Success;\n    }\n\n    WireResult Server::HandleTextureCreateView(DeserializeBuffer* deserializeBuffer) {\n        TextureCreateViewCmd cmd;\n        WIRE_TRY(cmd.Deserialize(deserializeBuffer, &mAllocator, *this));\n\n\n\n        Known<WGPUTextureView> resultData;\n        WIRE_TRY(TextureViewObjects().Allocate(&resultData, cmd.result));\n        resultData->generation = cmd.result.generation;\nWIRE_TRY(DoTextureCreateView(cmd.self, cmd.descriptor, &resultData->handle));\n\n        return WireResult::Success;\n    }\n\n    WireResult Server::HandleTextureDestroy(DeserializeBuffer* deserializeBuffer) {\n        TextureDestroyCmd cmd;\n        WIRE_TRY(cmd.Deserialize(deserializeBuffer, &mAllocator, *this));\n\nWIRE_TRY(DoTextureDestroy(cmd.self));\n        return WireResult::Success;\n    }\n\n    WireResult Server::HandleTextureSetLabel(DeserializeBuffer* deserializeBuffer) {\n        TextureSetLabelCmd cmd;\n        WIRE_TRY(cmd.Deserialize(deserializeBuffer, &mAllocator, *this));\n\nWIRE_TRY(DoTextureSetLabel(cmd.self, cmd.label));\n        return WireResult::Success;\n    }\n\n    WireResult Server::HandleTextureViewSetLabel(DeserializeBuffer* deserializeBuffer) {\n        TextureViewSetLabelCmd cmd;\n        WIRE_TRY(cmd.Deserialize(deserializeBuffer, &mAllocator, *this));\n\nWIRE_TRY(DoTextureViewSetLabel(cmd.self, cmd.label));\n        return WireResult::Success;\n    }\n\n    const volatile char* Server::HandleCommandsImpl(const volatile char* commands, size_t size) {\n        DeserializeBuffer deserializeBuffer(commands, size);\n\n        while (deserializeBuffer.AvailableSize() >= sizeof(CmdHeader) + sizeof(WireCmd)) {\n            // Start by chunked command handling, if it is done, then it means the whole buffer\n            // was consumed by it, so we return a pointer to the end of the commands.\n            switch (HandleChunkedCommands(deserializeBuffer.Buffer(), deserializeBuffer.AvailableSize())) {\n                case ChunkedCommandsResult::Consumed:\n                    return commands + size;\n                case ChunkedCommandsResult::Error:\n                    return nullptr;\n                case ChunkedCommandsResult::Passthrough:\n                    break;\n            }\n\n            WireCmd cmdId = *static_cast<const volatile WireCmd*>(static_cast<const volatile void*>(\n                deserializeBuffer.Buffer() + sizeof(CmdHeader)));\n            WireResult result;\n            switch (cmdId) {\n                case WireCmd::AdapterGetInstance:\n                    result = HandleAdapterGetInstance(&deserializeBuffer);\n                    break;\n                case WireCmd::AdapterRequestDevice:\n                    result = HandleAdapterRequestDevice(&deserializeBuffer);\n                    break;\n                case WireCmd::BindGroupLayoutSetLabel:\n                    result = HandleBindGroupLayoutSetLabel(&deserializeBuffer);\n                    break;\n                case WireCmd::BindGroupSetLabel:\n                    result = HandleBindGroupSetLabel(&deserializeBuffer);\n                    break;\n                case WireCmd::BufferDestroy:\n                    result = HandleBufferDestroy(&deserializeBuffer);\n                    break;\n                case WireCmd::BufferMapAsync:\n                    result = HandleBufferMapAsync(&deserializeBuffer);\n                    break;\n                case WireCmd::BufferSetLabel:\n                    result = HandleBufferSetLabel(&deserializeBuffer);\n                    break;\n                case WireCmd::BufferUnmap:\n                    result = HandleBufferUnmap(&deserializeBuffer);\n                    break;\n                case WireCmd::BufferUpdateMappedData:\n                    result = HandleBufferUpdateMappedData(&deserializeBuffer);\n                    break;\n                case WireCmd::CommandBufferSetLabel:\n                    result = HandleCommandBufferSetLabel(&deserializeBuffer);\n                    break;\n                case WireCmd::CommandEncoderBeginComputePass:\n                    result = HandleCommandEncoderBeginComputePass(&deserializeBuffer);\n                    break;\n                case WireCmd::CommandEncoderBeginRenderPass:\n                    result = HandleCommandEncoderBeginRenderPass(&deserializeBuffer);\n                    break;\n                case WireCmd::CommandEncoderClearBuffer:\n                    result = HandleCommandEncoderClearBuffer(&deserializeBuffer);\n                    break;\n                case WireCmd::CommandEncoderCopyBufferToBuffer:\n                    result = HandleCommandEncoderCopyBufferToBuffer(&deserializeBuffer);\n                    break;\n                case WireCmd::CommandEncoderCopyBufferToTexture:\n                    result = HandleCommandEncoderCopyBufferToTexture(&deserializeBuffer);\n                    break;\n                case WireCmd::CommandEncoderCopyTextureToBuffer:\n                    result = HandleCommandEncoderCopyTextureToBuffer(&deserializeBuffer);\n                    break;\n                case WireCmd::CommandEncoderCopyTextureToTexture:\n                    result = HandleCommandEncoderCopyTextureToTexture(&deserializeBuffer);\n                    break;\n                case WireCmd::CommandEncoderCopyTextureToTextureInternal:\n                    result = HandleCommandEncoderCopyTextureToTextureInternal(&deserializeBuffer);\n                    break;\n                case WireCmd::CommandEncoderFinish:\n                    result = HandleCommandEncoderFinish(&deserializeBuffer);\n                    break;\n                case WireCmd::CommandEncoderInjectValidationError:\n                    result = HandleCommandEncoderInjectValidationError(&deserializeBuffer);\n                    break;\n                case WireCmd::CommandEncoderInsertDebugMarker:\n                    result = HandleCommandEncoderInsertDebugMarker(&deserializeBuffer);\n                    break;\n                case WireCmd::CommandEncoderPopDebugGroup:\n                    result = HandleCommandEncoderPopDebugGroup(&deserializeBuffer);\n                    break;\n                case WireCmd::CommandEncoderPushDebugGroup:\n                    result = HandleCommandEncoderPushDebugGroup(&deserializeBuffer);\n                    break;\n                case WireCmd::CommandEncoderResolveQuerySet:\n                    result = HandleCommandEncoderResolveQuerySet(&deserializeBuffer);\n                    break;\n                case WireCmd::CommandEncoderSetLabel:\n                    result = HandleCommandEncoderSetLabel(&deserializeBuffer);\n                    break;\n                case WireCmd::CommandEncoderWriteBuffer:\n                    result = HandleCommandEncoderWriteBuffer(&deserializeBuffer);\n                    break;\n                case WireCmd::CommandEncoderWriteTimestamp:\n                    result = HandleCommandEncoderWriteTimestamp(&deserializeBuffer);\n                    break;\n                case WireCmd::ComputePassEncoderDispatchWorkgroups:\n                    result = HandleComputePassEncoderDispatchWorkgroups(&deserializeBuffer);\n                    break;\n                case WireCmd::ComputePassEncoderDispatchWorkgroupsIndirect:\n                    result = HandleComputePassEncoderDispatchWorkgroupsIndirect(&deserializeBuffer);\n                    break;\n                case WireCmd::ComputePassEncoderEnd:\n                    result = HandleComputePassEncoderEnd(&deserializeBuffer);\n                    break;\n                case WireCmd::ComputePassEncoderInsertDebugMarker:\n                    result = HandleComputePassEncoderInsertDebugMarker(&deserializeBuffer);\n                    break;\n                case WireCmd::ComputePassEncoderPopDebugGroup:\n                    result = HandleComputePassEncoderPopDebugGroup(&deserializeBuffer);\n                    break;\n                case WireCmd::ComputePassEncoderPushDebugGroup:\n                    result = HandleComputePassEncoderPushDebugGroup(&deserializeBuffer);\n                    break;\n                case WireCmd::ComputePassEncoderSetBindGroup:\n                    result = HandleComputePassEncoderSetBindGroup(&deserializeBuffer);\n                    break;\n                case WireCmd::ComputePassEncoderSetLabel:\n                    result = HandleComputePassEncoderSetLabel(&deserializeBuffer);\n                    break;\n                case WireCmd::ComputePassEncoderSetPipeline:\n                    result = HandleComputePassEncoderSetPipeline(&deserializeBuffer);\n                    break;\n                case WireCmd::ComputePassEncoderWriteTimestamp:\n                    result = HandleComputePassEncoderWriteTimestamp(&deserializeBuffer);\n                    break;\n                case WireCmd::ComputePipelineGetBindGroupLayout:\n                    result = HandleComputePipelineGetBindGroupLayout(&deserializeBuffer);\n                    break;\n                case WireCmd::ComputePipelineSetLabel:\n                    result = HandleComputePipelineSetLabel(&deserializeBuffer);\n                    break;\n                case WireCmd::DestroyObject:\n                    result = HandleDestroyObject(&deserializeBuffer);\n                    break;\n                case WireCmd::DeviceCreateBindGroup:\n                    result = HandleDeviceCreateBindGroup(&deserializeBuffer);\n                    break;\n                case WireCmd::DeviceCreateBindGroupLayout:\n                    result = HandleDeviceCreateBindGroupLayout(&deserializeBuffer);\n                    break;\n                case WireCmd::DeviceCreateBuffer:\n                    result = HandleDeviceCreateBuffer(&deserializeBuffer);\n                    break;\n                case WireCmd::DeviceCreateCommandEncoder:\n                    result = HandleDeviceCreateCommandEncoder(&deserializeBuffer);\n                    break;\n                case WireCmd::DeviceCreateComputePipeline:\n                    result = HandleDeviceCreateComputePipeline(&deserializeBuffer);\n                    break;\n                case WireCmd::DeviceCreateComputePipelineAsync:\n                    result = HandleDeviceCreateComputePipelineAsync(&deserializeBuffer);\n                    break;\n                case WireCmd::DeviceCreateErrorBuffer:\n                    result = HandleDeviceCreateErrorBuffer(&deserializeBuffer);\n                    break;\n                case WireCmd::DeviceCreateErrorExternalTexture:\n                    result = HandleDeviceCreateErrorExternalTexture(&deserializeBuffer);\n                    break;\n                case WireCmd::DeviceCreateErrorShaderModule:\n                    result = HandleDeviceCreateErrorShaderModule(&deserializeBuffer);\n                    break;\n                case WireCmd::DeviceCreateErrorTexture:\n                    result = HandleDeviceCreateErrorTexture(&deserializeBuffer);\n                    break;\n                case WireCmd::DeviceCreateExternalTexture:\n                    result = HandleDeviceCreateExternalTexture(&deserializeBuffer);\n                    break;\n                case WireCmd::DeviceCreatePipelineLayout:\n                    result = HandleDeviceCreatePipelineLayout(&deserializeBuffer);\n                    break;\n                case WireCmd::DeviceCreateQuerySet:\n                    result = HandleDeviceCreateQuerySet(&deserializeBuffer);\n                    break;\n                case WireCmd::DeviceCreateRenderBundleEncoder:\n                    result = HandleDeviceCreateRenderBundleEncoder(&deserializeBuffer);\n                    break;\n                case WireCmd::DeviceCreateRenderPipeline:\n                    result = HandleDeviceCreateRenderPipeline(&deserializeBuffer);\n                    break;\n                case WireCmd::DeviceCreateRenderPipelineAsync:\n                    result = HandleDeviceCreateRenderPipelineAsync(&deserializeBuffer);\n                    break;\n                case WireCmd::DeviceCreateSampler:\n                    result = HandleDeviceCreateSampler(&deserializeBuffer);\n                    break;\n                case WireCmd::DeviceCreateShaderModule:\n                    result = HandleDeviceCreateShaderModule(&deserializeBuffer);\n                    break;\n                case WireCmd::DeviceCreateSwapChain:\n                    result = HandleDeviceCreateSwapChain(&deserializeBuffer);\n                    break;\n                case WireCmd::DeviceCreateTexture:\n                    result = HandleDeviceCreateTexture(&deserializeBuffer);\n                    break;\n                case WireCmd::DeviceDestroy:\n                    result = HandleDeviceDestroy(&deserializeBuffer);\n                    break;\n                case WireCmd::DeviceForceLoss:\n                    result = HandleDeviceForceLoss(&deserializeBuffer);\n                    break;\n                case WireCmd::DeviceGetAdapter:\n                    result = HandleDeviceGetAdapter(&deserializeBuffer);\n                    break;\n                case WireCmd::DeviceGetQueue:\n                    result = HandleDeviceGetQueue(&deserializeBuffer);\n                    break;\n                case WireCmd::DeviceInjectError:\n                    result = HandleDeviceInjectError(&deserializeBuffer);\n                    break;\n                case WireCmd::DevicePopErrorScope:\n                    result = HandleDevicePopErrorScope(&deserializeBuffer);\n                    break;\n                case WireCmd::DevicePushErrorScope:\n                    result = HandleDevicePushErrorScope(&deserializeBuffer);\n                    break;\n                case WireCmd::DeviceSetLabel:\n                    result = HandleDeviceSetLabel(&deserializeBuffer);\n                    break;\n                case WireCmd::DeviceTick:\n                    result = HandleDeviceTick(&deserializeBuffer);\n                    break;\n                case WireCmd::DeviceValidateTextureDescriptor:\n                    result = HandleDeviceValidateTextureDescriptor(&deserializeBuffer);\n                    break;\n                case WireCmd::ExternalTextureDestroy:\n                    result = HandleExternalTextureDestroy(&deserializeBuffer);\n                    break;\n                case WireCmd::ExternalTextureExpire:\n                    result = HandleExternalTextureExpire(&deserializeBuffer);\n                    break;\n                case WireCmd::ExternalTextureRefresh:\n                    result = HandleExternalTextureRefresh(&deserializeBuffer);\n                    break;\n                case WireCmd::ExternalTextureSetLabel:\n                    result = HandleExternalTextureSetLabel(&deserializeBuffer);\n                    break;\n                case WireCmd::InstanceCreateSurface:\n                    result = HandleInstanceCreateSurface(&deserializeBuffer);\n                    break;\n                case WireCmd::InstanceProcessEvents:\n                    result = HandleInstanceProcessEvents(&deserializeBuffer);\n                    break;\n                case WireCmd::InstanceRequestAdapter:\n                    result = HandleInstanceRequestAdapter(&deserializeBuffer);\n                    break;\n                case WireCmd::PipelineLayoutSetLabel:\n                    result = HandlePipelineLayoutSetLabel(&deserializeBuffer);\n                    break;\n                case WireCmd::QuerySetDestroy:\n                    result = HandleQuerySetDestroy(&deserializeBuffer);\n                    break;\n                case WireCmd::QuerySetSetLabel:\n                    result = HandleQuerySetSetLabel(&deserializeBuffer);\n                    break;\n                case WireCmd::QueueCopyExternalTextureForBrowser:\n                    result = HandleQueueCopyExternalTextureForBrowser(&deserializeBuffer);\n                    break;\n                case WireCmd::QueueCopyTextureForBrowser:\n                    result = HandleQueueCopyTextureForBrowser(&deserializeBuffer);\n                    break;\n                case WireCmd::QueueOnSubmittedWorkDone:\n                    result = HandleQueueOnSubmittedWorkDone(&deserializeBuffer);\n                    break;\n                case WireCmd::QueueSetLabel:\n                    result = HandleQueueSetLabel(&deserializeBuffer);\n                    break;\n                case WireCmd::QueueSubmit:\n                    result = HandleQueueSubmit(&deserializeBuffer);\n                    break;\n                case WireCmd::QueueWriteBuffer:\n                    result = HandleQueueWriteBuffer(&deserializeBuffer);\n                    break;\n                case WireCmd::QueueWriteTexture:\n                    result = HandleQueueWriteTexture(&deserializeBuffer);\n                    break;\n                case WireCmd::RenderBundleEncoderDraw:\n                    result = HandleRenderBundleEncoderDraw(&deserializeBuffer);\n                    break;\n                case WireCmd::RenderBundleEncoderDrawIndexed:\n                    result = HandleRenderBundleEncoderDrawIndexed(&deserializeBuffer);\n                    break;\n                case WireCmd::RenderBundleEncoderDrawIndexedIndirect:\n                    result = HandleRenderBundleEncoderDrawIndexedIndirect(&deserializeBuffer);\n                    break;\n                case WireCmd::RenderBundleEncoderDrawIndirect:\n                    result = HandleRenderBundleEncoderDrawIndirect(&deserializeBuffer);\n                    break;\n                case WireCmd::RenderBundleEncoderFinish:\n                    result = HandleRenderBundleEncoderFinish(&deserializeBuffer);\n                    break;\n                case WireCmd::RenderBundleEncoderInsertDebugMarker:\n                    result = HandleRenderBundleEncoderInsertDebugMarker(&deserializeBuffer);\n                    break;\n                case WireCmd::RenderBundleEncoderPopDebugGroup:\n                    result = HandleRenderBundleEncoderPopDebugGroup(&deserializeBuffer);\n                    break;\n                case WireCmd::RenderBundleEncoderPushDebugGroup:\n                    result = HandleRenderBundleEncoderPushDebugGroup(&deserializeBuffer);\n                    break;\n                case WireCmd::RenderBundleEncoderSetBindGroup:\n                    result = HandleRenderBundleEncoderSetBindGroup(&deserializeBuffer);\n                    break;\n                case WireCmd::RenderBundleEncoderSetIndexBuffer:\n                    result = HandleRenderBundleEncoderSetIndexBuffer(&deserializeBuffer);\n                    break;\n                case WireCmd::RenderBundleEncoderSetLabel:\n                    result = HandleRenderBundleEncoderSetLabel(&deserializeBuffer);\n                    break;\n                case WireCmd::RenderBundleEncoderSetPipeline:\n                    result = HandleRenderBundleEncoderSetPipeline(&deserializeBuffer);\n                    break;\n                case WireCmd::RenderBundleEncoderSetVertexBuffer:\n                    result = HandleRenderBundleEncoderSetVertexBuffer(&deserializeBuffer);\n                    break;\n                case WireCmd::RenderBundleSetLabel:\n                    result = HandleRenderBundleSetLabel(&deserializeBuffer);\n                    break;\n                case WireCmd::RenderPassEncoderBeginOcclusionQuery:\n                    result = HandleRenderPassEncoderBeginOcclusionQuery(&deserializeBuffer);\n                    break;\n                case WireCmd::RenderPassEncoderDraw:\n                    result = HandleRenderPassEncoderDraw(&deserializeBuffer);\n                    break;\n                case WireCmd::RenderPassEncoderDrawIndexed:\n                    result = HandleRenderPassEncoderDrawIndexed(&deserializeBuffer);\n                    break;\n                case WireCmd::RenderPassEncoderDrawIndexedIndirect:\n                    result = HandleRenderPassEncoderDrawIndexedIndirect(&deserializeBuffer);\n                    break;\n                case WireCmd::RenderPassEncoderDrawIndirect:\n                    result = HandleRenderPassEncoderDrawIndirect(&deserializeBuffer);\n                    break;\n                case WireCmd::RenderPassEncoderEnd:\n                    result = HandleRenderPassEncoderEnd(&deserializeBuffer);\n                    break;\n                case WireCmd::RenderPassEncoderEndOcclusionQuery:\n                    result = HandleRenderPassEncoderEndOcclusionQuery(&deserializeBuffer);\n                    break;\n                case WireCmd::RenderPassEncoderExecuteBundles:\n                    result = HandleRenderPassEncoderExecuteBundles(&deserializeBuffer);\n                    break;\n                case WireCmd::RenderPassEncoderInsertDebugMarker:\n                    result = HandleRenderPassEncoderInsertDebugMarker(&deserializeBuffer);\n                    break;\n                case WireCmd::RenderPassEncoderPopDebugGroup:\n                    result = HandleRenderPassEncoderPopDebugGroup(&deserializeBuffer);\n                    break;\n                case WireCmd::RenderPassEncoderPushDebugGroup:\n                    result = HandleRenderPassEncoderPushDebugGroup(&deserializeBuffer);\n                    break;\n                case WireCmd::RenderPassEncoderSetBindGroup:\n                    result = HandleRenderPassEncoderSetBindGroup(&deserializeBuffer);\n                    break;\n                case WireCmd::RenderPassEncoderSetBlendConstant:\n                    result = HandleRenderPassEncoderSetBlendConstant(&deserializeBuffer);\n                    break;\n                case WireCmd::RenderPassEncoderSetIndexBuffer:\n                    result = HandleRenderPassEncoderSetIndexBuffer(&deserializeBuffer);\n                    break;\n                case WireCmd::RenderPassEncoderSetLabel:\n                    result = HandleRenderPassEncoderSetLabel(&deserializeBuffer);\n                    break;\n                case WireCmd::RenderPassEncoderSetPipeline:\n                    result = HandleRenderPassEncoderSetPipeline(&deserializeBuffer);\n                    break;\n                case WireCmd::RenderPassEncoderSetScissorRect:\n                    result = HandleRenderPassEncoderSetScissorRect(&deserializeBuffer);\n                    break;\n                case WireCmd::RenderPassEncoderSetStencilReference:\n                    result = HandleRenderPassEncoderSetStencilReference(&deserializeBuffer);\n                    break;\n                case WireCmd::RenderPassEncoderSetVertexBuffer:\n                    result = HandleRenderPassEncoderSetVertexBuffer(&deserializeBuffer);\n                    break;\n                case WireCmd::RenderPassEncoderSetViewport:\n                    result = HandleRenderPassEncoderSetViewport(&deserializeBuffer);\n                    break;\n                case WireCmd::RenderPassEncoderWriteTimestamp:\n                    result = HandleRenderPassEncoderWriteTimestamp(&deserializeBuffer);\n                    break;\n                case WireCmd::RenderPipelineGetBindGroupLayout:\n                    result = HandleRenderPipelineGetBindGroupLayout(&deserializeBuffer);\n                    break;\n                case WireCmd::RenderPipelineSetLabel:\n                    result = HandleRenderPipelineSetLabel(&deserializeBuffer);\n                    break;\n                case WireCmd::SamplerSetLabel:\n                    result = HandleSamplerSetLabel(&deserializeBuffer);\n                    break;\n                case WireCmd::ShaderModuleGetCompilationInfo:\n                    result = HandleShaderModuleGetCompilationInfo(&deserializeBuffer);\n                    break;\n                case WireCmd::ShaderModuleSetLabel:\n                    result = HandleShaderModuleSetLabel(&deserializeBuffer);\n                    break;\n                case WireCmd::SwapChainGetCurrentTexture:\n                    result = HandleSwapChainGetCurrentTexture(&deserializeBuffer);\n                    break;\n                case WireCmd::SwapChainGetCurrentTextureView:\n                    result = HandleSwapChainGetCurrentTextureView(&deserializeBuffer);\n                    break;\n                case WireCmd::SwapChainPresent:\n                    result = HandleSwapChainPresent(&deserializeBuffer);\n                    break;\n                case WireCmd::TextureCreateView:\n                    result = HandleTextureCreateView(&deserializeBuffer);\n                    break;\n                case WireCmd::TextureDestroy:\n                    result = HandleTextureDestroy(&deserializeBuffer);\n                    break;\n                case WireCmd::TextureSetLabel:\n                    result = HandleTextureSetLabel(&deserializeBuffer);\n                    break;\n                case WireCmd::TextureViewSetLabel:\n                    result = HandleTextureViewSetLabel(&deserializeBuffer);\n                    break;\n                default:\n                    result = WireResult::FatalError;\n            }\n\n            if (result != WireResult::Success) {\n                return nullptr;\n            }\n            mAllocator.Reset();\n        }\n\n        if (deserializeBuffer.AvailableSize() != 0) {\n            return nullptr;\n        }\n\n        return commands;\n    }\n\n}  // namespace dawn::wire::server\n", "src/dawn/wire/server/ServerPrototypes_autogen.inc": "\n// Command handlers & doers\nWireResult HandleAdapterGetInstance(DeserializeBuffer* deserializeBuffer);\n\nWireResult DoAdapterGetInstance(WGPUAdapter self, WGPUInstance* result);\nWireResult HandleAdapterRequestDevice(DeserializeBuffer* deserializeBuffer);\n\nWireResult DoAdapterRequestDevice(Known<WGPUAdapter> adapterId, uint64_t requestSerial, ObjectHandle deviceObjectHandle, WGPUDeviceDescriptor const * descriptor);\nWireResult HandleBindGroupLayoutSetLabel(DeserializeBuffer* deserializeBuffer);\n\nWireResult DoBindGroupLayoutSetLabel(WGPUBindGroupLayout self, char const * label);\nWireResult HandleBindGroupSetLabel(DeserializeBuffer* deserializeBuffer);\n\nWireResult DoBindGroupSetLabel(WGPUBindGroup self, char const * label);\nWireResult HandleBufferDestroy(DeserializeBuffer* deserializeBuffer);\n\nWireResult DoBufferDestroy(WGPUBuffer self);\nWireResult HandleBufferMapAsync(DeserializeBuffer* deserializeBuffer);\n\nWireResult DoBufferMapAsync(Known<WGPUBuffer> bufferId, uint64_t requestSerial, WGPUMapModeFlags mode, uint64_t offset, uint64_t size);\nWireResult HandleBufferSetLabel(DeserializeBuffer* deserializeBuffer);\n\nWireResult DoBufferSetLabel(WGPUBuffer self, char const * label);\nWireResult HandleBufferUnmap(DeserializeBuffer* deserializeBuffer);\n\nWireResult DoBufferUnmap(WGPUBuffer self);\nWireResult HandleBufferUpdateMappedData(DeserializeBuffer* deserializeBuffer);\n\nWireResult DoBufferUpdateMappedData(Known<WGPUBuffer> bufferId, uint64_t writeDataUpdateInfoLength, uint8_t const * writeDataUpdateInfo, uint64_t offset, uint64_t size);\nWireResult HandleCommandBufferSetLabel(DeserializeBuffer* deserializeBuffer);\n\nWireResult DoCommandBufferSetLabel(WGPUCommandBuffer self, char const * label);\nWireResult HandleCommandEncoderBeginComputePass(DeserializeBuffer* deserializeBuffer);\n\nWireResult DoCommandEncoderBeginComputePass(WGPUCommandEncoder self, WGPUComputePassDescriptor const * descriptor, WGPUComputePassEncoder* result);\nWireResult HandleCommandEncoderBeginRenderPass(DeserializeBuffer* deserializeBuffer);\n\nWireResult DoCommandEncoderBeginRenderPass(WGPUCommandEncoder self, WGPURenderPassDescriptor const * descriptor, WGPURenderPassEncoder* result);\nWireResult HandleCommandEncoderClearBuffer(DeserializeBuffer* deserializeBuffer);\n\nWireResult DoCommandEncoderClearBuffer(WGPUCommandEncoder self, WGPUBuffer buffer, uint64_t offset, uint64_t size);\nWireResult HandleCommandEncoderCopyBufferToBuffer(DeserializeBuffer* deserializeBuffer);\n\nWireResult DoCommandEncoderCopyBufferToBuffer(WGPUCommandEncoder self, WGPUBuffer source, uint64_t sourceOffset, WGPUBuffer destination, uint64_t destinationOffset, uint64_t size);\nWireResult HandleCommandEncoderCopyBufferToTexture(DeserializeBuffer* deserializeBuffer);\n\nWireResult DoCommandEncoderCopyBufferToTexture(WGPUCommandEncoder self, WGPUImageCopyBuffer const * source, WGPUImageCopyTexture const * destination, WGPUExtent3D const * copySize);\nWireResult HandleCommandEncoderCopyTextureToBuffer(DeserializeBuffer* deserializeBuffer);\n\nWireResult DoCommandEncoderCopyTextureToBuffer(WGPUCommandEncoder self, WGPUImageCopyTexture const * source, WGPUImageCopyBuffer const * destination, WGPUExtent3D const * copySize);\nWireResult HandleCommandEncoderCopyTextureToTexture(DeserializeBuffer* deserializeBuffer);\n\nWireResult DoCommandEncoderCopyTextureToTexture(WGPUCommandEncoder self, WGPUImageCopyTexture const * source, WGPUImageCopyTexture const * destination, WGPUExtent3D const * copySize);\nWireResult HandleCommandEncoderCopyTextureToTextureInternal(DeserializeBuffer* deserializeBuffer);\n\nWireResult DoCommandEncoderCopyTextureToTextureInternal(WGPUCommandEncoder self, WGPUImageCopyTexture const * source, WGPUImageCopyTexture const * destination, WGPUExtent3D const * copySize);\nWireResult HandleCommandEncoderFinish(DeserializeBuffer* deserializeBuffer);\n\nWireResult DoCommandEncoderFinish(WGPUCommandEncoder self, WGPUCommandBufferDescriptor const * descriptor, WGPUCommandBuffer* result);\nWireResult HandleCommandEncoderInjectValidationError(DeserializeBuffer* deserializeBuffer);\n\nWireResult DoCommandEncoderInjectValidationError(WGPUCommandEncoder self, char const * message);\nWireResult HandleCommandEncoderInsertDebugMarker(DeserializeBuffer* deserializeBuffer);\n\nWireResult DoCommandEncoderInsertDebugMarker(WGPUCommandEncoder self, char const * markerLabel);\nWireResult HandleCommandEncoderPopDebugGroup(DeserializeBuffer* deserializeBuffer);\n\nWireResult DoCommandEncoderPopDebugGroup(WGPUCommandEncoder self);\nWireResult HandleCommandEncoderPushDebugGroup(DeserializeBuffer* deserializeBuffer);\n\nWireResult DoCommandEncoderPushDebugGroup(WGPUCommandEncoder self, char const * groupLabel);\nWireResult HandleCommandEncoderResolveQuerySet(DeserializeBuffer* deserializeBuffer);\n\nWireResult DoCommandEncoderResolveQuerySet(WGPUCommandEncoder self, WGPUQuerySet querySet, uint32_t firstQuery, uint32_t queryCount, WGPUBuffer destination, uint64_t destinationOffset);\nWireResult HandleCommandEncoderSetLabel(DeserializeBuffer* deserializeBuffer);\n\nWireResult DoCommandEncoderSetLabel(WGPUCommandEncoder self, char const * label);\nWireResult HandleCommandEncoderWriteBuffer(DeserializeBuffer* deserializeBuffer);\n\nWireResult DoCommandEncoderWriteBuffer(WGPUCommandEncoder self, WGPUBuffer buffer, uint64_t bufferOffset, uint8_t const * data, uint64_t size);\nWireResult HandleCommandEncoderWriteTimestamp(DeserializeBuffer* deserializeBuffer);\n\nWireResult DoCommandEncoderWriteTimestamp(WGPUCommandEncoder self, WGPUQuerySet querySet, uint32_t queryIndex);\nWireResult HandleComputePassEncoderDispatchWorkgroups(DeserializeBuffer* deserializeBuffer);\n\nWireResult DoComputePassEncoderDispatchWorkgroups(WGPUComputePassEncoder self, uint32_t workgroupCountX, uint32_t workgroupCountY, uint32_t workgroupCountZ);\nWireResult HandleComputePassEncoderDispatchWorkgroupsIndirect(DeserializeBuffer* deserializeBuffer);\n\nWireResult DoComputePassEncoderDispatchWorkgroupsIndirect(WGPUComputePassEncoder self, WGPUBuffer indirectBuffer, uint64_t indirectOffset);\nWireResult HandleComputePassEncoderEnd(DeserializeBuffer* deserializeBuffer);\n\nWireResult DoComputePassEncoderEnd(WGPUComputePassEncoder self);\nWireResult HandleComputePassEncoderInsertDebugMarker(DeserializeBuffer* deserializeBuffer);\n\nWireResult DoComputePassEncoderInsertDebugMarker(WGPUComputePassEncoder self, char const * markerLabel);\nWireResult HandleComputePassEncoderPopDebugGroup(DeserializeBuffer* deserializeBuffer);\n\nWireResult DoComputePassEncoderPopDebugGroup(WGPUComputePassEncoder self);\nWireResult HandleComputePassEncoderPushDebugGroup(DeserializeBuffer* deserializeBuffer);\n\nWireResult DoComputePassEncoderPushDebugGroup(WGPUComputePassEncoder self, char const * groupLabel);\nWireResult HandleComputePassEncoderSetBindGroup(DeserializeBuffer* deserializeBuffer);\n\nWireResult DoComputePassEncoderSetBindGroup(WGPUComputePassEncoder self, uint32_t groupIndex, WGPUBindGroup group, size_t dynamicOffsetCount, uint32_t const * dynamicOffsets);\nWireResult HandleComputePassEncoderSetLabel(DeserializeBuffer* deserializeBuffer);\n\nWireResult DoComputePassEncoderSetLabel(WGPUComputePassEncoder self, char const * label);\nWireResult HandleComputePassEncoderSetPipeline(DeserializeBuffer* deserializeBuffer);\n\nWireResult DoComputePassEncoderSetPipeline(WGPUComputePassEncoder self, WGPUComputePipeline pipeline);\nWireResult HandleComputePassEncoderWriteTimestamp(DeserializeBuffer* deserializeBuffer);\n\nWireResult DoComputePassEncoderWriteTimestamp(WGPUComputePassEncoder self, WGPUQuerySet querySet, uint32_t queryIndex);\nWireResult HandleComputePipelineGetBindGroupLayout(DeserializeBuffer* deserializeBuffer);\n\nWireResult DoComputePipelineGetBindGroupLayout(WGPUComputePipeline self, uint32_t groupIndex, WGPUBindGroupLayout* result);\nWireResult HandleComputePipelineSetLabel(DeserializeBuffer* deserializeBuffer);\n\nWireResult DoComputePipelineSetLabel(WGPUComputePipeline self, char const * label);\nWireResult HandleDestroyObject(DeserializeBuffer* deserializeBuffer);\n\nWireResult DoDestroyObject(ObjectType objectType, ObjectId objectId);\nWireResult HandleDeviceCreateBindGroup(DeserializeBuffer* deserializeBuffer);\n\nWireResult DoDeviceCreateBindGroup(WGPUDevice self, WGPUBindGroupDescriptor const * descriptor, WGPUBindGroup* result);\nWireResult HandleDeviceCreateBindGroupLayout(DeserializeBuffer* deserializeBuffer);\n\nWireResult DoDeviceCreateBindGroupLayout(WGPUDevice self, WGPUBindGroupLayoutDescriptor const * descriptor, WGPUBindGroupLayout* result);\nWireResult HandleDeviceCreateBuffer(DeserializeBuffer* deserializeBuffer);\n\nWireResult DoDeviceCreateBuffer(Known<WGPUDevice> deviceId, WGPUBufferDescriptor const * descriptor, ObjectHandle result, uint64_t readHandleCreateInfoLength, uint8_t const * readHandleCreateInfo, uint64_t writeHandleCreateInfoLength, uint8_t const * writeHandleCreateInfo);\nWireResult HandleDeviceCreateCommandEncoder(DeserializeBuffer* deserializeBuffer);\n\nWireResult DoDeviceCreateCommandEncoder(WGPUDevice self, WGPUCommandEncoderDescriptor const * descriptor, WGPUCommandEncoder* result);\nWireResult HandleDeviceCreateComputePipeline(DeserializeBuffer* deserializeBuffer);\n\nWireResult DoDeviceCreateComputePipeline(WGPUDevice self, WGPUComputePipelineDescriptor const * descriptor, WGPUComputePipeline* result);\nWireResult HandleDeviceCreateComputePipelineAsync(DeserializeBuffer* deserializeBuffer);\n\nWireResult DoDeviceCreateComputePipelineAsync(Known<WGPUDevice> deviceId, uint64_t requestSerial, ObjectHandle pipelineObjectHandle, WGPUComputePipelineDescriptor const * descriptor);\nWireResult HandleDeviceCreateErrorBuffer(DeserializeBuffer* deserializeBuffer);\n\nWireResult DoDeviceCreateErrorBuffer(WGPUDevice self, WGPUBufferDescriptor const * descriptor, WGPUBuffer* result);\nWireResult HandleDeviceCreateErrorExternalTexture(DeserializeBuffer* deserializeBuffer);\n\nWireResult DoDeviceCreateErrorExternalTexture(WGPUDevice self, WGPUExternalTexture* result);\nWireResult HandleDeviceCreateErrorShaderModule(DeserializeBuffer* deserializeBuffer);\n\nWireResult DoDeviceCreateErrorShaderModule(WGPUDevice self, WGPUShaderModuleDescriptor const * descriptor, char const * errorMessage, WGPUShaderModule* result);\nWireResult HandleDeviceCreateErrorTexture(DeserializeBuffer* deserializeBuffer);\n\nWireResult DoDeviceCreateErrorTexture(WGPUDevice self, WGPUTextureDescriptor const * descriptor, WGPUTexture* result);\nWireResult HandleDeviceCreateExternalTexture(DeserializeBuffer* deserializeBuffer);\n\nWireResult DoDeviceCreateExternalTexture(WGPUDevice self, WGPUExternalTextureDescriptor const * externalTextureDescriptor, WGPUExternalTexture* result);\nWireResult HandleDeviceCreatePipelineLayout(DeserializeBuffer* deserializeBuffer);\n\nWireResult DoDeviceCreatePipelineLayout(WGPUDevice self, WGPUPipelineLayoutDescriptor const * descriptor, WGPUPipelineLayout* result);\nWireResult HandleDeviceCreateQuerySet(DeserializeBuffer* deserializeBuffer);\n\nWireResult DoDeviceCreateQuerySet(WGPUDevice self, WGPUQuerySetDescriptor const * descriptor, WGPUQuerySet* result);\nWireResult HandleDeviceCreateRenderBundleEncoder(DeserializeBuffer* deserializeBuffer);\n\nWireResult DoDeviceCreateRenderBundleEncoder(WGPUDevice self, WGPURenderBundleEncoderDescriptor const * descriptor, WGPURenderBundleEncoder* result);\nWireResult HandleDeviceCreateRenderPipeline(DeserializeBuffer* deserializeBuffer);\n\nWireResult DoDeviceCreateRenderPipeline(WGPUDevice self, WGPURenderPipelineDescriptor const * descriptor, WGPURenderPipeline* result);\nWireResult HandleDeviceCreateRenderPipelineAsync(DeserializeBuffer* deserializeBuffer);\n\nWireResult DoDeviceCreateRenderPipelineAsync(Known<WGPUDevice> deviceId, uint64_t requestSerial, ObjectHandle pipelineObjectHandle, WGPURenderPipelineDescriptor const * descriptor);\nWireResult HandleDeviceCreateSampler(DeserializeBuffer* deserializeBuffer);\n\nWireResult DoDeviceCreateSampler(WGPUDevice self, WGPUSamplerDescriptor const * descriptor, WGPUSampler* result);\nWireResult HandleDeviceCreateShaderModule(DeserializeBuffer* deserializeBuffer);\n\nWireResult DoDeviceCreateShaderModule(WGPUDevice self, WGPUShaderModuleDescriptor const * descriptor, WGPUShaderModule* result);\nWireResult HandleDeviceCreateSwapChain(DeserializeBuffer* deserializeBuffer);\n\nWireResult DoDeviceCreateSwapChain(WGPUDevice self, WGPUSurface surface, WGPUSwapChainDescriptor const * descriptor, WGPUSwapChain* result);\nWireResult HandleDeviceCreateTexture(DeserializeBuffer* deserializeBuffer);\n\nWireResult DoDeviceCreateTexture(WGPUDevice self, WGPUTextureDescriptor const * descriptor, WGPUTexture* result);\nWireResult HandleDeviceDestroy(DeserializeBuffer* deserializeBuffer);\n\nWireResult DoDeviceDestroy(WGPUDevice self);\nWireResult HandleDeviceForceLoss(DeserializeBuffer* deserializeBuffer);\n\nWireResult DoDeviceForceLoss(WGPUDevice self, WGPUDeviceLostReason type, char const * message);\nWireResult HandleDeviceGetAdapter(DeserializeBuffer* deserializeBuffer);\n\nWireResult DoDeviceGetAdapter(WGPUDevice self, WGPUAdapter* result);\nWireResult HandleDeviceGetQueue(DeserializeBuffer* deserializeBuffer);\n\nWireResult DoDeviceGetQueue(WGPUDevice self, WGPUQueue* result);\nWireResult HandleDeviceInjectError(DeserializeBuffer* deserializeBuffer);\n\nWireResult DoDeviceInjectError(WGPUDevice self, WGPUErrorType type, char const * message);\nWireResult HandleDevicePopErrorScope(DeserializeBuffer* deserializeBuffer);\n\nWireResult DoDevicePopErrorScope(Known<WGPUDevice> deviceId, uint64_t requestSerial);\nWireResult HandleDevicePushErrorScope(DeserializeBuffer* deserializeBuffer);\n\nWireResult DoDevicePushErrorScope(WGPUDevice self, WGPUErrorFilter filter);\nWireResult HandleDeviceSetLabel(DeserializeBuffer* deserializeBuffer);\n\nWireResult DoDeviceSetLabel(WGPUDevice self, char const * label);\nWireResult HandleDeviceTick(DeserializeBuffer* deserializeBuffer);\n\nWireResult DoDeviceTick(WGPUDevice self);\nWireResult HandleDeviceValidateTextureDescriptor(DeserializeBuffer* deserializeBuffer);\n\nWireResult DoDeviceValidateTextureDescriptor(WGPUDevice self, WGPUTextureDescriptor const * descriptor);\nWireResult HandleExternalTextureDestroy(DeserializeBuffer* deserializeBuffer);\n\nWireResult DoExternalTextureDestroy(WGPUExternalTexture self);\nWireResult HandleExternalTextureExpire(DeserializeBuffer* deserializeBuffer);\n\nWireResult DoExternalTextureExpire(WGPUExternalTexture self);\nWireResult HandleExternalTextureRefresh(DeserializeBuffer* deserializeBuffer);\n\nWireResult DoExternalTextureRefresh(WGPUExternalTexture self);\nWireResult HandleExternalTextureSetLabel(DeserializeBuffer* deserializeBuffer);\n\nWireResult DoExternalTextureSetLabel(WGPUExternalTexture self, char const * label);\nWireResult HandleInstanceCreateSurface(DeserializeBuffer* deserializeBuffer);\n\nWireResult DoInstanceCreateSurface(WGPUInstance self, WGPUSurfaceDescriptor const * descriptor, WGPUSurface* result);\nWireResult HandleInstanceProcessEvents(DeserializeBuffer* deserializeBuffer);\n\nWireResult DoInstanceProcessEvents(WGPUInstance self);\nWireResult HandleInstanceRequestAdapter(DeserializeBuffer* deserializeBuffer);\n\nWireResult DoInstanceRequestAdapter(Known<WGPUInstance> instanceId, uint64_t requestSerial, ObjectHandle adapterObjectHandle, WGPURequestAdapterOptions const * options);\nWireResult HandlePipelineLayoutSetLabel(DeserializeBuffer* deserializeBuffer);\n\nWireResult DoPipelineLayoutSetLabel(WGPUPipelineLayout self, char const * label);\nWireResult HandleQuerySetDestroy(DeserializeBuffer* deserializeBuffer);\n\nWireResult DoQuerySetDestroy(WGPUQuerySet self);\nWireResult HandleQuerySetSetLabel(DeserializeBuffer* deserializeBuffer);\n\nWireResult DoQuerySetSetLabel(WGPUQuerySet self, char const * label);\nWireResult HandleQueueCopyExternalTextureForBrowser(DeserializeBuffer* deserializeBuffer);\n\nWireResult DoQueueCopyExternalTextureForBrowser(WGPUQueue self, WGPUImageCopyExternalTexture const * source, WGPUImageCopyTexture const * destination, WGPUExtent3D const * copySize, WGPUCopyTextureForBrowserOptions const * options);\nWireResult HandleQueueCopyTextureForBrowser(DeserializeBuffer* deserializeBuffer);\n\nWireResult DoQueueCopyTextureForBrowser(WGPUQueue self, WGPUImageCopyTexture const * source, WGPUImageCopyTexture const * destination, WGPUExtent3D const * copySize, WGPUCopyTextureForBrowserOptions const * options);\nWireResult HandleQueueOnSubmittedWorkDone(DeserializeBuffer* deserializeBuffer);\n\nWireResult DoQueueOnSubmittedWorkDone(Known<WGPUQueue> queueId, uint64_t signalValue, uint64_t requestSerial);\nWireResult HandleQueueSetLabel(DeserializeBuffer* deserializeBuffer);\n\nWireResult DoQueueSetLabel(WGPUQueue self, char const * label);\nWireResult HandleQueueSubmit(DeserializeBuffer* deserializeBuffer);\n\nWireResult DoQueueSubmit(WGPUQueue self, size_t commandCount, WGPUCommandBuffer const * commands);\nWireResult HandleQueueWriteBuffer(DeserializeBuffer* deserializeBuffer);\n\nWireResult DoQueueWriteBuffer(Known<WGPUQueue> queueId, Known<WGPUBuffer> bufferId, uint64_t bufferOffset, uint8_t const * data, uint64_t size);\nWireResult HandleQueueWriteTexture(DeserializeBuffer* deserializeBuffer);\n\nWireResult DoQueueWriteTexture(Known<WGPUQueue> queueId, WGPUImageCopyTexture const * destination, uint8_t const * data, uint64_t dataSize, WGPUTextureDataLayout const * dataLayout, WGPUExtent3D const * writeSize);\nWireResult HandleRenderBundleEncoderDraw(DeserializeBuffer* deserializeBuffer);\n\nWireResult DoRenderBundleEncoderDraw(WGPURenderBundleEncoder self, uint32_t vertexCount, uint32_t instanceCount, uint32_t firstVertex, uint32_t firstInstance);\nWireResult HandleRenderBundleEncoderDrawIndexed(DeserializeBuffer* deserializeBuffer);\n\nWireResult DoRenderBundleEncoderDrawIndexed(WGPURenderBundleEncoder self, uint32_t indexCount, uint32_t instanceCount, uint32_t firstIndex, int32_t baseVertex, uint32_t firstInstance);\nWireResult HandleRenderBundleEncoderDrawIndexedIndirect(DeserializeBuffer* deserializeBuffer);\n\nWireResult DoRenderBundleEncoderDrawIndexedIndirect(WGPURenderBundleEncoder self, WGPUBuffer indirectBuffer, uint64_t indirectOffset);\nWireResult HandleRenderBundleEncoderDrawIndirect(DeserializeBuffer* deserializeBuffer);\n\nWireResult DoRenderBundleEncoderDrawIndirect(WGPURenderBundleEncoder self, WGPUBuffer indirectBuffer, uint64_t indirectOffset);\nWireResult HandleRenderBundleEncoderFinish(DeserializeBuffer* deserializeBuffer);\n\nWireResult DoRenderBundleEncoderFinish(WGPURenderBundleEncoder self, WGPURenderBundleDescriptor const * descriptor, WGPURenderBundle* result);\nWireResult HandleRenderBundleEncoderInsertDebugMarker(DeserializeBuffer* deserializeBuffer);\n\nWireResult DoRenderBundleEncoderInsertDebugMarker(WGPURenderBundleEncoder self, char const * markerLabel);\nWireResult HandleRenderBundleEncoderPopDebugGroup(DeserializeBuffer* deserializeBuffer);\n\nWireResult DoRenderBundleEncoderPopDebugGroup(WGPURenderBundleEncoder self);\nWireResult HandleRenderBundleEncoderPushDebugGroup(DeserializeBuffer* deserializeBuffer);\n\nWireResult DoRenderBundleEncoderPushDebugGroup(WGPURenderBundleEncoder self, char const * groupLabel);\nWireResult HandleRenderBundleEncoderSetBindGroup(DeserializeBuffer* deserializeBuffer);\n\nWireResult DoRenderBundleEncoderSetBindGroup(WGPURenderBundleEncoder self, uint32_t groupIndex, WGPUBindGroup group, size_t dynamicOffsetCount, uint32_t const * dynamicOffsets);\nWireResult HandleRenderBundleEncoderSetIndexBuffer(DeserializeBuffer* deserializeBuffer);\n\nWireResult DoRenderBundleEncoderSetIndexBuffer(WGPURenderBundleEncoder self, WGPUBuffer buffer, WGPUIndexFormat format, uint64_t offset, uint64_t size);\nWireResult HandleRenderBundleEncoderSetLabel(DeserializeBuffer* deserializeBuffer);\n\nWireResult DoRenderBundleEncoderSetLabel(WGPURenderBundleEncoder self, char const * label);\nWireResult HandleRenderBundleEncoderSetPipeline(DeserializeBuffer* deserializeBuffer);\n\nWireResult DoRenderBundleEncoderSetPipeline(WGPURenderBundleEncoder self, WGPURenderPipeline pipeline);\nWireResult HandleRenderBundleEncoderSetVertexBuffer(DeserializeBuffer* deserializeBuffer);\n\nWireResult DoRenderBundleEncoderSetVertexBuffer(WGPURenderBundleEncoder self, uint32_t slot, WGPUBuffer buffer, uint64_t offset, uint64_t size);\nWireResult HandleRenderBundleSetLabel(DeserializeBuffer* deserializeBuffer);\n\nWireResult DoRenderBundleSetLabel(WGPURenderBundle self, char const * label);\nWireResult HandleRenderPassEncoderBeginOcclusionQuery(DeserializeBuffer* deserializeBuffer);\n\nWireResult DoRenderPassEncoderBeginOcclusionQuery(WGPURenderPassEncoder self, uint32_t queryIndex);\nWireResult HandleRenderPassEncoderDraw(DeserializeBuffer* deserializeBuffer);\n\nWireResult DoRenderPassEncoderDraw(WGPURenderPassEncoder self, uint32_t vertexCount, uint32_t instanceCount, uint32_t firstVertex, uint32_t firstInstance);\nWireResult HandleRenderPassEncoderDrawIndexed(DeserializeBuffer* deserializeBuffer);\n\nWireResult DoRenderPassEncoderDrawIndexed(WGPURenderPassEncoder self, uint32_t indexCount, uint32_t instanceCount, uint32_t firstIndex, int32_t baseVertex, uint32_t firstInstance);\nWireResult HandleRenderPassEncoderDrawIndexedIndirect(DeserializeBuffer* deserializeBuffer);\n\nWireResult DoRenderPassEncoderDrawIndexedIndirect(WGPURenderPassEncoder self, WGPUBuffer indirectBuffer, uint64_t indirectOffset);\nWireResult HandleRenderPassEncoderDrawIndirect(DeserializeBuffer* deserializeBuffer);\n\nWireResult DoRenderPassEncoderDrawIndirect(WGPURenderPassEncoder self, WGPUBuffer indirectBuffer, uint64_t indirectOffset);\nWireResult HandleRenderPassEncoderEnd(DeserializeBuffer* deserializeBuffer);\n\nWireResult DoRenderPassEncoderEnd(WGPURenderPassEncoder self);\nWireResult HandleRenderPassEncoderEndOcclusionQuery(DeserializeBuffer* deserializeBuffer);\n\nWireResult DoRenderPassEncoderEndOcclusionQuery(WGPURenderPassEncoder self);\nWireResult HandleRenderPassEncoderExecuteBundles(DeserializeBuffer* deserializeBuffer);\n\nWireResult DoRenderPassEncoderExecuteBundles(WGPURenderPassEncoder self, size_t bundleCount, WGPURenderBundle const * bundles);\nWireResult HandleRenderPassEncoderInsertDebugMarker(DeserializeBuffer* deserializeBuffer);\n\nWireResult DoRenderPassEncoderInsertDebugMarker(WGPURenderPassEncoder self, char const * markerLabel);\nWireResult HandleRenderPassEncoderPopDebugGroup(DeserializeBuffer* deserializeBuffer);\n\nWireResult DoRenderPassEncoderPopDebugGroup(WGPURenderPassEncoder self);\nWireResult HandleRenderPassEncoderPushDebugGroup(DeserializeBuffer* deserializeBuffer);\n\nWireResult DoRenderPassEncoderPushDebugGroup(WGPURenderPassEncoder self, char const * groupLabel);\nWireResult HandleRenderPassEncoderSetBindGroup(DeserializeBuffer* deserializeBuffer);\n\nWireResult DoRenderPassEncoderSetBindGroup(WGPURenderPassEncoder self, uint32_t groupIndex, WGPUBindGroup group, size_t dynamicOffsetCount, uint32_t const * dynamicOffsets);\nWireResult HandleRenderPassEncoderSetBlendConstant(DeserializeBuffer* deserializeBuffer);\n\nWireResult DoRenderPassEncoderSetBlendConstant(WGPURenderPassEncoder self, WGPUColor const * color);\nWireResult HandleRenderPassEncoderSetIndexBuffer(DeserializeBuffer* deserializeBuffer);\n\nWireResult DoRenderPassEncoderSetIndexBuffer(WGPURenderPassEncoder self, WGPUBuffer buffer, WGPUIndexFormat format, uint64_t offset, uint64_t size);\nWireResult HandleRenderPassEncoderSetLabel(DeserializeBuffer* deserializeBuffer);\n\nWireResult DoRenderPassEncoderSetLabel(WGPURenderPassEncoder self, char const * label);\nWireResult HandleRenderPassEncoderSetPipeline(DeserializeBuffer* deserializeBuffer);\n\nWireResult DoRenderPassEncoderSetPipeline(WGPURenderPassEncoder self, WGPURenderPipeline pipeline);\nWireResult HandleRenderPassEncoderSetScissorRect(DeserializeBuffer* deserializeBuffer);\n\nWireResult DoRenderPassEncoderSetScissorRect(WGPURenderPassEncoder self, uint32_t x, uint32_t y, uint32_t width, uint32_t height);\nWireResult HandleRenderPassEncoderSetStencilReference(DeserializeBuffer* deserializeBuffer);\n\nWireResult DoRenderPassEncoderSetStencilReference(WGPURenderPassEncoder self, uint32_t reference);\nWireResult HandleRenderPassEncoderSetVertexBuffer(DeserializeBuffer* deserializeBuffer);\n\nWireResult DoRenderPassEncoderSetVertexBuffer(WGPURenderPassEncoder self, uint32_t slot, WGPUBuffer buffer, uint64_t offset, uint64_t size);\nWireResult HandleRenderPassEncoderSetViewport(DeserializeBuffer* deserializeBuffer);\n\nWireResult DoRenderPassEncoderSetViewport(WGPURenderPassEncoder self, float x, float y, float width, float height, float minDepth, float maxDepth);\nWireResult HandleRenderPassEncoderWriteTimestamp(DeserializeBuffer* deserializeBuffer);\n\nWireResult DoRenderPassEncoderWriteTimestamp(WGPURenderPassEncoder self, WGPUQuerySet querySet, uint32_t queryIndex);\nWireResult HandleRenderPipelineGetBindGroupLayout(DeserializeBuffer* deserializeBuffer);\n\nWireResult DoRenderPipelineGetBindGroupLayout(WGPURenderPipeline self, uint32_t groupIndex, WGPUBindGroupLayout* result);\nWireResult HandleRenderPipelineSetLabel(DeserializeBuffer* deserializeBuffer);\n\nWireResult DoRenderPipelineSetLabel(WGPURenderPipeline self, char const * label);\nWireResult HandleSamplerSetLabel(DeserializeBuffer* deserializeBuffer);\n\nWireResult DoSamplerSetLabel(WGPUSampler self, char const * label);\nWireResult HandleShaderModuleGetCompilationInfo(DeserializeBuffer* deserializeBuffer);\n\nWireResult DoShaderModuleGetCompilationInfo(Known<WGPUShaderModule> shaderModuleId, uint64_t requestSerial);\nWireResult HandleShaderModuleSetLabel(DeserializeBuffer* deserializeBuffer);\n\nWireResult DoShaderModuleSetLabel(WGPUShaderModule self, char const * label);\nWireResult HandleSwapChainGetCurrentTexture(DeserializeBuffer* deserializeBuffer);\n\nWireResult DoSwapChainGetCurrentTexture(WGPUSwapChain self, WGPUTexture* result);\nWireResult HandleSwapChainGetCurrentTextureView(DeserializeBuffer* deserializeBuffer);\n\nWireResult DoSwapChainGetCurrentTextureView(WGPUSwapChain self, WGPUTextureView* result);\nWireResult HandleSwapChainPresent(DeserializeBuffer* deserializeBuffer);\n\nWireResult DoSwapChainPresent(WGPUSwapChain self);\nWireResult HandleTextureCreateView(DeserializeBuffer* deserializeBuffer);\n\nWireResult DoTextureCreateView(WGPUTexture self, WGPUTextureViewDescriptor const * descriptor, WGPUTextureView* result);\nWireResult HandleTextureDestroy(DeserializeBuffer* deserializeBuffer);\n\nWireResult DoTextureDestroy(WGPUTexture self);\nWireResult HandleTextureSetLabel(DeserializeBuffer* deserializeBuffer);\n\nWireResult DoTextureSetLabel(WGPUTexture self, char const * label);\nWireResult HandleTextureViewSetLabel(DeserializeBuffer* deserializeBuffer);\n\nWireResult DoTextureViewSetLabel(WGPUTextureView self, char const * label);\n\nWireResult PreHandleBufferDestroy(const BufferDestroyCmd& cmd);\nWireResult PreHandleBufferUnmap(const BufferUnmapCmd& cmd);\n"}