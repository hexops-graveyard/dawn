{"src/dawn/wire/ObjectType_autogen.h": "\n#ifndef DAWNWIRE_OBJECTTPYE_AUTOGEN_H_\n#define DAWNWIRE_OBJECTTPYE_AUTOGEN_H_\n\n#include \"dawn/common/ityp_array.h\"\n\nnamespace dawn::wire {\n\n    enum class ObjectType : uint32_t {\n        Adapter,\n        BindGroup,\n        BindGroupLayout,\n        Buffer,\n        CommandBuffer,\n        CommandEncoder,\n        ComputePassEncoder,\n        ComputePipeline,\n        Device,\n        ExternalTexture,\n        Instance,\n        PipelineLayout,\n        QuerySet,\n        Queue,\n        RenderBundle,\n        RenderBundleEncoder,\n        RenderPassEncoder,\n        RenderPipeline,\n        Sampler,\n        ShaderModule,\n        Surface,\n        SwapChain,\n        Texture,\n        TextureView,\n    };\n\n    template <typename T>\n    using PerObjectType = ityp::array<ObjectType, T, 24>;\n\n} // namespace dawn::wire\n\n\n#endif  // DAWNWIRE_OBJECTTPYE_AUTOGEN_H_\n", "src/dawn/wire/WireCmd_autogen.h": "\n#ifndef DAWNWIRE_WIRECMD_AUTOGEN_H_\n#define DAWNWIRE_WIRECMD_AUTOGEN_H_\n\n#include \"dawn/webgpu.h\"\n\n#include \"dawn/wire/BufferConsumer.h\"\n#include \"dawn/wire/ObjectType_autogen.h\"\n#include \"dawn/wire/ObjectHandle.h\"\n#include \"dawn/wire/WireResult.h\"\n\nnamespace dawn::wire {\n\n    // Interface to allocate more space to deserialize pointed-to data.\n    // nullptr is treated as an error.\n    class DeserializeAllocator {\n        public:\n            virtual void* GetSpace(size_t size) = 0;\n    };\n\n    // Interface to convert an ID to a server object, if possible.\n    // Methods return FatalError if the ID is for a non-existent object and Success otherwise.\n    class ObjectIdResolver {\n        public:\n            virtual WireResult GetFromId(ObjectId id, WGPUAdapter* out) const = 0;\n            virtual WireResult GetOptionalFromId(ObjectId id, WGPUAdapter* out) const = 0;\n            virtual WireResult GetFromId(ObjectId id, WGPUBindGroup* out) const = 0;\n            virtual WireResult GetOptionalFromId(ObjectId id, WGPUBindGroup* out) const = 0;\n            virtual WireResult GetFromId(ObjectId id, WGPUBindGroupLayout* out) const = 0;\n            virtual WireResult GetOptionalFromId(ObjectId id, WGPUBindGroupLayout* out) const = 0;\n            virtual WireResult GetFromId(ObjectId id, WGPUBuffer* out) const = 0;\n            virtual WireResult GetOptionalFromId(ObjectId id, WGPUBuffer* out) const = 0;\n            virtual WireResult GetFromId(ObjectId id, WGPUCommandBuffer* out) const = 0;\n            virtual WireResult GetOptionalFromId(ObjectId id, WGPUCommandBuffer* out) const = 0;\n            virtual WireResult GetFromId(ObjectId id, WGPUCommandEncoder* out) const = 0;\n            virtual WireResult GetOptionalFromId(ObjectId id, WGPUCommandEncoder* out) const = 0;\n            virtual WireResult GetFromId(ObjectId id, WGPUComputePassEncoder* out) const = 0;\n            virtual WireResult GetOptionalFromId(ObjectId id, WGPUComputePassEncoder* out) const = 0;\n            virtual WireResult GetFromId(ObjectId id, WGPUComputePipeline* out) const = 0;\n            virtual WireResult GetOptionalFromId(ObjectId id, WGPUComputePipeline* out) const = 0;\n            virtual WireResult GetFromId(ObjectId id, WGPUDevice* out) const = 0;\n            virtual WireResult GetOptionalFromId(ObjectId id, WGPUDevice* out) const = 0;\n            virtual WireResult GetFromId(ObjectId id, WGPUExternalTexture* out) const = 0;\n            virtual WireResult GetOptionalFromId(ObjectId id, WGPUExternalTexture* out) const = 0;\n            virtual WireResult GetFromId(ObjectId id, WGPUInstance* out) const = 0;\n            virtual WireResult GetOptionalFromId(ObjectId id, WGPUInstance* out) const = 0;\n            virtual WireResult GetFromId(ObjectId id, WGPUPipelineLayout* out) const = 0;\n            virtual WireResult GetOptionalFromId(ObjectId id, WGPUPipelineLayout* out) const = 0;\n            virtual WireResult GetFromId(ObjectId id, WGPUQuerySet* out) const = 0;\n            virtual WireResult GetOptionalFromId(ObjectId id, WGPUQuerySet* out) const = 0;\n            virtual WireResult GetFromId(ObjectId id, WGPUQueue* out) const = 0;\n            virtual WireResult GetOptionalFromId(ObjectId id, WGPUQueue* out) const = 0;\n            virtual WireResult GetFromId(ObjectId id, WGPURenderBundle* out) const = 0;\n            virtual WireResult GetOptionalFromId(ObjectId id, WGPURenderBundle* out) const = 0;\n            virtual WireResult GetFromId(ObjectId id, WGPURenderBundleEncoder* out) const = 0;\n            virtual WireResult GetOptionalFromId(ObjectId id, WGPURenderBundleEncoder* out) const = 0;\n            virtual WireResult GetFromId(ObjectId id, WGPURenderPassEncoder* out) const = 0;\n            virtual WireResult GetOptionalFromId(ObjectId id, WGPURenderPassEncoder* out) const = 0;\n            virtual WireResult GetFromId(ObjectId id, WGPURenderPipeline* out) const = 0;\n            virtual WireResult GetOptionalFromId(ObjectId id, WGPURenderPipeline* out) const = 0;\n            virtual WireResult GetFromId(ObjectId id, WGPUSampler* out) const = 0;\n            virtual WireResult GetOptionalFromId(ObjectId id, WGPUSampler* out) const = 0;\n            virtual WireResult GetFromId(ObjectId id, WGPUShaderModule* out) const = 0;\n            virtual WireResult GetOptionalFromId(ObjectId id, WGPUShaderModule* out) const = 0;\n            virtual WireResult GetFromId(ObjectId id, WGPUSurface* out) const = 0;\n            virtual WireResult GetOptionalFromId(ObjectId id, WGPUSurface* out) const = 0;\n            virtual WireResult GetFromId(ObjectId id, WGPUSwapChain* out) const = 0;\n            virtual WireResult GetOptionalFromId(ObjectId id, WGPUSwapChain* out) const = 0;\n            virtual WireResult GetFromId(ObjectId id, WGPUTexture* out) const = 0;\n            virtual WireResult GetOptionalFromId(ObjectId id, WGPUTexture* out) const = 0;\n            virtual WireResult GetFromId(ObjectId id, WGPUTextureView* out) const = 0;\n            virtual WireResult GetOptionalFromId(ObjectId id, WGPUTextureView* out) const = 0;\n    };\n\n    // Interface to convert a client object to its ID for the wiring.\n    class ObjectIdProvider {\n        public:\n            virtual WireResult GetId(WGPUAdapter object, ObjectId* out) const = 0;\n            virtual WireResult GetOptionalId(WGPUAdapter object, ObjectId* out) const = 0;\n            virtual WireResult GetId(WGPUBindGroup object, ObjectId* out) const = 0;\n            virtual WireResult GetOptionalId(WGPUBindGroup object, ObjectId* out) const = 0;\n            virtual WireResult GetId(WGPUBindGroupLayout object, ObjectId* out) const = 0;\n            virtual WireResult GetOptionalId(WGPUBindGroupLayout object, ObjectId* out) const = 0;\n            virtual WireResult GetId(WGPUBuffer object, ObjectId* out) const = 0;\n            virtual WireResult GetOptionalId(WGPUBuffer object, ObjectId* out) const = 0;\n            virtual WireResult GetId(WGPUCommandBuffer object, ObjectId* out) const = 0;\n            virtual WireResult GetOptionalId(WGPUCommandBuffer object, ObjectId* out) const = 0;\n            virtual WireResult GetId(WGPUCommandEncoder object, ObjectId* out) const = 0;\n            virtual WireResult GetOptionalId(WGPUCommandEncoder object, ObjectId* out) const = 0;\n            virtual WireResult GetId(WGPUComputePassEncoder object, ObjectId* out) const = 0;\n            virtual WireResult GetOptionalId(WGPUComputePassEncoder object, ObjectId* out) const = 0;\n            virtual WireResult GetId(WGPUComputePipeline object, ObjectId* out) const = 0;\n            virtual WireResult GetOptionalId(WGPUComputePipeline object, ObjectId* out) const = 0;\n            virtual WireResult GetId(WGPUDevice object, ObjectId* out) const = 0;\n            virtual WireResult GetOptionalId(WGPUDevice object, ObjectId* out) const = 0;\n            virtual WireResult GetId(WGPUExternalTexture object, ObjectId* out) const = 0;\n            virtual WireResult GetOptionalId(WGPUExternalTexture object, ObjectId* out) const = 0;\n            virtual WireResult GetId(WGPUInstance object, ObjectId* out) const = 0;\n            virtual WireResult GetOptionalId(WGPUInstance object, ObjectId* out) const = 0;\n            virtual WireResult GetId(WGPUPipelineLayout object, ObjectId* out) const = 0;\n            virtual WireResult GetOptionalId(WGPUPipelineLayout object, ObjectId* out) const = 0;\n            virtual WireResult GetId(WGPUQuerySet object, ObjectId* out) const = 0;\n            virtual WireResult GetOptionalId(WGPUQuerySet object, ObjectId* out) const = 0;\n            virtual WireResult GetId(WGPUQueue object, ObjectId* out) const = 0;\n            virtual WireResult GetOptionalId(WGPUQueue object, ObjectId* out) const = 0;\n            virtual WireResult GetId(WGPURenderBundle object, ObjectId* out) const = 0;\n            virtual WireResult GetOptionalId(WGPURenderBundle object, ObjectId* out) const = 0;\n            virtual WireResult GetId(WGPURenderBundleEncoder object, ObjectId* out) const = 0;\n            virtual WireResult GetOptionalId(WGPURenderBundleEncoder object, ObjectId* out) const = 0;\n            virtual WireResult GetId(WGPURenderPassEncoder object, ObjectId* out) const = 0;\n            virtual WireResult GetOptionalId(WGPURenderPassEncoder object, ObjectId* out) const = 0;\n            virtual WireResult GetId(WGPURenderPipeline object, ObjectId* out) const = 0;\n            virtual WireResult GetOptionalId(WGPURenderPipeline object, ObjectId* out) const = 0;\n            virtual WireResult GetId(WGPUSampler object, ObjectId* out) const = 0;\n            virtual WireResult GetOptionalId(WGPUSampler object, ObjectId* out) const = 0;\n            virtual WireResult GetId(WGPUShaderModule object, ObjectId* out) const = 0;\n            virtual WireResult GetOptionalId(WGPUShaderModule object, ObjectId* out) const = 0;\n            virtual WireResult GetId(WGPUSurface object, ObjectId* out) const = 0;\n            virtual WireResult GetOptionalId(WGPUSurface object, ObjectId* out) const = 0;\n            virtual WireResult GetId(WGPUSwapChain object, ObjectId* out) const = 0;\n            virtual WireResult GetOptionalId(WGPUSwapChain object, ObjectId* out) const = 0;\n            virtual WireResult GetId(WGPUTexture object, ObjectId* out) const = 0;\n            virtual WireResult GetOptionalId(WGPUTexture object, ObjectId* out) const = 0;\n            virtual WireResult GetId(WGPUTextureView object, ObjectId* out) const = 0;\n            virtual WireResult GetOptionalId(WGPUTextureView object, ObjectId* out) const = 0;\n    };\n\n    enum class WireCmd : uint32_t {\n        AdapterRequestDevice,\n        BindGroupLayoutSetLabel,\n        BindGroupSetLabel,\n        BufferDestroy,\n        BufferMapAsync,\n        BufferSetLabel,\n        BufferUnmap,\n        BufferUpdateMappedData,\n        CommandBufferSetLabel,\n        CommandEncoderBeginComputePass,\n        CommandEncoderBeginRenderPass,\n        CommandEncoderClearBuffer,\n        CommandEncoderCopyBufferToBuffer,\n        CommandEncoderCopyBufferToTexture,\n        CommandEncoderCopyTextureToBuffer,\n        CommandEncoderCopyTextureToTexture,\n        CommandEncoderCopyTextureToTextureInternal,\n        CommandEncoderFinish,\n        CommandEncoderInjectValidationError,\n        CommandEncoderInsertDebugMarker,\n        CommandEncoderPopDebugGroup,\n        CommandEncoderPushDebugGroup,\n        CommandEncoderResolveQuerySet,\n        CommandEncoderSetLabel,\n        CommandEncoderWriteBuffer,\n        CommandEncoderWriteTimestamp,\n        ComputePassEncoderDispatch,\n        ComputePassEncoderDispatchIndirect,\n        ComputePassEncoderDispatchWorkgroups,\n        ComputePassEncoderDispatchWorkgroupsIndirect,\n        ComputePassEncoderEnd,\n        ComputePassEncoderEndPass,\n        ComputePassEncoderInsertDebugMarker,\n        ComputePassEncoderPopDebugGroup,\n        ComputePassEncoderPushDebugGroup,\n        ComputePassEncoderSetBindGroup,\n        ComputePassEncoderSetLabel,\n        ComputePassEncoderSetPipeline,\n        ComputePassEncoderWriteTimestamp,\n        ComputePipelineGetBindGroupLayout,\n        ComputePipelineSetLabel,\n        DestroyObject,\n        DeviceCreateBindGroup,\n        DeviceCreateBindGroupLayout,\n        DeviceCreateBuffer,\n        DeviceCreateCommandEncoder,\n        DeviceCreateComputePipeline,\n        DeviceCreateComputePipelineAsync,\n        DeviceCreateErrorBuffer,\n        DeviceCreateErrorExternalTexture,\n        DeviceCreateErrorTexture,\n        DeviceCreateExternalTexture,\n        DeviceCreatePipelineLayout,\n        DeviceCreateQuerySet,\n        DeviceCreateRenderBundleEncoder,\n        DeviceCreateRenderPipeline,\n        DeviceCreateRenderPipelineAsync,\n        DeviceCreateSampler,\n        DeviceCreateShaderModule,\n        DeviceCreateSwapChain,\n        DeviceCreateTexture,\n        DeviceDestroy,\n        DeviceGetQueue,\n        DeviceInjectError,\n        DeviceLoseForTesting,\n        DevicePopErrorScope,\n        DevicePushErrorScope,\n        DeviceSetLabel,\n        DeviceTick,\n        ExternalTextureDestroy,\n        ExternalTextureSetLabel,\n        InstanceCreateSurface,\n        InstanceRequestAdapter,\n        PipelineLayoutSetLabel,\n        QuerySetDestroy,\n        QuerySetSetLabel,\n        QueueCopyTextureForBrowser,\n        QueueOnSubmittedWorkDone,\n        QueueSetLabel,\n        QueueSubmit,\n        QueueWriteBuffer,\n        QueueWriteTexture,\n        RenderBundleEncoderDraw,\n        RenderBundleEncoderDrawIndexed,\n        RenderBundleEncoderDrawIndexedIndirect,\n        RenderBundleEncoderDrawIndirect,\n        RenderBundleEncoderFinish,\n        RenderBundleEncoderInsertDebugMarker,\n        RenderBundleEncoderPopDebugGroup,\n        RenderBundleEncoderPushDebugGroup,\n        RenderBundleEncoderSetBindGroup,\n        RenderBundleEncoderSetIndexBuffer,\n        RenderBundleEncoderSetLabel,\n        RenderBundleEncoderSetPipeline,\n        RenderBundleEncoderSetVertexBuffer,\n        RenderPassEncoderBeginOcclusionQuery,\n        RenderPassEncoderDraw,\n        RenderPassEncoderDrawIndexed,\n        RenderPassEncoderDrawIndexedIndirect,\n        RenderPassEncoderDrawIndirect,\n        RenderPassEncoderEnd,\n        RenderPassEncoderEndOcclusionQuery,\n        RenderPassEncoderEndPass,\n        RenderPassEncoderExecuteBundles,\n        RenderPassEncoderInsertDebugMarker,\n        RenderPassEncoderPopDebugGroup,\n        RenderPassEncoderPushDebugGroup,\n        RenderPassEncoderSetBindGroup,\n        RenderPassEncoderSetBlendConstant,\n        RenderPassEncoderSetIndexBuffer,\n        RenderPassEncoderSetLabel,\n        RenderPassEncoderSetPipeline,\n        RenderPassEncoderSetScissorRect,\n        RenderPassEncoderSetStencilReference,\n        RenderPassEncoderSetVertexBuffer,\n        RenderPassEncoderSetViewport,\n        RenderPassEncoderWriteTimestamp,\n        RenderPipelineGetBindGroupLayout,\n        RenderPipelineSetLabel,\n        SamplerSetLabel,\n        ShaderModuleGetCompilationInfo,\n        ShaderModuleSetLabel,\n        SwapChainConfigure,\n        SwapChainGetCurrentTextureView,\n        SwapChainPresent,\n        TextureCreateView,\n        TextureDestroy,\n        TextureSetLabel,\n        TextureViewSetLabel,\n    };\n\n    enum class ReturnWireCmd : uint32_t {\n        AdapterRequestDeviceCallback,\n        BufferMapAsyncCallback,\n        DeviceCreateComputePipelineAsyncCallback,\n        DeviceCreateRenderPipelineAsyncCallback,\n        DeviceLoggingCallback,\n        DeviceLostCallback,\n        DevicePopErrorScopeCallback,\n        DeviceUncapturedErrorCallback,\n        InstanceRequestAdapterCallback,\n        QueueWorkDoneCallback,\n        ShaderModuleGetCompilationInfoCallback,\n    };\n\n    struct CmdHeader {\n        uint64_t commandSize;\n    };\n\n\n    struct AdapterRequestDeviceCmd {\n    size_t GetRequiredSize() const;\n\n    WireResult Serialize(size_t commandSize, SerializeBuffer* serializeBuffer, const ObjectIdProvider& objectIdProvider) const;\n    // Override which produces a FatalError if any object is used.\n    WireResult Serialize(size_t commandSize, SerializeBuffer* serializeBuffer) const;\n\n    WireResult Deserialize(DeserializeBuffer* deserializeBuffer, DeserializeAllocator* allocator, const ObjectIdResolver& resolver);\n    // Override which produces a FatalError if any object is used.\n    WireResult Deserialize(DeserializeBuffer* deserializeBuffer, DeserializeAllocator* allocator);\n\n\n    ObjectId adapterId;\n    uint64_t requestSerial;\n    ObjectHandle deviceObjectHandle;\n    WGPUDeviceDescriptor const * descriptor;\n};\n\n    struct BindGroupLayoutSetLabelCmd {\n    size_t GetRequiredSize() const;\n\n    WireResult Serialize(size_t commandSize, SerializeBuffer* serializeBuffer, const ObjectIdProvider& objectIdProvider) const;\n    // Override which produces a FatalError if any object is used.\n    WireResult Serialize(size_t commandSize, SerializeBuffer* serializeBuffer) const;\n\n    WireResult Deserialize(DeserializeBuffer* deserializeBuffer, DeserializeAllocator* allocator, const ObjectIdResolver& resolver);\n    // Override which produces a FatalError if any object is used.\n    WireResult Deserialize(DeserializeBuffer* deserializeBuffer, DeserializeAllocator* allocator);\n\n    ObjectId selfId;\n\n    WGPUBindGroupLayout self;\n    char const * label;\n};\n\n    struct BindGroupSetLabelCmd {\n    size_t GetRequiredSize() const;\n\n    WireResult Serialize(size_t commandSize, SerializeBuffer* serializeBuffer, const ObjectIdProvider& objectIdProvider) const;\n    // Override which produces a FatalError if any object is used.\n    WireResult Serialize(size_t commandSize, SerializeBuffer* serializeBuffer) const;\n\n    WireResult Deserialize(DeserializeBuffer* deserializeBuffer, DeserializeAllocator* allocator, const ObjectIdResolver& resolver);\n    // Override which produces a FatalError if any object is used.\n    WireResult Deserialize(DeserializeBuffer* deserializeBuffer, DeserializeAllocator* allocator);\n\n    ObjectId selfId;\n\n    WGPUBindGroup self;\n    char const * label;\n};\n\n    struct BufferDestroyCmd {\n    size_t GetRequiredSize() const;\n\n    WireResult Serialize(size_t commandSize, SerializeBuffer* serializeBuffer, const ObjectIdProvider& objectIdProvider) const;\n    // Override which produces a FatalError if any object is used.\n    WireResult Serialize(size_t commandSize, SerializeBuffer* serializeBuffer) const;\n\n    WireResult Deserialize(DeserializeBuffer* deserializeBuffer, DeserializeAllocator* allocator, const ObjectIdResolver& resolver);\n    // Override which produces a FatalError if any object is used.\n    WireResult Deserialize(DeserializeBuffer* deserializeBuffer, DeserializeAllocator* allocator);\n\n    ObjectId selfId;\n\n    WGPUBuffer self;\n};\n\n    struct BufferMapAsyncCmd {\n    size_t GetRequiredSize() const;\n\n    WireResult Serialize(size_t commandSize, SerializeBuffer* serializeBuffer, const ObjectIdProvider& objectIdProvider) const;\n    // Override which produces a FatalError if any object is used.\n    WireResult Serialize(size_t commandSize, SerializeBuffer* serializeBuffer) const;\n\n    WireResult Deserialize(DeserializeBuffer* deserializeBuffer, DeserializeAllocator* allocator, const ObjectIdResolver& resolver);\n    // Override which produces a FatalError if any object is used.\n    WireResult Deserialize(DeserializeBuffer* deserializeBuffer, DeserializeAllocator* allocator);\n\n\n    ObjectId bufferId;\n    uint64_t requestSerial;\n    WGPUMapModeFlags mode;\n    uint64_t offset;\n    uint64_t size;\n};\n\n    struct BufferSetLabelCmd {\n    size_t GetRequiredSize() const;\n\n    WireResult Serialize(size_t commandSize, SerializeBuffer* serializeBuffer, const ObjectIdProvider& objectIdProvider) const;\n    // Override which produces a FatalError if any object is used.\n    WireResult Serialize(size_t commandSize, SerializeBuffer* serializeBuffer) const;\n\n    WireResult Deserialize(DeserializeBuffer* deserializeBuffer, DeserializeAllocator* allocator, const ObjectIdResolver& resolver);\n    // Override which produces a FatalError if any object is used.\n    WireResult Deserialize(DeserializeBuffer* deserializeBuffer, DeserializeAllocator* allocator);\n\n    ObjectId selfId;\n\n    WGPUBuffer self;\n    char const * label;\n};\n\n    struct BufferUnmapCmd {\n    size_t GetRequiredSize() const;\n\n    WireResult Serialize(size_t commandSize, SerializeBuffer* serializeBuffer, const ObjectIdProvider& objectIdProvider) const;\n    // Override which produces a FatalError if any object is used.\n    WireResult Serialize(size_t commandSize, SerializeBuffer* serializeBuffer) const;\n\n    WireResult Deserialize(DeserializeBuffer* deserializeBuffer, DeserializeAllocator* allocator, const ObjectIdResolver& resolver);\n    // Override which produces a FatalError if any object is used.\n    WireResult Deserialize(DeserializeBuffer* deserializeBuffer, DeserializeAllocator* allocator);\n\n    ObjectId selfId;\n\n    WGPUBuffer self;\n};\n\n    struct BufferUpdateMappedDataCmd {\n    size_t GetRequiredSize() const;\n\n    WireResult Serialize(size_t commandSize, SerializeBuffer* serializeBuffer, const ObjectIdProvider& objectIdProvider) const;\n    // Override which produces a FatalError if any object is used.\n    WireResult Serialize(size_t commandSize, SerializeBuffer* serializeBuffer) const;\n\n    WireResult Deserialize(DeserializeBuffer* deserializeBuffer, DeserializeAllocator* allocator, const ObjectIdResolver& resolver);\n    // Override which produces a FatalError if any object is used.\n    WireResult Deserialize(DeserializeBuffer* deserializeBuffer, DeserializeAllocator* allocator);\n\n\n    ObjectId bufferId;\n    uint64_t writeDataUpdateInfoLength;\n    uint8_t const * writeDataUpdateInfo;\n    uint64_t offset;\n    uint64_t size;\n};\n\n    struct CommandBufferSetLabelCmd {\n    size_t GetRequiredSize() const;\n\n    WireResult Serialize(size_t commandSize, SerializeBuffer* serializeBuffer, const ObjectIdProvider& objectIdProvider) const;\n    // Override which produces a FatalError if any object is used.\n    WireResult Serialize(size_t commandSize, SerializeBuffer* serializeBuffer) const;\n\n    WireResult Deserialize(DeserializeBuffer* deserializeBuffer, DeserializeAllocator* allocator, const ObjectIdResolver& resolver);\n    // Override which produces a FatalError if any object is used.\n    WireResult Deserialize(DeserializeBuffer* deserializeBuffer, DeserializeAllocator* allocator);\n\n    ObjectId selfId;\n\n    WGPUCommandBuffer self;\n    char const * label;\n};\n\n    struct CommandEncoderBeginComputePassCmd {\n    size_t GetRequiredSize() const;\n\n    WireResult Serialize(size_t commandSize, SerializeBuffer* serializeBuffer, const ObjectIdProvider& objectIdProvider) const;\n    // Override which produces a FatalError if any object is used.\n    WireResult Serialize(size_t commandSize, SerializeBuffer* serializeBuffer) const;\n\n    WireResult Deserialize(DeserializeBuffer* deserializeBuffer, DeserializeAllocator* allocator, const ObjectIdResolver& resolver);\n    // Override which produces a FatalError if any object is used.\n    WireResult Deserialize(DeserializeBuffer* deserializeBuffer, DeserializeAllocator* allocator);\n\n    ObjectId selfId;\n\n    WGPUCommandEncoder self;\n    WGPUComputePassDescriptor const * descriptor;\n    ObjectHandle result;\n};\n\n    struct CommandEncoderBeginRenderPassCmd {\n    size_t GetRequiredSize() const;\n\n    WireResult Serialize(size_t commandSize, SerializeBuffer* serializeBuffer, const ObjectIdProvider& objectIdProvider) const;\n    // Override which produces a FatalError if any object is used.\n    WireResult Serialize(size_t commandSize, SerializeBuffer* serializeBuffer) const;\n\n    WireResult Deserialize(DeserializeBuffer* deserializeBuffer, DeserializeAllocator* allocator, const ObjectIdResolver& resolver);\n    // Override which produces a FatalError if any object is used.\n    WireResult Deserialize(DeserializeBuffer* deserializeBuffer, DeserializeAllocator* allocator);\n\n    ObjectId selfId;\n\n    WGPUCommandEncoder self;\n    WGPURenderPassDescriptor const * descriptor;\n    ObjectHandle result;\n};\n\n    struct CommandEncoderClearBufferCmd {\n    size_t GetRequiredSize() const;\n\n    WireResult Serialize(size_t commandSize, SerializeBuffer* serializeBuffer, const ObjectIdProvider& objectIdProvider) const;\n    // Override which produces a FatalError if any object is used.\n    WireResult Serialize(size_t commandSize, SerializeBuffer* serializeBuffer) const;\n\n    WireResult Deserialize(DeserializeBuffer* deserializeBuffer, DeserializeAllocator* allocator, const ObjectIdResolver& resolver);\n    // Override which produces a FatalError if any object is used.\n    WireResult Deserialize(DeserializeBuffer* deserializeBuffer, DeserializeAllocator* allocator);\n\n    ObjectId selfId;\n\n    WGPUCommandEncoder self;\n    WGPUBuffer buffer;\n    uint64_t offset;\n    uint64_t size;\n};\n\n    struct CommandEncoderCopyBufferToBufferCmd {\n    size_t GetRequiredSize() const;\n\n    WireResult Serialize(size_t commandSize, SerializeBuffer* serializeBuffer, const ObjectIdProvider& objectIdProvider) const;\n    // Override which produces a FatalError if any object is used.\n    WireResult Serialize(size_t commandSize, SerializeBuffer* serializeBuffer) const;\n\n    WireResult Deserialize(DeserializeBuffer* deserializeBuffer, DeserializeAllocator* allocator, const ObjectIdResolver& resolver);\n    // Override which produces a FatalError if any object is used.\n    WireResult Deserialize(DeserializeBuffer* deserializeBuffer, DeserializeAllocator* allocator);\n\n    ObjectId selfId;\n\n    WGPUCommandEncoder self;\n    WGPUBuffer source;\n    uint64_t sourceOffset;\n    WGPUBuffer destination;\n    uint64_t destinationOffset;\n    uint64_t size;\n};\n\n    struct CommandEncoderCopyBufferToTextureCmd {\n    size_t GetRequiredSize() const;\n\n    WireResult Serialize(size_t commandSize, SerializeBuffer* serializeBuffer, const ObjectIdProvider& objectIdProvider) const;\n    // Override which produces a FatalError if any object is used.\n    WireResult Serialize(size_t commandSize, SerializeBuffer* serializeBuffer) const;\n\n    WireResult Deserialize(DeserializeBuffer* deserializeBuffer, DeserializeAllocator* allocator, const ObjectIdResolver& resolver);\n    // Override which produces a FatalError if any object is used.\n    WireResult Deserialize(DeserializeBuffer* deserializeBuffer, DeserializeAllocator* allocator);\n\n    ObjectId selfId;\n\n    WGPUCommandEncoder self;\n    WGPUImageCopyBuffer const * source;\n    WGPUImageCopyTexture const * destination;\n    WGPUExtent3D const * copySize;\n};\n\n    struct CommandEncoderCopyTextureToBufferCmd {\n    size_t GetRequiredSize() const;\n\n    WireResult Serialize(size_t commandSize, SerializeBuffer* serializeBuffer, const ObjectIdProvider& objectIdProvider) const;\n    // Override which produces a FatalError if any object is used.\n    WireResult Serialize(size_t commandSize, SerializeBuffer* serializeBuffer) const;\n\n    WireResult Deserialize(DeserializeBuffer* deserializeBuffer, DeserializeAllocator* allocator, const ObjectIdResolver& resolver);\n    // Override which produces a FatalError if any object is used.\n    WireResult Deserialize(DeserializeBuffer* deserializeBuffer, DeserializeAllocator* allocator);\n\n    ObjectId selfId;\n\n    WGPUCommandEncoder self;\n    WGPUImageCopyTexture const * source;\n    WGPUImageCopyBuffer const * destination;\n    WGPUExtent3D const * copySize;\n};\n\n    struct CommandEncoderCopyTextureToTextureCmd {\n    size_t GetRequiredSize() const;\n\n    WireResult Serialize(size_t commandSize, SerializeBuffer* serializeBuffer, const ObjectIdProvider& objectIdProvider) const;\n    // Override which produces a FatalError if any object is used.\n    WireResult Serialize(size_t commandSize, SerializeBuffer* serializeBuffer) const;\n\n    WireResult Deserialize(DeserializeBuffer* deserializeBuffer, DeserializeAllocator* allocator, const ObjectIdResolver& resolver);\n    // Override which produces a FatalError if any object is used.\n    WireResult Deserialize(DeserializeBuffer* deserializeBuffer, DeserializeAllocator* allocator);\n\n    ObjectId selfId;\n\n    WGPUCommandEncoder self;\n    WGPUImageCopyTexture const * source;\n    WGPUImageCopyTexture const * destination;\n    WGPUExtent3D const * copySize;\n};\n\n    struct CommandEncoderCopyTextureToTextureInternalCmd {\n    size_t GetRequiredSize() const;\n\n    WireResult Serialize(size_t commandSize, SerializeBuffer* serializeBuffer, const ObjectIdProvider& objectIdProvider) const;\n    // Override which produces a FatalError if any object is used.\n    WireResult Serialize(size_t commandSize, SerializeBuffer* serializeBuffer) const;\n\n    WireResult Deserialize(DeserializeBuffer* deserializeBuffer, DeserializeAllocator* allocator, const ObjectIdResolver& resolver);\n    // Override which produces a FatalError if any object is used.\n    WireResult Deserialize(DeserializeBuffer* deserializeBuffer, DeserializeAllocator* allocator);\n\n    ObjectId selfId;\n\n    WGPUCommandEncoder self;\n    WGPUImageCopyTexture const * source;\n    WGPUImageCopyTexture const * destination;\n    WGPUExtent3D const * copySize;\n};\n\n    struct CommandEncoderFinishCmd {\n    size_t GetRequiredSize() const;\n\n    WireResult Serialize(size_t commandSize, SerializeBuffer* serializeBuffer, const ObjectIdProvider& objectIdProvider) const;\n    // Override which produces a FatalError if any object is used.\n    WireResult Serialize(size_t commandSize, SerializeBuffer* serializeBuffer) const;\n\n    WireResult Deserialize(DeserializeBuffer* deserializeBuffer, DeserializeAllocator* allocator, const ObjectIdResolver& resolver);\n    // Override which produces a FatalError if any object is used.\n    WireResult Deserialize(DeserializeBuffer* deserializeBuffer, DeserializeAllocator* allocator);\n\n    ObjectId selfId;\n\n    WGPUCommandEncoder self;\n    WGPUCommandBufferDescriptor const * descriptor;\n    ObjectHandle result;\n};\n\n    struct CommandEncoderInjectValidationErrorCmd {\n    size_t GetRequiredSize() const;\n\n    WireResult Serialize(size_t commandSize, SerializeBuffer* serializeBuffer, const ObjectIdProvider& objectIdProvider) const;\n    // Override which produces a FatalError if any object is used.\n    WireResult Serialize(size_t commandSize, SerializeBuffer* serializeBuffer) const;\n\n    WireResult Deserialize(DeserializeBuffer* deserializeBuffer, DeserializeAllocator* allocator, const ObjectIdResolver& resolver);\n    // Override which produces a FatalError if any object is used.\n    WireResult Deserialize(DeserializeBuffer* deserializeBuffer, DeserializeAllocator* allocator);\n\n    ObjectId selfId;\n\n    WGPUCommandEncoder self;\n    char const * message;\n};\n\n    struct CommandEncoderInsertDebugMarkerCmd {\n    size_t GetRequiredSize() const;\n\n    WireResult Serialize(size_t commandSize, SerializeBuffer* serializeBuffer, const ObjectIdProvider& objectIdProvider) const;\n    // Override which produces a FatalError if any object is used.\n    WireResult Serialize(size_t commandSize, SerializeBuffer* serializeBuffer) const;\n\n    WireResult Deserialize(DeserializeBuffer* deserializeBuffer, DeserializeAllocator* allocator, const ObjectIdResolver& resolver);\n    // Override which produces a FatalError if any object is used.\n    WireResult Deserialize(DeserializeBuffer* deserializeBuffer, DeserializeAllocator* allocator);\n\n    ObjectId selfId;\n\n    WGPUCommandEncoder self;\n    char const * markerLabel;\n};\n\n    struct CommandEncoderPopDebugGroupCmd {\n    size_t GetRequiredSize() const;\n\n    WireResult Serialize(size_t commandSize, SerializeBuffer* serializeBuffer, const ObjectIdProvider& objectIdProvider) const;\n    // Override which produces a FatalError if any object is used.\n    WireResult Serialize(size_t commandSize, SerializeBuffer* serializeBuffer) const;\n\n    WireResult Deserialize(DeserializeBuffer* deserializeBuffer, DeserializeAllocator* allocator, const ObjectIdResolver& resolver);\n    // Override which produces a FatalError if any object is used.\n    WireResult Deserialize(DeserializeBuffer* deserializeBuffer, DeserializeAllocator* allocator);\n\n    ObjectId selfId;\n\n    WGPUCommandEncoder self;\n};\n\n    struct CommandEncoderPushDebugGroupCmd {\n    size_t GetRequiredSize() const;\n\n    WireResult Serialize(size_t commandSize, SerializeBuffer* serializeBuffer, const ObjectIdProvider& objectIdProvider) const;\n    // Override which produces a FatalError if any object is used.\n    WireResult Serialize(size_t commandSize, SerializeBuffer* serializeBuffer) const;\n\n    WireResult Deserialize(DeserializeBuffer* deserializeBuffer, DeserializeAllocator* allocator, const ObjectIdResolver& resolver);\n    // Override which produces a FatalError if any object is used.\n    WireResult Deserialize(DeserializeBuffer* deserializeBuffer, DeserializeAllocator* allocator);\n\n    ObjectId selfId;\n\n    WGPUCommandEncoder self;\n    char const * groupLabel;\n};\n\n    struct CommandEncoderResolveQuerySetCmd {\n    size_t GetRequiredSize() const;\n\n    WireResult Serialize(size_t commandSize, SerializeBuffer* serializeBuffer, const ObjectIdProvider& objectIdProvider) const;\n    // Override which produces a FatalError if any object is used.\n    WireResult Serialize(size_t commandSize, SerializeBuffer* serializeBuffer) const;\n\n    WireResult Deserialize(DeserializeBuffer* deserializeBuffer, DeserializeAllocator* allocator, const ObjectIdResolver& resolver);\n    // Override which produces a FatalError if any object is used.\n    WireResult Deserialize(DeserializeBuffer* deserializeBuffer, DeserializeAllocator* allocator);\n\n    ObjectId selfId;\n\n    WGPUCommandEncoder self;\n    WGPUQuerySet querySet;\n    uint32_t firstQuery;\n    uint32_t queryCount;\n    WGPUBuffer destination;\n    uint64_t destinationOffset;\n};\n\n    struct CommandEncoderSetLabelCmd {\n    size_t GetRequiredSize() const;\n\n    WireResult Serialize(size_t commandSize, SerializeBuffer* serializeBuffer, const ObjectIdProvider& objectIdProvider) const;\n    // Override which produces a FatalError if any object is used.\n    WireResult Serialize(size_t commandSize, SerializeBuffer* serializeBuffer) const;\n\n    WireResult Deserialize(DeserializeBuffer* deserializeBuffer, DeserializeAllocator* allocator, const ObjectIdResolver& resolver);\n    // Override which produces a FatalError if any object is used.\n    WireResult Deserialize(DeserializeBuffer* deserializeBuffer, DeserializeAllocator* allocator);\n\n    ObjectId selfId;\n\n    WGPUCommandEncoder self;\n    char const * label;\n};\n\n    struct CommandEncoderWriteBufferCmd {\n    size_t GetRequiredSize() const;\n\n    WireResult Serialize(size_t commandSize, SerializeBuffer* serializeBuffer, const ObjectIdProvider& objectIdProvider) const;\n    // Override which produces a FatalError if any object is used.\n    WireResult Serialize(size_t commandSize, SerializeBuffer* serializeBuffer) const;\n\n    WireResult Deserialize(DeserializeBuffer* deserializeBuffer, DeserializeAllocator* allocator, const ObjectIdResolver& resolver);\n    // Override which produces a FatalError if any object is used.\n    WireResult Deserialize(DeserializeBuffer* deserializeBuffer, DeserializeAllocator* allocator);\n\n    ObjectId selfId;\n\n    WGPUCommandEncoder self;\n    WGPUBuffer buffer;\n    uint64_t bufferOffset;\n    uint8_t const * data;\n    uint64_t size;\n};\n\n    struct CommandEncoderWriteTimestampCmd {\n    size_t GetRequiredSize() const;\n\n    WireResult Serialize(size_t commandSize, SerializeBuffer* serializeBuffer, const ObjectIdProvider& objectIdProvider) const;\n    // Override which produces a FatalError if any object is used.\n    WireResult Serialize(size_t commandSize, SerializeBuffer* serializeBuffer) const;\n\n    WireResult Deserialize(DeserializeBuffer* deserializeBuffer, DeserializeAllocator* allocator, const ObjectIdResolver& resolver);\n    // Override which produces a FatalError if any object is used.\n    WireResult Deserialize(DeserializeBuffer* deserializeBuffer, DeserializeAllocator* allocator);\n\n    ObjectId selfId;\n\n    WGPUCommandEncoder self;\n    WGPUQuerySet querySet;\n    uint32_t queryIndex;\n};\n\n    struct ComputePassEncoderDispatchCmd {\n    size_t GetRequiredSize() const;\n\n    WireResult Serialize(size_t commandSize, SerializeBuffer* serializeBuffer, const ObjectIdProvider& objectIdProvider) const;\n    // Override which produces a FatalError if any object is used.\n    WireResult Serialize(size_t commandSize, SerializeBuffer* serializeBuffer) const;\n\n    WireResult Deserialize(DeserializeBuffer* deserializeBuffer, DeserializeAllocator* allocator, const ObjectIdResolver& resolver);\n    // Override which produces a FatalError if any object is used.\n    WireResult Deserialize(DeserializeBuffer* deserializeBuffer, DeserializeAllocator* allocator);\n\n    ObjectId selfId;\n\n    WGPUComputePassEncoder self;\n    uint32_t workgroupCountX;\n    uint32_t workgroupCountY;\n    uint32_t workgroupCountZ;\n};\n\n    struct ComputePassEncoderDispatchIndirectCmd {\n    size_t GetRequiredSize() const;\n\n    WireResult Serialize(size_t commandSize, SerializeBuffer* serializeBuffer, const ObjectIdProvider& objectIdProvider) const;\n    // Override which produces a FatalError if any object is used.\n    WireResult Serialize(size_t commandSize, SerializeBuffer* serializeBuffer) const;\n\n    WireResult Deserialize(DeserializeBuffer* deserializeBuffer, DeserializeAllocator* allocator, const ObjectIdResolver& resolver);\n    // Override which produces a FatalError if any object is used.\n    WireResult Deserialize(DeserializeBuffer* deserializeBuffer, DeserializeAllocator* allocator);\n\n    ObjectId selfId;\n\n    WGPUComputePassEncoder self;\n    WGPUBuffer indirectBuffer;\n    uint64_t indirectOffset;\n};\n\n    struct ComputePassEncoderDispatchWorkgroupsCmd {\n    size_t GetRequiredSize() const;\n\n    WireResult Serialize(size_t commandSize, SerializeBuffer* serializeBuffer, const ObjectIdProvider& objectIdProvider) const;\n    // Override which produces a FatalError if any object is used.\n    WireResult Serialize(size_t commandSize, SerializeBuffer* serializeBuffer) const;\n\n    WireResult Deserialize(DeserializeBuffer* deserializeBuffer, DeserializeAllocator* allocator, const ObjectIdResolver& resolver);\n    // Override which produces a FatalError if any object is used.\n    WireResult Deserialize(DeserializeBuffer* deserializeBuffer, DeserializeAllocator* allocator);\n\n    ObjectId selfId;\n\n    WGPUComputePassEncoder self;\n    uint32_t workgroupCountX;\n    uint32_t workgroupCountY;\n    uint32_t workgroupCountZ;\n};\n\n    struct ComputePassEncoderDispatchWorkgroupsIndirectCmd {\n    size_t GetRequiredSize() const;\n\n    WireResult Serialize(size_t commandSize, SerializeBuffer* serializeBuffer, const ObjectIdProvider& objectIdProvider) const;\n    // Override which produces a FatalError if any object is used.\n    WireResult Serialize(size_t commandSize, SerializeBuffer* serializeBuffer) const;\n\n    WireResult Deserialize(DeserializeBuffer* deserializeBuffer, DeserializeAllocator* allocator, const ObjectIdResolver& resolver);\n    // Override which produces a FatalError if any object is used.\n    WireResult Deserialize(DeserializeBuffer* deserializeBuffer, DeserializeAllocator* allocator);\n\n    ObjectId selfId;\n\n    WGPUComputePassEncoder self;\n    WGPUBuffer indirectBuffer;\n    uint64_t indirectOffset;\n};\n\n    struct ComputePassEncoderEndCmd {\n    size_t GetRequiredSize() const;\n\n    WireResult Serialize(size_t commandSize, SerializeBuffer* serializeBuffer, const ObjectIdProvider& objectIdProvider) const;\n    // Override which produces a FatalError if any object is used.\n    WireResult Serialize(size_t commandSize, SerializeBuffer* serializeBuffer) const;\n\n    WireResult Deserialize(DeserializeBuffer* deserializeBuffer, DeserializeAllocator* allocator, const ObjectIdResolver& resolver);\n    // Override which produces a FatalError if any object is used.\n    WireResult Deserialize(DeserializeBuffer* deserializeBuffer, DeserializeAllocator* allocator);\n\n    ObjectId selfId;\n\n    WGPUComputePassEncoder self;\n};\n\n    struct ComputePassEncoderEndPassCmd {\n    size_t GetRequiredSize() const;\n\n    WireResult Serialize(size_t commandSize, SerializeBuffer* serializeBuffer, const ObjectIdProvider& objectIdProvider) const;\n    // Override which produces a FatalError if any object is used.\n    WireResult Serialize(size_t commandSize, SerializeBuffer* serializeBuffer) const;\n\n    WireResult Deserialize(DeserializeBuffer* deserializeBuffer, DeserializeAllocator* allocator, const ObjectIdResolver& resolver);\n    // Override which produces a FatalError if any object is used.\n    WireResult Deserialize(DeserializeBuffer* deserializeBuffer, DeserializeAllocator* allocator);\n\n    ObjectId selfId;\n\n    WGPUComputePassEncoder self;\n};\n\n    struct ComputePassEncoderInsertDebugMarkerCmd {\n    size_t GetRequiredSize() const;\n\n    WireResult Serialize(size_t commandSize, SerializeBuffer* serializeBuffer, const ObjectIdProvider& objectIdProvider) const;\n    // Override which produces a FatalError if any object is used.\n    WireResult Serialize(size_t commandSize, SerializeBuffer* serializeBuffer) const;\n\n    WireResult Deserialize(DeserializeBuffer* deserializeBuffer, DeserializeAllocator* allocator, const ObjectIdResolver& resolver);\n    // Override which produces a FatalError if any object is used.\n    WireResult Deserialize(DeserializeBuffer* deserializeBuffer, DeserializeAllocator* allocator);\n\n    ObjectId selfId;\n\n    WGPUComputePassEncoder self;\n    char const * markerLabel;\n};\n\n    struct ComputePassEncoderPopDebugGroupCmd {\n    size_t GetRequiredSize() const;\n\n    WireResult Serialize(size_t commandSize, SerializeBuffer* serializeBuffer, const ObjectIdProvider& objectIdProvider) const;\n    // Override which produces a FatalError if any object is used.\n    WireResult Serialize(size_t commandSize, SerializeBuffer* serializeBuffer) const;\n\n    WireResult Deserialize(DeserializeBuffer* deserializeBuffer, DeserializeAllocator* allocator, const ObjectIdResolver& resolver);\n    // Override which produces a FatalError if any object is used.\n    WireResult Deserialize(DeserializeBuffer* deserializeBuffer, DeserializeAllocator* allocator);\n\n    ObjectId selfId;\n\n    WGPUComputePassEncoder self;\n};\n\n    struct ComputePassEncoderPushDebugGroupCmd {\n    size_t GetRequiredSize() const;\n\n    WireResult Serialize(size_t commandSize, SerializeBuffer* serializeBuffer, const ObjectIdProvider& objectIdProvider) const;\n    // Override which produces a FatalError if any object is used.\n    WireResult Serialize(size_t commandSize, SerializeBuffer* serializeBuffer) const;\n\n    WireResult Deserialize(DeserializeBuffer* deserializeBuffer, DeserializeAllocator* allocator, const ObjectIdResolver& resolver);\n    // Override which produces a FatalError if any object is used.\n    WireResult Deserialize(DeserializeBuffer* deserializeBuffer, DeserializeAllocator* allocator);\n\n    ObjectId selfId;\n\n    WGPUComputePassEncoder self;\n    char const * groupLabel;\n};\n\n    struct ComputePassEncoderSetBindGroupCmd {\n    size_t GetRequiredSize() const;\n\n    WireResult Serialize(size_t commandSize, SerializeBuffer* serializeBuffer, const ObjectIdProvider& objectIdProvider) const;\n    // Override which produces a FatalError if any object is used.\n    WireResult Serialize(size_t commandSize, SerializeBuffer* serializeBuffer) const;\n\n    WireResult Deserialize(DeserializeBuffer* deserializeBuffer, DeserializeAllocator* allocator, const ObjectIdResolver& resolver);\n    // Override which produces a FatalError if any object is used.\n    WireResult Deserialize(DeserializeBuffer* deserializeBuffer, DeserializeAllocator* allocator);\n\n    ObjectId selfId;\n\n    WGPUComputePassEncoder self;\n    uint32_t groupIndex;\n    WGPUBindGroup group;\n    uint32_t dynamicOffsetCount;\n    uint32_t const * dynamicOffsets;\n};\n\n    struct ComputePassEncoderSetLabelCmd {\n    size_t GetRequiredSize() const;\n\n    WireResult Serialize(size_t commandSize, SerializeBuffer* serializeBuffer, const ObjectIdProvider& objectIdProvider) const;\n    // Override which produces a FatalError if any object is used.\n    WireResult Serialize(size_t commandSize, SerializeBuffer* serializeBuffer) const;\n\n    WireResult Deserialize(DeserializeBuffer* deserializeBuffer, DeserializeAllocator* allocator, const ObjectIdResolver& resolver);\n    // Override which produces a FatalError if any object is used.\n    WireResult Deserialize(DeserializeBuffer* deserializeBuffer, DeserializeAllocator* allocator);\n\n    ObjectId selfId;\n\n    WGPUComputePassEncoder self;\n    char const * label;\n};\n\n    struct ComputePassEncoderSetPipelineCmd {\n    size_t GetRequiredSize() const;\n\n    WireResult Serialize(size_t commandSize, SerializeBuffer* serializeBuffer, const ObjectIdProvider& objectIdProvider) const;\n    // Override which produces a FatalError if any object is used.\n    WireResult Serialize(size_t commandSize, SerializeBuffer* serializeBuffer) const;\n\n    WireResult Deserialize(DeserializeBuffer* deserializeBuffer, DeserializeAllocator* allocator, const ObjectIdResolver& resolver);\n    // Override which produces a FatalError if any object is used.\n    WireResult Deserialize(DeserializeBuffer* deserializeBuffer, DeserializeAllocator* allocator);\n\n    ObjectId selfId;\n\n    WGPUComputePassEncoder self;\n    WGPUComputePipeline pipeline;\n};\n\n    struct ComputePassEncoderWriteTimestampCmd {\n    size_t GetRequiredSize() const;\n\n    WireResult Serialize(size_t commandSize, SerializeBuffer* serializeBuffer, const ObjectIdProvider& objectIdProvider) const;\n    // Override which produces a FatalError if any object is used.\n    WireResult Serialize(size_t commandSize, SerializeBuffer* serializeBuffer) const;\n\n    WireResult Deserialize(DeserializeBuffer* deserializeBuffer, DeserializeAllocator* allocator, const ObjectIdResolver& resolver);\n    // Override which produces a FatalError if any object is used.\n    WireResult Deserialize(DeserializeBuffer* deserializeBuffer, DeserializeAllocator* allocator);\n\n    ObjectId selfId;\n\n    WGPUComputePassEncoder self;\n    WGPUQuerySet querySet;\n    uint32_t queryIndex;\n};\n\n    struct ComputePipelineGetBindGroupLayoutCmd {\n    size_t GetRequiredSize() const;\n\n    WireResult Serialize(size_t commandSize, SerializeBuffer* serializeBuffer, const ObjectIdProvider& objectIdProvider) const;\n    // Override which produces a FatalError if any object is used.\n    WireResult Serialize(size_t commandSize, SerializeBuffer* serializeBuffer) const;\n\n    WireResult Deserialize(DeserializeBuffer* deserializeBuffer, DeserializeAllocator* allocator, const ObjectIdResolver& resolver);\n    // Override which produces a FatalError if any object is used.\n    WireResult Deserialize(DeserializeBuffer* deserializeBuffer, DeserializeAllocator* allocator);\n\n    ObjectId selfId;\n\n    WGPUComputePipeline self;\n    uint32_t groupIndex;\n    ObjectHandle result;\n};\n\n    struct ComputePipelineSetLabelCmd {\n    size_t GetRequiredSize() const;\n\n    WireResult Serialize(size_t commandSize, SerializeBuffer* serializeBuffer, const ObjectIdProvider& objectIdProvider) const;\n    // Override which produces a FatalError if any object is used.\n    WireResult Serialize(size_t commandSize, SerializeBuffer* serializeBuffer) const;\n\n    WireResult Deserialize(DeserializeBuffer* deserializeBuffer, DeserializeAllocator* allocator, const ObjectIdResolver& resolver);\n    // Override which produces a FatalError if any object is used.\n    WireResult Deserialize(DeserializeBuffer* deserializeBuffer, DeserializeAllocator* allocator);\n\n    ObjectId selfId;\n\n    WGPUComputePipeline self;\n    char const * label;\n};\n\n    struct DestroyObjectCmd {\n    size_t GetRequiredSize() const;\n\n    WireResult Serialize(size_t commandSize, SerializeBuffer* serializeBuffer, const ObjectIdProvider& objectIdProvider) const;\n    // Override which produces a FatalError if any object is used.\n    WireResult Serialize(size_t commandSize, SerializeBuffer* serializeBuffer) const;\n\n    WireResult Deserialize(DeserializeBuffer* deserializeBuffer, DeserializeAllocator* allocator, const ObjectIdResolver& resolver);\n    // Override which produces a FatalError if any object is used.\n    WireResult Deserialize(DeserializeBuffer* deserializeBuffer, DeserializeAllocator* allocator);\n\n\n    ObjectType objectType;\n    ObjectId objectId;\n};\n\n    struct DeviceCreateBindGroupCmd {\n    size_t GetRequiredSize() const;\n\n    WireResult Serialize(size_t commandSize, SerializeBuffer* serializeBuffer, const ObjectIdProvider& objectIdProvider) const;\n    // Override which produces a FatalError if any object is used.\n    WireResult Serialize(size_t commandSize, SerializeBuffer* serializeBuffer) const;\n\n    WireResult Deserialize(DeserializeBuffer* deserializeBuffer, DeserializeAllocator* allocator, const ObjectIdResolver& resolver);\n    // Override which produces a FatalError if any object is used.\n    WireResult Deserialize(DeserializeBuffer* deserializeBuffer, DeserializeAllocator* allocator);\n\n    ObjectId selfId;\n\n    WGPUDevice self;\n    WGPUBindGroupDescriptor const * descriptor;\n    ObjectHandle result;\n};\n\n    struct DeviceCreateBindGroupLayoutCmd {\n    size_t GetRequiredSize() const;\n\n    WireResult Serialize(size_t commandSize, SerializeBuffer* serializeBuffer, const ObjectIdProvider& objectIdProvider) const;\n    // Override which produces a FatalError if any object is used.\n    WireResult Serialize(size_t commandSize, SerializeBuffer* serializeBuffer) const;\n\n    WireResult Deserialize(DeserializeBuffer* deserializeBuffer, DeserializeAllocator* allocator, const ObjectIdResolver& resolver);\n    // Override which produces a FatalError if any object is used.\n    WireResult Deserialize(DeserializeBuffer* deserializeBuffer, DeserializeAllocator* allocator);\n\n    ObjectId selfId;\n\n    WGPUDevice self;\n    WGPUBindGroupLayoutDescriptor const * descriptor;\n    ObjectHandle result;\n};\n\n    struct DeviceCreateBufferCmd {\n    size_t GetRequiredSize() const;\n\n    WireResult Serialize(size_t commandSize, SerializeBuffer* serializeBuffer, const ObjectIdProvider& objectIdProvider) const;\n    // Override which produces a FatalError if any object is used.\n    WireResult Serialize(size_t commandSize, SerializeBuffer* serializeBuffer) const;\n\n    WireResult Deserialize(DeserializeBuffer* deserializeBuffer, DeserializeAllocator* allocator, const ObjectIdResolver& resolver);\n    // Override which produces a FatalError if any object is used.\n    WireResult Deserialize(DeserializeBuffer* deserializeBuffer, DeserializeAllocator* allocator);\n\n\n    ObjectId deviceId;\n    WGPUBufferDescriptor const * descriptor;\n    ObjectHandle result;\n    uint64_t readHandleCreateInfoLength;\n    uint8_t const * readHandleCreateInfo;\n    uint64_t writeHandleCreateInfoLength;\n    uint8_t const * writeHandleCreateInfo;\n};\n\n    struct DeviceCreateCommandEncoderCmd {\n    size_t GetRequiredSize() const;\n\n    WireResult Serialize(size_t commandSize, SerializeBuffer* serializeBuffer, const ObjectIdProvider& objectIdProvider) const;\n    // Override which produces a FatalError if any object is used.\n    WireResult Serialize(size_t commandSize, SerializeBuffer* serializeBuffer) const;\n\n    WireResult Deserialize(DeserializeBuffer* deserializeBuffer, DeserializeAllocator* allocator, const ObjectIdResolver& resolver);\n    // Override which produces a FatalError if any object is used.\n    WireResult Deserialize(DeserializeBuffer* deserializeBuffer, DeserializeAllocator* allocator);\n\n    ObjectId selfId;\n\n    WGPUDevice self;\n    WGPUCommandEncoderDescriptor const * descriptor;\n    ObjectHandle result;\n};\n\n    struct DeviceCreateComputePipelineCmd {\n    size_t GetRequiredSize() const;\n\n    WireResult Serialize(size_t commandSize, SerializeBuffer* serializeBuffer, const ObjectIdProvider& objectIdProvider) const;\n    // Override which produces a FatalError if any object is used.\n    WireResult Serialize(size_t commandSize, SerializeBuffer* serializeBuffer) const;\n\n    WireResult Deserialize(DeserializeBuffer* deserializeBuffer, DeserializeAllocator* allocator, const ObjectIdResolver& resolver);\n    // Override which produces a FatalError if any object is used.\n    WireResult Deserialize(DeserializeBuffer* deserializeBuffer, DeserializeAllocator* allocator);\n\n    ObjectId selfId;\n\n    WGPUDevice self;\n    WGPUComputePipelineDescriptor const * descriptor;\n    ObjectHandle result;\n};\n\n    struct DeviceCreateComputePipelineAsyncCmd {\n    size_t GetRequiredSize() const;\n\n    WireResult Serialize(size_t commandSize, SerializeBuffer* serializeBuffer, const ObjectIdProvider& objectIdProvider) const;\n    // Override which produces a FatalError if any object is used.\n    WireResult Serialize(size_t commandSize, SerializeBuffer* serializeBuffer) const;\n\n    WireResult Deserialize(DeserializeBuffer* deserializeBuffer, DeserializeAllocator* allocator, const ObjectIdResolver& resolver);\n    // Override which produces a FatalError if any object is used.\n    WireResult Deserialize(DeserializeBuffer* deserializeBuffer, DeserializeAllocator* allocator);\n\n\n    ObjectId deviceId;\n    uint64_t requestSerial;\n    ObjectHandle pipelineObjectHandle;\n    WGPUComputePipelineDescriptor const * descriptor;\n};\n\n    struct DeviceCreateErrorBufferCmd {\n    size_t GetRequiredSize() const;\n\n    WireResult Serialize(size_t commandSize, SerializeBuffer* serializeBuffer, const ObjectIdProvider& objectIdProvider) const;\n    // Override which produces a FatalError if any object is used.\n    WireResult Serialize(size_t commandSize, SerializeBuffer* serializeBuffer) const;\n\n    WireResult Deserialize(DeserializeBuffer* deserializeBuffer, DeserializeAllocator* allocator, const ObjectIdResolver& resolver);\n    // Override which produces a FatalError if any object is used.\n    WireResult Deserialize(DeserializeBuffer* deserializeBuffer, DeserializeAllocator* allocator);\n\n    ObjectId selfId;\n\n    WGPUDevice self;\n    ObjectHandle result;\n};\n\n    struct DeviceCreateErrorExternalTextureCmd {\n    size_t GetRequiredSize() const;\n\n    WireResult Serialize(size_t commandSize, SerializeBuffer* serializeBuffer, const ObjectIdProvider& objectIdProvider) const;\n    // Override which produces a FatalError if any object is used.\n    WireResult Serialize(size_t commandSize, SerializeBuffer* serializeBuffer) const;\n\n    WireResult Deserialize(DeserializeBuffer* deserializeBuffer, DeserializeAllocator* allocator, const ObjectIdResolver& resolver);\n    // Override which produces a FatalError if any object is used.\n    WireResult Deserialize(DeserializeBuffer* deserializeBuffer, DeserializeAllocator* allocator);\n\n    ObjectId selfId;\n\n    WGPUDevice self;\n    ObjectHandle result;\n};\n\n    struct DeviceCreateErrorTextureCmd {\n    size_t GetRequiredSize() const;\n\n    WireResult Serialize(size_t commandSize, SerializeBuffer* serializeBuffer, const ObjectIdProvider& objectIdProvider) const;\n    // Override which produces a FatalError if any object is used.\n    WireResult Serialize(size_t commandSize, SerializeBuffer* serializeBuffer) const;\n\n    WireResult Deserialize(DeserializeBuffer* deserializeBuffer, DeserializeAllocator* allocator, const ObjectIdResolver& resolver);\n    // Override which produces a FatalError if any object is used.\n    WireResult Deserialize(DeserializeBuffer* deserializeBuffer, DeserializeAllocator* allocator);\n\n    ObjectId selfId;\n\n    WGPUDevice self;\n    WGPUTextureDescriptor const * descriptor;\n    ObjectHandle result;\n};\n\n    struct DeviceCreateExternalTextureCmd {\n    size_t GetRequiredSize() const;\n\n    WireResult Serialize(size_t commandSize, SerializeBuffer* serializeBuffer, const ObjectIdProvider& objectIdProvider) const;\n    // Override which produces a FatalError if any object is used.\n    WireResult Serialize(size_t commandSize, SerializeBuffer* serializeBuffer) const;\n\n    WireResult Deserialize(DeserializeBuffer* deserializeBuffer, DeserializeAllocator* allocator, const ObjectIdResolver& resolver);\n    // Override which produces a FatalError if any object is used.\n    WireResult Deserialize(DeserializeBuffer* deserializeBuffer, DeserializeAllocator* allocator);\n\n    ObjectId selfId;\n\n    WGPUDevice self;\n    WGPUExternalTextureDescriptor const * externalTextureDescriptor;\n    ObjectHandle result;\n};\n\n    struct DeviceCreatePipelineLayoutCmd {\n    size_t GetRequiredSize() const;\n\n    WireResult Serialize(size_t commandSize, SerializeBuffer* serializeBuffer, const ObjectIdProvider& objectIdProvider) const;\n    // Override which produces a FatalError if any object is used.\n    WireResult Serialize(size_t commandSize, SerializeBuffer* serializeBuffer) const;\n\n    WireResult Deserialize(DeserializeBuffer* deserializeBuffer, DeserializeAllocator* allocator, const ObjectIdResolver& resolver);\n    // Override which produces a FatalError if any object is used.\n    WireResult Deserialize(DeserializeBuffer* deserializeBuffer, DeserializeAllocator* allocator);\n\n    ObjectId selfId;\n\n    WGPUDevice self;\n    WGPUPipelineLayoutDescriptor const * descriptor;\n    ObjectHandle result;\n};\n\n    struct DeviceCreateQuerySetCmd {\n    size_t GetRequiredSize() const;\n\n    WireResult Serialize(size_t commandSize, SerializeBuffer* serializeBuffer, const ObjectIdProvider& objectIdProvider) const;\n    // Override which produces a FatalError if any object is used.\n    WireResult Serialize(size_t commandSize, SerializeBuffer* serializeBuffer) const;\n\n    WireResult Deserialize(DeserializeBuffer* deserializeBuffer, DeserializeAllocator* allocator, const ObjectIdResolver& resolver);\n    // Override which produces a FatalError if any object is used.\n    WireResult Deserialize(DeserializeBuffer* deserializeBuffer, DeserializeAllocator* allocator);\n\n    ObjectId selfId;\n\n    WGPUDevice self;\n    WGPUQuerySetDescriptor const * descriptor;\n    ObjectHandle result;\n};\n\n    struct DeviceCreateRenderBundleEncoderCmd {\n    size_t GetRequiredSize() const;\n\n    WireResult Serialize(size_t commandSize, SerializeBuffer* serializeBuffer, const ObjectIdProvider& objectIdProvider) const;\n    // Override which produces a FatalError if any object is used.\n    WireResult Serialize(size_t commandSize, SerializeBuffer* serializeBuffer) const;\n\n    WireResult Deserialize(DeserializeBuffer* deserializeBuffer, DeserializeAllocator* allocator, const ObjectIdResolver& resolver);\n    // Override which produces a FatalError if any object is used.\n    WireResult Deserialize(DeserializeBuffer* deserializeBuffer, DeserializeAllocator* allocator);\n\n    ObjectId selfId;\n\n    WGPUDevice self;\n    WGPURenderBundleEncoderDescriptor const * descriptor;\n    ObjectHandle result;\n};\n\n    struct DeviceCreateRenderPipelineCmd {\n    size_t GetRequiredSize() const;\n\n    WireResult Serialize(size_t commandSize, SerializeBuffer* serializeBuffer, const ObjectIdProvider& objectIdProvider) const;\n    // Override which produces a FatalError if any object is used.\n    WireResult Serialize(size_t commandSize, SerializeBuffer* serializeBuffer) const;\n\n    WireResult Deserialize(DeserializeBuffer* deserializeBuffer, DeserializeAllocator* allocator, const ObjectIdResolver& resolver);\n    // Override which produces a FatalError if any object is used.\n    WireResult Deserialize(DeserializeBuffer* deserializeBuffer, DeserializeAllocator* allocator);\n\n    ObjectId selfId;\n\n    WGPUDevice self;\n    WGPURenderPipelineDescriptor const * descriptor;\n    ObjectHandle result;\n};\n\n    struct DeviceCreateRenderPipelineAsyncCmd {\n    size_t GetRequiredSize() const;\n\n    WireResult Serialize(size_t commandSize, SerializeBuffer* serializeBuffer, const ObjectIdProvider& objectIdProvider) const;\n    // Override which produces a FatalError if any object is used.\n    WireResult Serialize(size_t commandSize, SerializeBuffer* serializeBuffer) const;\n\n    WireResult Deserialize(DeserializeBuffer* deserializeBuffer, DeserializeAllocator* allocator, const ObjectIdResolver& resolver);\n    // Override which produces a FatalError if any object is used.\n    WireResult Deserialize(DeserializeBuffer* deserializeBuffer, DeserializeAllocator* allocator);\n\n\n    ObjectId deviceId;\n    uint64_t requestSerial;\n    ObjectHandle pipelineObjectHandle;\n    WGPURenderPipelineDescriptor const * descriptor;\n};\n\n    struct DeviceCreateSamplerCmd {\n    size_t GetRequiredSize() const;\n\n    WireResult Serialize(size_t commandSize, SerializeBuffer* serializeBuffer, const ObjectIdProvider& objectIdProvider) const;\n    // Override which produces a FatalError if any object is used.\n    WireResult Serialize(size_t commandSize, SerializeBuffer* serializeBuffer) const;\n\n    WireResult Deserialize(DeserializeBuffer* deserializeBuffer, DeserializeAllocator* allocator, const ObjectIdResolver& resolver);\n    // Override which produces a FatalError if any object is used.\n    WireResult Deserialize(DeserializeBuffer* deserializeBuffer, DeserializeAllocator* allocator);\n\n    ObjectId selfId;\n\n    WGPUDevice self;\n    WGPUSamplerDescriptor const * descriptor;\n    ObjectHandle result;\n};\n\n    struct DeviceCreateShaderModuleCmd {\n    size_t GetRequiredSize() const;\n\n    WireResult Serialize(size_t commandSize, SerializeBuffer* serializeBuffer, const ObjectIdProvider& objectIdProvider) const;\n    // Override which produces a FatalError if any object is used.\n    WireResult Serialize(size_t commandSize, SerializeBuffer* serializeBuffer) const;\n\n    WireResult Deserialize(DeserializeBuffer* deserializeBuffer, DeserializeAllocator* allocator, const ObjectIdResolver& resolver);\n    // Override which produces a FatalError if any object is used.\n    WireResult Deserialize(DeserializeBuffer* deserializeBuffer, DeserializeAllocator* allocator);\n\n    ObjectId selfId;\n\n    WGPUDevice self;\n    WGPUShaderModuleDescriptor const * descriptor;\n    ObjectHandle result;\n};\n\n    struct DeviceCreateSwapChainCmd {\n    size_t GetRequiredSize() const;\n\n    WireResult Serialize(size_t commandSize, SerializeBuffer* serializeBuffer, const ObjectIdProvider& objectIdProvider) const;\n    // Override which produces a FatalError if any object is used.\n    WireResult Serialize(size_t commandSize, SerializeBuffer* serializeBuffer) const;\n\n    WireResult Deserialize(DeserializeBuffer* deserializeBuffer, DeserializeAllocator* allocator, const ObjectIdResolver& resolver);\n    // Override which produces a FatalError if any object is used.\n    WireResult Deserialize(DeserializeBuffer* deserializeBuffer, DeserializeAllocator* allocator);\n\n    ObjectId selfId;\n\n    WGPUDevice self;\n    WGPUSurface surface;\n    WGPUSwapChainDescriptor const * descriptor;\n    ObjectHandle result;\n};\n\n    struct DeviceCreateTextureCmd {\n    size_t GetRequiredSize() const;\n\n    WireResult Serialize(size_t commandSize, SerializeBuffer* serializeBuffer, const ObjectIdProvider& objectIdProvider) const;\n    // Override which produces a FatalError if any object is used.\n    WireResult Serialize(size_t commandSize, SerializeBuffer* serializeBuffer) const;\n\n    WireResult Deserialize(DeserializeBuffer* deserializeBuffer, DeserializeAllocator* allocator, const ObjectIdResolver& resolver);\n    // Override which produces a FatalError if any object is used.\n    WireResult Deserialize(DeserializeBuffer* deserializeBuffer, DeserializeAllocator* allocator);\n\n    ObjectId selfId;\n\n    WGPUDevice self;\n    WGPUTextureDescriptor const * descriptor;\n    ObjectHandle result;\n};\n\n    struct DeviceDestroyCmd {\n    size_t GetRequiredSize() const;\n\n    WireResult Serialize(size_t commandSize, SerializeBuffer* serializeBuffer, const ObjectIdProvider& objectIdProvider) const;\n    // Override which produces a FatalError if any object is used.\n    WireResult Serialize(size_t commandSize, SerializeBuffer* serializeBuffer) const;\n\n    WireResult Deserialize(DeserializeBuffer* deserializeBuffer, DeserializeAllocator* allocator, const ObjectIdResolver& resolver);\n    // Override which produces a FatalError if any object is used.\n    WireResult Deserialize(DeserializeBuffer* deserializeBuffer, DeserializeAllocator* allocator);\n\n    ObjectId selfId;\n\n    WGPUDevice self;\n};\n\n    struct DeviceGetQueueCmd {\n    size_t GetRequiredSize() const;\n\n    WireResult Serialize(size_t commandSize, SerializeBuffer* serializeBuffer, const ObjectIdProvider& objectIdProvider) const;\n    // Override which produces a FatalError if any object is used.\n    WireResult Serialize(size_t commandSize, SerializeBuffer* serializeBuffer) const;\n\n    WireResult Deserialize(DeserializeBuffer* deserializeBuffer, DeserializeAllocator* allocator, const ObjectIdResolver& resolver);\n    // Override which produces a FatalError if any object is used.\n    WireResult Deserialize(DeserializeBuffer* deserializeBuffer, DeserializeAllocator* allocator);\n\n    ObjectId selfId;\n\n    WGPUDevice self;\n    ObjectHandle result;\n};\n\n    struct DeviceInjectErrorCmd {\n    size_t GetRequiredSize() const;\n\n    WireResult Serialize(size_t commandSize, SerializeBuffer* serializeBuffer, const ObjectIdProvider& objectIdProvider) const;\n    // Override which produces a FatalError if any object is used.\n    WireResult Serialize(size_t commandSize, SerializeBuffer* serializeBuffer) const;\n\n    WireResult Deserialize(DeserializeBuffer* deserializeBuffer, DeserializeAllocator* allocator, const ObjectIdResolver& resolver);\n    // Override which produces a FatalError if any object is used.\n    WireResult Deserialize(DeserializeBuffer* deserializeBuffer, DeserializeAllocator* allocator);\n\n    ObjectId selfId;\n\n    WGPUDevice self;\n    WGPUErrorType type;\n    char const * message;\n};\n\n    struct DeviceLoseForTestingCmd {\n    size_t GetRequiredSize() const;\n\n    WireResult Serialize(size_t commandSize, SerializeBuffer* serializeBuffer, const ObjectIdProvider& objectIdProvider) const;\n    // Override which produces a FatalError if any object is used.\n    WireResult Serialize(size_t commandSize, SerializeBuffer* serializeBuffer) const;\n\n    WireResult Deserialize(DeserializeBuffer* deserializeBuffer, DeserializeAllocator* allocator, const ObjectIdResolver& resolver);\n    // Override which produces a FatalError if any object is used.\n    WireResult Deserialize(DeserializeBuffer* deserializeBuffer, DeserializeAllocator* allocator);\n\n    ObjectId selfId;\n\n    WGPUDevice self;\n};\n\n    struct DevicePopErrorScopeCmd {\n    size_t GetRequiredSize() const;\n\n    WireResult Serialize(size_t commandSize, SerializeBuffer* serializeBuffer, const ObjectIdProvider& objectIdProvider) const;\n    // Override which produces a FatalError if any object is used.\n    WireResult Serialize(size_t commandSize, SerializeBuffer* serializeBuffer) const;\n\n    WireResult Deserialize(DeserializeBuffer* deserializeBuffer, DeserializeAllocator* allocator, const ObjectIdResolver& resolver);\n    // Override which produces a FatalError if any object is used.\n    WireResult Deserialize(DeserializeBuffer* deserializeBuffer, DeserializeAllocator* allocator);\n\n\n    ObjectId deviceId;\n    uint64_t requestSerial;\n};\n\n    struct DevicePushErrorScopeCmd {\n    size_t GetRequiredSize() const;\n\n    WireResult Serialize(size_t commandSize, SerializeBuffer* serializeBuffer, const ObjectIdProvider& objectIdProvider) const;\n    // Override which produces a FatalError if any object is used.\n    WireResult Serialize(size_t commandSize, SerializeBuffer* serializeBuffer) const;\n\n    WireResult Deserialize(DeserializeBuffer* deserializeBuffer, DeserializeAllocator* allocator, const ObjectIdResolver& resolver);\n    // Override which produces a FatalError if any object is used.\n    WireResult Deserialize(DeserializeBuffer* deserializeBuffer, DeserializeAllocator* allocator);\n\n    ObjectId selfId;\n\n    WGPUDevice self;\n    WGPUErrorFilter filter;\n};\n\n    struct DeviceSetLabelCmd {\n    size_t GetRequiredSize() const;\n\n    WireResult Serialize(size_t commandSize, SerializeBuffer* serializeBuffer, const ObjectIdProvider& objectIdProvider) const;\n    // Override which produces a FatalError if any object is used.\n    WireResult Serialize(size_t commandSize, SerializeBuffer* serializeBuffer) const;\n\n    WireResult Deserialize(DeserializeBuffer* deserializeBuffer, DeserializeAllocator* allocator, const ObjectIdResolver& resolver);\n    // Override which produces a FatalError if any object is used.\n    WireResult Deserialize(DeserializeBuffer* deserializeBuffer, DeserializeAllocator* allocator);\n\n    ObjectId selfId;\n\n    WGPUDevice self;\n    char const * label;\n};\n\n    struct DeviceTickCmd {\n    size_t GetRequiredSize() const;\n\n    WireResult Serialize(size_t commandSize, SerializeBuffer* serializeBuffer, const ObjectIdProvider& objectIdProvider) const;\n    // Override which produces a FatalError if any object is used.\n    WireResult Serialize(size_t commandSize, SerializeBuffer* serializeBuffer) const;\n\n    WireResult Deserialize(DeserializeBuffer* deserializeBuffer, DeserializeAllocator* allocator, const ObjectIdResolver& resolver);\n    // Override which produces a FatalError if any object is used.\n    WireResult Deserialize(DeserializeBuffer* deserializeBuffer, DeserializeAllocator* allocator);\n\n    ObjectId selfId;\n\n    WGPUDevice self;\n};\n\n    struct ExternalTextureDestroyCmd {\n    size_t GetRequiredSize() const;\n\n    WireResult Serialize(size_t commandSize, SerializeBuffer* serializeBuffer, const ObjectIdProvider& objectIdProvider) const;\n    // Override which produces a FatalError if any object is used.\n    WireResult Serialize(size_t commandSize, SerializeBuffer* serializeBuffer) const;\n\n    WireResult Deserialize(DeserializeBuffer* deserializeBuffer, DeserializeAllocator* allocator, const ObjectIdResolver& resolver);\n    // Override which produces a FatalError if any object is used.\n    WireResult Deserialize(DeserializeBuffer* deserializeBuffer, DeserializeAllocator* allocator);\n\n    ObjectId selfId;\n\n    WGPUExternalTexture self;\n};\n\n    struct ExternalTextureSetLabelCmd {\n    size_t GetRequiredSize() const;\n\n    WireResult Serialize(size_t commandSize, SerializeBuffer* serializeBuffer, const ObjectIdProvider& objectIdProvider) const;\n    // Override which produces a FatalError if any object is used.\n    WireResult Serialize(size_t commandSize, SerializeBuffer* serializeBuffer) const;\n\n    WireResult Deserialize(DeserializeBuffer* deserializeBuffer, DeserializeAllocator* allocator, const ObjectIdResolver& resolver);\n    // Override which produces a FatalError if any object is used.\n    WireResult Deserialize(DeserializeBuffer* deserializeBuffer, DeserializeAllocator* allocator);\n\n    ObjectId selfId;\n\n    WGPUExternalTexture self;\n    char const * label;\n};\n\n    struct InstanceCreateSurfaceCmd {\n    size_t GetRequiredSize() const;\n\n    WireResult Serialize(size_t commandSize, SerializeBuffer* serializeBuffer, const ObjectIdProvider& objectIdProvider) const;\n    // Override which produces a FatalError if any object is used.\n    WireResult Serialize(size_t commandSize, SerializeBuffer* serializeBuffer) const;\n\n    WireResult Deserialize(DeserializeBuffer* deserializeBuffer, DeserializeAllocator* allocator, const ObjectIdResolver& resolver);\n    // Override which produces a FatalError if any object is used.\n    WireResult Deserialize(DeserializeBuffer* deserializeBuffer, DeserializeAllocator* allocator);\n\n    ObjectId selfId;\n\n    WGPUInstance self;\n    WGPUSurfaceDescriptor const * descriptor;\n    ObjectHandle result;\n};\n\n    struct InstanceRequestAdapterCmd {\n    size_t GetRequiredSize() const;\n\n    WireResult Serialize(size_t commandSize, SerializeBuffer* serializeBuffer, const ObjectIdProvider& objectIdProvider) const;\n    // Override which produces a FatalError if any object is used.\n    WireResult Serialize(size_t commandSize, SerializeBuffer* serializeBuffer) const;\n\n    WireResult Deserialize(DeserializeBuffer* deserializeBuffer, DeserializeAllocator* allocator, const ObjectIdResolver& resolver);\n    // Override which produces a FatalError if any object is used.\n    WireResult Deserialize(DeserializeBuffer* deserializeBuffer, DeserializeAllocator* allocator);\n\n\n    ObjectId instanceId;\n    uint64_t requestSerial;\n    ObjectHandle adapterObjectHandle;\n    WGPURequestAdapterOptions const * options;\n};\n\n    struct PipelineLayoutSetLabelCmd {\n    size_t GetRequiredSize() const;\n\n    WireResult Serialize(size_t commandSize, SerializeBuffer* serializeBuffer, const ObjectIdProvider& objectIdProvider) const;\n    // Override which produces a FatalError if any object is used.\n    WireResult Serialize(size_t commandSize, SerializeBuffer* serializeBuffer) const;\n\n    WireResult Deserialize(DeserializeBuffer* deserializeBuffer, DeserializeAllocator* allocator, const ObjectIdResolver& resolver);\n    // Override which produces a FatalError if any object is used.\n    WireResult Deserialize(DeserializeBuffer* deserializeBuffer, DeserializeAllocator* allocator);\n\n    ObjectId selfId;\n\n    WGPUPipelineLayout self;\n    char const * label;\n};\n\n    struct QuerySetDestroyCmd {\n    size_t GetRequiredSize() const;\n\n    WireResult Serialize(size_t commandSize, SerializeBuffer* serializeBuffer, const ObjectIdProvider& objectIdProvider) const;\n    // Override which produces a FatalError if any object is used.\n    WireResult Serialize(size_t commandSize, SerializeBuffer* serializeBuffer) const;\n\n    WireResult Deserialize(DeserializeBuffer* deserializeBuffer, DeserializeAllocator* allocator, const ObjectIdResolver& resolver);\n    // Override which produces a FatalError if any object is used.\n    WireResult Deserialize(DeserializeBuffer* deserializeBuffer, DeserializeAllocator* allocator);\n\n    ObjectId selfId;\n\n    WGPUQuerySet self;\n};\n\n    struct QuerySetSetLabelCmd {\n    size_t GetRequiredSize() const;\n\n    WireResult Serialize(size_t commandSize, SerializeBuffer* serializeBuffer, const ObjectIdProvider& objectIdProvider) const;\n    // Override which produces a FatalError if any object is used.\n    WireResult Serialize(size_t commandSize, SerializeBuffer* serializeBuffer) const;\n\n    WireResult Deserialize(DeserializeBuffer* deserializeBuffer, DeserializeAllocator* allocator, const ObjectIdResolver& resolver);\n    // Override which produces a FatalError if any object is used.\n    WireResult Deserialize(DeserializeBuffer* deserializeBuffer, DeserializeAllocator* allocator);\n\n    ObjectId selfId;\n\n    WGPUQuerySet self;\n    char const * label;\n};\n\n    struct QueueCopyTextureForBrowserCmd {\n    size_t GetRequiredSize() const;\n\n    WireResult Serialize(size_t commandSize, SerializeBuffer* serializeBuffer, const ObjectIdProvider& objectIdProvider) const;\n    // Override which produces a FatalError if any object is used.\n    WireResult Serialize(size_t commandSize, SerializeBuffer* serializeBuffer) const;\n\n    WireResult Deserialize(DeserializeBuffer* deserializeBuffer, DeserializeAllocator* allocator, const ObjectIdResolver& resolver);\n    // Override which produces a FatalError if any object is used.\n    WireResult Deserialize(DeserializeBuffer* deserializeBuffer, DeserializeAllocator* allocator);\n\n    ObjectId selfId;\n\n    WGPUQueue self;\n    WGPUImageCopyTexture const * source;\n    WGPUImageCopyTexture const * destination;\n    WGPUExtent3D const * copySize;\n    WGPUCopyTextureForBrowserOptions const * options;\n};\n\n    struct QueueOnSubmittedWorkDoneCmd {\n    size_t GetRequiredSize() const;\n\n    WireResult Serialize(size_t commandSize, SerializeBuffer* serializeBuffer, const ObjectIdProvider& objectIdProvider) const;\n    // Override which produces a FatalError if any object is used.\n    WireResult Serialize(size_t commandSize, SerializeBuffer* serializeBuffer) const;\n\n    WireResult Deserialize(DeserializeBuffer* deserializeBuffer, DeserializeAllocator* allocator, const ObjectIdResolver& resolver);\n    // Override which produces a FatalError if any object is used.\n    WireResult Deserialize(DeserializeBuffer* deserializeBuffer, DeserializeAllocator* allocator);\n\n\n    ObjectId queueId;\n    uint64_t signalValue;\n    uint64_t requestSerial;\n};\n\n    struct QueueSetLabelCmd {\n    size_t GetRequiredSize() const;\n\n    WireResult Serialize(size_t commandSize, SerializeBuffer* serializeBuffer, const ObjectIdProvider& objectIdProvider) const;\n    // Override which produces a FatalError if any object is used.\n    WireResult Serialize(size_t commandSize, SerializeBuffer* serializeBuffer) const;\n\n    WireResult Deserialize(DeserializeBuffer* deserializeBuffer, DeserializeAllocator* allocator, const ObjectIdResolver& resolver);\n    // Override which produces a FatalError if any object is used.\n    WireResult Deserialize(DeserializeBuffer* deserializeBuffer, DeserializeAllocator* allocator);\n\n    ObjectId selfId;\n\n    WGPUQueue self;\n    char const * label;\n};\n\n    struct QueueSubmitCmd {\n    size_t GetRequiredSize() const;\n\n    WireResult Serialize(size_t commandSize, SerializeBuffer* serializeBuffer, const ObjectIdProvider& objectIdProvider) const;\n    // Override which produces a FatalError if any object is used.\n    WireResult Serialize(size_t commandSize, SerializeBuffer* serializeBuffer) const;\n\n    WireResult Deserialize(DeserializeBuffer* deserializeBuffer, DeserializeAllocator* allocator, const ObjectIdResolver& resolver);\n    // Override which produces a FatalError if any object is used.\n    WireResult Deserialize(DeserializeBuffer* deserializeBuffer, DeserializeAllocator* allocator);\n\n    ObjectId selfId;\n\n    WGPUQueue self;\n    uint32_t commandCount;\n    WGPUCommandBuffer const * commands;\n};\n\n    struct QueueWriteBufferCmd {\n    size_t GetRequiredSize() const;\n\n    WireResult Serialize(size_t commandSize, SerializeBuffer* serializeBuffer, const ObjectIdProvider& objectIdProvider) const;\n    // Override which produces a FatalError if any object is used.\n    WireResult Serialize(size_t commandSize, SerializeBuffer* serializeBuffer) const;\n\n    WireResult Deserialize(DeserializeBuffer* deserializeBuffer, DeserializeAllocator* allocator, const ObjectIdResolver& resolver);\n    // Override which produces a FatalError if any object is used.\n    WireResult Deserialize(DeserializeBuffer* deserializeBuffer, DeserializeAllocator* allocator);\n\n\n    ObjectId queueId;\n    ObjectId bufferId;\n    uint64_t bufferOffset;\n    uint8_t const * data;\n    uint64_t size;\n};\n\n    struct QueueWriteTextureCmd {\n    size_t GetRequiredSize() const;\n\n    WireResult Serialize(size_t commandSize, SerializeBuffer* serializeBuffer, const ObjectIdProvider& objectIdProvider) const;\n    // Override which produces a FatalError if any object is used.\n    WireResult Serialize(size_t commandSize, SerializeBuffer* serializeBuffer) const;\n\n    WireResult Deserialize(DeserializeBuffer* deserializeBuffer, DeserializeAllocator* allocator, const ObjectIdResolver& resolver);\n    // Override which produces a FatalError if any object is used.\n    WireResult Deserialize(DeserializeBuffer* deserializeBuffer, DeserializeAllocator* allocator);\n\n\n    ObjectId queueId;\n    WGPUImageCopyTexture const * destination;\n    uint8_t const * data;\n    uint64_t dataSize;\n    WGPUTextureDataLayout const * dataLayout;\n    WGPUExtent3D const * writeSize;\n};\n\n    struct RenderBundleEncoderDrawCmd {\n    size_t GetRequiredSize() const;\n\n    WireResult Serialize(size_t commandSize, SerializeBuffer* serializeBuffer, const ObjectIdProvider& objectIdProvider) const;\n    // Override which produces a FatalError if any object is used.\n    WireResult Serialize(size_t commandSize, SerializeBuffer* serializeBuffer) const;\n\n    WireResult Deserialize(DeserializeBuffer* deserializeBuffer, DeserializeAllocator* allocator, const ObjectIdResolver& resolver);\n    // Override which produces a FatalError if any object is used.\n    WireResult Deserialize(DeserializeBuffer* deserializeBuffer, DeserializeAllocator* allocator);\n\n    ObjectId selfId;\n\n    WGPURenderBundleEncoder self;\n    uint32_t vertexCount;\n    uint32_t instanceCount;\n    uint32_t firstVertex;\n    uint32_t firstInstance;\n};\n\n    struct RenderBundleEncoderDrawIndexedCmd {\n    size_t GetRequiredSize() const;\n\n    WireResult Serialize(size_t commandSize, SerializeBuffer* serializeBuffer, const ObjectIdProvider& objectIdProvider) const;\n    // Override which produces a FatalError if any object is used.\n    WireResult Serialize(size_t commandSize, SerializeBuffer* serializeBuffer) const;\n\n    WireResult Deserialize(DeserializeBuffer* deserializeBuffer, DeserializeAllocator* allocator, const ObjectIdResolver& resolver);\n    // Override which produces a FatalError if any object is used.\n    WireResult Deserialize(DeserializeBuffer* deserializeBuffer, DeserializeAllocator* allocator);\n\n    ObjectId selfId;\n\n    WGPURenderBundleEncoder self;\n    uint32_t indexCount;\n    uint32_t instanceCount;\n    uint32_t firstIndex;\n    int32_t baseVertex;\n    uint32_t firstInstance;\n};\n\n    struct RenderBundleEncoderDrawIndexedIndirectCmd {\n    size_t GetRequiredSize() const;\n\n    WireResult Serialize(size_t commandSize, SerializeBuffer* serializeBuffer, const ObjectIdProvider& objectIdProvider) const;\n    // Override which produces a FatalError if any object is used.\n    WireResult Serialize(size_t commandSize, SerializeBuffer* serializeBuffer) const;\n\n    WireResult Deserialize(DeserializeBuffer* deserializeBuffer, DeserializeAllocator* allocator, const ObjectIdResolver& resolver);\n    // Override which produces a FatalError if any object is used.\n    WireResult Deserialize(DeserializeBuffer* deserializeBuffer, DeserializeAllocator* allocator);\n\n    ObjectId selfId;\n\n    WGPURenderBundleEncoder self;\n    WGPUBuffer indirectBuffer;\n    uint64_t indirectOffset;\n};\n\n    struct RenderBundleEncoderDrawIndirectCmd {\n    size_t GetRequiredSize() const;\n\n    WireResult Serialize(size_t commandSize, SerializeBuffer* serializeBuffer, const ObjectIdProvider& objectIdProvider) const;\n    // Override which produces a FatalError if any object is used.\n    WireResult Serialize(size_t commandSize, SerializeBuffer* serializeBuffer) const;\n\n    WireResult Deserialize(DeserializeBuffer* deserializeBuffer, DeserializeAllocator* allocator, const ObjectIdResolver& resolver);\n    // Override which produces a FatalError if any object is used.\n    WireResult Deserialize(DeserializeBuffer* deserializeBuffer, DeserializeAllocator* allocator);\n\n    ObjectId selfId;\n\n    WGPURenderBundleEncoder self;\n    WGPUBuffer indirectBuffer;\n    uint64_t indirectOffset;\n};\n\n    struct RenderBundleEncoderFinishCmd {\n    size_t GetRequiredSize() const;\n\n    WireResult Serialize(size_t commandSize, SerializeBuffer* serializeBuffer, const ObjectIdProvider& objectIdProvider) const;\n    // Override which produces a FatalError if any object is used.\n    WireResult Serialize(size_t commandSize, SerializeBuffer* serializeBuffer) const;\n\n    WireResult Deserialize(DeserializeBuffer* deserializeBuffer, DeserializeAllocator* allocator, const ObjectIdResolver& resolver);\n    // Override which produces a FatalError if any object is used.\n    WireResult Deserialize(DeserializeBuffer* deserializeBuffer, DeserializeAllocator* allocator);\n\n    ObjectId selfId;\n\n    WGPURenderBundleEncoder self;\n    WGPURenderBundleDescriptor const * descriptor;\n    ObjectHandle result;\n};\n\n    struct RenderBundleEncoderInsertDebugMarkerCmd {\n    size_t GetRequiredSize() const;\n\n    WireResult Serialize(size_t commandSize, SerializeBuffer* serializeBuffer, const ObjectIdProvider& objectIdProvider) const;\n    // Override which produces a FatalError if any object is used.\n    WireResult Serialize(size_t commandSize, SerializeBuffer* serializeBuffer) const;\n\n    WireResult Deserialize(DeserializeBuffer* deserializeBuffer, DeserializeAllocator* allocator, const ObjectIdResolver& resolver);\n    // Override which produces a FatalError if any object is used.\n    WireResult Deserialize(DeserializeBuffer* deserializeBuffer, DeserializeAllocator* allocator);\n\n    ObjectId selfId;\n\n    WGPURenderBundleEncoder self;\n    char const * markerLabel;\n};\n\n    struct RenderBundleEncoderPopDebugGroupCmd {\n    size_t GetRequiredSize() const;\n\n    WireResult Serialize(size_t commandSize, SerializeBuffer* serializeBuffer, const ObjectIdProvider& objectIdProvider) const;\n    // Override which produces a FatalError if any object is used.\n    WireResult Serialize(size_t commandSize, SerializeBuffer* serializeBuffer) const;\n\n    WireResult Deserialize(DeserializeBuffer* deserializeBuffer, DeserializeAllocator* allocator, const ObjectIdResolver& resolver);\n    // Override which produces a FatalError if any object is used.\n    WireResult Deserialize(DeserializeBuffer* deserializeBuffer, DeserializeAllocator* allocator);\n\n    ObjectId selfId;\n\n    WGPURenderBundleEncoder self;\n};\n\n    struct RenderBundleEncoderPushDebugGroupCmd {\n    size_t GetRequiredSize() const;\n\n    WireResult Serialize(size_t commandSize, SerializeBuffer* serializeBuffer, const ObjectIdProvider& objectIdProvider) const;\n    // Override which produces a FatalError if any object is used.\n    WireResult Serialize(size_t commandSize, SerializeBuffer* serializeBuffer) const;\n\n    WireResult Deserialize(DeserializeBuffer* deserializeBuffer, DeserializeAllocator* allocator, const ObjectIdResolver& resolver);\n    // Override which produces a FatalError if any object is used.\n    WireResult Deserialize(DeserializeBuffer* deserializeBuffer, DeserializeAllocator* allocator);\n\n    ObjectId selfId;\n\n    WGPURenderBundleEncoder self;\n    char const * groupLabel;\n};\n\n    struct RenderBundleEncoderSetBindGroupCmd {\n    size_t GetRequiredSize() const;\n\n    WireResult Serialize(size_t commandSize, SerializeBuffer* serializeBuffer, const ObjectIdProvider& objectIdProvider) const;\n    // Override which produces a FatalError if any object is used.\n    WireResult Serialize(size_t commandSize, SerializeBuffer* serializeBuffer) const;\n\n    WireResult Deserialize(DeserializeBuffer* deserializeBuffer, DeserializeAllocator* allocator, const ObjectIdResolver& resolver);\n    // Override which produces a FatalError if any object is used.\n    WireResult Deserialize(DeserializeBuffer* deserializeBuffer, DeserializeAllocator* allocator);\n\n    ObjectId selfId;\n\n    WGPURenderBundleEncoder self;\n    uint32_t groupIndex;\n    WGPUBindGroup group;\n    uint32_t dynamicOffsetCount;\n    uint32_t const * dynamicOffsets;\n};\n\n    struct RenderBundleEncoderSetIndexBufferCmd {\n    size_t GetRequiredSize() const;\n\n    WireResult Serialize(size_t commandSize, SerializeBuffer* serializeBuffer, const ObjectIdProvider& objectIdProvider) const;\n    // Override which produces a FatalError if any object is used.\n    WireResult Serialize(size_t commandSize, SerializeBuffer* serializeBuffer) const;\n\n    WireResult Deserialize(DeserializeBuffer* deserializeBuffer, DeserializeAllocator* allocator, const ObjectIdResolver& resolver);\n    // Override which produces a FatalError if any object is used.\n    WireResult Deserialize(DeserializeBuffer* deserializeBuffer, DeserializeAllocator* allocator);\n\n    ObjectId selfId;\n\n    WGPURenderBundleEncoder self;\n    WGPUBuffer buffer;\n    WGPUIndexFormat format;\n    uint64_t offset;\n    uint64_t size;\n};\n\n    struct RenderBundleEncoderSetLabelCmd {\n    size_t GetRequiredSize() const;\n\n    WireResult Serialize(size_t commandSize, SerializeBuffer* serializeBuffer, const ObjectIdProvider& objectIdProvider) const;\n    // Override which produces a FatalError if any object is used.\n    WireResult Serialize(size_t commandSize, SerializeBuffer* serializeBuffer) const;\n\n    WireResult Deserialize(DeserializeBuffer* deserializeBuffer, DeserializeAllocator* allocator, const ObjectIdResolver& resolver);\n    // Override which produces a FatalError if any object is used.\n    WireResult Deserialize(DeserializeBuffer* deserializeBuffer, DeserializeAllocator* allocator);\n\n    ObjectId selfId;\n\n    WGPURenderBundleEncoder self;\n    char const * label;\n};\n\n    struct RenderBundleEncoderSetPipelineCmd {\n    size_t GetRequiredSize() const;\n\n    WireResult Serialize(size_t commandSize, SerializeBuffer* serializeBuffer, const ObjectIdProvider& objectIdProvider) const;\n    // Override which produces a FatalError if any object is used.\n    WireResult Serialize(size_t commandSize, SerializeBuffer* serializeBuffer) const;\n\n    WireResult Deserialize(DeserializeBuffer* deserializeBuffer, DeserializeAllocator* allocator, const ObjectIdResolver& resolver);\n    // Override which produces a FatalError if any object is used.\n    WireResult Deserialize(DeserializeBuffer* deserializeBuffer, DeserializeAllocator* allocator);\n\n    ObjectId selfId;\n\n    WGPURenderBundleEncoder self;\n    WGPURenderPipeline pipeline;\n};\n\n    struct RenderBundleEncoderSetVertexBufferCmd {\n    size_t GetRequiredSize() const;\n\n    WireResult Serialize(size_t commandSize, SerializeBuffer* serializeBuffer, const ObjectIdProvider& objectIdProvider) const;\n    // Override which produces a FatalError if any object is used.\n    WireResult Serialize(size_t commandSize, SerializeBuffer* serializeBuffer) const;\n\n    WireResult Deserialize(DeserializeBuffer* deserializeBuffer, DeserializeAllocator* allocator, const ObjectIdResolver& resolver);\n    // Override which produces a FatalError if any object is used.\n    WireResult Deserialize(DeserializeBuffer* deserializeBuffer, DeserializeAllocator* allocator);\n\n    ObjectId selfId;\n\n    WGPURenderBundleEncoder self;\n    uint32_t slot;\n    WGPUBuffer buffer;\n    uint64_t offset;\n    uint64_t size;\n};\n\n    struct RenderPassEncoderBeginOcclusionQueryCmd {\n    size_t GetRequiredSize() const;\n\n    WireResult Serialize(size_t commandSize, SerializeBuffer* serializeBuffer, const ObjectIdProvider& objectIdProvider) const;\n    // Override which produces a FatalError if any object is used.\n    WireResult Serialize(size_t commandSize, SerializeBuffer* serializeBuffer) const;\n\n    WireResult Deserialize(DeserializeBuffer* deserializeBuffer, DeserializeAllocator* allocator, const ObjectIdResolver& resolver);\n    // Override which produces a FatalError if any object is used.\n    WireResult Deserialize(DeserializeBuffer* deserializeBuffer, DeserializeAllocator* allocator);\n\n    ObjectId selfId;\n\n    WGPURenderPassEncoder self;\n    uint32_t queryIndex;\n};\n\n    struct RenderPassEncoderDrawCmd {\n    size_t GetRequiredSize() const;\n\n    WireResult Serialize(size_t commandSize, SerializeBuffer* serializeBuffer, const ObjectIdProvider& objectIdProvider) const;\n    // Override which produces a FatalError if any object is used.\n    WireResult Serialize(size_t commandSize, SerializeBuffer* serializeBuffer) const;\n\n    WireResult Deserialize(DeserializeBuffer* deserializeBuffer, DeserializeAllocator* allocator, const ObjectIdResolver& resolver);\n    // Override which produces a FatalError if any object is used.\n    WireResult Deserialize(DeserializeBuffer* deserializeBuffer, DeserializeAllocator* allocator);\n\n    ObjectId selfId;\n\n    WGPURenderPassEncoder self;\n    uint32_t vertexCount;\n    uint32_t instanceCount;\n    uint32_t firstVertex;\n    uint32_t firstInstance;\n};\n\n    struct RenderPassEncoderDrawIndexedCmd {\n    size_t GetRequiredSize() const;\n\n    WireResult Serialize(size_t commandSize, SerializeBuffer* serializeBuffer, const ObjectIdProvider& objectIdProvider) const;\n    // Override which produces a FatalError if any object is used.\n    WireResult Serialize(size_t commandSize, SerializeBuffer* serializeBuffer) const;\n\n    WireResult Deserialize(DeserializeBuffer* deserializeBuffer, DeserializeAllocator* allocator, const ObjectIdResolver& resolver);\n    // Override which produces a FatalError if any object is used.\n    WireResult Deserialize(DeserializeBuffer* deserializeBuffer, DeserializeAllocator* allocator);\n\n    ObjectId selfId;\n\n    WGPURenderPassEncoder self;\n    uint32_t indexCount;\n    uint32_t instanceCount;\n    uint32_t firstIndex;\n    int32_t baseVertex;\n    uint32_t firstInstance;\n};\n\n    struct RenderPassEncoderDrawIndexedIndirectCmd {\n    size_t GetRequiredSize() const;\n\n    WireResult Serialize(size_t commandSize, SerializeBuffer* serializeBuffer, const ObjectIdProvider& objectIdProvider) const;\n    // Override which produces a FatalError if any object is used.\n    WireResult Serialize(size_t commandSize, SerializeBuffer* serializeBuffer) const;\n\n    WireResult Deserialize(DeserializeBuffer* deserializeBuffer, DeserializeAllocator* allocator, const ObjectIdResolver& resolver);\n    // Override which produces a FatalError if any object is used.\n    WireResult Deserialize(DeserializeBuffer* deserializeBuffer, DeserializeAllocator* allocator);\n\n    ObjectId selfId;\n\n    WGPURenderPassEncoder self;\n    WGPUBuffer indirectBuffer;\n    uint64_t indirectOffset;\n};\n\n    struct RenderPassEncoderDrawIndirectCmd {\n    size_t GetRequiredSize() const;\n\n    WireResult Serialize(size_t commandSize, SerializeBuffer* serializeBuffer, const ObjectIdProvider& objectIdProvider) const;\n    // Override which produces a FatalError if any object is used.\n    WireResult Serialize(size_t commandSize, SerializeBuffer* serializeBuffer) const;\n\n    WireResult Deserialize(DeserializeBuffer* deserializeBuffer, DeserializeAllocator* allocator, const ObjectIdResolver& resolver);\n    // Override which produces a FatalError if any object is used.\n    WireResult Deserialize(DeserializeBuffer* deserializeBuffer, DeserializeAllocator* allocator);\n\n    ObjectId selfId;\n\n    WGPURenderPassEncoder self;\n    WGPUBuffer indirectBuffer;\n    uint64_t indirectOffset;\n};\n\n    struct RenderPassEncoderEndCmd {\n    size_t GetRequiredSize() const;\n\n    WireResult Serialize(size_t commandSize, SerializeBuffer* serializeBuffer, const ObjectIdProvider& objectIdProvider) const;\n    // Override which produces a FatalError if any object is used.\n    WireResult Serialize(size_t commandSize, SerializeBuffer* serializeBuffer) const;\n\n    WireResult Deserialize(DeserializeBuffer* deserializeBuffer, DeserializeAllocator* allocator, const ObjectIdResolver& resolver);\n    // Override which produces a FatalError if any object is used.\n    WireResult Deserialize(DeserializeBuffer* deserializeBuffer, DeserializeAllocator* allocator);\n\n    ObjectId selfId;\n\n    WGPURenderPassEncoder self;\n};\n\n    struct RenderPassEncoderEndOcclusionQueryCmd {\n    size_t GetRequiredSize() const;\n\n    WireResult Serialize(size_t commandSize, SerializeBuffer* serializeBuffer, const ObjectIdProvider& objectIdProvider) const;\n    // Override which produces a FatalError if any object is used.\n    WireResult Serialize(size_t commandSize, SerializeBuffer* serializeBuffer) const;\n\n    WireResult Deserialize(DeserializeBuffer* deserializeBuffer, DeserializeAllocator* allocator, const ObjectIdResolver& resolver);\n    // Override which produces a FatalError if any object is used.\n    WireResult Deserialize(DeserializeBuffer* deserializeBuffer, DeserializeAllocator* allocator);\n\n    ObjectId selfId;\n\n    WGPURenderPassEncoder self;\n};\n\n    struct RenderPassEncoderEndPassCmd {\n    size_t GetRequiredSize() const;\n\n    WireResult Serialize(size_t commandSize, SerializeBuffer* serializeBuffer, const ObjectIdProvider& objectIdProvider) const;\n    // Override which produces a FatalError if any object is used.\n    WireResult Serialize(size_t commandSize, SerializeBuffer* serializeBuffer) const;\n\n    WireResult Deserialize(DeserializeBuffer* deserializeBuffer, DeserializeAllocator* allocator, const ObjectIdResolver& resolver);\n    // Override which produces a FatalError if any object is used.\n    WireResult Deserialize(DeserializeBuffer* deserializeBuffer, DeserializeAllocator* allocator);\n\n    ObjectId selfId;\n\n    WGPURenderPassEncoder self;\n};\n\n    struct RenderPassEncoderExecuteBundlesCmd {\n    size_t GetRequiredSize() const;\n\n    WireResult Serialize(size_t commandSize, SerializeBuffer* serializeBuffer, const ObjectIdProvider& objectIdProvider) const;\n    // Override which produces a FatalError if any object is used.\n    WireResult Serialize(size_t commandSize, SerializeBuffer* serializeBuffer) const;\n\n    WireResult Deserialize(DeserializeBuffer* deserializeBuffer, DeserializeAllocator* allocator, const ObjectIdResolver& resolver);\n    // Override which produces a FatalError if any object is used.\n    WireResult Deserialize(DeserializeBuffer* deserializeBuffer, DeserializeAllocator* allocator);\n\n    ObjectId selfId;\n\n    WGPURenderPassEncoder self;\n    uint32_t bundlesCount;\n    WGPURenderBundle const * bundles;\n};\n\n    struct RenderPassEncoderInsertDebugMarkerCmd {\n    size_t GetRequiredSize() const;\n\n    WireResult Serialize(size_t commandSize, SerializeBuffer* serializeBuffer, const ObjectIdProvider& objectIdProvider) const;\n    // Override which produces a FatalError if any object is used.\n    WireResult Serialize(size_t commandSize, SerializeBuffer* serializeBuffer) const;\n\n    WireResult Deserialize(DeserializeBuffer* deserializeBuffer, DeserializeAllocator* allocator, const ObjectIdResolver& resolver);\n    // Override which produces a FatalError if any object is used.\n    WireResult Deserialize(DeserializeBuffer* deserializeBuffer, DeserializeAllocator* allocator);\n\n    ObjectId selfId;\n\n    WGPURenderPassEncoder self;\n    char const * markerLabel;\n};\n\n    struct RenderPassEncoderPopDebugGroupCmd {\n    size_t GetRequiredSize() const;\n\n    WireResult Serialize(size_t commandSize, SerializeBuffer* serializeBuffer, const ObjectIdProvider& objectIdProvider) const;\n    // Override which produces a FatalError if any object is used.\n    WireResult Serialize(size_t commandSize, SerializeBuffer* serializeBuffer) const;\n\n    WireResult Deserialize(DeserializeBuffer* deserializeBuffer, DeserializeAllocator* allocator, const ObjectIdResolver& resolver);\n    // Override which produces a FatalError if any object is used.\n    WireResult Deserialize(DeserializeBuffer* deserializeBuffer, DeserializeAllocator* allocator);\n\n    ObjectId selfId;\n\n    WGPURenderPassEncoder self;\n};\n\n    struct RenderPassEncoderPushDebugGroupCmd {\n    size_t GetRequiredSize() const;\n\n    WireResult Serialize(size_t commandSize, SerializeBuffer* serializeBuffer, const ObjectIdProvider& objectIdProvider) const;\n    // Override which produces a FatalError if any object is used.\n    WireResult Serialize(size_t commandSize, SerializeBuffer* serializeBuffer) const;\n\n    WireResult Deserialize(DeserializeBuffer* deserializeBuffer, DeserializeAllocator* allocator, const ObjectIdResolver& resolver);\n    // Override which produces a FatalError if any object is used.\n    WireResult Deserialize(DeserializeBuffer* deserializeBuffer, DeserializeAllocator* allocator);\n\n    ObjectId selfId;\n\n    WGPURenderPassEncoder self;\n    char const * groupLabel;\n};\n\n    struct RenderPassEncoderSetBindGroupCmd {\n    size_t GetRequiredSize() const;\n\n    WireResult Serialize(size_t commandSize, SerializeBuffer* serializeBuffer, const ObjectIdProvider& objectIdProvider) const;\n    // Override which produces a FatalError if any object is used.\n    WireResult Serialize(size_t commandSize, SerializeBuffer* serializeBuffer) const;\n\n    WireResult Deserialize(DeserializeBuffer* deserializeBuffer, DeserializeAllocator* allocator, const ObjectIdResolver& resolver);\n    // Override which produces a FatalError if any object is used.\n    WireResult Deserialize(DeserializeBuffer* deserializeBuffer, DeserializeAllocator* allocator);\n\n    ObjectId selfId;\n\n    WGPURenderPassEncoder self;\n    uint32_t groupIndex;\n    WGPUBindGroup group;\n    uint32_t dynamicOffsetCount;\n    uint32_t const * dynamicOffsets;\n};\n\n    struct RenderPassEncoderSetBlendConstantCmd {\n    size_t GetRequiredSize() const;\n\n    WireResult Serialize(size_t commandSize, SerializeBuffer* serializeBuffer, const ObjectIdProvider& objectIdProvider) const;\n    // Override which produces a FatalError if any object is used.\n    WireResult Serialize(size_t commandSize, SerializeBuffer* serializeBuffer) const;\n\n    WireResult Deserialize(DeserializeBuffer* deserializeBuffer, DeserializeAllocator* allocator, const ObjectIdResolver& resolver);\n    // Override which produces a FatalError if any object is used.\n    WireResult Deserialize(DeserializeBuffer* deserializeBuffer, DeserializeAllocator* allocator);\n\n    ObjectId selfId;\n\n    WGPURenderPassEncoder self;\n    WGPUColor const * color;\n};\n\n    struct RenderPassEncoderSetIndexBufferCmd {\n    size_t GetRequiredSize() const;\n\n    WireResult Serialize(size_t commandSize, SerializeBuffer* serializeBuffer, const ObjectIdProvider& objectIdProvider) const;\n    // Override which produces a FatalError if any object is used.\n    WireResult Serialize(size_t commandSize, SerializeBuffer* serializeBuffer) const;\n\n    WireResult Deserialize(DeserializeBuffer* deserializeBuffer, DeserializeAllocator* allocator, const ObjectIdResolver& resolver);\n    // Override which produces a FatalError if any object is used.\n    WireResult Deserialize(DeserializeBuffer* deserializeBuffer, DeserializeAllocator* allocator);\n\n    ObjectId selfId;\n\n    WGPURenderPassEncoder self;\n    WGPUBuffer buffer;\n    WGPUIndexFormat format;\n    uint64_t offset;\n    uint64_t size;\n};\n\n    struct RenderPassEncoderSetLabelCmd {\n    size_t GetRequiredSize() const;\n\n    WireResult Serialize(size_t commandSize, SerializeBuffer* serializeBuffer, const ObjectIdProvider& objectIdProvider) const;\n    // Override which produces a FatalError if any object is used.\n    WireResult Serialize(size_t commandSize, SerializeBuffer* serializeBuffer) const;\n\n    WireResult Deserialize(DeserializeBuffer* deserializeBuffer, DeserializeAllocator* allocator, const ObjectIdResolver& resolver);\n    // Override which produces a FatalError if any object is used.\n    WireResult Deserialize(DeserializeBuffer* deserializeBuffer, DeserializeAllocator* allocator);\n\n    ObjectId selfId;\n\n    WGPURenderPassEncoder self;\n    char const * label;\n};\n\n    struct RenderPassEncoderSetPipelineCmd {\n    size_t GetRequiredSize() const;\n\n    WireResult Serialize(size_t commandSize, SerializeBuffer* serializeBuffer, const ObjectIdProvider& objectIdProvider) const;\n    // Override which produces a FatalError if any object is used.\n    WireResult Serialize(size_t commandSize, SerializeBuffer* serializeBuffer) const;\n\n    WireResult Deserialize(DeserializeBuffer* deserializeBuffer, DeserializeAllocator* allocator, const ObjectIdResolver& resolver);\n    // Override which produces a FatalError if any object is used.\n    WireResult Deserialize(DeserializeBuffer* deserializeBuffer, DeserializeAllocator* allocator);\n\n    ObjectId selfId;\n\n    WGPURenderPassEncoder self;\n    WGPURenderPipeline pipeline;\n};\n\n    struct RenderPassEncoderSetScissorRectCmd {\n    size_t GetRequiredSize() const;\n\n    WireResult Serialize(size_t commandSize, SerializeBuffer* serializeBuffer, const ObjectIdProvider& objectIdProvider) const;\n    // Override which produces a FatalError if any object is used.\n    WireResult Serialize(size_t commandSize, SerializeBuffer* serializeBuffer) const;\n\n    WireResult Deserialize(DeserializeBuffer* deserializeBuffer, DeserializeAllocator* allocator, const ObjectIdResolver& resolver);\n    // Override which produces a FatalError if any object is used.\n    WireResult Deserialize(DeserializeBuffer* deserializeBuffer, DeserializeAllocator* allocator);\n\n    ObjectId selfId;\n\n    WGPURenderPassEncoder self;\n    uint32_t x;\n    uint32_t y;\n    uint32_t width;\n    uint32_t height;\n};\n\n    struct RenderPassEncoderSetStencilReferenceCmd {\n    size_t GetRequiredSize() const;\n\n    WireResult Serialize(size_t commandSize, SerializeBuffer* serializeBuffer, const ObjectIdProvider& objectIdProvider) const;\n    // Override which produces a FatalError if any object is used.\n    WireResult Serialize(size_t commandSize, SerializeBuffer* serializeBuffer) const;\n\n    WireResult Deserialize(DeserializeBuffer* deserializeBuffer, DeserializeAllocator* allocator, const ObjectIdResolver& resolver);\n    // Override which produces a FatalError if any object is used.\n    WireResult Deserialize(DeserializeBuffer* deserializeBuffer, DeserializeAllocator* allocator);\n\n    ObjectId selfId;\n\n    WGPURenderPassEncoder self;\n    uint32_t reference;\n};\n\n    struct RenderPassEncoderSetVertexBufferCmd {\n    size_t GetRequiredSize() const;\n\n    WireResult Serialize(size_t commandSize, SerializeBuffer* serializeBuffer, const ObjectIdProvider& objectIdProvider) const;\n    // Override which produces a FatalError if any object is used.\n    WireResult Serialize(size_t commandSize, SerializeBuffer* serializeBuffer) const;\n\n    WireResult Deserialize(DeserializeBuffer* deserializeBuffer, DeserializeAllocator* allocator, const ObjectIdResolver& resolver);\n    // Override which produces a FatalError if any object is used.\n    WireResult Deserialize(DeserializeBuffer* deserializeBuffer, DeserializeAllocator* allocator);\n\n    ObjectId selfId;\n\n    WGPURenderPassEncoder self;\n    uint32_t slot;\n    WGPUBuffer buffer;\n    uint64_t offset;\n    uint64_t size;\n};\n\n    struct RenderPassEncoderSetViewportCmd {\n    size_t GetRequiredSize() const;\n\n    WireResult Serialize(size_t commandSize, SerializeBuffer* serializeBuffer, const ObjectIdProvider& objectIdProvider) const;\n    // Override which produces a FatalError if any object is used.\n    WireResult Serialize(size_t commandSize, SerializeBuffer* serializeBuffer) const;\n\n    WireResult Deserialize(DeserializeBuffer* deserializeBuffer, DeserializeAllocator* allocator, const ObjectIdResolver& resolver);\n    // Override which produces a FatalError if any object is used.\n    WireResult Deserialize(DeserializeBuffer* deserializeBuffer, DeserializeAllocator* allocator);\n\n    ObjectId selfId;\n\n    WGPURenderPassEncoder self;\n    float x;\n    float y;\n    float width;\n    float height;\n    float minDepth;\n    float maxDepth;\n};\n\n    struct RenderPassEncoderWriteTimestampCmd {\n    size_t GetRequiredSize() const;\n\n    WireResult Serialize(size_t commandSize, SerializeBuffer* serializeBuffer, const ObjectIdProvider& objectIdProvider) const;\n    // Override which produces a FatalError if any object is used.\n    WireResult Serialize(size_t commandSize, SerializeBuffer* serializeBuffer) const;\n\n    WireResult Deserialize(DeserializeBuffer* deserializeBuffer, DeserializeAllocator* allocator, const ObjectIdResolver& resolver);\n    // Override which produces a FatalError if any object is used.\n    WireResult Deserialize(DeserializeBuffer* deserializeBuffer, DeserializeAllocator* allocator);\n\n    ObjectId selfId;\n\n    WGPURenderPassEncoder self;\n    WGPUQuerySet querySet;\n    uint32_t queryIndex;\n};\n\n    struct RenderPipelineGetBindGroupLayoutCmd {\n    size_t GetRequiredSize() const;\n\n    WireResult Serialize(size_t commandSize, SerializeBuffer* serializeBuffer, const ObjectIdProvider& objectIdProvider) const;\n    // Override which produces a FatalError if any object is used.\n    WireResult Serialize(size_t commandSize, SerializeBuffer* serializeBuffer) const;\n\n    WireResult Deserialize(DeserializeBuffer* deserializeBuffer, DeserializeAllocator* allocator, const ObjectIdResolver& resolver);\n    // Override which produces a FatalError if any object is used.\n    WireResult Deserialize(DeserializeBuffer* deserializeBuffer, DeserializeAllocator* allocator);\n\n    ObjectId selfId;\n\n    WGPURenderPipeline self;\n    uint32_t groupIndex;\n    ObjectHandle result;\n};\n\n    struct RenderPipelineSetLabelCmd {\n    size_t GetRequiredSize() const;\n\n    WireResult Serialize(size_t commandSize, SerializeBuffer* serializeBuffer, const ObjectIdProvider& objectIdProvider) const;\n    // Override which produces a FatalError if any object is used.\n    WireResult Serialize(size_t commandSize, SerializeBuffer* serializeBuffer) const;\n\n    WireResult Deserialize(DeserializeBuffer* deserializeBuffer, DeserializeAllocator* allocator, const ObjectIdResolver& resolver);\n    // Override which produces a FatalError if any object is used.\n    WireResult Deserialize(DeserializeBuffer* deserializeBuffer, DeserializeAllocator* allocator);\n\n    ObjectId selfId;\n\n    WGPURenderPipeline self;\n    char const * label;\n};\n\n    struct SamplerSetLabelCmd {\n    size_t GetRequiredSize() const;\n\n    WireResult Serialize(size_t commandSize, SerializeBuffer* serializeBuffer, const ObjectIdProvider& objectIdProvider) const;\n    // Override which produces a FatalError if any object is used.\n    WireResult Serialize(size_t commandSize, SerializeBuffer* serializeBuffer) const;\n\n    WireResult Deserialize(DeserializeBuffer* deserializeBuffer, DeserializeAllocator* allocator, const ObjectIdResolver& resolver);\n    // Override which produces a FatalError if any object is used.\n    WireResult Deserialize(DeserializeBuffer* deserializeBuffer, DeserializeAllocator* allocator);\n\n    ObjectId selfId;\n\n    WGPUSampler self;\n    char const * label;\n};\n\n    struct ShaderModuleGetCompilationInfoCmd {\n    size_t GetRequiredSize() const;\n\n    WireResult Serialize(size_t commandSize, SerializeBuffer* serializeBuffer, const ObjectIdProvider& objectIdProvider) const;\n    // Override which produces a FatalError if any object is used.\n    WireResult Serialize(size_t commandSize, SerializeBuffer* serializeBuffer) const;\n\n    WireResult Deserialize(DeserializeBuffer* deserializeBuffer, DeserializeAllocator* allocator, const ObjectIdResolver& resolver);\n    // Override which produces a FatalError if any object is used.\n    WireResult Deserialize(DeserializeBuffer* deserializeBuffer, DeserializeAllocator* allocator);\n\n\n    ObjectId shaderModuleId;\n    uint64_t requestSerial;\n};\n\n    struct ShaderModuleSetLabelCmd {\n    size_t GetRequiredSize() const;\n\n    WireResult Serialize(size_t commandSize, SerializeBuffer* serializeBuffer, const ObjectIdProvider& objectIdProvider) const;\n    // Override which produces a FatalError if any object is used.\n    WireResult Serialize(size_t commandSize, SerializeBuffer* serializeBuffer) const;\n\n    WireResult Deserialize(DeserializeBuffer* deserializeBuffer, DeserializeAllocator* allocator, const ObjectIdResolver& resolver);\n    // Override which produces a FatalError if any object is used.\n    WireResult Deserialize(DeserializeBuffer* deserializeBuffer, DeserializeAllocator* allocator);\n\n    ObjectId selfId;\n\n    WGPUShaderModule self;\n    char const * label;\n};\n\n    struct SwapChainConfigureCmd {\n    size_t GetRequiredSize() const;\n\n    WireResult Serialize(size_t commandSize, SerializeBuffer* serializeBuffer, const ObjectIdProvider& objectIdProvider) const;\n    // Override which produces a FatalError if any object is used.\n    WireResult Serialize(size_t commandSize, SerializeBuffer* serializeBuffer) const;\n\n    WireResult Deserialize(DeserializeBuffer* deserializeBuffer, DeserializeAllocator* allocator, const ObjectIdResolver& resolver);\n    // Override which produces a FatalError if any object is used.\n    WireResult Deserialize(DeserializeBuffer* deserializeBuffer, DeserializeAllocator* allocator);\n\n    ObjectId selfId;\n\n    WGPUSwapChain self;\n    WGPUTextureFormat format;\n    WGPUTextureUsageFlags allowedUsage;\n    uint32_t width;\n    uint32_t height;\n};\n\n    struct SwapChainGetCurrentTextureViewCmd {\n    size_t GetRequiredSize() const;\n\n    WireResult Serialize(size_t commandSize, SerializeBuffer* serializeBuffer, const ObjectIdProvider& objectIdProvider) const;\n    // Override which produces a FatalError if any object is used.\n    WireResult Serialize(size_t commandSize, SerializeBuffer* serializeBuffer) const;\n\n    WireResult Deserialize(DeserializeBuffer* deserializeBuffer, DeserializeAllocator* allocator, const ObjectIdResolver& resolver);\n    // Override which produces a FatalError if any object is used.\n    WireResult Deserialize(DeserializeBuffer* deserializeBuffer, DeserializeAllocator* allocator);\n\n    ObjectId selfId;\n\n    WGPUSwapChain self;\n    ObjectHandle result;\n};\n\n    struct SwapChainPresentCmd {\n    size_t GetRequiredSize() const;\n\n    WireResult Serialize(size_t commandSize, SerializeBuffer* serializeBuffer, const ObjectIdProvider& objectIdProvider) const;\n    // Override which produces a FatalError if any object is used.\n    WireResult Serialize(size_t commandSize, SerializeBuffer* serializeBuffer) const;\n\n    WireResult Deserialize(DeserializeBuffer* deserializeBuffer, DeserializeAllocator* allocator, const ObjectIdResolver& resolver);\n    // Override which produces a FatalError if any object is used.\n    WireResult Deserialize(DeserializeBuffer* deserializeBuffer, DeserializeAllocator* allocator);\n\n    ObjectId selfId;\n\n    WGPUSwapChain self;\n};\n\n    struct TextureCreateViewCmd {\n    size_t GetRequiredSize() const;\n\n    WireResult Serialize(size_t commandSize, SerializeBuffer* serializeBuffer, const ObjectIdProvider& objectIdProvider) const;\n    // Override which produces a FatalError if any object is used.\n    WireResult Serialize(size_t commandSize, SerializeBuffer* serializeBuffer) const;\n\n    WireResult Deserialize(DeserializeBuffer* deserializeBuffer, DeserializeAllocator* allocator, const ObjectIdResolver& resolver);\n    // Override which produces a FatalError if any object is used.\n    WireResult Deserialize(DeserializeBuffer* deserializeBuffer, DeserializeAllocator* allocator);\n\n    ObjectId selfId;\n\n    WGPUTexture self;\n    WGPUTextureViewDescriptor const * descriptor;\n    ObjectHandle result;\n};\n\n    struct TextureDestroyCmd {\n    size_t GetRequiredSize() const;\n\n    WireResult Serialize(size_t commandSize, SerializeBuffer* serializeBuffer, const ObjectIdProvider& objectIdProvider) const;\n    // Override which produces a FatalError if any object is used.\n    WireResult Serialize(size_t commandSize, SerializeBuffer* serializeBuffer) const;\n\n    WireResult Deserialize(DeserializeBuffer* deserializeBuffer, DeserializeAllocator* allocator, const ObjectIdResolver& resolver);\n    // Override which produces a FatalError if any object is used.\n    WireResult Deserialize(DeserializeBuffer* deserializeBuffer, DeserializeAllocator* allocator);\n\n    ObjectId selfId;\n\n    WGPUTexture self;\n};\n\n    struct TextureSetLabelCmd {\n    size_t GetRequiredSize() const;\n\n    WireResult Serialize(size_t commandSize, SerializeBuffer* serializeBuffer, const ObjectIdProvider& objectIdProvider) const;\n    // Override which produces a FatalError if any object is used.\n    WireResult Serialize(size_t commandSize, SerializeBuffer* serializeBuffer) const;\n\n    WireResult Deserialize(DeserializeBuffer* deserializeBuffer, DeserializeAllocator* allocator, const ObjectIdResolver& resolver);\n    // Override which produces a FatalError if any object is used.\n    WireResult Deserialize(DeserializeBuffer* deserializeBuffer, DeserializeAllocator* allocator);\n\n    ObjectId selfId;\n\n    WGPUTexture self;\n    char const * label;\n};\n\n    struct TextureViewSetLabelCmd {\n    size_t GetRequiredSize() const;\n\n    WireResult Serialize(size_t commandSize, SerializeBuffer* serializeBuffer, const ObjectIdProvider& objectIdProvider) const;\n    // Override which produces a FatalError if any object is used.\n    WireResult Serialize(size_t commandSize, SerializeBuffer* serializeBuffer) const;\n\n    WireResult Deserialize(DeserializeBuffer* deserializeBuffer, DeserializeAllocator* allocator, const ObjectIdResolver& resolver);\n    // Override which produces a FatalError if any object is used.\n    WireResult Deserialize(DeserializeBuffer* deserializeBuffer, DeserializeAllocator* allocator);\n\n    ObjectId selfId;\n\n    WGPUTextureView self;\n    char const * label;\n};\n\n\n    struct ReturnAdapterRequestDeviceCallbackCmd {\n    size_t GetRequiredSize() const;\n\n    WireResult Serialize(size_t commandSize, SerializeBuffer* serializeBuffer, const ObjectIdProvider& objectIdProvider) const;\n    // Override which produces a FatalError if any object is used.\n    WireResult Serialize(size_t commandSize, SerializeBuffer* serializeBuffer) const;\n\n    WireResult Deserialize(DeserializeBuffer* deserializeBuffer, DeserializeAllocator* allocator, const ObjectIdResolver& resolver);\n    // Override which produces a FatalError if any object is used.\n    WireResult Deserialize(DeserializeBuffer* deserializeBuffer, DeserializeAllocator* allocator);\n\n\n    ObjectHandle adapter;\n    uint64_t requestSerial;\n    WGPURequestDeviceStatus status;\n    char const * message;\n    WGPUSupportedLimits const * limits;\n    uint32_t featuresCount;\n    WGPUFeatureName const * features;\n};\n\n    struct ReturnBufferMapAsyncCallbackCmd {\n    size_t GetRequiredSize() const;\n\n    WireResult Serialize(size_t commandSize, SerializeBuffer* serializeBuffer, const ObjectIdProvider& objectIdProvider) const;\n    // Override which produces a FatalError if any object is used.\n    WireResult Serialize(size_t commandSize, SerializeBuffer* serializeBuffer) const;\n\n    WireResult Deserialize(DeserializeBuffer* deserializeBuffer, DeserializeAllocator* allocator, const ObjectIdResolver& resolver);\n    // Override which produces a FatalError if any object is used.\n    WireResult Deserialize(DeserializeBuffer* deserializeBuffer, DeserializeAllocator* allocator);\n\n\n    ObjectHandle buffer;\n    uint64_t requestSerial;\n    uint32_t status;\n    uint64_t readDataUpdateInfoLength;\n    uint8_t const * readDataUpdateInfo;\n};\n\n    struct ReturnDeviceCreateComputePipelineAsyncCallbackCmd {\n    size_t GetRequiredSize() const;\n\n    WireResult Serialize(size_t commandSize, SerializeBuffer* serializeBuffer, const ObjectIdProvider& objectIdProvider) const;\n    // Override which produces a FatalError if any object is used.\n    WireResult Serialize(size_t commandSize, SerializeBuffer* serializeBuffer) const;\n\n    WireResult Deserialize(DeserializeBuffer* deserializeBuffer, DeserializeAllocator* allocator, const ObjectIdResolver& resolver);\n    // Override which produces a FatalError if any object is used.\n    WireResult Deserialize(DeserializeBuffer* deserializeBuffer, DeserializeAllocator* allocator);\n\n\n    ObjectHandle device;\n    uint64_t requestSerial;\n    WGPUCreatePipelineAsyncStatus status;\n    char const * message;\n};\n\n    struct ReturnDeviceCreateRenderPipelineAsyncCallbackCmd {\n    size_t GetRequiredSize() const;\n\n    WireResult Serialize(size_t commandSize, SerializeBuffer* serializeBuffer, const ObjectIdProvider& objectIdProvider) const;\n    // Override which produces a FatalError if any object is used.\n    WireResult Serialize(size_t commandSize, SerializeBuffer* serializeBuffer) const;\n\n    WireResult Deserialize(DeserializeBuffer* deserializeBuffer, DeserializeAllocator* allocator, const ObjectIdResolver& resolver);\n    // Override which produces a FatalError if any object is used.\n    WireResult Deserialize(DeserializeBuffer* deserializeBuffer, DeserializeAllocator* allocator);\n\n\n    ObjectHandle device;\n    uint64_t requestSerial;\n    WGPUCreatePipelineAsyncStatus status;\n    char const * message;\n};\n\n    struct ReturnDeviceLoggingCallbackCmd {\n    size_t GetRequiredSize() const;\n\n    WireResult Serialize(size_t commandSize, SerializeBuffer* serializeBuffer, const ObjectIdProvider& objectIdProvider) const;\n    // Override which produces a FatalError if any object is used.\n    WireResult Serialize(size_t commandSize, SerializeBuffer* serializeBuffer) const;\n\n    WireResult Deserialize(DeserializeBuffer* deserializeBuffer, DeserializeAllocator* allocator, const ObjectIdResolver& resolver);\n    // Override which produces a FatalError if any object is used.\n    WireResult Deserialize(DeserializeBuffer* deserializeBuffer, DeserializeAllocator* allocator);\n\n\n    ObjectHandle device;\n    WGPULoggingType type;\n    char const * message;\n};\n\n    struct ReturnDeviceLostCallbackCmd {\n    size_t GetRequiredSize() const;\n\n    WireResult Serialize(size_t commandSize, SerializeBuffer* serializeBuffer, const ObjectIdProvider& objectIdProvider) const;\n    // Override which produces a FatalError if any object is used.\n    WireResult Serialize(size_t commandSize, SerializeBuffer* serializeBuffer) const;\n\n    WireResult Deserialize(DeserializeBuffer* deserializeBuffer, DeserializeAllocator* allocator, const ObjectIdResolver& resolver);\n    // Override which produces a FatalError if any object is used.\n    WireResult Deserialize(DeserializeBuffer* deserializeBuffer, DeserializeAllocator* allocator);\n\n\n    ObjectHandle device;\n    WGPUDeviceLostReason reason;\n    char const * message;\n};\n\n    struct ReturnDevicePopErrorScopeCallbackCmd {\n    size_t GetRequiredSize() const;\n\n    WireResult Serialize(size_t commandSize, SerializeBuffer* serializeBuffer, const ObjectIdProvider& objectIdProvider) const;\n    // Override which produces a FatalError if any object is used.\n    WireResult Serialize(size_t commandSize, SerializeBuffer* serializeBuffer) const;\n\n    WireResult Deserialize(DeserializeBuffer* deserializeBuffer, DeserializeAllocator* allocator, const ObjectIdResolver& resolver);\n    // Override which produces a FatalError if any object is used.\n    WireResult Deserialize(DeserializeBuffer* deserializeBuffer, DeserializeAllocator* allocator);\n\n\n    ObjectHandle device;\n    uint64_t requestSerial;\n    WGPUErrorType type;\n    char const * message;\n};\n\n    struct ReturnDeviceUncapturedErrorCallbackCmd {\n    size_t GetRequiredSize() const;\n\n    WireResult Serialize(size_t commandSize, SerializeBuffer* serializeBuffer, const ObjectIdProvider& objectIdProvider) const;\n    // Override which produces a FatalError if any object is used.\n    WireResult Serialize(size_t commandSize, SerializeBuffer* serializeBuffer) const;\n\n    WireResult Deserialize(DeserializeBuffer* deserializeBuffer, DeserializeAllocator* allocator, const ObjectIdResolver& resolver);\n    // Override which produces a FatalError if any object is used.\n    WireResult Deserialize(DeserializeBuffer* deserializeBuffer, DeserializeAllocator* allocator);\n\n\n    ObjectHandle device;\n    WGPUErrorType type;\n    char const * message;\n};\n\n    struct ReturnInstanceRequestAdapterCallbackCmd {\n    size_t GetRequiredSize() const;\n\n    WireResult Serialize(size_t commandSize, SerializeBuffer* serializeBuffer, const ObjectIdProvider& objectIdProvider) const;\n    // Override which produces a FatalError if any object is used.\n    WireResult Serialize(size_t commandSize, SerializeBuffer* serializeBuffer) const;\n\n    WireResult Deserialize(DeserializeBuffer* deserializeBuffer, DeserializeAllocator* allocator, const ObjectIdResolver& resolver);\n    // Override which produces a FatalError if any object is used.\n    WireResult Deserialize(DeserializeBuffer* deserializeBuffer, DeserializeAllocator* allocator);\n\n\n    ObjectHandle instance;\n    uint64_t requestSerial;\n    WGPURequestAdapterStatus status;\n    char const * message;\n    WGPUAdapterProperties const * properties;\n    WGPUSupportedLimits const * limits;\n    uint32_t featuresCount;\n    WGPUFeatureName const * features;\n};\n\n    struct ReturnQueueWorkDoneCallbackCmd {\n    size_t GetRequiredSize() const;\n\n    WireResult Serialize(size_t commandSize, SerializeBuffer* serializeBuffer, const ObjectIdProvider& objectIdProvider) const;\n    // Override which produces a FatalError if any object is used.\n    WireResult Serialize(size_t commandSize, SerializeBuffer* serializeBuffer) const;\n\n    WireResult Deserialize(DeserializeBuffer* deserializeBuffer, DeserializeAllocator* allocator, const ObjectIdResolver& resolver);\n    // Override which produces a FatalError if any object is used.\n    WireResult Deserialize(DeserializeBuffer* deserializeBuffer, DeserializeAllocator* allocator);\n\n\n    ObjectHandle queue;\n    uint64_t requestSerial;\n    WGPUQueueWorkDoneStatus status;\n};\n\n    struct ReturnShaderModuleGetCompilationInfoCallbackCmd {\n    size_t GetRequiredSize() const;\n\n    WireResult Serialize(size_t commandSize, SerializeBuffer* serializeBuffer, const ObjectIdProvider& objectIdProvider) const;\n    // Override which produces a FatalError if any object is used.\n    WireResult Serialize(size_t commandSize, SerializeBuffer* serializeBuffer) const;\n\n    WireResult Deserialize(DeserializeBuffer* deserializeBuffer, DeserializeAllocator* allocator, const ObjectIdResolver& resolver);\n    // Override which produces a FatalError if any object is used.\n    WireResult Deserialize(DeserializeBuffer* deserializeBuffer, DeserializeAllocator* allocator);\n\n\n    ObjectHandle shaderModule;\n    uint64_t requestSerial;\n    WGPUCompilationInfoRequestStatus status;\n    WGPUCompilationInfo const * info;\n};\n\n\n}  // namespace dawn::wire\n\n#endif // DAWNWIRE_WIRECMD_AUTOGEN_H_\n", "src/dawn/wire/WireCmd_autogen.cpp": "\n#include \"dawn/wire/WireCmd_autogen.h\"\n\n#include \"dawn/common/Assert.h\"\n#include \"dawn/common/Log.h\"\n#include \"dawn/wire/BufferConsumer_impl.h\"\n#include \"dawn/wire/Wire.h\"\n\n#include <algorithm>\n#include <cstring>\n#include <limits>\n\n#ifdef __GNUC__\n// error: 'offsetof' within non-standard-layout type 'wgpu::XXX' is conditionally-supported\n#pragma GCC diagnostic ignored \"-Winvalid-offsetof\"\n#endif\n\n\n\n\n\n\n\n\n\n\nnamespace dawn::wire {\n\n    namespace {\n        // Allocates enough space from allocator to countain T[count] and return it in out.\n        // Return FatalError if the allocator couldn't allocate the memory.\n        // Always writes to |out| on success.\n        template <typename T, typename N>\n        WireResult GetSpace(DeserializeAllocator* allocator, N count, T** out) {\n            constexpr size_t kMaxCountWithoutOverflows = std::numeric_limits<size_t>::max() / sizeof(T);\n            if (count > kMaxCountWithoutOverflows) {\n                return WireResult::FatalError;\n            }\n\n            size_t totalSize = sizeof(T) * count;\n            *out = static_cast<T*>(allocator->GetSpace(totalSize));\n            if (*out == nullptr) {\n                return WireResult::FatalError;\n            }\n\n            return WireResult::Success;\n        }\n\n        struct WGPUChainedStructTransfer {\n            WGPUSType sType;\n            bool hasNext;\n        };\n\n        size_t GetChainedStructExtraRequiredSize(const WGPUChainedStruct* chainedStruct);\n        [[nodiscard]] WireResult SerializeChainedStruct(const WGPUChainedStruct* chainedStruct,\n                                                          SerializeBuffer* buffer,\n                                                          const ObjectIdProvider& provider);\n        WireResult DeserializeChainedStruct(const WGPUChainedStruct** outChainNext,\n                                            DeserializeBuffer* deserializeBuffer,\n                                            DeserializeAllocator* allocator,\n                                            const ObjectIdResolver& resolver);\n\n        size_t GetChainedStructExtraRequiredSize(WGPUChainedStructOut* chainedStruct);\n        [[nodiscard]] WireResult SerializeChainedStruct(WGPUChainedStructOut* chainedStruct,\n                                                          SerializeBuffer* buffer,\n                                                          const ObjectIdProvider& provider);\n        WireResult DeserializeChainedStruct(WGPUChainedStructOut** outChainNext,\n                                            DeserializeBuffer* deserializeBuffer,\n                                            DeserializeAllocator* allocator,\n                                            const ObjectIdResolver& resolver);\n\n                \nstruct WGPUAdapterPropertiesTransfer {\n    static_assert(0 <= 1,\n                  \"Record must be at most one of is_cmd, extensible, and chained.\");\n    bool hasNextInChain;\n\n    \nuint32_t vendorID;\n    \nuint32_t deviceID;\n    \nWGPUAdapterType adapterType;\n    \nWGPUBackendType backendType;\n\n    uint64_t vendorNameStrlen;\n    uint64_t architectureStrlen;\n    uint64_t nameStrlen;\n    uint64_t driverDescriptionStrlen;\n\n};\n\n\n\nDAWN_DECLARE_UNUSED size_t WGPUAdapterPropertiesGetExtraRequiredSize(const WGPUAdapterProperties& record) {\n    DAWN_UNUSED(record);\n\n    size_t result = 0;\n\n    if (record.nextInChain != nullptr) {\n        result += GetChainedStructExtraRequiredSize(record.nextInChain);\n    }\n\n\n    {\n    result += std::strlen(record.vendorName);\n    }\n\n    {\n    result += std::strlen(record.architecture);\n    }\n\n    {\n    result += std::strlen(record.name);\n    }\n\n    {\n    result += std::strlen(record.driverDescription);\n    }\n\n    {\n    }\n    {\n    }\n    {\n    }\n    {\n    }\n\n    return result;\n}\n// GetExtraRequiredSize isn't used for structures that are value members of other structures\n// because we assume they cannot contain pointers themselves.\nDAWN_UNUSED_FUNC(WGPUAdapterPropertiesGetExtraRequiredSize);\n\nDAWN_DECLARE_UNUSED WireResult WGPUAdapterPropertiesSerialize(\n    const WGPUAdapterProperties& record,\n    WGPUAdapterPropertiesTransfer* transfer,\n    SerializeBuffer* buffer, const ObjectIdProvider& provider) {\n    DAWN_UNUSED(buffer);\n\n\n    transfer->vendorID = record.vendorID;\n    transfer->deviceID = record.deviceID;\n    transfer->adapterType = record.adapterType;\n    transfer->backendType = record.backendType;\n\n    if (record.nextInChain != nullptr) {\n        transfer->hasNextInChain = true;\n        WIRE_TRY(SerializeChainedStruct(record.nextInChain, buffer, provider));\n    } else {\n        transfer->hasNextInChain = false;\n    }\n\n\n\n    {\n        transfer->vendorNameStrlen = std::strlen(record.vendorName);\n\n        char* stringInBuffer;\n        WIRE_TRY(buffer->NextN(transfer->vendorNameStrlen, &stringInBuffer));\n        memcpy(stringInBuffer, record.vendorName, transfer->vendorNameStrlen);\n    }\n\n    {\n        transfer->architectureStrlen = std::strlen(record.architecture);\n\n        char* stringInBuffer;\n        WIRE_TRY(buffer->NextN(transfer->architectureStrlen, &stringInBuffer));\n        memcpy(stringInBuffer, record.architecture, transfer->architectureStrlen);\n    }\n\n    {\n        transfer->nameStrlen = std::strlen(record.name);\n\n        char* stringInBuffer;\n        WIRE_TRY(buffer->NextN(transfer->nameStrlen, &stringInBuffer));\n        memcpy(stringInBuffer, record.name, transfer->nameStrlen);\n    }\n\n    {\n        transfer->driverDescriptionStrlen = std::strlen(record.driverDescription);\n\n        char* stringInBuffer;\n        WIRE_TRY(buffer->NextN(transfer->driverDescriptionStrlen, &stringInBuffer));\n        memcpy(stringInBuffer, record.driverDescription, transfer->driverDescriptionStrlen);\n    }\n\n    return WireResult::Success;\n}\nDAWN_UNUSED_FUNC(WGPUAdapterPropertiesSerialize);\n\nDAWN_DECLARE_UNUSED WireResult WGPUAdapterPropertiesDeserialize(\n    WGPUAdapterProperties* record,\n    const volatile WGPUAdapterPropertiesTransfer* transfer,\n    DeserializeBuffer* deserializeBuffer,\n    DeserializeAllocator* allocator, const ObjectIdResolver& resolver) {\n    DAWN_UNUSED(allocator);\n\n\n\n    static_assert(sizeof(record->vendorID) >= sizeof(transfer->vendorID), \"Deserialize assignment may not narrow.\");\nrecord->vendorID = transfer->vendorID;\n    static_assert(sizeof(record->deviceID) >= sizeof(transfer->deviceID), \"Deserialize assignment may not narrow.\");\nrecord->deviceID = transfer->deviceID;\n    static_assert(sizeof(record->adapterType) >= sizeof(transfer->adapterType), \"Deserialize assignment may not narrow.\");\nrecord->adapterType = transfer->adapterType;\n    static_assert(sizeof(record->backendType) >= sizeof(transfer->backendType), \"Deserialize assignment may not narrow.\");\nrecord->backendType = transfer->backendType;\n\n    record->nextInChain = nullptr;\n    if (transfer->hasNextInChain) {\n        WIRE_TRY(DeserializeChainedStruct(&record->nextInChain, deserializeBuffer, allocator, resolver));\n    }\n\n\n\n    {\n        uint64_t stringLength64 = transfer->vendorNameStrlen;\n        if (stringLength64 >= std::numeric_limits<size_t>::max()) {\n            return WireResult::FatalError;\n        }\n        size_t stringLength = static_cast<size_t>(stringLength64);\n\n        const volatile char* stringInBuffer;\n        WIRE_TRY(deserializeBuffer->ReadN(stringLength, &stringInBuffer));\n\n        char* copiedString;\n        WIRE_TRY(GetSpace(allocator, stringLength + 1, &copiedString));\n        memcpy(copiedString, const_cast<const char*>(stringInBuffer), stringLength);\n        copiedString[stringLength] = '\\0';\n        record->vendorName = copiedString;\n    }\n\n    {\n        uint64_t stringLength64 = transfer->architectureStrlen;\n        if (stringLength64 >= std::numeric_limits<size_t>::max()) {\n            return WireResult::FatalError;\n        }\n        size_t stringLength = static_cast<size_t>(stringLength64);\n\n        const volatile char* stringInBuffer;\n        WIRE_TRY(deserializeBuffer->ReadN(stringLength, &stringInBuffer));\n\n        char* copiedString;\n        WIRE_TRY(GetSpace(allocator, stringLength + 1, &copiedString));\n        memcpy(copiedString, const_cast<const char*>(stringInBuffer), stringLength);\n        copiedString[stringLength] = '\\0';\n        record->architecture = copiedString;\n    }\n\n    {\n        uint64_t stringLength64 = transfer->nameStrlen;\n        if (stringLength64 >= std::numeric_limits<size_t>::max()) {\n            return WireResult::FatalError;\n        }\n        size_t stringLength = static_cast<size_t>(stringLength64);\n\n        const volatile char* stringInBuffer;\n        WIRE_TRY(deserializeBuffer->ReadN(stringLength, &stringInBuffer));\n\n        char* copiedString;\n        WIRE_TRY(GetSpace(allocator, stringLength + 1, &copiedString));\n        memcpy(copiedString, const_cast<const char*>(stringInBuffer), stringLength);\n        copiedString[stringLength] = '\\0';\n        record->name = copiedString;\n    }\n\n    {\n        uint64_t stringLength64 = transfer->driverDescriptionStrlen;\n        if (stringLength64 >= std::numeric_limits<size_t>::max()) {\n            return WireResult::FatalError;\n        }\n        size_t stringLength = static_cast<size_t>(stringLength64);\n\n        const volatile char* stringInBuffer;\n        WIRE_TRY(deserializeBuffer->ReadN(stringLength, &stringInBuffer));\n\n        char* copiedString;\n        WIRE_TRY(GetSpace(allocator, stringLength + 1, &copiedString));\n        memcpy(copiedString, const_cast<const char*>(stringInBuffer), stringLength);\n        copiedString[stringLength] = '\\0';\n        record->driverDescription = copiedString;\n    }\n\n\n    return WireResult::Success;\n}\nDAWN_UNUSED_FUNC(WGPUAdapterPropertiesDeserialize);\n\n                \nstruct WGPUBindGroupEntryTransfer {\n    static_assert(0 <= 1,\n                  \"Record must be at most one of is_cmd, extensible, and chained.\");\n    bool hasNextInChain;\n\n    \nuint32_t binding;\n    ObjectId buffer;\n    \nuint64_t offset;\n    \nuint64_t size;\n    ObjectId sampler;\n    ObjectId textureView;\n\n\n};\n\n\n\nDAWN_DECLARE_UNUSED size_t WGPUBindGroupEntryGetExtraRequiredSize(const WGPUBindGroupEntry& record) {\n    DAWN_UNUSED(record);\n\n    size_t result = 0;\n\n    if (record.nextInChain != nullptr) {\n        result += GetChainedStructExtraRequiredSize(record.nextInChain);\n    }\n\n\n    {\n    }\n    {\n    }\n    {\n    }\n    {\n    }\n    {\n    }\n    {\n    }\n\n    return result;\n}\n// GetExtraRequiredSize isn't used for structures that are value members of other structures\n// because we assume they cannot contain pointers themselves.\nDAWN_UNUSED_FUNC(WGPUBindGroupEntryGetExtraRequiredSize);\n\nDAWN_DECLARE_UNUSED WireResult WGPUBindGroupEntrySerialize(\n    const WGPUBindGroupEntry& record,\n    WGPUBindGroupEntryTransfer* transfer,\n    SerializeBuffer* buffer, const ObjectIdProvider& provider) {\n    DAWN_UNUSED(buffer);\n\n\n    transfer->binding = record.binding;\n    WIRE_TRY(provider.GetOptionalId(record.buffer, &transfer->buffer));\n    transfer->offset = record.offset;\n    transfer->size = record.size;\n    WIRE_TRY(provider.GetOptionalId(record.sampler, &transfer->sampler));\n    WIRE_TRY(provider.GetOptionalId(record.textureView, &transfer->textureView));\n\n    if (record.nextInChain != nullptr) {\n        transfer->hasNextInChain = true;\n        WIRE_TRY(SerializeChainedStruct(record.nextInChain, buffer, provider));\n    } else {\n        transfer->hasNextInChain = false;\n    }\n\n\n\n    return WireResult::Success;\n}\nDAWN_UNUSED_FUNC(WGPUBindGroupEntrySerialize);\n\nDAWN_DECLARE_UNUSED WireResult WGPUBindGroupEntryDeserialize(\n    WGPUBindGroupEntry* record,\n    const volatile WGPUBindGroupEntryTransfer* transfer,\n    DeserializeBuffer* deserializeBuffer,\n    DeserializeAllocator* allocator, const ObjectIdResolver& resolver) {\n    DAWN_UNUSED(allocator);\n\n\n\n    static_assert(sizeof(record->binding) >= sizeof(transfer->binding), \"Deserialize assignment may not narrow.\");\nrecord->binding = transfer->binding;\n    WIRE_TRY(resolver.GetOptionalFromId(transfer->buffer, &record->buffer));\n    static_assert(sizeof(record->offset) >= sizeof(transfer->offset), \"Deserialize assignment may not narrow.\");\nrecord->offset = transfer->offset;\n    static_assert(sizeof(record->size) >= sizeof(transfer->size), \"Deserialize assignment may not narrow.\");\nrecord->size = transfer->size;\n    WIRE_TRY(resolver.GetOptionalFromId(transfer->sampler, &record->sampler));\n    WIRE_TRY(resolver.GetOptionalFromId(transfer->textureView, &record->textureView));\n\n    record->nextInChain = nullptr;\n    if (transfer->hasNextInChain) {\n        WIRE_TRY(DeserializeChainedStruct(&record->nextInChain, deserializeBuffer, allocator, resolver));\n    }\n\n\n\n\n    return WireResult::Success;\n}\nDAWN_UNUSED_FUNC(WGPUBindGroupEntryDeserialize);\n\n                \nstruct WGPUBlendComponentTransfer {\n    static_assert(0 <= 1,\n                  \"Record must be at most one of is_cmd, extensible, and chained.\");\n\n    \nWGPUBlendOperation operation;\n    \nWGPUBlendFactor srcFactor;\n    \nWGPUBlendFactor dstFactor;\n\n\n};\n\n\n\nDAWN_DECLARE_UNUSED size_t WGPUBlendComponentGetExtraRequiredSize(const WGPUBlendComponent& record) {\n    DAWN_UNUSED(record);\n\n    size_t result = 0;\n\n\n\n    {\n    }\n    {\n    }\n    {\n    }\n\n    return result;\n}\n// GetExtraRequiredSize isn't used for structures that are value members of other structures\n// because we assume they cannot contain pointers themselves.\nDAWN_UNUSED_FUNC(WGPUBlendComponentGetExtraRequiredSize);\n\nDAWN_DECLARE_UNUSED WireResult WGPUBlendComponentSerialize(\n    const WGPUBlendComponent& record,\n    WGPUBlendComponentTransfer* transfer,\n    SerializeBuffer* buffer) {\n    DAWN_UNUSED(buffer);\n\n\n    transfer->operation = record.operation;\n    transfer->srcFactor = record.srcFactor;\n    transfer->dstFactor = record.dstFactor;\n\n\n\n\n    return WireResult::Success;\n}\nDAWN_UNUSED_FUNC(WGPUBlendComponentSerialize);\n\nDAWN_DECLARE_UNUSED WireResult WGPUBlendComponentDeserialize(\n    WGPUBlendComponent* record,\n    const volatile WGPUBlendComponentTransfer* transfer,\n    DeserializeBuffer* deserializeBuffer,\n    DeserializeAllocator* allocator) {\n    DAWN_UNUSED(allocator);\n\n\n\n    static_assert(sizeof(record->operation) >= sizeof(transfer->operation), \"Deserialize assignment may not narrow.\");\nrecord->operation = transfer->operation;\n    static_assert(sizeof(record->srcFactor) >= sizeof(transfer->srcFactor), \"Deserialize assignment may not narrow.\");\nrecord->srcFactor = transfer->srcFactor;\n    static_assert(sizeof(record->dstFactor) >= sizeof(transfer->dstFactor), \"Deserialize assignment may not narrow.\");\nrecord->dstFactor = transfer->dstFactor;\n\n\n\n\n\n    return WireResult::Success;\n}\nDAWN_UNUSED_FUNC(WGPUBlendComponentDeserialize);\n\n                \nstruct WGPUBufferBindingLayoutTransfer {\n    static_assert(0 <= 1,\n                  \"Record must be at most one of is_cmd, extensible, and chained.\");\n    bool hasNextInChain;\n\n    \nWGPUBufferBindingType type;\n    \nbool hasDynamicOffset;\n    \nuint64_t minBindingSize;\n\n\n};\n\n\n\nDAWN_DECLARE_UNUSED size_t WGPUBufferBindingLayoutGetExtraRequiredSize(const WGPUBufferBindingLayout& record) {\n    DAWN_UNUSED(record);\n\n    size_t result = 0;\n\n    if (record.nextInChain != nullptr) {\n        result += GetChainedStructExtraRequiredSize(record.nextInChain);\n    }\n\n\n    {\n    }\n    {\n    }\n    {\n    }\n\n    return result;\n}\n// GetExtraRequiredSize isn't used for structures that are value members of other structures\n// because we assume they cannot contain pointers themselves.\nDAWN_UNUSED_FUNC(WGPUBufferBindingLayoutGetExtraRequiredSize);\n\nDAWN_DECLARE_UNUSED WireResult WGPUBufferBindingLayoutSerialize(\n    const WGPUBufferBindingLayout& record,\n    WGPUBufferBindingLayoutTransfer* transfer,\n    SerializeBuffer* buffer, const ObjectIdProvider& provider) {\n    DAWN_UNUSED(buffer);\n\n\n    transfer->type = record.type;\n    transfer->hasDynamicOffset = record.hasDynamicOffset;\n    transfer->minBindingSize = record.minBindingSize;\n\n    if (record.nextInChain != nullptr) {\n        transfer->hasNextInChain = true;\n        WIRE_TRY(SerializeChainedStruct(record.nextInChain, buffer, provider));\n    } else {\n        transfer->hasNextInChain = false;\n    }\n\n\n\n    return WireResult::Success;\n}\nDAWN_UNUSED_FUNC(WGPUBufferBindingLayoutSerialize);\n\nDAWN_DECLARE_UNUSED WireResult WGPUBufferBindingLayoutDeserialize(\n    WGPUBufferBindingLayout* record,\n    const volatile WGPUBufferBindingLayoutTransfer* transfer,\n    DeserializeBuffer* deserializeBuffer,\n    DeserializeAllocator* allocator, const ObjectIdResolver& resolver) {\n    DAWN_UNUSED(allocator);\n\n\n\n    static_assert(sizeof(record->type) >= sizeof(transfer->type), \"Deserialize assignment may not narrow.\");\nrecord->type = transfer->type;\n    static_assert(sizeof(record->hasDynamicOffset) >= sizeof(transfer->hasDynamicOffset), \"Deserialize assignment may not narrow.\");\nrecord->hasDynamicOffset = transfer->hasDynamicOffset;\n    static_assert(sizeof(record->minBindingSize) >= sizeof(transfer->minBindingSize), \"Deserialize assignment may not narrow.\");\nrecord->minBindingSize = transfer->minBindingSize;\n\n    record->nextInChain = nullptr;\n    if (transfer->hasNextInChain) {\n        WIRE_TRY(DeserializeChainedStruct(&record->nextInChain, deserializeBuffer, allocator, resolver));\n    }\n\n\n\n\n    return WireResult::Success;\n}\nDAWN_UNUSED_FUNC(WGPUBufferBindingLayoutDeserialize);\n\n                \nstruct WGPUBufferDescriptorTransfer {\n    static_assert(0 <= 1,\n                  \"Record must be at most one of is_cmd, extensible, and chained.\");\n    bool hasNextInChain;\n\n    WGPUBufferUsageFlags usage;\n    \nuint64_t size;\n    \nbool mappedAtCreation;\n\n    uint64_t labelStrlen;\n\n    bool has_label;\n};\n\n\n\nDAWN_DECLARE_UNUSED size_t WGPUBufferDescriptorGetExtraRequiredSize(const WGPUBufferDescriptor& record) {\n    DAWN_UNUSED(record);\n\n    size_t result = 0;\n\n    if (record.nextInChain != nullptr) {\n        result += GetChainedStructExtraRequiredSize(record.nextInChain);\n    }\n\n\n    bool has_label = record.label != nullptr;\n    if (has_label)\n    {\n    result += std::strlen(record.label);\n    }\n\n    {\n    }\n    {\n    }\n    {\n    }\n\n    return result;\n}\n// GetExtraRequiredSize isn't used for structures that are value members of other structures\n// because we assume they cannot contain pointers themselves.\nDAWN_UNUSED_FUNC(WGPUBufferDescriptorGetExtraRequiredSize);\n\nDAWN_DECLARE_UNUSED WireResult WGPUBufferDescriptorSerialize(\n    const WGPUBufferDescriptor& record,\n    WGPUBufferDescriptorTransfer* transfer,\n    SerializeBuffer* buffer, const ObjectIdProvider& provider) {\n    DAWN_UNUSED(buffer);\n\n\n    transfer->usage = record.usage;\n    transfer->size = record.size;\n    transfer->mappedAtCreation = record.mappedAtCreation;\n\n    if (record.nextInChain != nullptr) {\n        transfer->hasNextInChain = true;\n        WIRE_TRY(SerializeChainedStruct(record.nextInChain, buffer, provider));\n    } else {\n        transfer->hasNextInChain = false;\n    }\n\n\n\n    bool has_label = record.label != nullptr;\n    transfer->has_label = has_label;\n    if (has_label)\n    {\n        transfer->labelStrlen = std::strlen(record.label);\n\n        char* stringInBuffer;\n        WIRE_TRY(buffer->NextN(transfer->labelStrlen, &stringInBuffer));\n        memcpy(stringInBuffer, record.label, transfer->labelStrlen);\n    }\n\n    return WireResult::Success;\n}\nDAWN_UNUSED_FUNC(WGPUBufferDescriptorSerialize);\n\nDAWN_DECLARE_UNUSED WireResult WGPUBufferDescriptorDeserialize(\n    WGPUBufferDescriptor* record,\n    const volatile WGPUBufferDescriptorTransfer* transfer,\n    DeserializeBuffer* deserializeBuffer,\n    DeserializeAllocator* allocator, const ObjectIdResolver& resolver) {\n    DAWN_UNUSED(allocator);\n\n\n\n    static_assert(sizeof(record->usage) >= sizeof(transfer->usage), \"Deserialize assignment may not narrow.\");\nrecord->usage = transfer->usage;\n    static_assert(sizeof(record->size) >= sizeof(transfer->size), \"Deserialize assignment may not narrow.\");\nrecord->size = transfer->size;\n    static_assert(sizeof(record->mappedAtCreation) >= sizeof(transfer->mappedAtCreation), \"Deserialize assignment may not narrow.\");\nrecord->mappedAtCreation = transfer->mappedAtCreation;\n\n    record->nextInChain = nullptr;\n    if (transfer->hasNextInChain) {\n        WIRE_TRY(DeserializeChainedStruct(&record->nextInChain, deserializeBuffer, allocator, resolver));\n    }\n\n\n\n    bool has_label = transfer->has_label;\n    record->label = nullptr;\n    if (has_label)\n    {\n        uint64_t stringLength64 = transfer->labelStrlen;\n        if (stringLength64 >= std::numeric_limits<size_t>::max()) {\n            return WireResult::FatalError;\n        }\n        size_t stringLength = static_cast<size_t>(stringLength64);\n\n        const volatile char* stringInBuffer;\n        WIRE_TRY(deserializeBuffer->ReadN(stringLength, &stringInBuffer));\n\n        char* copiedString;\n        WIRE_TRY(GetSpace(allocator, stringLength + 1, &copiedString));\n        memcpy(copiedString, const_cast<const char*>(stringInBuffer), stringLength);\n        copiedString[stringLength] = '\\0';\n        record->label = copiedString;\n    }\n\n\n    return WireResult::Success;\n}\nDAWN_UNUSED_FUNC(WGPUBufferDescriptorDeserialize);\n\n                \nstruct WGPUColorTransfer {\n    static_assert(0 <= 1,\n                  \"Record must be at most one of is_cmd, extensible, and chained.\");\n\n    \ndouble r;\n    \ndouble g;\n    \ndouble b;\n    \ndouble a;\n\n\n};\n\n\n\nDAWN_DECLARE_UNUSED size_t WGPUColorGetExtraRequiredSize(const WGPUColor& record) {\n    DAWN_UNUSED(record);\n\n    size_t result = 0;\n\n\n\n    {\n    }\n    {\n    }\n    {\n    }\n    {\n    }\n\n    return result;\n}\n// GetExtraRequiredSize isn't used for structures that are value members of other structures\n// because we assume they cannot contain pointers themselves.\nDAWN_UNUSED_FUNC(WGPUColorGetExtraRequiredSize);\n\nDAWN_DECLARE_UNUSED WireResult WGPUColorSerialize(\n    const WGPUColor& record,\n    WGPUColorTransfer* transfer,\n    SerializeBuffer* buffer) {\n    DAWN_UNUSED(buffer);\n\n\n    transfer->r = record.r;\n    transfer->g = record.g;\n    transfer->b = record.b;\n    transfer->a = record.a;\n\n\n\n\n    return WireResult::Success;\n}\nDAWN_UNUSED_FUNC(WGPUColorSerialize);\n\nDAWN_DECLARE_UNUSED WireResult WGPUColorDeserialize(\n    WGPUColor* record,\n    const volatile WGPUColorTransfer* transfer,\n    DeserializeBuffer* deserializeBuffer,\n    DeserializeAllocator* allocator) {\n    DAWN_UNUSED(allocator);\n\n\n\n    static_assert(sizeof(record->r) >= sizeof(transfer->r), \"Deserialize assignment may not narrow.\");\nrecord->r = transfer->r;\n    static_assert(sizeof(record->g) >= sizeof(transfer->g), \"Deserialize assignment may not narrow.\");\nrecord->g = transfer->g;\n    static_assert(sizeof(record->b) >= sizeof(transfer->b), \"Deserialize assignment may not narrow.\");\nrecord->b = transfer->b;\n    static_assert(sizeof(record->a) >= sizeof(transfer->a), \"Deserialize assignment may not narrow.\");\nrecord->a = transfer->a;\n\n\n\n\n\n    return WireResult::Success;\n}\nDAWN_UNUSED_FUNC(WGPUColorDeserialize);\n\n                \nstruct WGPUCommandBufferDescriptorTransfer {\n    static_assert(0 <= 1,\n                  \"Record must be at most one of is_cmd, extensible, and chained.\");\n    bool hasNextInChain;\n\n\n    uint64_t labelStrlen;\n\n    bool has_label;\n};\n\n\n\nDAWN_DECLARE_UNUSED size_t WGPUCommandBufferDescriptorGetExtraRequiredSize(const WGPUCommandBufferDescriptor& record) {\n    DAWN_UNUSED(record);\n\n    size_t result = 0;\n\n    if (record.nextInChain != nullptr) {\n        result += GetChainedStructExtraRequiredSize(record.nextInChain);\n    }\n\n\n    bool has_label = record.label != nullptr;\n    if (has_label)\n    {\n    result += std::strlen(record.label);\n    }\n\n\n    return result;\n}\n// GetExtraRequiredSize isn't used for structures that are value members of other structures\n// because we assume they cannot contain pointers themselves.\nDAWN_UNUSED_FUNC(WGPUCommandBufferDescriptorGetExtraRequiredSize);\n\nDAWN_DECLARE_UNUSED WireResult WGPUCommandBufferDescriptorSerialize(\n    const WGPUCommandBufferDescriptor& record,\n    WGPUCommandBufferDescriptorTransfer* transfer,\n    SerializeBuffer* buffer, const ObjectIdProvider& provider) {\n    DAWN_UNUSED(buffer);\n\n\n\n    if (record.nextInChain != nullptr) {\n        transfer->hasNextInChain = true;\n        WIRE_TRY(SerializeChainedStruct(record.nextInChain, buffer, provider));\n    } else {\n        transfer->hasNextInChain = false;\n    }\n\n\n\n    bool has_label = record.label != nullptr;\n    transfer->has_label = has_label;\n    if (has_label)\n    {\n        transfer->labelStrlen = std::strlen(record.label);\n\n        char* stringInBuffer;\n        WIRE_TRY(buffer->NextN(transfer->labelStrlen, &stringInBuffer));\n        memcpy(stringInBuffer, record.label, transfer->labelStrlen);\n    }\n\n    return WireResult::Success;\n}\nDAWN_UNUSED_FUNC(WGPUCommandBufferDescriptorSerialize);\n\nDAWN_DECLARE_UNUSED WireResult WGPUCommandBufferDescriptorDeserialize(\n    WGPUCommandBufferDescriptor* record,\n    const volatile WGPUCommandBufferDescriptorTransfer* transfer,\n    DeserializeBuffer* deserializeBuffer,\n    DeserializeAllocator* allocator, const ObjectIdResolver& resolver) {\n    DAWN_UNUSED(allocator);\n\n\n\n\n    record->nextInChain = nullptr;\n    if (transfer->hasNextInChain) {\n        WIRE_TRY(DeserializeChainedStruct(&record->nextInChain, deserializeBuffer, allocator, resolver));\n    }\n\n\n\n    bool has_label = transfer->has_label;\n    record->label = nullptr;\n    if (has_label)\n    {\n        uint64_t stringLength64 = transfer->labelStrlen;\n        if (stringLength64 >= std::numeric_limits<size_t>::max()) {\n            return WireResult::FatalError;\n        }\n        size_t stringLength = static_cast<size_t>(stringLength64);\n\n        const volatile char* stringInBuffer;\n        WIRE_TRY(deserializeBuffer->ReadN(stringLength, &stringInBuffer));\n\n        char* copiedString;\n        WIRE_TRY(GetSpace(allocator, stringLength + 1, &copiedString));\n        memcpy(copiedString, const_cast<const char*>(stringInBuffer), stringLength);\n        copiedString[stringLength] = '\\0';\n        record->label = copiedString;\n    }\n\n\n    return WireResult::Success;\n}\nDAWN_UNUSED_FUNC(WGPUCommandBufferDescriptorDeserialize);\n\n                \nstruct WGPUCommandEncoderDescriptorTransfer {\n    static_assert(0 <= 1,\n                  \"Record must be at most one of is_cmd, extensible, and chained.\");\n    bool hasNextInChain;\n\n\n    uint64_t labelStrlen;\n\n    bool has_label;\n};\n\n\n\nDAWN_DECLARE_UNUSED size_t WGPUCommandEncoderDescriptorGetExtraRequiredSize(const WGPUCommandEncoderDescriptor& record) {\n    DAWN_UNUSED(record);\n\n    size_t result = 0;\n\n    if (record.nextInChain != nullptr) {\n        result += GetChainedStructExtraRequiredSize(record.nextInChain);\n    }\n\n\n    bool has_label = record.label != nullptr;\n    if (has_label)\n    {\n    result += std::strlen(record.label);\n    }\n\n\n    return result;\n}\n// GetExtraRequiredSize isn't used for structures that are value members of other structures\n// because we assume they cannot contain pointers themselves.\nDAWN_UNUSED_FUNC(WGPUCommandEncoderDescriptorGetExtraRequiredSize);\n\nDAWN_DECLARE_UNUSED WireResult WGPUCommandEncoderDescriptorSerialize(\n    const WGPUCommandEncoderDescriptor& record,\n    WGPUCommandEncoderDescriptorTransfer* transfer,\n    SerializeBuffer* buffer, const ObjectIdProvider& provider) {\n    DAWN_UNUSED(buffer);\n\n\n\n    if (record.nextInChain != nullptr) {\n        transfer->hasNextInChain = true;\n        WIRE_TRY(SerializeChainedStruct(record.nextInChain, buffer, provider));\n    } else {\n        transfer->hasNextInChain = false;\n    }\n\n\n\n    bool has_label = record.label != nullptr;\n    transfer->has_label = has_label;\n    if (has_label)\n    {\n        transfer->labelStrlen = std::strlen(record.label);\n\n        char* stringInBuffer;\n        WIRE_TRY(buffer->NextN(transfer->labelStrlen, &stringInBuffer));\n        memcpy(stringInBuffer, record.label, transfer->labelStrlen);\n    }\n\n    return WireResult::Success;\n}\nDAWN_UNUSED_FUNC(WGPUCommandEncoderDescriptorSerialize);\n\nDAWN_DECLARE_UNUSED WireResult WGPUCommandEncoderDescriptorDeserialize(\n    WGPUCommandEncoderDescriptor* record,\n    const volatile WGPUCommandEncoderDescriptorTransfer* transfer,\n    DeserializeBuffer* deserializeBuffer,\n    DeserializeAllocator* allocator, const ObjectIdResolver& resolver) {\n    DAWN_UNUSED(allocator);\n\n\n\n\n    record->nextInChain = nullptr;\n    if (transfer->hasNextInChain) {\n        WIRE_TRY(DeserializeChainedStruct(&record->nextInChain, deserializeBuffer, allocator, resolver));\n    }\n\n\n\n    bool has_label = transfer->has_label;\n    record->label = nullptr;\n    if (has_label)\n    {\n        uint64_t stringLength64 = transfer->labelStrlen;\n        if (stringLength64 >= std::numeric_limits<size_t>::max()) {\n            return WireResult::FatalError;\n        }\n        size_t stringLength = static_cast<size_t>(stringLength64);\n\n        const volatile char* stringInBuffer;\n        WIRE_TRY(deserializeBuffer->ReadN(stringLength, &stringInBuffer));\n\n        char* copiedString;\n        WIRE_TRY(GetSpace(allocator, stringLength + 1, &copiedString));\n        memcpy(copiedString, const_cast<const char*>(stringInBuffer), stringLength);\n        copiedString[stringLength] = '\\0';\n        record->label = copiedString;\n    }\n\n\n    return WireResult::Success;\n}\nDAWN_UNUSED_FUNC(WGPUCommandEncoderDescriptorDeserialize);\n\n                \nstruct WGPUCompilationMessageTransfer {\n    static_assert(0 <= 1,\n                  \"Record must be at most one of is_cmd, extensible, and chained.\");\n    bool hasNextInChain;\n\n    \nWGPUCompilationMessageType type;\n    \nuint64_t lineNum;\n    \nuint64_t linePos;\n    \nuint64_t offset;\n    \nuint64_t length;\n\n    uint64_t messageStrlen;\n\n    bool has_message;\n};\n\n\n\nDAWN_DECLARE_UNUSED size_t WGPUCompilationMessageGetExtraRequiredSize(const WGPUCompilationMessage& record) {\n    DAWN_UNUSED(record);\n\n    size_t result = 0;\n\n    if (record.nextInChain != nullptr) {\n        result += GetChainedStructExtraRequiredSize(record.nextInChain);\n    }\n\n\n    bool has_message = record.message != nullptr;\n    if (has_message)\n    {\n    result += std::strlen(record.message);\n    }\n\n    {\n    }\n    {\n    }\n    {\n    }\n    {\n    }\n    {\n    }\n\n    return result;\n}\n// GetExtraRequiredSize isn't used for structures that are value members of other structures\n// because we assume they cannot contain pointers themselves.\nDAWN_UNUSED_FUNC(WGPUCompilationMessageGetExtraRequiredSize);\n\nDAWN_DECLARE_UNUSED WireResult WGPUCompilationMessageSerialize(\n    const WGPUCompilationMessage& record,\n    WGPUCompilationMessageTransfer* transfer,\n    SerializeBuffer* buffer, const ObjectIdProvider& provider) {\n    DAWN_UNUSED(buffer);\n\n\n    transfer->type = record.type;\n    transfer->lineNum = record.lineNum;\n    transfer->linePos = record.linePos;\n    transfer->offset = record.offset;\n    transfer->length = record.length;\n\n    if (record.nextInChain != nullptr) {\n        transfer->hasNextInChain = true;\n        WIRE_TRY(SerializeChainedStruct(record.nextInChain, buffer, provider));\n    } else {\n        transfer->hasNextInChain = false;\n    }\n\n\n\n    bool has_message = record.message != nullptr;\n    transfer->has_message = has_message;\n    if (has_message)\n    {\n        transfer->messageStrlen = std::strlen(record.message);\n\n        char* stringInBuffer;\n        WIRE_TRY(buffer->NextN(transfer->messageStrlen, &stringInBuffer));\n        memcpy(stringInBuffer, record.message, transfer->messageStrlen);\n    }\n\n    return WireResult::Success;\n}\nDAWN_UNUSED_FUNC(WGPUCompilationMessageSerialize);\n\nDAWN_DECLARE_UNUSED WireResult WGPUCompilationMessageDeserialize(\n    WGPUCompilationMessage* record,\n    const volatile WGPUCompilationMessageTransfer* transfer,\n    DeserializeBuffer* deserializeBuffer,\n    DeserializeAllocator* allocator, const ObjectIdResolver& resolver) {\n    DAWN_UNUSED(allocator);\n\n\n\n    static_assert(sizeof(record->type) >= sizeof(transfer->type), \"Deserialize assignment may not narrow.\");\nrecord->type = transfer->type;\n    static_assert(sizeof(record->lineNum) >= sizeof(transfer->lineNum), \"Deserialize assignment may not narrow.\");\nrecord->lineNum = transfer->lineNum;\n    static_assert(sizeof(record->linePos) >= sizeof(transfer->linePos), \"Deserialize assignment may not narrow.\");\nrecord->linePos = transfer->linePos;\n    static_assert(sizeof(record->offset) >= sizeof(transfer->offset), \"Deserialize assignment may not narrow.\");\nrecord->offset = transfer->offset;\n    static_assert(sizeof(record->length) >= sizeof(transfer->length), \"Deserialize assignment may not narrow.\");\nrecord->length = transfer->length;\n\n    record->nextInChain = nullptr;\n    if (transfer->hasNextInChain) {\n        WIRE_TRY(DeserializeChainedStruct(&record->nextInChain, deserializeBuffer, allocator, resolver));\n    }\n\n\n\n    bool has_message = transfer->has_message;\n    record->message = nullptr;\n    if (has_message)\n    {\n        uint64_t stringLength64 = transfer->messageStrlen;\n        if (stringLength64 >= std::numeric_limits<size_t>::max()) {\n            return WireResult::FatalError;\n        }\n        size_t stringLength = static_cast<size_t>(stringLength64);\n\n        const volatile char* stringInBuffer;\n        WIRE_TRY(deserializeBuffer->ReadN(stringLength, &stringInBuffer));\n\n        char* copiedString;\n        WIRE_TRY(GetSpace(allocator, stringLength + 1, &copiedString));\n        memcpy(copiedString, const_cast<const char*>(stringInBuffer), stringLength);\n        copiedString[stringLength] = '\\0';\n        record->message = copiedString;\n    }\n\n\n    return WireResult::Success;\n}\nDAWN_UNUSED_FUNC(WGPUCompilationMessageDeserialize);\n\n                \nstruct WGPUComputePassTimestampWriteTransfer {\n    static_assert(0 <= 1,\n                  \"Record must be at most one of is_cmd, extensible, and chained.\");\n\n    ObjectId querySet;\n    \nuint32_t queryIndex;\n    \nWGPUComputePassTimestampLocation location;\n\n\n};\n\n\n\nDAWN_DECLARE_UNUSED size_t WGPUComputePassTimestampWriteGetExtraRequiredSize(const WGPUComputePassTimestampWrite& record) {\n    DAWN_UNUSED(record);\n\n    size_t result = 0;\n\n\n\n    {\n    }\n    {\n    }\n    {\n    }\n\n    return result;\n}\n// GetExtraRequiredSize isn't used for structures that are value members of other structures\n// because we assume they cannot contain pointers themselves.\nDAWN_UNUSED_FUNC(WGPUComputePassTimestampWriteGetExtraRequiredSize);\n\nDAWN_DECLARE_UNUSED WireResult WGPUComputePassTimestampWriteSerialize(\n    const WGPUComputePassTimestampWrite& record,\n    WGPUComputePassTimestampWriteTransfer* transfer,\n    SerializeBuffer* buffer, const ObjectIdProvider& provider) {\n    DAWN_UNUSED(buffer);\n\n\n    WIRE_TRY(provider.GetId(record.querySet, &transfer->querySet));\n    transfer->queryIndex = record.queryIndex;\n    transfer->location = record.location;\n\n\n\n\n    return WireResult::Success;\n}\nDAWN_UNUSED_FUNC(WGPUComputePassTimestampWriteSerialize);\n\nDAWN_DECLARE_UNUSED WireResult WGPUComputePassTimestampWriteDeserialize(\n    WGPUComputePassTimestampWrite* record,\n    const volatile WGPUComputePassTimestampWriteTransfer* transfer,\n    DeserializeBuffer* deserializeBuffer,\n    DeserializeAllocator* allocator, const ObjectIdResolver& resolver) {\n    DAWN_UNUSED(allocator);\n\n\n\n    WIRE_TRY(resolver.GetFromId(transfer->querySet, &record->querySet));\n    static_assert(sizeof(record->queryIndex) >= sizeof(transfer->queryIndex), \"Deserialize assignment may not narrow.\");\nrecord->queryIndex = transfer->queryIndex;\n    static_assert(sizeof(record->location) >= sizeof(transfer->location), \"Deserialize assignment may not narrow.\");\nrecord->location = transfer->location;\n\n\n\n\n\n    return WireResult::Success;\n}\nDAWN_UNUSED_FUNC(WGPUComputePassTimestampWriteDeserialize);\n\n                \nstruct WGPUConstantEntryTransfer {\n    static_assert(0 <= 1,\n                  \"Record must be at most one of is_cmd, extensible, and chained.\");\n    bool hasNextInChain;\n\n    \ndouble value;\n\n    uint64_t keyStrlen;\n\n};\n\n\n\nDAWN_DECLARE_UNUSED size_t WGPUConstantEntryGetExtraRequiredSize(const WGPUConstantEntry& record) {\n    DAWN_UNUSED(record);\n\n    size_t result = 0;\n\n    if (record.nextInChain != nullptr) {\n        result += GetChainedStructExtraRequiredSize(record.nextInChain);\n    }\n\n\n    {\n    result += std::strlen(record.key);\n    }\n\n    {\n    }\n\n    return result;\n}\n// GetExtraRequiredSize isn't used for structures that are value members of other structures\n// because we assume they cannot contain pointers themselves.\nDAWN_UNUSED_FUNC(WGPUConstantEntryGetExtraRequiredSize);\n\nDAWN_DECLARE_UNUSED WireResult WGPUConstantEntrySerialize(\n    const WGPUConstantEntry& record,\n    WGPUConstantEntryTransfer* transfer,\n    SerializeBuffer* buffer, const ObjectIdProvider& provider) {\n    DAWN_UNUSED(buffer);\n\n\n    transfer->value = record.value;\n\n    if (record.nextInChain != nullptr) {\n        transfer->hasNextInChain = true;\n        WIRE_TRY(SerializeChainedStruct(record.nextInChain, buffer, provider));\n    } else {\n        transfer->hasNextInChain = false;\n    }\n\n\n\n    {\n        transfer->keyStrlen = std::strlen(record.key);\n\n        char* stringInBuffer;\n        WIRE_TRY(buffer->NextN(transfer->keyStrlen, &stringInBuffer));\n        memcpy(stringInBuffer, record.key, transfer->keyStrlen);\n    }\n\n    return WireResult::Success;\n}\nDAWN_UNUSED_FUNC(WGPUConstantEntrySerialize);\n\nDAWN_DECLARE_UNUSED WireResult WGPUConstantEntryDeserialize(\n    WGPUConstantEntry* record,\n    const volatile WGPUConstantEntryTransfer* transfer,\n    DeserializeBuffer* deserializeBuffer,\n    DeserializeAllocator* allocator, const ObjectIdResolver& resolver) {\n    DAWN_UNUSED(allocator);\n\n\n\n    static_assert(sizeof(record->value) >= sizeof(transfer->value), \"Deserialize assignment may not narrow.\");\nrecord->value = transfer->value;\n\n    record->nextInChain = nullptr;\n    if (transfer->hasNextInChain) {\n        WIRE_TRY(DeserializeChainedStruct(&record->nextInChain, deserializeBuffer, allocator, resolver));\n    }\n\n\n\n    {\n        uint64_t stringLength64 = transfer->keyStrlen;\n        if (stringLength64 >= std::numeric_limits<size_t>::max()) {\n            return WireResult::FatalError;\n        }\n        size_t stringLength = static_cast<size_t>(stringLength64);\n\n        const volatile char* stringInBuffer;\n        WIRE_TRY(deserializeBuffer->ReadN(stringLength, &stringInBuffer));\n\n        char* copiedString;\n        WIRE_TRY(GetSpace(allocator, stringLength + 1, &copiedString));\n        memcpy(copiedString, const_cast<const char*>(stringInBuffer), stringLength);\n        copiedString[stringLength] = '\\0';\n        record->key = copiedString;\n    }\n\n\n    return WireResult::Success;\n}\nDAWN_UNUSED_FUNC(WGPUConstantEntryDeserialize);\n\n                \nstruct WGPUCopyTextureForBrowserOptionsTransfer {\n    static_assert(0 <= 1,\n                  \"Record must be at most one of is_cmd, extensible, and chained.\");\n    bool hasNextInChain;\n\n    \nbool flipY;\n    \nbool needsColorSpaceConversion;\n    \nWGPUAlphaMode srcAlphaMode;\n    \nWGPUAlphaMode dstAlphaMode;\n    \nbool internalUsage;\n\n\n    bool has_srcTransferFunctionParameters;\n    bool has_conversionMatrix;\n    bool has_dstTransferFunctionParameters;\n};\n\n\n\nDAWN_DECLARE_UNUSED size_t WGPUCopyTextureForBrowserOptionsGetExtraRequiredSize(const WGPUCopyTextureForBrowserOptions& record) {\n    DAWN_UNUSED(record);\n\n    size_t result = 0;\n\n    if (record.nextInChain != nullptr) {\n        result += GetChainedStructExtraRequiredSize(record.nextInChain);\n    }\n\n\n    {\n    }\n    {\n    }\n    {\n    }\n    if (record.srcTransferFunctionParameters != nullptr)\n    {\n        \n        auto memberLength = 7u;\n        result += memberLength * sizeof(\nfloat);\n    }\n    if (record.conversionMatrix != nullptr)\n    {\n        \n        auto memberLength = 9u;\n        result += memberLength * sizeof(\nfloat);\n    }\n    if (record.dstTransferFunctionParameters != nullptr)\n    {\n        \n        auto memberLength = 7u;\n        result += memberLength * sizeof(\nfloat);\n    }\n    {\n    }\n    {\n    }\n\n    return result;\n}\n// GetExtraRequiredSize isn't used for structures that are value members of other structures\n// because we assume they cannot contain pointers themselves.\nDAWN_UNUSED_FUNC(WGPUCopyTextureForBrowserOptionsGetExtraRequiredSize);\n\nDAWN_DECLARE_UNUSED WireResult WGPUCopyTextureForBrowserOptionsSerialize(\n    const WGPUCopyTextureForBrowserOptions& record,\n    WGPUCopyTextureForBrowserOptionsTransfer* transfer,\n    SerializeBuffer* buffer, const ObjectIdProvider& provider) {\n    DAWN_UNUSED(buffer);\n\n\n    transfer->flipY = record.flipY;\n    transfer->needsColorSpaceConversion = record.needsColorSpaceConversion;\n    transfer->srcAlphaMode = record.srcAlphaMode;\n    transfer->dstAlphaMode = record.dstAlphaMode;\n    transfer->internalUsage = record.internalUsage;\n\n    if (record.nextInChain != nullptr) {\n        transfer->hasNextInChain = true;\n        WIRE_TRY(SerializeChainedStruct(record.nextInChain, buffer, provider));\n    } else {\n        transfer->hasNextInChain = false;\n    }\n\n\n\n    \n\n    bool has_srcTransferFunctionParameters = record.srcTransferFunctionParameters != nullptr;\n    transfer->has_srcTransferFunctionParameters = has_srcTransferFunctionParameters;\n    if (has_srcTransferFunctionParameters)\n    {\n        auto memberLength = 7u;\n\n        \nfloat* memberBuffer;\n        WIRE_TRY(buffer->NextN(memberLength, &memberBuffer));\n\n        memcpy(\n            memberBuffer, record.srcTransferFunctionParameters,\n            sizeof(\nfloat) * memberLength);\n    }\n    \n\n    bool has_conversionMatrix = record.conversionMatrix != nullptr;\n    transfer->has_conversionMatrix = has_conversionMatrix;\n    if (has_conversionMatrix)\n    {\n        auto memberLength = 9u;\n\n        \nfloat* memberBuffer;\n        WIRE_TRY(buffer->NextN(memberLength, &memberBuffer));\n\n        memcpy(\n            memberBuffer, record.conversionMatrix,\n            sizeof(\nfloat) * memberLength);\n    }\n    \n\n    bool has_dstTransferFunctionParameters = record.dstTransferFunctionParameters != nullptr;\n    transfer->has_dstTransferFunctionParameters = has_dstTransferFunctionParameters;\n    if (has_dstTransferFunctionParameters)\n    {\n        auto memberLength = 7u;\n\n        \nfloat* memberBuffer;\n        WIRE_TRY(buffer->NextN(memberLength, &memberBuffer));\n\n        memcpy(\n            memberBuffer, record.dstTransferFunctionParameters,\n            sizeof(\nfloat) * memberLength);\n    }\n    return WireResult::Success;\n}\nDAWN_UNUSED_FUNC(WGPUCopyTextureForBrowserOptionsSerialize);\n\nDAWN_DECLARE_UNUSED WireResult WGPUCopyTextureForBrowserOptionsDeserialize(\n    WGPUCopyTextureForBrowserOptions* record,\n    const volatile WGPUCopyTextureForBrowserOptionsTransfer* transfer,\n    DeserializeBuffer* deserializeBuffer,\n    DeserializeAllocator* allocator, const ObjectIdResolver& resolver) {\n    DAWN_UNUSED(allocator);\n\n\n\n    static_assert(sizeof(record->flipY) >= sizeof(transfer->flipY), \"Deserialize assignment may not narrow.\");\nrecord->flipY = transfer->flipY;\n    static_assert(sizeof(record->needsColorSpaceConversion) >= sizeof(transfer->needsColorSpaceConversion), \"Deserialize assignment may not narrow.\");\nrecord->needsColorSpaceConversion = transfer->needsColorSpaceConversion;\n    static_assert(sizeof(record->srcAlphaMode) >= sizeof(transfer->srcAlphaMode), \"Deserialize assignment may not narrow.\");\nrecord->srcAlphaMode = transfer->srcAlphaMode;\n    static_assert(sizeof(record->dstAlphaMode) >= sizeof(transfer->dstAlphaMode), \"Deserialize assignment may not narrow.\");\nrecord->dstAlphaMode = transfer->dstAlphaMode;\n    static_assert(sizeof(record->internalUsage) >= sizeof(transfer->internalUsage), \"Deserialize assignment may not narrow.\");\nrecord->internalUsage = transfer->internalUsage;\n\n    record->nextInChain = nullptr;\n    if (transfer->hasNextInChain) {\n        WIRE_TRY(DeserializeChainedStruct(&record->nextInChain, deserializeBuffer, allocator, resolver));\n    }\n\n\n\n    \n\n    \n    bool has_srcTransferFunctionParameters = transfer->has_srcTransferFunctionParameters;\n    record->srcTransferFunctionParameters = nullptr;\n    if (has_srcTransferFunctionParameters)\n    {\n        auto memberLength = 7u;\n        const volatile \nfloat* memberBuffer;\n        WIRE_TRY(deserializeBuffer->ReadN(memberLength, &memberBuffer));\n\n        float* copiedMembers;\n        WIRE_TRY(GetSpace(allocator, memberLength, &copiedMembers));\n        record->srcTransferFunctionParameters = copiedMembers;\n\n        memcpy(\n            copiedMembers,\n            const_cast<const \nfloat*>(memberBuffer),\n           sizeof(\nfloat) * memberLength);\n    }\n    \n\n    \n    bool has_conversionMatrix = transfer->has_conversionMatrix;\n    record->conversionMatrix = nullptr;\n    if (has_conversionMatrix)\n    {\n        auto memberLength = 9u;\n        const volatile \nfloat* memberBuffer;\n        WIRE_TRY(deserializeBuffer->ReadN(memberLength, &memberBuffer));\n\n        float* copiedMembers;\n        WIRE_TRY(GetSpace(allocator, memberLength, &copiedMembers));\n        record->conversionMatrix = copiedMembers;\n\n        memcpy(\n            copiedMembers,\n            const_cast<const \nfloat*>(memberBuffer),\n           sizeof(\nfloat) * memberLength);\n    }\n    \n\n    \n    bool has_dstTransferFunctionParameters = transfer->has_dstTransferFunctionParameters;\n    record->dstTransferFunctionParameters = nullptr;\n    if (has_dstTransferFunctionParameters)\n    {\n        auto memberLength = 7u;\n        const volatile \nfloat* memberBuffer;\n        WIRE_TRY(deserializeBuffer->ReadN(memberLength, &memberBuffer));\n\n        float* copiedMembers;\n        WIRE_TRY(GetSpace(allocator, memberLength, &copiedMembers));\n        record->dstTransferFunctionParameters = copiedMembers;\n\n        memcpy(\n            copiedMembers,\n            const_cast<const \nfloat*>(memberBuffer),\n           sizeof(\nfloat) * memberLength);\n    }\n\n    return WireResult::Success;\n}\nDAWN_UNUSED_FUNC(WGPUCopyTextureForBrowserOptionsDeserialize);\n\n                \nstruct WGPUDawnEncoderInternalUsageDescriptorTransfer {\n    static_assert(0 <= 1,\n                  \"Record must be at most one of is_cmd, extensible, and chained.\");\n    WGPUChainedStructTransfer chain;\n\n    \nbool useInternalUsages;\n\n\n};\n\n\nstatic_assert(offsetof(WGPUDawnEncoderInternalUsageDescriptorTransfer, chain) == 0);\n\nDAWN_DECLARE_UNUSED size_t WGPUDawnEncoderInternalUsageDescriptorGetExtraRequiredSize(const WGPUDawnEncoderInternalUsageDescriptor& record) {\n    DAWN_UNUSED(record);\n\n    size_t result = 0;\n\n\n\n    {\n    }\n\n    return result;\n}\n// GetExtraRequiredSize isn't used for structures that are value members of other structures\n// because we assume they cannot contain pointers themselves.\nDAWN_UNUSED_FUNC(WGPUDawnEncoderInternalUsageDescriptorGetExtraRequiredSize);\n\nDAWN_DECLARE_UNUSED WireResult WGPUDawnEncoderInternalUsageDescriptorSerialize(\n    const WGPUDawnEncoderInternalUsageDescriptor& record,\n    WGPUDawnEncoderInternalUsageDescriptorTransfer* transfer,\n    SerializeBuffer* buffer, const ObjectIdProvider& provider) {\n    DAWN_UNUSED(buffer);\n\n\n    transfer->useInternalUsages = record.useInternalUsages;\n\n\n    ASSERT(transfer->chain.sType == WGPUSType_DawnEncoderInternalUsageDescriptor);\n    ASSERT(transfer->chain.hasNext == (record.chain.next != nullptr));\n\n\n    return WireResult::Success;\n}\nDAWN_UNUSED_FUNC(WGPUDawnEncoderInternalUsageDescriptorSerialize);\n\nDAWN_DECLARE_UNUSED WireResult WGPUDawnEncoderInternalUsageDescriptorDeserialize(\n    WGPUDawnEncoderInternalUsageDescriptor* record,\n    const volatile WGPUDawnEncoderInternalUsageDescriptorTransfer* transfer,\n    DeserializeBuffer* deserializeBuffer,\n    DeserializeAllocator* allocator, const ObjectIdResolver& resolver) {\n    DAWN_UNUSED(allocator);\n\n\n\n    static_assert(sizeof(record->useInternalUsages) >= sizeof(transfer->useInternalUsages), \"Deserialize assignment may not narrow.\");\nrecord->useInternalUsages = transfer->useInternalUsages;\n\n\n    ASSERT(record->chain.sType == WGPUSType_DawnEncoderInternalUsageDescriptor);\n    ASSERT(record->chain.next == nullptr);\n\n\n\n    return WireResult::Success;\n}\nDAWN_UNUSED_FUNC(WGPUDawnEncoderInternalUsageDescriptorDeserialize);\n\n                \nstruct WGPUDawnTextureInternalUsageDescriptorTransfer {\n    static_assert(0 <= 1,\n                  \"Record must be at most one of is_cmd, extensible, and chained.\");\n    WGPUChainedStructTransfer chain;\n\n    WGPUTextureUsageFlags internalUsage;\n\n\n};\n\n\nstatic_assert(offsetof(WGPUDawnTextureInternalUsageDescriptorTransfer, chain) == 0);\n\nDAWN_DECLARE_UNUSED size_t WGPUDawnTextureInternalUsageDescriptorGetExtraRequiredSize(const WGPUDawnTextureInternalUsageDescriptor& record) {\n    DAWN_UNUSED(record);\n\n    size_t result = 0;\n\n\n\n    {\n    }\n\n    return result;\n}\n// GetExtraRequiredSize isn't used for structures that are value members of other structures\n// because we assume they cannot contain pointers themselves.\nDAWN_UNUSED_FUNC(WGPUDawnTextureInternalUsageDescriptorGetExtraRequiredSize);\n\nDAWN_DECLARE_UNUSED WireResult WGPUDawnTextureInternalUsageDescriptorSerialize(\n    const WGPUDawnTextureInternalUsageDescriptor& record,\n    WGPUDawnTextureInternalUsageDescriptorTransfer* transfer,\n    SerializeBuffer* buffer, const ObjectIdProvider& provider) {\n    DAWN_UNUSED(buffer);\n\n\n    transfer->internalUsage = record.internalUsage;\n\n\n    ASSERT(transfer->chain.sType == WGPUSType_DawnTextureInternalUsageDescriptor);\n    ASSERT(transfer->chain.hasNext == (record.chain.next != nullptr));\n\n\n    return WireResult::Success;\n}\nDAWN_UNUSED_FUNC(WGPUDawnTextureInternalUsageDescriptorSerialize);\n\nDAWN_DECLARE_UNUSED WireResult WGPUDawnTextureInternalUsageDescriptorDeserialize(\n    WGPUDawnTextureInternalUsageDescriptor* record,\n    const volatile WGPUDawnTextureInternalUsageDescriptorTransfer* transfer,\n    DeserializeBuffer* deserializeBuffer,\n    DeserializeAllocator* allocator, const ObjectIdResolver& resolver) {\n    DAWN_UNUSED(allocator);\n\n\n\n    static_assert(sizeof(record->internalUsage) >= sizeof(transfer->internalUsage), \"Deserialize assignment may not narrow.\");\nrecord->internalUsage = transfer->internalUsage;\n\n\n    ASSERT(record->chain.sType == WGPUSType_DawnTextureInternalUsageDescriptor);\n    ASSERT(record->chain.next == nullptr);\n\n\n\n    return WireResult::Success;\n}\nDAWN_UNUSED_FUNC(WGPUDawnTextureInternalUsageDescriptorDeserialize);\n\n                \nstruct WGPUExtent3DTransfer {\n    static_assert(0 <= 1,\n                  \"Record must be at most one of is_cmd, extensible, and chained.\");\n\n    \nuint32_t width;\n    \nuint32_t height;\n    \nuint32_t depthOrArrayLayers;\n\n\n};\n\n\n\nDAWN_DECLARE_UNUSED size_t WGPUExtent3DGetExtraRequiredSize(const WGPUExtent3D& record) {\n    DAWN_UNUSED(record);\n\n    size_t result = 0;\n\n\n\n    {\n    }\n    {\n    }\n    {\n    }\n\n    return result;\n}\n// GetExtraRequiredSize isn't used for structures that are value members of other structures\n// because we assume they cannot contain pointers themselves.\nDAWN_UNUSED_FUNC(WGPUExtent3DGetExtraRequiredSize);\n\nDAWN_DECLARE_UNUSED WireResult WGPUExtent3DSerialize(\n    const WGPUExtent3D& record,\n    WGPUExtent3DTransfer* transfer,\n    SerializeBuffer* buffer) {\n    DAWN_UNUSED(buffer);\n\n\n    transfer->width = record.width;\n    transfer->height = record.height;\n    transfer->depthOrArrayLayers = record.depthOrArrayLayers;\n\n\n\n\n    return WireResult::Success;\n}\nDAWN_UNUSED_FUNC(WGPUExtent3DSerialize);\n\nDAWN_DECLARE_UNUSED WireResult WGPUExtent3DDeserialize(\n    WGPUExtent3D* record,\n    const volatile WGPUExtent3DTransfer* transfer,\n    DeserializeBuffer* deserializeBuffer,\n    DeserializeAllocator* allocator) {\n    DAWN_UNUSED(allocator);\n\n\n\n    static_assert(sizeof(record->width) >= sizeof(transfer->width), \"Deserialize assignment may not narrow.\");\nrecord->width = transfer->width;\n    static_assert(sizeof(record->height) >= sizeof(transfer->height), \"Deserialize assignment may not narrow.\");\nrecord->height = transfer->height;\n    static_assert(sizeof(record->depthOrArrayLayers) >= sizeof(transfer->depthOrArrayLayers), \"Deserialize assignment may not narrow.\");\nrecord->depthOrArrayLayers = transfer->depthOrArrayLayers;\n\n\n\n\n\n    return WireResult::Success;\n}\nDAWN_UNUSED_FUNC(WGPUExtent3DDeserialize);\n\n                \nstruct WGPUExternalTextureBindingEntryTransfer {\n    static_assert(0 <= 1,\n                  \"Record must be at most one of is_cmd, extensible, and chained.\");\n    WGPUChainedStructTransfer chain;\n\n    ObjectId externalTexture;\n\n\n};\n\n\nstatic_assert(offsetof(WGPUExternalTextureBindingEntryTransfer, chain) == 0);\n\nDAWN_DECLARE_UNUSED size_t WGPUExternalTextureBindingEntryGetExtraRequiredSize(const WGPUExternalTextureBindingEntry& record) {\n    DAWN_UNUSED(record);\n\n    size_t result = 0;\n\n\n\n    {\n    }\n\n    return result;\n}\n// GetExtraRequiredSize isn't used for structures that are value members of other structures\n// because we assume they cannot contain pointers themselves.\nDAWN_UNUSED_FUNC(WGPUExternalTextureBindingEntryGetExtraRequiredSize);\n\nDAWN_DECLARE_UNUSED WireResult WGPUExternalTextureBindingEntrySerialize(\n    const WGPUExternalTextureBindingEntry& record,\n    WGPUExternalTextureBindingEntryTransfer* transfer,\n    SerializeBuffer* buffer, const ObjectIdProvider& provider) {\n    DAWN_UNUSED(buffer);\n\n\n    WIRE_TRY(provider.GetId(record.externalTexture, &transfer->externalTexture));\n\n\n    ASSERT(transfer->chain.sType == WGPUSType_ExternalTextureBindingEntry);\n    ASSERT(transfer->chain.hasNext == (record.chain.next != nullptr));\n\n\n    return WireResult::Success;\n}\nDAWN_UNUSED_FUNC(WGPUExternalTextureBindingEntrySerialize);\n\nDAWN_DECLARE_UNUSED WireResult WGPUExternalTextureBindingEntryDeserialize(\n    WGPUExternalTextureBindingEntry* record,\n    const volatile WGPUExternalTextureBindingEntryTransfer* transfer,\n    DeserializeBuffer* deserializeBuffer,\n    DeserializeAllocator* allocator, const ObjectIdResolver& resolver) {\n    DAWN_UNUSED(allocator);\n\n\n\n    WIRE_TRY(resolver.GetFromId(transfer->externalTexture, &record->externalTexture));\n\n\n    ASSERT(record->chain.sType == WGPUSType_ExternalTextureBindingEntry);\n    ASSERT(record->chain.next == nullptr);\n\n\n\n    return WireResult::Success;\n}\nDAWN_UNUSED_FUNC(WGPUExternalTextureBindingEntryDeserialize);\n\n                \nstruct WGPUExternalTextureBindingLayoutTransfer {\n    static_assert(0 <= 1,\n                  \"Record must be at most one of is_cmd, extensible, and chained.\");\n    WGPUChainedStructTransfer chain;\n\n\n\n};\n\n\nstatic_assert(offsetof(WGPUExternalTextureBindingLayoutTransfer, chain) == 0);\n\nDAWN_DECLARE_UNUSED size_t WGPUExternalTextureBindingLayoutGetExtraRequiredSize(const WGPUExternalTextureBindingLayout& record) {\n    DAWN_UNUSED(record);\n\n    size_t result = 0;\n\n\n\n\n    return result;\n}\n// GetExtraRequiredSize isn't used for structures that are value members of other structures\n// because we assume they cannot contain pointers themselves.\nDAWN_UNUSED_FUNC(WGPUExternalTextureBindingLayoutGetExtraRequiredSize);\n\nDAWN_DECLARE_UNUSED WireResult WGPUExternalTextureBindingLayoutSerialize(\n    const WGPUExternalTextureBindingLayout& record,\n    WGPUExternalTextureBindingLayoutTransfer* transfer,\n    SerializeBuffer* buffer, const ObjectIdProvider& provider) {\n    DAWN_UNUSED(buffer);\n\n\n\n\n    ASSERT(transfer->chain.sType == WGPUSType_ExternalTextureBindingLayout);\n    ASSERT(transfer->chain.hasNext == (record.chain.next != nullptr));\n\n\n    return WireResult::Success;\n}\nDAWN_UNUSED_FUNC(WGPUExternalTextureBindingLayoutSerialize);\n\nDAWN_DECLARE_UNUSED WireResult WGPUExternalTextureBindingLayoutDeserialize(\n    WGPUExternalTextureBindingLayout* record,\n    const volatile WGPUExternalTextureBindingLayoutTransfer* transfer,\n    DeserializeBuffer* deserializeBuffer,\n    DeserializeAllocator* allocator, const ObjectIdResolver& resolver) {\n    DAWN_UNUSED(allocator);\n\n\n\n\n\n    ASSERT(record->chain.sType == WGPUSType_ExternalTextureBindingLayout);\n    ASSERT(record->chain.next == nullptr);\n\n\n\n    return WireResult::Success;\n}\nDAWN_UNUSED_FUNC(WGPUExternalTextureBindingLayoutDeserialize);\n\n                \nstruct WGPUExternalTextureDescriptorTransfer {\n    static_assert(0 <= 1,\n                  \"Record must be at most one of is_cmd, extensible, and chained.\");\n    bool hasNextInChain;\n\n    ObjectId plane0;\n    ObjectId plane1;\n    \nbool doYuvToRgbConversionOnly;\n\n    uint64_t labelStrlen;\n\n    bool has_label;\n    bool has_yuvToRgbConversionMatrix;\n};\n\n\n\nDAWN_DECLARE_UNUSED size_t WGPUExternalTextureDescriptorGetExtraRequiredSize(const WGPUExternalTextureDescriptor& record) {\n    DAWN_UNUSED(record);\n\n    size_t result = 0;\n\n    if (record.nextInChain != nullptr) {\n        result += GetChainedStructExtraRequiredSize(record.nextInChain);\n    }\n\n\n    bool has_label = record.label != nullptr;\n    if (has_label)\n    {\n    result += std::strlen(record.label);\n    }\n\n    {\n    }\n    {\n    }\n    {\n    }\n    if (record.yuvToRgbConversionMatrix != nullptr)\n    {\n        \n        auto memberLength = 12u;\n        result += memberLength * sizeof(\nfloat);\n    }\n    {\n        \n        auto memberLength = 7u;\n        result += memberLength * sizeof(\nfloat);\n    }\n    {\n        \n        auto memberLength = 7u;\n        result += memberLength * sizeof(\nfloat);\n    }\n    {\n        \n        auto memberLength = 9u;\n        result += memberLength * sizeof(\nfloat);\n    }\n\n    return result;\n}\n// GetExtraRequiredSize isn't used for structures that are value members of other structures\n// because we assume they cannot contain pointers themselves.\nDAWN_UNUSED_FUNC(WGPUExternalTextureDescriptorGetExtraRequiredSize);\n\nDAWN_DECLARE_UNUSED WireResult WGPUExternalTextureDescriptorSerialize(\n    const WGPUExternalTextureDescriptor& record,\n    WGPUExternalTextureDescriptorTransfer* transfer,\n    SerializeBuffer* buffer, const ObjectIdProvider& provider) {\n    DAWN_UNUSED(buffer);\n\n\n    WIRE_TRY(provider.GetId(record.plane0, &transfer->plane0));\n    WIRE_TRY(provider.GetOptionalId(record.plane1, &transfer->plane1));\n    transfer->doYuvToRgbConversionOnly = record.doYuvToRgbConversionOnly;\n\n    if (record.nextInChain != nullptr) {\n        transfer->hasNextInChain = true;\n        WIRE_TRY(SerializeChainedStruct(record.nextInChain, buffer, provider));\n    } else {\n        transfer->hasNextInChain = false;\n    }\n\n\n\n    bool has_label = record.label != nullptr;\n    transfer->has_label = has_label;\n    if (has_label)\n    {\n        transfer->labelStrlen = std::strlen(record.label);\n\n        char* stringInBuffer;\n        WIRE_TRY(buffer->NextN(transfer->labelStrlen, &stringInBuffer));\n        memcpy(stringInBuffer, record.label, transfer->labelStrlen);\n    }\n\n    \n\n    bool has_yuvToRgbConversionMatrix = record.yuvToRgbConversionMatrix != nullptr;\n    transfer->has_yuvToRgbConversionMatrix = has_yuvToRgbConversionMatrix;\n    if (has_yuvToRgbConversionMatrix)\n    {\n        auto memberLength = 12u;\n\n        \nfloat* memberBuffer;\n        WIRE_TRY(buffer->NextN(memberLength, &memberBuffer));\n\n        memcpy(\n            memberBuffer, record.yuvToRgbConversionMatrix,\n            sizeof(\nfloat) * memberLength);\n    }\n    \n\n    {\n        auto memberLength = 7u;\n\n        \nfloat* memberBuffer;\n        WIRE_TRY(buffer->NextN(memberLength, &memberBuffer));\n\n        memcpy(\n            memberBuffer, record.srcTransferFunctionParameters,\n            sizeof(\nfloat) * memberLength);\n    }\n    \n\n    {\n        auto memberLength = 7u;\n\n        \nfloat* memberBuffer;\n        WIRE_TRY(buffer->NextN(memberLength, &memberBuffer));\n\n        memcpy(\n            memberBuffer, record.dstTransferFunctionParameters,\n            sizeof(\nfloat) * memberLength);\n    }\n    \n\n    {\n        auto memberLength = 9u;\n\n        \nfloat* memberBuffer;\n        WIRE_TRY(buffer->NextN(memberLength, &memberBuffer));\n\n        memcpy(\n            memberBuffer, record.gamutConversionMatrix,\n            sizeof(\nfloat) * memberLength);\n    }\n    return WireResult::Success;\n}\nDAWN_UNUSED_FUNC(WGPUExternalTextureDescriptorSerialize);\n\nDAWN_DECLARE_UNUSED WireResult WGPUExternalTextureDescriptorDeserialize(\n    WGPUExternalTextureDescriptor* record,\n    const volatile WGPUExternalTextureDescriptorTransfer* transfer,\n    DeserializeBuffer* deserializeBuffer,\n    DeserializeAllocator* allocator, const ObjectIdResolver& resolver) {\n    DAWN_UNUSED(allocator);\n\n\n\n    WIRE_TRY(resolver.GetFromId(transfer->plane0, &record->plane0));\n    WIRE_TRY(resolver.GetOptionalFromId(transfer->plane1, &record->plane1));\n    static_assert(sizeof(record->doYuvToRgbConversionOnly) >= sizeof(transfer->doYuvToRgbConversionOnly), \"Deserialize assignment may not narrow.\");\nrecord->doYuvToRgbConversionOnly = transfer->doYuvToRgbConversionOnly;\n\n    record->nextInChain = nullptr;\n    if (transfer->hasNextInChain) {\n        WIRE_TRY(DeserializeChainedStruct(&record->nextInChain, deserializeBuffer, allocator, resolver));\n    }\n\n\n\n    bool has_label = transfer->has_label;\n    record->label = nullptr;\n    if (has_label)\n    {\n        uint64_t stringLength64 = transfer->labelStrlen;\n        if (stringLength64 >= std::numeric_limits<size_t>::max()) {\n            return WireResult::FatalError;\n        }\n        size_t stringLength = static_cast<size_t>(stringLength64);\n\n        const volatile char* stringInBuffer;\n        WIRE_TRY(deserializeBuffer->ReadN(stringLength, &stringInBuffer));\n\n        char* copiedString;\n        WIRE_TRY(GetSpace(allocator, stringLength + 1, &copiedString));\n        memcpy(copiedString, const_cast<const char*>(stringInBuffer), stringLength);\n        copiedString[stringLength] = '\\0';\n        record->label = copiedString;\n    }\n\n    \n\n    \n    bool has_yuvToRgbConversionMatrix = transfer->has_yuvToRgbConversionMatrix;\n    record->yuvToRgbConversionMatrix = nullptr;\n    if (has_yuvToRgbConversionMatrix)\n    {\n        auto memberLength = 12u;\n        const volatile \nfloat* memberBuffer;\n        WIRE_TRY(deserializeBuffer->ReadN(memberLength, &memberBuffer));\n\n        float* copiedMembers;\n        WIRE_TRY(GetSpace(allocator, memberLength, &copiedMembers));\n        record->yuvToRgbConversionMatrix = copiedMembers;\n\n        memcpy(\n            copiedMembers,\n            const_cast<const \nfloat*>(memberBuffer),\n           sizeof(\nfloat) * memberLength);\n    }\n    \n\n    {\n        auto memberLength = 7u;\n        const volatile \nfloat* memberBuffer;\n        WIRE_TRY(deserializeBuffer->ReadN(memberLength, &memberBuffer));\n\n        float* copiedMembers;\n        WIRE_TRY(GetSpace(allocator, memberLength, &copiedMembers));\n        record->srcTransferFunctionParameters = copiedMembers;\n\n        memcpy(\n            copiedMembers,\n            const_cast<const \nfloat*>(memberBuffer),\n           sizeof(\nfloat) * memberLength);\n    }\n    \n\n    {\n        auto memberLength = 7u;\n        const volatile \nfloat* memberBuffer;\n        WIRE_TRY(deserializeBuffer->ReadN(memberLength, &memberBuffer));\n\n        float* copiedMembers;\n        WIRE_TRY(GetSpace(allocator, memberLength, &copiedMembers));\n        record->dstTransferFunctionParameters = copiedMembers;\n\n        memcpy(\n            copiedMembers,\n            const_cast<const \nfloat*>(memberBuffer),\n           sizeof(\nfloat) * memberLength);\n    }\n    \n\n    {\n        auto memberLength = 9u;\n        const volatile \nfloat* memberBuffer;\n        WIRE_TRY(deserializeBuffer->ReadN(memberLength, &memberBuffer));\n\n        float* copiedMembers;\n        WIRE_TRY(GetSpace(allocator, memberLength, &copiedMembers));\n        record->gamutConversionMatrix = copiedMembers;\n\n        memcpy(\n            copiedMembers,\n            const_cast<const \nfloat*>(memberBuffer),\n           sizeof(\nfloat) * memberLength);\n    }\n\n    return WireResult::Success;\n}\nDAWN_UNUSED_FUNC(WGPUExternalTextureDescriptorDeserialize);\n\n                \nstruct WGPUInstanceDescriptorTransfer {\n    static_assert(0 <= 1,\n                  \"Record must be at most one of is_cmd, extensible, and chained.\");\n    bool hasNextInChain;\n\n\n\n};\n\n\n\nDAWN_DECLARE_UNUSED size_t WGPUInstanceDescriptorGetExtraRequiredSize(const WGPUInstanceDescriptor& record) {\n    DAWN_UNUSED(record);\n\n    size_t result = 0;\n\n    if (record.nextInChain != nullptr) {\n        result += GetChainedStructExtraRequiredSize(record.nextInChain);\n    }\n\n\n\n    return result;\n}\n// GetExtraRequiredSize isn't used for structures that are value members of other structures\n// because we assume they cannot contain pointers themselves.\nDAWN_UNUSED_FUNC(WGPUInstanceDescriptorGetExtraRequiredSize);\n\nDAWN_DECLARE_UNUSED WireResult WGPUInstanceDescriptorSerialize(\n    const WGPUInstanceDescriptor& record,\n    WGPUInstanceDescriptorTransfer* transfer,\n    SerializeBuffer* buffer, const ObjectIdProvider& provider) {\n    DAWN_UNUSED(buffer);\n\n\n\n    if (record.nextInChain != nullptr) {\n        transfer->hasNextInChain = true;\n        WIRE_TRY(SerializeChainedStruct(record.nextInChain, buffer, provider));\n    } else {\n        transfer->hasNextInChain = false;\n    }\n\n\n\n    return WireResult::Success;\n}\nDAWN_UNUSED_FUNC(WGPUInstanceDescriptorSerialize);\n\nDAWN_DECLARE_UNUSED WireResult WGPUInstanceDescriptorDeserialize(\n    WGPUInstanceDescriptor* record,\n    const volatile WGPUInstanceDescriptorTransfer* transfer,\n    DeserializeBuffer* deserializeBuffer,\n    DeserializeAllocator* allocator, const ObjectIdResolver& resolver) {\n    DAWN_UNUSED(allocator);\n\n\n\n\n    record->nextInChain = nullptr;\n    if (transfer->hasNextInChain) {\n        WIRE_TRY(DeserializeChainedStruct(&record->nextInChain, deserializeBuffer, allocator, resolver));\n    }\n\n\n\n\n    return WireResult::Success;\n}\nDAWN_UNUSED_FUNC(WGPUInstanceDescriptorDeserialize);\n\n                \nstruct WGPULimitsTransfer {\n    static_assert(0 <= 1,\n                  \"Record must be at most one of is_cmd, extensible, and chained.\");\n\n    \nuint32_t maxTextureDimension1D;\n    \nuint32_t maxTextureDimension2D;\n    \nuint32_t maxTextureDimension3D;\n    \nuint32_t maxTextureArrayLayers;\n    \nuint32_t maxBindGroups;\n    \nuint32_t maxDynamicUniformBuffersPerPipelineLayout;\n    \nuint32_t maxDynamicStorageBuffersPerPipelineLayout;\n    \nuint32_t maxSampledTexturesPerShaderStage;\n    \nuint32_t maxSamplersPerShaderStage;\n    \nuint32_t maxStorageBuffersPerShaderStage;\n    \nuint32_t maxStorageTexturesPerShaderStage;\n    \nuint32_t maxUniformBuffersPerShaderStage;\n    \nuint64_t maxUniformBufferBindingSize;\n    \nuint64_t maxStorageBufferBindingSize;\n    \nuint32_t minUniformBufferOffsetAlignment;\n    \nuint32_t minStorageBufferOffsetAlignment;\n    \nuint32_t maxVertexBuffers;\n    \nuint32_t maxVertexAttributes;\n    \nuint32_t maxVertexBufferArrayStride;\n    \nuint32_t maxInterStageShaderComponents;\n    \nuint32_t maxInterStageShaderVariables;\n    \nuint32_t maxColorAttachments;\n    \nuint32_t maxComputeWorkgroupStorageSize;\n    \nuint32_t maxComputeInvocationsPerWorkgroup;\n    \nuint32_t maxComputeWorkgroupSizeX;\n    \nuint32_t maxComputeWorkgroupSizeY;\n    \nuint32_t maxComputeWorkgroupSizeZ;\n    \nuint32_t maxComputeWorkgroupsPerDimension;\n\n\n};\n\n\n\nDAWN_DECLARE_UNUSED size_t WGPULimitsGetExtraRequiredSize(const WGPULimits& record) {\n    DAWN_UNUSED(record);\n\n    size_t result = 0;\n\n\n\n    {\n    }\n    {\n    }\n    {\n    }\n    {\n    }\n    {\n    }\n    {\n    }\n    {\n    }\n    {\n    }\n    {\n    }\n    {\n    }\n    {\n    }\n    {\n    }\n    {\n    }\n    {\n    }\n    {\n    }\n    {\n    }\n    {\n    }\n    {\n    }\n    {\n    }\n    {\n    }\n    {\n    }\n    {\n    }\n    {\n    }\n    {\n    }\n    {\n    }\n    {\n    }\n    {\n    }\n    {\n    }\n\n    return result;\n}\n// GetExtraRequiredSize isn't used for structures that are value members of other structures\n// because we assume they cannot contain pointers themselves.\nDAWN_UNUSED_FUNC(WGPULimitsGetExtraRequiredSize);\n\nDAWN_DECLARE_UNUSED WireResult WGPULimitsSerialize(\n    const WGPULimits& record,\n    WGPULimitsTransfer* transfer,\n    SerializeBuffer* buffer) {\n    DAWN_UNUSED(buffer);\n\n\n    transfer->maxTextureDimension1D = record.maxTextureDimension1D;\n    transfer->maxTextureDimension2D = record.maxTextureDimension2D;\n    transfer->maxTextureDimension3D = record.maxTextureDimension3D;\n    transfer->maxTextureArrayLayers = record.maxTextureArrayLayers;\n    transfer->maxBindGroups = record.maxBindGroups;\n    transfer->maxDynamicUniformBuffersPerPipelineLayout = record.maxDynamicUniformBuffersPerPipelineLayout;\n    transfer->maxDynamicStorageBuffersPerPipelineLayout = record.maxDynamicStorageBuffersPerPipelineLayout;\n    transfer->maxSampledTexturesPerShaderStage = record.maxSampledTexturesPerShaderStage;\n    transfer->maxSamplersPerShaderStage = record.maxSamplersPerShaderStage;\n    transfer->maxStorageBuffersPerShaderStage = record.maxStorageBuffersPerShaderStage;\n    transfer->maxStorageTexturesPerShaderStage = record.maxStorageTexturesPerShaderStage;\n    transfer->maxUniformBuffersPerShaderStage = record.maxUniformBuffersPerShaderStage;\n    transfer->maxUniformBufferBindingSize = record.maxUniformBufferBindingSize;\n    transfer->maxStorageBufferBindingSize = record.maxStorageBufferBindingSize;\n    transfer->minUniformBufferOffsetAlignment = record.minUniformBufferOffsetAlignment;\n    transfer->minStorageBufferOffsetAlignment = record.minStorageBufferOffsetAlignment;\n    transfer->maxVertexBuffers = record.maxVertexBuffers;\n    transfer->maxVertexAttributes = record.maxVertexAttributes;\n    transfer->maxVertexBufferArrayStride = record.maxVertexBufferArrayStride;\n    transfer->maxInterStageShaderComponents = record.maxInterStageShaderComponents;\n    transfer->maxInterStageShaderVariables = record.maxInterStageShaderVariables;\n    transfer->maxColorAttachments = record.maxColorAttachments;\n    transfer->maxComputeWorkgroupStorageSize = record.maxComputeWorkgroupStorageSize;\n    transfer->maxComputeInvocationsPerWorkgroup = record.maxComputeInvocationsPerWorkgroup;\n    transfer->maxComputeWorkgroupSizeX = record.maxComputeWorkgroupSizeX;\n    transfer->maxComputeWorkgroupSizeY = record.maxComputeWorkgroupSizeY;\n    transfer->maxComputeWorkgroupSizeZ = record.maxComputeWorkgroupSizeZ;\n    transfer->maxComputeWorkgroupsPerDimension = record.maxComputeWorkgroupsPerDimension;\n\n\n\n\n    return WireResult::Success;\n}\nDAWN_UNUSED_FUNC(WGPULimitsSerialize);\n\nDAWN_DECLARE_UNUSED WireResult WGPULimitsDeserialize(\n    WGPULimits* record,\n    const volatile WGPULimitsTransfer* transfer,\n    DeserializeBuffer* deserializeBuffer,\n    DeserializeAllocator* allocator) {\n    DAWN_UNUSED(allocator);\n\n\n\n    static_assert(sizeof(record->maxTextureDimension1D) >= sizeof(transfer->maxTextureDimension1D), \"Deserialize assignment may not narrow.\");\nrecord->maxTextureDimension1D = transfer->maxTextureDimension1D;\n    static_assert(sizeof(record->maxTextureDimension2D) >= sizeof(transfer->maxTextureDimension2D), \"Deserialize assignment may not narrow.\");\nrecord->maxTextureDimension2D = transfer->maxTextureDimension2D;\n    static_assert(sizeof(record->maxTextureDimension3D) >= sizeof(transfer->maxTextureDimension3D), \"Deserialize assignment may not narrow.\");\nrecord->maxTextureDimension3D = transfer->maxTextureDimension3D;\n    static_assert(sizeof(record->maxTextureArrayLayers) >= sizeof(transfer->maxTextureArrayLayers), \"Deserialize assignment may not narrow.\");\nrecord->maxTextureArrayLayers = transfer->maxTextureArrayLayers;\n    static_assert(sizeof(record->maxBindGroups) >= sizeof(transfer->maxBindGroups), \"Deserialize assignment may not narrow.\");\nrecord->maxBindGroups = transfer->maxBindGroups;\n    static_assert(sizeof(record->maxDynamicUniformBuffersPerPipelineLayout) >= sizeof(transfer->maxDynamicUniformBuffersPerPipelineLayout), \"Deserialize assignment may not narrow.\");\nrecord->maxDynamicUniformBuffersPerPipelineLayout = transfer->maxDynamicUniformBuffersPerPipelineLayout;\n    static_assert(sizeof(record->maxDynamicStorageBuffersPerPipelineLayout) >= sizeof(transfer->maxDynamicStorageBuffersPerPipelineLayout), \"Deserialize assignment may not narrow.\");\nrecord->maxDynamicStorageBuffersPerPipelineLayout = transfer->maxDynamicStorageBuffersPerPipelineLayout;\n    static_assert(sizeof(record->maxSampledTexturesPerShaderStage) >= sizeof(transfer->maxSampledTexturesPerShaderStage), \"Deserialize assignment may not narrow.\");\nrecord->maxSampledTexturesPerShaderStage = transfer->maxSampledTexturesPerShaderStage;\n    static_assert(sizeof(record->maxSamplersPerShaderStage) >= sizeof(transfer->maxSamplersPerShaderStage), \"Deserialize assignment may not narrow.\");\nrecord->maxSamplersPerShaderStage = transfer->maxSamplersPerShaderStage;\n    static_assert(sizeof(record->maxStorageBuffersPerShaderStage) >= sizeof(transfer->maxStorageBuffersPerShaderStage), \"Deserialize assignment may not narrow.\");\nrecord->maxStorageBuffersPerShaderStage = transfer->maxStorageBuffersPerShaderStage;\n    static_assert(sizeof(record->maxStorageTexturesPerShaderStage) >= sizeof(transfer->maxStorageTexturesPerShaderStage), \"Deserialize assignment may not narrow.\");\nrecord->maxStorageTexturesPerShaderStage = transfer->maxStorageTexturesPerShaderStage;\n    static_assert(sizeof(record->maxUniformBuffersPerShaderStage) >= sizeof(transfer->maxUniformBuffersPerShaderStage), \"Deserialize assignment may not narrow.\");\nrecord->maxUniformBuffersPerShaderStage = transfer->maxUniformBuffersPerShaderStage;\n    static_assert(sizeof(record->maxUniformBufferBindingSize) >= sizeof(transfer->maxUniformBufferBindingSize), \"Deserialize assignment may not narrow.\");\nrecord->maxUniformBufferBindingSize = transfer->maxUniformBufferBindingSize;\n    static_assert(sizeof(record->maxStorageBufferBindingSize) >= sizeof(transfer->maxStorageBufferBindingSize), \"Deserialize assignment may not narrow.\");\nrecord->maxStorageBufferBindingSize = transfer->maxStorageBufferBindingSize;\n    static_assert(sizeof(record->minUniformBufferOffsetAlignment) >= sizeof(transfer->minUniformBufferOffsetAlignment), \"Deserialize assignment may not narrow.\");\nrecord->minUniformBufferOffsetAlignment = transfer->minUniformBufferOffsetAlignment;\n    static_assert(sizeof(record->minStorageBufferOffsetAlignment) >= sizeof(transfer->minStorageBufferOffsetAlignment), \"Deserialize assignment may not narrow.\");\nrecord->minStorageBufferOffsetAlignment = transfer->minStorageBufferOffsetAlignment;\n    static_assert(sizeof(record->maxVertexBuffers) >= sizeof(transfer->maxVertexBuffers), \"Deserialize assignment may not narrow.\");\nrecord->maxVertexBuffers = transfer->maxVertexBuffers;\n    static_assert(sizeof(record->maxVertexAttributes) >= sizeof(transfer->maxVertexAttributes), \"Deserialize assignment may not narrow.\");\nrecord->maxVertexAttributes = transfer->maxVertexAttributes;\n    static_assert(sizeof(record->maxVertexBufferArrayStride) >= sizeof(transfer->maxVertexBufferArrayStride), \"Deserialize assignment may not narrow.\");\nrecord->maxVertexBufferArrayStride = transfer->maxVertexBufferArrayStride;\n    static_assert(sizeof(record->maxInterStageShaderComponents) >= sizeof(transfer->maxInterStageShaderComponents), \"Deserialize assignment may not narrow.\");\nrecord->maxInterStageShaderComponents = transfer->maxInterStageShaderComponents;\n    static_assert(sizeof(record->maxInterStageShaderVariables) >= sizeof(transfer->maxInterStageShaderVariables), \"Deserialize assignment may not narrow.\");\nrecord->maxInterStageShaderVariables = transfer->maxInterStageShaderVariables;\n    static_assert(sizeof(record->maxColorAttachments) >= sizeof(transfer->maxColorAttachments), \"Deserialize assignment may not narrow.\");\nrecord->maxColorAttachments = transfer->maxColorAttachments;\n    static_assert(sizeof(record->maxComputeWorkgroupStorageSize) >= sizeof(transfer->maxComputeWorkgroupStorageSize), \"Deserialize assignment may not narrow.\");\nrecord->maxComputeWorkgroupStorageSize = transfer->maxComputeWorkgroupStorageSize;\n    static_assert(sizeof(record->maxComputeInvocationsPerWorkgroup) >= sizeof(transfer->maxComputeInvocationsPerWorkgroup), \"Deserialize assignment may not narrow.\");\nrecord->maxComputeInvocationsPerWorkgroup = transfer->maxComputeInvocationsPerWorkgroup;\n    static_assert(sizeof(record->maxComputeWorkgroupSizeX) >= sizeof(transfer->maxComputeWorkgroupSizeX), \"Deserialize assignment may not narrow.\");\nrecord->maxComputeWorkgroupSizeX = transfer->maxComputeWorkgroupSizeX;\n    static_assert(sizeof(record->maxComputeWorkgroupSizeY) >= sizeof(transfer->maxComputeWorkgroupSizeY), \"Deserialize assignment may not narrow.\");\nrecord->maxComputeWorkgroupSizeY = transfer->maxComputeWorkgroupSizeY;\n    static_assert(sizeof(record->maxComputeWorkgroupSizeZ) >= sizeof(transfer->maxComputeWorkgroupSizeZ), \"Deserialize assignment may not narrow.\");\nrecord->maxComputeWorkgroupSizeZ = transfer->maxComputeWorkgroupSizeZ;\n    static_assert(sizeof(record->maxComputeWorkgroupsPerDimension) >= sizeof(transfer->maxComputeWorkgroupsPerDimension), \"Deserialize assignment may not narrow.\");\nrecord->maxComputeWorkgroupsPerDimension = transfer->maxComputeWorkgroupsPerDimension;\n\n\n\n\n\n    return WireResult::Success;\n}\nDAWN_UNUSED_FUNC(WGPULimitsDeserialize);\n\n                \nstruct WGPUMultisampleStateTransfer {\n    static_assert(0 <= 1,\n                  \"Record must be at most one of is_cmd, extensible, and chained.\");\n    bool hasNextInChain;\n\n    \nuint32_t count;\n    \nuint32_t mask;\n    \nbool alphaToCoverageEnabled;\n\n\n};\n\n\n\nDAWN_DECLARE_UNUSED size_t WGPUMultisampleStateGetExtraRequiredSize(const WGPUMultisampleState& record) {\n    DAWN_UNUSED(record);\n\n    size_t result = 0;\n\n    if (record.nextInChain != nullptr) {\n        result += GetChainedStructExtraRequiredSize(record.nextInChain);\n    }\n\n\n    {\n    }\n    {\n    }\n    {\n    }\n\n    return result;\n}\n// GetExtraRequiredSize isn't used for structures that are value members of other structures\n// because we assume they cannot contain pointers themselves.\nDAWN_UNUSED_FUNC(WGPUMultisampleStateGetExtraRequiredSize);\n\nDAWN_DECLARE_UNUSED WireResult WGPUMultisampleStateSerialize(\n    const WGPUMultisampleState& record,\n    WGPUMultisampleStateTransfer* transfer,\n    SerializeBuffer* buffer, const ObjectIdProvider& provider) {\n    DAWN_UNUSED(buffer);\n\n\n    transfer->count = record.count;\n    transfer->mask = record.mask;\n    transfer->alphaToCoverageEnabled = record.alphaToCoverageEnabled;\n\n    if (record.nextInChain != nullptr) {\n        transfer->hasNextInChain = true;\n        WIRE_TRY(SerializeChainedStruct(record.nextInChain, buffer, provider));\n    } else {\n        transfer->hasNextInChain = false;\n    }\n\n\n\n    return WireResult::Success;\n}\nDAWN_UNUSED_FUNC(WGPUMultisampleStateSerialize);\n\nDAWN_DECLARE_UNUSED WireResult WGPUMultisampleStateDeserialize(\n    WGPUMultisampleState* record,\n    const volatile WGPUMultisampleStateTransfer* transfer,\n    DeserializeBuffer* deserializeBuffer,\n    DeserializeAllocator* allocator, const ObjectIdResolver& resolver) {\n    DAWN_UNUSED(allocator);\n\n\n\n    static_assert(sizeof(record->count) >= sizeof(transfer->count), \"Deserialize assignment may not narrow.\");\nrecord->count = transfer->count;\n    static_assert(sizeof(record->mask) >= sizeof(transfer->mask), \"Deserialize assignment may not narrow.\");\nrecord->mask = transfer->mask;\n    static_assert(sizeof(record->alphaToCoverageEnabled) >= sizeof(transfer->alphaToCoverageEnabled), \"Deserialize assignment may not narrow.\");\nrecord->alphaToCoverageEnabled = transfer->alphaToCoverageEnabled;\n\n    record->nextInChain = nullptr;\n    if (transfer->hasNextInChain) {\n        WIRE_TRY(DeserializeChainedStruct(&record->nextInChain, deserializeBuffer, allocator, resolver));\n    }\n\n\n\n\n    return WireResult::Success;\n}\nDAWN_UNUSED_FUNC(WGPUMultisampleStateDeserialize);\n\n                \nstruct WGPUOrigin3DTransfer {\n    static_assert(0 <= 1,\n                  \"Record must be at most one of is_cmd, extensible, and chained.\");\n\n    \nuint32_t x;\n    \nuint32_t y;\n    \nuint32_t z;\n\n\n};\n\n\n\nDAWN_DECLARE_UNUSED size_t WGPUOrigin3DGetExtraRequiredSize(const WGPUOrigin3D& record) {\n    DAWN_UNUSED(record);\n\n    size_t result = 0;\n\n\n\n    {\n    }\n    {\n    }\n    {\n    }\n\n    return result;\n}\n// GetExtraRequiredSize isn't used for structures that are value members of other structures\n// because we assume they cannot contain pointers themselves.\nDAWN_UNUSED_FUNC(WGPUOrigin3DGetExtraRequiredSize);\n\nDAWN_DECLARE_UNUSED WireResult WGPUOrigin3DSerialize(\n    const WGPUOrigin3D& record,\n    WGPUOrigin3DTransfer* transfer,\n    SerializeBuffer* buffer) {\n    DAWN_UNUSED(buffer);\n\n\n    transfer->x = record.x;\n    transfer->y = record.y;\n    transfer->z = record.z;\n\n\n\n\n    return WireResult::Success;\n}\nDAWN_UNUSED_FUNC(WGPUOrigin3DSerialize);\n\nDAWN_DECLARE_UNUSED WireResult WGPUOrigin3DDeserialize(\n    WGPUOrigin3D* record,\n    const volatile WGPUOrigin3DTransfer* transfer,\n    DeserializeBuffer* deserializeBuffer,\n    DeserializeAllocator* allocator) {\n    DAWN_UNUSED(allocator);\n\n\n\n    static_assert(sizeof(record->x) >= sizeof(transfer->x), \"Deserialize assignment may not narrow.\");\nrecord->x = transfer->x;\n    static_assert(sizeof(record->y) >= sizeof(transfer->y), \"Deserialize assignment may not narrow.\");\nrecord->y = transfer->y;\n    static_assert(sizeof(record->z) >= sizeof(transfer->z), \"Deserialize assignment may not narrow.\");\nrecord->z = transfer->z;\n\n\n\n\n\n    return WireResult::Success;\n}\nDAWN_UNUSED_FUNC(WGPUOrigin3DDeserialize);\n\n                \nstruct WGPUPipelineLayoutDescriptorTransfer {\n    static_assert(0 <= 1,\n                  \"Record must be at most one of is_cmd, extensible, and chained.\");\n    bool hasNextInChain;\n\n    \nuint32_t bindGroupLayoutCount;\n\n    uint64_t labelStrlen;\n\n    bool has_label;\n};\n\n\n\nDAWN_DECLARE_UNUSED size_t WGPUPipelineLayoutDescriptorGetExtraRequiredSize(const WGPUPipelineLayoutDescriptor& record) {\n    DAWN_UNUSED(record);\n\n    size_t result = 0;\n\n    if (record.nextInChain != nullptr) {\n        result += GetChainedStructExtraRequiredSize(record.nextInChain);\n    }\n\n\n    bool has_label = record.label != nullptr;\n    if (has_label)\n    {\n    result += std::strlen(record.label);\n    }\n\n    {\n    }\n    {\n        \n        auto memberLength = record.bindGroupLayoutCount;\n        result += memberLength * sizeof(ObjectId);\n    }\n\n    return result;\n}\n// GetExtraRequiredSize isn't used for structures that are value members of other structures\n// because we assume they cannot contain pointers themselves.\nDAWN_UNUSED_FUNC(WGPUPipelineLayoutDescriptorGetExtraRequiredSize);\n\nDAWN_DECLARE_UNUSED WireResult WGPUPipelineLayoutDescriptorSerialize(\n    const WGPUPipelineLayoutDescriptor& record,\n    WGPUPipelineLayoutDescriptorTransfer* transfer,\n    SerializeBuffer* buffer, const ObjectIdProvider& provider) {\n    DAWN_UNUSED(buffer);\n\n\n    transfer->bindGroupLayoutCount = record.bindGroupLayoutCount;\n\n    if (record.nextInChain != nullptr) {\n        transfer->hasNextInChain = true;\n        WIRE_TRY(SerializeChainedStruct(record.nextInChain, buffer, provider));\n    } else {\n        transfer->hasNextInChain = false;\n    }\n\n\n\n    bool has_label = record.label != nullptr;\n    transfer->has_label = has_label;\n    if (has_label)\n    {\n        transfer->labelStrlen = std::strlen(record.label);\n\n        char* stringInBuffer;\n        WIRE_TRY(buffer->NextN(transfer->labelStrlen, &stringInBuffer));\n        memcpy(stringInBuffer, record.label, transfer->labelStrlen);\n    }\n\n    \n\n    {\n        auto memberLength = record.bindGroupLayoutCount;\n\n        ObjectId* memberBuffer;\n        WIRE_TRY(buffer->NextN(memberLength, &memberBuffer));\n\n        for (decltype(memberLength) i = 0; i < memberLength; ++i) {\n            WIRE_TRY(provider.GetId(record.bindGroupLayouts[i], &memberBuffer[i]));\n        }\n    }\n    return WireResult::Success;\n}\nDAWN_UNUSED_FUNC(WGPUPipelineLayoutDescriptorSerialize);\n\nDAWN_DECLARE_UNUSED WireResult WGPUPipelineLayoutDescriptorDeserialize(\n    WGPUPipelineLayoutDescriptor* record,\n    const volatile WGPUPipelineLayoutDescriptorTransfer* transfer,\n    DeserializeBuffer* deserializeBuffer,\n    DeserializeAllocator* allocator, const ObjectIdResolver& resolver) {\n    DAWN_UNUSED(allocator);\n\n\n\n    static_assert(sizeof(record->bindGroupLayoutCount) >= sizeof(transfer->bindGroupLayoutCount), \"Deserialize assignment may not narrow.\");\nrecord->bindGroupLayoutCount = transfer->bindGroupLayoutCount;\n\n    record->nextInChain = nullptr;\n    if (transfer->hasNextInChain) {\n        WIRE_TRY(DeserializeChainedStruct(&record->nextInChain, deserializeBuffer, allocator, resolver));\n    }\n\n\n\n    bool has_label = transfer->has_label;\n    record->label = nullptr;\n    if (has_label)\n    {\n        uint64_t stringLength64 = transfer->labelStrlen;\n        if (stringLength64 >= std::numeric_limits<size_t>::max()) {\n            return WireResult::FatalError;\n        }\n        size_t stringLength = static_cast<size_t>(stringLength64);\n\n        const volatile char* stringInBuffer;\n        WIRE_TRY(deserializeBuffer->ReadN(stringLength, &stringInBuffer));\n\n        char* copiedString;\n        WIRE_TRY(GetSpace(allocator, stringLength + 1, &copiedString));\n        memcpy(copiedString, const_cast<const char*>(stringInBuffer), stringLength);\n        copiedString[stringLength] = '\\0';\n        record->label = copiedString;\n    }\n\n    \n\n    {\n        auto memberLength = record->bindGroupLayoutCount;\n        const volatile ObjectId* memberBuffer;\n        WIRE_TRY(deserializeBuffer->ReadN(memberLength, &memberBuffer));\n\n        WGPUBindGroupLayout* copiedMembers;\n        WIRE_TRY(GetSpace(allocator, memberLength, &copiedMembers));\n        record->bindGroupLayouts = copiedMembers;\n\n        for (decltype(memberLength) i = 0; i < memberLength; ++i) {\n            WIRE_TRY(resolver.GetFromId(memberBuffer[i], &copiedMembers[i]));\n        }\n    }\n\n    return WireResult::Success;\n}\nDAWN_UNUSED_FUNC(WGPUPipelineLayoutDescriptorDeserialize);\n\n                \nstruct WGPUPrimitiveDepthClipControlTransfer {\n    static_assert(0 <= 1,\n                  \"Record must be at most one of is_cmd, extensible, and chained.\");\n    WGPUChainedStructTransfer chain;\n\n    \nbool unclippedDepth;\n\n\n};\n\n\nstatic_assert(offsetof(WGPUPrimitiveDepthClipControlTransfer, chain) == 0);\n\nDAWN_DECLARE_UNUSED size_t WGPUPrimitiveDepthClipControlGetExtraRequiredSize(const WGPUPrimitiveDepthClipControl& record) {\n    DAWN_UNUSED(record);\n\n    size_t result = 0;\n\n\n\n    {\n    }\n\n    return result;\n}\n// GetExtraRequiredSize isn't used for structures that are value members of other structures\n// because we assume they cannot contain pointers themselves.\nDAWN_UNUSED_FUNC(WGPUPrimitiveDepthClipControlGetExtraRequiredSize);\n\nDAWN_DECLARE_UNUSED WireResult WGPUPrimitiveDepthClipControlSerialize(\n    const WGPUPrimitiveDepthClipControl& record,\n    WGPUPrimitiveDepthClipControlTransfer* transfer,\n    SerializeBuffer* buffer, const ObjectIdProvider& provider) {\n    DAWN_UNUSED(buffer);\n\n\n    transfer->unclippedDepth = record.unclippedDepth;\n\n\n    ASSERT(transfer->chain.sType == WGPUSType_PrimitiveDepthClipControl);\n    ASSERT(transfer->chain.hasNext == (record.chain.next != nullptr));\n\n\n    return WireResult::Success;\n}\nDAWN_UNUSED_FUNC(WGPUPrimitiveDepthClipControlSerialize);\n\nDAWN_DECLARE_UNUSED WireResult WGPUPrimitiveDepthClipControlDeserialize(\n    WGPUPrimitiveDepthClipControl* record,\n    const volatile WGPUPrimitiveDepthClipControlTransfer* transfer,\n    DeserializeBuffer* deserializeBuffer,\n    DeserializeAllocator* allocator, const ObjectIdResolver& resolver) {\n    DAWN_UNUSED(allocator);\n\n\n\n    static_assert(sizeof(record->unclippedDepth) >= sizeof(transfer->unclippedDepth), \"Deserialize assignment may not narrow.\");\nrecord->unclippedDepth = transfer->unclippedDepth;\n\n\n    ASSERT(record->chain.sType == WGPUSType_PrimitiveDepthClipControl);\n    ASSERT(record->chain.next == nullptr);\n\n\n\n    return WireResult::Success;\n}\nDAWN_UNUSED_FUNC(WGPUPrimitiveDepthClipControlDeserialize);\n\n                \nstruct WGPUPrimitiveStateTransfer {\n    static_assert(0 <= 1,\n                  \"Record must be at most one of is_cmd, extensible, and chained.\");\n    bool hasNextInChain;\n\n    \nWGPUPrimitiveTopology topology;\n    \nWGPUIndexFormat stripIndexFormat;\n    \nWGPUFrontFace frontFace;\n    \nWGPUCullMode cullMode;\n\n\n};\n\n\n\nDAWN_DECLARE_UNUSED size_t WGPUPrimitiveStateGetExtraRequiredSize(const WGPUPrimitiveState& record) {\n    DAWN_UNUSED(record);\n\n    size_t result = 0;\n\n    if (record.nextInChain != nullptr) {\n        result += GetChainedStructExtraRequiredSize(record.nextInChain);\n    }\n\n\n    {\n    }\n    {\n    }\n    {\n    }\n    {\n    }\n\n    return result;\n}\n// GetExtraRequiredSize isn't used for structures that are value members of other structures\n// because we assume they cannot contain pointers themselves.\nDAWN_UNUSED_FUNC(WGPUPrimitiveStateGetExtraRequiredSize);\n\nDAWN_DECLARE_UNUSED WireResult WGPUPrimitiveStateSerialize(\n    const WGPUPrimitiveState& record,\n    WGPUPrimitiveStateTransfer* transfer,\n    SerializeBuffer* buffer, const ObjectIdProvider& provider) {\n    DAWN_UNUSED(buffer);\n\n\n    transfer->topology = record.topology;\n    transfer->stripIndexFormat = record.stripIndexFormat;\n    transfer->frontFace = record.frontFace;\n    transfer->cullMode = record.cullMode;\n\n    if (record.nextInChain != nullptr) {\n        transfer->hasNextInChain = true;\n        WIRE_TRY(SerializeChainedStruct(record.nextInChain, buffer, provider));\n    } else {\n        transfer->hasNextInChain = false;\n    }\n\n\n\n    return WireResult::Success;\n}\nDAWN_UNUSED_FUNC(WGPUPrimitiveStateSerialize);\n\nDAWN_DECLARE_UNUSED WireResult WGPUPrimitiveStateDeserialize(\n    WGPUPrimitiveState* record,\n    const volatile WGPUPrimitiveStateTransfer* transfer,\n    DeserializeBuffer* deserializeBuffer,\n    DeserializeAllocator* allocator, const ObjectIdResolver& resolver) {\n    DAWN_UNUSED(allocator);\n\n\n\n    static_assert(sizeof(record->topology) >= sizeof(transfer->topology), \"Deserialize assignment may not narrow.\");\nrecord->topology = transfer->topology;\n    static_assert(sizeof(record->stripIndexFormat) >= sizeof(transfer->stripIndexFormat), \"Deserialize assignment may not narrow.\");\nrecord->stripIndexFormat = transfer->stripIndexFormat;\n    static_assert(sizeof(record->frontFace) >= sizeof(transfer->frontFace), \"Deserialize assignment may not narrow.\");\nrecord->frontFace = transfer->frontFace;\n    static_assert(sizeof(record->cullMode) >= sizeof(transfer->cullMode), \"Deserialize assignment may not narrow.\");\nrecord->cullMode = transfer->cullMode;\n\n    record->nextInChain = nullptr;\n    if (transfer->hasNextInChain) {\n        WIRE_TRY(DeserializeChainedStruct(&record->nextInChain, deserializeBuffer, allocator, resolver));\n    }\n\n\n\n\n    return WireResult::Success;\n}\nDAWN_UNUSED_FUNC(WGPUPrimitiveStateDeserialize);\n\n                \nstruct WGPUQuerySetDescriptorTransfer {\n    static_assert(0 <= 1,\n                  \"Record must be at most one of is_cmd, extensible, and chained.\");\n    bool hasNextInChain;\n\n    \nWGPUQueryType type;\n    \nuint32_t count;\n    \nuint32_t pipelineStatisticsCount;\n\n    uint64_t labelStrlen;\n\n    bool has_label;\n};\n\n\n\nDAWN_DECLARE_UNUSED size_t WGPUQuerySetDescriptorGetExtraRequiredSize(const WGPUQuerySetDescriptor& record) {\n    DAWN_UNUSED(record);\n\n    size_t result = 0;\n\n    if (record.nextInChain != nullptr) {\n        result += GetChainedStructExtraRequiredSize(record.nextInChain);\n    }\n\n\n    bool has_label = record.label != nullptr;\n    if (has_label)\n    {\n    result += std::strlen(record.label);\n    }\n\n    {\n    }\n    {\n    }\n    {\n        \n        auto memberLength = record.pipelineStatisticsCount;\n        result += memberLength * sizeof(\nWGPUPipelineStatisticName);\n    }\n    {\n    }\n\n    return result;\n}\n// GetExtraRequiredSize isn't used for structures that are value members of other structures\n// because we assume they cannot contain pointers themselves.\nDAWN_UNUSED_FUNC(WGPUQuerySetDescriptorGetExtraRequiredSize);\n\nDAWN_DECLARE_UNUSED WireResult WGPUQuerySetDescriptorSerialize(\n    const WGPUQuerySetDescriptor& record,\n    WGPUQuerySetDescriptorTransfer* transfer,\n    SerializeBuffer* buffer, const ObjectIdProvider& provider) {\n    DAWN_UNUSED(buffer);\n\n\n    transfer->type = record.type;\n    transfer->count = record.count;\n    transfer->pipelineStatisticsCount = record.pipelineStatisticsCount;\n\n    if (record.nextInChain != nullptr) {\n        transfer->hasNextInChain = true;\n        WIRE_TRY(SerializeChainedStruct(record.nextInChain, buffer, provider));\n    } else {\n        transfer->hasNextInChain = false;\n    }\n\n\n\n    bool has_label = record.label != nullptr;\n    transfer->has_label = has_label;\n    if (has_label)\n    {\n        transfer->labelStrlen = std::strlen(record.label);\n\n        char* stringInBuffer;\n        WIRE_TRY(buffer->NextN(transfer->labelStrlen, &stringInBuffer));\n        memcpy(stringInBuffer, record.label, transfer->labelStrlen);\n    }\n\n    \n\n    {\n        auto memberLength = record.pipelineStatisticsCount;\n\n        \nWGPUPipelineStatisticName* memberBuffer;\n        WIRE_TRY(buffer->NextN(memberLength, &memberBuffer));\n\n        memcpy(\n            memberBuffer, record.pipelineStatistics,\n            sizeof(\nWGPUPipelineStatisticName) * memberLength);\n    }\n    return WireResult::Success;\n}\nDAWN_UNUSED_FUNC(WGPUQuerySetDescriptorSerialize);\n\nDAWN_DECLARE_UNUSED WireResult WGPUQuerySetDescriptorDeserialize(\n    WGPUQuerySetDescriptor* record,\n    const volatile WGPUQuerySetDescriptorTransfer* transfer,\n    DeserializeBuffer* deserializeBuffer,\n    DeserializeAllocator* allocator, const ObjectIdResolver& resolver) {\n    DAWN_UNUSED(allocator);\n\n\n\n    static_assert(sizeof(record->type) >= sizeof(transfer->type), \"Deserialize assignment may not narrow.\");\nrecord->type = transfer->type;\n    static_assert(sizeof(record->count) >= sizeof(transfer->count), \"Deserialize assignment may not narrow.\");\nrecord->count = transfer->count;\n    static_assert(sizeof(record->pipelineStatisticsCount) >= sizeof(transfer->pipelineStatisticsCount), \"Deserialize assignment may not narrow.\");\nrecord->pipelineStatisticsCount = transfer->pipelineStatisticsCount;\n\n    record->nextInChain = nullptr;\n    if (transfer->hasNextInChain) {\n        WIRE_TRY(DeserializeChainedStruct(&record->nextInChain, deserializeBuffer, allocator, resolver));\n    }\n\n\n\n    bool has_label = transfer->has_label;\n    record->label = nullptr;\n    if (has_label)\n    {\n        uint64_t stringLength64 = transfer->labelStrlen;\n        if (stringLength64 >= std::numeric_limits<size_t>::max()) {\n            return WireResult::FatalError;\n        }\n        size_t stringLength = static_cast<size_t>(stringLength64);\n\n        const volatile char* stringInBuffer;\n        WIRE_TRY(deserializeBuffer->ReadN(stringLength, &stringInBuffer));\n\n        char* copiedString;\n        WIRE_TRY(GetSpace(allocator, stringLength + 1, &copiedString));\n        memcpy(copiedString, const_cast<const char*>(stringInBuffer), stringLength);\n        copiedString[stringLength] = '\\0';\n        record->label = copiedString;\n    }\n\n    \n\n    {\n        auto memberLength = record->pipelineStatisticsCount;\n        const volatile \nWGPUPipelineStatisticName* memberBuffer;\n        WIRE_TRY(deserializeBuffer->ReadN(memberLength, &memberBuffer));\n\n        WGPUPipelineStatisticName* copiedMembers;\n        WIRE_TRY(GetSpace(allocator, memberLength, &copiedMembers));\n        record->pipelineStatistics = copiedMembers;\n\n        memcpy(\n            copiedMembers,\n            const_cast<const \nWGPUPipelineStatisticName*>(memberBuffer),\n           sizeof(\nWGPUPipelineStatisticName) * memberLength);\n    }\n\n    return WireResult::Success;\n}\nDAWN_UNUSED_FUNC(WGPUQuerySetDescriptorDeserialize);\n\n                \nstruct WGPUQueueDescriptorTransfer {\n    static_assert(0 <= 1,\n                  \"Record must be at most one of is_cmd, extensible, and chained.\");\n    bool hasNextInChain;\n\n\n    uint64_t labelStrlen;\n\n    bool has_label;\n};\n\n\n\nDAWN_DECLARE_UNUSED size_t WGPUQueueDescriptorGetExtraRequiredSize(const WGPUQueueDescriptor& record) {\n    DAWN_UNUSED(record);\n\n    size_t result = 0;\n\n    if (record.nextInChain != nullptr) {\n        result += GetChainedStructExtraRequiredSize(record.nextInChain);\n    }\n\n\n    bool has_label = record.label != nullptr;\n    if (has_label)\n    {\n    result += std::strlen(record.label);\n    }\n\n\n    return result;\n}\n// GetExtraRequiredSize isn't used for structures that are value members of other structures\n// because we assume they cannot contain pointers themselves.\nDAWN_UNUSED_FUNC(WGPUQueueDescriptorGetExtraRequiredSize);\n\nDAWN_DECLARE_UNUSED WireResult WGPUQueueDescriptorSerialize(\n    const WGPUQueueDescriptor& record,\n    WGPUQueueDescriptorTransfer* transfer,\n    SerializeBuffer* buffer, const ObjectIdProvider& provider) {\n    DAWN_UNUSED(buffer);\n\n\n\n    if (record.nextInChain != nullptr) {\n        transfer->hasNextInChain = true;\n        WIRE_TRY(SerializeChainedStruct(record.nextInChain, buffer, provider));\n    } else {\n        transfer->hasNextInChain = false;\n    }\n\n\n\n    bool has_label = record.label != nullptr;\n    transfer->has_label = has_label;\n    if (has_label)\n    {\n        transfer->labelStrlen = std::strlen(record.label);\n\n        char* stringInBuffer;\n        WIRE_TRY(buffer->NextN(transfer->labelStrlen, &stringInBuffer));\n        memcpy(stringInBuffer, record.label, transfer->labelStrlen);\n    }\n\n    return WireResult::Success;\n}\nDAWN_UNUSED_FUNC(WGPUQueueDescriptorSerialize);\n\nDAWN_DECLARE_UNUSED WireResult WGPUQueueDescriptorDeserialize(\n    WGPUQueueDescriptor* record,\n    const volatile WGPUQueueDescriptorTransfer* transfer,\n    DeserializeBuffer* deserializeBuffer,\n    DeserializeAllocator* allocator, const ObjectIdResolver& resolver) {\n    DAWN_UNUSED(allocator);\n\n\n\n\n    record->nextInChain = nullptr;\n    if (transfer->hasNextInChain) {\n        WIRE_TRY(DeserializeChainedStruct(&record->nextInChain, deserializeBuffer, allocator, resolver));\n    }\n\n\n\n    bool has_label = transfer->has_label;\n    record->label = nullptr;\n    if (has_label)\n    {\n        uint64_t stringLength64 = transfer->labelStrlen;\n        if (stringLength64 >= std::numeric_limits<size_t>::max()) {\n            return WireResult::FatalError;\n        }\n        size_t stringLength = static_cast<size_t>(stringLength64);\n\n        const volatile char* stringInBuffer;\n        WIRE_TRY(deserializeBuffer->ReadN(stringLength, &stringInBuffer));\n\n        char* copiedString;\n        WIRE_TRY(GetSpace(allocator, stringLength + 1, &copiedString));\n        memcpy(copiedString, const_cast<const char*>(stringInBuffer), stringLength);\n        copiedString[stringLength] = '\\0';\n        record->label = copiedString;\n    }\n\n\n    return WireResult::Success;\n}\nDAWN_UNUSED_FUNC(WGPUQueueDescriptorDeserialize);\n\n                \nstruct WGPURenderBundleDescriptorTransfer {\n    static_assert(0 <= 1,\n                  \"Record must be at most one of is_cmd, extensible, and chained.\");\n    bool hasNextInChain;\n\n\n    uint64_t labelStrlen;\n\n    bool has_label;\n};\n\n\n\nDAWN_DECLARE_UNUSED size_t WGPURenderBundleDescriptorGetExtraRequiredSize(const WGPURenderBundleDescriptor& record) {\n    DAWN_UNUSED(record);\n\n    size_t result = 0;\n\n    if (record.nextInChain != nullptr) {\n        result += GetChainedStructExtraRequiredSize(record.nextInChain);\n    }\n\n\n    bool has_label = record.label != nullptr;\n    if (has_label)\n    {\n    result += std::strlen(record.label);\n    }\n\n\n    return result;\n}\n// GetExtraRequiredSize isn't used for structures that are value members of other structures\n// because we assume they cannot contain pointers themselves.\nDAWN_UNUSED_FUNC(WGPURenderBundleDescriptorGetExtraRequiredSize);\n\nDAWN_DECLARE_UNUSED WireResult WGPURenderBundleDescriptorSerialize(\n    const WGPURenderBundleDescriptor& record,\n    WGPURenderBundleDescriptorTransfer* transfer,\n    SerializeBuffer* buffer, const ObjectIdProvider& provider) {\n    DAWN_UNUSED(buffer);\n\n\n\n    if (record.nextInChain != nullptr) {\n        transfer->hasNextInChain = true;\n        WIRE_TRY(SerializeChainedStruct(record.nextInChain, buffer, provider));\n    } else {\n        transfer->hasNextInChain = false;\n    }\n\n\n\n    bool has_label = record.label != nullptr;\n    transfer->has_label = has_label;\n    if (has_label)\n    {\n        transfer->labelStrlen = std::strlen(record.label);\n\n        char* stringInBuffer;\n        WIRE_TRY(buffer->NextN(transfer->labelStrlen, &stringInBuffer));\n        memcpy(stringInBuffer, record.label, transfer->labelStrlen);\n    }\n\n    return WireResult::Success;\n}\nDAWN_UNUSED_FUNC(WGPURenderBundleDescriptorSerialize);\n\nDAWN_DECLARE_UNUSED WireResult WGPURenderBundleDescriptorDeserialize(\n    WGPURenderBundleDescriptor* record,\n    const volatile WGPURenderBundleDescriptorTransfer* transfer,\n    DeserializeBuffer* deserializeBuffer,\n    DeserializeAllocator* allocator, const ObjectIdResolver& resolver) {\n    DAWN_UNUSED(allocator);\n\n\n\n\n    record->nextInChain = nullptr;\n    if (transfer->hasNextInChain) {\n        WIRE_TRY(DeserializeChainedStruct(&record->nextInChain, deserializeBuffer, allocator, resolver));\n    }\n\n\n\n    bool has_label = transfer->has_label;\n    record->label = nullptr;\n    if (has_label)\n    {\n        uint64_t stringLength64 = transfer->labelStrlen;\n        if (stringLength64 >= std::numeric_limits<size_t>::max()) {\n            return WireResult::FatalError;\n        }\n        size_t stringLength = static_cast<size_t>(stringLength64);\n\n        const volatile char* stringInBuffer;\n        WIRE_TRY(deserializeBuffer->ReadN(stringLength, &stringInBuffer));\n\n        char* copiedString;\n        WIRE_TRY(GetSpace(allocator, stringLength + 1, &copiedString));\n        memcpy(copiedString, const_cast<const char*>(stringInBuffer), stringLength);\n        copiedString[stringLength] = '\\0';\n        record->label = copiedString;\n    }\n\n\n    return WireResult::Success;\n}\nDAWN_UNUSED_FUNC(WGPURenderBundleDescriptorDeserialize);\n\n                \nstruct WGPURenderBundleEncoderDescriptorTransfer {\n    static_assert(0 <= 1,\n                  \"Record must be at most one of is_cmd, extensible, and chained.\");\n    bool hasNextInChain;\n\n    \nuint32_t colorFormatsCount;\n    \nWGPUTextureFormat depthStencilFormat;\n    \nuint32_t sampleCount;\n    \nbool depthReadOnly;\n    \nbool stencilReadOnly;\n\n    uint64_t labelStrlen;\n\n    bool has_label;\n};\n\n\n\nDAWN_DECLARE_UNUSED size_t WGPURenderBundleEncoderDescriptorGetExtraRequiredSize(const WGPURenderBundleEncoderDescriptor& record) {\n    DAWN_UNUSED(record);\n\n    size_t result = 0;\n\n    if (record.nextInChain != nullptr) {\n        result += GetChainedStructExtraRequiredSize(record.nextInChain);\n    }\n\n\n    bool has_label = record.label != nullptr;\n    if (has_label)\n    {\n    result += std::strlen(record.label);\n    }\n\n    {\n    }\n    {\n        \n        auto memberLength = record.colorFormatsCount;\n        result += memberLength * sizeof(\nWGPUTextureFormat);\n    }\n    {\n    }\n    {\n    }\n    {\n    }\n    {\n    }\n\n    return result;\n}\n// GetExtraRequiredSize isn't used for structures that are value members of other structures\n// because we assume they cannot contain pointers themselves.\nDAWN_UNUSED_FUNC(WGPURenderBundleEncoderDescriptorGetExtraRequiredSize);\n\nDAWN_DECLARE_UNUSED WireResult WGPURenderBundleEncoderDescriptorSerialize(\n    const WGPURenderBundleEncoderDescriptor& record,\n    WGPURenderBundleEncoderDescriptorTransfer* transfer,\n    SerializeBuffer* buffer, const ObjectIdProvider& provider) {\n    DAWN_UNUSED(buffer);\n\n\n    transfer->colorFormatsCount = record.colorFormatsCount;\n    transfer->depthStencilFormat = record.depthStencilFormat;\n    transfer->sampleCount = record.sampleCount;\n    transfer->depthReadOnly = record.depthReadOnly;\n    transfer->stencilReadOnly = record.stencilReadOnly;\n\n    if (record.nextInChain != nullptr) {\n        transfer->hasNextInChain = true;\n        WIRE_TRY(SerializeChainedStruct(record.nextInChain, buffer, provider));\n    } else {\n        transfer->hasNextInChain = false;\n    }\n\n\n\n    bool has_label = record.label != nullptr;\n    transfer->has_label = has_label;\n    if (has_label)\n    {\n        transfer->labelStrlen = std::strlen(record.label);\n\n        char* stringInBuffer;\n        WIRE_TRY(buffer->NextN(transfer->labelStrlen, &stringInBuffer));\n        memcpy(stringInBuffer, record.label, transfer->labelStrlen);\n    }\n\n    \n\n    {\n        auto memberLength = record.colorFormatsCount;\n\n        \nWGPUTextureFormat* memberBuffer;\n        WIRE_TRY(buffer->NextN(memberLength, &memberBuffer));\n\n        memcpy(\n            memberBuffer, record.colorFormats,\n            sizeof(\nWGPUTextureFormat) * memberLength);\n    }\n    return WireResult::Success;\n}\nDAWN_UNUSED_FUNC(WGPURenderBundleEncoderDescriptorSerialize);\n\nDAWN_DECLARE_UNUSED WireResult WGPURenderBundleEncoderDescriptorDeserialize(\n    WGPURenderBundleEncoderDescriptor* record,\n    const volatile WGPURenderBundleEncoderDescriptorTransfer* transfer,\n    DeserializeBuffer* deserializeBuffer,\n    DeserializeAllocator* allocator, const ObjectIdResolver& resolver) {\n    DAWN_UNUSED(allocator);\n\n\n\n    static_assert(sizeof(record->colorFormatsCount) >= sizeof(transfer->colorFormatsCount), \"Deserialize assignment may not narrow.\");\nrecord->colorFormatsCount = transfer->colorFormatsCount;\n    static_assert(sizeof(record->depthStencilFormat) >= sizeof(transfer->depthStencilFormat), \"Deserialize assignment may not narrow.\");\nrecord->depthStencilFormat = transfer->depthStencilFormat;\n    static_assert(sizeof(record->sampleCount) >= sizeof(transfer->sampleCount), \"Deserialize assignment may not narrow.\");\nrecord->sampleCount = transfer->sampleCount;\n    static_assert(sizeof(record->depthReadOnly) >= sizeof(transfer->depthReadOnly), \"Deserialize assignment may not narrow.\");\nrecord->depthReadOnly = transfer->depthReadOnly;\n    static_assert(sizeof(record->stencilReadOnly) >= sizeof(transfer->stencilReadOnly), \"Deserialize assignment may not narrow.\");\nrecord->stencilReadOnly = transfer->stencilReadOnly;\n\n    record->nextInChain = nullptr;\n    if (transfer->hasNextInChain) {\n        WIRE_TRY(DeserializeChainedStruct(&record->nextInChain, deserializeBuffer, allocator, resolver));\n    }\n\n\n\n    bool has_label = transfer->has_label;\n    record->label = nullptr;\n    if (has_label)\n    {\n        uint64_t stringLength64 = transfer->labelStrlen;\n        if (stringLength64 >= std::numeric_limits<size_t>::max()) {\n            return WireResult::FatalError;\n        }\n        size_t stringLength = static_cast<size_t>(stringLength64);\n\n        const volatile char* stringInBuffer;\n        WIRE_TRY(deserializeBuffer->ReadN(stringLength, &stringInBuffer));\n\n        char* copiedString;\n        WIRE_TRY(GetSpace(allocator, stringLength + 1, &copiedString));\n        memcpy(copiedString, const_cast<const char*>(stringInBuffer), stringLength);\n        copiedString[stringLength] = '\\0';\n        record->label = copiedString;\n    }\n\n    \n\n    {\n        auto memberLength = record->colorFormatsCount;\n        const volatile \nWGPUTextureFormat* memberBuffer;\n        WIRE_TRY(deserializeBuffer->ReadN(memberLength, &memberBuffer));\n\n        WGPUTextureFormat* copiedMembers;\n        WIRE_TRY(GetSpace(allocator, memberLength, &copiedMembers));\n        record->colorFormats = copiedMembers;\n\n        memcpy(\n            copiedMembers,\n            const_cast<const \nWGPUTextureFormat*>(memberBuffer),\n           sizeof(\nWGPUTextureFormat) * memberLength);\n    }\n\n    return WireResult::Success;\n}\nDAWN_UNUSED_FUNC(WGPURenderBundleEncoderDescriptorDeserialize);\n\n                \nstruct WGPURenderPassDepthStencilAttachmentTransfer {\n    static_assert(0 <= 1,\n                  \"Record must be at most one of is_cmd, extensible, and chained.\");\n\n    ObjectId view;\n    \nWGPULoadOp depthLoadOp;\n    \nWGPUStoreOp depthStoreOp;\n    \nfloat clearDepth;\n    \nfloat depthClearValue;\n    \nbool depthReadOnly;\n    \nWGPULoadOp stencilLoadOp;\n    \nWGPUStoreOp stencilStoreOp;\n    \nuint32_t clearStencil;\n    \nuint32_t stencilClearValue;\n    \nbool stencilReadOnly;\n\n\n};\n\n\n\nDAWN_DECLARE_UNUSED size_t WGPURenderPassDepthStencilAttachmentGetExtraRequiredSize(const WGPURenderPassDepthStencilAttachment& record) {\n    DAWN_UNUSED(record);\n\n    size_t result = 0;\n\n\n\n    {\n    }\n    {\n    }\n    {\n    }\n    {\n    }\n    {\n    }\n    {\n    }\n    {\n    }\n    {\n    }\n    {\n    }\n    {\n    }\n    {\n    }\n\n    return result;\n}\n// GetExtraRequiredSize isn't used for structures that are value members of other structures\n// because we assume they cannot contain pointers themselves.\nDAWN_UNUSED_FUNC(WGPURenderPassDepthStencilAttachmentGetExtraRequiredSize);\n\nDAWN_DECLARE_UNUSED WireResult WGPURenderPassDepthStencilAttachmentSerialize(\n    const WGPURenderPassDepthStencilAttachment& record,\n    WGPURenderPassDepthStencilAttachmentTransfer* transfer,\n    SerializeBuffer* buffer, const ObjectIdProvider& provider) {\n    DAWN_UNUSED(buffer);\n\n\n    WIRE_TRY(provider.GetId(record.view, &transfer->view));\n    transfer->depthLoadOp = record.depthLoadOp;\n    transfer->depthStoreOp = record.depthStoreOp;\n    transfer->clearDepth = record.clearDepth;\n    transfer->depthClearValue = record.depthClearValue;\n    transfer->depthReadOnly = record.depthReadOnly;\n    transfer->stencilLoadOp = record.stencilLoadOp;\n    transfer->stencilStoreOp = record.stencilStoreOp;\n    transfer->clearStencil = record.clearStencil;\n    transfer->stencilClearValue = record.stencilClearValue;\n    transfer->stencilReadOnly = record.stencilReadOnly;\n\n\n\n\n    return WireResult::Success;\n}\nDAWN_UNUSED_FUNC(WGPURenderPassDepthStencilAttachmentSerialize);\n\nDAWN_DECLARE_UNUSED WireResult WGPURenderPassDepthStencilAttachmentDeserialize(\n    WGPURenderPassDepthStencilAttachment* record,\n    const volatile WGPURenderPassDepthStencilAttachmentTransfer* transfer,\n    DeserializeBuffer* deserializeBuffer,\n    DeserializeAllocator* allocator, const ObjectIdResolver& resolver) {\n    DAWN_UNUSED(allocator);\n\n\n\n    WIRE_TRY(resolver.GetFromId(transfer->view, &record->view));\n    static_assert(sizeof(record->depthLoadOp) >= sizeof(transfer->depthLoadOp), \"Deserialize assignment may not narrow.\");\nrecord->depthLoadOp = transfer->depthLoadOp;\n    static_assert(sizeof(record->depthStoreOp) >= sizeof(transfer->depthStoreOp), \"Deserialize assignment may not narrow.\");\nrecord->depthStoreOp = transfer->depthStoreOp;\n    static_assert(sizeof(record->clearDepth) >= sizeof(transfer->clearDepth), \"Deserialize assignment may not narrow.\");\nrecord->clearDepth = transfer->clearDepth;\n    static_assert(sizeof(record->depthClearValue) >= sizeof(transfer->depthClearValue), \"Deserialize assignment may not narrow.\");\nrecord->depthClearValue = transfer->depthClearValue;\n    static_assert(sizeof(record->depthReadOnly) >= sizeof(transfer->depthReadOnly), \"Deserialize assignment may not narrow.\");\nrecord->depthReadOnly = transfer->depthReadOnly;\n    static_assert(sizeof(record->stencilLoadOp) >= sizeof(transfer->stencilLoadOp), \"Deserialize assignment may not narrow.\");\nrecord->stencilLoadOp = transfer->stencilLoadOp;\n    static_assert(sizeof(record->stencilStoreOp) >= sizeof(transfer->stencilStoreOp), \"Deserialize assignment may not narrow.\");\nrecord->stencilStoreOp = transfer->stencilStoreOp;\n    static_assert(sizeof(record->clearStencil) >= sizeof(transfer->clearStencil), \"Deserialize assignment may not narrow.\");\nrecord->clearStencil = transfer->clearStencil;\n    static_assert(sizeof(record->stencilClearValue) >= sizeof(transfer->stencilClearValue), \"Deserialize assignment may not narrow.\");\nrecord->stencilClearValue = transfer->stencilClearValue;\n    static_assert(sizeof(record->stencilReadOnly) >= sizeof(transfer->stencilReadOnly), \"Deserialize assignment may not narrow.\");\nrecord->stencilReadOnly = transfer->stencilReadOnly;\n\n\n\n\n\n    return WireResult::Success;\n}\nDAWN_UNUSED_FUNC(WGPURenderPassDepthStencilAttachmentDeserialize);\n\n                \nstruct WGPURenderPassDescriptorMaxDrawCountTransfer {\n    static_assert(0 <= 1,\n                  \"Record must be at most one of is_cmd, extensible, and chained.\");\n    WGPUChainedStructTransfer chain;\n\n    \nuint64_t maxDrawCount;\n\n\n};\n\n\nstatic_assert(offsetof(WGPURenderPassDescriptorMaxDrawCountTransfer, chain) == 0);\n\nDAWN_DECLARE_UNUSED size_t WGPURenderPassDescriptorMaxDrawCountGetExtraRequiredSize(const WGPURenderPassDescriptorMaxDrawCount& record) {\n    DAWN_UNUSED(record);\n\n    size_t result = 0;\n\n\n\n    {\n    }\n\n    return result;\n}\n// GetExtraRequiredSize isn't used for structures that are value members of other structures\n// because we assume they cannot contain pointers themselves.\nDAWN_UNUSED_FUNC(WGPURenderPassDescriptorMaxDrawCountGetExtraRequiredSize);\n\nDAWN_DECLARE_UNUSED WireResult WGPURenderPassDescriptorMaxDrawCountSerialize(\n    const WGPURenderPassDescriptorMaxDrawCount& record,\n    WGPURenderPassDescriptorMaxDrawCountTransfer* transfer,\n    SerializeBuffer* buffer, const ObjectIdProvider& provider) {\n    DAWN_UNUSED(buffer);\n\n\n    transfer->maxDrawCount = record.maxDrawCount;\n\n\n    ASSERT(transfer->chain.sType == WGPUSType_RenderPassDescriptorMaxDrawCount);\n    ASSERT(transfer->chain.hasNext == (record.chain.next != nullptr));\n\n\n    return WireResult::Success;\n}\nDAWN_UNUSED_FUNC(WGPURenderPassDescriptorMaxDrawCountSerialize);\n\nDAWN_DECLARE_UNUSED WireResult WGPURenderPassDescriptorMaxDrawCountDeserialize(\n    WGPURenderPassDescriptorMaxDrawCount* record,\n    const volatile WGPURenderPassDescriptorMaxDrawCountTransfer* transfer,\n    DeserializeBuffer* deserializeBuffer,\n    DeserializeAllocator* allocator, const ObjectIdResolver& resolver) {\n    DAWN_UNUSED(allocator);\n\n\n\n    static_assert(sizeof(record->maxDrawCount) >= sizeof(transfer->maxDrawCount), \"Deserialize assignment may not narrow.\");\nrecord->maxDrawCount = transfer->maxDrawCount;\n\n\n    ASSERT(record->chain.sType == WGPUSType_RenderPassDescriptorMaxDrawCount);\n    ASSERT(record->chain.next == nullptr);\n\n\n\n    return WireResult::Success;\n}\nDAWN_UNUSED_FUNC(WGPURenderPassDescriptorMaxDrawCountDeserialize);\n\n                \nstruct WGPURenderPassTimestampWriteTransfer {\n    static_assert(0 <= 1,\n                  \"Record must be at most one of is_cmd, extensible, and chained.\");\n\n    ObjectId querySet;\n    \nuint32_t queryIndex;\n    \nWGPURenderPassTimestampLocation location;\n\n\n};\n\n\n\nDAWN_DECLARE_UNUSED size_t WGPURenderPassTimestampWriteGetExtraRequiredSize(const WGPURenderPassTimestampWrite& record) {\n    DAWN_UNUSED(record);\n\n    size_t result = 0;\n\n\n\n    {\n    }\n    {\n    }\n    {\n    }\n\n    return result;\n}\n// GetExtraRequiredSize isn't used for structures that are value members of other structures\n// because we assume they cannot contain pointers themselves.\nDAWN_UNUSED_FUNC(WGPURenderPassTimestampWriteGetExtraRequiredSize);\n\nDAWN_DECLARE_UNUSED WireResult WGPURenderPassTimestampWriteSerialize(\n    const WGPURenderPassTimestampWrite& record,\n    WGPURenderPassTimestampWriteTransfer* transfer,\n    SerializeBuffer* buffer, const ObjectIdProvider& provider) {\n    DAWN_UNUSED(buffer);\n\n\n    WIRE_TRY(provider.GetId(record.querySet, &transfer->querySet));\n    transfer->queryIndex = record.queryIndex;\n    transfer->location = record.location;\n\n\n\n\n    return WireResult::Success;\n}\nDAWN_UNUSED_FUNC(WGPURenderPassTimestampWriteSerialize);\n\nDAWN_DECLARE_UNUSED WireResult WGPURenderPassTimestampWriteDeserialize(\n    WGPURenderPassTimestampWrite* record,\n    const volatile WGPURenderPassTimestampWriteTransfer* transfer,\n    DeserializeBuffer* deserializeBuffer,\n    DeserializeAllocator* allocator, const ObjectIdResolver& resolver) {\n    DAWN_UNUSED(allocator);\n\n\n\n    WIRE_TRY(resolver.GetFromId(transfer->querySet, &record->querySet));\n    static_assert(sizeof(record->queryIndex) >= sizeof(transfer->queryIndex), \"Deserialize assignment may not narrow.\");\nrecord->queryIndex = transfer->queryIndex;\n    static_assert(sizeof(record->location) >= sizeof(transfer->location), \"Deserialize assignment may not narrow.\");\nrecord->location = transfer->location;\n\n\n\n\n\n    return WireResult::Success;\n}\nDAWN_UNUSED_FUNC(WGPURenderPassTimestampWriteDeserialize);\n\n                \nstruct WGPURequestAdapterOptionsTransfer {\n    static_assert(0 <= 1,\n                  \"Record must be at most one of is_cmd, extensible, and chained.\");\n    bool hasNextInChain;\n\n    ObjectId compatibleSurface;\n    \nWGPUPowerPreference powerPreference;\n    \nbool forceFallbackAdapter;\n\n\n};\n\n\n\nDAWN_DECLARE_UNUSED size_t WGPURequestAdapterOptionsGetExtraRequiredSize(const WGPURequestAdapterOptions& record) {\n    DAWN_UNUSED(record);\n\n    size_t result = 0;\n\n    if (record.nextInChain != nullptr) {\n        result += GetChainedStructExtraRequiredSize(record.nextInChain);\n    }\n\n\n    {\n    }\n    {\n    }\n    {\n    }\n\n    return result;\n}\n// GetExtraRequiredSize isn't used for structures that are value members of other structures\n// because we assume they cannot contain pointers themselves.\nDAWN_UNUSED_FUNC(WGPURequestAdapterOptionsGetExtraRequiredSize);\n\nDAWN_DECLARE_UNUSED WireResult WGPURequestAdapterOptionsSerialize(\n    const WGPURequestAdapterOptions& record,\n    WGPURequestAdapterOptionsTransfer* transfer,\n    SerializeBuffer* buffer, const ObjectIdProvider& provider) {\n    DAWN_UNUSED(buffer);\n\n\n    WIRE_TRY(provider.GetOptionalId(record.compatibleSurface, &transfer->compatibleSurface));\n    transfer->powerPreference = record.powerPreference;\n    transfer->forceFallbackAdapter = record.forceFallbackAdapter;\n\n    if (record.nextInChain != nullptr) {\n        transfer->hasNextInChain = true;\n        WIRE_TRY(SerializeChainedStruct(record.nextInChain, buffer, provider));\n    } else {\n        transfer->hasNextInChain = false;\n    }\n\n\n\n    return WireResult::Success;\n}\nDAWN_UNUSED_FUNC(WGPURequestAdapterOptionsSerialize);\n\nDAWN_DECLARE_UNUSED WireResult WGPURequestAdapterOptionsDeserialize(\n    WGPURequestAdapterOptions* record,\n    const volatile WGPURequestAdapterOptionsTransfer* transfer,\n    DeserializeBuffer* deserializeBuffer,\n    DeserializeAllocator* allocator, const ObjectIdResolver& resolver) {\n    DAWN_UNUSED(allocator);\n\n\n\n    WIRE_TRY(resolver.GetOptionalFromId(transfer->compatibleSurface, &record->compatibleSurface));\n    static_assert(sizeof(record->powerPreference) >= sizeof(transfer->powerPreference), \"Deserialize assignment may not narrow.\");\nrecord->powerPreference = transfer->powerPreference;\n    static_assert(sizeof(record->forceFallbackAdapter) >= sizeof(transfer->forceFallbackAdapter), \"Deserialize assignment may not narrow.\");\nrecord->forceFallbackAdapter = transfer->forceFallbackAdapter;\n\n    record->nextInChain = nullptr;\n    if (transfer->hasNextInChain) {\n        WIRE_TRY(DeserializeChainedStruct(&record->nextInChain, deserializeBuffer, allocator, resolver));\n    }\n\n\n\n\n    return WireResult::Success;\n}\nDAWN_UNUSED_FUNC(WGPURequestAdapterOptionsDeserialize);\n\n                \nstruct WGPUSamplerBindingLayoutTransfer {\n    static_assert(0 <= 1,\n                  \"Record must be at most one of is_cmd, extensible, and chained.\");\n    bool hasNextInChain;\n\n    \nWGPUSamplerBindingType type;\n\n\n};\n\n\n\nDAWN_DECLARE_UNUSED size_t WGPUSamplerBindingLayoutGetExtraRequiredSize(const WGPUSamplerBindingLayout& record) {\n    DAWN_UNUSED(record);\n\n    size_t result = 0;\n\n    if (record.nextInChain != nullptr) {\n        result += GetChainedStructExtraRequiredSize(record.nextInChain);\n    }\n\n\n    {\n    }\n\n    return result;\n}\n// GetExtraRequiredSize isn't used for structures that are value members of other structures\n// because we assume they cannot contain pointers themselves.\nDAWN_UNUSED_FUNC(WGPUSamplerBindingLayoutGetExtraRequiredSize);\n\nDAWN_DECLARE_UNUSED WireResult WGPUSamplerBindingLayoutSerialize(\n    const WGPUSamplerBindingLayout& record,\n    WGPUSamplerBindingLayoutTransfer* transfer,\n    SerializeBuffer* buffer, const ObjectIdProvider& provider) {\n    DAWN_UNUSED(buffer);\n\n\n    transfer->type = record.type;\n\n    if (record.nextInChain != nullptr) {\n        transfer->hasNextInChain = true;\n        WIRE_TRY(SerializeChainedStruct(record.nextInChain, buffer, provider));\n    } else {\n        transfer->hasNextInChain = false;\n    }\n\n\n\n    return WireResult::Success;\n}\nDAWN_UNUSED_FUNC(WGPUSamplerBindingLayoutSerialize);\n\nDAWN_DECLARE_UNUSED WireResult WGPUSamplerBindingLayoutDeserialize(\n    WGPUSamplerBindingLayout* record,\n    const volatile WGPUSamplerBindingLayoutTransfer* transfer,\n    DeserializeBuffer* deserializeBuffer,\n    DeserializeAllocator* allocator, const ObjectIdResolver& resolver) {\n    DAWN_UNUSED(allocator);\n\n\n\n    static_assert(sizeof(record->type) >= sizeof(transfer->type), \"Deserialize assignment may not narrow.\");\nrecord->type = transfer->type;\n\n    record->nextInChain = nullptr;\n    if (transfer->hasNextInChain) {\n        WIRE_TRY(DeserializeChainedStruct(&record->nextInChain, deserializeBuffer, allocator, resolver));\n    }\n\n\n\n\n    return WireResult::Success;\n}\nDAWN_UNUSED_FUNC(WGPUSamplerBindingLayoutDeserialize);\n\n                \nstruct WGPUSamplerDescriptorTransfer {\n    static_assert(0 <= 1,\n                  \"Record must be at most one of is_cmd, extensible, and chained.\");\n    bool hasNextInChain;\n\n    \nWGPUAddressMode addressModeU;\n    \nWGPUAddressMode addressModeV;\n    \nWGPUAddressMode addressModeW;\n    \nWGPUFilterMode magFilter;\n    \nWGPUFilterMode minFilter;\n    \nWGPUFilterMode mipmapFilter;\n    \nfloat lodMinClamp;\n    \nfloat lodMaxClamp;\n    \nWGPUCompareFunction compare;\n    \nuint16_t maxAnisotropy;\n\n    uint64_t labelStrlen;\n\n    bool has_label;\n};\n\n\n\nDAWN_DECLARE_UNUSED size_t WGPUSamplerDescriptorGetExtraRequiredSize(const WGPUSamplerDescriptor& record) {\n    DAWN_UNUSED(record);\n\n    size_t result = 0;\n\n    if (record.nextInChain != nullptr) {\n        result += GetChainedStructExtraRequiredSize(record.nextInChain);\n    }\n\n\n    bool has_label = record.label != nullptr;\n    if (has_label)\n    {\n    result += std::strlen(record.label);\n    }\n\n    {\n    }\n    {\n    }\n    {\n    }\n    {\n    }\n    {\n    }\n    {\n    }\n    {\n    }\n    {\n    }\n    {\n    }\n    {\n    }\n\n    return result;\n}\n// GetExtraRequiredSize isn't used for structures that are value members of other structures\n// because we assume they cannot contain pointers themselves.\nDAWN_UNUSED_FUNC(WGPUSamplerDescriptorGetExtraRequiredSize);\n\nDAWN_DECLARE_UNUSED WireResult WGPUSamplerDescriptorSerialize(\n    const WGPUSamplerDescriptor& record,\n    WGPUSamplerDescriptorTransfer* transfer,\n    SerializeBuffer* buffer, const ObjectIdProvider& provider) {\n    DAWN_UNUSED(buffer);\n\n\n    transfer->addressModeU = record.addressModeU;\n    transfer->addressModeV = record.addressModeV;\n    transfer->addressModeW = record.addressModeW;\n    transfer->magFilter = record.magFilter;\n    transfer->minFilter = record.minFilter;\n    transfer->mipmapFilter = record.mipmapFilter;\n    transfer->lodMinClamp = record.lodMinClamp;\n    transfer->lodMaxClamp = record.lodMaxClamp;\n    transfer->compare = record.compare;\n    transfer->maxAnisotropy = record.maxAnisotropy;\n\n    if (record.nextInChain != nullptr) {\n        transfer->hasNextInChain = true;\n        WIRE_TRY(SerializeChainedStruct(record.nextInChain, buffer, provider));\n    } else {\n        transfer->hasNextInChain = false;\n    }\n\n\n\n    bool has_label = record.label != nullptr;\n    transfer->has_label = has_label;\n    if (has_label)\n    {\n        transfer->labelStrlen = std::strlen(record.label);\n\n        char* stringInBuffer;\n        WIRE_TRY(buffer->NextN(transfer->labelStrlen, &stringInBuffer));\n        memcpy(stringInBuffer, record.label, transfer->labelStrlen);\n    }\n\n    return WireResult::Success;\n}\nDAWN_UNUSED_FUNC(WGPUSamplerDescriptorSerialize);\n\nDAWN_DECLARE_UNUSED WireResult WGPUSamplerDescriptorDeserialize(\n    WGPUSamplerDescriptor* record,\n    const volatile WGPUSamplerDescriptorTransfer* transfer,\n    DeserializeBuffer* deserializeBuffer,\n    DeserializeAllocator* allocator, const ObjectIdResolver& resolver) {\n    DAWN_UNUSED(allocator);\n\n\n\n    static_assert(sizeof(record->addressModeU) >= sizeof(transfer->addressModeU), \"Deserialize assignment may not narrow.\");\nrecord->addressModeU = transfer->addressModeU;\n    static_assert(sizeof(record->addressModeV) >= sizeof(transfer->addressModeV), \"Deserialize assignment may not narrow.\");\nrecord->addressModeV = transfer->addressModeV;\n    static_assert(sizeof(record->addressModeW) >= sizeof(transfer->addressModeW), \"Deserialize assignment may not narrow.\");\nrecord->addressModeW = transfer->addressModeW;\n    static_assert(sizeof(record->magFilter) >= sizeof(transfer->magFilter), \"Deserialize assignment may not narrow.\");\nrecord->magFilter = transfer->magFilter;\n    static_assert(sizeof(record->minFilter) >= sizeof(transfer->minFilter), \"Deserialize assignment may not narrow.\");\nrecord->minFilter = transfer->minFilter;\n    static_assert(sizeof(record->mipmapFilter) >= sizeof(transfer->mipmapFilter), \"Deserialize assignment may not narrow.\");\nrecord->mipmapFilter = transfer->mipmapFilter;\n    static_assert(sizeof(record->lodMinClamp) >= sizeof(transfer->lodMinClamp), \"Deserialize assignment may not narrow.\");\nrecord->lodMinClamp = transfer->lodMinClamp;\n    static_assert(sizeof(record->lodMaxClamp) >= sizeof(transfer->lodMaxClamp), \"Deserialize assignment may not narrow.\");\nrecord->lodMaxClamp = transfer->lodMaxClamp;\n    static_assert(sizeof(record->compare) >= sizeof(transfer->compare), \"Deserialize assignment may not narrow.\");\nrecord->compare = transfer->compare;\n    static_assert(sizeof(record->maxAnisotropy) >= sizeof(transfer->maxAnisotropy), \"Deserialize assignment may not narrow.\");\nrecord->maxAnisotropy = transfer->maxAnisotropy;\n\n    record->nextInChain = nullptr;\n    if (transfer->hasNextInChain) {\n        WIRE_TRY(DeserializeChainedStruct(&record->nextInChain, deserializeBuffer, allocator, resolver));\n    }\n\n\n\n    bool has_label = transfer->has_label;\n    record->label = nullptr;\n    if (has_label)\n    {\n        uint64_t stringLength64 = transfer->labelStrlen;\n        if (stringLength64 >= std::numeric_limits<size_t>::max()) {\n            return WireResult::FatalError;\n        }\n        size_t stringLength = static_cast<size_t>(stringLength64);\n\n        const volatile char* stringInBuffer;\n        WIRE_TRY(deserializeBuffer->ReadN(stringLength, &stringInBuffer));\n\n        char* copiedString;\n        WIRE_TRY(GetSpace(allocator, stringLength + 1, &copiedString));\n        memcpy(copiedString, const_cast<const char*>(stringInBuffer), stringLength);\n        copiedString[stringLength] = '\\0';\n        record->label = copiedString;\n    }\n\n\n    return WireResult::Success;\n}\nDAWN_UNUSED_FUNC(WGPUSamplerDescriptorDeserialize);\n\n                \nstruct WGPUShaderModuleDescriptorTransfer {\n    static_assert(0 <= 1,\n                  \"Record must be at most one of is_cmd, extensible, and chained.\");\n    bool hasNextInChain;\n\n\n    uint64_t labelStrlen;\n\n    bool has_label;\n};\n\n\n\nDAWN_DECLARE_UNUSED size_t WGPUShaderModuleDescriptorGetExtraRequiredSize(const WGPUShaderModuleDescriptor& record) {\n    DAWN_UNUSED(record);\n\n    size_t result = 0;\n\n    if (record.nextInChain != nullptr) {\n        result += GetChainedStructExtraRequiredSize(record.nextInChain);\n    }\n\n\n    bool has_label = record.label != nullptr;\n    if (has_label)\n    {\n    result += std::strlen(record.label);\n    }\n\n\n    return result;\n}\n// GetExtraRequiredSize isn't used for structures that are value members of other structures\n// because we assume they cannot contain pointers themselves.\nDAWN_UNUSED_FUNC(WGPUShaderModuleDescriptorGetExtraRequiredSize);\n\nDAWN_DECLARE_UNUSED WireResult WGPUShaderModuleDescriptorSerialize(\n    const WGPUShaderModuleDescriptor& record,\n    WGPUShaderModuleDescriptorTransfer* transfer,\n    SerializeBuffer* buffer, const ObjectIdProvider& provider) {\n    DAWN_UNUSED(buffer);\n\n\n\n    if (record.nextInChain != nullptr) {\n        transfer->hasNextInChain = true;\n        WIRE_TRY(SerializeChainedStruct(record.nextInChain, buffer, provider));\n    } else {\n        transfer->hasNextInChain = false;\n    }\n\n\n\n    bool has_label = record.label != nullptr;\n    transfer->has_label = has_label;\n    if (has_label)\n    {\n        transfer->labelStrlen = std::strlen(record.label);\n\n        char* stringInBuffer;\n        WIRE_TRY(buffer->NextN(transfer->labelStrlen, &stringInBuffer));\n        memcpy(stringInBuffer, record.label, transfer->labelStrlen);\n    }\n\n    return WireResult::Success;\n}\nDAWN_UNUSED_FUNC(WGPUShaderModuleDescriptorSerialize);\n\nDAWN_DECLARE_UNUSED WireResult WGPUShaderModuleDescriptorDeserialize(\n    WGPUShaderModuleDescriptor* record,\n    const volatile WGPUShaderModuleDescriptorTransfer* transfer,\n    DeserializeBuffer* deserializeBuffer,\n    DeserializeAllocator* allocator, const ObjectIdResolver& resolver) {\n    DAWN_UNUSED(allocator);\n\n\n\n\n    record->nextInChain = nullptr;\n    if (transfer->hasNextInChain) {\n        WIRE_TRY(DeserializeChainedStruct(&record->nextInChain, deserializeBuffer, allocator, resolver));\n    }\n\n\n\n    bool has_label = transfer->has_label;\n    record->label = nullptr;\n    if (has_label)\n    {\n        uint64_t stringLength64 = transfer->labelStrlen;\n        if (stringLength64 >= std::numeric_limits<size_t>::max()) {\n            return WireResult::FatalError;\n        }\n        size_t stringLength = static_cast<size_t>(stringLength64);\n\n        const volatile char* stringInBuffer;\n        WIRE_TRY(deserializeBuffer->ReadN(stringLength, &stringInBuffer));\n\n        char* copiedString;\n        WIRE_TRY(GetSpace(allocator, stringLength + 1, &copiedString));\n        memcpy(copiedString, const_cast<const char*>(stringInBuffer), stringLength);\n        copiedString[stringLength] = '\\0';\n        record->label = copiedString;\n    }\n\n\n    return WireResult::Success;\n}\nDAWN_UNUSED_FUNC(WGPUShaderModuleDescriptorDeserialize);\n\n                \nstruct WGPUShaderModuleSPIRVDescriptorTransfer {\n    static_assert(0 <= 1,\n                  \"Record must be at most one of is_cmd, extensible, and chained.\");\n    WGPUChainedStructTransfer chain;\n\n    \nuint32_t codeSize;\n\n\n};\n\n\nstatic_assert(offsetof(WGPUShaderModuleSPIRVDescriptorTransfer, chain) == 0);\n\nDAWN_DECLARE_UNUSED size_t WGPUShaderModuleSPIRVDescriptorGetExtraRequiredSize(const WGPUShaderModuleSPIRVDescriptor& record) {\n    DAWN_UNUSED(record);\n\n    size_t result = 0;\n\n\n\n    {\n    }\n    {\n        \n        auto memberLength = record.codeSize;\n        result += memberLength * sizeof(\nuint32_t);\n    }\n\n    return result;\n}\n// GetExtraRequiredSize isn't used for structures that are value members of other structures\n// because we assume they cannot contain pointers themselves.\nDAWN_UNUSED_FUNC(WGPUShaderModuleSPIRVDescriptorGetExtraRequiredSize);\n\nDAWN_DECLARE_UNUSED WireResult WGPUShaderModuleSPIRVDescriptorSerialize(\n    const WGPUShaderModuleSPIRVDescriptor& record,\n    WGPUShaderModuleSPIRVDescriptorTransfer* transfer,\n    SerializeBuffer* buffer, const ObjectIdProvider& provider) {\n    DAWN_UNUSED(buffer);\n\n\n    transfer->codeSize = record.codeSize;\n\n\n    ASSERT(transfer->chain.sType == WGPUSType_ShaderModuleSPIRVDescriptor);\n    ASSERT(transfer->chain.hasNext == (record.chain.next != nullptr));\n\n\n    \n\n    {\n        auto memberLength = record.codeSize;\n\n        \nuint32_t* memberBuffer;\n        WIRE_TRY(buffer->NextN(memberLength, &memberBuffer));\n\n        memcpy(\n            memberBuffer, record.code,\n            sizeof(\nuint32_t) * memberLength);\n    }\n    return WireResult::Success;\n}\nDAWN_UNUSED_FUNC(WGPUShaderModuleSPIRVDescriptorSerialize);\n\nDAWN_DECLARE_UNUSED WireResult WGPUShaderModuleSPIRVDescriptorDeserialize(\n    WGPUShaderModuleSPIRVDescriptor* record,\n    const volatile WGPUShaderModuleSPIRVDescriptorTransfer* transfer,\n    DeserializeBuffer* deserializeBuffer,\n    DeserializeAllocator* allocator, const ObjectIdResolver& resolver) {\n    DAWN_UNUSED(allocator);\n\n\n\n    static_assert(sizeof(record->codeSize) >= sizeof(transfer->codeSize), \"Deserialize assignment may not narrow.\");\nrecord->codeSize = transfer->codeSize;\n\n\n    ASSERT(record->chain.sType == WGPUSType_ShaderModuleSPIRVDescriptor);\n    ASSERT(record->chain.next == nullptr);\n\n\n    \n\n    {\n        auto memberLength = record->codeSize;\n        const volatile \nuint32_t* memberBuffer;\n        WIRE_TRY(deserializeBuffer->ReadN(memberLength, &memberBuffer));\n\n        uint32_t* copiedMembers;\n        WIRE_TRY(GetSpace(allocator, memberLength, &copiedMembers));\n        record->code = copiedMembers;\n\n        memcpy(\n            copiedMembers,\n            const_cast<const \nuint32_t*>(memberBuffer),\n           sizeof(\nuint32_t) * memberLength);\n    }\n\n    return WireResult::Success;\n}\nDAWN_UNUSED_FUNC(WGPUShaderModuleSPIRVDescriptorDeserialize);\n\n                \nstruct WGPUShaderModuleWGSLDescriptorTransfer {\n    static_assert(0 <= 1,\n                  \"Record must be at most one of is_cmd, extensible, and chained.\");\n    WGPUChainedStructTransfer chain;\n\n\n    uint64_t sourceStrlen;\n\n};\n\n\nstatic_assert(offsetof(WGPUShaderModuleWGSLDescriptorTransfer, chain) == 0);\n\nDAWN_DECLARE_UNUSED size_t WGPUShaderModuleWGSLDescriptorGetExtraRequiredSize(const WGPUShaderModuleWGSLDescriptor& record) {\n    DAWN_UNUSED(record);\n\n    size_t result = 0;\n\n\n\n    {\n    result += std::strlen(record.source);\n    }\n\n\n    return result;\n}\n// GetExtraRequiredSize isn't used for structures that are value members of other structures\n// because we assume they cannot contain pointers themselves.\nDAWN_UNUSED_FUNC(WGPUShaderModuleWGSLDescriptorGetExtraRequiredSize);\n\nDAWN_DECLARE_UNUSED WireResult WGPUShaderModuleWGSLDescriptorSerialize(\n    const WGPUShaderModuleWGSLDescriptor& record,\n    WGPUShaderModuleWGSLDescriptorTransfer* transfer,\n    SerializeBuffer* buffer, const ObjectIdProvider& provider) {\n    DAWN_UNUSED(buffer);\n\n\n\n\n    ASSERT(transfer->chain.sType == WGPUSType_ShaderModuleWGSLDescriptor);\n    ASSERT(transfer->chain.hasNext == (record.chain.next != nullptr));\n\n\n    {\n        transfer->sourceStrlen = std::strlen(record.source);\n\n        char* stringInBuffer;\n        WIRE_TRY(buffer->NextN(transfer->sourceStrlen, &stringInBuffer));\n        memcpy(stringInBuffer, record.source, transfer->sourceStrlen);\n    }\n\n    return WireResult::Success;\n}\nDAWN_UNUSED_FUNC(WGPUShaderModuleWGSLDescriptorSerialize);\n\nDAWN_DECLARE_UNUSED WireResult WGPUShaderModuleWGSLDescriptorDeserialize(\n    WGPUShaderModuleWGSLDescriptor* record,\n    const volatile WGPUShaderModuleWGSLDescriptorTransfer* transfer,\n    DeserializeBuffer* deserializeBuffer,\n    DeserializeAllocator* allocator, const ObjectIdResolver& resolver) {\n    DAWN_UNUSED(allocator);\n\n\n\n\n\n    ASSERT(record->chain.sType == WGPUSType_ShaderModuleWGSLDescriptor);\n    ASSERT(record->chain.next == nullptr);\n\n\n    {\n        uint64_t stringLength64 = transfer->sourceStrlen;\n        if (stringLength64 >= std::numeric_limits<size_t>::max()) {\n            return WireResult::FatalError;\n        }\n        size_t stringLength = static_cast<size_t>(stringLength64);\n\n        const volatile char* stringInBuffer;\n        WIRE_TRY(deserializeBuffer->ReadN(stringLength, &stringInBuffer));\n\n        char* copiedString;\n        WIRE_TRY(GetSpace(allocator, stringLength + 1, &copiedString));\n        memcpy(copiedString, const_cast<const char*>(stringInBuffer), stringLength);\n        copiedString[stringLength] = '\\0';\n        record->source = copiedString;\n    }\n\n\n    return WireResult::Success;\n}\nDAWN_UNUSED_FUNC(WGPUShaderModuleWGSLDescriptorDeserialize);\n\n                \nstruct WGPUStencilFaceStateTransfer {\n    static_assert(0 <= 1,\n                  \"Record must be at most one of is_cmd, extensible, and chained.\");\n\n    \nWGPUCompareFunction compare;\n    \nWGPUStencilOperation failOp;\n    \nWGPUStencilOperation depthFailOp;\n    \nWGPUStencilOperation passOp;\n\n\n};\n\n\n\nDAWN_DECLARE_UNUSED size_t WGPUStencilFaceStateGetExtraRequiredSize(const WGPUStencilFaceState& record) {\n    DAWN_UNUSED(record);\n\n    size_t result = 0;\n\n\n\n    {\n    }\n    {\n    }\n    {\n    }\n    {\n    }\n\n    return result;\n}\n// GetExtraRequiredSize isn't used for structures that are value members of other structures\n// because we assume they cannot contain pointers themselves.\nDAWN_UNUSED_FUNC(WGPUStencilFaceStateGetExtraRequiredSize);\n\nDAWN_DECLARE_UNUSED WireResult WGPUStencilFaceStateSerialize(\n    const WGPUStencilFaceState& record,\n    WGPUStencilFaceStateTransfer* transfer,\n    SerializeBuffer* buffer) {\n    DAWN_UNUSED(buffer);\n\n\n    transfer->compare = record.compare;\n    transfer->failOp = record.failOp;\n    transfer->depthFailOp = record.depthFailOp;\n    transfer->passOp = record.passOp;\n\n\n\n\n    return WireResult::Success;\n}\nDAWN_UNUSED_FUNC(WGPUStencilFaceStateSerialize);\n\nDAWN_DECLARE_UNUSED WireResult WGPUStencilFaceStateDeserialize(\n    WGPUStencilFaceState* record,\n    const volatile WGPUStencilFaceStateTransfer* transfer,\n    DeserializeBuffer* deserializeBuffer,\n    DeserializeAllocator* allocator) {\n    DAWN_UNUSED(allocator);\n\n\n\n    static_assert(sizeof(record->compare) >= sizeof(transfer->compare), \"Deserialize assignment may not narrow.\");\nrecord->compare = transfer->compare;\n    static_assert(sizeof(record->failOp) >= sizeof(transfer->failOp), \"Deserialize assignment may not narrow.\");\nrecord->failOp = transfer->failOp;\n    static_assert(sizeof(record->depthFailOp) >= sizeof(transfer->depthFailOp), \"Deserialize assignment may not narrow.\");\nrecord->depthFailOp = transfer->depthFailOp;\n    static_assert(sizeof(record->passOp) >= sizeof(transfer->passOp), \"Deserialize assignment may not narrow.\");\nrecord->passOp = transfer->passOp;\n\n\n\n\n\n    return WireResult::Success;\n}\nDAWN_UNUSED_FUNC(WGPUStencilFaceStateDeserialize);\n\n                \nstruct WGPUStorageTextureBindingLayoutTransfer {\n    static_assert(0 <= 1,\n                  \"Record must be at most one of is_cmd, extensible, and chained.\");\n    bool hasNextInChain;\n\n    \nWGPUStorageTextureAccess access;\n    \nWGPUTextureFormat format;\n    \nWGPUTextureViewDimension viewDimension;\n\n\n};\n\n\n\nDAWN_DECLARE_UNUSED size_t WGPUStorageTextureBindingLayoutGetExtraRequiredSize(const WGPUStorageTextureBindingLayout& record) {\n    DAWN_UNUSED(record);\n\n    size_t result = 0;\n\n    if (record.nextInChain != nullptr) {\n        result += GetChainedStructExtraRequiredSize(record.nextInChain);\n    }\n\n\n    {\n    }\n    {\n    }\n    {\n    }\n\n    return result;\n}\n// GetExtraRequiredSize isn't used for structures that are value members of other structures\n// because we assume they cannot contain pointers themselves.\nDAWN_UNUSED_FUNC(WGPUStorageTextureBindingLayoutGetExtraRequiredSize);\n\nDAWN_DECLARE_UNUSED WireResult WGPUStorageTextureBindingLayoutSerialize(\n    const WGPUStorageTextureBindingLayout& record,\n    WGPUStorageTextureBindingLayoutTransfer* transfer,\n    SerializeBuffer* buffer, const ObjectIdProvider& provider) {\n    DAWN_UNUSED(buffer);\n\n\n    transfer->access = record.access;\n    transfer->format = record.format;\n    transfer->viewDimension = record.viewDimension;\n\n    if (record.nextInChain != nullptr) {\n        transfer->hasNextInChain = true;\n        WIRE_TRY(SerializeChainedStruct(record.nextInChain, buffer, provider));\n    } else {\n        transfer->hasNextInChain = false;\n    }\n\n\n\n    return WireResult::Success;\n}\nDAWN_UNUSED_FUNC(WGPUStorageTextureBindingLayoutSerialize);\n\nDAWN_DECLARE_UNUSED WireResult WGPUStorageTextureBindingLayoutDeserialize(\n    WGPUStorageTextureBindingLayout* record,\n    const volatile WGPUStorageTextureBindingLayoutTransfer* transfer,\n    DeserializeBuffer* deserializeBuffer,\n    DeserializeAllocator* allocator, const ObjectIdResolver& resolver) {\n    DAWN_UNUSED(allocator);\n\n\n\n    static_assert(sizeof(record->access) >= sizeof(transfer->access), \"Deserialize assignment may not narrow.\");\nrecord->access = transfer->access;\n    static_assert(sizeof(record->format) >= sizeof(transfer->format), \"Deserialize assignment may not narrow.\");\nrecord->format = transfer->format;\n    static_assert(sizeof(record->viewDimension) >= sizeof(transfer->viewDimension), \"Deserialize assignment may not narrow.\");\nrecord->viewDimension = transfer->viewDimension;\n\n    record->nextInChain = nullptr;\n    if (transfer->hasNextInChain) {\n        WIRE_TRY(DeserializeChainedStruct(&record->nextInChain, deserializeBuffer, allocator, resolver));\n    }\n\n\n\n\n    return WireResult::Success;\n}\nDAWN_UNUSED_FUNC(WGPUStorageTextureBindingLayoutDeserialize);\n\n                \nstruct WGPUSurfaceDescriptorTransfer {\n    static_assert(0 <= 1,\n                  \"Record must be at most one of is_cmd, extensible, and chained.\");\n    bool hasNextInChain;\n\n\n    uint64_t labelStrlen;\n\n    bool has_label;\n};\n\n\n\nDAWN_DECLARE_UNUSED size_t WGPUSurfaceDescriptorGetExtraRequiredSize(const WGPUSurfaceDescriptor& record) {\n    DAWN_UNUSED(record);\n\n    size_t result = 0;\n\n    if (record.nextInChain != nullptr) {\n        result += GetChainedStructExtraRequiredSize(record.nextInChain);\n    }\n\n\n    bool has_label = record.label != nullptr;\n    if (has_label)\n    {\n    result += std::strlen(record.label);\n    }\n\n\n    return result;\n}\n// GetExtraRequiredSize isn't used for structures that are value members of other structures\n// because we assume they cannot contain pointers themselves.\nDAWN_UNUSED_FUNC(WGPUSurfaceDescriptorGetExtraRequiredSize);\n\nDAWN_DECLARE_UNUSED WireResult WGPUSurfaceDescriptorSerialize(\n    const WGPUSurfaceDescriptor& record,\n    WGPUSurfaceDescriptorTransfer* transfer,\n    SerializeBuffer* buffer, const ObjectIdProvider& provider) {\n    DAWN_UNUSED(buffer);\n\n\n\n    if (record.nextInChain != nullptr) {\n        transfer->hasNextInChain = true;\n        WIRE_TRY(SerializeChainedStruct(record.nextInChain, buffer, provider));\n    } else {\n        transfer->hasNextInChain = false;\n    }\n\n\n\n    bool has_label = record.label != nullptr;\n    transfer->has_label = has_label;\n    if (has_label)\n    {\n        transfer->labelStrlen = std::strlen(record.label);\n\n        char* stringInBuffer;\n        WIRE_TRY(buffer->NextN(transfer->labelStrlen, &stringInBuffer));\n        memcpy(stringInBuffer, record.label, transfer->labelStrlen);\n    }\n\n    return WireResult::Success;\n}\nDAWN_UNUSED_FUNC(WGPUSurfaceDescriptorSerialize);\n\nDAWN_DECLARE_UNUSED WireResult WGPUSurfaceDescriptorDeserialize(\n    WGPUSurfaceDescriptor* record,\n    const volatile WGPUSurfaceDescriptorTransfer* transfer,\n    DeserializeBuffer* deserializeBuffer,\n    DeserializeAllocator* allocator, const ObjectIdResolver& resolver) {\n    DAWN_UNUSED(allocator);\n\n\n\n\n    record->nextInChain = nullptr;\n    if (transfer->hasNextInChain) {\n        WIRE_TRY(DeserializeChainedStruct(&record->nextInChain, deserializeBuffer, allocator, resolver));\n    }\n\n\n\n    bool has_label = transfer->has_label;\n    record->label = nullptr;\n    if (has_label)\n    {\n        uint64_t stringLength64 = transfer->labelStrlen;\n        if (stringLength64 >= std::numeric_limits<size_t>::max()) {\n            return WireResult::FatalError;\n        }\n        size_t stringLength = static_cast<size_t>(stringLength64);\n\n        const volatile char* stringInBuffer;\n        WIRE_TRY(deserializeBuffer->ReadN(stringLength, &stringInBuffer));\n\n        char* copiedString;\n        WIRE_TRY(GetSpace(allocator, stringLength + 1, &copiedString));\n        memcpy(copiedString, const_cast<const char*>(stringInBuffer), stringLength);\n        copiedString[stringLength] = '\\0';\n        record->label = copiedString;\n    }\n\n\n    return WireResult::Success;\n}\nDAWN_UNUSED_FUNC(WGPUSurfaceDescriptorDeserialize);\n\n                \nstruct WGPUSurfaceDescriptorFromCanvasHTMLSelectorTransfer {\n    static_assert(0 <= 1,\n                  \"Record must be at most one of is_cmd, extensible, and chained.\");\n    WGPUChainedStructTransfer chain;\n\n\n    uint64_t selectorStrlen;\n\n};\n\n\nstatic_assert(offsetof(WGPUSurfaceDescriptorFromCanvasHTMLSelectorTransfer, chain) == 0);\n\nDAWN_DECLARE_UNUSED size_t WGPUSurfaceDescriptorFromCanvasHTMLSelectorGetExtraRequiredSize(const WGPUSurfaceDescriptorFromCanvasHTMLSelector& record) {\n    DAWN_UNUSED(record);\n\n    size_t result = 0;\n\n\n\n    {\n    result += std::strlen(record.selector);\n    }\n\n\n    return result;\n}\n// GetExtraRequiredSize isn't used for structures that are value members of other structures\n// because we assume they cannot contain pointers themselves.\nDAWN_UNUSED_FUNC(WGPUSurfaceDescriptorFromCanvasHTMLSelectorGetExtraRequiredSize);\n\nDAWN_DECLARE_UNUSED WireResult WGPUSurfaceDescriptorFromCanvasHTMLSelectorSerialize(\n    const WGPUSurfaceDescriptorFromCanvasHTMLSelector& record,\n    WGPUSurfaceDescriptorFromCanvasHTMLSelectorTransfer* transfer,\n    SerializeBuffer* buffer, const ObjectIdProvider& provider) {\n    DAWN_UNUSED(buffer);\n\n\n\n\n    ASSERT(transfer->chain.sType == WGPUSType_SurfaceDescriptorFromCanvasHTMLSelector);\n    ASSERT(transfer->chain.hasNext == (record.chain.next != nullptr));\n\n\n    {\n        transfer->selectorStrlen = std::strlen(record.selector);\n\n        char* stringInBuffer;\n        WIRE_TRY(buffer->NextN(transfer->selectorStrlen, &stringInBuffer));\n        memcpy(stringInBuffer, record.selector, transfer->selectorStrlen);\n    }\n\n    return WireResult::Success;\n}\nDAWN_UNUSED_FUNC(WGPUSurfaceDescriptorFromCanvasHTMLSelectorSerialize);\n\nDAWN_DECLARE_UNUSED WireResult WGPUSurfaceDescriptorFromCanvasHTMLSelectorDeserialize(\n    WGPUSurfaceDescriptorFromCanvasHTMLSelector* record,\n    const volatile WGPUSurfaceDescriptorFromCanvasHTMLSelectorTransfer* transfer,\n    DeserializeBuffer* deserializeBuffer,\n    DeserializeAllocator* allocator, const ObjectIdResolver& resolver) {\n    DAWN_UNUSED(allocator);\n\n\n\n\n\n    ASSERT(record->chain.sType == WGPUSType_SurfaceDescriptorFromCanvasHTMLSelector);\n    ASSERT(record->chain.next == nullptr);\n\n\n    {\n        uint64_t stringLength64 = transfer->selectorStrlen;\n        if (stringLength64 >= std::numeric_limits<size_t>::max()) {\n            return WireResult::FatalError;\n        }\n        size_t stringLength = static_cast<size_t>(stringLength64);\n\n        const volatile char* stringInBuffer;\n        WIRE_TRY(deserializeBuffer->ReadN(stringLength, &stringInBuffer));\n\n        char* copiedString;\n        WIRE_TRY(GetSpace(allocator, stringLength + 1, &copiedString));\n        memcpy(copiedString, const_cast<const char*>(stringInBuffer), stringLength);\n        copiedString[stringLength] = '\\0';\n        record->selector = copiedString;\n    }\n\n\n    return WireResult::Success;\n}\nDAWN_UNUSED_FUNC(WGPUSurfaceDescriptorFromCanvasHTMLSelectorDeserialize);\n\n                \nstruct WGPUSwapChainDescriptorTransfer {\n    static_assert(0 <= 1,\n                  \"Record must be at most one of is_cmd, extensible, and chained.\");\n    bool hasNextInChain;\n\n    WGPUTextureUsageFlags usage;\n    \nWGPUTextureFormat format;\n    \nuint32_t width;\n    \nuint32_t height;\n    \nWGPUPresentMode presentMode;\n    \nuint64_t implementation;\n\n    uint64_t labelStrlen;\n\n    bool has_label;\n};\n\n\n\nDAWN_DECLARE_UNUSED size_t WGPUSwapChainDescriptorGetExtraRequiredSize(const WGPUSwapChainDescriptor& record) {\n    DAWN_UNUSED(record);\n\n    size_t result = 0;\n\n    if (record.nextInChain != nullptr) {\n        result += GetChainedStructExtraRequiredSize(record.nextInChain);\n    }\n\n\n    bool has_label = record.label != nullptr;\n    if (has_label)\n    {\n    result += std::strlen(record.label);\n    }\n\n    {\n    }\n    {\n    }\n    {\n    }\n    {\n    }\n    {\n    }\n    {\n    }\n\n    return result;\n}\n// GetExtraRequiredSize isn't used for structures that are value members of other structures\n// because we assume they cannot contain pointers themselves.\nDAWN_UNUSED_FUNC(WGPUSwapChainDescriptorGetExtraRequiredSize);\n\nDAWN_DECLARE_UNUSED WireResult WGPUSwapChainDescriptorSerialize(\n    const WGPUSwapChainDescriptor& record,\n    WGPUSwapChainDescriptorTransfer* transfer,\n    SerializeBuffer* buffer, const ObjectIdProvider& provider) {\n    DAWN_UNUSED(buffer);\n\n\n    transfer->usage = record.usage;\n    transfer->format = record.format;\n    transfer->width = record.width;\n    transfer->height = record.height;\n    transfer->presentMode = record.presentMode;\n    transfer->implementation = record.implementation;\n\n    if (record.nextInChain != nullptr) {\n        transfer->hasNextInChain = true;\n        WIRE_TRY(SerializeChainedStruct(record.nextInChain, buffer, provider));\n    } else {\n        transfer->hasNextInChain = false;\n    }\n\n\n\n    bool has_label = record.label != nullptr;\n    transfer->has_label = has_label;\n    if (has_label)\n    {\n        transfer->labelStrlen = std::strlen(record.label);\n\n        char* stringInBuffer;\n        WIRE_TRY(buffer->NextN(transfer->labelStrlen, &stringInBuffer));\n        memcpy(stringInBuffer, record.label, transfer->labelStrlen);\n    }\n\n    return WireResult::Success;\n}\nDAWN_UNUSED_FUNC(WGPUSwapChainDescriptorSerialize);\n\nDAWN_DECLARE_UNUSED WireResult WGPUSwapChainDescriptorDeserialize(\n    WGPUSwapChainDescriptor* record,\n    const volatile WGPUSwapChainDescriptorTransfer* transfer,\n    DeserializeBuffer* deserializeBuffer,\n    DeserializeAllocator* allocator, const ObjectIdResolver& resolver) {\n    DAWN_UNUSED(allocator);\n\n\n\n    static_assert(sizeof(record->usage) >= sizeof(transfer->usage), \"Deserialize assignment may not narrow.\");\nrecord->usage = transfer->usage;\n    static_assert(sizeof(record->format) >= sizeof(transfer->format), \"Deserialize assignment may not narrow.\");\nrecord->format = transfer->format;\n    static_assert(sizeof(record->width) >= sizeof(transfer->width), \"Deserialize assignment may not narrow.\");\nrecord->width = transfer->width;\n    static_assert(sizeof(record->height) >= sizeof(transfer->height), \"Deserialize assignment may not narrow.\");\nrecord->height = transfer->height;\n    static_assert(sizeof(record->presentMode) >= sizeof(transfer->presentMode), \"Deserialize assignment may not narrow.\");\nrecord->presentMode = transfer->presentMode;\n    static_assert(sizeof(record->implementation) >= sizeof(transfer->implementation), \"Deserialize assignment may not narrow.\");\nrecord->implementation = transfer->implementation;\n\n    record->nextInChain = nullptr;\n    if (transfer->hasNextInChain) {\n        WIRE_TRY(DeserializeChainedStruct(&record->nextInChain, deserializeBuffer, allocator, resolver));\n    }\n\n\n\n    bool has_label = transfer->has_label;\n    record->label = nullptr;\n    if (has_label)\n    {\n        uint64_t stringLength64 = transfer->labelStrlen;\n        if (stringLength64 >= std::numeric_limits<size_t>::max()) {\n            return WireResult::FatalError;\n        }\n        size_t stringLength = static_cast<size_t>(stringLength64);\n\n        const volatile char* stringInBuffer;\n        WIRE_TRY(deserializeBuffer->ReadN(stringLength, &stringInBuffer));\n\n        char* copiedString;\n        WIRE_TRY(GetSpace(allocator, stringLength + 1, &copiedString));\n        memcpy(copiedString, const_cast<const char*>(stringInBuffer), stringLength);\n        copiedString[stringLength] = '\\0';\n        record->label = copiedString;\n    }\n\n\n    return WireResult::Success;\n}\nDAWN_UNUSED_FUNC(WGPUSwapChainDescriptorDeserialize);\n\n                \nstruct WGPUTextureBindingLayoutTransfer {\n    static_assert(0 <= 1,\n                  \"Record must be at most one of is_cmd, extensible, and chained.\");\n    bool hasNextInChain;\n\n    \nWGPUTextureSampleType sampleType;\n    \nWGPUTextureViewDimension viewDimension;\n    \nbool multisampled;\n\n\n};\n\n\n\nDAWN_DECLARE_UNUSED size_t WGPUTextureBindingLayoutGetExtraRequiredSize(const WGPUTextureBindingLayout& record) {\n    DAWN_UNUSED(record);\n\n    size_t result = 0;\n\n    if (record.nextInChain != nullptr) {\n        result += GetChainedStructExtraRequiredSize(record.nextInChain);\n    }\n\n\n    {\n    }\n    {\n    }\n    {\n    }\n\n    return result;\n}\n// GetExtraRequiredSize isn't used for structures that are value members of other structures\n// because we assume they cannot contain pointers themselves.\nDAWN_UNUSED_FUNC(WGPUTextureBindingLayoutGetExtraRequiredSize);\n\nDAWN_DECLARE_UNUSED WireResult WGPUTextureBindingLayoutSerialize(\n    const WGPUTextureBindingLayout& record,\n    WGPUTextureBindingLayoutTransfer* transfer,\n    SerializeBuffer* buffer, const ObjectIdProvider& provider) {\n    DAWN_UNUSED(buffer);\n\n\n    transfer->sampleType = record.sampleType;\n    transfer->viewDimension = record.viewDimension;\n    transfer->multisampled = record.multisampled;\n\n    if (record.nextInChain != nullptr) {\n        transfer->hasNextInChain = true;\n        WIRE_TRY(SerializeChainedStruct(record.nextInChain, buffer, provider));\n    } else {\n        transfer->hasNextInChain = false;\n    }\n\n\n\n    return WireResult::Success;\n}\nDAWN_UNUSED_FUNC(WGPUTextureBindingLayoutSerialize);\n\nDAWN_DECLARE_UNUSED WireResult WGPUTextureBindingLayoutDeserialize(\n    WGPUTextureBindingLayout* record,\n    const volatile WGPUTextureBindingLayoutTransfer* transfer,\n    DeserializeBuffer* deserializeBuffer,\n    DeserializeAllocator* allocator, const ObjectIdResolver& resolver) {\n    DAWN_UNUSED(allocator);\n\n\n\n    static_assert(sizeof(record->sampleType) >= sizeof(transfer->sampleType), \"Deserialize assignment may not narrow.\");\nrecord->sampleType = transfer->sampleType;\n    static_assert(sizeof(record->viewDimension) >= sizeof(transfer->viewDimension), \"Deserialize assignment may not narrow.\");\nrecord->viewDimension = transfer->viewDimension;\n    static_assert(sizeof(record->multisampled) >= sizeof(transfer->multisampled), \"Deserialize assignment may not narrow.\");\nrecord->multisampled = transfer->multisampled;\n\n    record->nextInChain = nullptr;\n    if (transfer->hasNextInChain) {\n        WIRE_TRY(DeserializeChainedStruct(&record->nextInChain, deserializeBuffer, allocator, resolver));\n    }\n\n\n\n\n    return WireResult::Success;\n}\nDAWN_UNUSED_FUNC(WGPUTextureBindingLayoutDeserialize);\n\n                \nstruct WGPUTextureDataLayoutTransfer {\n    static_assert(0 <= 1,\n                  \"Record must be at most one of is_cmd, extensible, and chained.\");\n    bool hasNextInChain;\n\n    \nuint64_t offset;\n    \nuint32_t bytesPerRow;\n    \nuint32_t rowsPerImage;\n\n\n};\n\n\n\nDAWN_DECLARE_UNUSED size_t WGPUTextureDataLayoutGetExtraRequiredSize(const WGPUTextureDataLayout& record) {\n    DAWN_UNUSED(record);\n\n    size_t result = 0;\n\n    if (record.nextInChain != nullptr) {\n        result += GetChainedStructExtraRequiredSize(record.nextInChain);\n    }\n\n\n    {\n    }\n    {\n    }\n    {\n    }\n\n    return result;\n}\n// GetExtraRequiredSize isn't used for structures that are value members of other structures\n// because we assume they cannot contain pointers themselves.\nDAWN_UNUSED_FUNC(WGPUTextureDataLayoutGetExtraRequiredSize);\n\nDAWN_DECLARE_UNUSED WireResult WGPUTextureDataLayoutSerialize(\n    const WGPUTextureDataLayout& record,\n    WGPUTextureDataLayoutTransfer* transfer,\n    SerializeBuffer* buffer, const ObjectIdProvider& provider) {\n    DAWN_UNUSED(buffer);\n\n\n    transfer->offset = record.offset;\n    transfer->bytesPerRow = record.bytesPerRow;\n    transfer->rowsPerImage = record.rowsPerImage;\n\n    if (record.nextInChain != nullptr) {\n        transfer->hasNextInChain = true;\n        WIRE_TRY(SerializeChainedStruct(record.nextInChain, buffer, provider));\n    } else {\n        transfer->hasNextInChain = false;\n    }\n\n\n\n    return WireResult::Success;\n}\nDAWN_UNUSED_FUNC(WGPUTextureDataLayoutSerialize);\n\nDAWN_DECLARE_UNUSED WireResult WGPUTextureDataLayoutDeserialize(\n    WGPUTextureDataLayout* record,\n    const volatile WGPUTextureDataLayoutTransfer* transfer,\n    DeserializeBuffer* deserializeBuffer,\n    DeserializeAllocator* allocator, const ObjectIdResolver& resolver) {\n    DAWN_UNUSED(allocator);\n\n\n\n    static_assert(sizeof(record->offset) >= sizeof(transfer->offset), \"Deserialize assignment may not narrow.\");\nrecord->offset = transfer->offset;\n    static_assert(sizeof(record->bytesPerRow) >= sizeof(transfer->bytesPerRow), \"Deserialize assignment may not narrow.\");\nrecord->bytesPerRow = transfer->bytesPerRow;\n    static_assert(sizeof(record->rowsPerImage) >= sizeof(transfer->rowsPerImage), \"Deserialize assignment may not narrow.\");\nrecord->rowsPerImage = transfer->rowsPerImage;\n\n    record->nextInChain = nullptr;\n    if (transfer->hasNextInChain) {\n        WIRE_TRY(DeserializeChainedStruct(&record->nextInChain, deserializeBuffer, allocator, resolver));\n    }\n\n\n\n\n    return WireResult::Success;\n}\nDAWN_UNUSED_FUNC(WGPUTextureDataLayoutDeserialize);\n\n                \nstruct WGPUTextureViewDescriptorTransfer {\n    static_assert(0 <= 1,\n                  \"Record must be at most one of is_cmd, extensible, and chained.\");\n    bool hasNextInChain;\n\n    \nWGPUTextureFormat format;\n    \nWGPUTextureViewDimension dimension;\n    \nuint32_t baseMipLevel;\n    \nuint32_t mipLevelCount;\n    \nuint32_t baseArrayLayer;\n    \nuint32_t arrayLayerCount;\n    \nWGPUTextureAspect aspect;\n\n    uint64_t labelStrlen;\n\n    bool has_label;\n};\n\n\n\nDAWN_DECLARE_UNUSED size_t WGPUTextureViewDescriptorGetExtraRequiredSize(const WGPUTextureViewDescriptor& record) {\n    DAWN_UNUSED(record);\n\n    size_t result = 0;\n\n    if (record.nextInChain != nullptr) {\n        result += GetChainedStructExtraRequiredSize(record.nextInChain);\n    }\n\n\n    bool has_label = record.label != nullptr;\n    if (has_label)\n    {\n    result += std::strlen(record.label);\n    }\n\n    {\n    }\n    {\n    }\n    {\n    }\n    {\n    }\n    {\n    }\n    {\n    }\n    {\n    }\n\n    return result;\n}\n// GetExtraRequiredSize isn't used for structures that are value members of other structures\n// because we assume they cannot contain pointers themselves.\nDAWN_UNUSED_FUNC(WGPUTextureViewDescriptorGetExtraRequiredSize);\n\nDAWN_DECLARE_UNUSED WireResult WGPUTextureViewDescriptorSerialize(\n    const WGPUTextureViewDescriptor& record,\n    WGPUTextureViewDescriptorTransfer* transfer,\n    SerializeBuffer* buffer, const ObjectIdProvider& provider) {\n    DAWN_UNUSED(buffer);\n\n\n    transfer->format = record.format;\n    transfer->dimension = record.dimension;\n    transfer->baseMipLevel = record.baseMipLevel;\n    transfer->mipLevelCount = record.mipLevelCount;\n    transfer->baseArrayLayer = record.baseArrayLayer;\n    transfer->arrayLayerCount = record.arrayLayerCount;\n    transfer->aspect = record.aspect;\n\n    if (record.nextInChain != nullptr) {\n        transfer->hasNextInChain = true;\n        WIRE_TRY(SerializeChainedStruct(record.nextInChain, buffer, provider));\n    } else {\n        transfer->hasNextInChain = false;\n    }\n\n\n\n    bool has_label = record.label != nullptr;\n    transfer->has_label = has_label;\n    if (has_label)\n    {\n        transfer->labelStrlen = std::strlen(record.label);\n\n        char* stringInBuffer;\n        WIRE_TRY(buffer->NextN(transfer->labelStrlen, &stringInBuffer));\n        memcpy(stringInBuffer, record.label, transfer->labelStrlen);\n    }\n\n    return WireResult::Success;\n}\nDAWN_UNUSED_FUNC(WGPUTextureViewDescriptorSerialize);\n\nDAWN_DECLARE_UNUSED WireResult WGPUTextureViewDescriptorDeserialize(\n    WGPUTextureViewDescriptor* record,\n    const volatile WGPUTextureViewDescriptorTransfer* transfer,\n    DeserializeBuffer* deserializeBuffer,\n    DeserializeAllocator* allocator, const ObjectIdResolver& resolver) {\n    DAWN_UNUSED(allocator);\n\n\n\n    static_assert(sizeof(record->format) >= sizeof(transfer->format), \"Deserialize assignment may not narrow.\");\nrecord->format = transfer->format;\n    static_assert(sizeof(record->dimension) >= sizeof(transfer->dimension), \"Deserialize assignment may not narrow.\");\nrecord->dimension = transfer->dimension;\n    static_assert(sizeof(record->baseMipLevel) >= sizeof(transfer->baseMipLevel), \"Deserialize assignment may not narrow.\");\nrecord->baseMipLevel = transfer->baseMipLevel;\n    static_assert(sizeof(record->mipLevelCount) >= sizeof(transfer->mipLevelCount), \"Deserialize assignment may not narrow.\");\nrecord->mipLevelCount = transfer->mipLevelCount;\n    static_assert(sizeof(record->baseArrayLayer) >= sizeof(transfer->baseArrayLayer), \"Deserialize assignment may not narrow.\");\nrecord->baseArrayLayer = transfer->baseArrayLayer;\n    static_assert(sizeof(record->arrayLayerCount) >= sizeof(transfer->arrayLayerCount), \"Deserialize assignment may not narrow.\");\nrecord->arrayLayerCount = transfer->arrayLayerCount;\n    static_assert(sizeof(record->aspect) >= sizeof(transfer->aspect), \"Deserialize assignment may not narrow.\");\nrecord->aspect = transfer->aspect;\n\n    record->nextInChain = nullptr;\n    if (transfer->hasNextInChain) {\n        WIRE_TRY(DeserializeChainedStruct(&record->nextInChain, deserializeBuffer, allocator, resolver));\n    }\n\n\n\n    bool has_label = transfer->has_label;\n    record->label = nullptr;\n    if (has_label)\n    {\n        uint64_t stringLength64 = transfer->labelStrlen;\n        if (stringLength64 >= std::numeric_limits<size_t>::max()) {\n            return WireResult::FatalError;\n        }\n        size_t stringLength = static_cast<size_t>(stringLength64);\n\n        const volatile char* stringInBuffer;\n        WIRE_TRY(deserializeBuffer->ReadN(stringLength, &stringInBuffer));\n\n        char* copiedString;\n        WIRE_TRY(GetSpace(allocator, stringLength + 1, &copiedString));\n        memcpy(copiedString, const_cast<const char*>(stringInBuffer), stringLength);\n        copiedString[stringLength] = '\\0';\n        record->label = copiedString;\n    }\n\n\n    return WireResult::Success;\n}\nDAWN_UNUSED_FUNC(WGPUTextureViewDescriptorDeserialize);\n\n                \nstruct WGPUVertexAttributeTransfer {\n    static_assert(0 <= 1,\n                  \"Record must be at most one of is_cmd, extensible, and chained.\");\n\n    \nWGPUVertexFormat format;\n    \nuint64_t offset;\n    \nuint32_t shaderLocation;\n\n\n};\n\n\n\nDAWN_DECLARE_UNUSED size_t WGPUVertexAttributeGetExtraRequiredSize(const WGPUVertexAttribute& record) {\n    DAWN_UNUSED(record);\n\n    size_t result = 0;\n\n\n\n    {\n    }\n    {\n    }\n    {\n    }\n\n    return result;\n}\n// GetExtraRequiredSize isn't used for structures that are value members of other structures\n// because we assume they cannot contain pointers themselves.\nDAWN_UNUSED_FUNC(WGPUVertexAttributeGetExtraRequiredSize);\n\nDAWN_DECLARE_UNUSED WireResult WGPUVertexAttributeSerialize(\n    const WGPUVertexAttribute& record,\n    WGPUVertexAttributeTransfer* transfer,\n    SerializeBuffer* buffer) {\n    DAWN_UNUSED(buffer);\n\n\n    transfer->format = record.format;\n    transfer->offset = record.offset;\n    transfer->shaderLocation = record.shaderLocation;\n\n\n\n\n    return WireResult::Success;\n}\nDAWN_UNUSED_FUNC(WGPUVertexAttributeSerialize);\n\nDAWN_DECLARE_UNUSED WireResult WGPUVertexAttributeDeserialize(\n    WGPUVertexAttribute* record,\n    const volatile WGPUVertexAttributeTransfer* transfer,\n    DeserializeBuffer* deserializeBuffer,\n    DeserializeAllocator* allocator) {\n    DAWN_UNUSED(allocator);\n\n\n\n    static_assert(sizeof(record->format) >= sizeof(transfer->format), \"Deserialize assignment may not narrow.\");\nrecord->format = transfer->format;\n    static_assert(sizeof(record->offset) >= sizeof(transfer->offset), \"Deserialize assignment may not narrow.\");\nrecord->offset = transfer->offset;\n    static_assert(sizeof(record->shaderLocation) >= sizeof(transfer->shaderLocation), \"Deserialize assignment may not narrow.\");\nrecord->shaderLocation = transfer->shaderLocation;\n\n\n\n\n\n    return WireResult::Success;\n}\nDAWN_UNUSED_FUNC(WGPUVertexAttributeDeserialize);\n\n                \nstruct WGPUBindGroupDescriptorTransfer {\n    static_assert(0 <= 1,\n                  \"Record must be at most one of is_cmd, extensible, and chained.\");\n    bool hasNextInChain;\n\n    ObjectId layout;\n    \nuint32_t entryCount;\n\n    uint64_t labelStrlen;\n\n    bool has_label;\n};\n\n\n\nDAWN_DECLARE_UNUSED size_t WGPUBindGroupDescriptorGetExtraRequiredSize(const WGPUBindGroupDescriptor& record) {\n    DAWN_UNUSED(record);\n\n    size_t result = 0;\n\n    if (record.nextInChain != nullptr) {\n        result += GetChainedStructExtraRequiredSize(record.nextInChain);\n    }\n\n\n    bool has_label = record.label != nullptr;\n    if (has_label)\n    {\n    result += std::strlen(record.label);\n    }\n\n    {\n    }\n    {\n    }\n    {\n        \n        auto memberLength = record.entryCount;\n        result += memberLength * sizeof(WGPUBindGroupEntryTransfer);\n        for (decltype(memberLength) i = 0; i < memberLength; ++i) {\n            \n            result += WGPUBindGroupEntryGetExtraRequiredSize(record.entries[i]);\n        }\n    }\n\n    return result;\n}\n// GetExtraRequiredSize isn't used for structures that are value members of other structures\n// because we assume they cannot contain pointers themselves.\nDAWN_UNUSED_FUNC(WGPUBindGroupDescriptorGetExtraRequiredSize);\n\nDAWN_DECLARE_UNUSED WireResult WGPUBindGroupDescriptorSerialize(\n    const WGPUBindGroupDescriptor& record,\n    WGPUBindGroupDescriptorTransfer* transfer,\n    SerializeBuffer* buffer, const ObjectIdProvider& provider) {\n    DAWN_UNUSED(buffer);\n\n\n    WIRE_TRY(provider.GetId(record.layout, &transfer->layout));\n    transfer->entryCount = record.entryCount;\n\n    if (record.nextInChain != nullptr) {\n        transfer->hasNextInChain = true;\n        WIRE_TRY(SerializeChainedStruct(record.nextInChain, buffer, provider));\n    } else {\n        transfer->hasNextInChain = false;\n    }\n\n\n\n    bool has_label = record.label != nullptr;\n    transfer->has_label = has_label;\n    if (has_label)\n    {\n        transfer->labelStrlen = std::strlen(record.label);\n\n        char* stringInBuffer;\n        WIRE_TRY(buffer->NextN(transfer->labelStrlen, &stringInBuffer));\n        memcpy(stringInBuffer, record.label, transfer->labelStrlen);\n    }\n\n    \n\n    {\n        auto memberLength = record.entryCount;\n\n        WGPUBindGroupEntryTransfer* memberBuffer;\n        WIRE_TRY(buffer->NextN(memberLength, &memberBuffer));\n\n        for (decltype(memberLength) i = 0; i < memberLength; ++i) {\n            WIRE_TRY(WGPUBindGroupEntrySerialize(record.entries[i], &memberBuffer[i], buffer, provider));\n        }\n    }\n    return WireResult::Success;\n}\nDAWN_UNUSED_FUNC(WGPUBindGroupDescriptorSerialize);\n\nDAWN_DECLARE_UNUSED WireResult WGPUBindGroupDescriptorDeserialize(\n    WGPUBindGroupDescriptor* record,\n    const volatile WGPUBindGroupDescriptorTransfer* transfer,\n    DeserializeBuffer* deserializeBuffer,\n    DeserializeAllocator* allocator, const ObjectIdResolver& resolver) {\n    DAWN_UNUSED(allocator);\n\n\n\n    WIRE_TRY(resolver.GetFromId(transfer->layout, &record->layout));\n    static_assert(sizeof(record->entryCount) >= sizeof(transfer->entryCount), \"Deserialize assignment may not narrow.\");\nrecord->entryCount = transfer->entryCount;\n\n    record->nextInChain = nullptr;\n    if (transfer->hasNextInChain) {\n        WIRE_TRY(DeserializeChainedStruct(&record->nextInChain, deserializeBuffer, allocator, resolver));\n    }\n\n\n\n    bool has_label = transfer->has_label;\n    record->label = nullptr;\n    if (has_label)\n    {\n        uint64_t stringLength64 = transfer->labelStrlen;\n        if (stringLength64 >= std::numeric_limits<size_t>::max()) {\n            return WireResult::FatalError;\n        }\n        size_t stringLength = static_cast<size_t>(stringLength64);\n\n        const volatile char* stringInBuffer;\n        WIRE_TRY(deserializeBuffer->ReadN(stringLength, &stringInBuffer));\n\n        char* copiedString;\n        WIRE_TRY(GetSpace(allocator, stringLength + 1, &copiedString));\n        memcpy(copiedString, const_cast<const char*>(stringInBuffer), stringLength);\n        copiedString[stringLength] = '\\0';\n        record->label = copiedString;\n    }\n\n    \n\n    {\n        auto memberLength = record->entryCount;\n        const volatile WGPUBindGroupEntryTransfer* memberBuffer;\n        WIRE_TRY(deserializeBuffer->ReadN(memberLength, &memberBuffer));\n\n        WGPUBindGroupEntry* copiedMembers;\n        WIRE_TRY(GetSpace(allocator, memberLength, &copiedMembers));\n        record->entries = copiedMembers;\n\n        for (decltype(memberLength) i = 0; i < memberLength; ++i) {\n            WIRE_TRY(WGPUBindGroupEntryDeserialize(&copiedMembers[i], &memberBuffer[i], deserializeBuffer, allocator, resolver));\n        }\n    }\n\n    return WireResult::Success;\n}\nDAWN_UNUSED_FUNC(WGPUBindGroupDescriptorDeserialize);\n\n                \nstruct WGPUBindGroupLayoutEntryTransfer {\n    static_assert(0 <= 1,\n                  \"Record must be at most one of is_cmd, extensible, and chained.\");\n    bool hasNextInChain;\n\n    \nuint32_t binding;\n    WGPUShaderStageFlags visibility;\n    WGPUBufferBindingLayoutTransfer buffer;\n    WGPUSamplerBindingLayoutTransfer sampler;\n    WGPUTextureBindingLayoutTransfer texture;\n    WGPUStorageTextureBindingLayoutTransfer storageTexture;\n\n\n};\n\n\n\nDAWN_DECLARE_UNUSED size_t WGPUBindGroupLayoutEntryGetExtraRequiredSize(const WGPUBindGroupLayoutEntry& record) {\n    DAWN_UNUSED(record);\n\n    size_t result = 0;\n\n    if (record.nextInChain != nullptr) {\n        result += GetChainedStructExtraRequiredSize(record.nextInChain);\n    }\n\n\n    {\n    }\n    {\n    }\n    {\n        result += WGPUBufferBindingLayoutGetExtraRequiredSize(record.buffer);\n    }\n    {\n        result += WGPUSamplerBindingLayoutGetExtraRequiredSize(record.sampler);\n    }\n    {\n        result += WGPUTextureBindingLayoutGetExtraRequiredSize(record.texture);\n    }\n    {\n        result += WGPUStorageTextureBindingLayoutGetExtraRequiredSize(record.storageTexture);\n    }\n\n    return result;\n}\n// GetExtraRequiredSize isn't used for structures that are value members of other structures\n// because we assume they cannot contain pointers themselves.\nDAWN_UNUSED_FUNC(WGPUBindGroupLayoutEntryGetExtraRequiredSize);\n\nDAWN_DECLARE_UNUSED WireResult WGPUBindGroupLayoutEntrySerialize(\n    const WGPUBindGroupLayoutEntry& record,\n    WGPUBindGroupLayoutEntryTransfer* transfer,\n    SerializeBuffer* buffer, const ObjectIdProvider& provider) {\n    DAWN_UNUSED(buffer);\n\n\n    transfer->binding = record.binding;\n    transfer->visibility = record.visibility;\n    WIRE_TRY(WGPUBufferBindingLayoutSerialize(record.buffer, &transfer->buffer, buffer, provider));\n    WIRE_TRY(WGPUSamplerBindingLayoutSerialize(record.sampler, &transfer->sampler, buffer, provider));\n    WIRE_TRY(WGPUTextureBindingLayoutSerialize(record.texture, &transfer->texture, buffer, provider));\n    WIRE_TRY(WGPUStorageTextureBindingLayoutSerialize(record.storageTexture, &transfer->storageTexture, buffer, provider));\n\n    if (record.nextInChain != nullptr) {\n        transfer->hasNextInChain = true;\n        WIRE_TRY(SerializeChainedStruct(record.nextInChain, buffer, provider));\n    } else {\n        transfer->hasNextInChain = false;\n    }\n\n\n\n    return WireResult::Success;\n}\nDAWN_UNUSED_FUNC(WGPUBindGroupLayoutEntrySerialize);\n\nDAWN_DECLARE_UNUSED WireResult WGPUBindGroupLayoutEntryDeserialize(\n    WGPUBindGroupLayoutEntry* record,\n    const volatile WGPUBindGroupLayoutEntryTransfer* transfer,\n    DeserializeBuffer* deserializeBuffer,\n    DeserializeAllocator* allocator, const ObjectIdResolver& resolver) {\n    DAWN_UNUSED(allocator);\n\n\n\n    static_assert(sizeof(record->binding) >= sizeof(transfer->binding), \"Deserialize assignment may not narrow.\");\nrecord->binding = transfer->binding;\n    static_assert(sizeof(record->visibility) >= sizeof(transfer->visibility), \"Deserialize assignment may not narrow.\");\nrecord->visibility = transfer->visibility;\n    WIRE_TRY(WGPUBufferBindingLayoutDeserialize(&record->buffer, &transfer->buffer, deserializeBuffer, allocator, resolver));\n    WIRE_TRY(WGPUSamplerBindingLayoutDeserialize(&record->sampler, &transfer->sampler, deserializeBuffer, allocator, resolver));\n    WIRE_TRY(WGPUTextureBindingLayoutDeserialize(&record->texture, &transfer->texture, deserializeBuffer, allocator, resolver));\n    WIRE_TRY(WGPUStorageTextureBindingLayoutDeserialize(&record->storageTexture, &transfer->storageTexture, deserializeBuffer, allocator, resolver));\n\n    record->nextInChain = nullptr;\n    if (transfer->hasNextInChain) {\n        WIRE_TRY(DeserializeChainedStruct(&record->nextInChain, deserializeBuffer, allocator, resolver));\n    }\n\n\n\n\n    return WireResult::Success;\n}\nDAWN_UNUSED_FUNC(WGPUBindGroupLayoutEntryDeserialize);\n\n                \nstruct WGPUBlendStateTransfer {\n    static_assert(0 <= 1,\n                  \"Record must be at most one of is_cmd, extensible, and chained.\");\n\n    WGPUBlendComponentTransfer color;\n    WGPUBlendComponentTransfer alpha;\n\n\n};\n\n\n\nDAWN_DECLARE_UNUSED size_t WGPUBlendStateGetExtraRequiredSize(const WGPUBlendState& record) {\n    DAWN_UNUSED(record);\n\n    size_t result = 0;\n\n\n\n    {\n        result += WGPUBlendComponentGetExtraRequiredSize(record.color);\n    }\n    {\n        result += WGPUBlendComponentGetExtraRequiredSize(record.alpha);\n    }\n\n    return result;\n}\n// GetExtraRequiredSize isn't used for structures that are value members of other structures\n// because we assume they cannot contain pointers themselves.\nDAWN_UNUSED_FUNC(WGPUBlendStateGetExtraRequiredSize);\n\nDAWN_DECLARE_UNUSED WireResult WGPUBlendStateSerialize(\n    const WGPUBlendState& record,\n    WGPUBlendStateTransfer* transfer,\n    SerializeBuffer* buffer) {\n    DAWN_UNUSED(buffer);\n\n\n    static_assert(sizeof(transfer->color) == sizeof(record.color), \"Serialize memcpy size must match.\");\nmemcpy(&transfer->color, &record.color, sizeof(WGPUBlendComponentTransfer));\n    static_assert(sizeof(transfer->alpha) == sizeof(record.alpha), \"Serialize memcpy size must match.\");\nmemcpy(&transfer->alpha, &record.alpha, sizeof(WGPUBlendComponentTransfer));\n\n\n\n\n    return WireResult::Success;\n}\nDAWN_UNUSED_FUNC(WGPUBlendStateSerialize);\n\nDAWN_DECLARE_UNUSED WireResult WGPUBlendStateDeserialize(\n    WGPUBlendState* record,\n    const volatile WGPUBlendStateTransfer* transfer,\n    DeserializeBuffer* deserializeBuffer,\n    DeserializeAllocator* allocator) {\n    DAWN_UNUSED(allocator);\n\n\n\n    static_assert(sizeof(record->color) == sizeof(transfer->color), \"Deserialize memcpy size must match.\");\nmemcpy(&record->color, const_cast<const WGPUBlendComponentTransfer*>(&transfer->color), sizeof(WGPUBlendComponentTransfer));\n    static_assert(sizeof(record->alpha) == sizeof(transfer->alpha), \"Deserialize memcpy size must match.\");\nmemcpy(&record->alpha, const_cast<const WGPUBlendComponentTransfer*>(&transfer->alpha), sizeof(WGPUBlendComponentTransfer));\n\n\n\n\n\n    return WireResult::Success;\n}\nDAWN_UNUSED_FUNC(WGPUBlendStateDeserialize);\n\n                \nstruct WGPUCompilationInfoTransfer {\n    static_assert(0 <= 1,\n                  \"Record must be at most one of is_cmd, extensible, and chained.\");\n    bool hasNextInChain;\n\n    \nuint32_t messageCount;\n\n\n};\n\n\n\nDAWN_DECLARE_UNUSED size_t WGPUCompilationInfoGetExtraRequiredSize(const WGPUCompilationInfo& record) {\n    DAWN_UNUSED(record);\n\n    size_t result = 0;\n\n    if (record.nextInChain != nullptr) {\n        result += GetChainedStructExtraRequiredSize(record.nextInChain);\n    }\n\n\n    {\n    }\n    {\n        \n        auto memberLength = record.messageCount;\n        result += memberLength * sizeof(WGPUCompilationMessageTransfer);\n        for (decltype(memberLength) i = 0; i < memberLength; ++i) {\n            \n            result += WGPUCompilationMessageGetExtraRequiredSize(record.messages[i]);\n        }\n    }\n\n    return result;\n}\n// GetExtraRequiredSize isn't used for structures that are value members of other structures\n// because we assume they cannot contain pointers themselves.\nDAWN_UNUSED_FUNC(WGPUCompilationInfoGetExtraRequiredSize);\n\nDAWN_DECLARE_UNUSED WireResult WGPUCompilationInfoSerialize(\n    const WGPUCompilationInfo& record,\n    WGPUCompilationInfoTransfer* transfer,\n    SerializeBuffer* buffer, const ObjectIdProvider& provider) {\n    DAWN_UNUSED(buffer);\n\n\n    transfer->messageCount = record.messageCount;\n\n    if (record.nextInChain != nullptr) {\n        transfer->hasNextInChain = true;\n        WIRE_TRY(SerializeChainedStruct(record.nextInChain, buffer, provider));\n    } else {\n        transfer->hasNextInChain = false;\n    }\n\n\n\n    \n\n    {\n        auto memberLength = record.messageCount;\n\n        WGPUCompilationMessageTransfer* memberBuffer;\n        WIRE_TRY(buffer->NextN(memberLength, &memberBuffer));\n\n        for (decltype(memberLength) i = 0; i < memberLength; ++i) {\n            WIRE_TRY(WGPUCompilationMessageSerialize(record.messages[i], &memberBuffer[i], buffer, provider));\n        }\n    }\n    return WireResult::Success;\n}\nDAWN_UNUSED_FUNC(WGPUCompilationInfoSerialize);\n\nDAWN_DECLARE_UNUSED WireResult WGPUCompilationInfoDeserialize(\n    WGPUCompilationInfo* record,\n    const volatile WGPUCompilationInfoTransfer* transfer,\n    DeserializeBuffer* deserializeBuffer,\n    DeserializeAllocator* allocator, const ObjectIdResolver& resolver) {\n    DAWN_UNUSED(allocator);\n\n\n\n    static_assert(sizeof(record->messageCount) >= sizeof(transfer->messageCount), \"Deserialize assignment may not narrow.\");\nrecord->messageCount = transfer->messageCount;\n\n    record->nextInChain = nullptr;\n    if (transfer->hasNextInChain) {\n        WIRE_TRY(DeserializeChainedStruct(&record->nextInChain, deserializeBuffer, allocator, resolver));\n    }\n\n\n\n    \n\n    {\n        auto memberLength = record->messageCount;\n        const volatile WGPUCompilationMessageTransfer* memberBuffer;\n        WIRE_TRY(deserializeBuffer->ReadN(memberLength, &memberBuffer));\n\n        WGPUCompilationMessage* copiedMembers;\n        WIRE_TRY(GetSpace(allocator, memberLength, &copiedMembers));\n        record->messages = copiedMembers;\n\n        for (decltype(memberLength) i = 0; i < memberLength; ++i) {\n            WIRE_TRY(WGPUCompilationMessageDeserialize(&copiedMembers[i], &memberBuffer[i], deserializeBuffer, allocator, resolver));\n        }\n    }\n\n    return WireResult::Success;\n}\nDAWN_UNUSED_FUNC(WGPUCompilationInfoDeserialize);\n\n                \nstruct WGPUComputePassDescriptorTransfer {\n    static_assert(0 <= 1,\n                  \"Record must be at most one of is_cmd, extensible, and chained.\");\n    bool hasNextInChain;\n\n    \nuint32_t timestampWriteCount;\n\n    uint64_t labelStrlen;\n\n    bool has_label;\n};\n\n\n\nDAWN_DECLARE_UNUSED size_t WGPUComputePassDescriptorGetExtraRequiredSize(const WGPUComputePassDescriptor& record) {\n    DAWN_UNUSED(record);\n\n    size_t result = 0;\n\n    if (record.nextInChain != nullptr) {\n        result += GetChainedStructExtraRequiredSize(record.nextInChain);\n    }\n\n\n    bool has_label = record.label != nullptr;\n    if (has_label)\n    {\n    result += std::strlen(record.label);\n    }\n\n    {\n    }\n    {\n        \n        auto memberLength = record.timestampWriteCount;\n        result += memberLength * sizeof(WGPUComputePassTimestampWriteTransfer);\n        for (decltype(memberLength) i = 0; i < memberLength; ++i) {\n            \n            result += WGPUComputePassTimestampWriteGetExtraRequiredSize(record.timestampWrites[i]);\n        }\n    }\n\n    return result;\n}\n// GetExtraRequiredSize isn't used for structures that are value members of other structures\n// because we assume they cannot contain pointers themselves.\nDAWN_UNUSED_FUNC(WGPUComputePassDescriptorGetExtraRequiredSize);\n\nDAWN_DECLARE_UNUSED WireResult WGPUComputePassDescriptorSerialize(\n    const WGPUComputePassDescriptor& record,\n    WGPUComputePassDescriptorTransfer* transfer,\n    SerializeBuffer* buffer, const ObjectIdProvider& provider) {\n    DAWN_UNUSED(buffer);\n\n\n    transfer->timestampWriteCount = record.timestampWriteCount;\n\n    if (record.nextInChain != nullptr) {\n        transfer->hasNextInChain = true;\n        WIRE_TRY(SerializeChainedStruct(record.nextInChain, buffer, provider));\n    } else {\n        transfer->hasNextInChain = false;\n    }\n\n\n\n    bool has_label = record.label != nullptr;\n    transfer->has_label = has_label;\n    if (has_label)\n    {\n        transfer->labelStrlen = std::strlen(record.label);\n\n        char* stringInBuffer;\n        WIRE_TRY(buffer->NextN(transfer->labelStrlen, &stringInBuffer));\n        memcpy(stringInBuffer, record.label, transfer->labelStrlen);\n    }\n\n    \n\n    {\n        auto memberLength = record.timestampWriteCount;\n\n        WGPUComputePassTimestampWriteTransfer* memberBuffer;\n        WIRE_TRY(buffer->NextN(memberLength, &memberBuffer));\n\n        for (decltype(memberLength) i = 0; i < memberLength; ++i) {\n            WIRE_TRY(WGPUComputePassTimestampWriteSerialize(record.timestampWrites[i], &memberBuffer[i], buffer, provider));\n        }\n    }\n    return WireResult::Success;\n}\nDAWN_UNUSED_FUNC(WGPUComputePassDescriptorSerialize);\n\nDAWN_DECLARE_UNUSED WireResult WGPUComputePassDescriptorDeserialize(\n    WGPUComputePassDescriptor* record,\n    const volatile WGPUComputePassDescriptorTransfer* transfer,\n    DeserializeBuffer* deserializeBuffer,\n    DeserializeAllocator* allocator, const ObjectIdResolver& resolver) {\n    DAWN_UNUSED(allocator);\n\n\n\n    static_assert(sizeof(record->timestampWriteCount) >= sizeof(transfer->timestampWriteCount), \"Deserialize assignment may not narrow.\");\nrecord->timestampWriteCount = transfer->timestampWriteCount;\n\n    record->nextInChain = nullptr;\n    if (transfer->hasNextInChain) {\n        WIRE_TRY(DeserializeChainedStruct(&record->nextInChain, deserializeBuffer, allocator, resolver));\n    }\n\n\n\n    bool has_label = transfer->has_label;\n    record->label = nullptr;\n    if (has_label)\n    {\n        uint64_t stringLength64 = transfer->labelStrlen;\n        if (stringLength64 >= std::numeric_limits<size_t>::max()) {\n            return WireResult::FatalError;\n        }\n        size_t stringLength = static_cast<size_t>(stringLength64);\n\n        const volatile char* stringInBuffer;\n        WIRE_TRY(deserializeBuffer->ReadN(stringLength, &stringInBuffer));\n\n        char* copiedString;\n        WIRE_TRY(GetSpace(allocator, stringLength + 1, &copiedString));\n        memcpy(copiedString, const_cast<const char*>(stringInBuffer), stringLength);\n        copiedString[stringLength] = '\\0';\n        record->label = copiedString;\n    }\n\n    \n\n    {\n        auto memberLength = record->timestampWriteCount;\n        const volatile WGPUComputePassTimestampWriteTransfer* memberBuffer;\n        WIRE_TRY(deserializeBuffer->ReadN(memberLength, &memberBuffer));\n\n        WGPUComputePassTimestampWrite* copiedMembers;\n        WIRE_TRY(GetSpace(allocator, memberLength, &copiedMembers));\n        record->timestampWrites = copiedMembers;\n\n        for (decltype(memberLength) i = 0; i < memberLength; ++i) {\n            WIRE_TRY(WGPUComputePassTimestampWriteDeserialize(&copiedMembers[i], &memberBuffer[i], deserializeBuffer, allocator, resolver));\n        }\n    }\n\n    return WireResult::Success;\n}\nDAWN_UNUSED_FUNC(WGPUComputePassDescriptorDeserialize);\n\n                \nstruct WGPUDepthStencilStateTransfer {\n    static_assert(0 <= 1,\n                  \"Record must be at most one of is_cmd, extensible, and chained.\");\n    bool hasNextInChain;\n\n    \nWGPUTextureFormat format;\n    \nbool depthWriteEnabled;\n    \nWGPUCompareFunction depthCompare;\n    WGPUStencilFaceStateTransfer stencilFront;\n    WGPUStencilFaceStateTransfer stencilBack;\n    \nuint32_t stencilReadMask;\n    \nuint32_t stencilWriteMask;\n    \nint32_t depthBias;\n    \nfloat depthBiasSlopeScale;\n    \nfloat depthBiasClamp;\n\n\n};\n\n\n\nDAWN_DECLARE_UNUSED size_t WGPUDepthStencilStateGetExtraRequiredSize(const WGPUDepthStencilState& record) {\n    DAWN_UNUSED(record);\n\n    size_t result = 0;\n\n    if (record.nextInChain != nullptr) {\n        result += GetChainedStructExtraRequiredSize(record.nextInChain);\n    }\n\n\n    {\n    }\n    {\n    }\n    {\n    }\n    {\n        result += WGPUStencilFaceStateGetExtraRequiredSize(record.stencilFront);\n    }\n    {\n        result += WGPUStencilFaceStateGetExtraRequiredSize(record.stencilBack);\n    }\n    {\n    }\n    {\n    }\n    {\n    }\n    {\n    }\n    {\n    }\n\n    return result;\n}\n// GetExtraRequiredSize isn't used for structures that are value members of other structures\n// because we assume they cannot contain pointers themselves.\nDAWN_UNUSED_FUNC(WGPUDepthStencilStateGetExtraRequiredSize);\n\nDAWN_DECLARE_UNUSED WireResult WGPUDepthStencilStateSerialize(\n    const WGPUDepthStencilState& record,\n    WGPUDepthStencilStateTransfer* transfer,\n    SerializeBuffer* buffer, const ObjectIdProvider& provider) {\n    DAWN_UNUSED(buffer);\n\n\n    transfer->format = record.format;\n    transfer->depthWriteEnabled = record.depthWriteEnabled;\n    transfer->depthCompare = record.depthCompare;\n    static_assert(sizeof(transfer->stencilFront) == sizeof(record.stencilFront), \"Serialize memcpy size must match.\");\nmemcpy(&transfer->stencilFront, &record.stencilFront, sizeof(WGPUStencilFaceStateTransfer));\n    static_assert(sizeof(transfer->stencilBack) == sizeof(record.stencilBack), \"Serialize memcpy size must match.\");\nmemcpy(&transfer->stencilBack, &record.stencilBack, sizeof(WGPUStencilFaceStateTransfer));\n    transfer->stencilReadMask = record.stencilReadMask;\n    transfer->stencilWriteMask = record.stencilWriteMask;\n    transfer->depthBias = record.depthBias;\n    transfer->depthBiasSlopeScale = record.depthBiasSlopeScale;\n    transfer->depthBiasClamp = record.depthBiasClamp;\n\n    if (record.nextInChain != nullptr) {\n        transfer->hasNextInChain = true;\n        WIRE_TRY(SerializeChainedStruct(record.nextInChain, buffer, provider));\n    } else {\n        transfer->hasNextInChain = false;\n    }\n\n\n\n    return WireResult::Success;\n}\nDAWN_UNUSED_FUNC(WGPUDepthStencilStateSerialize);\n\nDAWN_DECLARE_UNUSED WireResult WGPUDepthStencilStateDeserialize(\n    WGPUDepthStencilState* record,\n    const volatile WGPUDepthStencilStateTransfer* transfer,\n    DeserializeBuffer* deserializeBuffer,\n    DeserializeAllocator* allocator, const ObjectIdResolver& resolver) {\n    DAWN_UNUSED(allocator);\n\n\n\n    static_assert(sizeof(record->format) >= sizeof(transfer->format), \"Deserialize assignment may not narrow.\");\nrecord->format = transfer->format;\n    static_assert(sizeof(record->depthWriteEnabled) >= sizeof(transfer->depthWriteEnabled), \"Deserialize assignment may not narrow.\");\nrecord->depthWriteEnabled = transfer->depthWriteEnabled;\n    static_assert(sizeof(record->depthCompare) >= sizeof(transfer->depthCompare), \"Deserialize assignment may not narrow.\");\nrecord->depthCompare = transfer->depthCompare;\n    static_assert(sizeof(record->stencilFront) == sizeof(transfer->stencilFront), \"Deserialize memcpy size must match.\");\nmemcpy(&record->stencilFront, const_cast<const WGPUStencilFaceStateTransfer*>(&transfer->stencilFront), sizeof(WGPUStencilFaceStateTransfer));\n    static_assert(sizeof(record->stencilBack) == sizeof(transfer->stencilBack), \"Deserialize memcpy size must match.\");\nmemcpy(&record->stencilBack, const_cast<const WGPUStencilFaceStateTransfer*>(&transfer->stencilBack), sizeof(WGPUStencilFaceStateTransfer));\n    static_assert(sizeof(record->stencilReadMask) >= sizeof(transfer->stencilReadMask), \"Deserialize assignment may not narrow.\");\nrecord->stencilReadMask = transfer->stencilReadMask;\n    static_assert(sizeof(record->stencilWriteMask) >= sizeof(transfer->stencilWriteMask), \"Deserialize assignment may not narrow.\");\nrecord->stencilWriteMask = transfer->stencilWriteMask;\n    static_assert(sizeof(record->depthBias) >= sizeof(transfer->depthBias), \"Deserialize assignment may not narrow.\");\nrecord->depthBias = transfer->depthBias;\n    static_assert(sizeof(record->depthBiasSlopeScale) >= sizeof(transfer->depthBiasSlopeScale), \"Deserialize assignment may not narrow.\");\nrecord->depthBiasSlopeScale = transfer->depthBiasSlopeScale;\n    static_assert(sizeof(record->depthBiasClamp) >= sizeof(transfer->depthBiasClamp), \"Deserialize assignment may not narrow.\");\nrecord->depthBiasClamp = transfer->depthBiasClamp;\n\n    record->nextInChain = nullptr;\n    if (transfer->hasNextInChain) {\n        WIRE_TRY(DeserializeChainedStruct(&record->nextInChain, deserializeBuffer, allocator, resolver));\n    }\n\n\n\n\n    return WireResult::Success;\n}\nDAWN_UNUSED_FUNC(WGPUDepthStencilStateDeserialize);\n\n                \nstruct WGPUImageCopyBufferTransfer {\n    static_assert(0 <= 1,\n                  \"Record must be at most one of is_cmd, extensible, and chained.\");\n    bool hasNextInChain;\n\n    WGPUTextureDataLayoutTransfer layout;\n    ObjectId buffer;\n\n\n};\n\n\n\nDAWN_DECLARE_UNUSED size_t WGPUImageCopyBufferGetExtraRequiredSize(const WGPUImageCopyBuffer& record) {\n    DAWN_UNUSED(record);\n\n    size_t result = 0;\n\n    if (record.nextInChain != nullptr) {\n        result += GetChainedStructExtraRequiredSize(record.nextInChain);\n    }\n\n\n    {\n        result += WGPUTextureDataLayoutGetExtraRequiredSize(record.layout);\n    }\n    {\n    }\n\n    return result;\n}\n// GetExtraRequiredSize isn't used for structures that are value members of other structures\n// because we assume they cannot contain pointers themselves.\nDAWN_UNUSED_FUNC(WGPUImageCopyBufferGetExtraRequiredSize);\n\nDAWN_DECLARE_UNUSED WireResult WGPUImageCopyBufferSerialize(\n    const WGPUImageCopyBuffer& record,\n    WGPUImageCopyBufferTransfer* transfer,\n    SerializeBuffer* buffer, const ObjectIdProvider& provider) {\n    DAWN_UNUSED(buffer);\n\n\n    WIRE_TRY(WGPUTextureDataLayoutSerialize(record.layout, &transfer->layout, buffer, provider));\n    WIRE_TRY(provider.GetId(record.buffer, &transfer->buffer));\n\n    if (record.nextInChain != nullptr) {\n        transfer->hasNextInChain = true;\n        WIRE_TRY(SerializeChainedStruct(record.nextInChain, buffer, provider));\n    } else {\n        transfer->hasNextInChain = false;\n    }\n\n\n\n    return WireResult::Success;\n}\nDAWN_UNUSED_FUNC(WGPUImageCopyBufferSerialize);\n\nDAWN_DECLARE_UNUSED WireResult WGPUImageCopyBufferDeserialize(\n    WGPUImageCopyBuffer* record,\n    const volatile WGPUImageCopyBufferTransfer* transfer,\n    DeserializeBuffer* deserializeBuffer,\n    DeserializeAllocator* allocator, const ObjectIdResolver& resolver) {\n    DAWN_UNUSED(allocator);\n\n\n\n    WIRE_TRY(WGPUTextureDataLayoutDeserialize(&record->layout, &transfer->layout, deserializeBuffer, allocator, resolver));\n    WIRE_TRY(resolver.GetFromId(transfer->buffer, &record->buffer));\n\n    record->nextInChain = nullptr;\n    if (transfer->hasNextInChain) {\n        WIRE_TRY(DeserializeChainedStruct(&record->nextInChain, deserializeBuffer, allocator, resolver));\n    }\n\n\n\n\n    return WireResult::Success;\n}\nDAWN_UNUSED_FUNC(WGPUImageCopyBufferDeserialize);\n\n                \nstruct WGPUImageCopyTextureTransfer {\n    static_assert(0 <= 1,\n                  \"Record must be at most one of is_cmd, extensible, and chained.\");\n    bool hasNextInChain;\n\n    ObjectId texture;\n    \nuint32_t mipLevel;\n    WGPUOrigin3DTransfer origin;\n    \nWGPUTextureAspect aspect;\n\n\n};\n\n\n\nDAWN_DECLARE_UNUSED size_t WGPUImageCopyTextureGetExtraRequiredSize(const WGPUImageCopyTexture& record) {\n    DAWN_UNUSED(record);\n\n    size_t result = 0;\n\n    if (record.nextInChain != nullptr) {\n        result += GetChainedStructExtraRequiredSize(record.nextInChain);\n    }\n\n\n    {\n    }\n    {\n    }\n    {\n        result += WGPUOrigin3DGetExtraRequiredSize(record.origin);\n    }\n    {\n    }\n\n    return result;\n}\n// GetExtraRequiredSize isn't used for structures that are value members of other structures\n// because we assume they cannot contain pointers themselves.\nDAWN_UNUSED_FUNC(WGPUImageCopyTextureGetExtraRequiredSize);\n\nDAWN_DECLARE_UNUSED WireResult WGPUImageCopyTextureSerialize(\n    const WGPUImageCopyTexture& record,\n    WGPUImageCopyTextureTransfer* transfer,\n    SerializeBuffer* buffer, const ObjectIdProvider& provider) {\n    DAWN_UNUSED(buffer);\n\n\n    WIRE_TRY(provider.GetId(record.texture, &transfer->texture));\n    transfer->mipLevel = record.mipLevel;\n    static_assert(sizeof(transfer->origin) == sizeof(record.origin), \"Serialize memcpy size must match.\");\nmemcpy(&transfer->origin, &record.origin, sizeof(WGPUOrigin3DTransfer));\n    transfer->aspect = record.aspect;\n\n    if (record.nextInChain != nullptr) {\n        transfer->hasNextInChain = true;\n        WIRE_TRY(SerializeChainedStruct(record.nextInChain, buffer, provider));\n    } else {\n        transfer->hasNextInChain = false;\n    }\n\n\n\n    return WireResult::Success;\n}\nDAWN_UNUSED_FUNC(WGPUImageCopyTextureSerialize);\n\nDAWN_DECLARE_UNUSED WireResult WGPUImageCopyTextureDeserialize(\n    WGPUImageCopyTexture* record,\n    const volatile WGPUImageCopyTextureTransfer* transfer,\n    DeserializeBuffer* deserializeBuffer,\n    DeserializeAllocator* allocator, const ObjectIdResolver& resolver) {\n    DAWN_UNUSED(allocator);\n\n\n\n    WIRE_TRY(resolver.GetFromId(transfer->texture, &record->texture));\n    static_assert(sizeof(record->mipLevel) >= sizeof(transfer->mipLevel), \"Deserialize assignment may not narrow.\");\nrecord->mipLevel = transfer->mipLevel;\n    static_assert(sizeof(record->origin) == sizeof(transfer->origin), \"Deserialize memcpy size must match.\");\nmemcpy(&record->origin, const_cast<const WGPUOrigin3DTransfer*>(&transfer->origin), sizeof(WGPUOrigin3DTransfer));\n    static_assert(sizeof(record->aspect) >= sizeof(transfer->aspect), \"Deserialize assignment may not narrow.\");\nrecord->aspect = transfer->aspect;\n\n    record->nextInChain = nullptr;\n    if (transfer->hasNextInChain) {\n        WIRE_TRY(DeserializeChainedStruct(&record->nextInChain, deserializeBuffer, allocator, resolver));\n    }\n\n\n\n\n    return WireResult::Success;\n}\nDAWN_UNUSED_FUNC(WGPUImageCopyTextureDeserialize);\n\n                \nstruct WGPUProgrammableStageDescriptorTransfer {\n    static_assert(0 <= 1,\n                  \"Record must be at most one of is_cmd, extensible, and chained.\");\n    bool hasNextInChain;\n\n    ObjectId module;\n    \nuint32_t constantCount;\n\n    uint64_t entryPointStrlen;\n\n};\n\n\n\nDAWN_DECLARE_UNUSED size_t WGPUProgrammableStageDescriptorGetExtraRequiredSize(const WGPUProgrammableStageDescriptor& record) {\n    DAWN_UNUSED(record);\n\n    size_t result = 0;\n\n    if (record.nextInChain != nullptr) {\n        result += GetChainedStructExtraRequiredSize(record.nextInChain);\n    }\n\n\n    {\n    result += std::strlen(record.entryPoint);\n    }\n\n    {\n    }\n    {\n    }\n    {\n        \n        auto memberLength = record.constantCount;\n        result += memberLength * sizeof(WGPUConstantEntryTransfer);\n        for (decltype(memberLength) i = 0; i < memberLength; ++i) {\n            \n            result += WGPUConstantEntryGetExtraRequiredSize(record.constants[i]);\n        }\n    }\n\n    return result;\n}\n// GetExtraRequiredSize isn't used for structures that are value members of other structures\n// because we assume they cannot contain pointers themselves.\nDAWN_UNUSED_FUNC(WGPUProgrammableStageDescriptorGetExtraRequiredSize);\n\nDAWN_DECLARE_UNUSED WireResult WGPUProgrammableStageDescriptorSerialize(\n    const WGPUProgrammableStageDescriptor& record,\n    WGPUProgrammableStageDescriptorTransfer* transfer,\n    SerializeBuffer* buffer, const ObjectIdProvider& provider) {\n    DAWN_UNUSED(buffer);\n\n\n    WIRE_TRY(provider.GetId(record.module, &transfer->module));\n    transfer->constantCount = record.constantCount;\n\n    if (record.nextInChain != nullptr) {\n        transfer->hasNextInChain = true;\n        WIRE_TRY(SerializeChainedStruct(record.nextInChain, buffer, provider));\n    } else {\n        transfer->hasNextInChain = false;\n    }\n\n\n\n    {\n        transfer->entryPointStrlen = std::strlen(record.entryPoint);\n\n        char* stringInBuffer;\n        WIRE_TRY(buffer->NextN(transfer->entryPointStrlen, &stringInBuffer));\n        memcpy(stringInBuffer, record.entryPoint, transfer->entryPointStrlen);\n    }\n\n    \n\n    {\n        auto memberLength = record.constantCount;\n\n        WGPUConstantEntryTransfer* memberBuffer;\n        WIRE_TRY(buffer->NextN(memberLength, &memberBuffer));\n\n        for (decltype(memberLength) i = 0; i < memberLength; ++i) {\n            WIRE_TRY(WGPUConstantEntrySerialize(record.constants[i], &memberBuffer[i], buffer, provider));\n        }\n    }\n    return WireResult::Success;\n}\nDAWN_UNUSED_FUNC(WGPUProgrammableStageDescriptorSerialize);\n\nDAWN_DECLARE_UNUSED WireResult WGPUProgrammableStageDescriptorDeserialize(\n    WGPUProgrammableStageDescriptor* record,\n    const volatile WGPUProgrammableStageDescriptorTransfer* transfer,\n    DeserializeBuffer* deserializeBuffer,\n    DeserializeAllocator* allocator, const ObjectIdResolver& resolver) {\n    DAWN_UNUSED(allocator);\n\n\n\n    WIRE_TRY(resolver.GetFromId(transfer->module, &record->module));\n    static_assert(sizeof(record->constantCount) >= sizeof(transfer->constantCount), \"Deserialize assignment may not narrow.\");\nrecord->constantCount = transfer->constantCount;\n\n    record->nextInChain = nullptr;\n    if (transfer->hasNextInChain) {\n        WIRE_TRY(DeserializeChainedStruct(&record->nextInChain, deserializeBuffer, allocator, resolver));\n    }\n\n\n\n    {\n        uint64_t stringLength64 = transfer->entryPointStrlen;\n        if (stringLength64 >= std::numeric_limits<size_t>::max()) {\n            return WireResult::FatalError;\n        }\n        size_t stringLength = static_cast<size_t>(stringLength64);\n\n        const volatile char* stringInBuffer;\n        WIRE_TRY(deserializeBuffer->ReadN(stringLength, &stringInBuffer));\n\n        char* copiedString;\n        WIRE_TRY(GetSpace(allocator, stringLength + 1, &copiedString));\n        memcpy(copiedString, const_cast<const char*>(stringInBuffer), stringLength);\n        copiedString[stringLength] = '\\0';\n        record->entryPoint = copiedString;\n    }\n\n    \n\n    {\n        auto memberLength = record->constantCount;\n        const volatile WGPUConstantEntryTransfer* memberBuffer;\n        WIRE_TRY(deserializeBuffer->ReadN(memberLength, &memberBuffer));\n\n        WGPUConstantEntry* copiedMembers;\n        WIRE_TRY(GetSpace(allocator, memberLength, &copiedMembers));\n        record->constants = copiedMembers;\n\n        for (decltype(memberLength) i = 0; i < memberLength; ++i) {\n            WIRE_TRY(WGPUConstantEntryDeserialize(&copiedMembers[i], &memberBuffer[i], deserializeBuffer, allocator, resolver));\n        }\n    }\n\n    return WireResult::Success;\n}\nDAWN_UNUSED_FUNC(WGPUProgrammableStageDescriptorDeserialize);\n\n                \nstruct WGPURenderPassColorAttachmentTransfer {\n    static_assert(0 <= 1,\n                  \"Record must be at most one of is_cmd, extensible, and chained.\");\n\n    ObjectId view;\n    ObjectId resolveTarget;\n    \nWGPULoadOp loadOp;\n    \nWGPUStoreOp storeOp;\n    WGPUColorTransfer clearColor;\n    WGPUColorTransfer clearValue;\n\n\n};\n\n\n\nDAWN_DECLARE_UNUSED size_t WGPURenderPassColorAttachmentGetExtraRequiredSize(const WGPURenderPassColorAttachment& record) {\n    DAWN_UNUSED(record);\n\n    size_t result = 0;\n\n\n\n    {\n    }\n    {\n    }\n    {\n    }\n    {\n    }\n    {\n        result += WGPUColorGetExtraRequiredSize(record.clearColor);\n    }\n    {\n        result += WGPUColorGetExtraRequiredSize(record.clearValue);\n    }\n\n    return result;\n}\n// GetExtraRequiredSize isn't used for structures that are value members of other structures\n// because we assume they cannot contain pointers themselves.\nDAWN_UNUSED_FUNC(WGPURenderPassColorAttachmentGetExtraRequiredSize);\n\nDAWN_DECLARE_UNUSED WireResult WGPURenderPassColorAttachmentSerialize(\n    const WGPURenderPassColorAttachment& record,\n    WGPURenderPassColorAttachmentTransfer* transfer,\n    SerializeBuffer* buffer, const ObjectIdProvider& provider) {\n    DAWN_UNUSED(buffer);\n\n\n    WIRE_TRY(provider.GetOptionalId(record.view, &transfer->view));\n    WIRE_TRY(provider.GetOptionalId(record.resolveTarget, &transfer->resolveTarget));\n    transfer->loadOp = record.loadOp;\n    transfer->storeOp = record.storeOp;\n    static_assert(sizeof(transfer->clearColor) == sizeof(record.clearColor), \"Serialize memcpy size must match.\");\nmemcpy(&transfer->clearColor, &record.clearColor, sizeof(WGPUColorTransfer));\n    static_assert(sizeof(transfer->clearValue) == sizeof(record.clearValue), \"Serialize memcpy size must match.\");\nmemcpy(&transfer->clearValue, &record.clearValue, sizeof(WGPUColorTransfer));\n\n\n\n\n    return WireResult::Success;\n}\nDAWN_UNUSED_FUNC(WGPURenderPassColorAttachmentSerialize);\n\nDAWN_DECLARE_UNUSED WireResult WGPURenderPassColorAttachmentDeserialize(\n    WGPURenderPassColorAttachment* record,\n    const volatile WGPURenderPassColorAttachmentTransfer* transfer,\n    DeserializeBuffer* deserializeBuffer,\n    DeserializeAllocator* allocator, const ObjectIdResolver& resolver) {\n    DAWN_UNUSED(allocator);\n\n\n\n    WIRE_TRY(resolver.GetOptionalFromId(transfer->view, &record->view));\n    WIRE_TRY(resolver.GetOptionalFromId(transfer->resolveTarget, &record->resolveTarget));\n    static_assert(sizeof(record->loadOp) >= sizeof(transfer->loadOp), \"Deserialize assignment may not narrow.\");\nrecord->loadOp = transfer->loadOp;\n    static_assert(sizeof(record->storeOp) >= sizeof(transfer->storeOp), \"Deserialize assignment may not narrow.\");\nrecord->storeOp = transfer->storeOp;\n    static_assert(sizeof(record->clearColor) == sizeof(transfer->clearColor), \"Deserialize memcpy size must match.\");\nmemcpy(&record->clearColor, const_cast<const WGPUColorTransfer*>(&transfer->clearColor), sizeof(WGPUColorTransfer));\n    static_assert(sizeof(record->clearValue) == sizeof(transfer->clearValue), \"Deserialize memcpy size must match.\");\nmemcpy(&record->clearValue, const_cast<const WGPUColorTransfer*>(&transfer->clearValue), sizeof(WGPUColorTransfer));\n\n\n\n\n\n    return WireResult::Success;\n}\nDAWN_UNUSED_FUNC(WGPURenderPassColorAttachmentDeserialize);\n\n                \nstruct WGPURequiredLimitsTransfer {\n    static_assert(0 <= 1,\n                  \"Record must be at most one of is_cmd, extensible, and chained.\");\n    bool hasNextInChain;\n\n    WGPULimitsTransfer limits;\n\n\n};\n\n\n\nDAWN_DECLARE_UNUSED size_t WGPURequiredLimitsGetExtraRequiredSize(const WGPURequiredLimits& record) {\n    DAWN_UNUSED(record);\n\n    size_t result = 0;\n\n    if (record.nextInChain != nullptr) {\n        result += GetChainedStructExtraRequiredSize(record.nextInChain);\n    }\n\n\n    {\n        result += WGPULimitsGetExtraRequiredSize(record.limits);\n    }\n\n    return result;\n}\n// GetExtraRequiredSize isn't used for structures that are value members of other structures\n// because we assume they cannot contain pointers themselves.\nDAWN_UNUSED_FUNC(WGPURequiredLimitsGetExtraRequiredSize);\n\nDAWN_DECLARE_UNUSED WireResult WGPURequiredLimitsSerialize(\n    const WGPURequiredLimits& record,\n    WGPURequiredLimitsTransfer* transfer,\n    SerializeBuffer* buffer, const ObjectIdProvider& provider) {\n    DAWN_UNUSED(buffer);\n\n\n    static_assert(sizeof(transfer->limits) == sizeof(record.limits), \"Serialize memcpy size must match.\");\nmemcpy(&transfer->limits, &record.limits, sizeof(WGPULimitsTransfer));\n\n    if (record.nextInChain != nullptr) {\n        transfer->hasNextInChain = true;\n        WIRE_TRY(SerializeChainedStruct(record.nextInChain, buffer, provider));\n    } else {\n        transfer->hasNextInChain = false;\n    }\n\n\n\n    return WireResult::Success;\n}\nDAWN_UNUSED_FUNC(WGPURequiredLimitsSerialize);\n\nDAWN_DECLARE_UNUSED WireResult WGPURequiredLimitsDeserialize(\n    WGPURequiredLimits* record,\n    const volatile WGPURequiredLimitsTransfer* transfer,\n    DeserializeBuffer* deserializeBuffer,\n    DeserializeAllocator* allocator, const ObjectIdResolver& resolver) {\n    DAWN_UNUSED(allocator);\n\n\n\n    static_assert(sizeof(record->limits) == sizeof(transfer->limits), \"Deserialize memcpy size must match.\");\nmemcpy(&record->limits, const_cast<const WGPULimitsTransfer*>(&transfer->limits), sizeof(WGPULimitsTransfer));\n\n    record->nextInChain = nullptr;\n    if (transfer->hasNextInChain) {\n        WIRE_TRY(DeserializeChainedStruct(&record->nextInChain, deserializeBuffer, allocator, resolver));\n    }\n\n\n\n\n    return WireResult::Success;\n}\nDAWN_UNUSED_FUNC(WGPURequiredLimitsDeserialize);\n\n                \nstruct WGPUSupportedLimitsTransfer {\n    static_assert(0 <= 1,\n                  \"Record must be at most one of is_cmd, extensible, and chained.\");\n    bool hasNextInChain;\n\n    WGPULimitsTransfer limits;\n\n\n};\n\n\n\nDAWN_DECLARE_UNUSED size_t WGPUSupportedLimitsGetExtraRequiredSize(const WGPUSupportedLimits& record) {\n    DAWN_UNUSED(record);\n\n    size_t result = 0;\n\n    if (record.nextInChain != nullptr) {\n        result += GetChainedStructExtraRequiredSize(record.nextInChain);\n    }\n\n\n    {\n        result += WGPULimitsGetExtraRequiredSize(record.limits);\n    }\n\n    return result;\n}\n// GetExtraRequiredSize isn't used for structures that are value members of other structures\n// because we assume they cannot contain pointers themselves.\nDAWN_UNUSED_FUNC(WGPUSupportedLimitsGetExtraRequiredSize);\n\nDAWN_DECLARE_UNUSED WireResult WGPUSupportedLimitsSerialize(\n    const WGPUSupportedLimits& record,\n    WGPUSupportedLimitsTransfer* transfer,\n    SerializeBuffer* buffer, const ObjectIdProvider& provider) {\n    DAWN_UNUSED(buffer);\n\n\n    static_assert(sizeof(transfer->limits) == sizeof(record.limits), \"Serialize memcpy size must match.\");\nmemcpy(&transfer->limits, &record.limits, sizeof(WGPULimitsTransfer));\n\n    if (record.nextInChain != nullptr) {\n        transfer->hasNextInChain = true;\n        WIRE_TRY(SerializeChainedStruct(record.nextInChain, buffer, provider));\n    } else {\n        transfer->hasNextInChain = false;\n    }\n\n\n\n    return WireResult::Success;\n}\nDAWN_UNUSED_FUNC(WGPUSupportedLimitsSerialize);\n\nDAWN_DECLARE_UNUSED WireResult WGPUSupportedLimitsDeserialize(\n    WGPUSupportedLimits* record,\n    const volatile WGPUSupportedLimitsTransfer* transfer,\n    DeserializeBuffer* deserializeBuffer,\n    DeserializeAllocator* allocator, const ObjectIdResolver& resolver) {\n    DAWN_UNUSED(allocator);\n\n\n\n    static_assert(sizeof(record->limits) == sizeof(transfer->limits), \"Deserialize memcpy size must match.\");\nmemcpy(&record->limits, const_cast<const WGPULimitsTransfer*>(&transfer->limits), sizeof(WGPULimitsTransfer));\n\n    record->nextInChain = nullptr;\n    if (transfer->hasNextInChain) {\n        WIRE_TRY(DeserializeChainedStruct(&record->nextInChain, deserializeBuffer, allocator, resolver));\n    }\n\n\n\n\n    return WireResult::Success;\n}\nDAWN_UNUSED_FUNC(WGPUSupportedLimitsDeserialize);\n\n                \nstruct WGPUTextureDescriptorTransfer {\n    static_assert(0 <= 1,\n                  \"Record must be at most one of is_cmd, extensible, and chained.\");\n    bool hasNextInChain;\n\n    WGPUTextureUsageFlags usage;\n    \nWGPUTextureDimension dimension;\n    WGPUExtent3DTransfer size;\n    \nWGPUTextureFormat format;\n    \nuint32_t mipLevelCount;\n    \nuint32_t sampleCount;\n    \nuint32_t viewFormatCount;\n\n    uint64_t labelStrlen;\n\n    bool has_label;\n};\n\n\n\nDAWN_DECLARE_UNUSED size_t WGPUTextureDescriptorGetExtraRequiredSize(const WGPUTextureDescriptor& record) {\n    DAWN_UNUSED(record);\n\n    size_t result = 0;\n\n    if (record.nextInChain != nullptr) {\n        result += GetChainedStructExtraRequiredSize(record.nextInChain);\n    }\n\n\n    bool has_label = record.label != nullptr;\n    if (has_label)\n    {\n    result += std::strlen(record.label);\n    }\n\n    {\n    }\n    {\n    }\n    {\n        result += WGPUExtent3DGetExtraRequiredSize(record.size);\n    }\n    {\n    }\n    {\n    }\n    {\n    }\n    {\n    }\n    {\n        \n        auto memberLength = record.viewFormatCount;\n        result += memberLength * sizeof(\nWGPUTextureFormat);\n    }\n\n    return result;\n}\n// GetExtraRequiredSize isn't used for structures that are value members of other structures\n// because we assume they cannot contain pointers themselves.\nDAWN_UNUSED_FUNC(WGPUTextureDescriptorGetExtraRequiredSize);\n\nDAWN_DECLARE_UNUSED WireResult WGPUTextureDescriptorSerialize(\n    const WGPUTextureDescriptor& record,\n    WGPUTextureDescriptorTransfer* transfer,\n    SerializeBuffer* buffer, const ObjectIdProvider& provider) {\n    DAWN_UNUSED(buffer);\n\n\n    transfer->usage = record.usage;\n    transfer->dimension = record.dimension;\n    static_assert(sizeof(transfer->size) == sizeof(record.size), \"Serialize memcpy size must match.\");\nmemcpy(&transfer->size, &record.size, sizeof(WGPUExtent3DTransfer));\n    transfer->format = record.format;\n    transfer->mipLevelCount = record.mipLevelCount;\n    transfer->sampleCount = record.sampleCount;\n    transfer->viewFormatCount = record.viewFormatCount;\n\n    if (record.nextInChain != nullptr) {\n        transfer->hasNextInChain = true;\n        WIRE_TRY(SerializeChainedStruct(record.nextInChain, buffer, provider));\n    } else {\n        transfer->hasNextInChain = false;\n    }\n\n\n\n    bool has_label = record.label != nullptr;\n    transfer->has_label = has_label;\n    if (has_label)\n    {\n        transfer->labelStrlen = std::strlen(record.label);\n\n        char* stringInBuffer;\n        WIRE_TRY(buffer->NextN(transfer->labelStrlen, &stringInBuffer));\n        memcpy(stringInBuffer, record.label, transfer->labelStrlen);\n    }\n\n    \n\n    {\n        auto memberLength = record.viewFormatCount;\n\n        \nWGPUTextureFormat* memberBuffer;\n        WIRE_TRY(buffer->NextN(memberLength, &memberBuffer));\n\n        memcpy(\n            memberBuffer, record.viewFormats,\n            sizeof(\nWGPUTextureFormat) * memberLength);\n    }\n    return WireResult::Success;\n}\nDAWN_UNUSED_FUNC(WGPUTextureDescriptorSerialize);\n\nDAWN_DECLARE_UNUSED WireResult WGPUTextureDescriptorDeserialize(\n    WGPUTextureDescriptor* record,\n    const volatile WGPUTextureDescriptorTransfer* transfer,\n    DeserializeBuffer* deserializeBuffer,\n    DeserializeAllocator* allocator, const ObjectIdResolver& resolver) {\n    DAWN_UNUSED(allocator);\n\n\n\n    static_assert(sizeof(record->usage) >= sizeof(transfer->usage), \"Deserialize assignment may not narrow.\");\nrecord->usage = transfer->usage;\n    static_assert(sizeof(record->dimension) >= sizeof(transfer->dimension), \"Deserialize assignment may not narrow.\");\nrecord->dimension = transfer->dimension;\n    static_assert(sizeof(record->size) == sizeof(transfer->size), \"Deserialize memcpy size must match.\");\nmemcpy(&record->size, const_cast<const WGPUExtent3DTransfer*>(&transfer->size), sizeof(WGPUExtent3DTransfer));\n    static_assert(sizeof(record->format) >= sizeof(transfer->format), \"Deserialize assignment may not narrow.\");\nrecord->format = transfer->format;\n    static_assert(sizeof(record->mipLevelCount) >= sizeof(transfer->mipLevelCount), \"Deserialize assignment may not narrow.\");\nrecord->mipLevelCount = transfer->mipLevelCount;\n    static_assert(sizeof(record->sampleCount) >= sizeof(transfer->sampleCount), \"Deserialize assignment may not narrow.\");\nrecord->sampleCount = transfer->sampleCount;\n    static_assert(sizeof(record->viewFormatCount) >= sizeof(transfer->viewFormatCount), \"Deserialize assignment may not narrow.\");\nrecord->viewFormatCount = transfer->viewFormatCount;\n\n    record->nextInChain = nullptr;\n    if (transfer->hasNextInChain) {\n        WIRE_TRY(DeserializeChainedStruct(&record->nextInChain, deserializeBuffer, allocator, resolver));\n    }\n\n\n\n    bool has_label = transfer->has_label;\n    record->label = nullptr;\n    if (has_label)\n    {\n        uint64_t stringLength64 = transfer->labelStrlen;\n        if (stringLength64 >= std::numeric_limits<size_t>::max()) {\n            return WireResult::FatalError;\n        }\n        size_t stringLength = static_cast<size_t>(stringLength64);\n\n        const volatile char* stringInBuffer;\n        WIRE_TRY(deserializeBuffer->ReadN(stringLength, &stringInBuffer));\n\n        char* copiedString;\n        WIRE_TRY(GetSpace(allocator, stringLength + 1, &copiedString));\n        memcpy(copiedString, const_cast<const char*>(stringInBuffer), stringLength);\n        copiedString[stringLength] = '\\0';\n        record->label = copiedString;\n    }\n\n    \n\n    {\n        auto memberLength = record->viewFormatCount;\n        const volatile \nWGPUTextureFormat* memberBuffer;\n        WIRE_TRY(deserializeBuffer->ReadN(memberLength, &memberBuffer));\n\n        WGPUTextureFormat* copiedMembers;\n        WIRE_TRY(GetSpace(allocator, memberLength, &copiedMembers));\n        record->viewFormats = copiedMembers;\n\n        memcpy(\n            copiedMembers,\n            const_cast<const \nWGPUTextureFormat*>(memberBuffer),\n           sizeof(\nWGPUTextureFormat) * memberLength);\n    }\n\n    return WireResult::Success;\n}\nDAWN_UNUSED_FUNC(WGPUTextureDescriptorDeserialize);\n\n                \nstruct WGPUVertexBufferLayoutTransfer {\n    static_assert(0 <= 1,\n                  \"Record must be at most one of is_cmd, extensible, and chained.\");\n\n    \nuint64_t arrayStride;\n    \nWGPUVertexStepMode stepMode;\n    \nuint32_t attributeCount;\n\n\n};\n\n\n\nDAWN_DECLARE_UNUSED size_t WGPUVertexBufferLayoutGetExtraRequiredSize(const WGPUVertexBufferLayout& record) {\n    DAWN_UNUSED(record);\n\n    size_t result = 0;\n\n\n\n    {\n    }\n    {\n    }\n    {\n    }\n    {\n        \n        auto memberLength = record.attributeCount;\n        result += memberLength * sizeof(WGPUVertexAttributeTransfer);\n        for (decltype(memberLength) i = 0; i < memberLength; ++i) {\n            \n            result += WGPUVertexAttributeGetExtraRequiredSize(record.attributes[i]);\n        }\n    }\n\n    return result;\n}\n// GetExtraRequiredSize isn't used for structures that are value members of other structures\n// because we assume they cannot contain pointers themselves.\nDAWN_UNUSED_FUNC(WGPUVertexBufferLayoutGetExtraRequiredSize);\n\nDAWN_DECLARE_UNUSED WireResult WGPUVertexBufferLayoutSerialize(\n    const WGPUVertexBufferLayout& record,\n    WGPUVertexBufferLayoutTransfer* transfer,\n    SerializeBuffer* buffer) {\n    DAWN_UNUSED(buffer);\n\n\n    transfer->arrayStride = record.arrayStride;\n    transfer->stepMode = record.stepMode;\n    transfer->attributeCount = record.attributeCount;\n\n\n\n\n    \n\n    {\n        auto memberLength = record.attributeCount;\n\n        WGPUVertexAttributeTransfer* memberBuffer;\n        WIRE_TRY(buffer->NextN(memberLength, &memberBuffer));\n\n        memcpy(\n            memberBuffer, record.attributes,\n            sizeof(WGPUVertexAttributeTransfer) * memberLength);\n    }\n    return WireResult::Success;\n}\nDAWN_UNUSED_FUNC(WGPUVertexBufferLayoutSerialize);\n\nDAWN_DECLARE_UNUSED WireResult WGPUVertexBufferLayoutDeserialize(\n    WGPUVertexBufferLayout* record,\n    const volatile WGPUVertexBufferLayoutTransfer* transfer,\n    DeserializeBuffer* deserializeBuffer,\n    DeserializeAllocator* allocator) {\n    DAWN_UNUSED(allocator);\n\n\n\n    static_assert(sizeof(record->arrayStride) >= sizeof(transfer->arrayStride), \"Deserialize assignment may not narrow.\");\nrecord->arrayStride = transfer->arrayStride;\n    static_assert(sizeof(record->stepMode) >= sizeof(transfer->stepMode), \"Deserialize assignment may not narrow.\");\nrecord->stepMode = transfer->stepMode;\n    static_assert(sizeof(record->attributeCount) >= sizeof(transfer->attributeCount), \"Deserialize assignment may not narrow.\");\nrecord->attributeCount = transfer->attributeCount;\n\n\n\n\n    \n\n    {\n        auto memberLength = record->attributeCount;\n        const volatile WGPUVertexAttributeTransfer* memberBuffer;\n        WIRE_TRY(deserializeBuffer->ReadN(memberLength, &memberBuffer));\n\n        WGPUVertexAttribute* copiedMembers;\n        WIRE_TRY(GetSpace(allocator, memberLength, &copiedMembers));\n        record->attributes = copiedMembers;\n\n        memcpy(\n            copiedMembers,\n            const_cast<const WGPUVertexAttributeTransfer*>(memberBuffer),\n           sizeof(WGPUVertexAttributeTransfer) * memberLength);\n    }\n\n    return WireResult::Success;\n}\nDAWN_UNUSED_FUNC(WGPUVertexBufferLayoutDeserialize);\n\n                \nstruct WGPUBindGroupLayoutDescriptorTransfer {\n    static_assert(0 <= 1,\n                  \"Record must be at most one of is_cmd, extensible, and chained.\");\n    bool hasNextInChain;\n\n    \nuint32_t entryCount;\n\n    uint64_t labelStrlen;\n\n    bool has_label;\n};\n\n\n\nDAWN_DECLARE_UNUSED size_t WGPUBindGroupLayoutDescriptorGetExtraRequiredSize(const WGPUBindGroupLayoutDescriptor& record) {\n    DAWN_UNUSED(record);\n\n    size_t result = 0;\n\n    if (record.nextInChain != nullptr) {\n        result += GetChainedStructExtraRequiredSize(record.nextInChain);\n    }\n\n\n    bool has_label = record.label != nullptr;\n    if (has_label)\n    {\n    result += std::strlen(record.label);\n    }\n\n    {\n    }\n    {\n        \n        auto memberLength = record.entryCount;\n        result += memberLength * sizeof(WGPUBindGroupLayoutEntryTransfer);\n        for (decltype(memberLength) i = 0; i < memberLength; ++i) {\n            \n            result += WGPUBindGroupLayoutEntryGetExtraRequiredSize(record.entries[i]);\n        }\n    }\n\n    return result;\n}\n// GetExtraRequiredSize isn't used for structures that are value members of other structures\n// because we assume they cannot contain pointers themselves.\nDAWN_UNUSED_FUNC(WGPUBindGroupLayoutDescriptorGetExtraRequiredSize);\n\nDAWN_DECLARE_UNUSED WireResult WGPUBindGroupLayoutDescriptorSerialize(\n    const WGPUBindGroupLayoutDescriptor& record,\n    WGPUBindGroupLayoutDescriptorTransfer* transfer,\n    SerializeBuffer* buffer, const ObjectIdProvider& provider) {\n    DAWN_UNUSED(buffer);\n\n\n    transfer->entryCount = record.entryCount;\n\n    if (record.nextInChain != nullptr) {\n        transfer->hasNextInChain = true;\n        WIRE_TRY(SerializeChainedStruct(record.nextInChain, buffer, provider));\n    } else {\n        transfer->hasNextInChain = false;\n    }\n\n\n\n    bool has_label = record.label != nullptr;\n    transfer->has_label = has_label;\n    if (has_label)\n    {\n        transfer->labelStrlen = std::strlen(record.label);\n\n        char* stringInBuffer;\n        WIRE_TRY(buffer->NextN(transfer->labelStrlen, &stringInBuffer));\n        memcpy(stringInBuffer, record.label, transfer->labelStrlen);\n    }\n\n    \n\n    {\n        auto memberLength = record.entryCount;\n\n        WGPUBindGroupLayoutEntryTransfer* memberBuffer;\n        WIRE_TRY(buffer->NextN(memberLength, &memberBuffer));\n\n        for (decltype(memberLength) i = 0; i < memberLength; ++i) {\n            WIRE_TRY(WGPUBindGroupLayoutEntrySerialize(record.entries[i], &memberBuffer[i], buffer, provider));\n        }\n    }\n    return WireResult::Success;\n}\nDAWN_UNUSED_FUNC(WGPUBindGroupLayoutDescriptorSerialize);\n\nDAWN_DECLARE_UNUSED WireResult WGPUBindGroupLayoutDescriptorDeserialize(\n    WGPUBindGroupLayoutDescriptor* record,\n    const volatile WGPUBindGroupLayoutDescriptorTransfer* transfer,\n    DeserializeBuffer* deserializeBuffer,\n    DeserializeAllocator* allocator, const ObjectIdResolver& resolver) {\n    DAWN_UNUSED(allocator);\n\n\n\n    static_assert(sizeof(record->entryCount) >= sizeof(transfer->entryCount), \"Deserialize assignment may not narrow.\");\nrecord->entryCount = transfer->entryCount;\n\n    record->nextInChain = nullptr;\n    if (transfer->hasNextInChain) {\n        WIRE_TRY(DeserializeChainedStruct(&record->nextInChain, deserializeBuffer, allocator, resolver));\n    }\n\n\n\n    bool has_label = transfer->has_label;\n    record->label = nullptr;\n    if (has_label)\n    {\n        uint64_t stringLength64 = transfer->labelStrlen;\n        if (stringLength64 >= std::numeric_limits<size_t>::max()) {\n            return WireResult::FatalError;\n        }\n        size_t stringLength = static_cast<size_t>(stringLength64);\n\n        const volatile char* stringInBuffer;\n        WIRE_TRY(deserializeBuffer->ReadN(stringLength, &stringInBuffer));\n\n        char* copiedString;\n        WIRE_TRY(GetSpace(allocator, stringLength + 1, &copiedString));\n        memcpy(copiedString, const_cast<const char*>(stringInBuffer), stringLength);\n        copiedString[stringLength] = '\\0';\n        record->label = copiedString;\n    }\n\n    \n\n    {\n        auto memberLength = record->entryCount;\n        const volatile WGPUBindGroupLayoutEntryTransfer* memberBuffer;\n        WIRE_TRY(deserializeBuffer->ReadN(memberLength, &memberBuffer));\n\n        WGPUBindGroupLayoutEntry* copiedMembers;\n        WIRE_TRY(GetSpace(allocator, memberLength, &copiedMembers));\n        record->entries = copiedMembers;\n\n        for (decltype(memberLength) i = 0; i < memberLength; ++i) {\n            WIRE_TRY(WGPUBindGroupLayoutEntryDeserialize(&copiedMembers[i], &memberBuffer[i], deserializeBuffer, allocator, resolver));\n        }\n    }\n\n    return WireResult::Success;\n}\nDAWN_UNUSED_FUNC(WGPUBindGroupLayoutDescriptorDeserialize);\n\n                \nstruct WGPUColorTargetStateTransfer {\n    static_assert(0 <= 1,\n                  \"Record must be at most one of is_cmd, extensible, and chained.\");\n    bool hasNextInChain;\n\n    \nWGPUTextureFormat format;\n    WGPUColorWriteMaskFlags writeMask;\n\n\n    bool has_blend;\n};\n\n\n\nDAWN_DECLARE_UNUSED size_t WGPUColorTargetStateGetExtraRequiredSize(const WGPUColorTargetState& record) {\n    DAWN_UNUSED(record);\n\n    size_t result = 0;\n\n    if (record.nextInChain != nullptr) {\n        result += GetChainedStructExtraRequiredSize(record.nextInChain);\n    }\n\n\n    {\n    }\n    if (record.blend != nullptr)\n    {\n        \n        auto memberLength = 1u;\n        result += memberLength * sizeof(WGPUBlendStateTransfer);\n        for (decltype(memberLength) i = 0; i < memberLength; ++i) {\n            \n            result += WGPUBlendStateGetExtraRequiredSize(record.blend[i]);\n        }\n    }\n    {\n    }\n\n    return result;\n}\n// GetExtraRequiredSize isn't used for structures that are value members of other structures\n// because we assume they cannot contain pointers themselves.\nDAWN_UNUSED_FUNC(WGPUColorTargetStateGetExtraRequiredSize);\n\nDAWN_DECLARE_UNUSED WireResult WGPUColorTargetStateSerialize(\n    const WGPUColorTargetState& record,\n    WGPUColorTargetStateTransfer* transfer,\n    SerializeBuffer* buffer, const ObjectIdProvider& provider) {\n    DAWN_UNUSED(buffer);\n\n\n    transfer->format = record.format;\n    transfer->writeMask = record.writeMask;\n\n    if (record.nextInChain != nullptr) {\n        transfer->hasNextInChain = true;\n        WIRE_TRY(SerializeChainedStruct(record.nextInChain, buffer, provider));\n    } else {\n        transfer->hasNextInChain = false;\n    }\n\n\n\n    \n\n    bool has_blend = record.blend != nullptr;\n    transfer->has_blend = has_blend;\n    if (has_blend)\n    {\n        auto memberLength = 1u;\n\n        WGPUBlendStateTransfer* memberBuffer;\n        WIRE_TRY(buffer->NextN(memberLength, &memberBuffer));\n\n        memcpy(\n            memberBuffer, record.blend,\n            sizeof(WGPUBlendStateTransfer) * memberLength);\n    }\n    return WireResult::Success;\n}\nDAWN_UNUSED_FUNC(WGPUColorTargetStateSerialize);\n\nDAWN_DECLARE_UNUSED WireResult WGPUColorTargetStateDeserialize(\n    WGPUColorTargetState* record,\n    const volatile WGPUColorTargetStateTransfer* transfer,\n    DeserializeBuffer* deserializeBuffer,\n    DeserializeAllocator* allocator, const ObjectIdResolver& resolver) {\n    DAWN_UNUSED(allocator);\n\n\n\n    static_assert(sizeof(record->format) >= sizeof(transfer->format), \"Deserialize assignment may not narrow.\");\nrecord->format = transfer->format;\n    static_assert(sizeof(record->writeMask) >= sizeof(transfer->writeMask), \"Deserialize assignment may not narrow.\");\nrecord->writeMask = transfer->writeMask;\n\n    record->nextInChain = nullptr;\n    if (transfer->hasNextInChain) {\n        WIRE_TRY(DeserializeChainedStruct(&record->nextInChain, deserializeBuffer, allocator, resolver));\n    }\n\n\n\n    \n\n    \n    bool has_blend = transfer->has_blend;\n    record->blend = nullptr;\n    if (has_blend)\n    {\n        auto memberLength = 1u;\n        const volatile WGPUBlendStateTransfer* memberBuffer;\n        WIRE_TRY(deserializeBuffer->ReadN(memberLength, &memberBuffer));\n\n        WGPUBlendState* copiedMembers;\n        WIRE_TRY(GetSpace(allocator, memberLength, &copiedMembers));\n        record->blend = copiedMembers;\n\n        memcpy(\n            copiedMembers,\n            const_cast<const WGPUBlendStateTransfer*>(memberBuffer),\n           sizeof(WGPUBlendStateTransfer) * memberLength);\n    }\n\n    return WireResult::Success;\n}\nDAWN_UNUSED_FUNC(WGPUColorTargetStateDeserialize);\n\n                \nstruct WGPUComputePipelineDescriptorTransfer {\n    static_assert(0 <= 1,\n                  \"Record must be at most one of is_cmd, extensible, and chained.\");\n    bool hasNextInChain;\n\n    ObjectId layout;\n    WGPUProgrammableStageDescriptorTransfer compute;\n\n    uint64_t labelStrlen;\n\n    bool has_label;\n};\n\n\n\nDAWN_DECLARE_UNUSED size_t WGPUComputePipelineDescriptorGetExtraRequiredSize(const WGPUComputePipelineDescriptor& record) {\n    DAWN_UNUSED(record);\n\n    size_t result = 0;\n\n    if (record.nextInChain != nullptr) {\n        result += GetChainedStructExtraRequiredSize(record.nextInChain);\n    }\n\n\n    bool has_label = record.label != nullptr;\n    if (has_label)\n    {\n    result += std::strlen(record.label);\n    }\n\n    {\n    }\n    {\n        result += WGPUProgrammableStageDescriptorGetExtraRequiredSize(record.compute);\n    }\n\n    return result;\n}\n// GetExtraRequiredSize isn't used for structures that are value members of other structures\n// because we assume they cannot contain pointers themselves.\nDAWN_UNUSED_FUNC(WGPUComputePipelineDescriptorGetExtraRequiredSize);\n\nDAWN_DECLARE_UNUSED WireResult WGPUComputePipelineDescriptorSerialize(\n    const WGPUComputePipelineDescriptor& record,\n    WGPUComputePipelineDescriptorTransfer* transfer,\n    SerializeBuffer* buffer, const ObjectIdProvider& provider) {\n    DAWN_UNUSED(buffer);\n\n\n    WIRE_TRY(provider.GetOptionalId(record.layout, &transfer->layout));\n    WIRE_TRY(WGPUProgrammableStageDescriptorSerialize(record.compute, &transfer->compute, buffer, provider));\n\n    if (record.nextInChain != nullptr) {\n        transfer->hasNextInChain = true;\n        WIRE_TRY(SerializeChainedStruct(record.nextInChain, buffer, provider));\n    } else {\n        transfer->hasNextInChain = false;\n    }\n\n\n\n    bool has_label = record.label != nullptr;\n    transfer->has_label = has_label;\n    if (has_label)\n    {\n        transfer->labelStrlen = std::strlen(record.label);\n\n        char* stringInBuffer;\n        WIRE_TRY(buffer->NextN(transfer->labelStrlen, &stringInBuffer));\n        memcpy(stringInBuffer, record.label, transfer->labelStrlen);\n    }\n\n    return WireResult::Success;\n}\nDAWN_UNUSED_FUNC(WGPUComputePipelineDescriptorSerialize);\n\nDAWN_DECLARE_UNUSED WireResult WGPUComputePipelineDescriptorDeserialize(\n    WGPUComputePipelineDescriptor* record,\n    const volatile WGPUComputePipelineDescriptorTransfer* transfer,\n    DeserializeBuffer* deserializeBuffer,\n    DeserializeAllocator* allocator, const ObjectIdResolver& resolver) {\n    DAWN_UNUSED(allocator);\n\n\n\n    WIRE_TRY(resolver.GetOptionalFromId(transfer->layout, &record->layout));\n    WIRE_TRY(WGPUProgrammableStageDescriptorDeserialize(&record->compute, &transfer->compute, deserializeBuffer, allocator, resolver));\n\n    record->nextInChain = nullptr;\n    if (transfer->hasNextInChain) {\n        WIRE_TRY(DeserializeChainedStruct(&record->nextInChain, deserializeBuffer, allocator, resolver));\n    }\n\n\n\n    bool has_label = transfer->has_label;\n    record->label = nullptr;\n    if (has_label)\n    {\n        uint64_t stringLength64 = transfer->labelStrlen;\n        if (stringLength64 >= std::numeric_limits<size_t>::max()) {\n            return WireResult::FatalError;\n        }\n        size_t stringLength = static_cast<size_t>(stringLength64);\n\n        const volatile char* stringInBuffer;\n        WIRE_TRY(deserializeBuffer->ReadN(stringLength, &stringInBuffer));\n\n        char* copiedString;\n        WIRE_TRY(GetSpace(allocator, stringLength + 1, &copiedString));\n        memcpy(copiedString, const_cast<const char*>(stringInBuffer), stringLength);\n        copiedString[stringLength] = '\\0';\n        record->label = copiedString;\n    }\n\n\n    return WireResult::Success;\n}\nDAWN_UNUSED_FUNC(WGPUComputePipelineDescriptorDeserialize);\n\n                \nstruct WGPUDeviceDescriptorTransfer {\n    static_assert(0 <= 1,\n                  \"Record must be at most one of is_cmd, extensible, and chained.\");\n    bool hasNextInChain;\n\n    \nuint32_t requiredFeaturesCount;\n    WGPUQueueDescriptorTransfer defaultQueue;\n\n    uint64_t labelStrlen;\n\n    bool has_label;\n    bool has_requiredLimits;\n};\n\n\n\nDAWN_DECLARE_UNUSED size_t WGPUDeviceDescriptorGetExtraRequiredSize(const WGPUDeviceDescriptor& record) {\n    DAWN_UNUSED(record);\n\n    size_t result = 0;\n\n    if (record.nextInChain != nullptr) {\n        result += GetChainedStructExtraRequiredSize(record.nextInChain);\n    }\n\n\n    bool has_label = record.label != nullptr;\n    if (has_label)\n    {\n    result += std::strlen(record.label);\n    }\n\n    {\n    }\n    {\n        \n        auto memberLength = record.requiredFeaturesCount;\n        result += memberLength * sizeof(\nWGPUFeatureName);\n    }\n    if (record.requiredLimits != nullptr)\n    {\n        \n        auto memberLength = 1u;\n        result += memberLength * sizeof(WGPURequiredLimitsTransfer);\n        for (decltype(memberLength) i = 0; i < memberLength; ++i) {\n            \n            result += WGPURequiredLimitsGetExtraRequiredSize(record.requiredLimits[i]);\n        }\n    }\n    {\n        result += WGPUQueueDescriptorGetExtraRequiredSize(record.defaultQueue);\n    }\n\n    return result;\n}\n// GetExtraRequiredSize isn't used for structures that are value members of other structures\n// because we assume they cannot contain pointers themselves.\nDAWN_UNUSED_FUNC(WGPUDeviceDescriptorGetExtraRequiredSize);\n\nDAWN_DECLARE_UNUSED WireResult WGPUDeviceDescriptorSerialize(\n    const WGPUDeviceDescriptor& record,\n    WGPUDeviceDescriptorTransfer* transfer,\n    SerializeBuffer* buffer, const ObjectIdProvider& provider) {\n    DAWN_UNUSED(buffer);\n\n\n    transfer->requiredFeaturesCount = record.requiredFeaturesCount;\n    WIRE_TRY(WGPUQueueDescriptorSerialize(record.defaultQueue, &transfer->defaultQueue, buffer, provider));\n\n    if (record.nextInChain != nullptr) {\n        transfer->hasNextInChain = true;\n        WIRE_TRY(SerializeChainedStruct(record.nextInChain, buffer, provider));\n    } else {\n        transfer->hasNextInChain = false;\n    }\n\n\n\n    bool has_label = record.label != nullptr;\n    transfer->has_label = has_label;\n    if (has_label)\n    {\n        transfer->labelStrlen = std::strlen(record.label);\n\n        char* stringInBuffer;\n        WIRE_TRY(buffer->NextN(transfer->labelStrlen, &stringInBuffer));\n        memcpy(stringInBuffer, record.label, transfer->labelStrlen);\n    }\n\n    \n\n    {\n        auto memberLength = record.requiredFeaturesCount;\n\n        \nWGPUFeatureName* memberBuffer;\n        WIRE_TRY(buffer->NextN(memberLength, &memberBuffer));\n\n        memcpy(\n            memberBuffer, record.requiredFeatures,\n            sizeof(\nWGPUFeatureName) * memberLength);\n    }\n    \n\n    bool has_requiredLimits = record.requiredLimits != nullptr;\n    transfer->has_requiredLimits = has_requiredLimits;\n    if (has_requiredLimits)\n    {\n        auto memberLength = 1u;\n\n        WGPURequiredLimitsTransfer* memberBuffer;\n        WIRE_TRY(buffer->NextN(memberLength, &memberBuffer));\n\n        for (decltype(memberLength) i = 0; i < memberLength; ++i) {\n            WIRE_TRY(WGPURequiredLimitsSerialize(record.requiredLimits[i], &memberBuffer[i], buffer, provider));\n        }\n    }\n    return WireResult::Success;\n}\nDAWN_UNUSED_FUNC(WGPUDeviceDescriptorSerialize);\n\nDAWN_DECLARE_UNUSED WireResult WGPUDeviceDescriptorDeserialize(\n    WGPUDeviceDescriptor* record,\n    const volatile WGPUDeviceDescriptorTransfer* transfer,\n    DeserializeBuffer* deserializeBuffer,\n    DeserializeAllocator* allocator, const ObjectIdResolver& resolver) {\n    DAWN_UNUSED(allocator);\n\n\n\n    static_assert(sizeof(record->requiredFeaturesCount) >= sizeof(transfer->requiredFeaturesCount), \"Deserialize assignment may not narrow.\");\nrecord->requiredFeaturesCount = transfer->requiredFeaturesCount;\n    WIRE_TRY(WGPUQueueDescriptorDeserialize(&record->defaultQueue, &transfer->defaultQueue, deserializeBuffer, allocator, resolver));\n\n    record->nextInChain = nullptr;\n    if (transfer->hasNextInChain) {\n        WIRE_TRY(DeserializeChainedStruct(&record->nextInChain, deserializeBuffer, allocator, resolver));\n    }\n\n\n\n    bool has_label = transfer->has_label;\n    record->label = nullptr;\n    if (has_label)\n    {\n        uint64_t stringLength64 = transfer->labelStrlen;\n        if (stringLength64 >= std::numeric_limits<size_t>::max()) {\n            return WireResult::FatalError;\n        }\n        size_t stringLength = static_cast<size_t>(stringLength64);\n\n        const volatile char* stringInBuffer;\n        WIRE_TRY(deserializeBuffer->ReadN(stringLength, &stringInBuffer));\n\n        char* copiedString;\n        WIRE_TRY(GetSpace(allocator, stringLength + 1, &copiedString));\n        memcpy(copiedString, const_cast<const char*>(stringInBuffer), stringLength);\n        copiedString[stringLength] = '\\0';\n        record->label = copiedString;\n    }\n\n    \n\n    {\n        auto memberLength = record->requiredFeaturesCount;\n        const volatile \nWGPUFeatureName* memberBuffer;\n        WIRE_TRY(deserializeBuffer->ReadN(memberLength, &memberBuffer));\n\n        WGPUFeatureName* copiedMembers;\n        WIRE_TRY(GetSpace(allocator, memberLength, &copiedMembers));\n        record->requiredFeatures = copiedMembers;\n\n        memcpy(\n            copiedMembers,\n            const_cast<const \nWGPUFeatureName*>(memberBuffer),\n           sizeof(\nWGPUFeatureName) * memberLength);\n    }\n    \n\n    \n    bool has_requiredLimits = transfer->has_requiredLimits;\n    record->requiredLimits = nullptr;\n    if (has_requiredLimits)\n    {\n        auto memberLength = 1u;\n        const volatile WGPURequiredLimitsTransfer* memberBuffer;\n        WIRE_TRY(deserializeBuffer->ReadN(memberLength, &memberBuffer));\n\n        WGPURequiredLimits* copiedMembers;\n        WIRE_TRY(GetSpace(allocator, memberLength, &copiedMembers));\n        record->requiredLimits = copiedMembers;\n\n        for (decltype(memberLength) i = 0; i < memberLength; ++i) {\n            WIRE_TRY(WGPURequiredLimitsDeserialize(&copiedMembers[i], &memberBuffer[i], deserializeBuffer, allocator, resolver));\n        }\n    }\n\n    return WireResult::Success;\n}\nDAWN_UNUSED_FUNC(WGPUDeviceDescriptorDeserialize);\n\n                \nstruct WGPURenderPassDescriptorTransfer {\n    static_assert(0 <= 1,\n                  \"Record must be at most one of is_cmd, extensible, and chained.\");\n    bool hasNextInChain;\n\n    \nuint32_t colorAttachmentCount;\n    ObjectId occlusionQuerySet;\n    \nuint32_t timestampWriteCount;\n\n    uint64_t labelStrlen;\n\n    bool has_label;\n    bool has_depthStencilAttachment;\n};\n\n\n\nDAWN_DECLARE_UNUSED size_t WGPURenderPassDescriptorGetExtraRequiredSize(const WGPURenderPassDescriptor& record) {\n    DAWN_UNUSED(record);\n\n    size_t result = 0;\n\n    if (record.nextInChain != nullptr) {\n        result += GetChainedStructExtraRequiredSize(record.nextInChain);\n    }\n\n\n    bool has_label = record.label != nullptr;\n    if (has_label)\n    {\n    result += std::strlen(record.label);\n    }\n\n    {\n    }\n    {\n        \n        auto memberLength = record.colorAttachmentCount;\n        result += memberLength * sizeof(WGPURenderPassColorAttachmentTransfer);\n        for (decltype(memberLength) i = 0; i < memberLength; ++i) {\n            \n            result += WGPURenderPassColorAttachmentGetExtraRequiredSize(record.colorAttachments[i]);\n        }\n    }\n    if (record.depthStencilAttachment != nullptr)\n    {\n        \n        auto memberLength = 1u;\n        result += memberLength * sizeof(WGPURenderPassDepthStencilAttachmentTransfer);\n        for (decltype(memberLength) i = 0; i < memberLength; ++i) {\n            \n            result += WGPURenderPassDepthStencilAttachmentGetExtraRequiredSize(record.depthStencilAttachment[i]);\n        }\n    }\n    {\n    }\n    {\n    }\n    {\n        \n        auto memberLength = record.timestampWriteCount;\n        result += memberLength * sizeof(WGPURenderPassTimestampWriteTransfer);\n        for (decltype(memberLength) i = 0; i < memberLength; ++i) {\n            \n            result += WGPURenderPassTimestampWriteGetExtraRequiredSize(record.timestampWrites[i]);\n        }\n    }\n\n    return result;\n}\n// GetExtraRequiredSize isn't used for structures that are value members of other structures\n// because we assume they cannot contain pointers themselves.\nDAWN_UNUSED_FUNC(WGPURenderPassDescriptorGetExtraRequiredSize);\n\nDAWN_DECLARE_UNUSED WireResult WGPURenderPassDescriptorSerialize(\n    const WGPURenderPassDescriptor& record,\n    WGPURenderPassDescriptorTransfer* transfer,\n    SerializeBuffer* buffer, const ObjectIdProvider& provider) {\n    DAWN_UNUSED(buffer);\n\n\n    transfer->colorAttachmentCount = record.colorAttachmentCount;\n    WIRE_TRY(provider.GetOptionalId(record.occlusionQuerySet, &transfer->occlusionQuerySet));\n    transfer->timestampWriteCount = record.timestampWriteCount;\n\n    if (record.nextInChain != nullptr) {\n        transfer->hasNextInChain = true;\n        WIRE_TRY(SerializeChainedStruct(record.nextInChain, buffer, provider));\n    } else {\n        transfer->hasNextInChain = false;\n    }\n\n\n\n    bool has_label = record.label != nullptr;\n    transfer->has_label = has_label;\n    if (has_label)\n    {\n        transfer->labelStrlen = std::strlen(record.label);\n\n        char* stringInBuffer;\n        WIRE_TRY(buffer->NextN(transfer->labelStrlen, &stringInBuffer));\n        memcpy(stringInBuffer, record.label, transfer->labelStrlen);\n    }\n\n    \n\n    {\n        auto memberLength = record.colorAttachmentCount;\n\n        WGPURenderPassColorAttachmentTransfer* memberBuffer;\n        WIRE_TRY(buffer->NextN(memberLength, &memberBuffer));\n\n        for (decltype(memberLength) i = 0; i < memberLength; ++i) {\n            WIRE_TRY(WGPURenderPassColorAttachmentSerialize(record.colorAttachments[i], &memberBuffer[i], buffer, provider));\n        }\n    }\n    \n\n    bool has_depthStencilAttachment = record.depthStencilAttachment != nullptr;\n    transfer->has_depthStencilAttachment = has_depthStencilAttachment;\n    if (has_depthStencilAttachment)\n    {\n        auto memberLength = 1u;\n\n        WGPURenderPassDepthStencilAttachmentTransfer* memberBuffer;\n        WIRE_TRY(buffer->NextN(memberLength, &memberBuffer));\n\n        for (decltype(memberLength) i = 0; i < memberLength; ++i) {\n            WIRE_TRY(WGPURenderPassDepthStencilAttachmentSerialize(record.depthStencilAttachment[i], &memberBuffer[i], buffer, provider));\n        }\n    }\n    \n\n    {\n        auto memberLength = record.timestampWriteCount;\n\n        WGPURenderPassTimestampWriteTransfer* memberBuffer;\n        WIRE_TRY(buffer->NextN(memberLength, &memberBuffer));\n\n        for (decltype(memberLength) i = 0; i < memberLength; ++i) {\n            WIRE_TRY(WGPURenderPassTimestampWriteSerialize(record.timestampWrites[i], &memberBuffer[i], buffer, provider));\n        }\n    }\n    return WireResult::Success;\n}\nDAWN_UNUSED_FUNC(WGPURenderPassDescriptorSerialize);\n\nDAWN_DECLARE_UNUSED WireResult WGPURenderPassDescriptorDeserialize(\n    WGPURenderPassDescriptor* record,\n    const volatile WGPURenderPassDescriptorTransfer* transfer,\n    DeserializeBuffer* deserializeBuffer,\n    DeserializeAllocator* allocator, const ObjectIdResolver& resolver) {\n    DAWN_UNUSED(allocator);\n\n\n\n    static_assert(sizeof(record->colorAttachmentCount) >= sizeof(transfer->colorAttachmentCount), \"Deserialize assignment may not narrow.\");\nrecord->colorAttachmentCount = transfer->colorAttachmentCount;\n    WIRE_TRY(resolver.GetOptionalFromId(transfer->occlusionQuerySet, &record->occlusionQuerySet));\n    static_assert(sizeof(record->timestampWriteCount) >= sizeof(transfer->timestampWriteCount), \"Deserialize assignment may not narrow.\");\nrecord->timestampWriteCount = transfer->timestampWriteCount;\n\n    record->nextInChain = nullptr;\n    if (transfer->hasNextInChain) {\n        WIRE_TRY(DeserializeChainedStruct(&record->nextInChain, deserializeBuffer, allocator, resolver));\n    }\n\n\n\n    bool has_label = transfer->has_label;\n    record->label = nullptr;\n    if (has_label)\n    {\n        uint64_t stringLength64 = transfer->labelStrlen;\n        if (stringLength64 >= std::numeric_limits<size_t>::max()) {\n            return WireResult::FatalError;\n        }\n        size_t stringLength = static_cast<size_t>(stringLength64);\n\n        const volatile char* stringInBuffer;\n        WIRE_TRY(deserializeBuffer->ReadN(stringLength, &stringInBuffer));\n\n        char* copiedString;\n        WIRE_TRY(GetSpace(allocator, stringLength + 1, &copiedString));\n        memcpy(copiedString, const_cast<const char*>(stringInBuffer), stringLength);\n        copiedString[stringLength] = '\\0';\n        record->label = copiedString;\n    }\n\n    \n\n    {\n        auto memberLength = record->colorAttachmentCount;\n        const volatile WGPURenderPassColorAttachmentTransfer* memberBuffer;\n        WIRE_TRY(deserializeBuffer->ReadN(memberLength, &memberBuffer));\n\n        WGPURenderPassColorAttachment* copiedMembers;\n        WIRE_TRY(GetSpace(allocator, memberLength, &copiedMembers));\n        record->colorAttachments = copiedMembers;\n\n        for (decltype(memberLength) i = 0; i < memberLength; ++i) {\n            WIRE_TRY(WGPURenderPassColorAttachmentDeserialize(&copiedMembers[i], &memberBuffer[i], deserializeBuffer, allocator, resolver));\n        }\n    }\n    \n\n    \n    bool has_depthStencilAttachment = transfer->has_depthStencilAttachment;\n    record->depthStencilAttachment = nullptr;\n    if (has_depthStencilAttachment)\n    {\n        auto memberLength = 1u;\n        const volatile WGPURenderPassDepthStencilAttachmentTransfer* memberBuffer;\n        WIRE_TRY(deserializeBuffer->ReadN(memberLength, &memberBuffer));\n\n        WGPURenderPassDepthStencilAttachment* copiedMembers;\n        WIRE_TRY(GetSpace(allocator, memberLength, &copiedMembers));\n        record->depthStencilAttachment = copiedMembers;\n\n        for (decltype(memberLength) i = 0; i < memberLength; ++i) {\n            WIRE_TRY(WGPURenderPassDepthStencilAttachmentDeserialize(&copiedMembers[i], &memberBuffer[i], deserializeBuffer, allocator, resolver));\n        }\n    }\n    \n\n    {\n        auto memberLength = record->timestampWriteCount;\n        const volatile WGPURenderPassTimestampWriteTransfer* memberBuffer;\n        WIRE_TRY(deserializeBuffer->ReadN(memberLength, &memberBuffer));\n\n        WGPURenderPassTimestampWrite* copiedMembers;\n        WIRE_TRY(GetSpace(allocator, memberLength, &copiedMembers));\n        record->timestampWrites = copiedMembers;\n\n        for (decltype(memberLength) i = 0; i < memberLength; ++i) {\n            WIRE_TRY(WGPURenderPassTimestampWriteDeserialize(&copiedMembers[i], &memberBuffer[i], deserializeBuffer, allocator, resolver));\n        }\n    }\n\n    return WireResult::Success;\n}\nDAWN_UNUSED_FUNC(WGPURenderPassDescriptorDeserialize);\n\n                \nstruct WGPUVertexStateTransfer {\n    static_assert(0 <= 1,\n                  \"Record must be at most one of is_cmd, extensible, and chained.\");\n    bool hasNextInChain;\n\n    ObjectId module;\n    \nuint32_t constantCount;\n    \nuint32_t bufferCount;\n\n    uint64_t entryPointStrlen;\n\n};\n\n\n\nDAWN_DECLARE_UNUSED size_t WGPUVertexStateGetExtraRequiredSize(const WGPUVertexState& record) {\n    DAWN_UNUSED(record);\n\n    size_t result = 0;\n\n    if (record.nextInChain != nullptr) {\n        result += GetChainedStructExtraRequiredSize(record.nextInChain);\n    }\n\n\n    {\n    result += std::strlen(record.entryPoint);\n    }\n\n    {\n    }\n    {\n    }\n    {\n        \n        auto memberLength = record.constantCount;\n        result += memberLength * sizeof(WGPUConstantEntryTransfer);\n        for (decltype(memberLength) i = 0; i < memberLength; ++i) {\n            \n            result += WGPUConstantEntryGetExtraRequiredSize(record.constants[i]);\n        }\n    }\n    {\n    }\n    {\n        \n        auto memberLength = record.bufferCount;\n        result += memberLength * sizeof(WGPUVertexBufferLayoutTransfer);\n        for (decltype(memberLength) i = 0; i < memberLength; ++i) {\n            \n            result += WGPUVertexBufferLayoutGetExtraRequiredSize(record.buffers[i]);\n        }\n    }\n\n    return result;\n}\n// GetExtraRequiredSize isn't used for structures that are value members of other structures\n// because we assume they cannot contain pointers themselves.\nDAWN_UNUSED_FUNC(WGPUVertexStateGetExtraRequiredSize);\n\nDAWN_DECLARE_UNUSED WireResult WGPUVertexStateSerialize(\n    const WGPUVertexState& record,\n    WGPUVertexStateTransfer* transfer,\n    SerializeBuffer* buffer, const ObjectIdProvider& provider) {\n    DAWN_UNUSED(buffer);\n\n\n    WIRE_TRY(provider.GetId(record.module, &transfer->module));\n    transfer->constantCount = record.constantCount;\n    transfer->bufferCount = record.bufferCount;\n\n    if (record.nextInChain != nullptr) {\n        transfer->hasNextInChain = true;\n        WIRE_TRY(SerializeChainedStruct(record.nextInChain, buffer, provider));\n    } else {\n        transfer->hasNextInChain = false;\n    }\n\n\n\n    {\n        transfer->entryPointStrlen = std::strlen(record.entryPoint);\n\n        char* stringInBuffer;\n        WIRE_TRY(buffer->NextN(transfer->entryPointStrlen, &stringInBuffer));\n        memcpy(stringInBuffer, record.entryPoint, transfer->entryPointStrlen);\n    }\n\n    \n\n    {\n        auto memberLength = record.constantCount;\n\n        WGPUConstantEntryTransfer* memberBuffer;\n        WIRE_TRY(buffer->NextN(memberLength, &memberBuffer));\n\n        for (decltype(memberLength) i = 0; i < memberLength; ++i) {\n            WIRE_TRY(WGPUConstantEntrySerialize(record.constants[i], &memberBuffer[i], buffer, provider));\n        }\n    }\n    \n\n    {\n        auto memberLength = record.bufferCount;\n\n        WGPUVertexBufferLayoutTransfer* memberBuffer;\n        WIRE_TRY(buffer->NextN(memberLength, &memberBuffer));\n\n        for (decltype(memberLength) i = 0; i < memberLength; ++i) {\n            WIRE_TRY(WGPUVertexBufferLayoutSerialize(record.buffers[i], &memberBuffer[i], buffer));\n        }\n    }\n    return WireResult::Success;\n}\nDAWN_UNUSED_FUNC(WGPUVertexStateSerialize);\n\nDAWN_DECLARE_UNUSED WireResult WGPUVertexStateDeserialize(\n    WGPUVertexState* record,\n    const volatile WGPUVertexStateTransfer* transfer,\n    DeserializeBuffer* deserializeBuffer,\n    DeserializeAllocator* allocator, const ObjectIdResolver& resolver) {\n    DAWN_UNUSED(allocator);\n\n\n\n    WIRE_TRY(resolver.GetFromId(transfer->module, &record->module));\n    static_assert(sizeof(record->constantCount) >= sizeof(transfer->constantCount), \"Deserialize assignment may not narrow.\");\nrecord->constantCount = transfer->constantCount;\n    static_assert(sizeof(record->bufferCount) >= sizeof(transfer->bufferCount), \"Deserialize assignment may not narrow.\");\nrecord->bufferCount = transfer->bufferCount;\n\n    record->nextInChain = nullptr;\n    if (transfer->hasNextInChain) {\n        WIRE_TRY(DeserializeChainedStruct(&record->nextInChain, deserializeBuffer, allocator, resolver));\n    }\n\n\n\n    {\n        uint64_t stringLength64 = transfer->entryPointStrlen;\n        if (stringLength64 >= std::numeric_limits<size_t>::max()) {\n            return WireResult::FatalError;\n        }\n        size_t stringLength = static_cast<size_t>(stringLength64);\n\n        const volatile char* stringInBuffer;\n        WIRE_TRY(deserializeBuffer->ReadN(stringLength, &stringInBuffer));\n\n        char* copiedString;\n        WIRE_TRY(GetSpace(allocator, stringLength + 1, &copiedString));\n        memcpy(copiedString, const_cast<const char*>(stringInBuffer), stringLength);\n        copiedString[stringLength] = '\\0';\n        record->entryPoint = copiedString;\n    }\n\n    \n\n    {\n        auto memberLength = record->constantCount;\n        const volatile WGPUConstantEntryTransfer* memberBuffer;\n        WIRE_TRY(deserializeBuffer->ReadN(memberLength, &memberBuffer));\n\n        WGPUConstantEntry* copiedMembers;\n        WIRE_TRY(GetSpace(allocator, memberLength, &copiedMembers));\n        record->constants = copiedMembers;\n\n        for (decltype(memberLength) i = 0; i < memberLength; ++i) {\n            WIRE_TRY(WGPUConstantEntryDeserialize(&copiedMembers[i], &memberBuffer[i], deserializeBuffer, allocator, resolver));\n        }\n    }\n    \n\n    {\n        auto memberLength = record->bufferCount;\n        const volatile WGPUVertexBufferLayoutTransfer* memberBuffer;\n        WIRE_TRY(deserializeBuffer->ReadN(memberLength, &memberBuffer));\n\n        WGPUVertexBufferLayout* copiedMembers;\n        WIRE_TRY(GetSpace(allocator, memberLength, &copiedMembers));\n        record->buffers = copiedMembers;\n\n        for (decltype(memberLength) i = 0; i < memberLength; ++i) {\n            WIRE_TRY(WGPUVertexBufferLayoutDeserialize(&copiedMembers[i], &memberBuffer[i], deserializeBuffer, allocator));\n        }\n    }\n\n    return WireResult::Success;\n}\nDAWN_UNUSED_FUNC(WGPUVertexStateDeserialize);\n\n                \nstruct WGPUFragmentStateTransfer {\n    static_assert(0 <= 1,\n                  \"Record must be at most one of is_cmd, extensible, and chained.\");\n    bool hasNextInChain;\n\n    ObjectId module;\n    \nuint32_t constantCount;\n    \nuint32_t targetCount;\n\n    uint64_t entryPointStrlen;\n\n};\n\n\n\nDAWN_DECLARE_UNUSED size_t WGPUFragmentStateGetExtraRequiredSize(const WGPUFragmentState& record) {\n    DAWN_UNUSED(record);\n\n    size_t result = 0;\n\n    if (record.nextInChain != nullptr) {\n        result += GetChainedStructExtraRequiredSize(record.nextInChain);\n    }\n\n\n    {\n    result += std::strlen(record.entryPoint);\n    }\n\n    {\n    }\n    {\n    }\n    {\n        \n        auto memberLength = record.constantCount;\n        result += memberLength * sizeof(WGPUConstantEntryTransfer);\n        for (decltype(memberLength) i = 0; i < memberLength; ++i) {\n            \n            result += WGPUConstantEntryGetExtraRequiredSize(record.constants[i]);\n        }\n    }\n    {\n    }\n    {\n        \n        auto memberLength = record.targetCount;\n        result += memberLength * sizeof(WGPUColorTargetStateTransfer);\n        for (decltype(memberLength) i = 0; i < memberLength; ++i) {\n            \n            result += WGPUColorTargetStateGetExtraRequiredSize(record.targets[i]);\n        }\n    }\n\n    return result;\n}\n// GetExtraRequiredSize isn't used for structures that are value members of other structures\n// because we assume they cannot contain pointers themselves.\nDAWN_UNUSED_FUNC(WGPUFragmentStateGetExtraRequiredSize);\n\nDAWN_DECLARE_UNUSED WireResult WGPUFragmentStateSerialize(\n    const WGPUFragmentState& record,\n    WGPUFragmentStateTransfer* transfer,\n    SerializeBuffer* buffer, const ObjectIdProvider& provider) {\n    DAWN_UNUSED(buffer);\n\n\n    WIRE_TRY(provider.GetId(record.module, &transfer->module));\n    transfer->constantCount = record.constantCount;\n    transfer->targetCount = record.targetCount;\n\n    if (record.nextInChain != nullptr) {\n        transfer->hasNextInChain = true;\n        WIRE_TRY(SerializeChainedStruct(record.nextInChain, buffer, provider));\n    } else {\n        transfer->hasNextInChain = false;\n    }\n\n\n\n    {\n        transfer->entryPointStrlen = std::strlen(record.entryPoint);\n\n        char* stringInBuffer;\n        WIRE_TRY(buffer->NextN(transfer->entryPointStrlen, &stringInBuffer));\n        memcpy(stringInBuffer, record.entryPoint, transfer->entryPointStrlen);\n    }\n\n    \n\n    {\n        auto memberLength = record.constantCount;\n\n        WGPUConstantEntryTransfer* memberBuffer;\n        WIRE_TRY(buffer->NextN(memberLength, &memberBuffer));\n\n        for (decltype(memberLength) i = 0; i < memberLength; ++i) {\n            WIRE_TRY(WGPUConstantEntrySerialize(record.constants[i], &memberBuffer[i], buffer, provider));\n        }\n    }\n    \n\n    {\n        auto memberLength = record.targetCount;\n\n        WGPUColorTargetStateTransfer* memberBuffer;\n        WIRE_TRY(buffer->NextN(memberLength, &memberBuffer));\n\n        for (decltype(memberLength) i = 0; i < memberLength; ++i) {\n            WIRE_TRY(WGPUColorTargetStateSerialize(record.targets[i], &memberBuffer[i], buffer, provider));\n        }\n    }\n    return WireResult::Success;\n}\nDAWN_UNUSED_FUNC(WGPUFragmentStateSerialize);\n\nDAWN_DECLARE_UNUSED WireResult WGPUFragmentStateDeserialize(\n    WGPUFragmentState* record,\n    const volatile WGPUFragmentStateTransfer* transfer,\n    DeserializeBuffer* deserializeBuffer,\n    DeserializeAllocator* allocator, const ObjectIdResolver& resolver) {\n    DAWN_UNUSED(allocator);\n\n\n\n    WIRE_TRY(resolver.GetFromId(transfer->module, &record->module));\n    static_assert(sizeof(record->constantCount) >= sizeof(transfer->constantCount), \"Deserialize assignment may not narrow.\");\nrecord->constantCount = transfer->constantCount;\n    static_assert(sizeof(record->targetCount) >= sizeof(transfer->targetCount), \"Deserialize assignment may not narrow.\");\nrecord->targetCount = transfer->targetCount;\n\n    record->nextInChain = nullptr;\n    if (transfer->hasNextInChain) {\n        WIRE_TRY(DeserializeChainedStruct(&record->nextInChain, deserializeBuffer, allocator, resolver));\n    }\n\n\n\n    {\n        uint64_t stringLength64 = transfer->entryPointStrlen;\n        if (stringLength64 >= std::numeric_limits<size_t>::max()) {\n            return WireResult::FatalError;\n        }\n        size_t stringLength = static_cast<size_t>(stringLength64);\n\n        const volatile char* stringInBuffer;\n        WIRE_TRY(deserializeBuffer->ReadN(stringLength, &stringInBuffer));\n\n        char* copiedString;\n        WIRE_TRY(GetSpace(allocator, stringLength + 1, &copiedString));\n        memcpy(copiedString, const_cast<const char*>(stringInBuffer), stringLength);\n        copiedString[stringLength] = '\\0';\n        record->entryPoint = copiedString;\n    }\n\n    \n\n    {\n        auto memberLength = record->constantCount;\n        const volatile WGPUConstantEntryTransfer* memberBuffer;\n        WIRE_TRY(deserializeBuffer->ReadN(memberLength, &memberBuffer));\n\n        WGPUConstantEntry* copiedMembers;\n        WIRE_TRY(GetSpace(allocator, memberLength, &copiedMembers));\n        record->constants = copiedMembers;\n\n        for (decltype(memberLength) i = 0; i < memberLength; ++i) {\n            WIRE_TRY(WGPUConstantEntryDeserialize(&copiedMembers[i], &memberBuffer[i], deserializeBuffer, allocator, resolver));\n        }\n    }\n    \n\n    {\n        auto memberLength = record->targetCount;\n        const volatile WGPUColorTargetStateTransfer* memberBuffer;\n        WIRE_TRY(deserializeBuffer->ReadN(memberLength, &memberBuffer));\n\n        WGPUColorTargetState* copiedMembers;\n        WIRE_TRY(GetSpace(allocator, memberLength, &copiedMembers));\n        record->targets = copiedMembers;\n\n        for (decltype(memberLength) i = 0; i < memberLength; ++i) {\n            WIRE_TRY(WGPUColorTargetStateDeserialize(&copiedMembers[i], &memberBuffer[i], deserializeBuffer, allocator, resolver));\n        }\n    }\n\n    return WireResult::Success;\n}\nDAWN_UNUSED_FUNC(WGPUFragmentStateDeserialize);\n\n                \nstruct WGPURenderPipelineDescriptorTransfer {\n    static_assert(0 <= 1,\n                  \"Record must be at most one of is_cmd, extensible, and chained.\");\n    bool hasNextInChain;\n\n    ObjectId layout;\n    WGPUVertexStateTransfer vertex;\n    WGPUPrimitiveStateTransfer primitive;\n    WGPUMultisampleStateTransfer multisample;\n\n    uint64_t labelStrlen;\n\n    bool has_label;\n    bool has_depthStencil;\n    bool has_fragment;\n};\n\n\n\nDAWN_DECLARE_UNUSED size_t WGPURenderPipelineDescriptorGetExtraRequiredSize(const WGPURenderPipelineDescriptor& record) {\n    DAWN_UNUSED(record);\n\n    size_t result = 0;\n\n    if (record.nextInChain != nullptr) {\n        result += GetChainedStructExtraRequiredSize(record.nextInChain);\n    }\n\n\n    bool has_label = record.label != nullptr;\n    if (has_label)\n    {\n    result += std::strlen(record.label);\n    }\n\n    {\n    }\n    {\n        result += WGPUVertexStateGetExtraRequiredSize(record.vertex);\n    }\n    {\n        result += WGPUPrimitiveStateGetExtraRequiredSize(record.primitive);\n    }\n    if (record.depthStencil != nullptr)\n    {\n        \n        auto memberLength = 1u;\n        result += memberLength * sizeof(WGPUDepthStencilStateTransfer);\n        for (decltype(memberLength) i = 0; i < memberLength; ++i) {\n            \n            result += WGPUDepthStencilStateGetExtraRequiredSize(record.depthStencil[i]);\n        }\n    }\n    {\n        result += WGPUMultisampleStateGetExtraRequiredSize(record.multisample);\n    }\n    if (record.fragment != nullptr)\n    {\n        \n        auto memberLength = 1u;\n        result += memberLength * sizeof(WGPUFragmentStateTransfer);\n        for (decltype(memberLength) i = 0; i < memberLength; ++i) {\n            \n            result += WGPUFragmentStateGetExtraRequiredSize(record.fragment[i]);\n        }\n    }\n\n    return result;\n}\n// GetExtraRequiredSize isn't used for structures that are value members of other structures\n// because we assume they cannot contain pointers themselves.\nDAWN_UNUSED_FUNC(WGPURenderPipelineDescriptorGetExtraRequiredSize);\n\nDAWN_DECLARE_UNUSED WireResult WGPURenderPipelineDescriptorSerialize(\n    const WGPURenderPipelineDescriptor& record,\n    WGPURenderPipelineDescriptorTransfer* transfer,\n    SerializeBuffer* buffer, const ObjectIdProvider& provider) {\n    DAWN_UNUSED(buffer);\n\n\n    WIRE_TRY(provider.GetOptionalId(record.layout, &transfer->layout));\n    WIRE_TRY(WGPUVertexStateSerialize(record.vertex, &transfer->vertex, buffer, provider));\n    WIRE_TRY(WGPUPrimitiveStateSerialize(record.primitive, &transfer->primitive, buffer, provider));\n    WIRE_TRY(WGPUMultisampleStateSerialize(record.multisample, &transfer->multisample, buffer, provider));\n\n    if (record.nextInChain != nullptr) {\n        transfer->hasNextInChain = true;\n        WIRE_TRY(SerializeChainedStruct(record.nextInChain, buffer, provider));\n    } else {\n        transfer->hasNextInChain = false;\n    }\n\n\n\n    bool has_label = record.label != nullptr;\n    transfer->has_label = has_label;\n    if (has_label)\n    {\n        transfer->labelStrlen = std::strlen(record.label);\n\n        char* stringInBuffer;\n        WIRE_TRY(buffer->NextN(transfer->labelStrlen, &stringInBuffer));\n        memcpy(stringInBuffer, record.label, transfer->labelStrlen);\n    }\n\n    \n\n    bool has_depthStencil = record.depthStencil != nullptr;\n    transfer->has_depthStencil = has_depthStencil;\n    if (has_depthStencil)\n    {\n        auto memberLength = 1u;\n\n        WGPUDepthStencilStateTransfer* memberBuffer;\n        WIRE_TRY(buffer->NextN(memberLength, &memberBuffer));\n\n        for (decltype(memberLength) i = 0; i < memberLength; ++i) {\n            WIRE_TRY(WGPUDepthStencilStateSerialize(record.depthStencil[i], &memberBuffer[i], buffer, provider));\n        }\n    }\n    \n\n    bool has_fragment = record.fragment != nullptr;\n    transfer->has_fragment = has_fragment;\n    if (has_fragment)\n    {\n        auto memberLength = 1u;\n\n        WGPUFragmentStateTransfer* memberBuffer;\n        WIRE_TRY(buffer->NextN(memberLength, &memberBuffer));\n\n        for (decltype(memberLength) i = 0; i < memberLength; ++i) {\n            WIRE_TRY(WGPUFragmentStateSerialize(record.fragment[i], &memberBuffer[i], buffer, provider));\n        }\n    }\n    return WireResult::Success;\n}\nDAWN_UNUSED_FUNC(WGPURenderPipelineDescriptorSerialize);\n\nDAWN_DECLARE_UNUSED WireResult WGPURenderPipelineDescriptorDeserialize(\n    WGPURenderPipelineDescriptor* record,\n    const volatile WGPURenderPipelineDescriptorTransfer* transfer,\n    DeserializeBuffer* deserializeBuffer,\n    DeserializeAllocator* allocator, const ObjectIdResolver& resolver) {\n    DAWN_UNUSED(allocator);\n\n\n\n    WIRE_TRY(resolver.GetOptionalFromId(transfer->layout, &record->layout));\n    WIRE_TRY(WGPUVertexStateDeserialize(&record->vertex, &transfer->vertex, deserializeBuffer, allocator, resolver));\n    WIRE_TRY(WGPUPrimitiveStateDeserialize(&record->primitive, &transfer->primitive, deserializeBuffer, allocator, resolver));\n    WIRE_TRY(WGPUMultisampleStateDeserialize(&record->multisample, &transfer->multisample, deserializeBuffer, allocator, resolver));\n\n    record->nextInChain = nullptr;\n    if (transfer->hasNextInChain) {\n        WIRE_TRY(DeserializeChainedStruct(&record->nextInChain, deserializeBuffer, allocator, resolver));\n    }\n\n\n\n    bool has_label = transfer->has_label;\n    record->label = nullptr;\n    if (has_label)\n    {\n        uint64_t stringLength64 = transfer->labelStrlen;\n        if (stringLength64 >= std::numeric_limits<size_t>::max()) {\n            return WireResult::FatalError;\n        }\n        size_t stringLength = static_cast<size_t>(stringLength64);\n\n        const volatile char* stringInBuffer;\n        WIRE_TRY(deserializeBuffer->ReadN(stringLength, &stringInBuffer));\n\n        char* copiedString;\n        WIRE_TRY(GetSpace(allocator, stringLength + 1, &copiedString));\n        memcpy(copiedString, const_cast<const char*>(stringInBuffer), stringLength);\n        copiedString[stringLength] = '\\0';\n        record->label = copiedString;\n    }\n\n    \n\n    \n    bool has_depthStencil = transfer->has_depthStencil;\n    record->depthStencil = nullptr;\n    if (has_depthStencil)\n    {\n        auto memberLength = 1u;\n        const volatile WGPUDepthStencilStateTransfer* memberBuffer;\n        WIRE_TRY(deserializeBuffer->ReadN(memberLength, &memberBuffer));\n\n        WGPUDepthStencilState* copiedMembers;\n        WIRE_TRY(GetSpace(allocator, memberLength, &copiedMembers));\n        record->depthStencil = copiedMembers;\n\n        for (decltype(memberLength) i = 0; i < memberLength; ++i) {\n            WIRE_TRY(WGPUDepthStencilStateDeserialize(&copiedMembers[i], &memberBuffer[i], deserializeBuffer, allocator, resolver));\n        }\n    }\n    \n\n    \n    bool has_fragment = transfer->has_fragment;\n    record->fragment = nullptr;\n    if (has_fragment)\n    {\n        auto memberLength = 1u;\n        const volatile WGPUFragmentStateTransfer* memberBuffer;\n        WIRE_TRY(deserializeBuffer->ReadN(memberLength, &memberBuffer));\n\n        WGPUFragmentState* copiedMembers;\n        WIRE_TRY(GetSpace(allocator, memberLength, &copiedMembers));\n        record->fragment = copiedMembers;\n\n        for (decltype(memberLength) i = 0; i < memberLength; ++i) {\n            WIRE_TRY(WGPUFragmentStateDeserialize(&copiedMembers[i], &memberBuffer[i], deserializeBuffer, allocator, resolver));\n        }\n    }\n\n    return WireResult::Success;\n}\nDAWN_UNUSED_FUNC(WGPURenderPipelineDescriptorDeserialize);\n\n\n\n            size_t GetChainedStructExtraRequiredSize(const WGPUChainedStruct* chainedStruct) {\n        ASSERT(chainedStruct != nullptr);\n        size_t result = 0;\n        while (chainedStruct != nullptr) {\n            switch (chainedStruct->sType) {\n                    case WGPUSType_SurfaceDescriptorFromCanvasHTMLSelector: {\n                        const auto& typedStruct = *reinterpret_cast<WGPUSurfaceDescriptorFromCanvasHTMLSelector const *>(chainedStruct);\n                        result += sizeof(WGPUSurfaceDescriptorFromCanvasHTMLSelectorTransfer);\n                        result += WGPUSurfaceDescriptorFromCanvasHTMLSelectorGetExtraRequiredSize(typedStruct);\n                        chainedStruct = typedStruct.chain.next;\n                        break;\n                    }\n                    case WGPUSType_ShaderModuleSPIRVDescriptor: {\n                        const auto& typedStruct = *reinterpret_cast<WGPUShaderModuleSPIRVDescriptor const *>(chainedStruct);\n                        result += sizeof(WGPUShaderModuleSPIRVDescriptorTransfer);\n                        result += WGPUShaderModuleSPIRVDescriptorGetExtraRequiredSize(typedStruct);\n                        chainedStruct = typedStruct.chain.next;\n                        break;\n                    }\n                    case WGPUSType_ShaderModuleWGSLDescriptor: {\n                        const auto& typedStruct = *reinterpret_cast<WGPUShaderModuleWGSLDescriptor const *>(chainedStruct);\n                        result += sizeof(WGPUShaderModuleWGSLDescriptorTransfer);\n                        result += WGPUShaderModuleWGSLDescriptorGetExtraRequiredSize(typedStruct);\n                        chainedStruct = typedStruct.chain.next;\n                        break;\n                    }\n                    case WGPUSType_PrimitiveDepthClipControl: {\n                        const auto& typedStruct = *reinterpret_cast<WGPUPrimitiveDepthClipControl const *>(chainedStruct);\n                        result += sizeof(WGPUPrimitiveDepthClipControlTransfer);\n                        result += WGPUPrimitiveDepthClipControlGetExtraRequiredSize(typedStruct);\n                        chainedStruct = typedStruct.chain.next;\n                        break;\n                    }\n                    case WGPUSType_ExternalTextureBindingEntry: {\n                        const auto& typedStruct = *reinterpret_cast<WGPUExternalTextureBindingEntry const *>(chainedStruct);\n                        result += sizeof(WGPUExternalTextureBindingEntryTransfer);\n                        result += WGPUExternalTextureBindingEntryGetExtraRequiredSize(typedStruct);\n                        chainedStruct = typedStruct.chain.next;\n                        break;\n                    }\n                    case WGPUSType_ExternalTextureBindingLayout: {\n                        const auto& typedStruct = *reinterpret_cast<WGPUExternalTextureBindingLayout const *>(chainedStruct);\n                        result += sizeof(WGPUExternalTextureBindingLayoutTransfer);\n                        result += WGPUExternalTextureBindingLayoutGetExtraRequiredSize(typedStruct);\n                        chainedStruct = typedStruct.chain.next;\n                        break;\n                    }\n                    case WGPUSType_RenderPassDescriptorMaxDrawCount: {\n                        const auto& typedStruct = *reinterpret_cast<WGPURenderPassDescriptorMaxDrawCount const *>(chainedStruct);\n                        result += sizeof(WGPURenderPassDescriptorMaxDrawCountTransfer);\n                        result += WGPURenderPassDescriptorMaxDrawCountGetExtraRequiredSize(typedStruct);\n                        chainedStruct = typedStruct.chain.next;\n                        break;\n                    }\n                    case WGPUSType_DawnTextureInternalUsageDescriptor: {\n                        const auto& typedStruct = *reinterpret_cast<WGPUDawnTextureInternalUsageDescriptor const *>(chainedStruct);\n                        result += sizeof(WGPUDawnTextureInternalUsageDescriptorTransfer);\n                        result += WGPUDawnTextureInternalUsageDescriptorGetExtraRequiredSize(typedStruct);\n                        chainedStruct = typedStruct.chain.next;\n                        break;\n                    }\n                    case WGPUSType_DawnEncoderInternalUsageDescriptor: {\n                        const auto& typedStruct = *reinterpret_cast<WGPUDawnEncoderInternalUsageDescriptor const *>(chainedStruct);\n                        result += sizeof(WGPUDawnEncoderInternalUsageDescriptorTransfer);\n                        result += WGPUDawnEncoderInternalUsageDescriptorGetExtraRequiredSize(typedStruct);\n                        chainedStruct = typedStruct.chain.next;\n                        break;\n                    }\n                    // Explicitly list the Invalid enum. MSVC complains about no case labels.\n                    case WGPUSType_Invalid:\n                    default:\n                        // Invalid enum. Reserve space just for the transfer header (sType and hasNext).\n                        result += sizeof(WGPUChainedStructTransfer);\n                        chainedStruct = chainedStruct->next;\n                        break;\n                }\n            }\n            return result;\n        }\n\n        [[nodiscard]] WireResult SerializeChainedStruct(const WGPUChainedStruct* chainedStruct,\n                                                          SerializeBuffer* buffer,\n                                                          const ObjectIdProvider& provider) {\n            ASSERT(chainedStruct != nullptr);\n            ASSERT(buffer != nullptr);\n            do {\n                switch (chainedStruct->sType) {\n                        case WGPUSType_SurfaceDescriptorFromCanvasHTMLSelector: {\n\n                            WGPUSurfaceDescriptorFromCanvasHTMLSelectorTransfer* transfer;\n                            WIRE_TRY(buffer->Next(&transfer));\n                            transfer->chain.sType = chainedStruct->sType;\n                            transfer->chain.hasNext = chainedStruct->next != nullptr;\n\n                            WIRE_TRY(WGPUSurfaceDescriptorFromCanvasHTMLSelectorSerialize(*reinterpret_cast<WGPUSurfaceDescriptorFromCanvasHTMLSelector const*>(chainedStruct), transfer, buffer, provider));\n\n                            chainedStruct = chainedStruct->next;\n                        } break;\n                        case WGPUSType_ShaderModuleSPIRVDescriptor: {\n\n                            WGPUShaderModuleSPIRVDescriptorTransfer* transfer;\n                            WIRE_TRY(buffer->Next(&transfer));\n                            transfer->chain.sType = chainedStruct->sType;\n                            transfer->chain.hasNext = chainedStruct->next != nullptr;\n\n                            WIRE_TRY(WGPUShaderModuleSPIRVDescriptorSerialize(*reinterpret_cast<WGPUShaderModuleSPIRVDescriptor const*>(chainedStruct), transfer, buffer, provider));\n\n                            chainedStruct = chainedStruct->next;\n                        } break;\n                        case WGPUSType_ShaderModuleWGSLDescriptor: {\n\n                            WGPUShaderModuleWGSLDescriptorTransfer* transfer;\n                            WIRE_TRY(buffer->Next(&transfer));\n                            transfer->chain.sType = chainedStruct->sType;\n                            transfer->chain.hasNext = chainedStruct->next != nullptr;\n\n                            WIRE_TRY(WGPUShaderModuleWGSLDescriptorSerialize(*reinterpret_cast<WGPUShaderModuleWGSLDescriptor const*>(chainedStruct), transfer, buffer, provider));\n\n                            chainedStruct = chainedStruct->next;\n                        } break;\n                        case WGPUSType_PrimitiveDepthClipControl: {\n\n                            WGPUPrimitiveDepthClipControlTransfer* transfer;\n                            WIRE_TRY(buffer->Next(&transfer));\n                            transfer->chain.sType = chainedStruct->sType;\n                            transfer->chain.hasNext = chainedStruct->next != nullptr;\n\n                            WIRE_TRY(WGPUPrimitiveDepthClipControlSerialize(*reinterpret_cast<WGPUPrimitiveDepthClipControl const*>(chainedStruct), transfer, buffer, provider));\n\n                            chainedStruct = chainedStruct->next;\n                        } break;\n                        case WGPUSType_ExternalTextureBindingEntry: {\n\n                            WGPUExternalTextureBindingEntryTransfer* transfer;\n                            WIRE_TRY(buffer->Next(&transfer));\n                            transfer->chain.sType = chainedStruct->sType;\n                            transfer->chain.hasNext = chainedStruct->next != nullptr;\n\n                            WIRE_TRY(WGPUExternalTextureBindingEntrySerialize(*reinterpret_cast<WGPUExternalTextureBindingEntry const*>(chainedStruct), transfer, buffer, provider));\n\n                            chainedStruct = chainedStruct->next;\n                        } break;\n                        case WGPUSType_ExternalTextureBindingLayout: {\n\n                            WGPUExternalTextureBindingLayoutTransfer* transfer;\n                            WIRE_TRY(buffer->Next(&transfer));\n                            transfer->chain.sType = chainedStruct->sType;\n                            transfer->chain.hasNext = chainedStruct->next != nullptr;\n\n                            WIRE_TRY(WGPUExternalTextureBindingLayoutSerialize(*reinterpret_cast<WGPUExternalTextureBindingLayout const*>(chainedStruct), transfer, buffer, provider));\n\n                            chainedStruct = chainedStruct->next;\n                        } break;\n                        case WGPUSType_RenderPassDescriptorMaxDrawCount: {\n\n                            WGPURenderPassDescriptorMaxDrawCountTransfer* transfer;\n                            WIRE_TRY(buffer->Next(&transfer));\n                            transfer->chain.sType = chainedStruct->sType;\n                            transfer->chain.hasNext = chainedStruct->next != nullptr;\n\n                            WIRE_TRY(WGPURenderPassDescriptorMaxDrawCountSerialize(*reinterpret_cast<WGPURenderPassDescriptorMaxDrawCount const*>(chainedStruct), transfer, buffer, provider));\n\n                            chainedStruct = chainedStruct->next;\n                        } break;\n                        case WGPUSType_DawnTextureInternalUsageDescriptor: {\n\n                            WGPUDawnTextureInternalUsageDescriptorTransfer* transfer;\n                            WIRE_TRY(buffer->Next(&transfer));\n                            transfer->chain.sType = chainedStruct->sType;\n                            transfer->chain.hasNext = chainedStruct->next != nullptr;\n\n                            WIRE_TRY(WGPUDawnTextureInternalUsageDescriptorSerialize(*reinterpret_cast<WGPUDawnTextureInternalUsageDescriptor const*>(chainedStruct), transfer, buffer, provider));\n\n                            chainedStruct = chainedStruct->next;\n                        } break;\n                        case WGPUSType_DawnEncoderInternalUsageDescriptor: {\n\n                            WGPUDawnEncoderInternalUsageDescriptorTransfer* transfer;\n                            WIRE_TRY(buffer->Next(&transfer));\n                            transfer->chain.sType = chainedStruct->sType;\n                            transfer->chain.hasNext = chainedStruct->next != nullptr;\n\n                            WIRE_TRY(WGPUDawnEncoderInternalUsageDescriptorSerialize(*reinterpret_cast<WGPUDawnEncoderInternalUsageDescriptor const*>(chainedStruct), transfer, buffer, provider));\n\n                            chainedStruct = chainedStruct->next;\n                        } break;\n                    // Explicitly list the Invalid enum. MSVC complains about no case labels.\n                    case WGPUSType_Invalid:\n                    default: {\n                        // Invalid enum. Serialize just the transfer header with Invalid as the sType.\n                        // TODO(crbug.com/dawn/369): Unknown sTypes are silently discarded.\n                        if (chainedStruct->sType != WGPUSType_Invalid) {\n                            dawn::WarningLog() << \"Unknown sType \" << chainedStruct->sType << \" discarded.\";\n                        }\n\n                        WGPUChainedStructTransfer* transfer;\n                        WIRE_TRY(buffer->Next(&transfer));\n                        transfer->sType = WGPUSType_Invalid;\n                        transfer->hasNext = chainedStruct->next != nullptr;\n\n                        // Still move on in case there are valid structs after this.\n                        chainedStruct = chainedStruct->next;\n                        break;\n                    }\n                }\n            } while (chainedStruct != nullptr);\n            return WireResult::Success;\n        }\n\n        WireResult DeserializeChainedStruct(const WGPUChainedStruct** outChainNext,\n                                            DeserializeBuffer* deserializeBuffer,\n                                            DeserializeAllocator* allocator,\n                                            const ObjectIdResolver& resolver) {\n            bool hasNext;\n            do {\n                const volatile WGPUChainedStructTransfer* header;\n                WIRE_TRY(deserializeBuffer->Peek(&header));\n                WGPUSType sType = header->sType;\n                switch (sType) {\n                        case WGPUSType_SurfaceDescriptorFromCanvasHTMLSelector: {\n                            const volatile WGPUSurfaceDescriptorFromCanvasHTMLSelectorTransfer* transfer;\n                            WIRE_TRY(deserializeBuffer->Read(&transfer));\n\n                            WGPUSurfaceDescriptorFromCanvasHTMLSelector* outStruct;\n                            WIRE_TRY(GetSpace(allocator, sizeof(WGPUSurfaceDescriptorFromCanvasHTMLSelector), &outStruct));\n                            outStruct->chain.sType = sType;\n                            outStruct->chain.next = nullptr;\n\n                            *outChainNext = &outStruct->chain;\n                            outChainNext = &outStruct->chain.next;\n\n                            WIRE_TRY(WGPUSurfaceDescriptorFromCanvasHTMLSelectorDeserialize(outStruct, transfer, deserializeBuffer, allocator, resolver));\n\n                            hasNext = transfer->chain.hasNext;\n                        } break;\n                        case WGPUSType_ShaderModuleSPIRVDescriptor: {\n                            const volatile WGPUShaderModuleSPIRVDescriptorTransfer* transfer;\n                            WIRE_TRY(deserializeBuffer->Read(&transfer));\n\n                            WGPUShaderModuleSPIRVDescriptor* outStruct;\n                            WIRE_TRY(GetSpace(allocator, sizeof(WGPUShaderModuleSPIRVDescriptor), &outStruct));\n                            outStruct->chain.sType = sType;\n                            outStruct->chain.next = nullptr;\n\n                            *outChainNext = &outStruct->chain;\n                            outChainNext = &outStruct->chain.next;\n\n                            WIRE_TRY(WGPUShaderModuleSPIRVDescriptorDeserialize(outStruct, transfer, deserializeBuffer, allocator, resolver));\n\n                            hasNext = transfer->chain.hasNext;\n                        } break;\n                        case WGPUSType_ShaderModuleWGSLDescriptor: {\n                            const volatile WGPUShaderModuleWGSLDescriptorTransfer* transfer;\n                            WIRE_TRY(deserializeBuffer->Read(&transfer));\n\n                            WGPUShaderModuleWGSLDescriptor* outStruct;\n                            WIRE_TRY(GetSpace(allocator, sizeof(WGPUShaderModuleWGSLDescriptor), &outStruct));\n                            outStruct->chain.sType = sType;\n                            outStruct->chain.next = nullptr;\n\n                            *outChainNext = &outStruct->chain;\n                            outChainNext = &outStruct->chain.next;\n\n                            WIRE_TRY(WGPUShaderModuleWGSLDescriptorDeserialize(outStruct, transfer, deserializeBuffer, allocator, resolver));\n\n                            hasNext = transfer->chain.hasNext;\n                        } break;\n                        case WGPUSType_PrimitiveDepthClipControl: {\n                            const volatile WGPUPrimitiveDepthClipControlTransfer* transfer;\n                            WIRE_TRY(deserializeBuffer->Read(&transfer));\n\n                            WGPUPrimitiveDepthClipControl* outStruct;\n                            WIRE_TRY(GetSpace(allocator, sizeof(WGPUPrimitiveDepthClipControl), &outStruct));\n                            outStruct->chain.sType = sType;\n                            outStruct->chain.next = nullptr;\n\n                            *outChainNext = &outStruct->chain;\n                            outChainNext = &outStruct->chain.next;\n\n                            WIRE_TRY(WGPUPrimitiveDepthClipControlDeserialize(outStruct, transfer, deserializeBuffer, allocator, resolver));\n\n                            hasNext = transfer->chain.hasNext;\n                        } break;\n                        case WGPUSType_ExternalTextureBindingEntry: {\n                            const volatile WGPUExternalTextureBindingEntryTransfer* transfer;\n                            WIRE_TRY(deserializeBuffer->Read(&transfer));\n\n                            WGPUExternalTextureBindingEntry* outStruct;\n                            WIRE_TRY(GetSpace(allocator, sizeof(WGPUExternalTextureBindingEntry), &outStruct));\n                            outStruct->chain.sType = sType;\n                            outStruct->chain.next = nullptr;\n\n                            *outChainNext = &outStruct->chain;\n                            outChainNext = &outStruct->chain.next;\n\n                            WIRE_TRY(WGPUExternalTextureBindingEntryDeserialize(outStruct, transfer, deserializeBuffer, allocator, resolver));\n\n                            hasNext = transfer->chain.hasNext;\n                        } break;\n                        case WGPUSType_ExternalTextureBindingLayout: {\n                            const volatile WGPUExternalTextureBindingLayoutTransfer* transfer;\n                            WIRE_TRY(deserializeBuffer->Read(&transfer));\n\n                            WGPUExternalTextureBindingLayout* outStruct;\n                            WIRE_TRY(GetSpace(allocator, sizeof(WGPUExternalTextureBindingLayout), &outStruct));\n                            outStruct->chain.sType = sType;\n                            outStruct->chain.next = nullptr;\n\n                            *outChainNext = &outStruct->chain;\n                            outChainNext = &outStruct->chain.next;\n\n                            WIRE_TRY(WGPUExternalTextureBindingLayoutDeserialize(outStruct, transfer, deserializeBuffer, allocator, resolver));\n\n                            hasNext = transfer->chain.hasNext;\n                        } break;\n                        case WGPUSType_RenderPassDescriptorMaxDrawCount: {\n                            const volatile WGPURenderPassDescriptorMaxDrawCountTransfer* transfer;\n                            WIRE_TRY(deserializeBuffer->Read(&transfer));\n\n                            WGPURenderPassDescriptorMaxDrawCount* outStruct;\n                            WIRE_TRY(GetSpace(allocator, sizeof(WGPURenderPassDescriptorMaxDrawCount), &outStruct));\n                            outStruct->chain.sType = sType;\n                            outStruct->chain.next = nullptr;\n\n                            *outChainNext = &outStruct->chain;\n                            outChainNext = &outStruct->chain.next;\n\n                            WIRE_TRY(WGPURenderPassDescriptorMaxDrawCountDeserialize(outStruct, transfer, deserializeBuffer, allocator, resolver));\n\n                            hasNext = transfer->chain.hasNext;\n                        } break;\n                        case WGPUSType_DawnTextureInternalUsageDescriptor: {\n                            const volatile WGPUDawnTextureInternalUsageDescriptorTransfer* transfer;\n                            WIRE_TRY(deserializeBuffer->Read(&transfer));\n\n                            WGPUDawnTextureInternalUsageDescriptor* outStruct;\n                            WIRE_TRY(GetSpace(allocator, sizeof(WGPUDawnTextureInternalUsageDescriptor), &outStruct));\n                            outStruct->chain.sType = sType;\n                            outStruct->chain.next = nullptr;\n\n                            *outChainNext = &outStruct->chain;\n                            outChainNext = &outStruct->chain.next;\n\n                            WIRE_TRY(WGPUDawnTextureInternalUsageDescriptorDeserialize(outStruct, transfer, deserializeBuffer, allocator, resolver));\n\n                            hasNext = transfer->chain.hasNext;\n                        } break;\n                        case WGPUSType_DawnEncoderInternalUsageDescriptor: {\n                            const volatile WGPUDawnEncoderInternalUsageDescriptorTransfer* transfer;\n                            WIRE_TRY(deserializeBuffer->Read(&transfer));\n\n                            WGPUDawnEncoderInternalUsageDescriptor* outStruct;\n                            WIRE_TRY(GetSpace(allocator, sizeof(WGPUDawnEncoderInternalUsageDescriptor), &outStruct));\n                            outStruct->chain.sType = sType;\n                            outStruct->chain.next = nullptr;\n\n                            *outChainNext = &outStruct->chain;\n                            outChainNext = &outStruct->chain.next;\n\n                            WIRE_TRY(WGPUDawnEncoderInternalUsageDescriptorDeserialize(outStruct, transfer, deserializeBuffer, allocator, resolver));\n\n                            hasNext = transfer->chain.hasNext;\n                        } break;\n                    // Explicitly list the Invalid enum. MSVC complains about no case labels.\n                    case WGPUSType_Invalid:\n                    default: {\n                        // Invalid enum. Deserialize just the transfer header with Invalid as the sType.\n                        // TODO(crbug.com/dawn/369): Unknown sTypes are silently discarded.\n                        if (sType != WGPUSType_Invalid) {\n                            dawn::WarningLog() << \"Unknown sType \" << sType << \" discarded.\";\n                        }\n\n                        const volatile WGPUChainedStructTransfer* transfer;\n                        WIRE_TRY(deserializeBuffer->Read(&transfer));\n\n                        WGPUChainedStruct* outStruct;\n                        WIRE_TRY(GetSpace(allocator, sizeof(WGPUChainedStruct), &outStruct));\n                        outStruct->sType = WGPUSType_Invalid;\n                        outStruct->next = nullptr;\n\n                        // Still move on in case there are valid structs after this.\n                        *outChainNext = outStruct;\n                        outChainNext = &outStruct->next;\n                        hasNext = transfer->hasNext;\n                        break;\n                    }\n                }\n            } while (hasNext);\n\n            return WireResult::Success;\n        }\n\n            size_t GetChainedStructExtraRequiredSize(WGPUChainedStructOut* chainedStruct) {\n        ASSERT(chainedStruct != nullptr);\n        size_t result = 0;\n        while (chainedStruct != nullptr) {\n            switch (chainedStruct->sType) {\n                    // Explicitly list the Invalid enum. MSVC complains about no case labels.\n                    case WGPUSType_Invalid:\n                    default:\n                        // Invalid enum. Reserve space just for the transfer header (sType and hasNext).\n                        result += sizeof(WGPUChainedStructTransfer);\n                        chainedStruct = chainedStruct->next;\n                        break;\n                }\n            }\n            return result;\n        }\n\n        [[nodiscard]] WireResult SerializeChainedStruct(WGPUChainedStructOut* chainedStruct,\n                                                          SerializeBuffer* buffer,\n                                                          const ObjectIdProvider& provider) {\n            ASSERT(chainedStruct != nullptr);\n            ASSERT(buffer != nullptr);\n            do {\n                switch (chainedStruct->sType) {\n                    // Explicitly list the Invalid enum. MSVC complains about no case labels.\n                    case WGPUSType_Invalid:\n                    default: {\n                        // Invalid enum. Serialize just the transfer header with Invalid as the sType.\n                        // TODO(crbug.com/dawn/369): Unknown sTypes are silently discarded.\n                        if (chainedStruct->sType != WGPUSType_Invalid) {\n                            dawn::WarningLog() << \"Unknown sType \" << chainedStruct->sType << \" discarded.\";\n                        }\n\n                        WGPUChainedStructTransfer* transfer;\n                        WIRE_TRY(buffer->Next(&transfer));\n                        transfer->sType = WGPUSType_Invalid;\n                        transfer->hasNext = chainedStruct->next != nullptr;\n\n                        // Still move on in case there are valid structs after this.\n                        chainedStruct = chainedStruct->next;\n                        break;\n                    }\n                }\n            } while (chainedStruct != nullptr);\n            return WireResult::Success;\n        }\n\n        WireResult DeserializeChainedStruct(WGPUChainedStructOut** outChainNext,\n                                            DeserializeBuffer* deserializeBuffer,\n                                            DeserializeAllocator* allocator,\n                                            const ObjectIdResolver& resolver) {\n            bool hasNext;\n            do {\n                const volatile WGPUChainedStructTransfer* header;\n                WIRE_TRY(deserializeBuffer->Peek(&header));\n                WGPUSType sType = header->sType;\n                switch (sType) {\n                    // Explicitly list the Invalid enum. MSVC complains about no case labels.\n                    case WGPUSType_Invalid:\n                    default: {\n                        // Invalid enum. Deserialize just the transfer header with Invalid as the sType.\n                        // TODO(crbug.com/dawn/369): Unknown sTypes are silently discarded.\n                        if (sType != WGPUSType_Invalid) {\n                            dawn::WarningLog() << \"Unknown sType \" << sType << \" discarded.\";\n                        }\n\n                        const volatile WGPUChainedStructTransfer* transfer;\n                        WIRE_TRY(deserializeBuffer->Read(&transfer));\n\n                        WGPUChainedStructOut* outStruct;\n                        WIRE_TRY(GetSpace(allocator, sizeof(WGPUChainedStructOut), &outStruct));\n                        outStruct->sType = WGPUSType_Invalid;\n                        outStruct->next = nullptr;\n\n                        // Still move on in case there are valid structs after this.\n                        *outChainNext = outStruct;\n                        outChainNext = &outStruct->next;\n                        hasNext = transfer->hasNext;\n                        break;\n                    }\n                }\n            } while (hasNext);\n\n            return WireResult::Success;\n        }\n\n\n            \nstruct AdapterRequestDeviceTransfer : CmdHeader {\n    static_assert(1 <= 1,\n                  \"Record must be at most one of is_cmd, extensible, and chained.\");\n    WireCmd commandId;\n\n    \nObjectId adapterId;\n    \nuint64_t requestSerial;\n    \nObjectHandle deviceObjectHandle;\n\n\n};\n\nstatic_assert(offsetof(AdapterRequestDeviceTransfer, commandSize) == 0);\nstatic_assert(offsetof(AdapterRequestDeviceTransfer, commandId) == sizeof(CmdHeader));\n\n\nDAWN_DECLARE_UNUSED size_t AdapterRequestDeviceGetExtraRequiredSize(const AdapterRequestDeviceCmd& record) {\n    DAWN_UNUSED(record);\n\n    size_t result = 0;\n\n\n\n    {\n    }\n    {\n    }\n    {\n    }\n    {\n        \n        auto memberLength = 1u;\n        result += memberLength * sizeof(WGPUDeviceDescriptorTransfer);\n        for (decltype(memberLength) i = 0; i < memberLength; ++i) {\n            \n            result += WGPUDeviceDescriptorGetExtraRequiredSize(record.descriptor[i]);\n        }\n    }\n\n    return result;\n}\n// GetExtraRequiredSize isn't used for structures that are value members of other structures\n// because we assume they cannot contain pointers themselves.\nDAWN_UNUSED_FUNC(AdapterRequestDeviceGetExtraRequiredSize);\n\nDAWN_DECLARE_UNUSED WireResult AdapterRequestDeviceSerialize(\n    const AdapterRequestDeviceCmd& record,\n    AdapterRequestDeviceTransfer* transfer,\n    SerializeBuffer* buffer, const ObjectIdProvider& provider) {\n    DAWN_UNUSED(buffer);\n\n    transfer->commandId = WireCmd::AdapterRequestDevice;\n\n    transfer->adapterId = record.adapterId;\n    transfer->requestSerial = record.requestSerial;\n    transfer->deviceObjectHandle = record.deviceObjectHandle;\n\n\n\n\n    \n\n    {\n        auto memberLength = 1u;\n\n        WGPUDeviceDescriptorTransfer* memberBuffer;\n        WIRE_TRY(buffer->NextN(memberLength, &memberBuffer));\n\n        for (decltype(memberLength) i = 0; i < memberLength; ++i) {\n            WIRE_TRY(WGPUDeviceDescriptorSerialize(record.descriptor[i], &memberBuffer[i], buffer, provider));\n        }\n    }\n    return WireResult::Success;\n}\nDAWN_UNUSED_FUNC(AdapterRequestDeviceSerialize);\n\nDAWN_DECLARE_UNUSED WireResult AdapterRequestDeviceDeserialize(\n    AdapterRequestDeviceCmd* record,\n    const volatile AdapterRequestDeviceTransfer* transfer,\n    DeserializeBuffer* deserializeBuffer,\n    DeserializeAllocator* allocator, const ObjectIdResolver& resolver) {\n    DAWN_UNUSED(allocator);\n\n    ASSERT(transfer->commandId == WireCmd::AdapterRequestDevice);\n\n\n    static_assert(sizeof(record->adapterId) >= sizeof(transfer->adapterId), \"Deserialize assignment may not narrow.\");\nrecord->adapterId = transfer->adapterId;\n    static_assert(sizeof(record->requestSerial) >= sizeof(transfer->requestSerial), \"Deserialize assignment may not narrow.\");\nrecord->requestSerial = transfer->requestSerial;\n    static_assert(sizeof(record->deviceObjectHandle) >= sizeof(transfer->deviceObjectHandle), \"Deserialize assignment may not narrow.\");\nrecord->deviceObjectHandle = transfer->deviceObjectHandle;\n\n\n\n\n    \n\n    {\n        auto memberLength = 1u;\n        const volatile WGPUDeviceDescriptorTransfer* memberBuffer;\n        WIRE_TRY(deserializeBuffer->ReadN(memberLength, &memberBuffer));\n\n        WGPUDeviceDescriptor* copiedMembers;\n        WIRE_TRY(GetSpace(allocator, memberLength, &copiedMembers));\n        record->descriptor = copiedMembers;\n\n        for (decltype(memberLength) i = 0; i < memberLength; ++i) {\n            WIRE_TRY(WGPUDeviceDescriptorDeserialize(&copiedMembers[i], &memberBuffer[i], deserializeBuffer, allocator, resolver));\n        }\n    }\n\n    return WireResult::Success;\n}\nDAWN_UNUSED_FUNC(AdapterRequestDeviceDeserialize);\n\n            \nstruct BindGroupLayoutSetLabelTransfer : CmdHeader {\n    static_assert(1 <= 1,\n                  \"Record must be at most one of is_cmd, extensible, and chained.\");\n    WireCmd commandId;\n\n    ObjectId self;\n\n    uint64_t labelStrlen;\n\n};\n\nstatic_assert(offsetof(BindGroupLayoutSetLabelTransfer, commandSize) == 0);\nstatic_assert(offsetof(BindGroupLayoutSetLabelTransfer, commandId) == sizeof(CmdHeader));\n\n\nDAWN_DECLARE_UNUSED size_t BindGroupLayoutSetLabelGetExtraRequiredSize(const BindGroupLayoutSetLabelCmd& record) {\n    DAWN_UNUSED(record);\n\n    size_t result = 0;\n\n\n\n    {\n    result += std::strlen(record.label);\n    }\n\n    {\n    }\n\n    return result;\n}\n// GetExtraRequiredSize isn't used for structures that are value members of other structures\n// because we assume they cannot contain pointers themselves.\nDAWN_UNUSED_FUNC(BindGroupLayoutSetLabelGetExtraRequiredSize);\n\nDAWN_DECLARE_UNUSED WireResult BindGroupLayoutSetLabelSerialize(\n    const BindGroupLayoutSetLabelCmd& record,\n    BindGroupLayoutSetLabelTransfer* transfer,\n    SerializeBuffer* buffer, const ObjectIdProvider& provider) {\n    DAWN_UNUSED(buffer);\n\n    transfer->commandId = WireCmd::BindGroupLayoutSetLabel;\n\n    WIRE_TRY(provider.GetId(record.self, &transfer->self));\n\n\n\n\n    {\n        transfer->labelStrlen = std::strlen(record.label);\n\n        char* stringInBuffer;\n        WIRE_TRY(buffer->NextN(transfer->labelStrlen, &stringInBuffer));\n        memcpy(stringInBuffer, record.label, transfer->labelStrlen);\n    }\n\n    return WireResult::Success;\n}\nDAWN_UNUSED_FUNC(BindGroupLayoutSetLabelSerialize);\n\nDAWN_DECLARE_UNUSED WireResult BindGroupLayoutSetLabelDeserialize(\n    BindGroupLayoutSetLabelCmd* record,\n    const volatile BindGroupLayoutSetLabelTransfer* transfer,\n    DeserializeBuffer* deserializeBuffer,\n    DeserializeAllocator* allocator, const ObjectIdResolver& resolver) {\n    DAWN_UNUSED(allocator);\n\n    ASSERT(transfer->commandId == WireCmd::BindGroupLayoutSetLabel);\n\n    record->selfId = transfer->self;\n\n    WIRE_TRY(resolver.GetFromId(transfer->self, &record->self));\n\n\n\n\n    {\n        uint64_t stringLength64 = transfer->labelStrlen;\n        if (stringLength64 >= std::numeric_limits<size_t>::max()) {\n            return WireResult::FatalError;\n        }\n        size_t stringLength = static_cast<size_t>(stringLength64);\n\n        const volatile char* stringInBuffer;\n        WIRE_TRY(deserializeBuffer->ReadN(stringLength, &stringInBuffer));\n\n        char* copiedString;\n        WIRE_TRY(GetSpace(allocator, stringLength + 1, &copiedString));\n        memcpy(copiedString, const_cast<const char*>(stringInBuffer), stringLength);\n        copiedString[stringLength] = '\\0';\n        record->label = copiedString;\n    }\n\n\n    return WireResult::Success;\n}\nDAWN_UNUSED_FUNC(BindGroupLayoutSetLabelDeserialize);\n\n            \nstruct BindGroupSetLabelTransfer : CmdHeader {\n    static_assert(1 <= 1,\n                  \"Record must be at most one of is_cmd, extensible, and chained.\");\n    WireCmd commandId;\n\n    ObjectId self;\n\n    uint64_t labelStrlen;\n\n};\n\nstatic_assert(offsetof(BindGroupSetLabelTransfer, commandSize) == 0);\nstatic_assert(offsetof(BindGroupSetLabelTransfer, commandId) == sizeof(CmdHeader));\n\n\nDAWN_DECLARE_UNUSED size_t BindGroupSetLabelGetExtraRequiredSize(const BindGroupSetLabelCmd& record) {\n    DAWN_UNUSED(record);\n\n    size_t result = 0;\n\n\n\n    {\n    result += std::strlen(record.label);\n    }\n\n    {\n    }\n\n    return result;\n}\n// GetExtraRequiredSize isn't used for structures that are value members of other structures\n// because we assume they cannot contain pointers themselves.\nDAWN_UNUSED_FUNC(BindGroupSetLabelGetExtraRequiredSize);\n\nDAWN_DECLARE_UNUSED WireResult BindGroupSetLabelSerialize(\n    const BindGroupSetLabelCmd& record,\n    BindGroupSetLabelTransfer* transfer,\n    SerializeBuffer* buffer, const ObjectIdProvider& provider) {\n    DAWN_UNUSED(buffer);\n\n    transfer->commandId = WireCmd::BindGroupSetLabel;\n\n    WIRE_TRY(provider.GetId(record.self, &transfer->self));\n\n\n\n\n    {\n        transfer->labelStrlen = std::strlen(record.label);\n\n        char* stringInBuffer;\n        WIRE_TRY(buffer->NextN(transfer->labelStrlen, &stringInBuffer));\n        memcpy(stringInBuffer, record.label, transfer->labelStrlen);\n    }\n\n    return WireResult::Success;\n}\nDAWN_UNUSED_FUNC(BindGroupSetLabelSerialize);\n\nDAWN_DECLARE_UNUSED WireResult BindGroupSetLabelDeserialize(\n    BindGroupSetLabelCmd* record,\n    const volatile BindGroupSetLabelTransfer* transfer,\n    DeserializeBuffer* deserializeBuffer,\n    DeserializeAllocator* allocator, const ObjectIdResolver& resolver) {\n    DAWN_UNUSED(allocator);\n\n    ASSERT(transfer->commandId == WireCmd::BindGroupSetLabel);\n\n    record->selfId = transfer->self;\n\n    WIRE_TRY(resolver.GetFromId(transfer->self, &record->self));\n\n\n\n\n    {\n        uint64_t stringLength64 = transfer->labelStrlen;\n        if (stringLength64 >= std::numeric_limits<size_t>::max()) {\n            return WireResult::FatalError;\n        }\n        size_t stringLength = static_cast<size_t>(stringLength64);\n\n        const volatile char* stringInBuffer;\n        WIRE_TRY(deserializeBuffer->ReadN(stringLength, &stringInBuffer));\n\n        char* copiedString;\n        WIRE_TRY(GetSpace(allocator, stringLength + 1, &copiedString));\n        memcpy(copiedString, const_cast<const char*>(stringInBuffer), stringLength);\n        copiedString[stringLength] = '\\0';\n        record->label = copiedString;\n    }\n\n\n    return WireResult::Success;\n}\nDAWN_UNUSED_FUNC(BindGroupSetLabelDeserialize);\n\n            \nstruct BufferDestroyTransfer : CmdHeader {\n    static_assert(1 <= 1,\n                  \"Record must be at most one of is_cmd, extensible, and chained.\");\n    WireCmd commandId;\n\n    ObjectId self;\n\n\n};\n\nstatic_assert(offsetof(BufferDestroyTransfer, commandSize) == 0);\nstatic_assert(offsetof(BufferDestroyTransfer, commandId) == sizeof(CmdHeader));\n\n\nDAWN_DECLARE_UNUSED size_t BufferDestroyGetExtraRequiredSize(const BufferDestroyCmd& record) {\n    DAWN_UNUSED(record);\n\n    size_t result = 0;\n\n\n\n    {\n    }\n\n    return result;\n}\n// GetExtraRequiredSize isn't used for structures that are value members of other structures\n// because we assume they cannot contain pointers themselves.\nDAWN_UNUSED_FUNC(BufferDestroyGetExtraRequiredSize);\n\nDAWN_DECLARE_UNUSED WireResult BufferDestroySerialize(\n    const BufferDestroyCmd& record,\n    BufferDestroyTransfer* transfer,\n    SerializeBuffer* buffer, const ObjectIdProvider& provider) {\n    DAWN_UNUSED(buffer);\n\n    transfer->commandId = WireCmd::BufferDestroy;\n\n    WIRE_TRY(provider.GetId(record.self, &transfer->self));\n\n\n\n\n    return WireResult::Success;\n}\nDAWN_UNUSED_FUNC(BufferDestroySerialize);\n\nDAWN_DECLARE_UNUSED WireResult BufferDestroyDeserialize(\n    BufferDestroyCmd* record,\n    const volatile BufferDestroyTransfer* transfer,\n    DeserializeBuffer* deserializeBuffer,\n    DeserializeAllocator* allocator, const ObjectIdResolver& resolver) {\n    DAWN_UNUSED(allocator);\n\n    ASSERT(transfer->commandId == WireCmd::BufferDestroy);\n\n    record->selfId = transfer->self;\n\n    WIRE_TRY(resolver.GetFromId(transfer->self, &record->self));\n\n\n\n\n\n    return WireResult::Success;\n}\nDAWN_UNUSED_FUNC(BufferDestroyDeserialize);\n\n            \nstruct BufferMapAsyncTransfer : CmdHeader {\n    static_assert(1 <= 1,\n                  \"Record must be at most one of is_cmd, extensible, and chained.\");\n    WireCmd commandId;\n\n    \nObjectId bufferId;\n    \nuint64_t requestSerial;\n    WGPUMapModeFlags mode;\n    \nuint64_t offset;\n    \nuint64_t size;\n\n\n};\n\nstatic_assert(offsetof(BufferMapAsyncTransfer, commandSize) == 0);\nstatic_assert(offsetof(BufferMapAsyncTransfer, commandId) == sizeof(CmdHeader));\n\n\nDAWN_DECLARE_UNUSED size_t BufferMapAsyncGetExtraRequiredSize(const BufferMapAsyncCmd& record) {\n    DAWN_UNUSED(record);\n\n    size_t result = 0;\n\n\n\n    {\n    }\n    {\n    }\n    {\n    }\n    {\n    }\n    {\n    }\n\n    return result;\n}\n// GetExtraRequiredSize isn't used for structures that are value members of other structures\n// because we assume they cannot contain pointers themselves.\nDAWN_UNUSED_FUNC(BufferMapAsyncGetExtraRequiredSize);\n\nDAWN_DECLARE_UNUSED WireResult BufferMapAsyncSerialize(\n    const BufferMapAsyncCmd& record,\n    BufferMapAsyncTransfer* transfer,\n    SerializeBuffer* buffer) {\n    DAWN_UNUSED(buffer);\n\n    transfer->commandId = WireCmd::BufferMapAsync;\n\n    transfer->bufferId = record.bufferId;\n    transfer->requestSerial = record.requestSerial;\n    transfer->mode = record.mode;\n    transfer->offset = record.offset;\n    transfer->size = record.size;\n\n\n\n\n    return WireResult::Success;\n}\nDAWN_UNUSED_FUNC(BufferMapAsyncSerialize);\n\nDAWN_DECLARE_UNUSED WireResult BufferMapAsyncDeserialize(\n    BufferMapAsyncCmd* record,\n    const volatile BufferMapAsyncTransfer* transfer,\n    DeserializeBuffer* deserializeBuffer,\n    DeserializeAllocator* allocator) {\n    DAWN_UNUSED(allocator);\n\n    ASSERT(transfer->commandId == WireCmd::BufferMapAsync);\n\n\n    static_assert(sizeof(record->bufferId) >= sizeof(transfer->bufferId), \"Deserialize assignment may not narrow.\");\nrecord->bufferId = transfer->bufferId;\n    static_assert(sizeof(record->requestSerial) >= sizeof(transfer->requestSerial), \"Deserialize assignment may not narrow.\");\nrecord->requestSerial = transfer->requestSerial;\n    static_assert(sizeof(record->mode) >= sizeof(transfer->mode), \"Deserialize assignment may not narrow.\");\nrecord->mode = transfer->mode;\n    static_assert(sizeof(record->offset) >= sizeof(transfer->offset), \"Deserialize assignment may not narrow.\");\nrecord->offset = transfer->offset;\n    static_assert(sizeof(record->size) >= sizeof(transfer->size), \"Deserialize assignment may not narrow.\");\nrecord->size = transfer->size;\n\n\n\n\n\n    return WireResult::Success;\n}\nDAWN_UNUSED_FUNC(BufferMapAsyncDeserialize);\n\n            \nstruct BufferSetLabelTransfer : CmdHeader {\n    static_assert(1 <= 1,\n                  \"Record must be at most one of is_cmd, extensible, and chained.\");\n    WireCmd commandId;\n\n    ObjectId self;\n\n    uint64_t labelStrlen;\n\n};\n\nstatic_assert(offsetof(BufferSetLabelTransfer, commandSize) == 0);\nstatic_assert(offsetof(BufferSetLabelTransfer, commandId) == sizeof(CmdHeader));\n\n\nDAWN_DECLARE_UNUSED size_t BufferSetLabelGetExtraRequiredSize(const BufferSetLabelCmd& record) {\n    DAWN_UNUSED(record);\n\n    size_t result = 0;\n\n\n\n    {\n    result += std::strlen(record.label);\n    }\n\n    {\n    }\n\n    return result;\n}\n// GetExtraRequiredSize isn't used for structures that are value members of other structures\n// because we assume they cannot contain pointers themselves.\nDAWN_UNUSED_FUNC(BufferSetLabelGetExtraRequiredSize);\n\nDAWN_DECLARE_UNUSED WireResult BufferSetLabelSerialize(\n    const BufferSetLabelCmd& record,\n    BufferSetLabelTransfer* transfer,\n    SerializeBuffer* buffer, const ObjectIdProvider& provider) {\n    DAWN_UNUSED(buffer);\n\n    transfer->commandId = WireCmd::BufferSetLabel;\n\n    WIRE_TRY(provider.GetId(record.self, &transfer->self));\n\n\n\n\n    {\n        transfer->labelStrlen = std::strlen(record.label);\n\n        char* stringInBuffer;\n        WIRE_TRY(buffer->NextN(transfer->labelStrlen, &stringInBuffer));\n        memcpy(stringInBuffer, record.label, transfer->labelStrlen);\n    }\n\n    return WireResult::Success;\n}\nDAWN_UNUSED_FUNC(BufferSetLabelSerialize);\n\nDAWN_DECLARE_UNUSED WireResult BufferSetLabelDeserialize(\n    BufferSetLabelCmd* record,\n    const volatile BufferSetLabelTransfer* transfer,\n    DeserializeBuffer* deserializeBuffer,\n    DeserializeAllocator* allocator, const ObjectIdResolver& resolver) {\n    DAWN_UNUSED(allocator);\n\n    ASSERT(transfer->commandId == WireCmd::BufferSetLabel);\n\n    record->selfId = transfer->self;\n\n    WIRE_TRY(resolver.GetFromId(transfer->self, &record->self));\n\n\n\n\n    {\n        uint64_t stringLength64 = transfer->labelStrlen;\n        if (stringLength64 >= std::numeric_limits<size_t>::max()) {\n            return WireResult::FatalError;\n        }\n        size_t stringLength = static_cast<size_t>(stringLength64);\n\n        const volatile char* stringInBuffer;\n        WIRE_TRY(deserializeBuffer->ReadN(stringLength, &stringInBuffer));\n\n        char* copiedString;\n        WIRE_TRY(GetSpace(allocator, stringLength + 1, &copiedString));\n        memcpy(copiedString, const_cast<const char*>(stringInBuffer), stringLength);\n        copiedString[stringLength] = '\\0';\n        record->label = copiedString;\n    }\n\n\n    return WireResult::Success;\n}\nDAWN_UNUSED_FUNC(BufferSetLabelDeserialize);\n\n            \nstruct BufferUnmapTransfer : CmdHeader {\n    static_assert(1 <= 1,\n                  \"Record must be at most one of is_cmd, extensible, and chained.\");\n    WireCmd commandId;\n\n    ObjectId self;\n\n\n};\n\nstatic_assert(offsetof(BufferUnmapTransfer, commandSize) == 0);\nstatic_assert(offsetof(BufferUnmapTransfer, commandId) == sizeof(CmdHeader));\n\n\nDAWN_DECLARE_UNUSED size_t BufferUnmapGetExtraRequiredSize(const BufferUnmapCmd& record) {\n    DAWN_UNUSED(record);\n\n    size_t result = 0;\n\n\n\n    {\n    }\n\n    return result;\n}\n// GetExtraRequiredSize isn't used for structures that are value members of other structures\n// because we assume they cannot contain pointers themselves.\nDAWN_UNUSED_FUNC(BufferUnmapGetExtraRequiredSize);\n\nDAWN_DECLARE_UNUSED WireResult BufferUnmapSerialize(\n    const BufferUnmapCmd& record,\n    BufferUnmapTransfer* transfer,\n    SerializeBuffer* buffer, const ObjectIdProvider& provider) {\n    DAWN_UNUSED(buffer);\n\n    transfer->commandId = WireCmd::BufferUnmap;\n\n    WIRE_TRY(provider.GetId(record.self, &transfer->self));\n\n\n\n\n    return WireResult::Success;\n}\nDAWN_UNUSED_FUNC(BufferUnmapSerialize);\n\nDAWN_DECLARE_UNUSED WireResult BufferUnmapDeserialize(\n    BufferUnmapCmd* record,\n    const volatile BufferUnmapTransfer* transfer,\n    DeserializeBuffer* deserializeBuffer,\n    DeserializeAllocator* allocator, const ObjectIdResolver& resolver) {\n    DAWN_UNUSED(allocator);\n\n    ASSERT(transfer->commandId == WireCmd::BufferUnmap);\n\n    record->selfId = transfer->self;\n\n    WIRE_TRY(resolver.GetFromId(transfer->self, &record->self));\n\n\n\n\n\n    return WireResult::Success;\n}\nDAWN_UNUSED_FUNC(BufferUnmapDeserialize);\n\n            \nstruct BufferUpdateMappedDataTransfer : CmdHeader {\n    static_assert(1 <= 1,\n                  \"Record must be at most one of is_cmd, extensible, and chained.\");\n    WireCmd commandId;\n\n    \nObjectId bufferId;\n    \nuint64_t writeDataUpdateInfoLength;\n    \nuint64_t offset;\n    \nuint64_t size;\n\n\n};\n\nstatic_assert(offsetof(BufferUpdateMappedDataTransfer, commandSize) == 0);\nstatic_assert(offsetof(BufferUpdateMappedDataTransfer, commandId) == sizeof(CmdHeader));\n\n\nDAWN_DECLARE_UNUSED size_t BufferUpdateMappedDataGetExtraRequiredSize(const BufferUpdateMappedDataCmd& record) {\n    DAWN_UNUSED(record);\n\n    size_t result = 0;\n\n\n\n    {\n    }\n    {\n    }\n    {\n    }\n    {\n    }\n\n    return result;\n}\n// GetExtraRequiredSize isn't used for structures that are value members of other structures\n// because we assume they cannot contain pointers themselves.\nDAWN_UNUSED_FUNC(BufferUpdateMappedDataGetExtraRequiredSize);\n\nDAWN_DECLARE_UNUSED WireResult BufferUpdateMappedDataSerialize(\n    const BufferUpdateMappedDataCmd& record,\n    BufferUpdateMappedDataTransfer* transfer,\n    SerializeBuffer* buffer) {\n    DAWN_UNUSED(buffer);\n\n    transfer->commandId = WireCmd::BufferUpdateMappedData;\n\n    transfer->bufferId = record.bufferId;\n    transfer->writeDataUpdateInfoLength = record.writeDataUpdateInfoLength;\n    transfer->offset = record.offset;\n    transfer->size = record.size;\n\n\n\n\n    return WireResult::Success;\n}\nDAWN_UNUSED_FUNC(BufferUpdateMappedDataSerialize);\n\nDAWN_DECLARE_UNUSED WireResult BufferUpdateMappedDataDeserialize(\n    BufferUpdateMappedDataCmd* record,\n    const volatile BufferUpdateMappedDataTransfer* transfer,\n    DeserializeBuffer* deserializeBuffer,\n    DeserializeAllocator* allocator) {\n    DAWN_UNUSED(allocator);\n\n    ASSERT(transfer->commandId == WireCmd::BufferUpdateMappedData);\n\n\n    static_assert(sizeof(record->bufferId) >= sizeof(transfer->bufferId), \"Deserialize assignment may not narrow.\");\nrecord->bufferId = transfer->bufferId;\n    static_assert(sizeof(record->writeDataUpdateInfoLength) >= sizeof(transfer->writeDataUpdateInfoLength), \"Deserialize assignment may not narrow.\");\nrecord->writeDataUpdateInfoLength = transfer->writeDataUpdateInfoLength;\n    static_assert(sizeof(record->offset) >= sizeof(transfer->offset), \"Deserialize assignment may not narrow.\");\nrecord->offset = transfer->offset;\n    static_assert(sizeof(record->size) >= sizeof(transfer->size), \"Deserialize assignment may not narrow.\");\nrecord->size = transfer->size;\n\n\n\n\n    \n\n    {\n        auto memberLength = record->writeDataUpdateInfoLength;\n        const volatile \nuint8_t* memberBuffer;\n        WIRE_TRY(deserializeBuffer->ReadN(memberLength, &memberBuffer));\n\n        uint8_t* copiedMembers;\n        WIRE_TRY(GetSpace(allocator, memberLength, &copiedMembers));\n        record->writeDataUpdateInfo = copiedMembers;\n\n        memcpy(\n            copiedMembers,\n            const_cast<const \nuint8_t*>(memberBuffer),\n           sizeof(\nuint8_t) * memberLength);\n    }\n\n    return WireResult::Success;\n}\nDAWN_UNUSED_FUNC(BufferUpdateMappedDataDeserialize);\n\n            \nstruct CommandBufferSetLabelTransfer : CmdHeader {\n    static_assert(1 <= 1,\n                  \"Record must be at most one of is_cmd, extensible, and chained.\");\n    WireCmd commandId;\n\n    ObjectId self;\n\n    uint64_t labelStrlen;\n\n};\n\nstatic_assert(offsetof(CommandBufferSetLabelTransfer, commandSize) == 0);\nstatic_assert(offsetof(CommandBufferSetLabelTransfer, commandId) == sizeof(CmdHeader));\n\n\nDAWN_DECLARE_UNUSED size_t CommandBufferSetLabelGetExtraRequiredSize(const CommandBufferSetLabelCmd& record) {\n    DAWN_UNUSED(record);\n\n    size_t result = 0;\n\n\n\n    {\n    result += std::strlen(record.label);\n    }\n\n    {\n    }\n\n    return result;\n}\n// GetExtraRequiredSize isn't used for structures that are value members of other structures\n// because we assume they cannot contain pointers themselves.\nDAWN_UNUSED_FUNC(CommandBufferSetLabelGetExtraRequiredSize);\n\nDAWN_DECLARE_UNUSED WireResult CommandBufferSetLabelSerialize(\n    const CommandBufferSetLabelCmd& record,\n    CommandBufferSetLabelTransfer* transfer,\n    SerializeBuffer* buffer, const ObjectIdProvider& provider) {\n    DAWN_UNUSED(buffer);\n\n    transfer->commandId = WireCmd::CommandBufferSetLabel;\n\n    WIRE_TRY(provider.GetId(record.self, &transfer->self));\n\n\n\n\n    {\n        transfer->labelStrlen = std::strlen(record.label);\n\n        char* stringInBuffer;\n        WIRE_TRY(buffer->NextN(transfer->labelStrlen, &stringInBuffer));\n        memcpy(stringInBuffer, record.label, transfer->labelStrlen);\n    }\n\n    return WireResult::Success;\n}\nDAWN_UNUSED_FUNC(CommandBufferSetLabelSerialize);\n\nDAWN_DECLARE_UNUSED WireResult CommandBufferSetLabelDeserialize(\n    CommandBufferSetLabelCmd* record,\n    const volatile CommandBufferSetLabelTransfer* transfer,\n    DeserializeBuffer* deserializeBuffer,\n    DeserializeAllocator* allocator, const ObjectIdResolver& resolver) {\n    DAWN_UNUSED(allocator);\n\n    ASSERT(transfer->commandId == WireCmd::CommandBufferSetLabel);\n\n    record->selfId = transfer->self;\n\n    WIRE_TRY(resolver.GetFromId(transfer->self, &record->self));\n\n\n\n\n    {\n        uint64_t stringLength64 = transfer->labelStrlen;\n        if (stringLength64 >= std::numeric_limits<size_t>::max()) {\n            return WireResult::FatalError;\n        }\n        size_t stringLength = static_cast<size_t>(stringLength64);\n\n        const volatile char* stringInBuffer;\n        WIRE_TRY(deserializeBuffer->ReadN(stringLength, &stringInBuffer));\n\n        char* copiedString;\n        WIRE_TRY(GetSpace(allocator, stringLength + 1, &copiedString));\n        memcpy(copiedString, const_cast<const char*>(stringInBuffer), stringLength);\n        copiedString[stringLength] = '\\0';\n        record->label = copiedString;\n    }\n\n\n    return WireResult::Success;\n}\nDAWN_UNUSED_FUNC(CommandBufferSetLabelDeserialize);\n\n            \nstruct CommandEncoderBeginComputePassTransfer : CmdHeader {\n    static_assert(1 <= 1,\n                  \"Record must be at most one of is_cmd, extensible, and chained.\");\n    WireCmd commandId;\n\n    ObjectId self;\n    \nObjectHandle result;\n\n\n    bool has_descriptor;\n};\n\nstatic_assert(offsetof(CommandEncoderBeginComputePassTransfer, commandSize) == 0);\nstatic_assert(offsetof(CommandEncoderBeginComputePassTransfer, commandId) == sizeof(CmdHeader));\n\n\nDAWN_DECLARE_UNUSED size_t CommandEncoderBeginComputePassGetExtraRequiredSize(const CommandEncoderBeginComputePassCmd& record) {\n    DAWN_UNUSED(record);\n\n    size_t result = 0;\n\n\n\n    {\n    }\n    if (record.descriptor != nullptr)\n    {\n        \n        auto memberLength = 1u;\n        result += memberLength * sizeof(WGPUComputePassDescriptorTransfer);\n        for (decltype(memberLength) i = 0; i < memberLength; ++i) {\n            \n            result += WGPUComputePassDescriptorGetExtraRequiredSize(record.descriptor[i]);\n        }\n    }\n    {\n    }\n\n    return result;\n}\n// GetExtraRequiredSize isn't used for structures that are value members of other structures\n// because we assume they cannot contain pointers themselves.\nDAWN_UNUSED_FUNC(CommandEncoderBeginComputePassGetExtraRequiredSize);\n\nDAWN_DECLARE_UNUSED WireResult CommandEncoderBeginComputePassSerialize(\n    const CommandEncoderBeginComputePassCmd& record,\n    CommandEncoderBeginComputePassTransfer* transfer,\n    SerializeBuffer* buffer, const ObjectIdProvider& provider) {\n    DAWN_UNUSED(buffer);\n\n    transfer->commandId = WireCmd::CommandEncoderBeginComputePass;\n\n    WIRE_TRY(provider.GetId(record.self, &transfer->self));\n    transfer->result = record.result;\n\n\n\n\n    \n\n    bool has_descriptor = record.descriptor != nullptr;\n    transfer->has_descriptor = has_descriptor;\n    if (has_descriptor)\n    {\n        auto memberLength = 1u;\n\n        WGPUComputePassDescriptorTransfer* memberBuffer;\n        WIRE_TRY(buffer->NextN(memberLength, &memberBuffer));\n\n        for (decltype(memberLength) i = 0; i < memberLength; ++i) {\n            WIRE_TRY(WGPUComputePassDescriptorSerialize(record.descriptor[i], &memberBuffer[i], buffer, provider));\n        }\n    }\n    return WireResult::Success;\n}\nDAWN_UNUSED_FUNC(CommandEncoderBeginComputePassSerialize);\n\nDAWN_DECLARE_UNUSED WireResult CommandEncoderBeginComputePassDeserialize(\n    CommandEncoderBeginComputePassCmd* record,\n    const volatile CommandEncoderBeginComputePassTransfer* transfer,\n    DeserializeBuffer* deserializeBuffer,\n    DeserializeAllocator* allocator, const ObjectIdResolver& resolver) {\n    DAWN_UNUSED(allocator);\n\n    ASSERT(transfer->commandId == WireCmd::CommandEncoderBeginComputePass);\n\n    record->selfId = transfer->self;\n\n    WIRE_TRY(resolver.GetFromId(transfer->self, &record->self));\n    static_assert(sizeof(record->result) >= sizeof(transfer->result), \"Deserialize assignment may not narrow.\");\nrecord->result = transfer->result;\n\n\n\n\n    \n\n    \n    bool has_descriptor = transfer->has_descriptor;\n    record->descriptor = nullptr;\n    if (has_descriptor)\n    {\n        auto memberLength = 1u;\n        const volatile WGPUComputePassDescriptorTransfer* memberBuffer;\n        WIRE_TRY(deserializeBuffer->ReadN(memberLength, &memberBuffer));\n\n        WGPUComputePassDescriptor* copiedMembers;\n        WIRE_TRY(GetSpace(allocator, memberLength, &copiedMembers));\n        record->descriptor = copiedMembers;\n\n        for (decltype(memberLength) i = 0; i < memberLength; ++i) {\n            WIRE_TRY(WGPUComputePassDescriptorDeserialize(&copiedMembers[i], &memberBuffer[i], deserializeBuffer, allocator, resolver));\n        }\n    }\n\n    return WireResult::Success;\n}\nDAWN_UNUSED_FUNC(CommandEncoderBeginComputePassDeserialize);\n\n            \nstruct CommandEncoderBeginRenderPassTransfer : CmdHeader {\n    static_assert(1 <= 1,\n                  \"Record must be at most one of is_cmd, extensible, and chained.\");\n    WireCmd commandId;\n\n    ObjectId self;\n    \nObjectHandle result;\n\n\n};\n\nstatic_assert(offsetof(CommandEncoderBeginRenderPassTransfer, commandSize) == 0);\nstatic_assert(offsetof(CommandEncoderBeginRenderPassTransfer, commandId) == sizeof(CmdHeader));\n\n\nDAWN_DECLARE_UNUSED size_t CommandEncoderBeginRenderPassGetExtraRequiredSize(const CommandEncoderBeginRenderPassCmd& record) {\n    DAWN_UNUSED(record);\n\n    size_t result = 0;\n\n\n\n    {\n    }\n    {\n        \n        auto memberLength = 1u;\n        result += memberLength * sizeof(WGPURenderPassDescriptorTransfer);\n        for (decltype(memberLength) i = 0; i < memberLength; ++i) {\n            \n            result += WGPURenderPassDescriptorGetExtraRequiredSize(record.descriptor[i]);\n        }\n    }\n    {\n    }\n\n    return result;\n}\n// GetExtraRequiredSize isn't used for structures that are value members of other structures\n// because we assume they cannot contain pointers themselves.\nDAWN_UNUSED_FUNC(CommandEncoderBeginRenderPassGetExtraRequiredSize);\n\nDAWN_DECLARE_UNUSED WireResult CommandEncoderBeginRenderPassSerialize(\n    const CommandEncoderBeginRenderPassCmd& record,\n    CommandEncoderBeginRenderPassTransfer* transfer,\n    SerializeBuffer* buffer, const ObjectIdProvider& provider) {\n    DAWN_UNUSED(buffer);\n\n    transfer->commandId = WireCmd::CommandEncoderBeginRenderPass;\n\n    WIRE_TRY(provider.GetId(record.self, &transfer->self));\n    transfer->result = record.result;\n\n\n\n\n    \n\n    {\n        auto memberLength = 1u;\n\n        WGPURenderPassDescriptorTransfer* memberBuffer;\n        WIRE_TRY(buffer->NextN(memberLength, &memberBuffer));\n\n        for (decltype(memberLength) i = 0; i < memberLength; ++i) {\n            WIRE_TRY(WGPURenderPassDescriptorSerialize(record.descriptor[i], &memberBuffer[i], buffer, provider));\n        }\n    }\n    return WireResult::Success;\n}\nDAWN_UNUSED_FUNC(CommandEncoderBeginRenderPassSerialize);\n\nDAWN_DECLARE_UNUSED WireResult CommandEncoderBeginRenderPassDeserialize(\n    CommandEncoderBeginRenderPassCmd* record,\n    const volatile CommandEncoderBeginRenderPassTransfer* transfer,\n    DeserializeBuffer* deserializeBuffer,\n    DeserializeAllocator* allocator, const ObjectIdResolver& resolver) {\n    DAWN_UNUSED(allocator);\n\n    ASSERT(transfer->commandId == WireCmd::CommandEncoderBeginRenderPass);\n\n    record->selfId = transfer->self;\n\n    WIRE_TRY(resolver.GetFromId(transfer->self, &record->self));\n    static_assert(sizeof(record->result) >= sizeof(transfer->result), \"Deserialize assignment may not narrow.\");\nrecord->result = transfer->result;\n\n\n\n\n    \n\n    {\n        auto memberLength = 1u;\n        const volatile WGPURenderPassDescriptorTransfer* memberBuffer;\n        WIRE_TRY(deserializeBuffer->ReadN(memberLength, &memberBuffer));\n\n        WGPURenderPassDescriptor* copiedMembers;\n        WIRE_TRY(GetSpace(allocator, memberLength, &copiedMembers));\n        record->descriptor = copiedMembers;\n\n        for (decltype(memberLength) i = 0; i < memberLength; ++i) {\n            WIRE_TRY(WGPURenderPassDescriptorDeserialize(&copiedMembers[i], &memberBuffer[i], deserializeBuffer, allocator, resolver));\n        }\n    }\n\n    return WireResult::Success;\n}\nDAWN_UNUSED_FUNC(CommandEncoderBeginRenderPassDeserialize);\n\n            \nstruct CommandEncoderClearBufferTransfer : CmdHeader {\n    static_assert(1 <= 1,\n                  \"Record must be at most one of is_cmd, extensible, and chained.\");\n    WireCmd commandId;\n\n    ObjectId self;\n    ObjectId buffer;\n    \nuint64_t offset;\n    \nuint64_t size;\n\n\n};\n\nstatic_assert(offsetof(CommandEncoderClearBufferTransfer, commandSize) == 0);\nstatic_assert(offsetof(CommandEncoderClearBufferTransfer, commandId) == sizeof(CmdHeader));\n\n\nDAWN_DECLARE_UNUSED size_t CommandEncoderClearBufferGetExtraRequiredSize(const CommandEncoderClearBufferCmd& record) {\n    DAWN_UNUSED(record);\n\n    size_t result = 0;\n\n\n\n    {\n    }\n    {\n    }\n    {\n    }\n    {\n    }\n\n    return result;\n}\n// GetExtraRequiredSize isn't used for structures that are value members of other structures\n// because we assume they cannot contain pointers themselves.\nDAWN_UNUSED_FUNC(CommandEncoderClearBufferGetExtraRequiredSize);\n\nDAWN_DECLARE_UNUSED WireResult CommandEncoderClearBufferSerialize(\n    const CommandEncoderClearBufferCmd& record,\n    CommandEncoderClearBufferTransfer* transfer,\n    SerializeBuffer* buffer, const ObjectIdProvider& provider) {\n    DAWN_UNUSED(buffer);\n\n    transfer->commandId = WireCmd::CommandEncoderClearBuffer;\n\n    WIRE_TRY(provider.GetId(record.self, &transfer->self));\n    WIRE_TRY(provider.GetId(record.buffer, &transfer->buffer));\n    transfer->offset = record.offset;\n    transfer->size = record.size;\n\n\n\n\n    return WireResult::Success;\n}\nDAWN_UNUSED_FUNC(CommandEncoderClearBufferSerialize);\n\nDAWN_DECLARE_UNUSED WireResult CommandEncoderClearBufferDeserialize(\n    CommandEncoderClearBufferCmd* record,\n    const volatile CommandEncoderClearBufferTransfer* transfer,\n    DeserializeBuffer* deserializeBuffer,\n    DeserializeAllocator* allocator, const ObjectIdResolver& resolver) {\n    DAWN_UNUSED(allocator);\n\n    ASSERT(transfer->commandId == WireCmd::CommandEncoderClearBuffer);\n\n    record->selfId = transfer->self;\n\n    WIRE_TRY(resolver.GetFromId(transfer->self, &record->self));\n    WIRE_TRY(resolver.GetFromId(transfer->buffer, &record->buffer));\n    static_assert(sizeof(record->offset) >= sizeof(transfer->offset), \"Deserialize assignment may not narrow.\");\nrecord->offset = transfer->offset;\n    static_assert(sizeof(record->size) >= sizeof(transfer->size), \"Deserialize assignment may not narrow.\");\nrecord->size = transfer->size;\n\n\n\n\n\n    return WireResult::Success;\n}\nDAWN_UNUSED_FUNC(CommandEncoderClearBufferDeserialize);\n\n            \nstruct CommandEncoderCopyBufferToBufferTransfer : CmdHeader {\n    static_assert(1 <= 1,\n                  \"Record must be at most one of is_cmd, extensible, and chained.\");\n    WireCmd commandId;\n\n    ObjectId self;\n    ObjectId source;\n    \nuint64_t sourceOffset;\n    ObjectId destination;\n    \nuint64_t destinationOffset;\n    \nuint64_t size;\n\n\n};\n\nstatic_assert(offsetof(CommandEncoderCopyBufferToBufferTransfer, commandSize) == 0);\nstatic_assert(offsetof(CommandEncoderCopyBufferToBufferTransfer, commandId) == sizeof(CmdHeader));\n\n\nDAWN_DECLARE_UNUSED size_t CommandEncoderCopyBufferToBufferGetExtraRequiredSize(const CommandEncoderCopyBufferToBufferCmd& record) {\n    DAWN_UNUSED(record);\n\n    size_t result = 0;\n\n\n\n    {\n    }\n    {\n    }\n    {\n    }\n    {\n    }\n    {\n    }\n    {\n    }\n\n    return result;\n}\n// GetExtraRequiredSize isn't used for structures that are value members of other structures\n// because we assume they cannot contain pointers themselves.\nDAWN_UNUSED_FUNC(CommandEncoderCopyBufferToBufferGetExtraRequiredSize);\n\nDAWN_DECLARE_UNUSED WireResult CommandEncoderCopyBufferToBufferSerialize(\n    const CommandEncoderCopyBufferToBufferCmd& record,\n    CommandEncoderCopyBufferToBufferTransfer* transfer,\n    SerializeBuffer* buffer, const ObjectIdProvider& provider) {\n    DAWN_UNUSED(buffer);\n\n    transfer->commandId = WireCmd::CommandEncoderCopyBufferToBuffer;\n\n    WIRE_TRY(provider.GetId(record.self, &transfer->self));\n    WIRE_TRY(provider.GetId(record.source, &transfer->source));\n    transfer->sourceOffset = record.sourceOffset;\n    WIRE_TRY(provider.GetId(record.destination, &transfer->destination));\n    transfer->destinationOffset = record.destinationOffset;\n    transfer->size = record.size;\n\n\n\n\n    return WireResult::Success;\n}\nDAWN_UNUSED_FUNC(CommandEncoderCopyBufferToBufferSerialize);\n\nDAWN_DECLARE_UNUSED WireResult CommandEncoderCopyBufferToBufferDeserialize(\n    CommandEncoderCopyBufferToBufferCmd* record,\n    const volatile CommandEncoderCopyBufferToBufferTransfer* transfer,\n    DeserializeBuffer* deserializeBuffer,\n    DeserializeAllocator* allocator, const ObjectIdResolver& resolver) {\n    DAWN_UNUSED(allocator);\n\n    ASSERT(transfer->commandId == WireCmd::CommandEncoderCopyBufferToBuffer);\n\n    record->selfId = transfer->self;\n\n    WIRE_TRY(resolver.GetFromId(transfer->self, &record->self));\n    WIRE_TRY(resolver.GetFromId(transfer->source, &record->source));\n    static_assert(sizeof(record->sourceOffset) >= sizeof(transfer->sourceOffset), \"Deserialize assignment may not narrow.\");\nrecord->sourceOffset = transfer->sourceOffset;\n    WIRE_TRY(resolver.GetFromId(transfer->destination, &record->destination));\n    static_assert(sizeof(record->destinationOffset) >= sizeof(transfer->destinationOffset), \"Deserialize assignment may not narrow.\");\nrecord->destinationOffset = transfer->destinationOffset;\n    static_assert(sizeof(record->size) >= sizeof(transfer->size), \"Deserialize assignment may not narrow.\");\nrecord->size = transfer->size;\n\n\n\n\n\n    return WireResult::Success;\n}\nDAWN_UNUSED_FUNC(CommandEncoderCopyBufferToBufferDeserialize);\n\n            \nstruct CommandEncoderCopyBufferToTextureTransfer : CmdHeader {\n    static_assert(1 <= 1,\n                  \"Record must be at most one of is_cmd, extensible, and chained.\");\n    WireCmd commandId;\n\n    ObjectId self;\n\n\n};\n\nstatic_assert(offsetof(CommandEncoderCopyBufferToTextureTransfer, commandSize) == 0);\nstatic_assert(offsetof(CommandEncoderCopyBufferToTextureTransfer, commandId) == sizeof(CmdHeader));\n\n\nDAWN_DECLARE_UNUSED size_t CommandEncoderCopyBufferToTextureGetExtraRequiredSize(const CommandEncoderCopyBufferToTextureCmd& record) {\n    DAWN_UNUSED(record);\n\n    size_t result = 0;\n\n\n\n    {\n    }\n    {\n        \n        auto memberLength = 1u;\n        result += memberLength * sizeof(WGPUImageCopyBufferTransfer);\n        for (decltype(memberLength) i = 0; i < memberLength; ++i) {\n            \n            result += WGPUImageCopyBufferGetExtraRequiredSize(record.source[i]);\n        }\n    }\n    {\n        \n        auto memberLength = 1u;\n        result += memberLength * sizeof(WGPUImageCopyTextureTransfer);\n        for (decltype(memberLength) i = 0; i < memberLength; ++i) {\n            \n            result += WGPUImageCopyTextureGetExtraRequiredSize(record.destination[i]);\n        }\n    }\n    {\n        \n        auto memberLength = 1u;\n        result += memberLength * sizeof(WGPUExtent3DTransfer);\n        for (decltype(memberLength) i = 0; i < memberLength; ++i) {\n            \n            result += WGPUExtent3DGetExtraRequiredSize(record.copySize[i]);\n        }\n    }\n\n    return result;\n}\n// GetExtraRequiredSize isn't used for structures that are value members of other structures\n// because we assume they cannot contain pointers themselves.\nDAWN_UNUSED_FUNC(CommandEncoderCopyBufferToTextureGetExtraRequiredSize);\n\nDAWN_DECLARE_UNUSED WireResult CommandEncoderCopyBufferToTextureSerialize(\n    const CommandEncoderCopyBufferToTextureCmd& record,\n    CommandEncoderCopyBufferToTextureTransfer* transfer,\n    SerializeBuffer* buffer, const ObjectIdProvider& provider) {\n    DAWN_UNUSED(buffer);\n\n    transfer->commandId = WireCmd::CommandEncoderCopyBufferToTexture;\n\n    WIRE_TRY(provider.GetId(record.self, &transfer->self));\n\n\n\n\n    \n\n    {\n        auto memberLength = 1u;\n\n        WGPUImageCopyBufferTransfer* memberBuffer;\n        WIRE_TRY(buffer->NextN(memberLength, &memberBuffer));\n\n        for (decltype(memberLength) i = 0; i < memberLength; ++i) {\n            WIRE_TRY(WGPUImageCopyBufferSerialize(record.source[i], &memberBuffer[i], buffer, provider));\n        }\n    }\n    \n\n    {\n        auto memberLength = 1u;\n\n        WGPUImageCopyTextureTransfer* memberBuffer;\n        WIRE_TRY(buffer->NextN(memberLength, &memberBuffer));\n\n        for (decltype(memberLength) i = 0; i < memberLength; ++i) {\n            WIRE_TRY(WGPUImageCopyTextureSerialize(record.destination[i], &memberBuffer[i], buffer, provider));\n        }\n    }\n    \n\n    {\n        auto memberLength = 1u;\n\n        WGPUExtent3DTransfer* memberBuffer;\n        WIRE_TRY(buffer->NextN(memberLength, &memberBuffer));\n\n        memcpy(\n            memberBuffer, record.copySize,\n            sizeof(WGPUExtent3DTransfer) * memberLength);\n    }\n    return WireResult::Success;\n}\nDAWN_UNUSED_FUNC(CommandEncoderCopyBufferToTextureSerialize);\n\nDAWN_DECLARE_UNUSED WireResult CommandEncoderCopyBufferToTextureDeserialize(\n    CommandEncoderCopyBufferToTextureCmd* record,\n    const volatile CommandEncoderCopyBufferToTextureTransfer* transfer,\n    DeserializeBuffer* deserializeBuffer,\n    DeserializeAllocator* allocator, const ObjectIdResolver& resolver) {\n    DAWN_UNUSED(allocator);\n\n    ASSERT(transfer->commandId == WireCmd::CommandEncoderCopyBufferToTexture);\n\n    record->selfId = transfer->self;\n\n    WIRE_TRY(resolver.GetFromId(transfer->self, &record->self));\n\n\n\n\n    \n\n    {\n        auto memberLength = 1u;\n        const volatile WGPUImageCopyBufferTransfer* memberBuffer;\n        WIRE_TRY(deserializeBuffer->ReadN(memberLength, &memberBuffer));\n\n        WGPUImageCopyBuffer* copiedMembers;\n        WIRE_TRY(GetSpace(allocator, memberLength, &copiedMembers));\n        record->source = copiedMembers;\n\n        for (decltype(memberLength) i = 0; i < memberLength; ++i) {\n            WIRE_TRY(WGPUImageCopyBufferDeserialize(&copiedMembers[i], &memberBuffer[i], deserializeBuffer, allocator, resolver));\n        }\n    }\n    \n\n    {\n        auto memberLength = 1u;\n        const volatile WGPUImageCopyTextureTransfer* memberBuffer;\n        WIRE_TRY(deserializeBuffer->ReadN(memberLength, &memberBuffer));\n\n        WGPUImageCopyTexture* copiedMembers;\n        WIRE_TRY(GetSpace(allocator, memberLength, &copiedMembers));\n        record->destination = copiedMembers;\n\n        for (decltype(memberLength) i = 0; i < memberLength; ++i) {\n            WIRE_TRY(WGPUImageCopyTextureDeserialize(&copiedMembers[i], &memberBuffer[i], deserializeBuffer, allocator, resolver));\n        }\n    }\n    \n\n    {\n        auto memberLength = 1u;\n        const volatile WGPUExtent3DTransfer* memberBuffer;\n        WIRE_TRY(deserializeBuffer->ReadN(memberLength, &memberBuffer));\n\n        WGPUExtent3D* copiedMembers;\n        WIRE_TRY(GetSpace(allocator, memberLength, &copiedMembers));\n        record->copySize = copiedMembers;\n\n        memcpy(\n            copiedMembers,\n            const_cast<const WGPUExtent3DTransfer*>(memberBuffer),\n           sizeof(WGPUExtent3DTransfer) * memberLength);\n    }\n\n    return WireResult::Success;\n}\nDAWN_UNUSED_FUNC(CommandEncoderCopyBufferToTextureDeserialize);\n\n            \nstruct CommandEncoderCopyTextureToBufferTransfer : CmdHeader {\n    static_assert(1 <= 1,\n                  \"Record must be at most one of is_cmd, extensible, and chained.\");\n    WireCmd commandId;\n\n    ObjectId self;\n\n\n};\n\nstatic_assert(offsetof(CommandEncoderCopyTextureToBufferTransfer, commandSize) == 0);\nstatic_assert(offsetof(CommandEncoderCopyTextureToBufferTransfer, commandId) == sizeof(CmdHeader));\n\n\nDAWN_DECLARE_UNUSED size_t CommandEncoderCopyTextureToBufferGetExtraRequiredSize(const CommandEncoderCopyTextureToBufferCmd& record) {\n    DAWN_UNUSED(record);\n\n    size_t result = 0;\n\n\n\n    {\n    }\n    {\n        \n        auto memberLength = 1u;\n        result += memberLength * sizeof(WGPUImageCopyTextureTransfer);\n        for (decltype(memberLength) i = 0; i < memberLength; ++i) {\n            \n            result += WGPUImageCopyTextureGetExtraRequiredSize(record.source[i]);\n        }\n    }\n    {\n        \n        auto memberLength = 1u;\n        result += memberLength * sizeof(WGPUImageCopyBufferTransfer);\n        for (decltype(memberLength) i = 0; i < memberLength; ++i) {\n            \n            result += WGPUImageCopyBufferGetExtraRequiredSize(record.destination[i]);\n        }\n    }\n    {\n        \n        auto memberLength = 1u;\n        result += memberLength * sizeof(WGPUExtent3DTransfer);\n        for (decltype(memberLength) i = 0; i < memberLength; ++i) {\n            \n            result += WGPUExtent3DGetExtraRequiredSize(record.copySize[i]);\n        }\n    }\n\n    return result;\n}\n// GetExtraRequiredSize isn't used for structures that are value members of other structures\n// because we assume they cannot contain pointers themselves.\nDAWN_UNUSED_FUNC(CommandEncoderCopyTextureToBufferGetExtraRequiredSize);\n\nDAWN_DECLARE_UNUSED WireResult CommandEncoderCopyTextureToBufferSerialize(\n    const CommandEncoderCopyTextureToBufferCmd& record,\n    CommandEncoderCopyTextureToBufferTransfer* transfer,\n    SerializeBuffer* buffer, const ObjectIdProvider& provider) {\n    DAWN_UNUSED(buffer);\n\n    transfer->commandId = WireCmd::CommandEncoderCopyTextureToBuffer;\n\n    WIRE_TRY(provider.GetId(record.self, &transfer->self));\n\n\n\n\n    \n\n    {\n        auto memberLength = 1u;\n\n        WGPUImageCopyTextureTransfer* memberBuffer;\n        WIRE_TRY(buffer->NextN(memberLength, &memberBuffer));\n\n        for (decltype(memberLength) i = 0; i < memberLength; ++i) {\n            WIRE_TRY(WGPUImageCopyTextureSerialize(record.source[i], &memberBuffer[i], buffer, provider));\n        }\n    }\n    \n\n    {\n        auto memberLength = 1u;\n\n        WGPUImageCopyBufferTransfer* memberBuffer;\n        WIRE_TRY(buffer->NextN(memberLength, &memberBuffer));\n\n        for (decltype(memberLength) i = 0; i < memberLength; ++i) {\n            WIRE_TRY(WGPUImageCopyBufferSerialize(record.destination[i], &memberBuffer[i], buffer, provider));\n        }\n    }\n    \n\n    {\n        auto memberLength = 1u;\n\n        WGPUExtent3DTransfer* memberBuffer;\n        WIRE_TRY(buffer->NextN(memberLength, &memberBuffer));\n\n        memcpy(\n            memberBuffer, record.copySize,\n            sizeof(WGPUExtent3DTransfer) * memberLength);\n    }\n    return WireResult::Success;\n}\nDAWN_UNUSED_FUNC(CommandEncoderCopyTextureToBufferSerialize);\n\nDAWN_DECLARE_UNUSED WireResult CommandEncoderCopyTextureToBufferDeserialize(\n    CommandEncoderCopyTextureToBufferCmd* record,\n    const volatile CommandEncoderCopyTextureToBufferTransfer* transfer,\n    DeserializeBuffer* deserializeBuffer,\n    DeserializeAllocator* allocator, const ObjectIdResolver& resolver) {\n    DAWN_UNUSED(allocator);\n\n    ASSERT(transfer->commandId == WireCmd::CommandEncoderCopyTextureToBuffer);\n\n    record->selfId = transfer->self;\n\n    WIRE_TRY(resolver.GetFromId(transfer->self, &record->self));\n\n\n\n\n    \n\n    {\n        auto memberLength = 1u;\n        const volatile WGPUImageCopyTextureTransfer* memberBuffer;\n        WIRE_TRY(deserializeBuffer->ReadN(memberLength, &memberBuffer));\n\n        WGPUImageCopyTexture* copiedMembers;\n        WIRE_TRY(GetSpace(allocator, memberLength, &copiedMembers));\n        record->source = copiedMembers;\n\n        for (decltype(memberLength) i = 0; i < memberLength; ++i) {\n            WIRE_TRY(WGPUImageCopyTextureDeserialize(&copiedMembers[i], &memberBuffer[i], deserializeBuffer, allocator, resolver));\n        }\n    }\n    \n\n    {\n        auto memberLength = 1u;\n        const volatile WGPUImageCopyBufferTransfer* memberBuffer;\n        WIRE_TRY(deserializeBuffer->ReadN(memberLength, &memberBuffer));\n\n        WGPUImageCopyBuffer* copiedMembers;\n        WIRE_TRY(GetSpace(allocator, memberLength, &copiedMembers));\n        record->destination = copiedMembers;\n\n        for (decltype(memberLength) i = 0; i < memberLength; ++i) {\n            WIRE_TRY(WGPUImageCopyBufferDeserialize(&copiedMembers[i], &memberBuffer[i], deserializeBuffer, allocator, resolver));\n        }\n    }\n    \n\n    {\n        auto memberLength = 1u;\n        const volatile WGPUExtent3DTransfer* memberBuffer;\n        WIRE_TRY(deserializeBuffer->ReadN(memberLength, &memberBuffer));\n\n        WGPUExtent3D* copiedMembers;\n        WIRE_TRY(GetSpace(allocator, memberLength, &copiedMembers));\n        record->copySize = copiedMembers;\n\n        memcpy(\n            copiedMembers,\n            const_cast<const WGPUExtent3DTransfer*>(memberBuffer),\n           sizeof(WGPUExtent3DTransfer) * memberLength);\n    }\n\n    return WireResult::Success;\n}\nDAWN_UNUSED_FUNC(CommandEncoderCopyTextureToBufferDeserialize);\n\n            \nstruct CommandEncoderCopyTextureToTextureTransfer : CmdHeader {\n    static_assert(1 <= 1,\n                  \"Record must be at most one of is_cmd, extensible, and chained.\");\n    WireCmd commandId;\n\n    ObjectId self;\n\n\n};\n\nstatic_assert(offsetof(CommandEncoderCopyTextureToTextureTransfer, commandSize) == 0);\nstatic_assert(offsetof(CommandEncoderCopyTextureToTextureTransfer, commandId) == sizeof(CmdHeader));\n\n\nDAWN_DECLARE_UNUSED size_t CommandEncoderCopyTextureToTextureGetExtraRequiredSize(const CommandEncoderCopyTextureToTextureCmd& record) {\n    DAWN_UNUSED(record);\n\n    size_t result = 0;\n\n\n\n    {\n    }\n    {\n        \n        auto memberLength = 1u;\n        result += memberLength * sizeof(WGPUImageCopyTextureTransfer);\n        for (decltype(memberLength) i = 0; i < memberLength; ++i) {\n            \n            result += WGPUImageCopyTextureGetExtraRequiredSize(record.source[i]);\n        }\n    }\n    {\n        \n        auto memberLength = 1u;\n        result += memberLength * sizeof(WGPUImageCopyTextureTransfer);\n        for (decltype(memberLength) i = 0; i < memberLength; ++i) {\n            \n            result += WGPUImageCopyTextureGetExtraRequiredSize(record.destination[i]);\n        }\n    }\n    {\n        \n        auto memberLength = 1u;\n        result += memberLength * sizeof(WGPUExtent3DTransfer);\n        for (decltype(memberLength) i = 0; i < memberLength; ++i) {\n            \n            result += WGPUExtent3DGetExtraRequiredSize(record.copySize[i]);\n        }\n    }\n\n    return result;\n}\n// GetExtraRequiredSize isn't used for structures that are value members of other structures\n// because we assume they cannot contain pointers themselves.\nDAWN_UNUSED_FUNC(CommandEncoderCopyTextureToTextureGetExtraRequiredSize);\n\nDAWN_DECLARE_UNUSED WireResult CommandEncoderCopyTextureToTextureSerialize(\n    const CommandEncoderCopyTextureToTextureCmd& record,\n    CommandEncoderCopyTextureToTextureTransfer* transfer,\n    SerializeBuffer* buffer, const ObjectIdProvider& provider) {\n    DAWN_UNUSED(buffer);\n\n    transfer->commandId = WireCmd::CommandEncoderCopyTextureToTexture;\n\n    WIRE_TRY(provider.GetId(record.self, &transfer->self));\n\n\n\n\n    \n\n    {\n        auto memberLength = 1u;\n\n        WGPUImageCopyTextureTransfer* memberBuffer;\n        WIRE_TRY(buffer->NextN(memberLength, &memberBuffer));\n\n        for (decltype(memberLength) i = 0; i < memberLength; ++i) {\n            WIRE_TRY(WGPUImageCopyTextureSerialize(record.source[i], &memberBuffer[i], buffer, provider));\n        }\n    }\n    \n\n    {\n        auto memberLength = 1u;\n\n        WGPUImageCopyTextureTransfer* memberBuffer;\n        WIRE_TRY(buffer->NextN(memberLength, &memberBuffer));\n\n        for (decltype(memberLength) i = 0; i < memberLength; ++i) {\n            WIRE_TRY(WGPUImageCopyTextureSerialize(record.destination[i], &memberBuffer[i], buffer, provider));\n        }\n    }\n    \n\n    {\n        auto memberLength = 1u;\n\n        WGPUExtent3DTransfer* memberBuffer;\n        WIRE_TRY(buffer->NextN(memberLength, &memberBuffer));\n\n        memcpy(\n            memberBuffer, record.copySize,\n            sizeof(WGPUExtent3DTransfer) * memberLength);\n    }\n    return WireResult::Success;\n}\nDAWN_UNUSED_FUNC(CommandEncoderCopyTextureToTextureSerialize);\n\nDAWN_DECLARE_UNUSED WireResult CommandEncoderCopyTextureToTextureDeserialize(\n    CommandEncoderCopyTextureToTextureCmd* record,\n    const volatile CommandEncoderCopyTextureToTextureTransfer* transfer,\n    DeserializeBuffer* deserializeBuffer,\n    DeserializeAllocator* allocator, const ObjectIdResolver& resolver) {\n    DAWN_UNUSED(allocator);\n\n    ASSERT(transfer->commandId == WireCmd::CommandEncoderCopyTextureToTexture);\n\n    record->selfId = transfer->self;\n\n    WIRE_TRY(resolver.GetFromId(transfer->self, &record->self));\n\n\n\n\n    \n\n    {\n        auto memberLength = 1u;\n        const volatile WGPUImageCopyTextureTransfer* memberBuffer;\n        WIRE_TRY(deserializeBuffer->ReadN(memberLength, &memberBuffer));\n\n        WGPUImageCopyTexture* copiedMembers;\n        WIRE_TRY(GetSpace(allocator, memberLength, &copiedMembers));\n        record->source = copiedMembers;\n\n        for (decltype(memberLength) i = 0; i < memberLength; ++i) {\n            WIRE_TRY(WGPUImageCopyTextureDeserialize(&copiedMembers[i], &memberBuffer[i], deserializeBuffer, allocator, resolver));\n        }\n    }\n    \n\n    {\n        auto memberLength = 1u;\n        const volatile WGPUImageCopyTextureTransfer* memberBuffer;\n        WIRE_TRY(deserializeBuffer->ReadN(memberLength, &memberBuffer));\n\n        WGPUImageCopyTexture* copiedMembers;\n        WIRE_TRY(GetSpace(allocator, memberLength, &copiedMembers));\n        record->destination = copiedMembers;\n\n        for (decltype(memberLength) i = 0; i < memberLength; ++i) {\n            WIRE_TRY(WGPUImageCopyTextureDeserialize(&copiedMembers[i], &memberBuffer[i], deserializeBuffer, allocator, resolver));\n        }\n    }\n    \n\n    {\n        auto memberLength = 1u;\n        const volatile WGPUExtent3DTransfer* memberBuffer;\n        WIRE_TRY(deserializeBuffer->ReadN(memberLength, &memberBuffer));\n\n        WGPUExtent3D* copiedMembers;\n        WIRE_TRY(GetSpace(allocator, memberLength, &copiedMembers));\n        record->copySize = copiedMembers;\n\n        memcpy(\n            copiedMembers,\n            const_cast<const WGPUExtent3DTransfer*>(memberBuffer),\n           sizeof(WGPUExtent3DTransfer) * memberLength);\n    }\n\n    return WireResult::Success;\n}\nDAWN_UNUSED_FUNC(CommandEncoderCopyTextureToTextureDeserialize);\n\n            \nstruct CommandEncoderCopyTextureToTextureInternalTransfer : CmdHeader {\n    static_assert(1 <= 1,\n                  \"Record must be at most one of is_cmd, extensible, and chained.\");\n    WireCmd commandId;\n\n    ObjectId self;\n\n\n};\n\nstatic_assert(offsetof(CommandEncoderCopyTextureToTextureInternalTransfer, commandSize) == 0);\nstatic_assert(offsetof(CommandEncoderCopyTextureToTextureInternalTransfer, commandId) == sizeof(CmdHeader));\n\n\nDAWN_DECLARE_UNUSED size_t CommandEncoderCopyTextureToTextureInternalGetExtraRequiredSize(const CommandEncoderCopyTextureToTextureInternalCmd& record) {\n    DAWN_UNUSED(record);\n\n    size_t result = 0;\n\n\n\n    {\n    }\n    {\n        \n        auto memberLength = 1u;\n        result += memberLength * sizeof(WGPUImageCopyTextureTransfer);\n        for (decltype(memberLength) i = 0; i < memberLength; ++i) {\n            \n            result += WGPUImageCopyTextureGetExtraRequiredSize(record.source[i]);\n        }\n    }\n    {\n        \n        auto memberLength = 1u;\n        result += memberLength * sizeof(WGPUImageCopyTextureTransfer);\n        for (decltype(memberLength) i = 0; i < memberLength; ++i) {\n            \n            result += WGPUImageCopyTextureGetExtraRequiredSize(record.destination[i]);\n        }\n    }\n    {\n        \n        auto memberLength = 1u;\n        result += memberLength * sizeof(WGPUExtent3DTransfer);\n        for (decltype(memberLength) i = 0; i < memberLength; ++i) {\n            \n            result += WGPUExtent3DGetExtraRequiredSize(record.copySize[i]);\n        }\n    }\n\n    return result;\n}\n// GetExtraRequiredSize isn't used for structures that are value members of other structures\n// because we assume they cannot contain pointers themselves.\nDAWN_UNUSED_FUNC(CommandEncoderCopyTextureToTextureInternalGetExtraRequiredSize);\n\nDAWN_DECLARE_UNUSED WireResult CommandEncoderCopyTextureToTextureInternalSerialize(\n    const CommandEncoderCopyTextureToTextureInternalCmd& record,\n    CommandEncoderCopyTextureToTextureInternalTransfer* transfer,\n    SerializeBuffer* buffer, const ObjectIdProvider& provider) {\n    DAWN_UNUSED(buffer);\n\n    transfer->commandId = WireCmd::CommandEncoderCopyTextureToTextureInternal;\n\n    WIRE_TRY(provider.GetId(record.self, &transfer->self));\n\n\n\n\n    \n\n    {\n        auto memberLength = 1u;\n\n        WGPUImageCopyTextureTransfer* memberBuffer;\n        WIRE_TRY(buffer->NextN(memberLength, &memberBuffer));\n\n        for (decltype(memberLength) i = 0; i < memberLength; ++i) {\n            WIRE_TRY(WGPUImageCopyTextureSerialize(record.source[i], &memberBuffer[i], buffer, provider));\n        }\n    }\n    \n\n    {\n        auto memberLength = 1u;\n\n        WGPUImageCopyTextureTransfer* memberBuffer;\n        WIRE_TRY(buffer->NextN(memberLength, &memberBuffer));\n\n        for (decltype(memberLength) i = 0; i < memberLength; ++i) {\n            WIRE_TRY(WGPUImageCopyTextureSerialize(record.destination[i], &memberBuffer[i], buffer, provider));\n        }\n    }\n    \n\n    {\n        auto memberLength = 1u;\n\n        WGPUExtent3DTransfer* memberBuffer;\n        WIRE_TRY(buffer->NextN(memberLength, &memberBuffer));\n\n        memcpy(\n            memberBuffer, record.copySize,\n            sizeof(WGPUExtent3DTransfer) * memberLength);\n    }\n    return WireResult::Success;\n}\nDAWN_UNUSED_FUNC(CommandEncoderCopyTextureToTextureInternalSerialize);\n\nDAWN_DECLARE_UNUSED WireResult CommandEncoderCopyTextureToTextureInternalDeserialize(\n    CommandEncoderCopyTextureToTextureInternalCmd* record,\n    const volatile CommandEncoderCopyTextureToTextureInternalTransfer* transfer,\n    DeserializeBuffer* deserializeBuffer,\n    DeserializeAllocator* allocator, const ObjectIdResolver& resolver) {\n    DAWN_UNUSED(allocator);\n\n    ASSERT(transfer->commandId == WireCmd::CommandEncoderCopyTextureToTextureInternal);\n\n    record->selfId = transfer->self;\n\n    WIRE_TRY(resolver.GetFromId(transfer->self, &record->self));\n\n\n\n\n    \n\n    {\n        auto memberLength = 1u;\n        const volatile WGPUImageCopyTextureTransfer* memberBuffer;\n        WIRE_TRY(deserializeBuffer->ReadN(memberLength, &memberBuffer));\n\n        WGPUImageCopyTexture* copiedMembers;\n        WIRE_TRY(GetSpace(allocator, memberLength, &copiedMembers));\n        record->source = copiedMembers;\n\n        for (decltype(memberLength) i = 0; i < memberLength; ++i) {\n            WIRE_TRY(WGPUImageCopyTextureDeserialize(&copiedMembers[i], &memberBuffer[i], deserializeBuffer, allocator, resolver));\n        }\n    }\n    \n\n    {\n        auto memberLength = 1u;\n        const volatile WGPUImageCopyTextureTransfer* memberBuffer;\n        WIRE_TRY(deserializeBuffer->ReadN(memberLength, &memberBuffer));\n\n        WGPUImageCopyTexture* copiedMembers;\n        WIRE_TRY(GetSpace(allocator, memberLength, &copiedMembers));\n        record->destination = copiedMembers;\n\n        for (decltype(memberLength) i = 0; i < memberLength; ++i) {\n            WIRE_TRY(WGPUImageCopyTextureDeserialize(&copiedMembers[i], &memberBuffer[i], deserializeBuffer, allocator, resolver));\n        }\n    }\n    \n\n    {\n        auto memberLength = 1u;\n        const volatile WGPUExtent3DTransfer* memberBuffer;\n        WIRE_TRY(deserializeBuffer->ReadN(memberLength, &memberBuffer));\n\n        WGPUExtent3D* copiedMembers;\n        WIRE_TRY(GetSpace(allocator, memberLength, &copiedMembers));\n        record->copySize = copiedMembers;\n\n        memcpy(\n            copiedMembers,\n            const_cast<const WGPUExtent3DTransfer*>(memberBuffer),\n           sizeof(WGPUExtent3DTransfer) * memberLength);\n    }\n\n    return WireResult::Success;\n}\nDAWN_UNUSED_FUNC(CommandEncoderCopyTextureToTextureInternalDeserialize);\n\n            \nstruct CommandEncoderFinishTransfer : CmdHeader {\n    static_assert(1 <= 1,\n                  \"Record must be at most one of is_cmd, extensible, and chained.\");\n    WireCmd commandId;\n\n    ObjectId self;\n    \nObjectHandle result;\n\n\n    bool has_descriptor;\n};\n\nstatic_assert(offsetof(CommandEncoderFinishTransfer, commandSize) == 0);\nstatic_assert(offsetof(CommandEncoderFinishTransfer, commandId) == sizeof(CmdHeader));\n\n\nDAWN_DECLARE_UNUSED size_t CommandEncoderFinishGetExtraRequiredSize(const CommandEncoderFinishCmd& record) {\n    DAWN_UNUSED(record);\n\n    size_t result = 0;\n\n\n\n    {\n    }\n    if (record.descriptor != nullptr)\n    {\n        \n        auto memberLength = 1u;\n        result += memberLength * sizeof(WGPUCommandBufferDescriptorTransfer);\n        for (decltype(memberLength) i = 0; i < memberLength; ++i) {\n            \n            result += WGPUCommandBufferDescriptorGetExtraRequiredSize(record.descriptor[i]);\n        }\n    }\n    {\n    }\n\n    return result;\n}\n// GetExtraRequiredSize isn't used for structures that are value members of other structures\n// because we assume they cannot contain pointers themselves.\nDAWN_UNUSED_FUNC(CommandEncoderFinishGetExtraRequiredSize);\n\nDAWN_DECLARE_UNUSED WireResult CommandEncoderFinishSerialize(\n    const CommandEncoderFinishCmd& record,\n    CommandEncoderFinishTransfer* transfer,\n    SerializeBuffer* buffer, const ObjectIdProvider& provider) {\n    DAWN_UNUSED(buffer);\n\n    transfer->commandId = WireCmd::CommandEncoderFinish;\n\n    WIRE_TRY(provider.GetId(record.self, &transfer->self));\n    transfer->result = record.result;\n\n\n\n\n    \n\n    bool has_descriptor = record.descriptor != nullptr;\n    transfer->has_descriptor = has_descriptor;\n    if (has_descriptor)\n    {\n        auto memberLength = 1u;\n\n        WGPUCommandBufferDescriptorTransfer* memberBuffer;\n        WIRE_TRY(buffer->NextN(memberLength, &memberBuffer));\n\n        for (decltype(memberLength) i = 0; i < memberLength; ++i) {\n            WIRE_TRY(WGPUCommandBufferDescriptorSerialize(record.descriptor[i], &memberBuffer[i], buffer, provider));\n        }\n    }\n    return WireResult::Success;\n}\nDAWN_UNUSED_FUNC(CommandEncoderFinishSerialize);\n\nDAWN_DECLARE_UNUSED WireResult CommandEncoderFinishDeserialize(\n    CommandEncoderFinishCmd* record,\n    const volatile CommandEncoderFinishTransfer* transfer,\n    DeserializeBuffer* deserializeBuffer,\n    DeserializeAllocator* allocator, const ObjectIdResolver& resolver) {\n    DAWN_UNUSED(allocator);\n\n    ASSERT(transfer->commandId == WireCmd::CommandEncoderFinish);\n\n    record->selfId = transfer->self;\n\n    WIRE_TRY(resolver.GetFromId(transfer->self, &record->self));\n    static_assert(sizeof(record->result) >= sizeof(transfer->result), \"Deserialize assignment may not narrow.\");\nrecord->result = transfer->result;\n\n\n\n\n    \n\n    \n    bool has_descriptor = transfer->has_descriptor;\n    record->descriptor = nullptr;\n    if (has_descriptor)\n    {\n        auto memberLength = 1u;\n        const volatile WGPUCommandBufferDescriptorTransfer* memberBuffer;\n        WIRE_TRY(deserializeBuffer->ReadN(memberLength, &memberBuffer));\n\n        WGPUCommandBufferDescriptor* copiedMembers;\n        WIRE_TRY(GetSpace(allocator, memberLength, &copiedMembers));\n        record->descriptor = copiedMembers;\n\n        for (decltype(memberLength) i = 0; i < memberLength; ++i) {\n            WIRE_TRY(WGPUCommandBufferDescriptorDeserialize(&copiedMembers[i], &memberBuffer[i], deserializeBuffer, allocator, resolver));\n        }\n    }\n\n    return WireResult::Success;\n}\nDAWN_UNUSED_FUNC(CommandEncoderFinishDeserialize);\n\n            \nstruct CommandEncoderInjectValidationErrorTransfer : CmdHeader {\n    static_assert(1 <= 1,\n                  \"Record must be at most one of is_cmd, extensible, and chained.\");\n    WireCmd commandId;\n\n    ObjectId self;\n\n    uint64_t messageStrlen;\n\n};\n\nstatic_assert(offsetof(CommandEncoderInjectValidationErrorTransfer, commandSize) == 0);\nstatic_assert(offsetof(CommandEncoderInjectValidationErrorTransfer, commandId) == sizeof(CmdHeader));\n\n\nDAWN_DECLARE_UNUSED size_t CommandEncoderInjectValidationErrorGetExtraRequiredSize(const CommandEncoderInjectValidationErrorCmd& record) {\n    DAWN_UNUSED(record);\n\n    size_t result = 0;\n\n\n\n    {\n    result += std::strlen(record.message);\n    }\n\n    {\n    }\n\n    return result;\n}\n// GetExtraRequiredSize isn't used for structures that are value members of other structures\n// because we assume they cannot contain pointers themselves.\nDAWN_UNUSED_FUNC(CommandEncoderInjectValidationErrorGetExtraRequiredSize);\n\nDAWN_DECLARE_UNUSED WireResult CommandEncoderInjectValidationErrorSerialize(\n    const CommandEncoderInjectValidationErrorCmd& record,\n    CommandEncoderInjectValidationErrorTransfer* transfer,\n    SerializeBuffer* buffer, const ObjectIdProvider& provider) {\n    DAWN_UNUSED(buffer);\n\n    transfer->commandId = WireCmd::CommandEncoderInjectValidationError;\n\n    WIRE_TRY(provider.GetId(record.self, &transfer->self));\n\n\n\n\n    {\n        transfer->messageStrlen = std::strlen(record.message);\n\n        char* stringInBuffer;\n        WIRE_TRY(buffer->NextN(transfer->messageStrlen, &stringInBuffer));\n        memcpy(stringInBuffer, record.message, transfer->messageStrlen);\n    }\n\n    return WireResult::Success;\n}\nDAWN_UNUSED_FUNC(CommandEncoderInjectValidationErrorSerialize);\n\nDAWN_DECLARE_UNUSED WireResult CommandEncoderInjectValidationErrorDeserialize(\n    CommandEncoderInjectValidationErrorCmd* record,\n    const volatile CommandEncoderInjectValidationErrorTransfer* transfer,\n    DeserializeBuffer* deserializeBuffer,\n    DeserializeAllocator* allocator, const ObjectIdResolver& resolver) {\n    DAWN_UNUSED(allocator);\n\n    ASSERT(transfer->commandId == WireCmd::CommandEncoderInjectValidationError);\n\n    record->selfId = transfer->self;\n\n    WIRE_TRY(resolver.GetFromId(transfer->self, &record->self));\n\n\n\n\n    {\n        uint64_t stringLength64 = transfer->messageStrlen;\n        if (stringLength64 >= std::numeric_limits<size_t>::max()) {\n            return WireResult::FatalError;\n        }\n        size_t stringLength = static_cast<size_t>(stringLength64);\n\n        const volatile char* stringInBuffer;\n        WIRE_TRY(deserializeBuffer->ReadN(stringLength, &stringInBuffer));\n\n        char* copiedString;\n        WIRE_TRY(GetSpace(allocator, stringLength + 1, &copiedString));\n        memcpy(copiedString, const_cast<const char*>(stringInBuffer), stringLength);\n        copiedString[stringLength] = '\\0';\n        record->message = copiedString;\n    }\n\n\n    return WireResult::Success;\n}\nDAWN_UNUSED_FUNC(CommandEncoderInjectValidationErrorDeserialize);\n\n            \nstruct CommandEncoderInsertDebugMarkerTransfer : CmdHeader {\n    static_assert(1 <= 1,\n                  \"Record must be at most one of is_cmd, extensible, and chained.\");\n    WireCmd commandId;\n\n    ObjectId self;\n\n    uint64_t markerLabelStrlen;\n\n};\n\nstatic_assert(offsetof(CommandEncoderInsertDebugMarkerTransfer, commandSize) == 0);\nstatic_assert(offsetof(CommandEncoderInsertDebugMarkerTransfer, commandId) == sizeof(CmdHeader));\n\n\nDAWN_DECLARE_UNUSED size_t CommandEncoderInsertDebugMarkerGetExtraRequiredSize(const CommandEncoderInsertDebugMarkerCmd& record) {\n    DAWN_UNUSED(record);\n\n    size_t result = 0;\n\n\n\n    {\n    result += std::strlen(record.markerLabel);\n    }\n\n    {\n    }\n\n    return result;\n}\n// GetExtraRequiredSize isn't used for structures that are value members of other structures\n// because we assume they cannot contain pointers themselves.\nDAWN_UNUSED_FUNC(CommandEncoderInsertDebugMarkerGetExtraRequiredSize);\n\nDAWN_DECLARE_UNUSED WireResult CommandEncoderInsertDebugMarkerSerialize(\n    const CommandEncoderInsertDebugMarkerCmd& record,\n    CommandEncoderInsertDebugMarkerTransfer* transfer,\n    SerializeBuffer* buffer, const ObjectIdProvider& provider) {\n    DAWN_UNUSED(buffer);\n\n    transfer->commandId = WireCmd::CommandEncoderInsertDebugMarker;\n\n    WIRE_TRY(provider.GetId(record.self, &transfer->self));\n\n\n\n\n    {\n        transfer->markerLabelStrlen = std::strlen(record.markerLabel);\n\n        char* stringInBuffer;\n        WIRE_TRY(buffer->NextN(transfer->markerLabelStrlen, &stringInBuffer));\n        memcpy(stringInBuffer, record.markerLabel, transfer->markerLabelStrlen);\n    }\n\n    return WireResult::Success;\n}\nDAWN_UNUSED_FUNC(CommandEncoderInsertDebugMarkerSerialize);\n\nDAWN_DECLARE_UNUSED WireResult CommandEncoderInsertDebugMarkerDeserialize(\n    CommandEncoderInsertDebugMarkerCmd* record,\n    const volatile CommandEncoderInsertDebugMarkerTransfer* transfer,\n    DeserializeBuffer* deserializeBuffer,\n    DeserializeAllocator* allocator, const ObjectIdResolver& resolver) {\n    DAWN_UNUSED(allocator);\n\n    ASSERT(transfer->commandId == WireCmd::CommandEncoderInsertDebugMarker);\n\n    record->selfId = transfer->self;\n\n    WIRE_TRY(resolver.GetFromId(transfer->self, &record->self));\n\n\n\n\n    {\n        uint64_t stringLength64 = transfer->markerLabelStrlen;\n        if (stringLength64 >= std::numeric_limits<size_t>::max()) {\n            return WireResult::FatalError;\n        }\n        size_t stringLength = static_cast<size_t>(stringLength64);\n\n        const volatile char* stringInBuffer;\n        WIRE_TRY(deserializeBuffer->ReadN(stringLength, &stringInBuffer));\n\n        char* copiedString;\n        WIRE_TRY(GetSpace(allocator, stringLength + 1, &copiedString));\n        memcpy(copiedString, const_cast<const char*>(stringInBuffer), stringLength);\n        copiedString[stringLength] = '\\0';\n        record->markerLabel = copiedString;\n    }\n\n\n    return WireResult::Success;\n}\nDAWN_UNUSED_FUNC(CommandEncoderInsertDebugMarkerDeserialize);\n\n            \nstruct CommandEncoderPopDebugGroupTransfer : CmdHeader {\n    static_assert(1 <= 1,\n                  \"Record must be at most one of is_cmd, extensible, and chained.\");\n    WireCmd commandId;\n\n    ObjectId self;\n\n\n};\n\nstatic_assert(offsetof(CommandEncoderPopDebugGroupTransfer, commandSize) == 0);\nstatic_assert(offsetof(CommandEncoderPopDebugGroupTransfer, commandId) == sizeof(CmdHeader));\n\n\nDAWN_DECLARE_UNUSED size_t CommandEncoderPopDebugGroupGetExtraRequiredSize(const CommandEncoderPopDebugGroupCmd& record) {\n    DAWN_UNUSED(record);\n\n    size_t result = 0;\n\n\n\n    {\n    }\n\n    return result;\n}\n// GetExtraRequiredSize isn't used for structures that are value members of other structures\n// because we assume they cannot contain pointers themselves.\nDAWN_UNUSED_FUNC(CommandEncoderPopDebugGroupGetExtraRequiredSize);\n\nDAWN_DECLARE_UNUSED WireResult CommandEncoderPopDebugGroupSerialize(\n    const CommandEncoderPopDebugGroupCmd& record,\n    CommandEncoderPopDebugGroupTransfer* transfer,\n    SerializeBuffer* buffer, const ObjectIdProvider& provider) {\n    DAWN_UNUSED(buffer);\n\n    transfer->commandId = WireCmd::CommandEncoderPopDebugGroup;\n\n    WIRE_TRY(provider.GetId(record.self, &transfer->self));\n\n\n\n\n    return WireResult::Success;\n}\nDAWN_UNUSED_FUNC(CommandEncoderPopDebugGroupSerialize);\n\nDAWN_DECLARE_UNUSED WireResult CommandEncoderPopDebugGroupDeserialize(\n    CommandEncoderPopDebugGroupCmd* record,\n    const volatile CommandEncoderPopDebugGroupTransfer* transfer,\n    DeserializeBuffer* deserializeBuffer,\n    DeserializeAllocator* allocator, const ObjectIdResolver& resolver) {\n    DAWN_UNUSED(allocator);\n\n    ASSERT(transfer->commandId == WireCmd::CommandEncoderPopDebugGroup);\n\n    record->selfId = transfer->self;\n\n    WIRE_TRY(resolver.GetFromId(transfer->self, &record->self));\n\n\n\n\n\n    return WireResult::Success;\n}\nDAWN_UNUSED_FUNC(CommandEncoderPopDebugGroupDeserialize);\n\n            \nstruct CommandEncoderPushDebugGroupTransfer : CmdHeader {\n    static_assert(1 <= 1,\n                  \"Record must be at most one of is_cmd, extensible, and chained.\");\n    WireCmd commandId;\n\n    ObjectId self;\n\n    uint64_t groupLabelStrlen;\n\n};\n\nstatic_assert(offsetof(CommandEncoderPushDebugGroupTransfer, commandSize) == 0);\nstatic_assert(offsetof(CommandEncoderPushDebugGroupTransfer, commandId) == sizeof(CmdHeader));\n\n\nDAWN_DECLARE_UNUSED size_t CommandEncoderPushDebugGroupGetExtraRequiredSize(const CommandEncoderPushDebugGroupCmd& record) {\n    DAWN_UNUSED(record);\n\n    size_t result = 0;\n\n\n\n    {\n    result += std::strlen(record.groupLabel);\n    }\n\n    {\n    }\n\n    return result;\n}\n// GetExtraRequiredSize isn't used for structures that are value members of other structures\n// because we assume they cannot contain pointers themselves.\nDAWN_UNUSED_FUNC(CommandEncoderPushDebugGroupGetExtraRequiredSize);\n\nDAWN_DECLARE_UNUSED WireResult CommandEncoderPushDebugGroupSerialize(\n    const CommandEncoderPushDebugGroupCmd& record,\n    CommandEncoderPushDebugGroupTransfer* transfer,\n    SerializeBuffer* buffer, const ObjectIdProvider& provider) {\n    DAWN_UNUSED(buffer);\n\n    transfer->commandId = WireCmd::CommandEncoderPushDebugGroup;\n\n    WIRE_TRY(provider.GetId(record.self, &transfer->self));\n\n\n\n\n    {\n        transfer->groupLabelStrlen = std::strlen(record.groupLabel);\n\n        char* stringInBuffer;\n        WIRE_TRY(buffer->NextN(transfer->groupLabelStrlen, &stringInBuffer));\n        memcpy(stringInBuffer, record.groupLabel, transfer->groupLabelStrlen);\n    }\n\n    return WireResult::Success;\n}\nDAWN_UNUSED_FUNC(CommandEncoderPushDebugGroupSerialize);\n\nDAWN_DECLARE_UNUSED WireResult CommandEncoderPushDebugGroupDeserialize(\n    CommandEncoderPushDebugGroupCmd* record,\n    const volatile CommandEncoderPushDebugGroupTransfer* transfer,\n    DeserializeBuffer* deserializeBuffer,\n    DeserializeAllocator* allocator, const ObjectIdResolver& resolver) {\n    DAWN_UNUSED(allocator);\n\n    ASSERT(transfer->commandId == WireCmd::CommandEncoderPushDebugGroup);\n\n    record->selfId = transfer->self;\n\n    WIRE_TRY(resolver.GetFromId(transfer->self, &record->self));\n\n\n\n\n    {\n        uint64_t stringLength64 = transfer->groupLabelStrlen;\n        if (stringLength64 >= std::numeric_limits<size_t>::max()) {\n            return WireResult::FatalError;\n        }\n        size_t stringLength = static_cast<size_t>(stringLength64);\n\n        const volatile char* stringInBuffer;\n        WIRE_TRY(deserializeBuffer->ReadN(stringLength, &stringInBuffer));\n\n        char* copiedString;\n        WIRE_TRY(GetSpace(allocator, stringLength + 1, &copiedString));\n        memcpy(copiedString, const_cast<const char*>(stringInBuffer), stringLength);\n        copiedString[stringLength] = '\\0';\n        record->groupLabel = copiedString;\n    }\n\n\n    return WireResult::Success;\n}\nDAWN_UNUSED_FUNC(CommandEncoderPushDebugGroupDeserialize);\n\n            \nstruct CommandEncoderResolveQuerySetTransfer : CmdHeader {\n    static_assert(1 <= 1,\n                  \"Record must be at most one of is_cmd, extensible, and chained.\");\n    WireCmd commandId;\n\n    ObjectId self;\n    ObjectId querySet;\n    \nuint32_t firstQuery;\n    \nuint32_t queryCount;\n    ObjectId destination;\n    \nuint64_t destinationOffset;\n\n\n};\n\nstatic_assert(offsetof(CommandEncoderResolveQuerySetTransfer, commandSize) == 0);\nstatic_assert(offsetof(CommandEncoderResolveQuerySetTransfer, commandId) == sizeof(CmdHeader));\n\n\nDAWN_DECLARE_UNUSED size_t CommandEncoderResolveQuerySetGetExtraRequiredSize(const CommandEncoderResolveQuerySetCmd& record) {\n    DAWN_UNUSED(record);\n\n    size_t result = 0;\n\n\n\n    {\n    }\n    {\n    }\n    {\n    }\n    {\n    }\n    {\n    }\n    {\n    }\n\n    return result;\n}\n// GetExtraRequiredSize isn't used for structures that are value members of other structures\n// because we assume they cannot contain pointers themselves.\nDAWN_UNUSED_FUNC(CommandEncoderResolveQuerySetGetExtraRequiredSize);\n\nDAWN_DECLARE_UNUSED WireResult CommandEncoderResolveQuerySetSerialize(\n    const CommandEncoderResolveQuerySetCmd& record,\n    CommandEncoderResolveQuerySetTransfer* transfer,\n    SerializeBuffer* buffer, const ObjectIdProvider& provider) {\n    DAWN_UNUSED(buffer);\n\n    transfer->commandId = WireCmd::CommandEncoderResolveQuerySet;\n\n    WIRE_TRY(provider.GetId(record.self, &transfer->self));\n    WIRE_TRY(provider.GetId(record.querySet, &transfer->querySet));\n    transfer->firstQuery = record.firstQuery;\n    transfer->queryCount = record.queryCount;\n    WIRE_TRY(provider.GetId(record.destination, &transfer->destination));\n    transfer->destinationOffset = record.destinationOffset;\n\n\n\n\n    return WireResult::Success;\n}\nDAWN_UNUSED_FUNC(CommandEncoderResolveQuerySetSerialize);\n\nDAWN_DECLARE_UNUSED WireResult CommandEncoderResolveQuerySetDeserialize(\n    CommandEncoderResolveQuerySetCmd* record,\n    const volatile CommandEncoderResolveQuerySetTransfer* transfer,\n    DeserializeBuffer* deserializeBuffer,\n    DeserializeAllocator* allocator, const ObjectIdResolver& resolver) {\n    DAWN_UNUSED(allocator);\n\n    ASSERT(transfer->commandId == WireCmd::CommandEncoderResolveQuerySet);\n\n    record->selfId = transfer->self;\n\n    WIRE_TRY(resolver.GetFromId(transfer->self, &record->self));\n    WIRE_TRY(resolver.GetFromId(transfer->querySet, &record->querySet));\n    static_assert(sizeof(record->firstQuery) >= sizeof(transfer->firstQuery), \"Deserialize assignment may not narrow.\");\nrecord->firstQuery = transfer->firstQuery;\n    static_assert(sizeof(record->queryCount) >= sizeof(transfer->queryCount), \"Deserialize assignment may not narrow.\");\nrecord->queryCount = transfer->queryCount;\n    WIRE_TRY(resolver.GetFromId(transfer->destination, &record->destination));\n    static_assert(sizeof(record->destinationOffset) >= sizeof(transfer->destinationOffset), \"Deserialize assignment may not narrow.\");\nrecord->destinationOffset = transfer->destinationOffset;\n\n\n\n\n\n    return WireResult::Success;\n}\nDAWN_UNUSED_FUNC(CommandEncoderResolveQuerySetDeserialize);\n\n            \nstruct CommandEncoderSetLabelTransfer : CmdHeader {\n    static_assert(1 <= 1,\n                  \"Record must be at most one of is_cmd, extensible, and chained.\");\n    WireCmd commandId;\n\n    ObjectId self;\n\n    uint64_t labelStrlen;\n\n};\n\nstatic_assert(offsetof(CommandEncoderSetLabelTransfer, commandSize) == 0);\nstatic_assert(offsetof(CommandEncoderSetLabelTransfer, commandId) == sizeof(CmdHeader));\n\n\nDAWN_DECLARE_UNUSED size_t CommandEncoderSetLabelGetExtraRequiredSize(const CommandEncoderSetLabelCmd& record) {\n    DAWN_UNUSED(record);\n\n    size_t result = 0;\n\n\n\n    {\n    result += std::strlen(record.label);\n    }\n\n    {\n    }\n\n    return result;\n}\n// GetExtraRequiredSize isn't used for structures that are value members of other structures\n// because we assume they cannot contain pointers themselves.\nDAWN_UNUSED_FUNC(CommandEncoderSetLabelGetExtraRequiredSize);\n\nDAWN_DECLARE_UNUSED WireResult CommandEncoderSetLabelSerialize(\n    const CommandEncoderSetLabelCmd& record,\n    CommandEncoderSetLabelTransfer* transfer,\n    SerializeBuffer* buffer, const ObjectIdProvider& provider) {\n    DAWN_UNUSED(buffer);\n\n    transfer->commandId = WireCmd::CommandEncoderSetLabel;\n\n    WIRE_TRY(provider.GetId(record.self, &transfer->self));\n\n\n\n\n    {\n        transfer->labelStrlen = std::strlen(record.label);\n\n        char* stringInBuffer;\n        WIRE_TRY(buffer->NextN(transfer->labelStrlen, &stringInBuffer));\n        memcpy(stringInBuffer, record.label, transfer->labelStrlen);\n    }\n\n    return WireResult::Success;\n}\nDAWN_UNUSED_FUNC(CommandEncoderSetLabelSerialize);\n\nDAWN_DECLARE_UNUSED WireResult CommandEncoderSetLabelDeserialize(\n    CommandEncoderSetLabelCmd* record,\n    const volatile CommandEncoderSetLabelTransfer* transfer,\n    DeserializeBuffer* deserializeBuffer,\n    DeserializeAllocator* allocator, const ObjectIdResolver& resolver) {\n    DAWN_UNUSED(allocator);\n\n    ASSERT(transfer->commandId == WireCmd::CommandEncoderSetLabel);\n\n    record->selfId = transfer->self;\n\n    WIRE_TRY(resolver.GetFromId(transfer->self, &record->self));\n\n\n\n\n    {\n        uint64_t stringLength64 = transfer->labelStrlen;\n        if (stringLength64 >= std::numeric_limits<size_t>::max()) {\n            return WireResult::FatalError;\n        }\n        size_t stringLength = static_cast<size_t>(stringLength64);\n\n        const volatile char* stringInBuffer;\n        WIRE_TRY(deserializeBuffer->ReadN(stringLength, &stringInBuffer));\n\n        char* copiedString;\n        WIRE_TRY(GetSpace(allocator, stringLength + 1, &copiedString));\n        memcpy(copiedString, const_cast<const char*>(stringInBuffer), stringLength);\n        copiedString[stringLength] = '\\0';\n        record->label = copiedString;\n    }\n\n\n    return WireResult::Success;\n}\nDAWN_UNUSED_FUNC(CommandEncoderSetLabelDeserialize);\n\n            \nstruct CommandEncoderWriteBufferTransfer : CmdHeader {\n    static_assert(1 <= 1,\n                  \"Record must be at most one of is_cmd, extensible, and chained.\");\n    WireCmd commandId;\n\n    ObjectId self;\n    ObjectId buffer;\n    \nuint64_t bufferOffset;\n    \nuint64_t size;\n\n\n};\n\nstatic_assert(offsetof(CommandEncoderWriteBufferTransfer, commandSize) == 0);\nstatic_assert(offsetof(CommandEncoderWriteBufferTransfer, commandId) == sizeof(CmdHeader));\n\n\nDAWN_DECLARE_UNUSED size_t CommandEncoderWriteBufferGetExtraRequiredSize(const CommandEncoderWriteBufferCmd& record) {\n    DAWN_UNUSED(record);\n\n    size_t result = 0;\n\n\n\n    {\n    }\n    {\n    }\n    {\n    }\n    {\n        \n        auto memberLength = record.size;\n        result += memberLength * sizeof(\nuint8_t);\n    }\n    {\n    }\n\n    return result;\n}\n// GetExtraRequiredSize isn't used for structures that are value members of other structures\n// because we assume they cannot contain pointers themselves.\nDAWN_UNUSED_FUNC(CommandEncoderWriteBufferGetExtraRequiredSize);\n\nDAWN_DECLARE_UNUSED WireResult CommandEncoderWriteBufferSerialize(\n    const CommandEncoderWriteBufferCmd& record,\n    CommandEncoderWriteBufferTransfer* transfer,\n    SerializeBuffer* buffer, const ObjectIdProvider& provider) {\n    DAWN_UNUSED(buffer);\n\n    transfer->commandId = WireCmd::CommandEncoderWriteBuffer;\n\n    WIRE_TRY(provider.GetId(record.self, &transfer->self));\n    WIRE_TRY(provider.GetId(record.buffer, &transfer->buffer));\n    transfer->bufferOffset = record.bufferOffset;\n    transfer->size = record.size;\n\n\n\n\n    \n\n    {\n        auto memberLength = record.size;\n\n        \nuint8_t* memberBuffer;\n        WIRE_TRY(buffer->NextN(memberLength, &memberBuffer));\n\n        memcpy(\n            memberBuffer, record.data,\n            sizeof(\nuint8_t) * memberLength);\n    }\n    return WireResult::Success;\n}\nDAWN_UNUSED_FUNC(CommandEncoderWriteBufferSerialize);\n\nDAWN_DECLARE_UNUSED WireResult CommandEncoderWriteBufferDeserialize(\n    CommandEncoderWriteBufferCmd* record,\n    const volatile CommandEncoderWriteBufferTransfer* transfer,\n    DeserializeBuffer* deserializeBuffer,\n    DeserializeAllocator* allocator, const ObjectIdResolver& resolver) {\n    DAWN_UNUSED(allocator);\n\n    ASSERT(transfer->commandId == WireCmd::CommandEncoderWriteBuffer);\n\n    record->selfId = transfer->self;\n\n    WIRE_TRY(resolver.GetFromId(transfer->self, &record->self));\n    WIRE_TRY(resolver.GetFromId(transfer->buffer, &record->buffer));\n    static_assert(sizeof(record->bufferOffset) >= sizeof(transfer->bufferOffset), \"Deserialize assignment may not narrow.\");\nrecord->bufferOffset = transfer->bufferOffset;\n    static_assert(sizeof(record->size) >= sizeof(transfer->size), \"Deserialize assignment may not narrow.\");\nrecord->size = transfer->size;\n\n\n\n\n    \n\n    {\n        auto memberLength = record->size;\n        const volatile \nuint8_t* memberBuffer;\n        WIRE_TRY(deserializeBuffer->ReadN(memberLength, &memberBuffer));\n\n        uint8_t* copiedMembers;\n        WIRE_TRY(GetSpace(allocator, memberLength, &copiedMembers));\n        record->data = copiedMembers;\n\n        memcpy(\n            copiedMembers,\n            const_cast<const \nuint8_t*>(memberBuffer),\n           sizeof(\nuint8_t) * memberLength);\n    }\n\n    return WireResult::Success;\n}\nDAWN_UNUSED_FUNC(CommandEncoderWriteBufferDeserialize);\n\n            \nstruct CommandEncoderWriteTimestampTransfer : CmdHeader {\n    static_assert(1 <= 1,\n                  \"Record must be at most one of is_cmd, extensible, and chained.\");\n    WireCmd commandId;\n\n    ObjectId self;\n    ObjectId querySet;\n    \nuint32_t queryIndex;\n\n\n};\n\nstatic_assert(offsetof(CommandEncoderWriteTimestampTransfer, commandSize) == 0);\nstatic_assert(offsetof(CommandEncoderWriteTimestampTransfer, commandId) == sizeof(CmdHeader));\n\n\nDAWN_DECLARE_UNUSED size_t CommandEncoderWriteTimestampGetExtraRequiredSize(const CommandEncoderWriteTimestampCmd& record) {\n    DAWN_UNUSED(record);\n\n    size_t result = 0;\n\n\n\n    {\n    }\n    {\n    }\n    {\n    }\n\n    return result;\n}\n// GetExtraRequiredSize isn't used for structures that are value members of other structures\n// because we assume they cannot contain pointers themselves.\nDAWN_UNUSED_FUNC(CommandEncoderWriteTimestampGetExtraRequiredSize);\n\nDAWN_DECLARE_UNUSED WireResult CommandEncoderWriteTimestampSerialize(\n    const CommandEncoderWriteTimestampCmd& record,\n    CommandEncoderWriteTimestampTransfer* transfer,\n    SerializeBuffer* buffer, const ObjectIdProvider& provider) {\n    DAWN_UNUSED(buffer);\n\n    transfer->commandId = WireCmd::CommandEncoderWriteTimestamp;\n\n    WIRE_TRY(provider.GetId(record.self, &transfer->self));\n    WIRE_TRY(provider.GetId(record.querySet, &transfer->querySet));\n    transfer->queryIndex = record.queryIndex;\n\n\n\n\n    return WireResult::Success;\n}\nDAWN_UNUSED_FUNC(CommandEncoderWriteTimestampSerialize);\n\nDAWN_DECLARE_UNUSED WireResult CommandEncoderWriteTimestampDeserialize(\n    CommandEncoderWriteTimestampCmd* record,\n    const volatile CommandEncoderWriteTimestampTransfer* transfer,\n    DeserializeBuffer* deserializeBuffer,\n    DeserializeAllocator* allocator, const ObjectIdResolver& resolver) {\n    DAWN_UNUSED(allocator);\n\n    ASSERT(transfer->commandId == WireCmd::CommandEncoderWriteTimestamp);\n\n    record->selfId = transfer->self;\n\n    WIRE_TRY(resolver.GetFromId(transfer->self, &record->self));\n    WIRE_TRY(resolver.GetFromId(transfer->querySet, &record->querySet));\n    static_assert(sizeof(record->queryIndex) >= sizeof(transfer->queryIndex), \"Deserialize assignment may not narrow.\");\nrecord->queryIndex = transfer->queryIndex;\n\n\n\n\n\n    return WireResult::Success;\n}\nDAWN_UNUSED_FUNC(CommandEncoderWriteTimestampDeserialize);\n\n            \nstruct ComputePassEncoderDispatchTransfer : CmdHeader {\n    static_assert(1 <= 1,\n                  \"Record must be at most one of is_cmd, extensible, and chained.\");\n    WireCmd commandId;\n\n    ObjectId self;\n    \nuint32_t workgroupCountX;\n    \nuint32_t workgroupCountY;\n    \nuint32_t workgroupCountZ;\n\n\n};\n\nstatic_assert(offsetof(ComputePassEncoderDispatchTransfer, commandSize) == 0);\nstatic_assert(offsetof(ComputePassEncoderDispatchTransfer, commandId) == sizeof(CmdHeader));\n\n\nDAWN_DECLARE_UNUSED size_t ComputePassEncoderDispatchGetExtraRequiredSize(const ComputePassEncoderDispatchCmd& record) {\n    DAWN_UNUSED(record);\n\n    size_t result = 0;\n\n\n\n    {\n    }\n    {\n    }\n    {\n    }\n    {\n    }\n\n    return result;\n}\n// GetExtraRequiredSize isn't used for structures that are value members of other structures\n// because we assume they cannot contain pointers themselves.\nDAWN_UNUSED_FUNC(ComputePassEncoderDispatchGetExtraRequiredSize);\n\nDAWN_DECLARE_UNUSED WireResult ComputePassEncoderDispatchSerialize(\n    const ComputePassEncoderDispatchCmd& record,\n    ComputePassEncoderDispatchTransfer* transfer,\n    SerializeBuffer* buffer, const ObjectIdProvider& provider) {\n    DAWN_UNUSED(buffer);\n\n    transfer->commandId = WireCmd::ComputePassEncoderDispatch;\n\n    WIRE_TRY(provider.GetId(record.self, &transfer->self));\n    transfer->workgroupCountX = record.workgroupCountX;\n    transfer->workgroupCountY = record.workgroupCountY;\n    transfer->workgroupCountZ = record.workgroupCountZ;\n\n\n\n\n    return WireResult::Success;\n}\nDAWN_UNUSED_FUNC(ComputePassEncoderDispatchSerialize);\n\nDAWN_DECLARE_UNUSED WireResult ComputePassEncoderDispatchDeserialize(\n    ComputePassEncoderDispatchCmd* record,\n    const volatile ComputePassEncoderDispatchTransfer* transfer,\n    DeserializeBuffer* deserializeBuffer,\n    DeserializeAllocator* allocator, const ObjectIdResolver& resolver) {\n    DAWN_UNUSED(allocator);\n\n    ASSERT(transfer->commandId == WireCmd::ComputePassEncoderDispatch);\n\n    record->selfId = transfer->self;\n\n    WIRE_TRY(resolver.GetFromId(transfer->self, &record->self));\n    static_assert(sizeof(record->workgroupCountX) >= sizeof(transfer->workgroupCountX), \"Deserialize assignment may not narrow.\");\nrecord->workgroupCountX = transfer->workgroupCountX;\n    static_assert(sizeof(record->workgroupCountY) >= sizeof(transfer->workgroupCountY), \"Deserialize assignment may not narrow.\");\nrecord->workgroupCountY = transfer->workgroupCountY;\n    static_assert(sizeof(record->workgroupCountZ) >= sizeof(transfer->workgroupCountZ), \"Deserialize assignment may not narrow.\");\nrecord->workgroupCountZ = transfer->workgroupCountZ;\n\n\n\n\n\n    return WireResult::Success;\n}\nDAWN_UNUSED_FUNC(ComputePassEncoderDispatchDeserialize);\n\n            \nstruct ComputePassEncoderDispatchIndirectTransfer : CmdHeader {\n    static_assert(1 <= 1,\n                  \"Record must be at most one of is_cmd, extensible, and chained.\");\n    WireCmd commandId;\n\n    ObjectId self;\n    ObjectId indirectBuffer;\n    \nuint64_t indirectOffset;\n\n\n};\n\nstatic_assert(offsetof(ComputePassEncoderDispatchIndirectTransfer, commandSize) == 0);\nstatic_assert(offsetof(ComputePassEncoderDispatchIndirectTransfer, commandId) == sizeof(CmdHeader));\n\n\nDAWN_DECLARE_UNUSED size_t ComputePassEncoderDispatchIndirectGetExtraRequiredSize(const ComputePassEncoderDispatchIndirectCmd& record) {\n    DAWN_UNUSED(record);\n\n    size_t result = 0;\n\n\n\n    {\n    }\n    {\n    }\n    {\n    }\n\n    return result;\n}\n// GetExtraRequiredSize isn't used for structures that are value members of other structures\n// because we assume they cannot contain pointers themselves.\nDAWN_UNUSED_FUNC(ComputePassEncoderDispatchIndirectGetExtraRequiredSize);\n\nDAWN_DECLARE_UNUSED WireResult ComputePassEncoderDispatchIndirectSerialize(\n    const ComputePassEncoderDispatchIndirectCmd& record,\n    ComputePassEncoderDispatchIndirectTransfer* transfer,\n    SerializeBuffer* buffer, const ObjectIdProvider& provider) {\n    DAWN_UNUSED(buffer);\n\n    transfer->commandId = WireCmd::ComputePassEncoderDispatchIndirect;\n\n    WIRE_TRY(provider.GetId(record.self, &transfer->self));\n    WIRE_TRY(provider.GetId(record.indirectBuffer, &transfer->indirectBuffer));\n    transfer->indirectOffset = record.indirectOffset;\n\n\n\n\n    return WireResult::Success;\n}\nDAWN_UNUSED_FUNC(ComputePassEncoderDispatchIndirectSerialize);\n\nDAWN_DECLARE_UNUSED WireResult ComputePassEncoderDispatchIndirectDeserialize(\n    ComputePassEncoderDispatchIndirectCmd* record,\n    const volatile ComputePassEncoderDispatchIndirectTransfer* transfer,\n    DeserializeBuffer* deserializeBuffer,\n    DeserializeAllocator* allocator, const ObjectIdResolver& resolver) {\n    DAWN_UNUSED(allocator);\n\n    ASSERT(transfer->commandId == WireCmd::ComputePassEncoderDispatchIndirect);\n\n    record->selfId = transfer->self;\n\n    WIRE_TRY(resolver.GetFromId(transfer->self, &record->self));\n    WIRE_TRY(resolver.GetFromId(transfer->indirectBuffer, &record->indirectBuffer));\n    static_assert(sizeof(record->indirectOffset) >= sizeof(transfer->indirectOffset), \"Deserialize assignment may not narrow.\");\nrecord->indirectOffset = transfer->indirectOffset;\n\n\n\n\n\n    return WireResult::Success;\n}\nDAWN_UNUSED_FUNC(ComputePassEncoderDispatchIndirectDeserialize);\n\n            \nstruct ComputePassEncoderDispatchWorkgroupsTransfer : CmdHeader {\n    static_assert(1 <= 1,\n                  \"Record must be at most one of is_cmd, extensible, and chained.\");\n    WireCmd commandId;\n\n    ObjectId self;\n    \nuint32_t workgroupCountX;\n    \nuint32_t workgroupCountY;\n    \nuint32_t workgroupCountZ;\n\n\n};\n\nstatic_assert(offsetof(ComputePassEncoderDispatchWorkgroupsTransfer, commandSize) == 0);\nstatic_assert(offsetof(ComputePassEncoderDispatchWorkgroupsTransfer, commandId) == sizeof(CmdHeader));\n\n\nDAWN_DECLARE_UNUSED size_t ComputePassEncoderDispatchWorkgroupsGetExtraRequiredSize(const ComputePassEncoderDispatchWorkgroupsCmd& record) {\n    DAWN_UNUSED(record);\n\n    size_t result = 0;\n\n\n\n    {\n    }\n    {\n    }\n    {\n    }\n    {\n    }\n\n    return result;\n}\n// GetExtraRequiredSize isn't used for structures that are value members of other structures\n// because we assume they cannot contain pointers themselves.\nDAWN_UNUSED_FUNC(ComputePassEncoderDispatchWorkgroupsGetExtraRequiredSize);\n\nDAWN_DECLARE_UNUSED WireResult ComputePassEncoderDispatchWorkgroupsSerialize(\n    const ComputePassEncoderDispatchWorkgroupsCmd& record,\n    ComputePassEncoderDispatchWorkgroupsTransfer* transfer,\n    SerializeBuffer* buffer, const ObjectIdProvider& provider) {\n    DAWN_UNUSED(buffer);\n\n    transfer->commandId = WireCmd::ComputePassEncoderDispatchWorkgroups;\n\n    WIRE_TRY(provider.GetId(record.self, &transfer->self));\n    transfer->workgroupCountX = record.workgroupCountX;\n    transfer->workgroupCountY = record.workgroupCountY;\n    transfer->workgroupCountZ = record.workgroupCountZ;\n\n\n\n\n    return WireResult::Success;\n}\nDAWN_UNUSED_FUNC(ComputePassEncoderDispatchWorkgroupsSerialize);\n\nDAWN_DECLARE_UNUSED WireResult ComputePassEncoderDispatchWorkgroupsDeserialize(\n    ComputePassEncoderDispatchWorkgroupsCmd* record,\n    const volatile ComputePassEncoderDispatchWorkgroupsTransfer* transfer,\n    DeserializeBuffer* deserializeBuffer,\n    DeserializeAllocator* allocator, const ObjectIdResolver& resolver) {\n    DAWN_UNUSED(allocator);\n\n    ASSERT(transfer->commandId == WireCmd::ComputePassEncoderDispatchWorkgroups);\n\n    record->selfId = transfer->self;\n\n    WIRE_TRY(resolver.GetFromId(transfer->self, &record->self));\n    static_assert(sizeof(record->workgroupCountX) >= sizeof(transfer->workgroupCountX), \"Deserialize assignment may not narrow.\");\nrecord->workgroupCountX = transfer->workgroupCountX;\n    static_assert(sizeof(record->workgroupCountY) >= sizeof(transfer->workgroupCountY), \"Deserialize assignment may not narrow.\");\nrecord->workgroupCountY = transfer->workgroupCountY;\n    static_assert(sizeof(record->workgroupCountZ) >= sizeof(transfer->workgroupCountZ), \"Deserialize assignment may not narrow.\");\nrecord->workgroupCountZ = transfer->workgroupCountZ;\n\n\n\n\n\n    return WireResult::Success;\n}\nDAWN_UNUSED_FUNC(ComputePassEncoderDispatchWorkgroupsDeserialize);\n\n            \nstruct ComputePassEncoderDispatchWorkgroupsIndirectTransfer : CmdHeader {\n    static_assert(1 <= 1,\n                  \"Record must be at most one of is_cmd, extensible, and chained.\");\n    WireCmd commandId;\n\n    ObjectId self;\n    ObjectId indirectBuffer;\n    \nuint64_t indirectOffset;\n\n\n};\n\nstatic_assert(offsetof(ComputePassEncoderDispatchWorkgroupsIndirectTransfer, commandSize) == 0);\nstatic_assert(offsetof(ComputePassEncoderDispatchWorkgroupsIndirectTransfer, commandId) == sizeof(CmdHeader));\n\n\nDAWN_DECLARE_UNUSED size_t ComputePassEncoderDispatchWorkgroupsIndirectGetExtraRequiredSize(const ComputePassEncoderDispatchWorkgroupsIndirectCmd& record) {\n    DAWN_UNUSED(record);\n\n    size_t result = 0;\n\n\n\n    {\n    }\n    {\n    }\n    {\n    }\n\n    return result;\n}\n// GetExtraRequiredSize isn't used for structures that are value members of other structures\n// because we assume they cannot contain pointers themselves.\nDAWN_UNUSED_FUNC(ComputePassEncoderDispatchWorkgroupsIndirectGetExtraRequiredSize);\n\nDAWN_DECLARE_UNUSED WireResult ComputePassEncoderDispatchWorkgroupsIndirectSerialize(\n    const ComputePassEncoderDispatchWorkgroupsIndirectCmd& record,\n    ComputePassEncoderDispatchWorkgroupsIndirectTransfer* transfer,\n    SerializeBuffer* buffer, const ObjectIdProvider& provider) {\n    DAWN_UNUSED(buffer);\n\n    transfer->commandId = WireCmd::ComputePassEncoderDispatchWorkgroupsIndirect;\n\n    WIRE_TRY(provider.GetId(record.self, &transfer->self));\n    WIRE_TRY(provider.GetId(record.indirectBuffer, &transfer->indirectBuffer));\n    transfer->indirectOffset = record.indirectOffset;\n\n\n\n\n    return WireResult::Success;\n}\nDAWN_UNUSED_FUNC(ComputePassEncoderDispatchWorkgroupsIndirectSerialize);\n\nDAWN_DECLARE_UNUSED WireResult ComputePassEncoderDispatchWorkgroupsIndirectDeserialize(\n    ComputePassEncoderDispatchWorkgroupsIndirectCmd* record,\n    const volatile ComputePassEncoderDispatchWorkgroupsIndirectTransfer* transfer,\n    DeserializeBuffer* deserializeBuffer,\n    DeserializeAllocator* allocator, const ObjectIdResolver& resolver) {\n    DAWN_UNUSED(allocator);\n\n    ASSERT(transfer->commandId == WireCmd::ComputePassEncoderDispatchWorkgroupsIndirect);\n\n    record->selfId = transfer->self;\n\n    WIRE_TRY(resolver.GetFromId(transfer->self, &record->self));\n    WIRE_TRY(resolver.GetFromId(transfer->indirectBuffer, &record->indirectBuffer));\n    static_assert(sizeof(record->indirectOffset) >= sizeof(transfer->indirectOffset), \"Deserialize assignment may not narrow.\");\nrecord->indirectOffset = transfer->indirectOffset;\n\n\n\n\n\n    return WireResult::Success;\n}\nDAWN_UNUSED_FUNC(ComputePassEncoderDispatchWorkgroupsIndirectDeserialize);\n\n            \nstruct ComputePassEncoderEndTransfer : CmdHeader {\n    static_assert(1 <= 1,\n                  \"Record must be at most one of is_cmd, extensible, and chained.\");\n    WireCmd commandId;\n\n    ObjectId self;\n\n\n};\n\nstatic_assert(offsetof(ComputePassEncoderEndTransfer, commandSize) == 0);\nstatic_assert(offsetof(ComputePassEncoderEndTransfer, commandId) == sizeof(CmdHeader));\n\n\nDAWN_DECLARE_UNUSED size_t ComputePassEncoderEndGetExtraRequiredSize(const ComputePassEncoderEndCmd& record) {\n    DAWN_UNUSED(record);\n\n    size_t result = 0;\n\n\n\n    {\n    }\n\n    return result;\n}\n// GetExtraRequiredSize isn't used for structures that are value members of other structures\n// because we assume they cannot contain pointers themselves.\nDAWN_UNUSED_FUNC(ComputePassEncoderEndGetExtraRequiredSize);\n\nDAWN_DECLARE_UNUSED WireResult ComputePassEncoderEndSerialize(\n    const ComputePassEncoderEndCmd& record,\n    ComputePassEncoderEndTransfer* transfer,\n    SerializeBuffer* buffer, const ObjectIdProvider& provider) {\n    DAWN_UNUSED(buffer);\n\n    transfer->commandId = WireCmd::ComputePassEncoderEnd;\n\n    WIRE_TRY(provider.GetId(record.self, &transfer->self));\n\n\n\n\n    return WireResult::Success;\n}\nDAWN_UNUSED_FUNC(ComputePassEncoderEndSerialize);\n\nDAWN_DECLARE_UNUSED WireResult ComputePassEncoderEndDeserialize(\n    ComputePassEncoderEndCmd* record,\n    const volatile ComputePassEncoderEndTransfer* transfer,\n    DeserializeBuffer* deserializeBuffer,\n    DeserializeAllocator* allocator, const ObjectIdResolver& resolver) {\n    DAWN_UNUSED(allocator);\n\n    ASSERT(transfer->commandId == WireCmd::ComputePassEncoderEnd);\n\n    record->selfId = transfer->self;\n\n    WIRE_TRY(resolver.GetFromId(transfer->self, &record->self));\n\n\n\n\n\n    return WireResult::Success;\n}\nDAWN_UNUSED_FUNC(ComputePassEncoderEndDeserialize);\n\n            \nstruct ComputePassEncoderEndPassTransfer : CmdHeader {\n    static_assert(1 <= 1,\n                  \"Record must be at most one of is_cmd, extensible, and chained.\");\n    WireCmd commandId;\n\n    ObjectId self;\n\n\n};\n\nstatic_assert(offsetof(ComputePassEncoderEndPassTransfer, commandSize) == 0);\nstatic_assert(offsetof(ComputePassEncoderEndPassTransfer, commandId) == sizeof(CmdHeader));\n\n\nDAWN_DECLARE_UNUSED size_t ComputePassEncoderEndPassGetExtraRequiredSize(const ComputePassEncoderEndPassCmd& record) {\n    DAWN_UNUSED(record);\n\n    size_t result = 0;\n\n\n\n    {\n    }\n\n    return result;\n}\n// GetExtraRequiredSize isn't used for structures that are value members of other structures\n// because we assume they cannot contain pointers themselves.\nDAWN_UNUSED_FUNC(ComputePassEncoderEndPassGetExtraRequiredSize);\n\nDAWN_DECLARE_UNUSED WireResult ComputePassEncoderEndPassSerialize(\n    const ComputePassEncoderEndPassCmd& record,\n    ComputePassEncoderEndPassTransfer* transfer,\n    SerializeBuffer* buffer, const ObjectIdProvider& provider) {\n    DAWN_UNUSED(buffer);\n\n    transfer->commandId = WireCmd::ComputePassEncoderEndPass;\n\n    WIRE_TRY(provider.GetId(record.self, &transfer->self));\n\n\n\n\n    return WireResult::Success;\n}\nDAWN_UNUSED_FUNC(ComputePassEncoderEndPassSerialize);\n\nDAWN_DECLARE_UNUSED WireResult ComputePassEncoderEndPassDeserialize(\n    ComputePassEncoderEndPassCmd* record,\n    const volatile ComputePassEncoderEndPassTransfer* transfer,\n    DeserializeBuffer* deserializeBuffer,\n    DeserializeAllocator* allocator, const ObjectIdResolver& resolver) {\n    DAWN_UNUSED(allocator);\n\n    ASSERT(transfer->commandId == WireCmd::ComputePassEncoderEndPass);\n\n    record->selfId = transfer->self;\n\n    WIRE_TRY(resolver.GetFromId(transfer->self, &record->self));\n\n\n\n\n\n    return WireResult::Success;\n}\nDAWN_UNUSED_FUNC(ComputePassEncoderEndPassDeserialize);\n\n            \nstruct ComputePassEncoderInsertDebugMarkerTransfer : CmdHeader {\n    static_assert(1 <= 1,\n                  \"Record must be at most one of is_cmd, extensible, and chained.\");\n    WireCmd commandId;\n\n    ObjectId self;\n\n    uint64_t markerLabelStrlen;\n\n};\n\nstatic_assert(offsetof(ComputePassEncoderInsertDebugMarkerTransfer, commandSize) == 0);\nstatic_assert(offsetof(ComputePassEncoderInsertDebugMarkerTransfer, commandId) == sizeof(CmdHeader));\n\n\nDAWN_DECLARE_UNUSED size_t ComputePassEncoderInsertDebugMarkerGetExtraRequiredSize(const ComputePassEncoderInsertDebugMarkerCmd& record) {\n    DAWN_UNUSED(record);\n\n    size_t result = 0;\n\n\n\n    {\n    result += std::strlen(record.markerLabel);\n    }\n\n    {\n    }\n\n    return result;\n}\n// GetExtraRequiredSize isn't used for structures that are value members of other structures\n// because we assume they cannot contain pointers themselves.\nDAWN_UNUSED_FUNC(ComputePassEncoderInsertDebugMarkerGetExtraRequiredSize);\n\nDAWN_DECLARE_UNUSED WireResult ComputePassEncoderInsertDebugMarkerSerialize(\n    const ComputePassEncoderInsertDebugMarkerCmd& record,\n    ComputePassEncoderInsertDebugMarkerTransfer* transfer,\n    SerializeBuffer* buffer, const ObjectIdProvider& provider) {\n    DAWN_UNUSED(buffer);\n\n    transfer->commandId = WireCmd::ComputePassEncoderInsertDebugMarker;\n\n    WIRE_TRY(provider.GetId(record.self, &transfer->self));\n\n\n\n\n    {\n        transfer->markerLabelStrlen = std::strlen(record.markerLabel);\n\n        char* stringInBuffer;\n        WIRE_TRY(buffer->NextN(transfer->markerLabelStrlen, &stringInBuffer));\n        memcpy(stringInBuffer, record.markerLabel, transfer->markerLabelStrlen);\n    }\n\n    return WireResult::Success;\n}\nDAWN_UNUSED_FUNC(ComputePassEncoderInsertDebugMarkerSerialize);\n\nDAWN_DECLARE_UNUSED WireResult ComputePassEncoderInsertDebugMarkerDeserialize(\n    ComputePassEncoderInsertDebugMarkerCmd* record,\n    const volatile ComputePassEncoderInsertDebugMarkerTransfer* transfer,\n    DeserializeBuffer* deserializeBuffer,\n    DeserializeAllocator* allocator, const ObjectIdResolver& resolver) {\n    DAWN_UNUSED(allocator);\n\n    ASSERT(transfer->commandId == WireCmd::ComputePassEncoderInsertDebugMarker);\n\n    record->selfId = transfer->self;\n\n    WIRE_TRY(resolver.GetFromId(transfer->self, &record->self));\n\n\n\n\n    {\n        uint64_t stringLength64 = transfer->markerLabelStrlen;\n        if (stringLength64 >= std::numeric_limits<size_t>::max()) {\n            return WireResult::FatalError;\n        }\n        size_t stringLength = static_cast<size_t>(stringLength64);\n\n        const volatile char* stringInBuffer;\n        WIRE_TRY(deserializeBuffer->ReadN(stringLength, &stringInBuffer));\n\n        char* copiedString;\n        WIRE_TRY(GetSpace(allocator, stringLength + 1, &copiedString));\n        memcpy(copiedString, const_cast<const char*>(stringInBuffer), stringLength);\n        copiedString[stringLength] = '\\0';\n        record->markerLabel = copiedString;\n    }\n\n\n    return WireResult::Success;\n}\nDAWN_UNUSED_FUNC(ComputePassEncoderInsertDebugMarkerDeserialize);\n\n            \nstruct ComputePassEncoderPopDebugGroupTransfer : CmdHeader {\n    static_assert(1 <= 1,\n                  \"Record must be at most one of is_cmd, extensible, and chained.\");\n    WireCmd commandId;\n\n    ObjectId self;\n\n\n};\n\nstatic_assert(offsetof(ComputePassEncoderPopDebugGroupTransfer, commandSize) == 0);\nstatic_assert(offsetof(ComputePassEncoderPopDebugGroupTransfer, commandId) == sizeof(CmdHeader));\n\n\nDAWN_DECLARE_UNUSED size_t ComputePassEncoderPopDebugGroupGetExtraRequiredSize(const ComputePassEncoderPopDebugGroupCmd& record) {\n    DAWN_UNUSED(record);\n\n    size_t result = 0;\n\n\n\n    {\n    }\n\n    return result;\n}\n// GetExtraRequiredSize isn't used for structures that are value members of other structures\n// because we assume they cannot contain pointers themselves.\nDAWN_UNUSED_FUNC(ComputePassEncoderPopDebugGroupGetExtraRequiredSize);\n\nDAWN_DECLARE_UNUSED WireResult ComputePassEncoderPopDebugGroupSerialize(\n    const ComputePassEncoderPopDebugGroupCmd& record,\n    ComputePassEncoderPopDebugGroupTransfer* transfer,\n    SerializeBuffer* buffer, const ObjectIdProvider& provider) {\n    DAWN_UNUSED(buffer);\n\n    transfer->commandId = WireCmd::ComputePassEncoderPopDebugGroup;\n\n    WIRE_TRY(provider.GetId(record.self, &transfer->self));\n\n\n\n\n    return WireResult::Success;\n}\nDAWN_UNUSED_FUNC(ComputePassEncoderPopDebugGroupSerialize);\n\nDAWN_DECLARE_UNUSED WireResult ComputePassEncoderPopDebugGroupDeserialize(\n    ComputePassEncoderPopDebugGroupCmd* record,\n    const volatile ComputePassEncoderPopDebugGroupTransfer* transfer,\n    DeserializeBuffer* deserializeBuffer,\n    DeserializeAllocator* allocator, const ObjectIdResolver& resolver) {\n    DAWN_UNUSED(allocator);\n\n    ASSERT(transfer->commandId == WireCmd::ComputePassEncoderPopDebugGroup);\n\n    record->selfId = transfer->self;\n\n    WIRE_TRY(resolver.GetFromId(transfer->self, &record->self));\n\n\n\n\n\n    return WireResult::Success;\n}\nDAWN_UNUSED_FUNC(ComputePassEncoderPopDebugGroupDeserialize);\n\n            \nstruct ComputePassEncoderPushDebugGroupTransfer : CmdHeader {\n    static_assert(1 <= 1,\n                  \"Record must be at most one of is_cmd, extensible, and chained.\");\n    WireCmd commandId;\n\n    ObjectId self;\n\n    uint64_t groupLabelStrlen;\n\n};\n\nstatic_assert(offsetof(ComputePassEncoderPushDebugGroupTransfer, commandSize) == 0);\nstatic_assert(offsetof(ComputePassEncoderPushDebugGroupTransfer, commandId) == sizeof(CmdHeader));\n\n\nDAWN_DECLARE_UNUSED size_t ComputePassEncoderPushDebugGroupGetExtraRequiredSize(const ComputePassEncoderPushDebugGroupCmd& record) {\n    DAWN_UNUSED(record);\n\n    size_t result = 0;\n\n\n\n    {\n    result += std::strlen(record.groupLabel);\n    }\n\n    {\n    }\n\n    return result;\n}\n// GetExtraRequiredSize isn't used for structures that are value members of other structures\n// because we assume they cannot contain pointers themselves.\nDAWN_UNUSED_FUNC(ComputePassEncoderPushDebugGroupGetExtraRequiredSize);\n\nDAWN_DECLARE_UNUSED WireResult ComputePassEncoderPushDebugGroupSerialize(\n    const ComputePassEncoderPushDebugGroupCmd& record,\n    ComputePassEncoderPushDebugGroupTransfer* transfer,\n    SerializeBuffer* buffer, const ObjectIdProvider& provider) {\n    DAWN_UNUSED(buffer);\n\n    transfer->commandId = WireCmd::ComputePassEncoderPushDebugGroup;\n\n    WIRE_TRY(provider.GetId(record.self, &transfer->self));\n\n\n\n\n    {\n        transfer->groupLabelStrlen = std::strlen(record.groupLabel);\n\n        char* stringInBuffer;\n        WIRE_TRY(buffer->NextN(transfer->groupLabelStrlen, &stringInBuffer));\n        memcpy(stringInBuffer, record.groupLabel, transfer->groupLabelStrlen);\n    }\n\n    return WireResult::Success;\n}\nDAWN_UNUSED_FUNC(ComputePassEncoderPushDebugGroupSerialize);\n\nDAWN_DECLARE_UNUSED WireResult ComputePassEncoderPushDebugGroupDeserialize(\n    ComputePassEncoderPushDebugGroupCmd* record,\n    const volatile ComputePassEncoderPushDebugGroupTransfer* transfer,\n    DeserializeBuffer* deserializeBuffer,\n    DeserializeAllocator* allocator, const ObjectIdResolver& resolver) {\n    DAWN_UNUSED(allocator);\n\n    ASSERT(transfer->commandId == WireCmd::ComputePassEncoderPushDebugGroup);\n\n    record->selfId = transfer->self;\n\n    WIRE_TRY(resolver.GetFromId(transfer->self, &record->self));\n\n\n\n\n    {\n        uint64_t stringLength64 = transfer->groupLabelStrlen;\n        if (stringLength64 >= std::numeric_limits<size_t>::max()) {\n            return WireResult::FatalError;\n        }\n        size_t stringLength = static_cast<size_t>(stringLength64);\n\n        const volatile char* stringInBuffer;\n        WIRE_TRY(deserializeBuffer->ReadN(stringLength, &stringInBuffer));\n\n        char* copiedString;\n        WIRE_TRY(GetSpace(allocator, stringLength + 1, &copiedString));\n        memcpy(copiedString, const_cast<const char*>(stringInBuffer), stringLength);\n        copiedString[stringLength] = '\\0';\n        record->groupLabel = copiedString;\n    }\n\n\n    return WireResult::Success;\n}\nDAWN_UNUSED_FUNC(ComputePassEncoderPushDebugGroupDeserialize);\n\n            \nstruct ComputePassEncoderSetBindGroupTransfer : CmdHeader {\n    static_assert(1 <= 1,\n                  \"Record must be at most one of is_cmd, extensible, and chained.\");\n    WireCmd commandId;\n\n    ObjectId self;\n    \nuint32_t groupIndex;\n    ObjectId group;\n    \nuint32_t dynamicOffsetCount;\n\n\n};\n\nstatic_assert(offsetof(ComputePassEncoderSetBindGroupTransfer, commandSize) == 0);\nstatic_assert(offsetof(ComputePassEncoderSetBindGroupTransfer, commandId) == sizeof(CmdHeader));\n\n\nDAWN_DECLARE_UNUSED size_t ComputePassEncoderSetBindGroupGetExtraRequiredSize(const ComputePassEncoderSetBindGroupCmd& record) {\n    DAWN_UNUSED(record);\n\n    size_t result = 0;\n\n\n\n    {\n    }\n    {\n    }\n    {\n    }\n    {\n    }\n    {\n        \n        auto memberLength = record.dynamicOffsetCount;\n        result += memberLength * sizeof(\nuint32_t);\n    }\n\n    return result;\n}\n// GetExtraRequiredSize isn't used for structures that are value members of other structures\n// because we assume they cannot contain pointers themselves.\nDAWN_UNUSED_FUNC(ComputePassEncoderSetBindGroupGetExtraRequiredSize);\n\nDAWN_DECLARE_UNUSED WireResult ComputePassEncoderSetBindGroupSerialize(\n    const ComputePassEncoderSetBindGroupCmd& record,\n    ComputePassEncoderSetBindGroupTransfer* transfer,\n    SerializeBuffer* buffer, const ObjectIdProvider& provider) {\n    DAWN_UNUSED(buffer);\n\n    transfer->commandId = WireCmd::ComputePassEncoderSetBindGroup;\n\n    WIRE_TRY(provider.GetId(record.self, &transfer->self));\n    transfer->groupIndex = record.groupIndex;\n    WIRE_TRY(provider.GetId(record.group, &transfer->group));\n    transfer->dynamicOffsetCount = record.dynamicOffsetCount;\n\n\n\n\n    \n\n    {\n        auto memberLength = record.dynamicOffsetCount;\n\n        \nuint32_t* memberBuffer;\n        WIRE_TRY(buffer->NextN(memberLength, &memberBuffer));\n\n        memcpy(\n            memberBuffer, record.dynamicOffsets,\n            sizeof(\nuint32_t) * memberLength);\n    }\n    return WireResult::Success;\n}\nDAWN_UNUSED_FUNC(ComputePassEncoderSetBindGroupSerialize);\n\nDAWN_DECLARE_UNUSED WireResult ComputePassEncoderSetBindGroupDeserialize(\n    ComputePassEncoderSetBindGroupCmd* record,\n    const volatile ComputePassEncoderSetBindGroupTransfer* transfer,\n    DeserializeBuffer* deserializeBuffer,\n    DeserializeAllocator* allocator, const ObjectIdResolver& resolver) {\n    DAWN_UNUSED(allocator);\n\n    ASSERT(transfer->commandId == WireCmd::ComputePassEncoderSetBindGroup);\n\n    record->selfId = transfer->self;\n\n    WIRE_TRY(resolver.GetFromId(transfer->self, &record->self));\n    static_assert(sizeof(record->groupIndex) >= sizeof(transfer->groupIndex), \"Deserialize assignment may not narrow.\");\nrecord->groupIndex = transfer->groupIndex;\n    WIRE_TRY(resolver.GetFromId(transfer->group, &record->group));\n    static_assert(sizeof(record->dynamicOffsetCount) >= sizeof(transfer->dynamicOffsetCount), \"Deserialize assignment may not narrow.\");\nrecord->dynamicOffsetCount = transfer->dynamicOffsetCount;\n\n\n\n\n    \n\n    {\n        auto memberLength = record->dynamicOffsetCount;\n        const volatile \nuint32_t* memberBuffer;\n        WIRE_TRY(deserializeBuffer->ReadN(memberLength, &memberBuffer));\n\n        uint32_t* copiedMembers;\n        WIRE_TRY(GetSpace(allocator, memberLength, &copiedMembers));\n        record->dynamicOffsets = copiedMembers;\n\n        memcpy(\n            copiedMembers,\n            const_cast<const \nuint32_t*>(memberBuffer),\n           sizeof(\nuint32_t) * memberLength);\n    }\n\n    return WireResult::Success;\n}\nDAWN_UNUSED_FUNC(ComputePassEncoderSetBindGroupDeserialize);\n\n            \nstruct ComputePassEncoderSetLabelTransfer : CmdHeader {\n    static_assert(1 <= 1,\n                  \"Record must be at most one of is_cmd, extensible, and chained.\");\n    WireCmd commandId;\n\n    ObjectId self;\n\n    uint64_t labelStrlen;\n\n};\n\nstatic_assert(offsetof(ComputePassEncoderSetLabelTransfer, commandSize) == 0);\nstatic_assert(offsetof(ComputePassEncoderSetLabelTransfer, commandId) == sizeof(CmdHeader));\n\n\nDAWN_DECLARE_UNUSED size_t ComputePassEncoderSetLabelGetExtraRequiredSize(const ComputePassEncoderSetLabelCmd& record) {\n    DAWN_UNUSED(record);\n\n    size_t result = 0;\n\n\n\n    {\n    result += std::strlen(record.label);\n    }\n\n    {\n    }\n\n    return result;\n}\n// GetExtraRequiredSize isn't used for structures that are value members of other structures\n// because we assume they cannot contain pointers themselves.\nDAWN_UNUSED_FUNC(ComputePassEncoderSetLabelGetExtraRequiredSize);\n\nDAWN_DECLARE_UNUSED WireResult ComputePassEncoderSetLabelSerialize(\n    const ComputePassEncoderSetLabelCmd& record,\n    ComputePassEncoderSetLabelTransfer* transfer,\n    SerializeBuffer* buffer, const ObjectIdProvider& provider) {\n    DAWN_UNUSED(buffer);\n\n    transfer->commandId = WireCmd::ComputePassEncoderSetLabel;\n\n    WIRE_TRY(provider.GetId(record.self, &transfer->self));\n\n\n\n\n    {\n        transfer->labelStrlen = std::strlen(record.label);\n\n        char* stringInBuffer;\n        WIRE_TRY(buffer->NextN(transfer->labelStrlen, &stringInBuffer));\n        memcpy(stringInBuffer, record.label, transfer->labelStrlen);\n    }\n\n    return WireResult::Success;\n}\nDAWN_UNUSED_FUNC(ComputePassEncoderSetLabelSerialize);\n\nDAWN_DECLARE_UNUSED WireResult ComputePassEncoderSetLabelDeserialize(\n    ComputePassEncoderSetLabelCmd* record,\n    const volatile ComputePassEncoderSetLabelTransfer* transfer,\n    DeserializeBuffer* deserializeBuffer,\n    DeserializeAllocator* allocator, const ObjectIdResolver& resolver) {\n    DAWN_UNUSED(allocator);\n\n    ASSERT(transfer->commandId == WireCmd::ComputePassEncoderSetLabel);\n\n    record->selfId = transfer->self;\n\n    WIRE_TRY(resolver.GetFromId(transfer->self, &record->self));\n\n\n\n\n    {\n        uint64_t stringLength64 = transfer->labelStrlen;\n        if (stringLength64 >= std::numeric_limits<size_t>::max()) {\n            return WireResult::FatalError;\n        }\n        size_t stringLength = static_cast<size_t>(stringLength64);\n\n        const volatile char* stringInBuffer;\n        WIRE_TRY(deserializeBuffer->ReadN(stringLength, &stringInBuffer));\n\n        char* copiedString;\n        WIRE_TRY(GetSpace(allocator, stringLength + 1, &copiedString));\n        memcpy(copiedString, const_cast<const char*>(stringInBuffer), stringLength);\n        copiedString[stringLength] = '\\0';\n        record->label = copiedString;\n    }\n\n\n    return WireResult::Success;\n}\nDAWN_UNUSED_FUNC(ComputePassEncoderSetLabelDeserialize);\n\n            \nstruct ComputePassEncoderSetPipelineTransfer : CmdHeader {\n    static_assert(1 <= 1,\n                  \"Record must be at most one of is_cmd, extensible, and chained.\");\n    WireCmd commandId;\n\n    ObjectId self;\n    ObjectId pipeline;\n\n\n};\n\nstatic_assert(offsetof(ComputePassEncoderSetPipelineTransfer, commandSize) == 0);\nstatic_assert(offsetof(ComputePassEncoderSetPipelineTransfer, commandId) == sizeof(CmdHeader));\n\n\nDAWN_DECLARE_UNUSED size_t ComputePassEncoderSetPipelineGetExtraRequiredSize(const ComputePassEncoderSetPipelineCmd& record) {\n    DAWN_UNUSED(record);\n\n    size_t result = 0;\n\n\n\n    {\n    }\n    {\n    }\n\n    return result;\n}\n// GetExtraRequiredSize isn't used for structures that are value members of other structures\n// because we assume they cannot contain pointers themselves.\nDAWN_UNUSED_FUNC(ComputePassEncoderSetPipelineGetExtraRequiredSize);\n\nDAWN_DECLARE_UNUSED WireResult ComputePassEncoderSetPipelineSerialize(\n    const ComputePassEncoderSetPipelineCmd& record,\n    ComputePassEncoderSetPipelineTransfer* transfer,\n    SerializeBuffer* buffer, const ObjectIdProvider& provider) {\n    DAWN_UNUSED(buffer);\n\n    transfer->commandId = WireCmd::ComputePassEncoderSetPipeline;\n\n    WIRE_TRY(provider.GetId(record.self, &transfer->self));\n    WIRE_TRY(provider.GetId(record.pipeline, &transfer->pipeline));\n\n\n\n\n    return WireResult::Success;\n}\nDAWN_UNUSED_FUNC(ComputePassEncoderSetPipelineSerialize);\n\nDAWN_DECLARE_UNUSED WireResult ComputePassEncoderSetPipelineDeserialize(\n    ComputePassEncoderSetPipelineCmd* record,\n    const volatile ComputePassEncoderSetPipelineTransfer* transfer,\n    DeserializeBuffer* deserializeBuffer,\n    DeserializeAllocator* allocator, const ObjectIdResolver& resolver) {\n    DAWN_UNUSED(allocator);\n\n    ASSERT(transfer->commandId == WireCmd::ComputePassEncoderSetPipeline);\n\n    record->selfId = transfer->self;\n\n    WIRE_TRY(resolver.GetFromId(transfer->self, &record->self));\n    WIRE_TRY(resolver.GetFromId(transfer->pipeline, &record->pipeline));\n\n\n\n\n\n    return WireResult::Success;\n}\nDAWN_UNUSED_FUNC(ComputePassEncoderSetPipelineDeserialize);\n\n            \nstruct ComputePassEncoderWriteTimestampTransfer : CmdHeader {\n    static_assert(1 <= 1,\n                  \"Record must be at most one of is_cmd, extensible, and chained.\");\n    WireCmd commandId;\n\n    ObjectId self;\n    ObjectId querySet;\n    \nuint32_t queryIndex;\n\n\n};\n\nstatic_assert(offsetof(ComputePassEncoderWriteTimestampTransfer, commandSize) == 0);\nstatic_assert(offsetof(ComputePassEncoderWriteTimestampTransfer, commandId) == sizeof(CmdHeader));\n\n\nDAWN_DECLARE_UNUSED size_t ComputePassEncoderWriteTimestampGetExtraRequiredSize(const ComputePassEncoderWriteTimestampCmd& record) {\n    DAWN_UNUSED(record);\n\n    size_t result = 0;\n\n\n\n    {\n    }\n    {\n    }\n    {\n    }\n\n    return result;\n}\n// GetExtraRequiredSize isn't used for structures that are value members of other structures\n// because we assume they cannot contain pointers themselves.\nDAWN_UNUSED_FUNC(ComputePassEncoderWriteTimestampGetExtraRequiredSize);\n\nDAWN_DECLARE_UNUSED WireResult ComputePassEncoderWriteTimestampSerialize(\n    const ComputePassEncoderWriteTimestampCmd& record,\n    ComputePassEncoderWriteTimestampTransfer* transfer,\n    SerializeBuffer* buffer, const ObjectIdProvider& provider) {\n    DAWN_UNUSED(buffer);\n\n    transfer->commandId = WireCmd::ComputePassEncoderWriteTimestamp;\n\n    WIRE_TRY(provider.GetId(record.self, &transfer->self));\n    WIRE_TRY(provider.GetId(record.querySet, &transfer->querySet));\n    transfer->queryIndex = record.queryIndex;\n\n\n\n\n    return WireResult::Success;\n}\nDAWN_UNUSED_FUNC(ComputePassEncoderWriteTimestampSerialize);\n\nDAWN_DECLARE_UNUSED WireResult ComputePassEncoderWriteTimestampDeserialize(\n    ComputePassEncoderWriteTimestampCmd* record,\n    const volatile ComputePassEncoderWriteTimestampTransfer* transfer,\n    DeserializeBuffer* deserializeBuffer,\n    DeserializeAllocator* allocator, const ObjectIdResolver& resolver) {\n    DAWN_UNUSED(allocator);\n\n    ASSERT(transfer->commandId == WireCmd::ComputePassEncoderWriteTimestamp);\n\n    record->selfId = transfer->self;\n\n    WIRE_TRY(resolver.GetFromId(transfer->self, &record->self));\n    WIRE_TRY(resolver.GetFromId(transfer->querySet, &record->querySet));\n    static_assert(sizeof(record->queryIndex) >= sizeof(transfer->queryIndex), \"Deserialize assignment may not narrow.\");\nrecord->queryIndex = transfer->queryIndex;\n\n\n\n\n\n    return WireResult::Success;\n}\nDAWN_UNUSED_FUNC(ComputePassEncoderWriteTimestampDeserialize);\n\n            \nstruct ComputePipelineGetBindGroupLayoutTransfer : CmdHeader {\n    static_assert(1 <= 1,\n                  \"Record must be at most one of is_cmd, extensible, and chained.\");\n    WireCmd commandId;\n\n    ObjectId self;\n    \nuint32_t groupIndex;\n    \nObjectHandle result;\n\n\n};\n\nstatic_assert(offsetof(ComputePipelineGetBindGroupLayoutTransfer, commandSize) == 0);\nstatic_assert(offsetof(ComputePipelineGetBindGroupLayoutTransfer, commandId) == sizeof(CmdHeader));\n\n\nDAWN_DECLARE_UNUSED size_t ComputePipelineGetBindGroupLayoutGetExtraRequiredSize(const ComputePipelineGetBindGroupLayoutCmd& record) {\n    DAWN_UNUSED(record);\n\n    size_t result = 0;\n\n\n\n    {\n    }\n    {\n    }\n    {\n    }\n\n    return result;\n}\n// GetExtraRequiredSize isn't used for structures that are value members of other structures\n// because we assume they cannot contain pointers themselves.\nDAWN_UNUSED_FUNC(ComputePipelineGetBindGroupLayoutGetExtraRequiredSize);\n\nDAWN_DECLARE_UNUSED WireResult ComputePipelineGetBindGroupLayoutSerialize(\n    const ComputePipelineGetBindGroupLayoutCmd& record,\n    ComputePipelineGetBindGroupLayoutTransfer* transfer,\n    SerializeBuffer* buffer, const ObjectIdProvider& provider) {\n    DAWN_UNUSED(buffer);\n\n    transfer->commandId = WireCmd::ComputePipelineGetBindGroupLayout;\n\n    WIRE_TRY(provider.GetId(record.self, &transfer->self));\n    transfer->groupIndex = record.groupIndex;\n    transfer->result = record.result;\n\n\n\n\n    return WireResult::Success;\n}\nDAWN_UNUSED_FUNC(ComputePipelineGetBindGroupLayoutSerialize);\n\nDAWN_DECLARE_UNUSED WireResult ComputePipelineGetBindGroupLayoutDeserialize(\n    ComputePipelineGetBindGroupLayoutCmd* record,\n    const volatile ComputePipelineGetBindGroupLayoutTransfer* transfer,\n    DeserializeBuffer* deserializeBuffer,\n    DeserializeAllocator* allocator, const ObjectIdResolver& resolver) {\n    DAWN_UNUSED(allocator);\n\n    ASSERT(transfer->commandId == WireCmd::ComputePipelineGetBindGroupLayout);\n\n    record->selfId = transfer->self;\n\n    WIRE_TRY(resolver.GetFromId(transfer->self, &record->self));\n    static_assert(sizeof(record->groupIndex) >= sizeof(transfer->groupIndex), \"Deserialize assignment may not narrow.\");\nrecord->groupIndex = transfer->groupIndex;\n    static_assert(sizeof(record->result) >= sizeof(transfer->result), \"Deserialize assignment may not narrow.\");\nrecord->result = transfer->result;\n\n\n\n\n\n    return WireResult::Success;\n}\nDAWN_UNUSED_FUNC(ComputePipelineGetBindGroupLayoutDeserialize);\n\n            \nstruct ComputePipelineSetLabelTransfer : CmdHeader {\n    static_assert(1 <= 1,\n                  \"Record must be at most one of is_cmd, extensible, and chained.\");\n    WireCmd commandId;\n\n    ObjectId self;\n\n    uint64_t labelStrlen;\n\n};\n\nstatic_assert(offsetof(ComputePipelineSetLabelTransfer, commandSize) == 0);\nstatic_assert(offsetof(ComputePipelineSetLabelTransfer, commandId) == sizeof(CmdHeader));\n\n\nDAWN_DECLARE_UNUSED size_t ComputePipelineSetLabelGetExtraRequiredSize(const ComputePipelineSetLabelCmd& record) {\n    DAWN_UNUSED(record);\n\n    size_t result = 0;\n\n\n\n    {\n    result += std::strlen(record.label);\n    }\n\n    {\n    }\n\n    return result;\n}\n// GetExtraRequiredSize isn't used for structures that are value members of other structures\n// because we assume they cannot contain pointers themselves.\nDAWN_UNUSED_FUNC(ComputePipelineSetLabelGetExtraRequiredSize);\n\nDAWN_DECLARE_UNUSED WireResult ComputePipelineSetLabelSerialize(\n    const ComputePipelineSetLabelCmd& record,\n    ComputePipelineSetLabelTransfer* transfer,\n    SerializeBuffer* buffer, const ObjectIdProvider& provider) {\n    DAWN_UNUSED(buffer);\n\n    transfer->commandId = WireCmd::ComputePipelineSetLabel;\n\n    WIRE_TRY(provider.GetId(record.self, &transfer->self));\n\n\n\n\n    {\n        transfer->labelStrlen = std::strlen(record.label);\n\n        char* stringInBuffer;\n        WIRE_TRY(buffer->NextN(transfer->labelStrlen, &stringInBuffer));\n        memcpy(stringInBuffer, record.label, transfer->labelStrlen);\n    }\n\n    return WireResult::Success;\n}\nDAWN_UNUSED_FUNC(ComputePipelineSetLabelSerialize);\n\nDAWN_DECLARE_UNUSED WireResult ComputePipelineSetLabelDeserialize(\n    ComputePipelineSetLabelCmd* record,\n    const volatile ComputePipelineSetLabelTransfer* transfer,\n    DeserializeBuffer* deserializeBuffer,\n    DeserializeAllocator* allocator, const ObjectIdResolver& resolver) {\n    DAWN_UNUSED(allocator);\n\n    ASSERT(transfer->commandId == WireCmd::ComputePipelineSetLabel);\n\n    record->selfId = transfer->self;\n\n    WIRE_TRY(resolver.GetFromId(transfer->self, &record->self));\n\n\n\n\n    {\n        uint64_t stringLength64 = transfer->labelStrlen;\n        if (stringLength64 >= std::numeric_limits<size_t>::max()) {\n            return WireResult::FatalError;\n        }\n        size_t stringLength = static_cast<size_t>(stringLength64);\n\n        const volatile char* stringInBuffer;\n        WIRE_TRY(deserializeBuffer->ReadN(stringLength, &stringInBuffer));\n\n        char* copiedString;\n        WIRE_TRY(GetSpace(allocator, stringLength + 1, &copiedString));\n        memcpy(copiedString, const_cast<const char*>(stringInBuffer), stringLength);\n        copiedString[stringLength] = '\\0';\n        record->label = copiedString;\n    }\n\n\n    return WireResult::Success;\n}\nDAWN_UNUSED_FUNC(ComputePipelineSetLabelDeserialize);\n\n            \nstruct DestroyObjectTransfer : CmdHeader {\n    static_assert(1 <= 1,\n                  \"Record must be at most one of is_cmd, extensible, and chained.\");\n    WireCmd commandId;\n\n    \nObjectType objectType;\n    \nObjectId objectId;\n\n\n};\n\nstatic_assert(offsetof(DestroyObjectTransfer, commandSize) == 0);\nstatic_assert(offsetof(DestroyObjectTransfer, commandId) == sizeof(CmdHeader));\n\n\nDAWN_DECLARE_UNUSED size_t DestroyObjectGetExtraRequiredSize(const DestroyObjectCmd& record) {\n    DAWN_UNUSED(record);\n\n    size_t result = 0;\n\n\n\n    {\n    }\n    {\n    }\n\n    return result;\n}\n// GetExtraRequiredSize isn't used for structures that are value members of other structures\n// because we assume they cannot contain pointers themselves.\nDAWN_UNUSED_FUNC(DestroyObjectGetExtraRequiredSize);\n\nDAWN_DECLARE_UNUSED WireResult DestroyObjectSerialize(\n    const DestroyObjectCmd& record,\n    DestroyObjectTransfer* transfer,\n    SerializeBuffer* buffer) {\n    DAWN_UNUSED(buffer);\n\n    transfer->commandId = WireCmd::DestroyObject;\n\n    transfer->objectType = record.objectType;\n    transfer->objectId = record.objectId;\n\n\n\n\n    return WireResult::Success;\n}\nDAWN_UNUSED_FUNC(DestroyObjectSerialize);\n\nDAWN_DECLARE_UNUSED WireResult DestroyObjectDeserialize(\n    DestroyObjectCmd* record,\n    const volatile DestroyObjectTransfer* transfer,\n    DeserializeBuffer* deserializeBuffer,\n    DeserializeAllocator* allocator) {\n    DAWN_UNUSED(allocator);\n\n    ASSERT(transfer->commandId == WireCmd::DestroyObject);\n\n\n    static_assert(sizeof(record->objectType) >= sizeof(transfer->objectType), \"Deserialize assignment may not narrow.\");\nrecord->objectType = transfer->objectType;\n    static_assert(sizeof(record->objectId) >= sizeof(transfer->objectId), \"Deserialize assignment may not narrow.\");\nrecord->objectId = transfer->objectId;\n\n\n\n\n\n    return WireResult::Success;\n}\nDAWN_UNUSED_FUNC(DestroyObjectDeserialize);\n\n            \nstruct DeviceCreateBindGroupTransfer : CmdHeader {\n    static_assert(1 <= 1,\n                  \"Record must be at most one of is_cmd, extensible, and chained.\");\n    WireCmd commandId;\n\n    ObjectId self;\n    \nObjectHandle result;\n\n\n};\n\nstatic_assert(offsetof(DeviceCreateBindGroupTransfer, commandSize) == 0);\nstatic_assert(offsetof(DeviceCreateBindGroupTransfer, commandId) == sizeof(CmdHeader));\n\n\nDAWN_DECLARE_UNUSED size_t DeviceCreateBindGroupGetExtraRequiredSize(const DeviceCreateBindGroupCmd& record) {\n    DAWN_UNUSED(record);\n\n    size_t result = 0;\n\n\n\n    {\n    }\n    {\n        \n        auto memberLength = 1u;\n        result += memberLength * sizeof(WGPUBindGroupDescriptorTransfer);\n        for (decltype(memberLength) i = 0; i < memberLength; ++i) {\n            \n            result += WGPUBindGroupDescriptorGetExtraRequiredSize(record.descriptor[i]);\n        }\n    }\n    {\n    }\n\n    return result;\n}\n// GetExtraRequiredSize isn't used for structures that are value members of other structures\n// because we assume they cannot contain pointers themselves.\nDAWN_UNUSED_FUNC(DeviceCreateBindGroupGetExtraRequiredSize);\n\nDAWN_DECLARE_UNUSED WireResult DeviceCreateBindGroupSerialize(\n    const DeviceCreateBindGroupCmd& record,\n    DeviceCreateBindGroupTransfer* transfer,\n    SerializeBuffer* buffer, const ObjectIdProvider& provider) {\n    DAWN_UNUSED(buffer);\n\n    transfer->commandId = WireCmd::DeviceCreateBindGroup;\n\n    WIRE_TRY(provider.GetId(record.self, &transfer->self));\n    transfer->result = record.result;\n\n\n\n\n    \n\n    {\n        auto memberLength = 1u;\n\n        WGPUBindGroupDescriptorTransfer* memberBuffer;\n        WIRE_TRY(buffer->NextN(memberLength, &memberBuffer));\n\n        for (decltype(memberLength) i = 0; i < memberLength; ++i) {\n            WIRE_TRY(WGPUBindGroupDescriptorSerialize(record.descriptor[i], &memberBuffer[i], buffer, provider));\n        }\n    }\n    return WireResult::Success;\n}\nDAWN_UNUSED_FUNC(DeviceCreateBindGroupSerialize);\n\nDAWN_DECLARE_UNUSED WireResult DeviceCreateBindGroupDeserialize(\n    DeviceCreateBindGroupCmd* record,\n    const volatile DeviceCreateBindGroupTransfer* transfer,\n    DeserializeBuffer* deserializeBuffer,\n    DeserializeAllocator* allocator, const ObjectIdResolver& resolver) {\n    DAWN_UNUSED(allocator);\n\n    ASSERT(transfer->commandId == WireCmd::DeviceCreateBindGroup);\n\n    record->selfId = transfer->self;\n\n    WIRE_TRY(resolver.GetFromId(transfer->self, &record->self));\n    static_assert(sizeof(record->result) >= sizeof(transfer->result), \"Deserialize assignment may not narrow.\");\nrecord->result = transfer->result;\n\n\n\n\n    \n\n    {\n        auto memberLength = 1u;\n        const volatile WGPUBindGroupDescriptorTransfer* memberBuffer;\n        WIRE_TRY(deserializeBuffer->ReadN(memberLength, &memberBuffer));\n\n        WGPUBindGroupDescriptor* copiedMembers;\n        WIRE_TRY(GetSpace(allocator, memberLength, &copiedMembers));\n        record->descriptor = copiedMembers;\n\n        for (decltype(memberLength) i = 0; i < memberLength; ++i) {\n            WIRE_TRY(WGPUBindGroupDescriptorDeserialize(&copiedMembers[i], &memberBuffer[i], deserializeBuffer, allocator, resolver));\n        }\n    }\n\n    return WireResult::Success;\n}\nDAWN_UNUSED_FUNC(DeviceCreateBindGroupDeserialize);\n\n            \nstruct DeviceCreateBindGroupLayoutTransfer : CmdHeader {\n    static_assert(1 <= 1,\n                  \"Record must be at most one of is_cmd, extensible, and chained.\");\n    WireCmd commandId;\n\n    ObjectId self;\n    \nObjectHandle result;\n\n\n};\n\nstatic_assert(offsetof(DeviceCreateBindGroupLayoutTransfer, commandSize) == 0);\nstatic_assert(offsetof(DeviceCreateBindGroupLayoutTransfer, commandId) == sizeof(CmdHeader));\n\n\nDAWN_DECLARE_UNUSED size_t DeviceCreateBindGroupLayoutGetExtraRequiredSize(const DeviceCreateBindGroupLayoutCmd& record) {\n    DAWN_UNUSED(record);\n\n    size_t result = 0;\n\n\n\n    {\n    }\n    {\n        \n        auto memberLength = 1u;\n        result += memberLength * sizeof(WGPUBindGroupLayoutDescriptorTransfer);\n        for (decltype(memberLength) i = 0; i < memberLength; ++i) {\n            \n            result += WGPUBindGroupLayoutDescriptorGetExtraRequiredSize(record.descriptor[i]);\n        }\n    }\n    {\n    }\n\n    return result;\n}\n// GetExtraRequiredSize isn't used for structures that are value members of other structures\n// because we assume they cannot contain pointers themselves.\nDAWN_UNUSED_FUNC(DeviceCreateBindGroupLayoutGetExtraRequiredSize);\n\nDAWN_DECLARE_UNUSED WireResult DeviceCreateBindGroupLayoutSerialize(\n    const DeviceCreateBindGroupLayoutCmd& record,\n    DeviceCreateBindGroupLayoutTransfer* transfer,\n    SerializeBuffer* buffer, const ObjectIdProvider& provider) {\n    DAWN_UNUSED(buffer);\n\n    transfer->commandId = WireCmd::DeviceCreateBindGroupLayout;\n\n    WIRE_TRY(provider.GetId(record.self, &transfer->self));\n    transfer->result = record.result;\n\n\n\n\n    \n\n    {\n        auto memberLength = 1u;\n\n        WGPUBindGroupLayoutDescriptorTransfer* memberBuffer;\n        WIRE_TRY(buffer->NextN(memberLength, &memberBuffer));\n\n        for (decltype(memberLength) i = 0; i < memberLength; ++i) {\n            WIRE_TRY(WGPUBindGroupLayoutDescriptorSerialize(record.descriptor[i], &memberBuffer[i], buffer, provider));\n        }\n    }\n    return WireResult::Success;\n}\nDAWN_UNUSED_FUNC(DeviceCreateBindGroupLayoutSerialize);\n\nDAWN_DECLARE_UNUSED WireResult DeviceCreateBindGroupLayoutDeserialize(\n    DeviceCreateBindGroupLayoutCmd* record,\n    const volatile DeviceCreateBindGroupLayoutTransfer* transfer,\n    DeserializeBuffer* deserializeBuffer,\n    DeserializeAllocator* allocator, const ObjectIdResolver& resolver) {\n    DAWN_UNUSED(allocator);\n\n    ASSERT(transfer->commandId == WireCmd::DeviceCreateBindGroupLayout);\n\n    record->selfId = transfer->self;\n\n    WIRE_TRY(resolver.GetFromId(transfer->self, &record->self));\n    static_assert(sizeof(record->result) >= sizeof(transfer->result), \"Deserialize assignment may not narrow.\");\nrecord->result = transfer->result;\n\n\n\n\n    \n\n    {\n        auto memberLength = 1u;\n        const volatile WGPUBindGroupLayoutDescriptorTransfer* memberBuffer;\n        WIRE_TRY(deserializeBuffer->ReadN(memberLength, &memberBuffer));\n\n        WGPUBindGroupLayoutDescriptor* copiedMembers;\n        WIRE_TRY(GetSpace(allocator, memberLength, &copiedMembers));\n        record->descriptor = copiedMembers;\n\n        for (decltype(memberLength) i = 0; i < memberLength; ++i) {\n            WIRE_TRY(WGPUBindGroupLayoutDescriptorDeserialize(&copiedMembers[i], &memberBuffer[i], deserializeBuffer, allocator, resolver));\n        }\n    }\n\n    return WireResult::Success;\n}\nDAWN_UNUSED_FUNC(DeviceCreateBindGroupLayoutDeserialize);\n\n            \nstruct DeviceCreateBufferTransfer : CmdHeader {\n    static_assert(1 <= 1,\n                  \"Record must be at most one of is_cmd, extensible, and chained.\");\n    WireCmd commandId;\n\n    \nObjectId deviceId;\n    \nObjectHandle result;\n    \nuint64_t readHandleCreateInfoLength;\n    \nuint64_t writeHandleCreateInfoLength;\n\n\n};\n\nstatic_assert(offsetof(DeviceCreateBufferTransfer, commandSize) == 0);\nstatic_assert(offsetof(DeviceCreateBufferTransfer, commandId) == sizeof(CmdHeader));\n\n\nDAWN_DECLARE_UNUSED size_t DeviceCreateBufferGetExtraRequiredSize(const DeviceCreateBufferCmd& record) {\n    DAWN_UNUSED(record);\n\n    size_t result = 0;\n\n\n\n    {\n    }\n    {\n        \n        auto memberLength = 1u;\n        result += memberLength * sizeof(WGPUBufferDescriptorTransfer);\n        for (decltype(memberLength) i = 0; i < memberLength; ++i) {\n            \n            result += WGPUBufferDescriptorGetExtraRequiredSize(record.descriptor[i]);\n        }\n    }\n    {\n    }\n    {\n    }\n    {\n    }\n\n    return result;\n}\n// GetExtraRequiredSize isn't used for structures that are value members of other structures\n// because we assume they cannot contain pointers themselves.\nDAWN_UNUSED_FUNC(DeviceCreateBufferGetExtraRequiredSize);\n\nDAWN_DECLARE_UNUSED WireResult DeviceCreateBufferSerialize(\n    const DeviceCreateBufferCmd& record,\n    DeviceCreateBufferTransfer* transfer,\n    SerializeBuffer* buffer, const ObjectIdProvider& provider) {\n    DAWN_UNUSED(buffer);\n\n    transfer->commandId = WireCmd::DeviceCreateBuffer;\n\n    transfer->deviceId = record.deviceId;\n    transfer->result = record.result;\n    transfer->readHandleCreateInfoLength = record.readHandleCreateInfoLength;\n    transfer->writeHandleCreateInfoLength = record.writeHandleCreateInfoLength;\n\n\n\n\n    \n\n    {\n        auto memberLength = 1u;\n\n        WGPUBufferDescriptorTransfer* memberBuffer;\n        WIRE_TRY(buffer->NextN(memberLength, &memberBuffer));\n\n        for (decltype(memberLength) i = 0; i < memberLength; ++i) {\n            WIRE_TRY(WGPUBufferDescriptorSerialize(record.descriptor[i], &memberBuffer[i], buffer, provider));\n        }\n    }\n    return WireResult::Success;\n}\nDAWN_UNUSED_FUNC(DeviceCreateBufferSerialize);\n\nDAWN_DECLARE_UNUSED WireResult DeviceCreateBufferDeserialize(\n    DeviceCreateBufferCmd* record,\n    const volatile DeviceCreateBufferTransfer* transfer,\n    DeserializeBuffer* deserializeBuffer,\n    DeserializeAllocator* allocator, const ObjectIdResolver& resolver) {\n    DAWN_UNUSED(allocator);\n\n    ASSERT(transfer->commandId == WireCmd::DeviceCreateBuffer);\n\n\n    static_assert(sizeof(record->deviceId) >= sizeof(transfer->deviceId), \"Deserialize assignment may not narrow.\");\nrecord->deviceId = transfer->deviceId;\n    static_assert(sizeof(record->result) >= sizeof(transfer->result), \"Deserialize assignment may not narrow.\");\nrecord->result = transfer->result;\n    static_assert(sizeof(record->readHandleCreateInfoLength) >= sizeof(transfer->readHandleCreateInfoLength), \"Deserialize assignment may not narrow.\");\nrecord->readHandleCreateInfoLength = transfer->readHandleCreateInfoLength;\n    static_assert(sizeof(record->writeHandleCreateInfoLength) >= sizeof(transfer->writeHandleCreateInfoLength), \"Deserialize assignment may not narrow.\");\nrecord->writeHandleCreateInfoLength = transfer->writeHandleCreateInfoLength;\n\n\n\n\n    \n\n    {\n        auto memberLength = 1u;\n        const volatile WGPUBufferDescriptorTransfer* memberBuffer;\n        WIRE_TRY(deserializeBuffer->ReadN(memberLength, &memberBuffer));\n\n        WGPUBufferDescriptor* copiedMembers;\n        WIRE_TRY(GetSpace(allocator, memberLength, &copiedMembers));\n        record->descriptor = copiedMembers;\n\n        for (decltype(memberLength) i = 0; i < memberLength; ++i) {\n            WIRE_TRY(WGPUBufferDescriptorDeserialize(&copiedMembers[i], &memberBuffer[i], deserializeBuffer, allocator, resolver));\n        }\n    }\n    \n\n    {\n        auto memberLength = record->readHandleCreateInfoLength;\n        const volatile \nuint8_t* memberBuffer;\n        WIRE_TRY(deserializeBuffer->ReadN(memberLength, &memberBuffer));\n\n        uint8_t* copiedMembers;\n        WIRE_TRY(GetSpace(allocator, memberLength, &copiedMembers));\n        record->readHandleCreateInfo = copiedMembers;\n\n        memcpy(\n            copiedMembers,\n            const_cast<const \nuint8_t*>(memberBuffer),\n           sizeof(\nuint8_t) * memberLength);\n    }\n    \n\n    {\n        auto memberLength = record->writeHandleCreateInfoLength;\n        const volatile \nuint8_t* memberBuffer;\n        WIRE_TRY(deserializeBuffer->ReadN(memberLength, &memberBuffer));\n\n        uint8_t* copiedMembers;\n        WIRE_TRY(GetSpace(allocator, memberLength, &copiedMembers));\n        record->writeHandleCreateInfo = copiedMembers;\n\n        memcpy(\n            copiedMembers,\n            const_cast<const \nuint8_t*>(memberBuffer),\n           sizeof(\nuint8_t) * memberLength);\n    }\n\n    return WireResult::Success;\n}\nDAWN_UNUSED_FUNC(DeviceCreateBufferDeserialize);\n\n            \nstruct DeviceCreateCommandEncoderTransfer : CmdHeader {\n    static_assert(1 <= 1,\n                  \"Record must be at most one of is_cmd, extensible, and chained.\");\n    WireCmd commandId;\n\n    ObjectId self;\n    \nObjectHandle result;\n\n\n    bool has_descriptor;\n};\n\nstatic_assert(offsetof(DeviceCreateCommandEncoderTransfer, commandSize) == 0);\nstatic_assert(offsetof(DeviceCreateCommandEncoderTransfer, commandId) == sizeof(CmdHeader));\n\n\nDAWN_DECLARE_UNUSED size_t DeviceCreateCommandEncoderGetExtraRequiredSize(const DeviceCreateCommandEncoderCmd& record) {\n    DAWN_UNUSED(record);\n\n    size_t result = 0;\n\n\n\n    {\n    }\n    if (record.descriptor != nullptr)\n    {\n        \n        auto memberLength = 1u;\n        result += memberLength * sizeof(WGPUCommandEncoderDescriptorTransfer);\n        for (decltype(memberLength) i = 0; i < memberLength; ++i) {\n            \n            result += WGPUCommandEncoderDescriptorGetExtraRequiredSize(record.descriptor[i]);\n        }\n    }\n    {\n    }\n\n    return result;\n}\n// GetExtraRequiredSize isn't used for structures that are value members of other structures\n// because we assume they cannot contain pointers themselves.\nDAWN_UNUSED_FUNC(DeviceCreateCommandEncoderGetExtraRequiredSize);\n\nDAWN_DECLARE_UNUSED WireResult DeviceCreateCommandEncoderSerialize(\n    const DeviceCreateCommandEncoderCmd& record,\n    DeviceCreateCommandEncoderTransfer* transfer,\n    SerializeBuffer* buffer, const ObjectIdProvider& provider) {\n    DAWN_UNUSED(buffer);\n\n    transfer->commandId = WireCmd::DeviceCreateCommandEncoder;\n\n    WIRE_TRY(provider.GetId(record.self, &transfer->self));\n    transfer->result = record.result;\n\n\n\n\n    \n\n    bool has_descriptor = record.descriptor != nullptr;\n    transfer->has_descriptor = has_descriptor;\n    if (has_descriptor)\n    {\n        auto memberLength = 1u;\n\n        WGPUCommandEncoderDescriptorTransfer* memberBuffer;\n        WIRE_TRY(buffer->NextN(memberLength, &memberBuffer));\n\n        for (decltype(memberLength) i = 0; i < memberLength; ++i) {\n            WIRE_TRY(WGPUCommandEncoderDescriptorSerialize(record.descriptor[i], &memberBuffer[i], buffer, provider));\n        }\n    }\n    return WireResult::Success;\n}\nDAWN_UNUSED_FUNC(DeviceCreateCommandEncoderSerialize);\n\nDAWN_DECLARE_UNUSED WireResult DeviceCreateCommandEncoderDeserialize(\n    DeviceCreateCommandEncoderCmd* record,\n    const volatile DeviceCreateCommandEncoderTransfer* transfer,\n    DeserializeBuffer* deserializeBuffer,\n    DeserializeAllocator* allocator, const ObjectIdResolver& resolver) {\n    DAWN_UNUSED(allocator);\n\n    ASSERT(transfer->commandId == WireCmd::DeviceCreateCommandEncoder);\n\n    record->selfId = transfer->self;\n\n    WIRE_TRY(resolver.GetFromId(transfer->self, &record->self));\n    static_assert(sizeof(record->result) >= sizeof(transfer->result), \"Deserialize assignment may not narrow.\");\nrecord->result = transfer->result;\n\n\n\n\n    \n\n    \n    bool has_descriptor = transfer->has_descriptor;\n    record->descriptor = nullptr;\n    if (has_descriptor)\n    {\n        auto memberLength = 1u;\n        const volatile WGPUCommandEncoderDescriptorTransfer* memberBuffer;\n        WIRE_TRY(deserializeBuffer->ReadN(memberLength, &memberBuffer));\n\n        WGPUCommandEncoderDescriptor* copiedMembers;\n        WIRE_TRY(GetSpace(allocator, memberLength, &copiedMembers));\n        record->descriptor = copiedMembers;\n\n        for (decltype(memberLength) i = 0; i < memberLength; ++i) {\n            WIRE_TRY(WGPUCommandEncoderDescriptorDeserialize(&copiedMembers[i], &memberBuffer[i], deserializeBuffer, allocator, resolver));\n        }\n    }\n\n    return WireResult::Success;\n}\nDAWN_UNUSED_FUNC(DeviceCreateCommandEncoderDeserialize);\n\n            \nstruct DeviceCreateComputePipelineTransfer : CmdHeader {\n    static_assert(1 <= 1,\n                  \"Record must be at most one of is_cmd, extensible, and chained.\");\n    WireCmd commandId;\n\n    ObjectId self;\n    \nObjectHandle result;\n\n\n};\n\nstatic_assert(offsetof(DeviceCreateComputePipelineTransfer, commandSize) == 0);\nstatic_assert(offsetof(DeviceCreateComputePipelineTransfer, commandId) == sizeof(CmdHeader));\n\n\nDAWN_DECLARE_UNUSED size_t DeviceCreateComputePipelineGetExtraRequiredSize(const DeviceCreateComputePipelineCmd& record) {\n    DAWN_UNUSED(record);\n\n    size_t result = 0;\n\n\n\n    {\n    }\n    {\n        \n        auto memberLength = 1u;\n        result += memberLength * sizeof(WGPUComputePipelineDescriptorTransfer);\n        for (decltype(memberLength) i = 0; i < memberLength; ++i) {\n            \n            result += WGPUComputePipelineDescriptorGetExtraRequiredSize(record.descriptor[i]);\n        }\n    }\n    {\n    }\n\n    return result;\n}\n// GetExtraRequiredSize isn't used for structures that are value members of other structures\n// because we assume they cannot contain pointers themselves.\nDAWN_UNUSED_FUNC(DeviceCreateComputePipelineGetExtraRequiredSize);\n\nDAWN_DECLARE_UNUSED WireResult DeviceCreateComputePipelineSerialize(\n    const DeviceCreateComputePipelineCmd& record,\n    DeviceCreateComputePipelineTransfer* transfer,\n    SerializeBuffer* buffer, const ObjectIdProvider& provider) {\n    DAWN_UNUSED(buffer);\n\n    transfer->commandId = WireCmd::DeviceCreateComputePipeline;\n\n    WIRE_TRY(provider.GetId(record.self, &transfer->self));\n    transfer->result = record.result;\n\n\n\n\n    \n\n    {\n        auto memberLength = 1u;\n\n        WGPUComputePipelineDescriptorTransfer* memberBuffer;\n        WIRE_TRY(buffer->NextN(memberLength, &memberBuffer));\n\n        for (decltype(memberLength) i = 0; i < memberLength; ++i) {\n            WIRE_TRY(WGPUComputePipelineDescriptorSerialize(record.descriptor[i], &memberBuffer[i], buffer, provider));\n        }\n    }\n    return WireResult::Success;\n}\nDAWN_UNUSED_FUNC(DeviceCreateComputePipelineSerialize);\n\nDAWN_DECLARE_UNUSED WireResult DeviceCreateComputePipelineDeserialize(\n    DeviceCreateComputePipelineCmd* record,\n    const volatile DeviceCreateComputePipelineTransfer* transfer,\n    DeserializeBuffer* deserializeBuffer,\n    DeserializeAllocator* allocator, const ObjectIdResolver& resolver) {\n    DAWN_UNUSED(allocator);\n\n    ASSERT(transfer->commandId == WireCmd::DeviceCreateComputePipeline);\n\n    record->selfId = transfer->self;\n\n    WIRE_TRY(resolver.GetFromId(transfer->self, &record->self));\n    static_assert(sizeof(record->result) >= sizeof(transfer->result), \"Deserialize assignment may not narrow.\");\nrecord->result = transfer->result;\n\n\n\n\n    \n\n    {\n        auto memberLength = 1u;\n        const volatile WGPUComputePipelineDescriptorTransfer* memberBuffer;\n        WIRE_TRY(deserializeBuffer->ReadN(memberLength, &memberBuffer));\n\n        WGPUComputePipelineDescriptor* copiedMembers;\n        WIRE_TRY(GetSpace(allocator, memberLength, &copiedMembers));\n        record->descriptor = copiedMembers;\n\n        for (decltype(memberLength) i = 0; i < memberLength; ++i) {\n            WIRE_TRY(WGPUComputePipelineDescriptorDeserialize(&copiedMembers[i], &memberBuffer[i], deserializeBuffer, allocator, resolver));\n        }\n    }\n\n    return WireResult::Success;\n}\nDAWN_UNUSED_FUNC(DeviceCreateComputePipelineDeserialize);\n\n            \nstruct DeviceCreateComputePipelineAsyncTransfer : CmdHeader {\n    static_assert(1 <= 1,\n                  \"Record must be at most one of is_cmd, extensible, and chained.\");\n    WireCmd commandId;\n\n    \nObjectId deviceId;\n    \nuint64_t requestSerial;\n    \nObjectHandle pipelineObjectHandle;\n\n\n};\n\nstatic_assert(offsetof(DeviceCreateComputePipelineAsyncTransfer, commandSize) == 0);\nstatic_assert(offsetof(DeviceCreateComputePipelineAsyncTransfer, commandId) == sizeof(CmdHeader));\n\n\nDAWN_DECLARE_UNUSED size_t DeviceCreateComputePipelineAsyncGetExtraRequiredSize(const DeviceCreateComputePipelineAsyncCmd& record) {\n    DAWN_UNUSED(record);\n\n    size_t result = 0;\n\n\n\n    {\n    }\n    {\n    }\n    {\n    }\n    {\n        \n        auto memberLength = 1u;\n        result += memberLength * sizeof(WGPUComputePipelineDescriptorTransfer);\n        for (decltype(memberLength) i = 0; i < memberLength; ++i) {\n            \n            result += WGPUComputePipelineDescriptorGetExtraRequiredSize(record.descriptor[i]);\n        }\n    }\n\n    return result;\n}\n// GetExtraRequiredSize isn't used for structures that are value members of other structures\n// because we assume they cannot contain pointers themselves.\nDAWN_UNUSED_FUNC(DeviceCreateComputePipelineAsyncGetExtraRequiredSize);\n\nDAWN_DECLARE_UNUSED WireResult DeviceCreateComputePipelineAsyncSerialize(\n    const DeviceCreateComputePipelineAsyncCmd& record,\n    DeviceCreateComputePipelineAsyncTransfer* transfer,\n    SerializeBuffer* buffer, const ObjectIdProvider& provider) {\n    DAWN_UNUSED(buffer);\n\n    transfer->commandId = WireCmd::DeviceCreateComputePipelineAsync;\n\n    transfer->deviceId = record.deviceId;\n    transfer->requestSerial = record.requestSerial;\n    transfer->pipelineObjectHandle = record.pipelineObjectHandle;\n\n\n\n\n    \n\n    {\n        auto memberLength = 1u;\n\n        WGPUComputePipelineDescriptorTransfer* memberBuffer;\n        WIRE_TRY(buffer->NextN(memberLength, &memberBuffer));\n\n        for (decltype(memberLength) i = 0; i < memberLength; ++i) {\n            WIRE_TRY(WGPUComputePipelineDescriptorSerialize(record.descriptor[i], &memberBuffer[i], buffer, provider));\n        }\n    }\n    return WireResult::Success;\n}\nDAWN_UNUSED_FUNC(DeviceCreateComputePipelineAsyncSerialize);\n\nDAWN_DECLARE_UNUSED WireResult DeviceCreateComputePipelineAsyncDeserialize(\n    DeviceCreateComputePipelineAsyncCmd* record,\n    const volatile DeviceCreateComputePipelineAsyncTransfer* transfer,\n    DeserializeBuffer* deserializeBuffer,\n    DeserializeAllocator* allocator, const ObjectIdResolver& resolver) {\n    DAWN_UNUSED(allocator);\n\n    ASSERT(transfer->commandId == WireCmd::DeviceCreateComputePipelineAsync);\n\n\n    static_assert(sizeof(record->deviceId) >= sizeof(transfer->deviceId), \"Deserialize assignment may not narrow.\");\nrecord->deviceId = transfer->deviceId;\n    static_assert(sizeof(record->requestSerial) >= sizeof(transfer->requestSerial), \"Deserialize assignment may not narrow.\");\nrecord->requestSerial = transfer->requestSerial;\n    static_assert(sizeof(record->pipelineObjectHandle) >= sizeof(transfer->pipelineObjectHandle), \"Deserialize assignment may not narrow.\");\nrecord->pipelineObjectHandle = transfer->pipelineObjectHandle;\n\n\n\n\n    \n\n    {\n        auto memberLength = 1u;\n        const volatile WGPUComputePipelineDescriptorTransfer* memberBuffer;\n        WIRE_TRY(deserializeBuffer->ReadN(memberLength, &memberBuffer));\n\n        WGPUComputePipelineDescriptor* copiedMembers;\n        WIRE_TRY(GetSpace(allocator, memberLength, &copiedMembers));\n        record->descriptor = copiedMembers;\n\n        for (decltype(memberLength) i = 0; i < memberLength; ++i) {\n            WIRE_TRY(WGPUComputePipelineDescriptorDeserialize(&copiedMembers[i], &memberBuffer[i], deserializeBuffer, allocator, resolver));\n        }\n    }\n\n    return WireResult::Success;\n}\nDAWN_UNUSED_FUNC(DeviceCreateComputePipelineAsyncDeserialize);\n\n            \nstruct DeviceCreateErrorBufferTransfer : CmdHeader {\n    static_assert(1 <= 1,\n                  \"Record must be at most one of is_cmd, extensible, and chained.\");\n    WireCmd commandId;\n\n    ObjectId self;\n    \nObjectHandle result;\n\n\n};\n\nstatic_assert(offsetof(DeviceCreateErrorBufferTransfer, commandSize) == 0);\nstatic_assert(offsetof(DeviceCreateErrorBufferTransfer, commandId) == sizeof(CmdHeader));\n\n\nDAWN_DECLARE_UNUSED size_t DeviceCreateErrorBufferGetExtraRequiredSize(const DeviceCreateErrorBufferCmd& record) {\n    DAWN_UNUSED(record);\n\n    size_t result = 0;\n\n\n\n    {\n    }\n    {\n    }\n\n    return result;\n}\n// GetExtraRequiredSize isn't used for structures that are value members of other structures\n// because we assume they cannot contain pointers themselves.\nDAWN_UNUSED_FUNC(DeviceCreateErrorBufferGetExtraRequiredSize);\n\nDAWN_DECLARE_UNUSED WireResult DeviceCreateErrorBufferSerialize(\n    const DeviceCreateErrorBufferCmd& record,\n    DeviceCreateErrorBufferTransfer* transfer,\n    SerializeBuffer* buffer, const ObjectIdProvider& provider) {\n    DAWN_UNUSED(buffer);\n\n    transfer->commandId = WireCmd::DeviceCreateErrorBuffer;\n\n    WIRE_TRY(provider.GetId(record.self, &transfer->self));\n    transfer->result = record.result;\n\n\n\n\n    return WireResult::Success;\n}\nDAWN_UNUSED_FUNC(DeviceCreateErrorBufferSerialize);\n\nDAWN_DECLARE_UNUSED WireResult DeviceCreateErrorBufferDeserialize(\n    DeviceCreateErrorBufferCmd* record,\n    const volatile DeviceCreateErrorBufferTransfer* transfer,\n    DeserializeBuffer* deserializeBuffer,\n    DeserializeAllocator* allocator, const ObjectIdResolver& resolver) {\n    DAWN_UNUSED(allocator);\n\n    ASSERT(transfer->commandId == WireCmd::DeviceCreateErrorBuffer);\n\n    record->selfId = transfer->self;\n\n    WIRE_TRY(resolver.GetFromId(transfer->self, &record->self));\n    static_assert(sizeof(record->result) >= sizeof(transfer->result), \"Deserialize assignment may not narrow.\");\nrecord->result = transfer->result;\n\n\n\n\n\n    return WireResult::Success;\n}\nDAWN_UNUSED_FUNC(DeviceCreateErrorBufferDeserialize);\n\n            \nstruct DeviceCreateErrorExternalTextureTransfer : CmdHeader {\n    static_assert(1 <= 1,\n                  \"Record must be at most one of is_cmd, extensible, and chained.\");\n    WireCmd commandId;\n\n    ObjectId self;\n    \nObjectHandle result;\n\n\n};\n\nstatic_assert(offsetof(DeviceCreateErrorExternalTextureTransfer, commandSize) == 0);\nstatic_assert(offsetof(DeviceCreateErrorExternalTextureTransfer, commandId) == sizeof(CmdHeader));\n\n\nDAWN_DECLARE_UNUSED size_t DeviceCreateErrorExternalTextureGetExtraRequiredSize(const DeviceCreateErrorExternalTextureCmd& record) {\n    DAWN_UNUSED(record);\n\n    size_t result = 0;\n\n\n\n    {\n    }\n    {\n    }\n\n    return result;\n}\n// GetExtraRequiredSize isn't used for structures that are value members of other structures\n// because we assume they cannot contain pointers themselves.\nDAWN_UNUSED_FUNC(DeviceCreateErrorExternalTextureGetExtraRequiredSize);\n\nDAWN_DECLARE_UNUSED WireResult DeviceCreateErrorExternalTextureSerialize(\n    const DeviceCreateErrorExternalTextureCmd& record,\n    DeviceCreateErrorExternalTextureTransfer* transfer,\n    SerializeBuffer* buffer, const ObjectIdProvider& provider) {\n    DAWN_UNUSED(buffer);\n\n    transfer->commandId = WireCmd::DeviceCreateErrorExternalTexture;\n\n    WIRE_TRY(provider.GetId(record.self, &transfer->self));\n    transfer->result = record.result;\n\n\n\n\n    return WireResult::Success;\n}\nDAWN_UNUSED_FUNC(DeviceCreateErrorExternalTextureSerialize);\n\nDAWN_DECLARE_UNUSED WireResult DeviceCreateErrorExternalTextureDeserialize(\n    DeviceCreateErrorExternalTextureCmd* record,\n    const volatile DeviceCreateErrorExternalTextureTransfer* transfer,\n    DeserializeBuffer* deserializeBuffer,\n    DeserializeAllocator* allocator, const ObjectIdResolver& resolver) {\n    DAWN_UNUSED(allocator);\n\n    ASSERT(transfer->commandId == WireCmd::DeviceCreateErrorExternalTexture);\n\n    record->selfId = transfer->self;\n\n    WIRE_TRY(resolver.GetFromId(transfer->self, &record->self));\n    static_assert(sizeof(record->result) >= sizeof(transfer->result), \"Deserialize assignment may not narrow.\");\nrecord->result = transfer->result;\n\n\n\n\n\n    return WireResult::Success;\n}\nDAWN_UNUSED_FUNC(DeviceCreateErrorExternalTextureDeserialize);\n\n            \nstruct DeviceCreateErrorTextureTransfer : CmdHeader {\n    static_assert(1 <= 1,\n                  \"Record must be at most one of is_cmd, extensible, and chained.\");\n    WireCmd commandId;\n\n    ObjectId self;\n    \nObjectHandle result;\n\n\n};\n\nstatic_assert(offsetof(DeviceCreateErrorTextureTransfer, commandSize) == 0);\nstatic_assert(offsetof(DeviceCreateErrorTextureTransfer, commandId) == sizeof(CmdHeader));\n\n\nDAWN_DECLARE_UNUSED size_t DeviceCreateErrorTextureGetExtraRequiredSize(const DeviceCreateErrorTextureCmd& record) {\n    DAWN_UNUSED(record);\n\n    size_t result = 0;\n\n\n\n    {\n    }\n    {\n        \n        auto memberLength = 1u;\n        result += memberLength * sizeof(WGPUTextureDescriptorTransfer);\n        for (decltype(memberLength) i = 0; i < memberLength; ++i) {\n            \n            result += WGPUTextureDescriptorGetExtraRequiredSize(record.descriptor[i]);\n        }\n    }\n    {\n    }\n\n    return result;\n}\n// GetExtraRequiredSize isn't used for structures that are value members of other structures\n// because we assume they cannot contain pointers themselves.\nDAWN_UNUSED_FUNC(DeviceCreateErrorTextureGetExtraRequiredSize);\n\nDAWN_DECLARE_UNUSED WireResult DeviceCreateErrorTextureSerialize(\n    const DeviceCreateErrorTextureCmd& record,\n    DeviceCreateErrorTextureTransfer* transfer,\n    SerializeBuffer* buffer, const ObjectIdProvider& provider) {\n    DAWN_UNUSED(buffer);\n\n    transfer->commandId = WireCmd::DeviceCreateErrorTexture;\n\n    WIRE_TRY(provider.GetId(record.self, &transfer->self));\n    transfer->result = record.result;\n\n\n\n\n    \n\n    {\n        auto memberLength = 1u;\n\n        WGPUTextureDescriptorTransfer* memberBuffer;\n        WIRE_TRY(buffer->NextN(memberLength, &memberBuffer));\n\n        for (decltype(memberLength) i = 0; i < memberLength; ++i) {\n            WIRE_TRY(WGPUTextureDescriptorSerialize(record.descriptor[i], &memberBuffer[i], buffer, provider));\n        }\n    }\n    return WireResult::Success;\n}\nDAWN_UNUSED_FUNC(DeviceCreateErrorTextureSerialize);\n\nDAWN_DECLARE_UNUSED WireResult DeviceCreateErrorTextureDeserialize(\n    DeviceCreateErrorTextureCmd* record,\n    const volatile DeviceCreateErrorTextureTransfer* transfer,\n    DeserializeBuffer* deserializeBuffer,\n    DeserializeAllocator* allocator, const ObjectIdResolver& resolver) {\n    DAWN_UNUSED(allocator);\n\n    ASSERT(transfer->commandId == WireCmd::DeviceCreateErrorTexture);\n\n    record->selfId = transfer->self;\n\n    WIRE_TRY(resolver.GetFromId(transfer->self, &record->self));\n    static_assert(sizeof(record->result) >= sizeof(transfer->result), \"Deserialize assignment may not narrow.\");\nrecord->result = transfer->result;\n\n\n\n\n    \n\n    {\n        auto memberLength = 1u;\n        const volatile WGPUTextureDescriptorTransfer* memberBuffer;\n        WIRE_TRY(deserializeBuffer->ReadN(memberLength, &memberBuffer));\n\n        WGPUTextureDescriptor* copiedMembers;\n        WIRE_TRY(GetSpace(allocator, memberLength, &copiedMembers));\n        record->descriptor = copiedMembers;\n\n        for (decltype(memberLength) i = 0; i < memberLength; ++i) {\n            WIRE_TRY(WGPUTextureDescriptorDeserialize(&copiedMembers[i], &memberBuffer[i], deserializeBuffer, allocator, resolver));\n        }\n    }\n\n    return WireResult::Success;\n}\nDAWN_UNUSED_FUNC(DeviceCreateErrorTextureDeserialize);\n\n            \nstruct DeviceCreateExternalTextureTransfer : CmdHeader {\n    static_assert(1 <= 1,\n                  \"Record must be at most one of is_cmd, extensible, and chained.\");\n    WireCmd commandId;\n\n    ObjectId self;\n    \nObjectHandle result;\n\n\n};\n\nstatic_assert(offsetof(DeviceCreateExternalTextureTransfer, commandSize) == 0);\nstatic_assert(offsetof(DeviceCreateExternalTextureTransfer, commandId) == sizeof(CmdHeader));\n\n\nDAWN_DECLARE_UNUSED size_t DeviceCreateExternalTextureGetExtraRequiredSize(const DeviceCreateExternalTextureCmd& record) {\n    DAWN_UNUSED(record);\n\n    size_t result = 0;\n\n\n\n    {\n    }\n    {\n        \n        auto memberLength = 1u;\n        result += memberLength * sizeof(WGPUExternalTextureDescriptorTransfer);\n        for (decltype(memberLength) i = 0; i < memberLength; ++i) {\n            \n            result += WGPUExternalTextureDescriptorGetExtraRequiredSize(record.externalTextureDescriptor[i]);\n        }\n    }\n    {\n    }\n\n    return result;\n}\n// GetExtraRequiredSize isn't used for structures that are value members of other structures\n// because we assume they cannot contain pointers themselves.\nDAWN_UNUSED_FUNC(DeviceCreateExternalTextureGetExtraRequiredSize);\n\nDAWN_DECLARE_UNUSED WireResult DeviceCreateExternalTextureSerialize(\n    const DeviceCreateExternalTextureCmd& record,\n    DeviceCreateExternalTextureTransfer* transfer,\n    SerializeBuffer* buffer, const ObjectIdProvider& provider) {\n    DAWN_UNUSED(buffer);\n\n    transfer->commandId = WireCmd::DeviceCreateExternalTexture;\n\n    WIRE_TRY(provider.GetId(record.self, &transfer->self));\n    transfer->result = record.result;\n\n\n\n\n    \n\n    {\n        auto memberLength = 1u;\n\n        WGPUExternalTextureDescriptorTransfer* memberBuffer;\n        WIRE_TRY(buffer->NextN(memberLength, &memberBuffer));\n\n        for (decltype(memberLength) i = 0; i < memberLength; ++i) {\n            WIRE_TRY(WGPUExternalTextureDescriptorSerialize(record.externalTextureDescriptor[i], &memberBuffer[i], buffer, provider));\n        }\n    }\n    return WireResult::Success;\n}\nDAWN_UNUSED_FUNC(DeviceCreateExternalTextureSerialize);\n\nDAWN_DECLARE_UNUSED WireResult DeviceCreateExternalTextureDeserialize(\n    DeviceCreateExternalTextureCmd* record,\n    const volatile DeviceCreateExternalTextureTransfer* transfer,\n    DeserializeBuffer* deserializeBuffer,\n    DeserializeAllocator* allocator, const ObjectIdResolver& resolver) {\n    DAWN_UNUSED(allocator);\n\n    ASSERT(transfer->commandId == WireCmd::DeviceCreateExternalTexture);\n\n    record->selfId = transfer->self;\n\n    WIRE_TRY(resolver.GetFromId(transfer->self, &record->self));\n    static_assert(sizeof(record->result) >= sizeof(transfer->result), \"Deserialize assignment may not narrow.\");\nrecord->result = transfer->result;\n\n\n\n\n    \n\n    {\n        auto memberLength = 1u;\n        const volatile WGPUExternalTextureDescriptorTransfer* memberBuffer;\n        WIRE_TRY(deserializeBuffer->ReadN(memberLength, &memberBuffer));\n\n        WGPUExternalTextureDescriptor* copiedMembers;\n        WIRE_TRY(GetSpace(allocator, memberLength, &copiedMembers));\n        record->externalTextureDescriptor = copiedMembers;\n\n        for (decltype(memberLength) i = 0; i < memberLength; ++i) {\n            WIRE_TRY(WGPUExternalTextureDescriptorDeserialize(&copiedMembers[i], &memberBuffer[i], deserializeBuffer, allocator, resolver));\n        }\n    }\n\n    return WireResult::Success;\n}\nDAWN_UNUSED_FUNC(DeviceCreateExternalTextureDeserialize);\n\n            \nstruct DeviceCreatePipelineLayoutTransfer : CmdHeader {\n    static_assert(1 <= 1,\n                  \"Record must be at most one of is_cmd, extensible, and chained.\");\n    WireCmd commandId;\n\n    ObjectId self;\n    \nObjectHandle result;\n\n\n};\n\nstatic_assert(offsetof(DeviceCreatePipelineLayoutTransfer, commandSize) == 0);\nstatic_assert(offsetof(DeviceCreatePipelineLayoutTransfer, commandId) == sizeof(CmdHeader));\n\n\nDAWN_DECLARE_UNUSED size_t DeviceCreatePipelineLayoutGetExtraRequiredSize(const DeviceCreatePipelineLayoutCmd& record) {\n    DAWN_UNUSED(record);\n\n    size_t result = 0;\n\n\n\n    {\n    }\n    {\n        \n        auto memberLength = 1u;\n        result += memberLength * sizeof(WGPUPipelineLayoutDescriptorTransfer);\n        for (decltype(memberLength) i = 0; i < memberLength; ++i) {\n            \n            result += WGPUPipelineLayoutDescriptorGetExtraRequiredSize(record.descriptor[i]);\n        }\n    }\n    {\n    }\n\n    return result;\n}\n// GetExtraRequiredSize isn't used for structures that are value members of other structures\n// because we assume they cannot contain pointers themselves.\nDAWN_UNUSED_FUNC(DeviceCreatePipelineLayoutGetExtraRequiredSize);\n\nDAWN_DECLARE_UNUSED WireResult DeviceCreatePipelineLayoutSerialize(\n    const DeviceCreatePipelineLayoutCmd& record,\n    DeviceCreatePipelineLayoutTransfer* transfer,\n    SerializeBuffer* buffer, const ObjectIdProvider& provider) {\n    DAWN_UNUSED(buffer);\n\n    transfer->commandId = WireCmd::DeviceCreatePipelineLayout;\n\n    WIRE_TRY(provider.GetId(record.self, &transfer->self));\n    transfer->result = record.result;\n\n\n\n\n    \n\n    {\n        auto memberLength = 1u;\n\n        WGPUPipelineLayoutDescriptorTransfer* memberBuffer;\n        WIRE_TRY(buffer->NextN(memberLength, &memberBuffer));\n\n        for (decltype(memberLength) i = 0; i < memberLength; ++i) {\n            WIRE_TRY(WGPUPipelineLayoutDescriptorSerialize(record.descriptor[i], &memberBuffer[i], buffer, provider));\n        }\n    }\n    return WireResult::Success;\n}\nDAWN_UNUSED_FUNC(DeviceCreatePipelineLayoutSerialize);\n\nDAWN_DECLARE_UNUSED WireResult DeviceCreatePipelineLayoutDeserialize(\n    DeviceCreatePipelineLayoutCmd* record,\n    const volatile DeviceCreatePipelineLayoutTransfer* transfer,\n    DeserializeBuffer* deserializeBuffer,\n    DeserializeAllocator* allocator, const ObjectIdResolver& resolver) {\n    DAWN_UNUSED(allocator);\n\n    ASSERT(transfer->commandId == WireCmd::DeviceCreatePipelineLayout);\n\n    record->selfId = transfer->self;\n\n    WIRE_TRY(resolver.GetFromId(transfer->self, &record->self));\n    static_assert(sizeof(record->result) >= sizeof(transfer->result), \"Deserialize assignment may not narrow.\");\nrecord->result = transfer->result;\n\n\n\n\n    \n\n    {\n        auto memberLength = 1u;\n        const volatile WGPUPipelineLayoutDescriptorTransfer* memberBuffer;\n        WIRE_TRY(deserializeBuffer->ReadN(memberLength, &memberBuffer));\n\n        WGPUPipelineLayoutDescriptor* copiedMembers;\n        WIRE_TRY(GetSpace(allocator, memberLength, &copiedMembers));\n        record->descriptor = copiedMembers;\n\n        for (decltype(memberLength) i = 0; i < memberLength; ++i) {\n            WIRE_TRY(WGPUPipelineLayoutDescriptorDeserialize(&copiedMembers[i], &memberBuffer[i], deserializeBuffer, allocator, resolver));\n        }\n    }\n\n    return WireResult::Success;\n}\nDAWN_UNUSED_FUNC(DeviceCreatePipelineLayoutDeserialize);\n\n            \nstruct DeviceCreateQuerySetTransfer : CmdHeader {\n    static_assert(1 <= 1,\n                  \"Record must be at most one of is_cmd, extensible, and chained.\");\n    WireCmd commandId;\n\n    ObjectId self;\n    \nObjectHandle result;\n\n\n};\n\nstatic_assert(offsetof(DeviceCreateQuerySetTransfer, commandSize) == 0);\nstatic_assert(offsetof(DeviceCreateQuerySetTransfer, commandId) == sizeof(CmdHeader));\n\n\nDAWN_DECLARE_UNUSED size_t DeviceCreateQuerySetGetExtraRequiredSize(const DeviceCreateQuerySetCmd& record) {\n    DAWN_UNUSED(record);\n\n    size_t result = 0;\n\n\n\n    {\n    }\n    {\n        \n        auto memberLength = 1u;\n        result += memberLength * sizeof(WGPUQuerySetDescriptorTransfer);\n        for (decltype(memberLength) i = 0; i < memberLength; ++i) {\n            \n            result += WGPUQuerySetDescriptorGetExtraRequiredSize(record.descriptor[i]);\n        }\n    }\n    {\n    }\n\n    return result;\n}\n// GetExtraRequiredSize isn't used for structures that are value members of other structures\n// because we assume they cannot contain pointers themselves.\nDAWN_UNUSED_FUNC(DeviceCreateQuerySetGetExtraRequiredSize);\n\nDAWN_DECLARE_UNUSED WireResult DeviceCreateQuerySetSerialize(\n    const DeviceCreateQuerySetCmd& record,\n    DeviceCreateQuerySetTransfer* transfer,\n    SerializeBuffer* buffer, const ObjectIdProvider& provider) {\n    DAWN_UNUSED(buffer);\n\n    transfer->commandId = WireCmd::DeviceCreateQuerySet;\n\n    WIRE_TRY(provider.GetId(record.self, &transfer->self));\n    transfer->result = record.result;\n\n\n\n\n    \n\n    {\n        auto memberLength = 1u;\n\n        WGPUQuerySetDescriptorTransfer* memberBuffer;\n        WIRE_TRY(buffer->NextN(memberLength, &memberBuffer));\n\n        for (decltype(memberLength) i = 0; i < memberLength; ++i) {\n            WIRE_TRY(WGPUQuerySetDescriptorSerialize(record.descriptor[i], &memberBuffer[i], buffer, provider));\n        }\n    }\n    return WireResult::Success;\n}\nDAWN_UNUSED_FUNC(DeviceCreateQuerySetSerialize);\n\nDAWN_DECLARE_UNUSED WireResult DeviceCreateQuerySetDeserialize(\n    DeviceCreateQuerySetCmd* record,\n    const volatile DeviceCreateQuerySetTransfer* transfer,\n    DeserializeBuffer* deserializeBuffer,\n    DeserializeAllocator* allocator, const ObjectIdResolver& resolver) {\n    DAWN_UNUSED(allocator);\n\n    ASSERT(transfer->commandId == WireCmd::DeviceCreateQuerySet);\n\n    record->selfId = transfer->self;\n\n    WIRE_TRY(resolver.GetFromId(transfer->self, &record->self));\n    static_assert(sizeof(record->result) >= sizeof(transfer->result), \"Deserialize assignment may not narrow.\");\nrecord->result = transfer->result;\n\n\n\n\n    \n\n    {\n        auto memberLength = 1u;\n        const volatile WGPUQuerySetDescriptorTransfer* memberBuffer;\n        WIRE_TRY(deserializeBuffer->ReadN(memberLength, &memberBuffer));\n\n        WGPUQuerySetDescriptor* copiedMembers;\n        WIRE_TRY(GetSpace(allocator, memberLength, &copiedMembers));\n        record->descriptor = copiedMembers;\n\n        for (decltype(memberLength) i = 0; i < memberLength; ++i) {\n            WIRE_TRY(WGPUQuerySetDescriptorDeserialize(&copiedMembers[i], &memberBuffer[i], deserializeBuffer, allocator, resolver));\n        }\n    }\n\n    return WireResult::Success;\n}\nDAWN_UNUSED_FUNC(DeviceCreateQuerySetDeserialize);\n\n            \nstruct DeviceCreateRenderBundleEncoderTransfer : CmdHeader {\n    static_assert(1 <= 1,\n                  \"Record must be at most one of is_cmd, extensible, and chained.\");\n    WireCmd commandId;\n\n    ObjectId self;\n    \nObjectHandle result;\n\n\n};\n\nstatic_assert(offsetof(DeviceCreateRenderBundleEncoderTransfer, commandSize) == 0);\nstatic_assert(offsetof(DeviceCreateRenderBundleEncoderTransfer, commandId) == sizeof(CmdHeader));\n\n\nDAWN_DECLARE_UNUSED size_t DeviceCreateRenderBundleEncoderGetExtraRequiredSize(const DeviceCreateRenderBundleEncoderCmd& record) {\n    DAWN_UNUSED(record);\n\n    size_t result = 0;\n\n\n\n    {\n    }\n    {\n        \n        auto memberLength = 1u;\n        result += memberLength * sizeof(WGPURenderBundleEncoderDescriptorTransfer);\n        for (decltype(memberLength) i = 0; i < memberLength; ++i) {\n            \n            result += WGPURenderBundleEncoderDescriptorGetExtraRequiredSize(record.descriptor[i]);\n        }\n    }\n    {\n    }\n\n    return result;\n}\n// GetExtraRequiredSize isn't used for structures that are value members of other structures\n// because we assume they cannot contain pointers themselves.\nDAWN_UNUSED_FUNC(DeviceCreateRenderBundleEncoderGetExtraRequiredSize);\n\nDAWN_DECLARE_UNUSED WireResult DeviceCreateRenderBundleEncoderSerialize(\n    const DeviceCreateRenderBundleEncoderCmd& record,\n    DeviceCreateRenderBundleEncoderTransfer* transfer,\n    SerializeBuffer* buffer, const ObjectIdProvider& provider) {\n    DAWN_UNUSED(buffer);\n\n    transfer->commandId = WireCmd::DeviceCreateRenderBundleEncoder;\n\n    WIRE_TRY(provider.GetId(record.self, &transfer->self));\n    transfer->result = record.result;\n\n\n\n\n    \n\n    {\n        auto memberLength = 1u;\n\n        WGPURenderBundleEncoderDescriptorTransfer* memberBuffer;\n        WIRE_TRY(buffer->NextN(memberLength, &memberBuffer));\n\n        for (decltype(memberLength) i = 0; i < memberLength; ++i) {\n            WIRE_TRY(WGPURenderBundleEncoderDescriptorSerialize(record.descriptor[i], &memberBuffer[i], buffer, provider));\n        }\n    }\n    return WireResult::Success;\n}\nDAWN_UNUSED_FUNC(DeviceCreateRenderBundleEncoderSerialize);\n\nDAWN_DECLARE_UNUSED WireResult DeviceCreateRenderBundleEncoderDeserialize(\n    DeviceCreateRenderBundleEncoderCmd* record,\n    const volatile DeviceCreateRenderBundleEncoderTransfer* transfer,\n    DeserializeBuffer* deserializeBuffer,\n    DeserializeAllocator* allocator, const ObjectIdResolver& resolver) {\n    DAWN_UNUSED(allocator);\n\n    ASSERT(transfer->commandId == WireCmd::DeviceCreateRenderBundleEncoder);\n\n    record->selfId = transfer->self;\n\n    WIRE_TRY(resolver.GetFromId(transfer->self, &record->self));\n    static_assert(sizeof(record->result) >= sizeof(transfer->result), \"Deserialize assignment may not narrow.\");\nrecord->result = transfer->result;\n\n\n\n\n    \n\n    {\n        auto memberLength = 1u;\n        const volatile WGPURenderBundleEncoderDescriptorTransfer* memberBuffer;\n        WIRE_TRY(deserializeBuffer->ReadN(memberLength, &memberBuffer));\n\n        WGPURenderBundleEncoderDescriptor* copiedMembers;\n        WIRE_TRY(GetSpace(allocator, memberLength, &copiedMembers));\n        record->descriptor = copiedMembers;\n\n        for (decltype(memberLength) i = 0; i < memberLength; ++i) {\n            WIRE_TRY(WGPURenderBundleEncoderDescriptorDeserialize(&copiedMembers[i], &memberBuffer[i], deserializeBuffer, allocator, resolver));\n        }\n    }\n\n    return WireResult::Success;\n}\nDAWN_UNUSED_FUNC(DeviceCreateRenderBundleEncoderDeserialize);\n\n            \nstruct DeviceCreateRenderPipelineTransfer : CmdHeader {\n    static_assert(1 <= 1,\n                  \"Record must be at most one of is_cmd, extensible, and chained.\");\n    WireCmd commandId;\n\n    ObjectId self;\n    \nObjectHandle result;\n\n\n};\n\nstatic_assert(offsetof(DeviceCreateRenderPipelineTransfer, commandSize) == 0);\nstatic_assert(offsetof(DeviceCreateRenderPipelineTransfer, commandId) == sizeof(CmdHeader));\n\n\nDAWN_DECLARE_UNUSED size_t DeviceCreateRenderPipelineGetExtraRequiredSize(const DeviceCreateRenderPipelineCmd& record) {\n    DAWN_UNUSED(record);\n\n    size_t result = 0;\n\n\n\n    {\n    }\n    {\n        \n        auto memberLength = 1u;\n        result += memberLength * sizeof(WGPURenderPipelineDescriptorTransfer);\n        for (decltype(memberLength) i = 0; i < memberLength; ++i) {\n            \n            result += WGPURenderPipelineDescriptorGetExtraRequiredSize(record.descriptor[i]);\n        }\n    }\n    {\n    }\n\n    return result;\n}\n// GetExtraRequiredSize isn't used for structures that are value members of other structures\n// because we assume they cannot contain pointers themselves.\nDAWN_UNUSED_FUNC(DeviceCreateRenderPipelineGetExtraRequiredSize);\n\nDAWN_DECLARE_UNUSED WireResult DeviceCreateRenderPipelineSerialize(\n    const DeviceCreateRenderPipelineCmd& record,\n    DeviceCreateRenderPipelineTransfer* transfer,\n    SerializeBuffer* buffer, const ObjectIdProvider& provider) {\n    DAWN_UNUSED(buffer);\n\n    transfer->commandId = WireCmd::DeviceCreateRenderPipeline;\n\n    WIRE_TRY(provider.GetId(record.self, &transfer->self));\n    transfer->result = record.result;\n\n\n\n\n    \n\n    {\n        auto memberLength = 1u;\n\n        WGPURenderPipelineDescriptorTransfer* memberBuffer;\n        WIRE_TRY(buffer->NextN(memberLength, &memberBuffer));\n\n        for (decltype(memberLength) i = 0; i < memberLength; ++i) {\n            WIRE_TRY(WGPURenderPipelineDescriptorSerialize(record.descriptor[i], &memberBuffer[i], buffer, provider));\n        }\n    }\n    return WireResult::Success;\n}\nDAWN_UNUSED_FUNC(DeviceCreateRenderPipelineSerialize);\n\nDAWN_DECLARE_UNUSED WireResult DeviceCreateRenderPipelineDeserialize(\n    DeviceCreateRenderPipelineCmd* record,\n    const volatile DeviceCreateRenderPipelineTransfer* transfer,\n    DeserializeBuffer* deserializeBuffer,\n    DeserializeAllocator* allocator, const ObjectIdResolver& resolver) {\n    DAWN_UNUSED(allocator);\n\n    ASSERT(transfer->commandId == WireCmd::DeviceCreateRenderPipeline);\n\n    record->selfId = transfer->self;\n\n    WIRE_TRY(resolver.GetFromId(transfer->self, &record->self));\n    static_assert(sizeof(record->result) >= sizeof(transfer->result), \"Deserialize assignment may not narrow.\");\nrecord->result = transfer->result;\n\n\n\n\n    \n\n    {\n        auto memberLength = 1u;\n        const volatile WGPURenderPipelineDescriptorTransfer* memberBuffer;\n        WIRE_TRY(deserializeBuffer->ReadN(memberLength, &memberBuffer));\n\n        WGPURenderPipelineDescriptor* copiedMembers;\n        WIRE_TRY(GetSpace(allocator, memberLength, &copiedMembers));\n        record->descriptor = copiedMembers;\n\n        for (decltype(memberLength) i = 0; i < memberLength; ++i) {\n            WIRE_TRY(WGPURenderPipelineDescriptorDeserialize(&copiedMembers[i], &memberBuffer[i], deserializeBuffer, allocator, resolver));\n        }\n    }\n\n    return WireResult::Success;\n}\nDAWN_UNUSED_FUNC(DeviceCreateRenderPipelineDeserialize);\n\n            \nstruct DeviceCreateRenderPipelineAsyncTransfer : CmdHeader {\n    static_assert(1 <= 1,\n                  \"Record must be at most one of is_cmd, extensible, and chained.\");\n    WireCmd commandId;\n\n    \nObjectId deviceId;\n    \nuint64_t requestSerial;\n    \nObjectHandle pipelineObjectHandle;\n\n\n};\n\nstatic_assert(offsetof(DeviceCreateRenderPipelineAsyncTransfer, commandSize) == 0);\nstatic_assert(offsetof(DeviceCreateRenderPipelineAsyncTransfer, commandId) == sizeof(CmdHeader));\n\n\nDAWN_DECLARE_UNUSED size_t DeviceCreateRenderPipelineAsyncGetExtraRequiredSize(const DeviceCreateRenderPipelineAsyncCmd& record) {\n    DAWN_UNUSED(record);\n\n    size_t result = 0;\n\n\n\n    {\n    }\n    {\n    }\n    {\n    }\n    {\n        \n        auto memberLength = 1u;\n        result += memberLength * sizeof(WGPURenderPipelineDescriptorTransfer);\n        for (decltype(memberLength) i = 0; i < memberLength; ++i) {\n            \n            result += WGPURenderPipelineDescriptorGetExtraRequiredSize(record.descriptor[i]);\n        }\n    }\n\n    return result;\n}\n// GetExtraRequiredSize isn't used for structures that are value members of other structures\n// because we assume they cannot contain pointers themselves.\nDAWN_UNUSED_FUNC(DeviceCreateRenderPipelineAsyncGetExtraRequiredSize);\n\nDAWN_DECLARE_UNUSED WireResult DeviceCreateRenderPipelineAsyncSerialize(\n    const DeviceCreateRenderPipelineAsyncCmd& record,\n    DeviceCreateRenderPipelineAsyncTransfer* transfer,\n    SerializeBuffer* buffer, const ObjectIdProvider& provider) {\n    DAWN_UNUSED(buffer);\n\n    transfer->commandId = WireCmd::DeviceCreateRenderPipelineAsync;\n\n    transfer->deviceId = record.deviceId;\n    transfer->requestSerial = record.requestSerial;\n    transfer->pipelineObjectHandle = record.pipelineObjectHandle;\n\n\n\n\n    \n\n    {\n        auto memberLength = 1u;\n\n        WGPURenderPipelineDescriptorTransfer* memberBuffer;\n        WIRE_TRY(buffer->NextN(memberLength, &memberBuffer));\n\n        for (decltype(memberLength) i = 0; i < memberLength; ++i) {\n            WIRE_TRY(WGPURenderPipelineDescriptorSerialize(record.descriptor[i], &memberBuffer[i], buffer, provider));\n        }\n    }\n    return WireResult::Success;\n}\nDAWN_UNUSED_FUNC(DeviceCreateRenderPipelineAsyncSerialize);\n\nDAWN_DECLARE_UNUSED WireResult DeviceCreateRenderPipelineAsyncDeserialize(\n    DeviceCreateRenderPipelineAsyncCmd* record,\n    const volatile DeviceCreateRenderPipelineAsyncTransfer* transfer,\n    DeserializeBuffer* deserializeBuffer,\n    DeserializeAllocator* allocator, const ObjectIdResolver& resolver) {\n    DAWN_UNUSED(allocator);\n\n    ASSERT(transfer->commandId == WireCmd::DeviceCreateRenderPipelineAsync);\n\n\n    static_assert(sizeof(record->deviceId) >= sizeof(transfer->deviceId), \"Deserialize assignment may not narrow.\");\nrecord->deviceId = transfer->deviceId;\n    static_assert(sizeof(record->requestSerial) >= sizeof(transfer->requestSerial), \"Deserialize assignment may not narrow.\");\nrecord->requestSerial = transfer->requestSerial;\n    static_assert(sizeof(record->pipelineObjectHandle) >= sizeof(transfer->pipelineObjectHandle), \"Deserialize assignment may not narrow.\");\nrecord->pipelineObjectHandle = transfer->pipelineObjectHandle;\n\n\n\n\n    \n\n    {\n        auto memberLength = 1u;\n        const volatile WGPURenderPipelineDescriptorTransfer* memberBuffer;\n        WIRE_TRY(deserializeBuffer->ReadN(memberLength, &memberBuffer));\n\n        WGPURenderPipelineDescriptor* copiedMembers;\n        WIRE_TRY(GetSpace(allocator, memberLength, &copiedMembers));\n        record->descriptor = copiedMembers;\n\n        for (decltype(memberLength) i = 0; i < memberLength; ++i) {\n            WIRE_TRY(WGPURenderPipelineDescriptorDeserialize(&copiedMembers[i], &memberBuffer[i], deserializeBuffer, allocator, resolver));\n        }\n    }\n\n    return WireResult::Success;\n}\nDAWN_UNUSED_FUNC(DeviceCreateRenderPipelineAsyncDeserialize);\n\n            \nstruct DeviceCreateSamplerTransfer : CmdHeader {\n    static_assert(1 <= 1,\n                  \"Record must be at most one of is_cmd, extensible, and chained.\");\n    WireCmd commandId;\n\n    ObjectId self;\n    \nObjectHandle result;\n\n\n    bool has_descriptor;\n};\n\nstatic_assert(offsetof(DeviceCreateSamplerTransfer, commandSize) == 0);\nstatic_assert(offsetof(DeviceCreateSamplerTransfer, commandId) == sizeof(CmdHeader));\n\n\nDAWN_DECLARE_UNUSED size_t DeviceCreateSamplerGetExtraRequiredSize(const DeviceCreateSamplerCmd& record) {\n    DAWN_UNUSED(record);\n\n    size_t result = 0;\n\n\n\n    {\n    }\n    if (record.descriptor != nullptr)\n    {\n        \n        auto memberLength = 1u;\n        result += memberLength * sizeof(WGPUSamplerDescriptorTransfer);\n        for (decltype(memberLength) i = 0; i < memberLength; ++i) {\n            \n            result += WGPUSamplerDescriptorGetExtraRequiredSize(record.descriptor[i]);\n        }\n    }\n    {\n    }\n\n    return result;\n}\n// GetExtraRequiredSize isn't used for structures that are value members of other structures\n// because we assume they cannot contain pointers themselves.\nDAWN_UNUSED_FUNC(DeviceCreateSamplerGetExtraRequiredSize);\n\nDAWN_DECLARE_UNUSED WireResult DeviceCreateSamplerSerialize(\n    const DeviceCreateSamplerCmd& record,\n    DeviceCreateSamplerTransfer* transfer,\n    SerializeBuffer* buffer, const ObjectIdProvider& provider) {\n    DAWN_UNUSED(buffer);\n\n    transfer->commandId = WireCmd::DeviceCreateSampler;\n\n    WIRE_TRY(provider.GetId(record.self, &transfer->self));\n    transfer->result = record.result;\n\n\n\n\n    \n\n    bool has_descriptor = record.descriptor != nullptr;\n    transfer->has_descriptor = has_descriptor;\n    if (has_descriptor)\n    {\n        auto memberLength = 1u;\n\n        WGPUSamplerDescriptorTransfer* memberBuffer;\n        WIRE_TRY(buffer->NextN(memberLength, &memberBuffer));\n\n        for (decltype(memberLength) i = 0; i < memberLength; ++i) {\n            WIRE_TRY(WGPUSamplerDescriptorSerialize(record.descriptor[i], &memberBuffer[i], buffer, provider));\n        }\n    }\n    return WireResult::Success;\n}\nDAWN_UNUSED_FUNC(DeviceCreateSamplerSerialize);\n\nDAWN_DECLARE_UNUSED WireResult DeviceCreateSamplerDeserialize(\n    DeviceCreateSamplerCmd* record,\n    const volatile DeviceCreateSamplerTransfer* transfer,\n    DeserializeBuffer* deserializeBuffer,\n    DeserializeAllocator* allocator, const ObjectIdResolver& resolver) {\n    DAWN_UNUSED(allocator);\n\n    ASSERT(transfer->commandId == WireCmd::DeviceCreateSampler);\n\n    record->selfId = transfer->self;\n\n    WIRE_TRY(resolver.GetFromId(transfer->self, &record->self));\n    static_assert(sizeof(record->result) >= sizeof(transfer->result), \"Deserialize assignment may not narrow.\");\nrecord->result = transfer->result;\n\n\n\n\n    \n\n    \n    bool has_descriptor = transfer->has_descriptor;\n    record->descriptor = nullptr;\n    if (has_descriptor)\n    {\n        auto memberLength = 1u;\n        const volatile WGPUSamplerDescriptorTransfer* memberBuffer;\n        WIRE_TRY(deserializeBuffer->ReadN(memberLength, &memberBuffer));\n\n        WGPUSamplerDescriptor* copiedMembers;\n        WIRE_TRY(GetSpace(allocator, memberLength, &copiedMembers));\n        record->descriptor = copiedMembers;\n\n        for (decltype(memberLength) i = 0; i < memberLength; ++i) {\n            WIRE_TRY(WGPUSamplerDescriptorDeserialize(&copiedMembers[i], &memberBuffer[i], deserializeBuffer, allocator, resolver));\n        }\n    }\n\n    return WireResult::Success;\n}\nDAWN_UNUSED_FUNC(DeviceCreateSamplerDeserialize);\n\n            \nstruct DeviceCreateShaderModuleTransfer : CmdHeader {\n    static_assert(1 <= 1,\n                  \"Record must be at most one of is_cmd, extensible, and chained.\");\n    WireCmd commandId;\n\n    ObjectId self;\n    \nObjectHandle result;\n\n\n};\n\nstatic_assert(offsetof(DeviceCreateShaderModuleTransfer, commandSize) == 0);\nstatic_assert(offsetof(DeviceCreateShaderModuleTransfer, commandId) == sizeof(CmdHeader));\n\n\nDAWN_DECLARE_UNUSED size_t DeviceCreateShaderModuleGetExtraRequiredSize(const DeviceCreateShaderModuleCmd& record) {\n    DAWN_UNUSED(record);\n\n    size_t result = 0;\n\n\n\n    {\n    }\n    {\n        \n        auto memberLength = 1u;\n        result += memberLength * sizeof(WGPUShaderModuleDescriptorTransfer);\n        for (decltype(memberLength) i = 0; i < memberLength; ++i) {\n            \n            result += WGPUShaderModuleDescriptorGetExtraRequiredSize(record.descriptor[i]);\n        }\n    }\n    {\n    }\n\n    return result;\n}\n// GetExtraRequiredSize isn't used for structures that are value members of other structures\n// because we assume they cannot contain pointers themselves.\nDAWN_UNUSED_FUNC(DeviceCreateShaderModuleGetExtraRequiredSize);\n\nDAWN_DECLARE_UNUSED WireResult DeviceCreateShaderModuleSerialize(\n    const DeviceCreateShaderModuleCmd& record,\n    DeviceCreateShaderModuleTransfer* transfer,\n    SerializeBuffer* buffer, const ObjectIdProvider& provider) {\n    DAWN_UNUSED(buffer);\n\n    transfer->commandId = WireCmd::DeviceCreateShaderModule;\n\n    WIRE_TRY(provider.GetId(record.self, &transfer->self));\n    transfer->result = record.result;\n\n\n\n\n    \n\n    {\n        auto memberLength = 1u;\n\n        WGPUShaderModuleDescriptorTransfer* memberBuffer;\n        WIRE_TRY(buffer->NextN(memberLength, &memberBuffer));\n\n        for (decltype(memberLength) i = 0; i < memberLength; ++i) {\n            WIRE_TRY(WGPUShaderModuleDescriptorSerialize(record.descriptor[i], &memberBuffer[i], buffer, provider));\n        }\n    }\n    return WireResult::Success;\n}\nDAWN_UNUSED_FUNC(DeviceCreateShaderModuleSerialize);\n\nDAWN_DECLARE_UNUSED WireResult DeviceCreateShaderModuleDeserialize(\n    DeviceCreateShaderModuleCmd* record,\n    const volatile DeviceCreateShaderModuleTransfer* transfer,\n    DeserializeBuffer* deserializeBuffer,\n    DeserializeAllocator* allocator, const ObjectIdResolver& resolver) {\n    DAWN_UNUSED(allocator);\n\n    ASSERT(transfer->commandId == WireCmd::DeviceCreateShaderModule);\n\n    record->selfId = transfer->self;\n\n    WIRE_TRY(resolver.GetFromId(transfer->self, &record->self));\n    static_assert(sizeof(record->result) >= sizeof(transfer->result), \"Deserialize assignment may not narrow.\");\nrecord->result = transfer->result;\n\n\n\n\n    \n\n    {\n        auto memberLength = 1u;\n        const volatile WGPUShaderModuleDescriptorTransfer* memberBuffer;\n        WIRE_TRY(deserializeBuffer->ReadN(memberLength, &memberBuffer));\n\n        WGPUShaderModuleDescriptor* copiedMembers;\n        WIRE_TRY(GetSpace(allocator, memberLength, &copiedMembers));\n        record->descriptor = copiedMembers;\n\n        for (decltype(memberLength) i = 0; i < memberLength; ++i) {\n            WIRE_TRY(WGPUShaderModuleDescriptorDeserialize(&copiedMembers[i], &memberBuffer[i], deserializeBuffer, allocator, resolver));\n        }\n    }\n\n    return WireResult::Success;\n}\nDAWN_UNUSED_FUNC(DeviceCreateShaderModuleDeserialize);\n\n            \nstruct DeviceCreateSwapChainTransfer : CmdHeader {\n    static_assert(1 <= 1,\n                  \"Record must be at most one of is_cmd, extensible, and chained.\");\n    WireCmd commandId;\n\n    ObjectId self;\n    ObjectId surface;\n    \nObjectHandle result;\n\n\n};\n\nstatic_assert(offsetof(DeviceCreateSwapChainTransfer, commandSize) == 0);\nstatic_assert(offsetof(DeviceCreateSwapChainTransfer, commandId) == sizeof(CmdHeader));\n\n\nDAWN_DECLARE_UNUSED size_t DeviceCreateSwapChainGetExtraRequiredSize(const DeviceCreateSwapChainCmd& record) {\n    DAWN_UNUSED(record);\n\n    size_t result = 0;\n\n\n\n    {\n    }\n    {\n    }\n    {\n        \n        auto memberLength = 1u;\n        result += memberLength * sizeof(WGPUSwapChainDescriptorTransfer);\n        for (decltype(memberLength) i = 0; i < memberLength; ++i) {\n            \n            result += WGPUSwapChainDescriptorGetExtraRequiredSize(record.descriptor[i]);\n        }\n    }\n    {\n    }\n\n    return result;\n}\n// GetExtraRequiredSize isn't used for structures that are value members of other structures\n// because we assume they cannot contain pointers themselves.\nDAWN_UNUSED_FUNC(DeviceCreateSwapChainGetExtraRequiredSize);\n\nDAWN_DECLARE_UNUSED WireResult DeviceCreateSwapChainSerialize(\n    const DeviceCreateSwapChainCmd& record,\n    DeviceCreateSwapChainTransfer* transfer,\n    SerializeBuffer* buffer, const ObjectIdProvider& provider) {\n    DAWN_UNUSED(buffer);\n\n    transfer->commandId = WireCmd::DeviceCreateSwapChain;\n\n    WIRE_TRY(provider.GetId(record.self, &transfer->self));\n    WIRE_TRY(provider.GetOptionalId(record.surface, &transfer->surface));\n    transfer->result = record.result;\n\n\n\n\n    \n\n    {\n        auto memberLength = 1u;\n\n        WGPUSwapChainDescriptorTransfer* memberBuffer;\n        WIRE_TRY(buffer->NextN(memberLength, &memberBuffer));\n\n        for (decltype(memberLength) i = 0; i < memberLength; ++i) {\n            WIRE_TRY(WGPUSwapChainDescriptorSerialize(record.descriptor[i], &memberBuffer[i], buffer, provider));\n        }\n    }\n    return WireResult::Success;\n}\nDAWN_UNUSED_FUNC(DeviceCreateSwapChainSerialize);\n\nDAWN_DECLARE_UNUSED WireResult DeviceCreateSwapChainDeserialize(\n    DeviceCreateSwapChainCmd* record,\n    const volatile DeviceCreateSwapChainTransfer* transfer,\n    DeserializeBuffer* deserializeBuffer,\n    DeserializeAllocator* allocator, const ObjectIdResolver& resolver) {\n    DAWN_UNUSED(allocator);\n\n    ASSERT(transfer->commandId == WireCmd::DeviceCreateSwapChain);\n\n    record->selfId = transfer->self;\n\n    WIRE_TRY(resolver.GetFromId(transfer->self, &record->self));\n    WIRE_TRY(resolver.GetOptionalFromId(transfer->surface, &record->surface));\n    static_assert(sizeof(record->result) >= sizeof(transfer->result), \"Deserialize assignment may not narrow.\");\nrecord->result = transfer->result;\n\n\n\n\n    \n\n    {\n        auto memberLength = 1u;\n        const volatile WGPUSwapChainDescriptorTransfer* memberBuffer;\n        WIRE_TRY(deserializeBuffer->ReadN(memberLength, &memberBuffer));\n\n        WGPUSwapChainDescriptor* copiedMembers;\n        WIRE_TRY(GetSpace(allocator, memberLength, &copiedMembers));\n        record->descriptor = copiedMembers;\n\n        for (decltype(memberLength) i = 0; i < memberLength; ++i) {\n            WIRE_TRY(WGPUSwapChainDescriptorDeserialize(&copiedMembers[i], &memberBuffer[i], deserializeBuffer, allocator, resolver));\n        }\n    }\n\n    return WireResult::Success;\n}\nDAWN_UNUSED_FUNC(DeviceCreateSwapChainDeserialize);\n\n            \nstruct DeviceCreateTextureTransfer : CmdHeader {\n    static_assert(1 <= 1,\n                  \"Record must be at most one of is_cmd, extensible, and chained.\");\n    WireCmd commandId;\n\n    ObjectId self;\n    \nObjectHandle result;\n\n\n};\n\nstatic_assert(offsetof(DeviceCreateTextureTransfer, commandSize) == 0);\nstatic_assert(offsetof(DeviceCreateTextureTransfer, commandId) == sizeof(CmdHeader));\n\n\nDAWN_DECLARE_UNUSED size_t DeviceCreateTextureGetExtraRequiredSize(const DeviceCreateTextureCmd& record) {\n    DAWN_UNUSED(record);\n\n    size_t result = 0;\n\n\n\n    {\n    }\n    {\n        \n        auto memberLength = 1u;\n        result += memberLength * sizeof(WGPUTextureDescriptorTransfer);\n        for (decltype(memberLength) i = 0; i < memberLength; ++i) {\n            \n            result += WGPUTextureDescriptorGetExtraRequiredSize(record.descriptor[i]);\n        }\n    }\n    {\n    }\n\n    return result;\n}\n// GetExtraRequiredSize isn't used for structures that are value members of other structures\n// because we assume they cannot contain pointers themselves.\nDAWN_UNUSED_FUNC(DeviceCreateTextureGetExtraRequiredSize);\n\nDAWN_DECLARE_UNUSED WireResult DeviceCreateTextureSerialize(\n    const DeviceCreateTextureCmd& record,\n    DeviceCreateTextureTransfer* transfer,\n    SerializeBuffer* buffer, const ObjectIdProvider& provider) {\n    DAWN_UNUSED(buffer);\n\n    transfer->commandId = WireCmd::DeviceCreateTexture;\n\n    WIRE_TRY(provider.GetId(record.self, &transfer->self));\n    transfer->result = record.result;\n\n\n\n\n    \n\n    {\n        auto memberLength = 1u;\n\n        WGPUTextureDescriptorTransfer* memberBuffer;\n        WIRE_TRY(buffer->NextN(memberLength, &memberBuffer));\n\n        for (decltype(memberLength) i = 0; i < memberLength; ++i) {\n            WIRE_TRY(WGPUTextureDescriptorSerialize(record.descriptor[i], &memberBuffer[i], buffer, provider));\n        }\n    }\n    return WireResult::Success;\n}\nDAWN_UNUSED_FUNC(DeviceCreateTextureSerialize);\n\nDAWN_DECLARE_UNUSED WireResult DeviceCreateTextureDeserialize(\n    DeviceCreateTextureCmd* record,\n    const volatile DeviceCreateTextureTransfer* transfer,\n    DeserializeBuffer* deserializeBuffer,\n    DeserializeAllocator* allocator, const ObjectIdResolver& resolver) {\n    DAWN_UNUSED(allocator);\n\n    ASSERT(transfer->commandId == WireCmd::DeviceCreateTexture);\n\n    record->selfId = transfer->self;\n\n    WIRE_TRY(resolver.GetFromId(transfer->self, &record->self));\n    static_assert(sizeof(record->result) >= sizeof(transfer->result), \"Deserialize assignment may not narrow.\");\nrecord->result = transfer->result;\n\n\n\n\n    \n\n    {\n        auto memberLength = 1u;\n        const volatile WGPUTextureDescriptorTransfer* memberBuffer;\n        WIRE_TRY(deserializeBuffer->ReadN(memberLength, &memberBuffer));\n\n        WGPUTextureDescriptor* copiedMembers;\n        WIRE_TRY(GetSpace(allocator, memberLength, &copiedMembers));\n        record->descriptor = copiedMembers;\n\n        for (decltype(memberLength) i = 0; i < memberLength; ++i) {\n            WIRE_TRY(WGPUTextureDescriptorDeserialize(&copiedMembers[i], &memberBuffer[i], deserializeBuffer, allocator, resolver));\n        }\n    }\n\n    return WireResult::Success;\n}\nDAWN_UNUSED_FUNC(DeviceCreateTextureDeserialize);\n\n            \nstruct DeviceDestroyTransfer : CmdHeader {\n    static_assert(1 <= 1,\n                  \"Record must be at most one of is_cmd, extensible, and chained.\");\n    WireCmd commandId;\n\n    ObjectId self;\n\n\n};\n\nstatic_assert(offsetof(DeviceDestroyTransfer, commandSize) == 0);\nstatic_assert(offsetof(DeviceDestroyTransfer, commandId) == sizeof(CmdHeader));\n\n\nDAWN_DECLARE_UNUSED size_t DeviceDestroyGetExtraRequiredSize(const DeviceDestroyCmd& record) {\n    DAWN_UNUSED(record);\n\n    size_t result = 0;\n\n\n\n    {\n    }\n\n    return result;\n}\n// GetExtraRequiredSize isn't used for structures that are value members of other structures\n// because we assume they cannot contain pointers themselves.\nDAWN_UNUSED_FUNC(DeviceDestroyGetExtraRequiredSize);\n\nDAWN_DECLARE_UNUSED WireResult DeviceDestroySerialize(\n    const DeviceDestroyCmd& record,\n    DeviceDestroyTransfer* transfer,\n    SerializeBuffer* buffer, const ObjectIdProvider& provider) {\n    DAWN_UNUSED(buffer);\n\n    transfer->commandId = WireCmd::DeviceDestroy;\n\n    WIRE_TRY(provider.GetId(record.self, &transfer->self));\n\n\n\n\n    return WireResult::Success;\n}\nDAWN_UNUSED_FUNC(DeviceDestroySerialize);\n\nDAWN_DECLARE_UNUSED WireResult DeviceDestroyDeserialize(\n    DeviceDestroyCmd* record,\n    const volatile DeviceDestroyTransfer* transfer,\n    DeserializeBuffer* deserializeBuffer,\n    DeserializeAllocator* allocator, const ObjectIdResolver& resolver) {\n    DAWN_UNUSED(allocator);\n\n    ASSERT(transfer->commandId == WireCmd::DeviceDestroy);\n\n    record->selfId = transfer->self;\n\n    WIRE_TRY(resolver.GetFromId(transfer->self, &record->self));\n\n\n\n\n\n    return WireResult::Success;\n}\nDAWN_UNUSED_FUNC(DeviceDestroyDeserialize);\n\n            \nstruct DeviceGetQueueTransfer : CmdHeader {\n    static_assert(1 <= 1,\n                  \"Record must be at most one of is_cmd, extensible, and chained.\");\n    WireCmd commandId;\n\n    ObjectId self;\n    \nObjectHandle result;\n\n\n};\n\nstatic_assert(offsetof(DeviceGetQueueTransfer, commandSize) == 0);\nstatic_assert(offsetof(DeviceGetQueueTransfer, commandId) == sizeof(CmdHeader));\n\n\nDAWN_DECLARE_UNUSED size_t DeviceGetQueueGetExtraRequiredSize(const DeviceGetQueueCmd& record) {\n    DAWN_UNUSED(record);\n\n    size_t result = 0;\n\n\n\n    {\n    }\n    {\n    }\n\n    return result;\n}\n// GetExtraRequiredSize isn't used for structures that are value members of other structures\n// because we assume they cannot contain pointers themselves.\nDAWN_UNUSED_FUNC(DeviceGetQueueGetExtraRequiredSize);\n\nDAWN_DECLARE_UNUSED WireResult DeviceGetQueueSerialize(\n    const DeviceGetQueueCmd& record,\n    DeviceGetQueueTransfer* transfer,\n    SerializeBuffer* buffer, const ObjectIdProvider& provider) {\n    DAWN_UNUSED(buffer);\n\n    transfer->commandId = WireCmd::DeviceGetQueue;\n\n    WIRE_TRY(provider.GetId(record.self, &transfer->self));\n    transfer->result = record.result;\n\n\n\n\n    return WireResult::Success;\n}\nDAWN_UNUSED_FUNC(DeviceGetQueueSerialize);\n\nDAWN_DECLARE_UNUSED WireResult DeviceGetQueueDeserialize(\n    DeviceGetQueueCmd* record,\n    const volatile DeviceGetQueueTransfer* transfer,\n    DeserializeBuffer* deserializeBuffer,\n    DeserializeAllocator* allocator, const ObjectIdResolver& resolver) {\n    DAWN_UNUSED(allocator);\n\n    ASSERT(transfer->commandId == WireCmd::DeviceGetQueue);\n\n    record->selfId = transfer->self;\n\n    WIRE_TRY(resolver.GetFromId(transfer->self, &record->self));\n    static_assert(sizeof(record->result) >= sizeof(transfer->result), \"Deserialize assignment may not narrow.\");\nrecord->result = transfer->result;\n\n\n\n\n\n    return WireResult::Success;\n}\nDAWN_UNUSED_FUNC(DeviceGetQueueDeserialize);\n\n            \nstruct DeviceInjectErrorTransfer : CmdHeader {\n    static_assert(1 <= 1,\n                  \"Record must be at most one of is_cmd, extensible, and chained.\");\n    WireCmd commandId;\n\n    ObjectId self;\n    \nWGPUErrorType type;\n\n    uint64_t messageStrlen;\n\n};\n\nstatic_assert(offsetof(DeviceInjectErrorTransfer, commandSize) == 0);\nstatic_assert(offsetof(DeviceInjectErrorTransfer, commandId) == sizeof(CmdHeader));\n\n\nDAWN_DECLARE_UNUSED size_t DeviceInjectErrorGetExtraRequiredSize(const DeviceInjectErrorCmd& record) {\n    DAWN_UNUSED(record);\n\n    size_t result = 0;\n\n\n\n    {\n    result += std::strlen(record.message);\n    }\n\n    {\n    }\n    {\n    }\n\n    return result;\n}\n// GetExtraRequiredSize isn't used for structures that are value members of other structures\n// because we assume they cannot contain pointers themselves.\nDAWN_UNUSED_FUNC(DeviceInjectErrorGetExtraRequiredSize);\n\nDAWN_DECLARE_UNUSED WireResult DeviceInjectErrorSerialize(\n    const DeviceInjectErrorCmd& record,\n    DeviceInjectErrorTransfer* transfer,\n    SerializeBuffer* buffer, const ObjectIdProvider& provider) {\n    DAWN_UNUSED(buffer);\n\n    transfer->commandId = WireCmd::DeviceInjectError;\n\n    WIRE_TRY(provider.GetId(record.self, &transfer->self));\n    transfer->type = record.type;\n\n\n\n\n    {\n        transfer->messageStrlen = std::strlen(record.message);\n\n        char* stringInBuffer;\n        WIRE_TRY(buffer->NextN(transfer->messageStrlen, &stringInBuffer));\n        memcpy(stringInBuffer, record.message, transfer->messageStrlen);\n    }\n\n    return WireResult::Success;\n}\nDAWN_UNUSED_FUNC(DeviceInjectErrorSerialize);\n\nDAWN_DECLARE_UNUSED WireResult DeviceInjectErrorDeserialize(\n    DeviceInjectErrorCmd* record,\n    const volatile DeviceInjectErrorTransfer* transfer,\n    DeserializeBuffer* deserializeBuffer,\n    DeserializeAllocator* allocator, const ObjectIdResolver& resolver) {\n    DAWN_UNUSED(allocator);\n\n    ASSERT(transfer->commandId == WireCmd::DeviceInjectError);\n\n    record->selfId = transfer->self;\n\n    WIRE_TRY(resolver.GetFromId(transfer->self, &record->self));\n    static_assert(sizeof(record->type) >= sizeof(transfer->type), \"Deserialize assignment may not narrow.\");\nrecord->type = transfer->type;\n\n\n\n\n    {\n        uint64_t stringLength64 = transfer->messageStrlen;\n        if (stringLength64 >= std::numeric_limits<size_t>::max()) {\n            return WireResult::FatalError;\n        }\n        size_t stringLength = static_cast<size_t>(stringLength64);\n\n        const volatile char* stringInBuffer;\n        WIRE_TRY(deserializeBuffer->ReadN(stringLength, &stringInBuffer));\n\n        char* copiedString;\n        WIRE_TRY(GetSpace(allocator, stringLength + 1, &copiedString));\n        memcpy(copiedString, const_cast<const char*>(stringInBuffer), stringLength);\n        copiedString[stringLength] = '\\0';\n        record->message = copiedString;\n    }\n\n\n    return WireResult::Success;\n}\nDAWN_UNUSED_FUNC(DeviceInjectErrorDeserialize);\n\n            \nstruct DeviceLoseForTestingTransfer : CmdHeader {\n    static_assert(1 <= 1,\n                  \"Record must be at most one of is_cmd, extensible, and chained.\");\n    WireCmd commandId;\n\n    ObjectId self;\n\n\n};\n\nstatic_assert(offsetof(DeviceLoseForTestingTransfer, commandSize) == 0);\nstatic_assert(offsetof(DeviceLoseForTestingTransfer, commandId) == sizeof(CmdHeader));\n\n\nDAWN_DECLARE_UNUSED size_t DeviceLoseForTestingGetExtraRequiredSize(const DeviceLoseForTestingCmd& record) {\n    DAWN_UNUSED(record);\n\n    size_t result = 0;\n\n\n\n    {\n    }\n\n    return result;\n}\n// GetExtraRequiredSize isn't used for structures that are value members of other structures\n// because we assume they cannot contain pointers themselves.\nDAWN_UNUSED_FUNC(DeviceLoseForTestingGetExtraRequiredSize);\n\nDAWN_DECLARE_UNUSED WireResult DeviceLoseForTestingSerialize(\n    const DeviceLoseForTestingCmd& record,\n    DeviceLoseForTestingTransfer* transfer,\n    SerializeBuffer* buffer, const ObjectIdProvider& provider) {\n    DAWN_UNUSED(buffer);\n\n    transfer->commandId = WireCmd::DeviceLoseForTesting;\n\n    WIRE_TRY(provider.GetId(record.self, &transfer->self));\n\n\n\n\n    return WireResult::Success;\n}\nDAWN_UNUSED_FUNC(DeviceLoseForTestingSerialize);\n\nDAWN_DECLARE_UNUSED WireResult DeviceLoseForTestingDeserialize(\n    DeviceLoseForTestingCmd* record,\n    const volatile DeviceLoseForTestingTransfer* transfer,\n    DeserializeBuffer* deserializeBuffer,\n    DeserializeAllocator* allocator, const ObjectIdResolver& resolver) {\n    DAWN_UNUSED(allocator);\n\n    ASSERT(transfer->commandId == WireCmd::DeviceLoseForTesting);\n\n    record->selfId = transfer->self;\n\n    WIRE_TRY(resolver.GetFromId(transfer->self, &record->self));\n\n\n\n\n\n    return WireResult::Success;\n}\nDAWN_UNUSED_FUNC(DeviceLoseForTestingDeserialize);\n\n            \nstruct DevicePopErrorScopeTransfer : CmdHeader {\n    static_assert(1 <= 1,\n                  \"Record must be at most one of is_cmd, extensible, and chained.\");\n    WireCmd commandId;\n\n    \nObjectId deviceId;\n    \nuint64_t requestSerial;\n\n\n};\n\nstatic_assert(offsetof(DevicePopErrorScopeTransfer, commandSize) == 0);\nstatic_assert(offsetof(DevicePopErrorScopeTransfer, commandId) == sizeof(CmdHeader));\n\n\nDAWN_DECLARE_UNUSED size_t DevicePopErrorScopeGetExtraRequiredSize(const DevicePopErrorScopeCmd& record) {\n    DAWN_UNUSED(record);\n\n    size_t result = 0;\n\n\n\n    {\n    }\n    {\n    }\n\n    return result;\n}\n// GetExtraRequiredSize isn't used for structures that are value members of other structures\n// because we assume they cannot contain pointers themselves.\nDAWN_UNUSED_FUNC(DevicePopErrorScopeGetExtraRequiredSize);\n\nDAWN_DECLARE_UNUSED WireResult DevicePopErrorScopeSerialize(\n    const DevicePopErrorScopeCmd& record,\n    DevicePopErrorScopeTransfer* transfer,\n    SerializeBuffer* buffer) {\n    DAWN_UNUSED(buffer);\n\n    transfer->commandId = WireCmd::DevicePopErrorScope;\n\n    transfer->deviceId = record.deviceId;\n    transfer->requestSerial = record.requestSerial;\n\n\n\n\n    return WireResult::Success;\n}\nDAWN_UNUSED_FUNC(DevicePopErrorScopeSerialize);\n\nDAWN_DECLARE_UNUSED WireResult DevicePopErrorScopeDeserialize(\n    DevicePopErrorScopeCmd* record,\n    const volatile DevicePopErrorScopeTransfer* transfer,\n    DeserializeBuffer* deserializeBuffer,\n    DeserializeAllocator* allocator) {\n    DAWN_UNUSED(allocator);\n\n    ASSERT(transfer->commandId == WireCmd::DevicePopErrorScope);\n\n\n    static_assert(sizeof(record->deviceId) >= sizeof(transfer->deviceId), \"Deserialize assignment may not narrow.\");\nrecord->deviceId = transfer->deviceId;\n    static_assert(sizeof(record->requestSerial) >= sizeof(transfer->requestSerial), \"Deserialize assignment may not narrow.\");\nrecord->requestSerial = transfer->requestSerial;\n\n\n\n\n\n    return WireResult::Success;\n}\nDAWN_UNUSED_FUNC(DevicePopErrorScopeDeserialize);\n\n            \nstruct DevicePushErrorScopeTransfer : CmdHeader {\n    static_assert(1 <= 1,\n                  \"Record must be at most one of is_cmd, extensible, and chained.\");\n    WireCmd commandId;\n\n    ObjectId self;\n    \nWGPUErrorFilter filter;\n\n\n};\n\nstatic_assert(offsetof(DevicePushErrorScopeTransfer, commandSize) == 0);\nstatic_assert(offsetof(DevicePushErrorScopeTransfer, commandId) == sizeof(CmdHeader));\n\n\nDAWN_DECLARE_UNUSED size_t DevicePushErrorScopeGetExtraRequiredSize(const DevicePushErrorScopeCmd& record) {\n    DAWN_UNUSED(record);\n\n    size_t result = 0;\n\n\n\n    {\n    }\n    {\n    }\n\n    return result;\n}\n// GetExtraRequiredSize isn't used for structures that are value members of other structures\n// because we assume they cannot contain pointers themselves.\nDAWN_UNUSED_FUNC(DevicePushErrorScopeGetExtraRequiredSize);\n\nDAWN_DECLARE_UNUSED WireResult DevicePushErrorScopeSerialize(\n    const DevicePushErrorScopeCmd& record,\n    DevicePushErrorScopeTransfer* transfer,\n    SerializeBuffer* buffer, const ObjectIdProvider& provider) {\n    DAWN_UNUSED(buffer);\n\n    transfer->commandId = WireCmd::DevicePushErrorScope;\n\n    WIRE_TRY(provider.GetId(record.self, &transfer->self));\n    transfer->filter = record.filter;\n\n\n\n\n    return WireResult::Success;\n}\nDAWN_UNUSED_FUNC(DevicePushErrorScopeSerialize);\n\nDAWN_DECLARE_UNUSED WireResult DevicePushErrorScopeDeserialize(\n    DevicePushErrorScopeCmd* record,\n    const volatile DevicePushErrorScopeTransfer* transfer,\n    DeserializeBuffer* deserializeBuffer,\n    DeserializeAllocator* allocator, const ObjectIdResolver& resolver) {\n    DAWN_UNUSED(allocator);\n\n    ASSERT(transfer->commandId == WireCmd::DevicePushErrorScope);\n\n    record->selfId = transfer->self;\n\n    WIRE_TRY(resolver.GetFromId(transfer->self, &record->self));\n    static_assert(sizeof(record->filter) >= sizeof(transfer->filter), \"Deserialize assignment may not narrow.\");\nrecord->filter = transfer->filter;\n\n\n\n\n\n    return WireResult::Success;\n}\nDAWN_UNUSED_FUNC(DevicePushErrorScopeDeserialize);\n\n            \nstruct DeviceSetLabelTransfer : CmdHeader {\n    static_assert(1 <= 1,\n                  \"Record must be at most one of is_cmd, extensible, and chained.\");\n    WireCmd commandId;\n\n    ObjectId self;\n\n    uint64_t labelStrlen;\n\n};\n\nstatic_assert(offsetof(DeviceSetLabelTransfer, commandSize) == 0);\nstatic_assert(offsetof(DeviceSetLabelTransfer, commandId) == sizeof(CmdHeader));\n\n\nDAWN_DECLARE_UNUSED size_t DeviceSetLabelGetExtraRequiredSize(const DeviceSetLabelCmd& record) {\n    DAWN_UNUSED(record);\n\n    size_t result = 0;\n\n\n\n    {\n    result += std::strlen(record.label);\n    }\n\n    {\n    }\n\n    return result;\n}\n// GetExtraRequiredSize isn't used for structures that are value members of other structures\n// because we assume they cannot contain pointers themselves.\nDAWN_UNUSED_FUNC(DeviceSetLabelGetExtraRequiredSize);\n\nDAWN_DECLARE_UNUSED WireResult DeviceSetLabelSerialize(\n    const DeviceSetLabelCmd& record,\n    DeviceSetLabelTransfer* transfer,\n    SerializeBuffer* buffer, const ObjectIdProvider& provider) {\n    DAWN_UNUSED(buffer);\n\n    transfer->commandId = WireCmd::DeviceSetLabel;\n\n    WIRE_TRY(provider.GetId(record.self, &transfer->self));\n\n\n\n\n    {\n        transfer->labelStrlen = std::strlen(record.label);\n\n        char* stringInBuffer;\n        WIRE_TRY(buffer->NextN(transfer->labelStrlen, &stringInBuffer));\n        memcpy(stringInBuffer, record.label, transfer->labelStrlen);\n    }\n\n    return WireResult::Success;\n}\nDAWN_UNUSED_FUNC(DeviceSetLabelSerialize);\n\nDAWN_DECLARE_UNUSED WireResult DeviceSetLabelDeserialize(\n    DeviceSetLabelCmd* record,\n    const volatile DeviceSetLabelTransfer* transfer,\n    DeserializeBuffer* deserializeBuffer,\n    DeserializeAllocator* allocator, const ObjectIdResolver& resolver) {\n    DAWN_UNUSED(allocator);\n\n    ASSERT(transfer->commandId == WireCmd::DeviceSetLabel);\n\n    record->selfId = transfer->self;\n\n    WIRE_TRY(resolver.GetFromId(transfer->self, &record->self));\n\n\n\n\n    {\n        uint64_t stringLength64 = transfer->labelStrlen;\n        if (stringLength64 >= std::numeric_limits<size_t>::max()) {\n            return WireResult::FatalError;\n        }\n        size_t stringLength = static_cast<size_t>(stringLength64);\n\n        const volatile char* stringInBuffer;\n        WIRE_TRY(deserializeBuffer->ReadN(stringLength, &stringInBuffer));\n\n        char* copiedString;\n        WIRE_TRY(GetSpace(allocator, stringLength + 1, &copiedString));\n        memcpy(copiedString, const_cast<const char*>(stringInBuffer), stringLength);\n        copiedString[stringLength] = '\\0';\n        record->label = copiedString;\n    }\n\n\n    return WireResult::Success;\n}\nDAWN_UNUSED_FUNC(DeviceSetLabelDeserialize);\n\n            \nstruct DeviceTickTransfer : CmdHeader {\n    static_assert(1 <= 1,\n                  \"Record must be at most one of is_cmd, extensible, and chained.\");\n    WireCmd commandId;\n\n    ObjectId self;\n\n\n};\n\nstatic_assert(offsetof(DeviceTickTransfer, commandSize) == 0);\nstatic_assert(offsetof(DeviceTickTransfer, commandId) == sizeof(CmdHeader));\n\n\nDAWN_DECLARE_UNUSED size_t DeviceTickGetExtraRequiredSize(const DeviceTickCmd& record) {\n    DAWN_UNUSED(record);\n\n    size_t result = 0;\n\n\n\n    {\n    }\n\n    return result;\n}\n// GetExtraRequiredSize isn't used for structures that are value members of other structures\n// because we assume they cannot contain pointers themselves.\nDAWN_UNUSED_FUNC(DeviceTickGetExtraRequiredSize);\n\nDAWN_DECLARE_UNUSED WireResult DeviceTickSerialize(\n    const DeviceTickCmd& record,\n    DeviceTickTransfer* transfer,\n    SerializeBuffer* buffer, const ObjectIdProvider& provider) {\n    DAWN_UNUSED(buffer);\n\n    transfer->commandId = WireCmd::DeviceTick;\n\n    WIRE_TRY(provider.GetId(record.self, &transfer->self));\n\n\n\n\n    return WireResult::Success;\n}\nDAWN_UNUSED_FUNC(DeviceTickSerialize);\n\nDAWN_DECLARE_UNUSED WireResult DeviceTickDeserialize(\n    DeviceTickCmd* record,\n    const volatile DeviceTickTransfer* transfer,\n    DeserializeBuffer* deserializeBuffer,\n    DeserializeAllocator* allocator, const ObjectIdResolver& resolver) {\n    DAWN_UNUSED(allocator);\n\n    ASSERT(transfer->commandId == WireCmd::DeviceTick);\n\n    record->selfId = transfer->self;\n\n    WIRE_TRY(resolver.GetFromId(transfer->self, &record->self));\n\n\n\n\n\n    return WireResult::Success;\n}\nDAWN_UNUSED_FUNC(DeviceTickDeserialize);\n\n            \nstruct ExternalTextureDestroyTransfer : CmdHeader {\n    static_assert(1 <= 1,\n                  \"Record must be at most one of is_cmd, extensible, and chained.\");\n    WireCmd commandId;\n\n    ObjectId self;\n\n\n};\n\nstatic_assert(offsetof(ExternalTextureDestroyTransfer, commandSize) == 0);\nstatic_assert(offsetof(ExternalTextureDestroyTransfer, commandId) == sizeof(CmdHeader));\n\n\nDAWN_DECLARE_UNUSED size_t ExternalTextureDestroyGetExtraRequiredSize(const ExternalTextureDestroyCmd& record) {\n    DAWN_UNUSED(record);\n\n    size_t result = 0;\n\n\n\n    {\n    }\n\n    return result;\n}\n// GetExtraRequiredSize isn't used for structures that are value members of other structures\n// because we assume they cannot contain pointers themselves.\nDAWN_UNUSED_FUNC(ExternalTextureDestroyGetExtraRequiredSize);\n\nDAWN_DECLARE_UNUSED WireResult ExternalTextureDestroySerialize(\n    const ExternalTextureDestroyCmd& record,\n    ExternalTextureDestroyTransfer* transfer,\n    SerializeBuffer* buffer, const ObjectIdProvider& provider) {\n    DAWN_UNUSED(buffer);\n\n    transfer->commandId = WireCmd::ExternalTextureDestroy;\n\n    WIRE_TRY(provider.GetId(record.self, &transfer->self));\n\n\n\n\n    return WireResult::Success;\n}\nDAWN_UNUSED_FUNC(ExternalTextureDestroySerialize);\n\nDAWN_DECLARE_UNUSED WireResult ExternalTextureDestroyDeserialize(\n    ExternalTextureDestroyCmd* record,\n    const volatile ExternalTextureDestroyTransfer* transfer,\n    DeserializeBuffer* deserializeBuffer,\n    DeserializeAllocator* allocator, const ObjectIdResolver& resolver) {\n    DAWN_UNUSED(allocator);\n\n    ASSERT(transfer->commandId == WireCmd::ExternalTextureDestroy);\n\n    record->selfId = transfer->self;\n\n    WIRE_TRY(resolver.GetFromId(transfer->self, &record->self));\n\n\n\n\n\n    return WireResult::Success;\n}\nDAWN_UNUSED_FUNC(ExternalTextureDestroyDeserialize);\n\n            \nstruct ExternalTextureSetLabelTransfer : CmdHeader {\n    static_assert(1 <= 1,\n                  \"Record must be at most one of is_cmd, extensible, and chained.\");\n    WireCmd commandId;\n\n    ObjectId self;\n\n    uint64_t labelStrlen;\n\n};\n\nstatic_assert(offsetof(ExternalTextureSetLabelTransfer, commandSize) == 0);\nstatic_assert(offsetof(ExternalTextureSetLabelTransfer, commandId) == sizeof(CmdHeader));\n\n\nDAWN_DECLARE_UNUSED size_t ExternalTextureSetLabelGetExtraRequiredSize(const ExternalTextureSetLabelCmd& record) {\n    DAWN_UNUSED(record);\n\n    size_t result = 0;\n\n\n\n    {\n    result += std::strlen(record.label);\n    }\n\n    {\n    }\n\n    return result;\n}\n// GetExtraRequiredSize isn't used for structures that are value members of other structures\n// because we assume they cannot contain pointers themselves.\nDAWN_UNUSED_FUNC(ExternalTextureSetLabelGetExtraRequiredSize);\n\nDAWN_DECLARE_UNUSED WireResult ExternalTextureSetLabelSerialize(\n    const ExternalTextureSetLabelCmd& record,\n    ExternalTextureSetLabelTransfer* transfer,\n    SerializeBuffer* buffer, const ObjectIdProvider& provider) {\n    DAWN_UNUSED(buffer);\n\n    transfer->commandId = WireCmd::ExternalTextureSetLabel;\n\n    WIRE_TRY(provider.GetId(record.self, &transfer->self));\n\n\n\n\n    {\n        transfer->labelStrlen = std::strlen(record.label);\n\n        char* stringInBuffer;\n        WIRE_TRY(buffer->NextN(transfer->labelStrlen, &stringInBuffer));\n        memcpy(stringInBuffer, record.label, transfer->labelStrlen);\n    }\n\n    return WireResult::Success;\n}\nDAWN_UNUSED_FUNC(ExternalTextureSetLabelSerialize);\n\nDAWN_DECLARE_UNUSED WireResult ExternalTextureSetLabelDeserialize(\n    ExternalTextureSetLabelCmd* record,\n    const volatile ExternalTextureSetLabelTransfer* transfer,\n    DeserializeBuffer* deserializeBuffer,\n    DeserializeAllocator* allocator, const ObjectIdResolver& resolver) {\n    DAWN_UNUSED(allocator);\n\n    ASSERT(transfer->commandId == WireCmd::ExternalTextureSetLabel);\n\n    record->selfId = transfer->self;\n\n    WIRE_TRY(resolver.GetFromId(transfer->self, &record->self));\n\n\n\n\n    {\n        uint64_t stringLength64 = transfer->labelStrlen;\n        if (stringLength64 >= std::numeric_limits<size_t>::max()) {\n            return WireResult::FatalError;\n        }\n        size_t stringLength = static_cast<size_t>(stringLength64);\n\n        const volatile char* stringInBuffer;\n        WIRE_TRY(deserializeBuffer->ReadN(stringLength, &stringInBuffer));\n\n        char* copiedString;\n        WIRE_TRY(GetSpace(allocator, stringLength + 1, &copiedString));\n        memcpy(copiedString, const_cast<const char*>(stringInBuffer), stringLength);\n        copiedString[stringLength] = '\\0';\n        record->label = copiedString;\n    }\n\n\n    return WireResult::Success;\n}\nDAWN_UNUSED_FUNC(ExternalTextureSetLabelDeserialize);\n\n            \nstruct InstanceCreateSurfaceTransfer : CmdHeader {\n    static_assert(1 <= 1,\n                  \"Record must be at most one of is_cmd, extensible, and chained.\");\n    WireCmd commandId;\n\n    ObjectId self;\n    \nObjectHandle result;\n\n\n};\n\nstatic_assert(offsetof(InstanceCreateSurfaceTransfer, commandSize) == 0);\nstatic_assert(offsetof(InstanceCreateSurfaceTransfer, commandId) == sizeof(CmdHeader));\n\n\nDAWN_DECLARE_UNUSED size_t InstanceCreateSurfaceGetExtraRequiredSize(const InstanceCreateSurfaceCmd& record) {\n    DAWN_UNUSED(record);\n\n    size_t result = 0;\n\n\n\n    {\n    }\n    {\n        \n        auto memberLength = 1u;\n        result += memberLength * sizeof(WGPUSurfaceDescriptorTransfer);\n        for (decltype(memberLength) i = 0; i < memberLength; ++i) {\n            \n            result += WGPUSurfaceDescriptorGetExtraRequiredSize(record.descriptor[i]);\n        }\n    }\n    {\n    }\n\n    return result;\n}\n// GetExtraRequiredSize isn't used for structures that are value members of other structures\n// because we assume they cannot contain pointers themselves.\nDAWN_UNUSED_FUNC(InstanceCreateSurfaceGetExtraRequiredSize);\n\nDAWN_DECLARE_UNUSED WireResult InstanceCreateSurfaceSerialize(\n    const InstanceCreateSurfaceCmd& record,\n    InstanceCreateSurfaceTransfer* transfer,\n    SerializeBuffer* buffer, const ObjectIdProvider& provider) {\n    DAWN_UNUSED(buffer);\n\n    transfer->commandId = WireCmd::InstanceCreateSurface;\n\n    WIRE_TRY(provider.GetId(record.self, &transfer->self));\n    transfer->result = record.result;\n\n\n\n\n    \n\n    {\n        auto memberLength = 1u;\n\n        WGPUSurfaceDescriptorTransfer* memberBuffer;\n        WIRE_TRY(buffer->NextN(memberLength, &memberBuffer));\n\n        for (decltype(memberLength) i = 0; i < memberLength; ++i) {\n            WIRE_TRY(WGPUSurfaceDescriptorSerialize(record.descriptor[i], &memberBuffer[i], buffer, provider));\n        }\n    }\n    return WireResult::Success;\n}\nDAWN_UNUSED_FUNC(InstanceCreateSurfaceSerialize);\n\nDAWN_DECLARE_UNUSED WireResult InstanceCreateSurfaceDeserialize(\n    InstanceCreateSurfaceCmd* record,\n    const volatile InstanceCreateSurfaceTransfer* transfer,\n    DeserializeBuffer* deserializeBuffer,\n    DeserializeAllocator* allocator, const ObjectIdResolver& resolver) {\n    DAWN_UNUSED(allocator);\n\n    ASSERT(transfer->commandId == WireCmd::InstanceCreateSurface);\n\n    record->selfId = transfer->self;\n\n    WIRE_TRY(resolver.GetFromId(transfer->self, &record->self));\n    static_assert(sizeof(record->result) >= sizeof(transfer->result), \"Deserialize assignment may not narrow.\");\nrecord->result = transfer->result;\n\n\n\n\n    \n\n    {\n        auto memberLength = 1u;\n        const volatile WGPUSurfaceDescriptorTransfer* memberBuffer;\n        WIRE_TRY(deserializeBuffer->ReadN(memberLength, &memberBuffer));\n\n        WGPUSurfaceDescriptor* copiedMembers;\n        WIRE_TRY(GetSpace(allocator, memberLength, &copiedMembers));\n        record->descriptor = copiedMembers;\n\n        for (decltype(memberLength) i = 0; i < memberLength; ++i) {\n            WIRE_TRY(WGPUSurfaceDescriptorDeserialize(&copiedMembers[i], &memberBuffer[i], deserializeBuffer, allocator, resolver));\n        }\n    }\n\n    return WireResult::Success;\n}\nDAWN_UNUSED_FUNC(InstanceCreateSurfaceDeserialize);\n\n            \nstruct InstanceRequestAdapterTransfer : CmdHeader {\n    static_assert(1 <= 1,\n                  \"Record must be at most one of is_cmd, extensible, and chained.\");\n    WireCmd commandId;\n\n    \nObjectId instanceId;\n    \nuint64_t requestSerial;\n    \nObjectHandle adapterObjectHandle;\n\n\n};\n\nstatic_assert(offsetof(InstanceRequestAdapterTransfer, commandSize) == 0);\nstatic_assert(offsetof(InstanceRequestAdapterTransfer, commandId) == sizeof(CmdHeader));\n\n\nDAWN_DECLARE_UNUSED size_t InstanceRequestAdapterGetExtraRequiredSize(const InstanceRequestAdapterCmd& record) {\n    DAWN_UNUSED(record);\n\n    size_t result = 0;\n\n\n\n    {\n    }\n    {\n    }\n    {\n    }\n    {\n        \n        auto memberLength = 1u;\n        result += memberLength * sizeof(WGPURequestAdapterOptionsTransfer);\n        for (decltype(memberLength) i = 0; i < memberLength; ++i) {\n            \n            result += WGPURequestAdapterOptionsGetExtraRequiredSize(record.options[i]);\n        }\n    }\n\n    return result;\n}\n// GetExtraRequiredSize isn't used for structures that are value members of other structures\n// because we assume they cannot contain pointers themselves.\nDAWN_UNUSED_FUNC(InstanceRequestAdapterGetExtraRequiredSize);\n\nDAWN_DECLARE_UNUSED WireResult InstanceRequestAdapterSerialize(\n    const InstanceRequestAdapterCmd& record,\n    InstanceRequestAdapterTransfer* transfer,\n    SerializeBuffer* buffer, const ObjectIdProvider& provider) {\n    DAWN_UNUSED(buffer);\n\n    transfer->commandId = WireCmd::InstanceRequestAdapter;\n\n    transfer->instanceId = record.instanceId;\n    transfer->requestSerial = record.requestSerial;\n    transfer->adapterObjectHandle = record.adapterObjectHandle;\n\n\n\n\n    \n\n    {\n        auto memberLength = 1u;\n\n        WGPURequestAdapterOptionsTransfer* memberBuffer;\n        WIRE_TRY(buffer->NextN(memberLength, &memberBuffer));\n\n        for (decltype(memberLength) i = 0; i < memberLength; ++i) {\n            WIRE_TRY(WGPURequestAdapterOptionsSerialize(record.options[i], &memberBuffer[i], buffer, provider));\n        }\n    }\n    return WireResult::Success;\n}\nDAWN_UNUSED_FUNC(InstanceRequestAdapterSerialize);\n\nDAWN_DECLARE_UNUSED WireResult InstanceRequestAdapterDeserialize(\n    InstanceRequestAdapterCmd* record,\n    const volatile InstanceRequestAdapterTransfer* transfer,\n    DeserializeBuffer* deserializeBuffer,\n    DeserializeAllocator* allocator, const ObjectIdResolver& resolver) {\n    DAWN_UNUSED(allocator);\n\n    ASSERT(transfer->commandId == WireCmd::InstanceRequestAdapter);\n\n\n    static_assert(sizeof(record->instanceId) >= sizeof(transfer->instanceId), \"Deserialize assignment may not narrow.\");\nrecord->instanceId = transfer->instanceId;\n    static_assert(sizeof(record->requestSerial) >= sizeof(transfer->requestSerial), \"Deserialize assignment may not narrow.\");\nrecord->requestSerial = transfer->requestSerial;\n    static_assert(sizeof(record->adapterObjectHandle) >= sizeof(transfer->adapterObjectHandle), \"Deserialize assignment may not narrow.\");\nrecord->adapterObjectHandle = transfer->adapterObjectHandle;\n\n\n\n\n    \n\n    {\n        auto memberLength = 1u;\n        const volatile WGPURequestAdapterOptionsTransfer* memberBuffer;\n        WIRE_TRY(deserializeBuffer->ReadN(memberLength, &memberBuffer));\n\n        WGPURequestAdapterOptions* copiedMembers;\n        WIRE_TRY(GetSpace(allocator, memberLength, &copiedMembers));\n        record->options = copiedMembers;\n\n        for (decltype(memberLength) i = 0; i < memberLength; ++i) {\n            WIRE_TRY(WGPURequestAdapterOptionsDeserialize(&copiedMembers[i], &memberBuffer[i], deserializeBuffer, allocator, resolver));\n        }\n    }\n\n    return WireResult::Success;\n}\nDAWN_UNUSED_FUNC(InstanceRequestAdapterDeserialize);\n\n            \nstruct PipelineLayoutSetLabelTransfer : CmdHeader {\n    static_assert(1 <= 1,\n                  \"Record must be at most one of is_cmd, extensible, and chained.\");\n    WireCmd commandId;\n\n    ObjectId self;\n\n    uint64_t labelStrlen;\n\n};\n\nstatic_assert(offsetof(PipelineLayoutSetLabelTransfer, commandSize) == 0);\nstatic_assert(offsetof(PipelineLayoutSetLabelTransfer, commandId) == sizeof(CmdHeader));\n\n\nDAWN_DECLARE_UNUSED size_t PipelineLayoutSetLabelGetExtraRequiredSize(const PipelineLayoutSetLabelCmd& record) {\n    DAWN_UNUSED(record);\n\n    size_t result = 0;\n\n\n\n    {\n    result += std::strlen(record.label);\n    }\n\n    {\n    }\n\n    return result;\n}\n// GetExtraRequiredSize isn't used for structures that are value members of other structures\n// because we assume they cannot contain pointers themselves.\nDAWN_UNUSED_FUNC(PipelineLayoutSetLabelGetExtraRequiredSize);\n\nDAWN_DECLARE_UNUSED WireResult PipelineLayoutSetLabelSerialize(\n    const PipelineLayoutSetLabelCmd& record,\n    PipelineLayoutSetLabelTransfer* transfer,\n    SerializeBuffer* buffer, const ObjectIdProvider& provider) {\n    DAWN_UNUSED(buffer);\n\n    transfer->commandId = WireCmd::PipelineLayoutSetLabel;\n\n    WIRE_TRY(provider.GetId(record.self, &transfer->self));\n\n\n\n\n    {\n        transfer->labelStrlen = std::strlen(record.label);\n\n        char* stringInBuffer;\n        WIRE_TRY(buffer->NextN(transfer->labelStrlen, &stringInBuffer));\n        memcpy(stringInBuffer, record.label, transfer->labelStrlen);\n    }\n\n    return WireResult::Success;\n}\nDAWN_UNUSED_FUNC(PipelineLayoutSetLabelSerialize);\n\nDAWN_DECLARE_UNUSED WireResult PipelineLayoutSetLabelDeserialize(\n    PipelineLayoutSetLabelCmd* record,\n    const volatile PipelineLayoutSetLabelTransfer* transfer,\n    DeserializeBuffer* deserializeBuffer,\n    DeserializeAllocator* allocator, const ObjectIdResolver& resolver) {\n    DAWN_UNUSED(allocator);\n\n    ASSERT(transfer->commandId == WireCmd::PipelineLayoutSetLabel);\n\n    record->selfId = transfer->self;\n\n    WIRE_TRY(resolver.GetFromId(transfer->self, &record->self));\n\n\n\n\n    {\n        uint64_t stringLength64 = transfer->labelStrlen;\n        if (stringLength64 >= std::numeric_limits<size_t>::max()) {\n            return WireResult::FatalError;\n        }\n        size_t stringLength = static_cast<size_t>(stringLength64);\n\n        const volatile char* stringInBuffer;\n        WIRE_TRY(deserializeBuffer->ReadN(stringLength, &stringInBuffer));\n\n        char* copiedString;\n        WIRE_TRY(GetSpace(allocator, stringLength + 1, &copiedString));\n        memcpy(copiedString, const_cast<const char*>(stringInBuffer), stringLength);\n        copiedString[stringLength] = '\\0';\n        record->label = copiedString;\n    }\n\n\n    return WireResult::Success;\n}\nDAWN_UNUSED_FUNC(PipelineLayoutSetLabelDeserialize);\n\n            \nstruct QuerySetDestroyTransfer : CmdHeader {\n    static_assert(1 <= 1,\n                  \"Record must be at most one of is_cmd, extensible, and chained.\");\n    WireCmd commandId;\n\n    ObjectId self;\n\n\n};\n\nstatic_assert(offsetof(QuerySetDestroyTransfer, commandSize) == 0);\nstatic_assert(offsetof(QuerySetDestroyTransfer, commandId) == sizeof(CmdHeader));\n\n\nDAWN_DECLARE_UNUSED size_t QuerySetDestroyGetExtraRequiredSize(const QuerySetDestroyCmd& record) {\n    DAWN_UNUSED(record);\n\n    size_t result = 0;\n\n\n\n    {\n    }\n\n    return result;\n}\n// GetExtraRequiredSize isn't used for structures that are value members of other structures\n// because we assume they cannot contain pointers themselves.\nDAWN_UNUSED_FUNC(QuerySetDestroyGetExtraRequiredSize);\n\nDAWN_DECLARE_UNUSED WireResult QuerySetDestroySerialize(\n    const QuerySetDestroyCmd& record,\n    QuerySetDestroyTransfer* transfer,\n    SerializeBuffer* buffer, const ObjectIdProvider& provider) {\n    DAWN_UNUSED(buffer);\n\n    transfer->commandId = WireCmd::QuerySetDestroy;\n\n    WIRE_TRY(provider.GetId(record.self, &transfer->self));\n\n\n\n\n    return WireResult::Success;\n}\nDAWN_UNUSED_FUNC(QuerySetDestroySerialize);\n\nDAWN_DECLARE_UNUSED WireResult QuerySetDestroyDeserialize(\n    QuerySetDestroyCmd* record,\n    const volatile QuerySetDestroyTransfer* transfer,\n    DeserializeBuffer* deserializeBuffer,\n    DeserializeAllocator* allocator, const ObjectIdResolver& resolver) {\n    DAWN_UNUSED(allocator);\n\n    ASSERT(transfer->commandId == WireCmd::QuerySetDestroy);\n\n    record->selfId = transfer->self;\n\n    WIRE_TRY(resolver.GetFromId(transfer->self, &record->self));\n\n\n\n\n\n    return WireResult::Success;\n}\nDAWN_UNUSED_FUNC(QuerySetDestroyDeserialize);\n\n            \nstruct QuerySetSetLabelTransfer : CmdHeader {\n    static_assert(1 <= 1,\n                  \"Record must be at most one of is_cmd, extensible, and chained.\");\n    WireCmd commandId;\n\n    ObjectId self;\n\n    uint64_t labelStrlen;\n\n};\n\nstatic_assert(offsetof(QuerySetSetLabelTransfer, commandSize) == 0);\nstatic_assert(offsetof(QuerySetSetLabelTransfer, commandId) == sizeof(CmdHeader));\n\n\nDAWN_DECLARE_UNUSED size_t QuerySetSetLabelGetExtraRequiredSize(const QuerySetSetLabelCmd& record) {\n    DAWN_UNUSED(record);\n\n    size_t result = 0;\n\n\n\n    {\n    result += std::strlen(record.label);\n    }\n\n    {\n    }\n\n    return result;\n}\n// GetExtraRequiredSize isn't used for structures that are value members of other structures\n// because we assume they cannot contain pointers themselves.\nDAWN_UNUSED_FUNC(QuerySetSetLabelGetExtraRequiredSize);\n\nDAWN_DECLARE_UNUSED WireResult QuerySetSetLabelSerialize(\n    const QuerySetSetLabelCmd& record,\n    QuerySetSetLabelTransfer* transfer,\n    SerializeBuffer* buffer, const ObjectIdProvider& provider) {\n    DAWN_UNUSED(buffer);\n\n    transfer->commandId = WireCmd::QuerySetSetLabel;\n\n    WIRE_TRY(provider.GetId(record.self, &transfer->self));\n\n\n\n\n    {\n        transfer->labelStrlen = std::strlen(record.label);\n\n        char* stringInBuffer;\n        WIRE_TRY(buffer->NextN(transfer->labelStrlen, &stringInBuffer));\n        memcpy(stringInBuffer, record.label, transfer->labelStrlen);\n    }\n\n    return WireResult::Success;\n}\nDAWN_UNUSED_FUNC(QuerySetSetLabelSerialize);\n\nDAWN_DECLARE_UNUSED WireResult QuerySetSetLabelDeserialize(\n    QuerySetSetLabelCmd* record,\n    const volatile QuerySetSetLabelTransfer* transfer,\n    DeserializeBuffer* deserializeBuffer,\n    DeserializeAllocator* allocator, const ObjectIdResolver& resolver) {\n    DAWN_UNUSED(allocator);\n\n    ASSERT(transfer->commandId == WireCmd::QuerySetSetLabel);\n\n    record->selfId = transfer->self;\n\n    WIRE_TRY(resolver.GetFromId(transfer->self, &record->self));\n\n\n\n\n    {\n        uint64_t stringLength64 = transfer->labelStrlen;\n        if (stringLength64 >= std::numeric_limits<size_t>::max()) {\n            return WireResult::FatalError;\n        }\n        size_t stringLength = static_cast<size_t>(stringLength64);\n\n        const volatile char* stringInBuffer;\n        WIRE_TRY(deserializeBuffer->ReadN(stringLength, &stringInBuffer));\n\n        char* copiedString;\n        WIRE_TRY(GetSpace(allocator, stringLength + 1, &copiedString));\n        memcpy(copiedString, const_cast<const char*>(stringInBuffer), stringLength);\n        copiedString[stringLength] = '\\0';\n        record->label = copiedString;\n    }\n\n\n    return WireResult::Success;\n}\nDAWN_UNUSED_FUNC(QuerySetSetLabelDeserialize);\n\n            \nstruct QueueCopyTextureForBrowserTransfer : CmdHeader {\n    static_assert(1 <= 1,\n                  \"Record must be at most one of is_cmd, extensible, and chained.\");\n    WireCmd commandId;\n\n    ObjectId self;\n\n\n};\n\nstatic_assert(offsetof(QueueCopyTextureForBrowserTransfer, commandSize) == 0);\nstatic_assert(offsetof(QueueCopyTextureForBrowserTransfer, commandId) == sizeof(CmdHeader));\n\n\nDAWN_DECLARE_UNUSED size_t QueueCopyTextureForBrowserGetExtraRequiredSize(const QueueCopyTextureForBrowserCmd& record) {\n    DAWN_UNUSED(record);\n\n    size_t result = 0;\n\n\n\n    {\n    }\n    {\n        \n        auto memberLength = 1u;\n        result += memberLength * sizeof(WGPUImageCopyTextureTransfer);\n        for (decltype(memberLength) i = 0; i < memberLength; ++i) {\n            \n            result += WGPUImageCopyTextureGetExtraRequiredSize(record.source[i]);\n        }\n    }\n    {\n        \n        auto memberLength = 1u;\n        result += memberLength * sizeof(WGPUImageCopyTextureTransfer);\n        for (decltype(memberLength) i = 0; i < memberLength; ++i) {\n            \n            result += WGPUImageCopyTextureGetExtraRequiredSize(record.destination[i]);\n        }\n    }\n    {\n        \n        auto memberLength = 1u;\n        result += memberLength * sizeof(WGPUExtent3DTransfer);\n        for (decltype(memberLength) i = 0; i < memberLength; ++i) {\n            \n            result += WGPUExtent3DGetExtraRequiredSize(record.copySize[i]);\n        }\n    }\n    {\n        \n        auto memberLength = 1u;\n        result += memberLength * sizeof(WGPUCopyTextureForBrowserOptionsTransfer);\n        for (decltype(memberLength) i = 0; i < memberLength; ++i) {\n            \n            result += WGPUCopyTextureForBrowserOptionsGetExtraRequiredSize(record.options[i]);\n        }\n    }\n\n    return result;\n}\n// GetExtraRequiredSize isn't used for structures that are value members of other structures\n// because we assume they cannot contain pointers themselves.\nDAWN_UNUSED_FUNC(QueueCopyTextureForBrowserGetExtraRequiredSize);\n\nDAWN_DECLARE_UNUSED WireResult QueueCopyTextureForBrowserSerialize(\n    const QueueCopyTextureForBrowserCmd& record,\n    QueueCopyTextureForBrowserTransfer* transfer,\n    SerializeBuffer* buffer, const ObjectIdProvider& provider) {\n    DAWN_UNUSED(buffer);\n\n    transfer->commandId = WireCmd::QueueCopyTextureForBrowser;\n\n    WIRE_TRY(provider.GetId(record.self, &transfer->self));\n\n\n\n\n    \n\n    {\n        auto memberLength = 1u;\n\n        WGPUImageCopyTextureTransfer* memberBuffer;\n        WIRE_TRY(buffer->NextN(memberLength, &memberBuffer));\n\n        for (decltype(memberLength) i = 0; i < memberLength; ++i) {\n            WIRE_TRY(WGPUImageCopyTextureSerialize(record.source[i], &memberBuffer[i], buffer, provider));\n        }\n    }\n    \n\n    {\n        auto memberLength = 1u;\n\n        WGPUImageCopyTextureTransfer* memberBuffer;\n        WIRE_TRY(buffer->NextN(memberLength, &memberBuffer));\n\n        for (decltype(memberLength) i = 0; i < memberLength; ++i) {\n            WIRE_TRY(WGPUImageCopyTextureSerialize(record.destination[i], &memberBuffer[i], buffer, provider));\n        }\n    }\n    \n\n    {\n        auto memberLength = 1u;\n\n        WGPUExtent3DTransfer* memberBuffer;\n        WIRE_TRY(buffer->NextN(memberLength, &memberBuffer));\n\n        memcpy(\n            memberBuffer, record.copySize,\n            sizeof(WGPUExtent3DTransfer) * memberLength);\n    }\n    \n\n    {\n        auto memberLength = 1u;\n\n        WGPUCopyTextureForBrowserOptionsTransfer* memberBuffer;\n        WIRE_TRY(buffer->NextN(memberLength, &memberBuffer));\n\n        for (decltype(memberLength) i = 0; i < memberLength; ++i) {\n            WIRE_TRY(WGPUCopyTextureForBrowserOptionsSerialize(record.options[i], &memberBuffer[i], buffer, provider));\n        }\n    }\n    return WireResult::Success;\n}\nDAWN_UNUSED_FUNC(QueueCopyTextureForBrowserSerialize);\n\nDAWN_DECLARE_UNUSED WireResult QueueCopyTextureForBrowserDeserialize(\n    QueueCopyTextureForBrowserCmd* record,\n    const volatile QueueCopyTextureForBrowserTransfer* transfer,\n    DeserializeBuffer* deserializeBuffer,\n    DeserializeAllocator* allocator, const ObjectIdResolver& resolver) {\n    DAWN_UNUSED(allocator);\n\n    ASSERT(transfer->commandId == WireCmd::QueueCopyTextureForBrowser);\n\n    record->selfId = transfer->self;\n\n    WIRE_TRY(resolver.GetFromId(transfer->self, &record->self));\n\n\n\n\n    \n\n    {\n        auto memberLength = 1u;\n        const volatile WGPUImageCopyTextureTransfer* memberBuffer;\n        WIRE_TRY(deserializeBuffer->ReadN(memberLength, &memberBuffer));\n\n        WGPUImageCopyTexture* copiedMembers;\n        WIRE_TRY(GetSpace(allocator, memberLength, &copiedMembers));\n        record->source = copiedMembers;\n\n        for (decltype(memberLength) i = 0; i < memberLength; ++i) {\n            WIRE_TRY(WGPUImageCopyTextureDeserialize(&copiedMembers[i], &memberBuffer[i], deserializeBuffer, allocator, resolver));\n        }\n    }\n    \n\n    {\n        auto memberLength = 1u;\n        const volatile WGPUImageCopyTextureTransfer* memberBuffer;\n        WIRE_TRY(deserializeBuffer->ReadN(memberLength, &memberBuffer));\n\n        WGPUImageCopyTexture* copiedMembers;\n        WIRE_TRY(GetSpace(allocator, memberLength, &copiedMembers));\n        record->destination = copiedMembers;\n\n        for (decltype(memberLength) i = 0; i < memberLength; ++i) {\n            WIRE_TRY(WGPUImageCopyTextureDeserialize(&copiedMembers[i], &memberBuffer[i], deserializeBuffer, allocator, resolver));\n        }\n    }\n    \n\n    {\n        auto memberLength = 1u;\n        const volatile WGPUExtent3DTransfer* memberBuffer;\n        WIRE_TRY(deserializeBuffer->ReadN(memberLength, &memberBuffer));\n\n        WGPUExtent3D* copiedMembers;\n        WIRE_TRY(GetSpace(allocator, memberLength, &copiedMembers));\n        record->copySize = copiedMembers;\n\n        memcpy(\n            copiedMembers,\n            const_cast<const WGPUExtent3DTransfer*>(memberBuffer),\n           sizeof(WGPUExtent3DTransfer) * memberLength);\n    }\n    \n\n    {\n        auto memberLength = 1u;\n        const volatile WGPUCopyTextureForBrowserOptionsTransfer* memberBuffer;\n        WIRE_TRY(deserializeBuffer->ReadN(memberLength, &memberBuffer));\n\n        WGPUCopyTextureForBrowserOptions* copiedMembers;\n        WIRE_TRY(GetSpace(allocator, memberLength, &copiedMembers));\n        record->options = copiedMembers;\n\n        for (decltype(memberLength) i = 0; i < memberLength; ++i) {\n            WIRE_TRY(WGPUCopyTextureForBrowserOptionsDeserialize(&copiedMembers[i], &memberBuffer[i], deserializeBuffer, allocator, resolver));\n        }\n    }\n\n    return WireResult::Success;\n}\nDAWN_UNUSED_FUNC(QueueCopyTextureForBrowserDeserialize);\n\n            \nstruct QueueOnSubmittedWorkDoneTransfer : CmdHeader {\n    static_assert(1 <= 1,\n                  \"Record must be at most one of is_cmd, extensible, and chained.\");\n    WireCmd commandId;\n\n    \nObjectId queueId;\n    \nuint64_t signalValue;\n    \nuint64_t requestSerial;\n\n\n};\n\nstatic_assert(offsetof(QueueOnSubmittedWorkDoneTransfer, commandSize) == 0);\nstatic_assert(offsetof(QueueOnSubmittedWorkDoneTransfer, commandId) == sizeof(CmdHeader));\n\n\nDAWN_DECLARE_UNUSED size_t QueueOnSubmittedWorkDoneGetExtraRequiredSize(const QueueOnSubmittedWorkDoneCmd& record) {\n    DAWN_UNUSED(record);\n\n    size_t result = 0;\n\n\n\n    {\n    }\n    {\n    }\n    {\n    }\n\n    return result;\n}\n// GetExtraRequiredSize isn't used for structures that are value members of other structures\n// because we assume they cannot contain pointers themselves.\nDAWN_UNUSED_FUNC(QueueOnSubmittedWorkDoneGetExtraRequiredSize);\n\nDAWN_DECLARE_UNUSED WireResult QueueOnSubmittedWorkDoneSerialize(\n    const QueueOnSubmittedWorkDoneCmd& record,\n    QueueOnSubmittedWorkDoneTransfer* transfer,\n    SerializeBuffer* buffer) {\n    DAWN_UNUSED(buffer);\n\n    transfer->commandId = WireCmd::QueueOnSubmittedWorkDone;\n\n    transfer->queueId = record.queueId;\n    transfer->signalValue = record.signalValue;\n    transfer->requestSerial = record.requestSerial;\n\n\n\n\n    return WireResult::Success;\n}\nDAWN_UNUSED_FUNC(QueueOnSubmittedWorkDoneSerialize);\n\nDAWN_DECLARE_UNUSED WireResult QueueOnSubmittedWorkDoneDeserialize(\n    QueueOnSubmittedWorkDoneCmd* record,\n    const volatile QueueOnSubmittedWorkDoneTransfer* transfer,\n    DeserializeBuffer* deserializeBuffer,\n    DeserializeAllocator* allocator) {\n    DAWN_UNUSED(allocator);\n\n    ASSERT(transfer->commandId == WireCmd::QueueOnSubmittedWorkDone);\n\n\n    static_assert(sizeof(record->queueId) >= sizeof(transfer->queueId), \"Deserialize assignment may not narrow.\");\nrecord->queueId = transfer->queueId;\n    static_assert(sizeof(record->signalValue) >= sizeof(transfer->signalValue), \"Deserialize assignment may not narrow.\");\nrecord->signalValue = transfer->signalValue;\n    static_assert(sizeof(record->requestSerial) >= sizeof(transfer->requestSerial), \"Deserialize assignment may not narrow.\");\nrecord->requestSerial = transfer->requestSerial;\n\n\n\n\n\n    return WireResult::Success;\n}\nDAWN_UNUSED_FUNC(QueueOnSubmittedWorkDoneDeserialize);\n\n            \nstruct QueueSetLabelTransfer : CmdHeader {\n    static_assert(1 <= 1,\n                  \"Record must be at most one of is_cmd, extensible, and chained.\");\n    WireCmd commandId;\n\n    ObjectId self;\n\n    uint64_t labelStrlen;\n\n};\n\nstatic_assert(offsetof(QueueSetLabelTransfer, commandSize) == 0);\nstatic_assert(offsetof(QueueSetLabelTransfer, commandId) == sizeof(CmdHeader));\n\n\nDAWN_DECLARE_UNUSED size_t QueueSetLabelGetExtraRequiredSize(const QueueSetLabelCmd& record) {\n    DAWN_UNUSED(record);\n\n    size_t result = 0;\n\n\n\n    {\n    result += std::strlen(record.label);\n    }\n\n    {\n    }\n\n    return result;\n}\n// GetExtraRequiredSize isn't used for structures that are value members of other structures\n// because we assume they cannot contain pointers themselves.\nDAWN_UNUSED_FUNC(QueueSetLabelGetExtraRequiredSize);\n\nDAWN_DECLARE_UNUSED WireResult QueueSetLabelSerialize(\n    const QueueSetLabelCmd& record,\n    QueueSetLabelTransfer* transfer,\n    SerializeBuffer* buffer, const ObjectIdProvider& provider) {\n    DAWN_UNUSED(buffer);\n\n    transfer->commandId = WireCmd::QueueSetLabel;\n\n    WIRE_TRY(provider.GetId(record.self, &transfer->self));\n\n\n\n\n    {\n        transfer->labelStrlen = std::strlen(record.label);\n\n        char* stringInBuffer;\n        WIRE_TRY(buffer->NextN(transfer->labelStrlen, &stringInBuffer));\n        memcpy(stringInBuffer, record.label, transfer->labelStrlen);\n    }\n\n    return WireResult::Success;\n}\nDAWN_UNUSED_FUNC(QueueSetLabelSerialize);\n\nDAWN_DECLARE_UNUSED WireResult QueueSetLabelDeserialize(\n    QueueSetLabelCmd* record,\n    const volatile QueueSetLabelTransfer* transfer,\n    DeserializeBuffer* deserializeBuffer,\n    DeserializeAllocator* allocator, const ObjectIdResolver& resolver) {\n    DAWN_UNUSED(allocator);\n\n    ASSERT(transfer->commandId == WireCmd::QueueSetLabel);\n\n    record->selfId = transfer->self;\n\n    WIRE_TRY(resolver.GetFromId(transfer->self, &record->self));\n\n\n\n\n    {\n        uint64_t stringLength64 = transfer->labelStrlen;\n        if (stringLength64 >= std::numeric_limits<size_t>::max()) {\n            return WireResult::FatalError;\n        }\n        size_t stringLength = static_cast<size_t>(stringLength64);\n\n        const volatile char* stringInBuffer;\n        WIRE_TRY(deserializeBuffer->ReadN(stringLength, &stringInBuffer));\n\n        char* copiedString;\n        WIRE_TRY(GetSpace(allocator, stringLength + 1, &copiedString));\n        memcpy(copiedString, const_cast<const char*>(stringInBuffer), stringLength);\n        copiedString[stringLength] = '\\0';\n        record->label = copiedString;\n    }\n\n\n    return WireResult::Success;\n}\nDAWN_UNUSED_FUNC(QueueSetLabelDeserialize);\n\n            \nstruct QueueSubmitTransfer : CmdHeader {\n    static_assert(1 <= 1,\n                  \"Record must be at most one of is_cmd, extensible, and chained.\");\n    WireCmd commandId;\n\n    ObjectId self;\n    \nuint32_t commandCount;\n\n\n};\n\nstatic_assert(offsetof(QueueSubmitTransfer, commandSize) == 0);\nstatic_assert(offsetof(QueueSubmitTransfer, commandId) == sizeof(CmdHeader));\n\n\nDAWN_DECLARE_UNUSED size_t QueueSubmitGetExtraRequiredSize(const QueueSubmitCmd& record) {\n    DAWN_UNUSED(record);\n\n    size_t result = 0;\n\n\n\n    {\n    }\n    {\n    }\n    {\n        \n        auto memberLength = record.commandCount;\n        result += memberLength * sizeof(ObjectId);\n    }\n\n    return result;\n}\n// GetExtraRequiredSize isn't used for structures that are value members of other structures\n// because we assume they cannot contain pointers themselves.\nDAWN_UNUSED_FUNC(QueueSubmitGetExtraRequiredSize);\n\nDAWN_DECLARE_UNUSED WireResult QueueSubmitSerialize(\n    const QueueSubmitCmd& record,\n    QueueSubmitTransfer* transfer,\n    SerializeBuffer* buffer, const ObjectIdProvider& provider) {\n    DAWN_UNUSED(buffer);\n\n    transfer->commandId = WireCmd::QueueSubmit;\n\n    WIRE_TRY(provider.GetId(record.self, &transfer->self));\n    transfer->commandCount = record.commandCount;\n\n\n\n\n    \n\n    {\n        auto memberLength = record.commandCount;\n\n        ObjectId* memberBuffer;\n        WIRE_TRY(buffer->NextN(memberLength, &memberBuffer));\n\n        for (decltype(memberLength) i = 0; i < memberLength; ++i) {\n            WIRE_TRY(provider.GetId(record.commands[i], &memberBuffer[i]));\n        }\n    }\n    return WireResult::Success;\n}\nDAWN_UNUSED_FUNC(QueueSubmitSerialize);\n\nDAWN_DECLARE_UNUSED WireResult QueueSubmitDeserialize(\n    QueueSubmitCmd* record,\n    const volatile QueueSubmitTransfer* transfer,\n    DeserializeBuffer* deserializeBuffer,\n    DeserializeAllocator* allocator, const ObjectIdResolver& resolver) {\n    DAWN_UNUSED(allocator);\n\n    ASSERT(transfer->commandId == WireCmd::QueueSubmit);\n\n    record->selfId = transfer->self;\n\n    WIRE_TRY(resolver.GetFromId(transfer->self, &record->self));\n    static_assert(sizeof(record->commandCount) >= sizeof(transfer->commandCount), \"Deserialize assignment may not narrow.\");\nrecord->commandCount = transfer->commandCount;\n\n\n\n\n    \n\n    {\n        auto memberLength = record->commandCount;\n        const volatile ObjectId* memberBuffer;\n        WIRE_TRY(deserializeBuffer->ReadN(memberLength, &memberBuffer));\n\n        WGPUCommandBuffer* copiedMembers;\n        WIRE_TRY(GetSpace(allocator, memberLength, &copiedMembers));\n        record->commands = copiedMembers;\n\n        for (decltype(memberLength) i = 0; i < memberLength; ++i) {\n            WIRE_TRY(resolver.GetFromId(memberBuffer[i], &copiedMembers[i]));\n        }\n    }\n\n    return WireResult::Success;\n}\nDAWN_UNUSED_FUNC(QueueSubmitDeserialize);\n\n            \nstruct QueueWriteBufferTransfer : CmdHeader {\n    static_assert(1 <= 1,\n                  \"Record must be at most one of is_cmd, extensible, and chained.\");\n    WireCmd commandId;\n\n    \nObjectId queueId;\n    \nObjectId bufferId;\n    \nuint64_t bufferOffset;\n    \nuint64_t size;\n\n\n};\n\nstatic_assert(offsetof(QueueWriteBufferTransfer, commandSize) == 0);\nstatic_assert(offsetof(QueueWriteBufferTransfer, commandId) == sizeof(CmdHeader));\n\n\nDAWN_DECLARE_UNUSED size_t QueueWriteBufferGetExtraRequiredSize(const QueueWriteBufferCmd& record) {\n    DAWN_UNUSED(record);\n\n    size_t result = 0;\n\n\n\n    {\n    }\n    {\n    }\n    {\n    }\n    {\n        \n        auto memberLength = record.size;\n        result += memberLength * sizeof(\nuint8_t);\n    }\n    {\n    }\n\n    return result;\n}\n// GetExtraRequiredSize isn't used for structures that are value members of other structures\n// because we assume they cannot contain pointers themselves.\nDAWN_UNUSED_FUNC(QueueWriteBufferGetExtraRequiredSize);\n\nDAWN_DECLARE_UNUSED WireResult QueueWriteBufferSerialize(\n    const QueueWriteBufferCmd& record,\n    QueueWriteBufferTransfer* transfer,\n    SerializeBuffer* buffer) {\n    DAWN_UNUSED(buffer);\n\n    transfer->commandId = WireCmd::QueueWriteBuffer;\n\n    transfer->queueId = record.queueId;\n    transfer->bufferId = record.bufferId;\n    transfer->bufferOffset = record.bufferOffset;\n    transfer->size = record.size;\n\n\n\n\n    \n\n    {\n        auto memberLength = record.size;\n\n        \nuint8_t* memberBuffer;\n        WIRE_TRY(buffer->NextN(memberLength, &memberBuffer));\n\n        memcpy(\n            memberBuffer, record.data,\n            sizeof(\nuint8_t) * memberLength);\n    }\n    return WireResult::Success;\n}\nDAWN_UNUSED_FUNC(QueueWriteBufferSerialize);\n\nDAWN_DECLARE_UNUSED WireResult QueueWriteBufferDeserialize(\n    QueueWriteBufferCmd* record,\n    const volatile QueueWriteBufferTransfer* transfer,\n    DeserializeBuffer* deserializeBuffer,\n    DeserializeAllocator* allocator) {\n    DAWN_UNUSED(allocator);\n\n    ASSERT(transfer->commandId == WireCmd::QueueWriteBuffer);\n\n\n    static_assert(sizeof(record->queueId) >= sizeof(transfer->queueId), \"Deserialize assignment may not narrow.\");\nrecord->queueId = transfer->queueId;\n    static_assert(sizeof(record->bufferId) >= sizeof(transfer->bufferId), \"Deserialize assignment may not narrow.\");\nrecord->bufferId = transfer->bufferId;\n    static_assert(sizeof(record->bufferOffset) >= sizeof(transfer->bufferOffset), \"Deserialize assignment may not narrow.\");\nrecord->bufferOffset = transfer->bufferOffset;\n    static_assert(sizeof(record->size) >= sizeof(transfer->size), \"Deserialize assignment may not narrow.\");\nrecord->size = transfer->size;\n\n\n\n\n    \n\n    {\n        auto memberLength = record->size;\n        const volatile \nuint8_t* memberBuffer;\n        WIRE_TRY(deserializeBuffer->ReadN(memberLength, &memberBuffer));\n\n        record->data =\n            const_cast<const \nuint8_t*>(memberBuffer);\n\n    }\n\n    return WireResult::Success;\n}\nDAWN_UNUSED_FUNC(QueueWriteBufferDeserialize);\n\n            \nstruct QueueWriteTextureTransfer : CmdHeader {\n    static_assert(1 <= 1,\n                  \"Record must be at most one of is_cmd, extensible, and chained.\");\n    WireCmd commandId;\n\n    \nObjectId queueId;\n    \nuint64_t dataSize;\n\n\n};\n\nstatic_assert(offsetof(QueueWriteTextureTransfer, commandSize) == 0);\nstatic_assert(offsetof(QueueWriteTextureTransfer, commandId) == sizeof(CmdHeader));\n\n\nDAWN_DECLARE_UNUSED size_t QueueWriteTextureGetExtraRequiredSize(const QueueWriteTextureCmd& record) {\n    DAWN_UNUSED(record);\n\n    size_t result = 0;\n\n\n\n    {\n    }\n    {\n        \n        auto memberLength = 1u;\n        result += memberLength * sizeof(WGPUImageCopyTextureTransfer);\n        for (decltype(memberLength) i = 0; i < memberLength; ++i) {\n            \n            result += WGPUImageCopyTextureGetExtraRequiredSize(record.destination[i]);\n        }\n    }\n    {\n        \n        auto memberLength = record.dataSize;\n        result += memberLength * sizeof(\nuint8_t);\n    }\n    {\n    }\n    {\n        \n        auto memberLength = 1u;\n        result += memberLength * sizeof(WGPUTextureDataLayoutTransfer);\n        for (decltype(memberLength) i = 0; i < memberLength; ++i) {\n            \n            result += WGPUTextureDataLayoutGetExtraRequiredSize(record.dataLayout[i]);\n        }\n    }\n    {\n        \n        auto memberLength = 1u;\n        result += memberLength * sizeof(WGPUExtent3DTransfer);\n        for (decltype(memberLength) i = 0; i < memberLength; ++i) {\n            \n            result += WGPUExtent3DGetExtraRequiredSize(record.writeSize[i]);\n        }\n    }\n\n    return result;\n}\n// GetExtraRequiredSize isn't used for structures that are value members of other structures\n// because we assume they cannot contain pointers themselves.\nDAWN_UNUSED_FUNC(QueueWriteTextureGetExtraRequiredSize);\n\nDAWN_DECLARE_UNUSED WireResult QueueWriteTextureSerialize(\n    const QueueWriteTextureCmd& record,\n    QueueWriteTextureTransfer* transfer,\n    SerializeBuffer* buffer, const ObjectIdProvider& provider) {\n    DAWN_UNUSED(buffer);\n\n    transfer->commandId = WireCmd::QueueWriteTexture;\n\n    transfer->queueId = record.queueId;\n    transfer->dataSize = record.dataSize;\n\n\n\n\n    \n\n    {\n        auto memberLength = 1u;\n\n        WGPUImageCopyTextureTransfer* memberBuffer;\n        WIRE_TRY(buffer->NextN(memberLength, &memberBuffer));\n\n        for (decltype(memberLength) i = 0; i < memberLength; ++i) {\n            WIRE_TRY(WGPUImageCopyTextureSerialize(record.destination[i], &memberBuffer[i], buffer, provider));\n        }\n    }\n    \n\n    {\n        auto memberLength = record.dataSize;\n\n        \nuint8_t* memberBuffer;\n        WIRE_TRY(buffer->NextN(memberLength, &memberBuffer));\n\n        memcpy(\n            memberBuffer, record.data,\n            sizeof(\nuint8_t) * memberLength);\n    }\n    \n\n    {\n        auto memberLength = 1u;\n\n        WGPUTextureDataLayoutTransfer* memberBuffer;\n        WIRE_TRY(buffer->NextN(memberLength, &memberBuffer));\n\n        for (decltype(memberLength) i = 0; i < memberLength; ++i) {\n            WIRE_TRY(WGPUTextureDataLayoutSerialize(record.dataLayout[i], &memberBuffer[i], buffer, provider));\n        }\n    }\n    \n\n    {\n        auto memberLength = 1u;\n\n        WGPUExtent3DTransfer* memberBuffer;\n        WIRE_TRY(buffer->NextN(memberLength, &memberBuffer));\n\n        memcpy(\n            memberBuffer, record.writeSize,\n            sizeof(WGPUExtent3DTransfer) * memberLength);\n    }\n    return WireResult::Success;\n}\nDAWN_UNUSED_FUNC(QueueWriteTextureSerialize);\n\nDAWN_DECLARE_UNUSED WireResult QueueWriteTextureDeserialize(\n    QueueWriteTextureCmd* record,\n    const volatile QueueWriteTextureTransfer* transfer,\n    DeserializeBuffer* deserializeBuffer,\n    DeserializeAllocator* allocator, const ObjectIdResolver& resolver) {\n    DAWN_UNUSED(allocator);\n\n    ASSERT(transfer->commandId == WireCmd::QueueWriteTexture);\n\n\n    static_assert(sizeof(record->queueId) >= sizeof(transfer->queueId), \"Deserialize assignment may not narrow.\");\nrecord->queueId = transfer->queueId;\n    static_assert(sizeof(record->dataSize) >= sizeof(transfer->dataSize), \"Deserialize assignment may not narrow.\");\nrecord->dataSize = transfer->dataSize;\n\n\n\n\n    \n\n    {\n        auto memberLength = 1u;\n        const volatile WGPUImageCopyTextureTransfer* memberBuffer;\n        WIRE_TRY(deserializeBuffer->ReadN(memberLength, &memberBuffer));\n\n        WGPUImageCopyTexture* copiedMembers;\n        WIRE_TRY(GetSpace(allocator, memberLength, &copiedMembers));\n        record->destination = copiedMembers;\n\n        for (decltype(memberLength) i = 0; i < memberLength; ++i) {\n            WIRE_TRY(WGPUImageCopyTextureDeserialize(&copiedMembers[i], &memberBuffer[i], deserializeBuffer, allocator, resolver));\n        }\n    }\n    \n\n    {\n        auto memberLength = record->dataSize;\n        const volatile \nuint8_t* memberBuffer;\n        WIRE_TRY(deserializeBuffer->ReadN(memberLength, &memberBuffer));\n\n        record->data =\n            const_cast<const \nuint8_t*>(memberBuffer);\n\n    }\n    \n\n    {\n        auto memberLength = 1u;\n        const volatile WGPUTextureDataLayoutTransfer* memberBuffer;\n        WIRE_TRY(deserializeBuffer->ReadN(memberLength, &memberBuffer));\n\n        WGPUTextureDataLayout* copiedMembers;\n        WIRE_TRY(GetSpace(allocator, memberLength, &copiedMembers));\n        record->dataLayout = copiedMembers;\n\n        for (decltype(memberLength) i = 0; i < memberLength; ++i) {\n            WIRE_TRY(WGPUTextureDataLayoutDeserialize(&copiedMembers[i], &memberBuffer[i], deserializeBuffer, allocator, resolver));\n        }\n    }\n    \n\n    {\n        auto memberLength = 1u;\n        const volatile WGPUExtent3DTransfer* memberBuffer;\n        WIRE_TRY(deserializeBuffer->ReadN(memberLength, &memberBuffer));\n\n        WGPUExtent3D* copiedMembers;\n        WIRE_TRY(GetSpace(allocator, memberLength, &copiedMembers));\n        record->writeSize = copiedMembers;\n\n        memcpy(\n            copiedMembers,\n            const_cast<const WGPUExtent3DTransfer*>(memberBuffer),\n           sizeof(WGPUExtent3DTransfer) * memberLength);\n    }\n\n    return WireResult::Success;\n}\nDAWN_UNUSED_FUNC(QueueWriteTextureDeserialize);\n\n            \nstruct RenderBundleEncoderDrawTransfer : CmdHeader {\n    static_assert(1 <= 1,\n                  \"Record must be at most one of is_cmd, extensible, and chained.\");\n    WireCmd commandId;\n\n    ObjectId self;\n    \nuint32_t vertexCount;\n    \nuint32_t instanceCount;\n    \nuint32_t firstVertex;\n    \nuint32_t firstInstance;\n\n\n};\n\nstatic_assert(offsetof(RenderBundleEncoderDrawTransfer, commandSize) == 0);\nstatic_assert(offsetof(RenderBundleEncoderDrawTransfer, commandId) == sizeof(CmdHeader));\n\n\nDAWN_DECLARE_UNUSED size_t RenderBundleEncoderDrawGetExtraRequiredSize(const RenderBundleEncoderDrawCmd& record) {\n    DAWN_UNUSED(record);\n\n    size_t result = 0;\n\n\n\n    {\n    }\n    {\n    }\n    {\n    }\n    {\n    }\n    {\n    }\n\n    return result;\n}\n// GetExtraRequiredSize isn't used for structures that are value members of other structures\n// because we assume they cannot contain pointers themselves.\nDAWN_UNUSED_FUNC(RenderBundleEncoderDrawGetExtraRequiredSize);\n\nDAWN_DECLARE_UNUSED WireResult RenderBundleEncoderDrawSerialize(\n    const RenderBundleEncoderDrawCmd& record,\n    RenderBundleEncoderDrawTransfer* transfer,\n    SerializeBuffer* buffer, const ObjectIdProvider& provider) {\n    DAWN_UNUSED(buffer);\n\n    transfer->commandId = WireCmd::RenderBundleEncoderDraw;\n\n    WIRE_TRY(provider.GetId(record.self, &transfer->self));\n    transfer->vertexCount = record.vertexCount;\n    transfer->instanceCount = record.instanceCount;\n    transfer->firstVertex = record.firstVertex;\n    transfer->firstInstance = record.firstInstance;\n\n\n\n\n    return WireResult::Success;\n}\nDAWN_UNUSED_FUNC(RenderBundleEncoderDrawSerialize);\n\nDAWN_DECLARE_UNUSED WireResult RenderBundleEncoderDrawDeserialize(\n    RenderBundleEncoderDrawCmd* record,\n    const volatile RenderBundleEncoderDrawTransfer* transfer,\n    DeserializeBuffer* deserializeBuffer,\n    DeserializeAllocator* allocator, const ObjectIdResolver& resolver) {\n    DAWN_UNUSED(allocator);\n\n    ASSERT(transfer->commandId == WireCmd::RenderBundleEncoderDraw);\n\n    record->selfId = transfer->self;\n\n    WIRE_TRY(resolver.GetFromId(transfer->self, &record->self));\n    static_assert(sizeof(record->vertexCount) >= sizeof(transfer->vertexCount), \"Deserialize assignment may not narrow.\");\nrecord->vertexCount = transfer->vertexCount;\n    static_assert(sizeof(record->instanceCount) >= sizeof(transfer->instanceCount), \"Deserialize assignment may not narrow.\");\nrecord->instanceCount = transfer->instanceCount;\n    static_assert(sizeof(record->firstVertex) >= sizeof(transfer->firstVertex), \"Deserialize assignment may not narrow.\");\nrecord->firstVertex = transfer->firstVertex;\n    static_assert(sizeof(record->firstInstance) >= sizeof(transfer->firstInstance), \"Deserialize assignment may not narrow.\");\nrecord->firstInstance = transfer->firstInstance;\n\n\n\n\n\n    return WireResult::Success;\n}\nDAWN_UNUSED_FUNC(RenderBundleEncoderDrawDeserialize);\n\n            \nstruct RenderBundleEncoderDrawIndexedTransfer : CmdHeader {\n    static_assert(1 <= 1,\n                  \"Record must be at most one of is_cmd, extensible, and chained.\");\n    WireCmd commandId;\n\n    ObjectId self;\n    \nuint32_t indexCount;\n    \nuint32_t instanceCount;\n    \nuint32_t firstIndex;\n    \nint32_t baseVertex;\n    \nuint32_t firstInstance;\n\n\n};\n\nstatic_assert(offsetof(RenderBundleEncoderDrawIndexedTransfer, commandSize) == 0);\nstatic_assert(offsetof(RenderBundleEncoderDrawIndexedTransfer, commandId) == sizeof(CmdHeader));\n\n\nDAWN_DECLARE_UNUSED size_t RenderBundleEncoderDrawIndexedGetExtraRequiredSize(const RenderBundleEncoderDrawIndexedCmd& record) {\n    DAWN_UNUSED(record);\n\n    size_t result = 0;\n\n\n\n    {\n    }\n    {\n    }\n    {\n    }\n    {\n    }\n    {\n    }\n    {\n    }\n\n    return result;\n}\n// GetExtraRequiredSize isn't used for structures that are value members of other structures\n// because we assume they cannot contain pointers themselves.\nDAWN_UNUSED_FUNC(RenderBundleEncoderDrawIndexedGetExtraRequiredSize);\n\nDAWN_DECLARE_UNUSED WireResult RenderBundleEncoderDrawIndexedSerialize(\n    const RenderBundleEncoderDrawIndexedCmd& record,\n    RenderBundleEncoderDrawIndexedTransfer* transfer,\n    SerializeBuffer* buffer, const ObjectIdProvider& provider) {\n    DAWN_UNUSED(buffer);\n\n    transfer->commandId = WireCmd::RenderBundleEncoderDrawIndexed;\n\n    WIRE_TRY(provider.GetId(record.self, &transfer->self));\n    transfer->indexCount = record.indexCount;\n    transfer->instanceCount = record.instanceCount;\n    transfer->firstIndex = record.firstIndex;\n    transfer->baseVertex = record.baseVertex;\n    transfer->firstInstance = record.firstInstance;\n\n\n\n\n    return WireResult::Success;\n}\nDAWN_UNUSED_FUNC(RenderBundleEncoderDrawIndexedSerialize);\n\nDAWN_DECLARE_UNUSED WireResult RenderBundleEncoderDrawIndexedDeserialize(\n    RenderBundleEncoderDrawIndexedCmd* record,\n    const volatile RenderBundleEncoderDrawIndexedTransfer* transfer,\n    DeserializeBuffer* deserializeBuffer,\n    DeserializeAllocator* allocator, const ObjectIdResolver& resolver) {\n    DAWN_UNUSED(allocator);\n\n    ASSERT(transfer->commandId == WireCmd::RenderBundleEncoderDrawIndexed);\n\n    record->selfId = transfer->self;\n\n    WIRE_TRY(resolver.GetFromId(transfer->self, &record->self));\n    static_assert(sizeof(record->indexCount) >= sizeof(transfer->indexCount), \"Deserialize assignment may not narrow.\");\nrecord->indexCount = transfer->indexCount;\n    static_assert(sizeof(record->instanceCount) >= sizeof(transfer->instanceCount), \"Deserialize assignment may not narrow.\");\nrecord->instanceCount = transfer->instanceCount;\n    static_assert(sizeof(record->firstIndex) >= sizeof(transfer->firstIndex), \"Deserialize assignment may not narrow.\");\nrecord->firstIndex = transfer->firstIndex;\n    static_assert(sizeof(record->baseVertex) >= sizeof(transfer->baseVertex), \"Deserialize assignment may not narrow.\");\nrecord->baseVertex = transfer->baseVertex;\n    static_assert(sizeof(record->firstInstance) >= sizeof(transfer->firstInstance), \"Deserialize assignment may not narrow.\");\nrecord->firstInstance = transfer->firstInstance;\n\n\n\n\n\n    return WireResult::Success;\n}\nDAWN_UNUSED_FUNC(RenderBundleEncoderDrawIndexedDeserialize);\n\n            \nstruct RenderBundleEncoderDrawIndexedIndirectTransfer : CmdHeader {\n    static_assert(1 <= 1,\n                  \"Record must be at most one of is_cmd, extensible, and chained.\");\n    WireCmd commandId;\n\n    ObjectId self;\n    ObjectId indirectBuffer;\n    \nuint64_t indirectOffset;\n\n\n};\n\nstatic_assert(offsetof(RenderBundleEncoderDrawIndexedIndirectTransfer, commandSize) == 0);\nstatic_assert(offsetof(RenderBundleEncoderDrawIndexedIndirectTransfer, commandId) == sizeof(CmdHeader));\n\n\nDAWN_DECLARE_UNUSED size_t RenderBundleEncoderDrawIndexedIndirectGetExtraRequiredSize(const RenderBundleEncoderDrawIndexedIndirectCmd& record) {\n    DAWN_UNUSED(record);\n\n    size_t result = 0;\n\n\n\n    {\n    }\n    {\n    }\n    {\n    }\n\n    return result;\n}\n// GetExtraRequiredSize isn't used for structures that are value members of other structures\n// because we assume they cannot contain pointers themselves.\nDAWN_UNUSED_FUNC(RenderBundleEncoderDrawIndexedIndirectGetExtraRequiredSize);\n\nDAWN_DECLARE_UNUSED WireResult RenderBundleEncoderDrawIndexedIndirectSerialize(\n    const RenderBundleEncoderDrawIndexedIndirectCmd& record,\n    RenderBundleEncoderDrawIndexedIndirectTransfer* transfer,\n    SerializeBuffer* buffer, const ObjectIdProvider& provider) {\n    DAWN_UNUSED(buffer);\n\n    transfer->commandId = WireCmd::RenderBundleEncoderDrawIndexedIndirect;\n\n    WIRE_TRY(provider.GetId(record.self, &transfer->self));\n    WIRE_TRY(provider.GetId(record.indirectBuffer, &transfer->indirectBuffer));\n    transfer->indirectOffset = record.indirectOffset;\n\n\n\n\n    return WireResult::Success;\n}\nDAWN_UNUSED_FUNC(RenderBundleEncoderDrawIndexedIndirectSerialize);\n\nDAWN_DECLARE_UNUSED WireResult RenderBundleEncoderDrawIndexedIndirectDeserialize(\n    RenderBundleEncoderDrawIndexedIndirectCmd* record,\n    const volatile RenderBundleEncoderDrawIndexedIndirectTransfer* transfer,\n    DeserializeBuffer* deserializeBuffer,\n    DeserializeAllocator* allocator, const ObjectIdResolver& resolver) {\n    DAWN_UNUSED(allocator);\n\n    ASSERT(transfer->commandId == WireCmd::RenderBundleEncoderDrawIndexedIndirect);\n\n    record->selfId = transfer->self;\n\n    WIRE_TRY(resolver.GetFromId(transfer->self, &record->self));\n    WIRE_TRY(resolver.GetFromId(transfer->indirectBuffer, &record->indirectBuffer));\n    static_assert(sizeof(record->indirectOffset) >= sizeof(transfer->indirectOffset), \"Deserialize assignment may not narrow.\");\nrecord->indirectOffset = transfer->indirectOffset;\n\n\n\n\n\n    return WireResult::Success;\n}\nDAWN_UNUSED_FUNC(RenderBundleEncoderDrawIndexedIndirectDeserialize);\n\n            \nstruct RenderBundleEncoderDrawIndirectTransfer : CmdHeader {\n    static_assert(1 <= 1,\n                  \"Record must be at most one of is_cmd, extensible, and chained.\");\n    WireCmd commandId;\n\n    ObjectId self;\n    ObjectId indirectBuffer;\n    \nuint64_t indirectOffset;\n\n\n};\n\nstatic_assert(offsetof(RenderBundleEncoderDrawIndirectTransfer, commandSize) == 0);\nstatic_assert(offsetof(RenderBundleEncoderDrawIndirectTransfer, commandId) == sizeof(CmdHeader));\n\n\nDAWN_DECLARE_UNUSED size_t RenderBundleEncoderDrawIndirectGetExtraRequiredSize(const RenderBundleEncoderDrawIndirectCmd& record) {\n    DAWN_UNUSED(record);\n\n    size_t result = 0;\n\n\n\n    {\n    }\n    {\n    }\n    {\n    }\n\n    return result;\n}\n// GetExtraRequiredSize isn't used for structures that are value members of other structures\n// because we assume they cannot contain pointers themselves.\nDAWN_UNUSED_FUNC(RenderBundleEncoderDrawIndirectGetExtraRequiredSize);\n\nDAWN_DECLARE_UNUSED WireResult RenderBundleEncoderDrawIndirectSerialize(\n    const RenderBundleEncoderDrawIndirectCmd& record,\n    RenderBundleEncoderDrawIndirectTransfer* transfer,\n    SerializeBuffer* buffer, const ObjectIdProvider& provider) {\n    DAWN_UNUSED(buffer);\n\n    transfer->commandId = WireCmd::RenderBundleEncoderDrawIndirect;\n\n    WIRE_TRY(provider.GetId(record.self, &transfer->self));\n    WIRE_TRY(provider.GetId(record.indirectBuffer, &transfer->indirectBuffer));\n    transfer->indirectOffset = record.indirectOffset;\n\n\n\n\n    return WireResult::Success;\n}\nDAWN_UNUSED_FUNC(RenderBundleEncoderDrawIndirectSerialize);\n\nDAWN_DECLARE_UNUSED WireResult RenderBundleEncoderDrawIndirectDeserialize(\n    RenderBundleEncoderDrawIndirectCmd* record,\n    const volatile RenderBundleEncoderDrawIndirectTransfer* transfer,\n    DeserializeBuffer* deserializeBuffer,\n    DeserializeAllocator* allocator, const ObjectIdResolver& resolver) {\n    DAWN_UNUSED(allocator);\n\n    ASSERT(transfer->commandId == WireCmd::RenderBundleEncoderDrawIndirect);\n\n    record->selfId = transfer->self;\n\n    WIRE_TRY(resolver.GetFromId(transfer->self, &record->self));\n    WIRE_TRY(resolver.GetFromId(transfer->indirectBuffer, &record->indirectBuffer));\n    static_assert(sizeof(record->indirectOffset) >= sizeof(transfer->indirectOffset), \"Deserialize assignment may not narrow.\");\nrecord->indirectOffset = transfer->indirectOffset;\n\n\n\n\n\n    return WireResult::Success;\n}\nDAWN_UNUSED_FUNC(RenderBundleEncoderDrawIndirectDeserialize);\n\n            \nstruct RenderBundleEncoderFinishTransfer : CmdHeader {\n    static_assert(1 <= 1,\n                  \"Record must be at most one of is_cmd, extensible, and chained.\");\n    WireCmd commandId;\n\n    ObjectId self;\n    \nObjectHandle result;\n\n\n    bool has_descriptor;\n};\n\nstatic_assert(offsetof(RenderBundleEncoderFinishTransfer, commandSize) == 0);\nstatic_assert(offsetof(RenderBundleEncoderFinishTransfer, commandId) == sizeof(CmdHeader));\n\n\nDAWN_DECLARE_UNUSED size_t RenderBundleEncoderFinishGetExtraRequiredSize(const RenderBundleEncoderFinishCmd& record) {\n    DAWN_UNUSED(record);\n\n    size_t result = 0;\n\n\n\n    {\n    }\n    if (record.descriptor != nullptr)\n    {\n        \n        auto memberLength = 1u;\n        result += memberLength * sizeof(WGPURenderBundleDescriptorTransfer);\n        for (decltype(memberLength) i = 0; i < memberLength; ++i) {\n            \n            result += WGPURenderBundleDescriptorGetExtraRequiredSize(record.descriptor[i]);\n        }\n    }\n    {\n    }\n\n    return result;\n}\n// GetExtraRequiredSize isn't used for structures that are value members of other structures\n// because we assume they cannot contain pointers themselves.\nDAWN_UNUSED_FUNC(RenderBundleEncoderFinishGetExtraRequiredSize);\n\nDAWN_DECLARE_UNUSED WireResult RenderBundleEncoderFinishSerialize(\n    const RenderBundleEncoderFinishCmd& record,\n    RenderBundleEncoderFinishTransfer* transfer,\n    SerializeBuffer* buffer, const ObjectIdProvider& provider) {\n    DAWN_UNUSED(buffer);\n\n    transfer->commandId = WireCmd::RenderBundleEncoderFinish;\n\n    WIRE_TRY(provider.GetId(record.self, &transfer->self));\n    transfer->result = record.result;\n\n\n\n\n    \n\n    bool has_descriptor = record.descriptor != nullptr;\n    transfer->has_descriptor = has_descriptor;\n    if (has_descriptor)\n    {\n        auto memberLength = 1u;\n\n        WGPURenderBundleDescriptorTransfer* memberBuffer;\n        WIRE_TRY(buffer->NextN(memberLength, &memberBuffer));\n\n        for (decltype(memberLength) i = 0; i < memberLength; ++i) {\n            WIRE_TRY(WGPURenderBundleDescriptorSerialize(record.descriptor[i], &memberBuffer[i], buffer, provider));\n        }\n    }\n    return WireResult::Success;\n}\nDAWN_UNUSED_FUNC(RenderBundleEncoderFinishSerialize);\n\nDAWN_DECLARE_UNUSED WireResult RenderBundleEncoderFinishDeserialize(\n    RenderBundleEncoderFinishCmd* record,\n    const volatile RenderBundleEncoderFinishTransfer* transfer,\n    DeserializeBuffer* deserializeBuffer,\n    DeserializeAllocator* allocator, const ObjectIdResolver& resolver) {\n    DAWN_UNUSED(allocator);\n\n    ASSERT(transfer->commandId == WireCmd::RenderBundleEncoderFinish);\n\n    record->selfId = transfer->self;\n\n    WIRE_TRY(resolver.GetFromId(transfer->self, &record->self));\n    static_assert(sizeof(record->result) >= sizeof(transfer->result), \"Deserialize assignment may not narrow.\");\nrecord->result = transfer->result;\n\n\n\n\n    \n\n    \n    bool has_descriptor = transfer->has_descriptor;\n    record->descriptor = nullptr;\n    if (has_descriptor)\n    {\n        auto memberLength = 1u;\n        const volatile WGPURenderBundleDescriptorTransfer* memberBuffer;\n        WIRE_TRY(deserializeBuffer->ReadN(memberLength, &memberBuffer));\n\n        WGPURenderBundleDescriptor* copiedMembers;\n        WIRE_TRY(GetSpace(allocator, memberLength, &copiedMembers));\n        record->descriptor = copiedMembers;\n\n        for (decltype(memberLength) i = 0; i < memberLength; ++i) {\n            WIRE_TRY(WGPURenderBundleDescriptorDeserialize(&copiedMembers[i], &memberBuffer[i], deserializeBuffer, allocator, resolver));\n        }\n    }\n\n    return WireResult::Success;\n}\nDAWN_UNUSED_FUNC(RenderBundleEncoderFinishDeserialize);\n\n            \nstruct RenderBundleEncoderInsertDebugMarkerTransfer : CmdHeader {\n    static_assert(1 <= 1,\n                  \"Record must be at most one of is_cmd, extensible, and chained.\");\n    WireCmd commandId;\n\n    ObjectId self;\n\n    uint64_t markerLabelStrlen;\n\n};\n\nstatic_assert(offsetof(RenderBundleEncoderInsertDebugMarkerTransfer, commandSize) == 0);\nstatic_assert(offsetof(RenderBundleEncoderInsertDebugMarkerTransfer, commandId) == sizeof(CmdHeader));\n\n\nDAWN_DECLARE_UNUSED size_t RenderBundleEncoderInsertDebugMarkerGetExtraRequiredSize(const RenderBundleEncoderInsertDebugMarkerCmd& record) {\n    DAWN_UNUSED(record);\n\n    size_t result = 0;\n\n\n\n    {\n    result += std::strlen(record.markerLabel);\n    }\n\n    {\n    }\n\n    return result;\n}\n// GetExtraRequiredSize isn't used for structures that are value members of other structures\n// because we assume they cannot contain pointers themselves.\nDAWN_UNUSED_FUNC(RenderBundleEncoderInsertDebugMarkerGetExtraRequiredSize);\n\nDAWN_DECLARE_UNUSED WireResult RenderBundleEncoderInsertDebugMarkerSerialize(\n    const RenderBundleEncoderInsertDebugMarkerCmd& record,\n    RenderBundleEncoderInsertDebugMarkerTransfer* transfer,\n    SerializeBuffer* buffer, const ObjectIdProvider& provider) {\n    DAWN_UNUSED(buffer);\n\n    transfer->commandId = WireCmd::RenderBundleEncoderInsertDebugMarker;\n\n    WIRE_TRY(provider.GetId(record.self, &transfer->self));\n\n\n\n\n    {\n        transfer->markerLabelStrlen = std::strlen(record.markerLabel);\n\n        char* stringInBuffer;\n        WIRE_TRY(buffer->NextN(transfer->markerLabelStrlen, &stringInBuffer));\n        memcpy(stringInBuffer, record.markerLabel, transfer->markerLabelStrlen);\n    }\n\n    return WireResult::Success;\n}\nDAWN_UNUSED_FUNC(RenderBundleEncoderInsertDebugMarkerSerialize);\n\nDAWN_DECLARE_UNUSED WireResult RenderBundleEncoderInsertDebugMarkerDeserialize(\n    RenderBundleEncoderInsertDebugMarkerCmd* record,\n    const volatile RenderBundleEncoderInsertDebugMarkerTransfer* transfer,\n    DeserializeBuffer* deserializeBuffer,\n    DeserializeAllocator* allocator, const ObjectIdResolver& resolver) {\n    DAWN_UNUSED(allocator);\n\n    ASSERT(transfer->commandId == WireCmd::RenderBundleEncoderInsertDebugMarker);\n\n    record->selfId = transfer->self;\n\n    WIRE_TRY(resolver.GetFromId(transfer->self, &record->self));\n\n\n\n\n    {\n        uint64_t stringLength64 = transfer->markerLabelStrlen;\n        if (stringLength64 >= std::numeric_limits<size_t>::max()) {\n            return WireResult::FatalError;\n        }\n        size_t stringLength = static_cast<size_t>(stringLength64);\n\n        const volatile char* stringInBuffer;\n        WIRE_TRY(deserializeBuffer->ReadN(stringLength, &stringInBuffer));\n\n        char* copiedString;\n        WIRE_TRY(GetSpace(allocator, stringLength + 1, &copiedString));\n        memcpy(copiedString, const_cast<const char*>(stringInBuffer), stringLength);\n        copiedString[stringLength] = '\\0';\n        record->markerLabel = copiedString;\n    }\n\n\n    return WireResult::Success;\n}\nDAWN_UNUSED_FUNC(RenderBundleEncoderInsertDebugMarkerDeserialize);\n\n            \nstruct RenderBundleEncoderPopDebugGroupTransfer : CmdHeader {\n    static_assert(1 <= 1,\n                  \"Record must be at most one of is_cmd, extensible, and chained.\");\n    WireCmd commandId;\n\n    ObjectId self;\n\n\n};\n\nstatic_assert(offsetof(RenderBundleEncoderPopDebugGroupTransfer, commandSize) == 0);\nstatic_assert(offsetof(RenderBundleEncoderPopDebugGroupTransfer, commandId) == sizeof(CmdHeader));\n\n\nDAWN_DECLARE_UNUSED size_t RenderBundleEncoderPopDebugGroupGetExtraRequiredSize(const RenderBundleEncoderPopDebugGroupCmd& record) {\n    DAWN_UNUSED(record);\n\n    size_t result = 0;\n\n\n\n    {\n    }\n\n    return result;\n}\n// GetExtraRequiredSize isn't used for structures that are value members of other structures\n// because we assume they cannot contain pointers themselves.\nDAWN_UNUSED_FUNC(RenderBundleEncoderPopDebugGroupGetExtraRequiredSize);\n\nDAWN_DECLARE_UNUSED WireResult RenderBundleEncoderPopDebugGroupSerialize(\n    const RenderBundleEncoderPopDebugGroupCmd& record,\n    RenderBundleEncoderPopDebugGroupTransfer* transfer,\n    SerializeBuffer* buffer, const ObjectIdProvider& provider) {\n    DAWN_UNUSED(buffer);\n\n    transfer->commandId = WireCmd::RenderBundleEncoderPopDebugGroup;\n\n    WIRE_TRY(provider.GetId(record.self, &transfer->self));\n\n\n\n\n    return WireResult::Success;\n}\nDAWN_UNUSED_FUNC(RenderBundleEncoderPopDebugGroupSerialize);\n\nDAWN_DECLARE_UNUSED WireResult RenderBundleEncoderPopDebugGroupDeserialize(\n    RenderBundleEncoderPopDebugGroupCmd* record,\n    const volatile RenderBundleEncoderPopDebugGroupTransfer* transfer,\n    DeserializeBuffer* deserializeBuffer,\n    DeserializeAllocator* allocator, const ObjectIdResolver& resolver) {\n    DAWN_UNUSED(allocator);\n\n    ASSERT(transfer->commandId == WireCmd::RenderBundleEncoderPopDebugGroup);\n\n    record->selfId = transfer->self;\n\n    WIRE_TRY(resolver.GetFromId(transfer->self, &record->self));\n\n\n\n\n\n    return WireResult::Success;\n}\nDAWN_UNUSED_FUNC(RenderBundleEncoderPopDebugGroupDeserialize);\n\n            \nstruct RenderBundleEncoderPushDebugGroupTransfer : CmdHeader {\n    static_assert(1 <= 1,\n                  \"Record must be at most one of is_cmd, extensible, and chained.\");\n    WireCmd commandId;\n\n    ObjectId self;\n\n    uint64_t groupLabelStrlen;\n\n};\n\nstatic_assert(offsetof(RenderBundleEncoderPushDebugGroupTransfer, commandSize) == 0);\nstatic_assert(offsetof(RenderBundleEncoderPushDebugGroupTransfer, commandId) == sizeof(CmdHeader));\n\n\nDAWN_DECLARE_UNUSED size_t RenderBundleEncoderPushDebugGroupGetExtraRequiredSize(const RenderBundleEncoderPushDebugGroupCmd& record) {\n    DAWN_UNUSED(record);\n\n    size_t result = 0;\n\n\n\n    {\n    result += std::strlen(record.groupLabel);\n    }\n\n    {\n    }\n\n    return result;\n}\n// GetExtraRequiredSize isn't used for structures that are value members of other structures\n// because we assume they cannot contain pointers themselves.\nDAWN_UNUSED_FUNC(RenderBundleEncoderPushDebugGroupGetExtraRequiredSize);\n\nDAWN_DECLARE_UNUSED WireResult RenderBundleEncoderPushDebugGroupSerialize(\n    const RenderBundleEncoderPushDebugGroupCmd& record,\n    RenderBundleEncoderPushDebugGroupTransfer* transfer,\n    SerializeBuffer* buffer, const ObjectIdProvider& provider) {\n    DAWN_UNUSED(buffer);\n\n    transfer->commandId = WireCmd::RenderBundleEncoderPushDebugGroup;\n\n    WIRE_TRY(provider.GetId(record.self, &transfer->self));\n\n\n\n\n    {\n        transfer->groupLabelStrlen = std::strlen(record.groupLabel);\n\n        char* stringInBuffer;\n        WIRE_TRY(buffer->NextN(transfer->groupLabelStrlen, &stringInBuffer));\n        memcpy(stringInBuffer, record.groupLabel, transfer->groupLabelStrlen);\n    }\n\n    return WireResult::Success;\n}\nDAWN_UNUSED_FUNC(RenderBundleEncoderPushDebugGroupSerialize);\n\nDAWN_DECLARE_UNUSED WireResult RenderBundleEncoderPushDebugGroupDeserialize(\n    RenderBundleEncoderPushDebugGroupCmd* record,\n    const volatile RenderBundleEncoderPushDebugGroupTransfer* transfer,\n    DeserializeBuffer* deserializeBuffer,\n    DeserializeAllocator* allocator, const ObjectIdResolver& resolver) {\n    DAWN_UNUSED(allocator);\n\n    ASSERT(transfer->commandId == WireCmd::RenderBundleEncoderPushDebugGroup);\n\n    record->selfId = transfer->self;\n\n    WIRE_TRY(resolver.GetFromId(transfer->self, &record->self));\n\n\n\n\n    {\n        uint64_t stringLength64 = transfer->groupLabelStrlen;\n        if (stringLength64 >= std::numeric_limits<size_t>::max()) {\n            return WireResult::FatalError;\n        }\n        size_t stringLength = static_cast<size_t>(stringLength64);\n\n        const volatile char* stringInBuffer;\n        WIRE_TRY(deserializeBuffer->ReadN(stringLength, &stringInBuffer));\n\n        char* copiedString;\n        WIRE_TRY(GetSpace(allocator, stringLength + 1, &copiedString));\n        memcpy(copiedString, const_cast<const char*>(stringInBuffer), stringLength);\n        copiedString[stringLength] = '\\0';\n        record->groupLabel = copiedString;\n    }\n\n\n    return WireResult::Success;\n}\nDAWN_UNUSED_FUNC(RenderBundleEncoderPushDebugGroupDeserialize);\n\n            \nstruct RenderBundleEncoderSetBindGroupTransfer : CmdHeader {\n    static_assert(1 <= 1,\n                  \"Record must be at most one of is_cmd, extensible, and chained.\");\n    WireCmd commandId;\n\n    ObjectId self;\n    \nuint32_t groupIndex;\n    ObjectId group;\n    \nuint32_t dynamicOffsetCount;\n\n\n};\n\nstatic_assert(offsetof(RenderBundleEncoderSetBindGroupTransfer, commandSize) == 0);\nstatic_assert(offsetof(RenderBundleEncoderSetBindGroupTransfer, commandId) == sizeof(CmdHeader));\n\n\nDAWN_DECLARE_UNUSED size_t RenderBundleEncoderSetBindGroupGetExtraRequiredSize(const RenderBundleEncoderSetBindGroupCmd& record) {\n    DAWN_UNUSED(record);\n\n    size_t result = 0;\n\n\n\n    {\n    }\n    {\n    }\n    {\n    }\n    {\n    }\n    {\n        \n        auto memberLength = record.dynamicOffsetCount;\n        result += memberLength * sizeof(\nuint32_t);\n    }\n\n    return result;\n}\n// GetExtraRequiredSize isn't used for structures that are value members of other structures\n// because we assume they cannot contain pointers themselves.\nDAWN_UNUSED_FUNC(RenderBundleEncoderSetBindGroupGetExtraRequiredSize);\n\nDAWN_DECLARE_UNUSED WireResult RenderBundleEncoderSetBindGroupSerialize(\n    const RenderBundleEncoderSetBindGroupCmd& record,\n    RenderBundleEncoderSetBindGroupTransfer* transfer,\n    SerializeBuffer* buffer, const ObjectIdProvider& provider) {\n    DAWN_UNUSED(buffer);\n\n    transfer->commandId = WireCmd::RenderBundleEncoderSetBindGroup;\n\n    WIRE_TRY(provider.GetId(record.self, &transfer->self));\n    transfer->groupIndex = record.groupIndex;\n    WIRE_TRY(provider.GetId(record.group, &transfer->group));\n    transfer->dynamicOffsetCount = record.dynamicOffsetCount;\n\n\n\n\n    \n\n    {\n        auto memberLength = record.dynamicOffsetCount;\n\n        \nuint32_t* memberBuffer;\n        WIRE_TRY(buffer->NextN(memberLength, &memberBuffer));\n\n        memcpy(\n            memberBuffer, record.dynamicOffsets,\n            sizeof(\nuint32_t) * memberLength);\n    }\n    return WireResult::Success;\n}\nDAWN_UNUSED_FUNC(RenderBundleEncoderSetBindGroupSerialize);\n\nDAWN_DECLARE_UNUSED WireResult RenderBundleEncoderSetBindGroupDeserialize(\n    RenderBundleEncoderSetBindGroupCmd* record,\n    const volatile RenderBundleEncoderSetBindGroupTransfer* transfer,\n    DeserializeBuffer* deserializeBuffer,\n    DeserializeAllocator* allocator, const ObjectIdResolver& resolver) {\n    DAWN_UNUSED(allocator);\n\n    ASSERT(transfer->commandId == WireCmd::RenderBundleEncoderSetBindGroup);\n\n    record->selfId = transfer->self;\n\n    WIRE_TRY(resolver.GetFromId(transfer->self, &record->self));\n    static_assert(sizeof(record->groupIndex) >= sizeof(transfer->groupIndex), \"Deserialize assignment may not narrow.\");\nrecord->groupIndex = transfer->groupIndex;\n    WIRE_TRY(resolver.GetFromId(transfer->group, &record->group));\n    static_assert(sizeof(record->dynamicOffsetCount) >= sizeof(transfer->dynamicOffsetCount), \"Deserialize assignment may not narrow.\");\nrecord->dynamicOffsetCount = transfer->dynamicOffsetCount;\n\n\n\n\n    \n\n    {\n        auto memberLength = record->dynamicOffsetCount;\n        const volatile \nuint32_t* memberBuffer;\n        WIRE_TRY(deserializeBuffer->ReadN(memberLength, &memberBuffer));\n\n        uint32_t* copiedMembers;\n        WIRE_TRY(GetSpace(allocator, memberLength, &copiedMembers));\n        record->dynamicOffsets = copiedMembers;\n\n        memcpy(\n            copiedMembers,\n            const_cast<const \nuint32_t*>(memberBuffer),\n           sizeof(\nuint32_t) * memberLength);\n    }\n\n    return WireResult::Success;\n}\nDAWN_UNUSED_FUNC(RenderBundleEncoderSetBindGroupDeserialize);\n\n            \nstruct RenderBundleEncoderSetIndexBufferTransfer : CmdHeader {\n    static_assert(1 <= 1,\n                  \"Record must be at most one of is_cmd, extensible, and chained.\");\n    WireCmd commandId;\n\n    ObjectId self;\n    ObjectId buffer;\n    \nWGPUIndexFormat format;\n    \nuint64_t offset;\n    \nuint64_t size;\n\n\n};\n\nstatic_assert(offsetof(RenderBundleEncoderSetIndexBufferTransfer, commandSize) == 0);\nstatic_assert(offsetof(RenderBundleEncoderSetIndexBufferTransfer, commandId) == sizeof(CmdHeader));\n\n\nDAWN_DECLARE_UNUSED size_t RenderBundleEncoderSetIndexBufferGetExtraRequiredSize(const RenderBundleEncoderSetIndexBufferCmd& record) {\n    DAWN_UNUSED(record);\n\n    size_t result = 0;\n\n\n\n    {\n    }\n    {\n    }\n    {\n    }\n    {\n    }\n    {\n    }\n\n    return result;\n}\n// GetExtraRequiredSize isn't used for structures that are value members of other structures\n// because we assume they cannot contain pointers themselves.\nDAWN_UNUSED_FUNC(RenderBundleEncoderSetIndexBufferGetExtraRequiredSize);\n\nDAWN_DECLARE_UNUSED WireResult RenderBundleEncoderSetIndexBufferSerialize(\n    const RenderBundleEncoderSetIndexBufferCmd& record,\n    RenderBundleEncoderSetIndexBufferTransfer* transfer,\n    SerializeBuffer* buffer, const ObjectIdProvider& provider) {\n    DAWN_UNUSED(buffer);\n\n    transfer->commandId = WireCmd::RenderBundleEncoderSetIndexBuffer;\n\n    WIRE_TRY(provider.GetId(record.self, &transfer->self));\n    WIRE_TRY(provider.GetId(record.buffer, &transfer->buffer));\n    transfer->format = record.format;\n    transfer->offset = record.offset;\n    transfer->size = record.size;\n\n\n\n\n    return WireResult::Success;\n}\nDAWN_UNUSED_FUNC(RenderBundleEncoderSetIndexBufferSerialize);\n\nDAWN_DECLARE_UNUSED WireResult RenderBundleEncoderSetIndexBufferDeserialize(\n    RenderBundleEncoderSetIndexBufferCmd* record,\n    const volatile RenderBundleEncoderSetIndexBufferTransfer* transfer,\n    DeserializeBuffer* deserializeBuffer,\n    DeserializeAllocator* allocator, const ObjectIdResolver& resolver) {\n    DAWN_UNUSED(allocator);\n\n    ASSERT(transfer->commandId == WireCmd::RenderBundleEncoderSetIndexBuffer);\n\n    record->selfId = transfer->self;\n\n    WIRE_TRY(resolver.GetFromId(transfer->self, &record->self));\n    WIRE_TRY(resolver.GetFromId(transfer->buffer, &record->buffer));\n    static_assert(sizeof(record->format) >= sizeof(transfer->format), \"Deserialize assignment may not narrow.\");\nrecord->format = transfer->format;\n    static_assert(sizeof(record->offset) >= sizeof(transfer->offset), \"Deserialize assignment may not narrow.\");\nrecord->offset = transfer->offset;\n    static_assert(sizeof(record->size) >= sizeof(transfer->size), \"Deserialize assignment may not narrow.\");\nrecord->size = transfer->size;\n\n\n\n\n\n    return WireResult::Success;\n}\nDAWN_UNUSED_FUNC(RenderBundleEncoderSetIndexBufferDeserialize);\n\n            \nstruct RenderBundleEncoderSetLabelTransfer : CmdHeader {\n    static_assert(1 <= 1,\n                  \"Record must be at most one of is_cmd, extensible, and chained.\");\n    WireCmd commandId;\n\n    ObjectId self;\n\n    uint64_t labelStrlen;\n\n};\n\nstatic_assert(offsetof(RenderBundleEncoderSetLabelTransfer, commandSize) == 0);\nstatic_assert(offsetof(RenderBundleEncoderSetLabelTransfer, commandId) == sizeof(CmdHeader));\n\n\nDAWN_DECLARE_UNUSED size_t RenderBundleEncoderSetLabelGetExtraRequiredSize(const RenderBundleEncoderSetLabelCmd& record) {\n    DAWN_UNUSED(record);\n\n    size_t result = 0;\n\n\n\n    {\n    result += std::strlen(record.label);\n    }\n\n    {\n    }\n\n    return result;\n}\n// GetExtraRequiredSize isn't used for structures that are value members of other structures\n// because we assume they cannot contain pointers themselves.\nDAWN_UNUSED_FUNC(RenderBundleEncoderSetLabelGetExtraRequiredSize);\n\nDAWN_DECLARE_UNUSED WireResult RenderBundleEncoderSetLabelSerialize(\n    const RenderBundleEncoderSetLabelCmd& record,\n    RenderBundleEncoderSetLabelTransfer* transfer,\n    SerializeBuffer* buffer, const ObjectIdProvider& provider) {\n    DAWN_UNUSED(buffer);\n\n    transfer->commandId = WireCmd::RenderBundleEncoderSetLabel;\n\n    WIRE_TRY(provider.GetId(record.self, &transfer->self));\n\n\n\n\n    {\n        transfer->labelStrlen = std::strlen(record.label);\n\n        char* stringInBuffer;\n        WIRE_TRY(buffer->NextN(transfer->labelStrlen, &stringInBuffer));\n        memcpy(stringInBuffer, record.label, transfer->labelStrlen);\n    }\n\n    return WireResult::Success;\n}\nDAWN_UNUSED_FUNC(RenderBundleEncoderSetLabelSerialize);\n\nDAWN_DECLARE_UNUSED WireResult RenderBundleEncoderSetLabelDeserialize(\n    RenderBundleEncoderSetLabelCmd* record,\n    const volatile RenderBundleEncoderSetLabelTransfer* transfer,\n    DeserializeBuffer* deserializeBuffer,\n    DeserializeAllocator* allocator, const ObjectIdResolver& resolver) {\n    DAWN_UNUSED(allocator);\n\n    ASSERT(transfer->commandId == WireCmd::RenderBundleEncoderSetLabel);\n\n    record->selfId = transfer->self;\n\n    WIRE_TRY(resolver.GetFromId(transfer->self, &record->self));\n\n\n\n\n    {\n        uint64_t stringLength64 = transfer->labelStrlen;\n        if (stringLength64 >= std::numeric_limits<size_t>::max()) {\n            return WireResult::FatalError;\n        }\n        size_t stringLength = static_cast<size_t>(stringLength64);\n\n        const volatile char* stringInBuffer;\n        WIRE_TRY(deserializeBuffer->ReadN(stringLength, &stringInBuffer));\n\n        char* copiedString;\n        WIRE_TRY(GetSpace(allocator, stringLength + 1, &copiedString));\n        memcpy(copiedString, const_cast<const char*>(stringInBuffer), stringLength);\n        copiedString[stringLength] = '\\0';\n        record->label = copiedString;\n    }\n\n\n    return WireResult::Success;\n}\nDAWN_UNUSED_FUNC(RenderBundleEncoderSetLabelDeserialize);\n\n            \nstruct RenderBundleEncoderSetPipelineTransfer : CmdHeader {\n    static_assert(1 <= 1,\n                  \"Record must be at most one of is_cmd, extensible, and chained.\");\n    WireCmd commandId;\n\n    ObjectId self;\n    ObjectId pipeline;\n\n\n};\n\nstatic_assert(offsetof(RenderBundleEncoderSetPipelineTransfer, commandSize) == 0);\nstatic_assert(offsetof(RenderBundleEncoderSetPipelineTransfer, commandId) == sizeof(CmdHeader));\n\n\nDAWN_DECLARE_UNUSED size_t RenderBundleEncoderSetPipelineGetExtraRequiredSize(const RenderBundleEncoderSetPipelineCmd& record) {\n    DAWN_UNUSED(record);\n\n    size_t result = 0;\n\n\n\n    {\n    }\n    {\n    }\n\n    return result;\n}\n// GetExtraRequiredSize isn't used for structures that are value members of other structures\n// because we assume they cannot contain pointers themselves.\nDAWN_UNUSED_FUNC(RenderBundleEncoderSetPipelineGetExtraRequiredSize);\n\nDAWN_DECLARE_UNUSED WireResult RenderBundleEncoderSetPipelineSerialize(\n    const RenderBundleEncoderSetPipelineCmd& record,\n    RenderBundleEncoderSetPipelineTransfer* transfer,\n    SerializeBuffer* buffer, const ObjectIdProvider& provider) {\n    DAWN_UNUSED(buffer);\n\n    transfer->commandId = WireCmd::RenderBundleEncoderSetPipeline;\n\n    WIRE_TRY(provider.GetId(record.self, &transfer->self));\n    WIRE_TRY(provider.GetId(record.pipeline, &transfer->pipeline));\n\n\n\n\n    return WireResult::Success;\n}\nDAWN_UNUSED_FUNC(RenderBundleEncoderSetPipelineSerialize);\n\nDAWN_DECLARE_UNUSED WireResult RenderBundleEncoderSetPipelineDeserialize(\n    RenderBundleEncoderSetPipelineCmd* record,\n    const volatile RenderBundleEncoderSetPipelineTransfer* transfer,\n    DeserializeBuffer* deserializeBuffer,\n    DeserializeAllocator* allocator, const ObjectIdResolver& resolver) {\n    DAWN_UNUSED(allocator);\n\n    ASSERT(transfer->commandId == WireCmd::RenderBundleEncoderSetPipeline);\n\n    record->selfId = transfer->self;\n\n    WIRE_TRY(resolver.GetFromId(transfer->self, &record->self));\n    WIRE_TRY(resolver.GetFromId(transfer->pipeline, &record->pipeline));\n\n\n\n\n\n    return WireResult::Success;\n}\nDAWN_UNUSED_FUNC(RenderBundleEncoderSetPipelineDeserialize);\n\n            \nstruct RenderBundleEncoderSetVertexBufferTransfer : CmdHeader {\n    static_assert(1 <= 1,\n                  \"Record must be at most one of is_cmd, extensible, and chained.\");\n    WireCmd commandId;\n\n    ObjectId self;\n    \nuint32_t slot;\n    ObjectId buffer;\n    \nuint64_t offset;\n    \nuint64_t size;\n\n\n};\n\nstatic_assert(offsetof(RenderBundleEncoderSetVertexBufferTransfer, commandSize) == 0);\nstatic_assert(offsetof(RenderBundleEncoderSetVertexBufferTransfer, commandId) == sizeof(CmdHeader));\n\n\nDAWN_DECLARE_UNUSED size_t RenderBundleEncoderSetVertexBufferGetExtraRequiredSize(const RenderBundleEncoderSetVertexBufferCmd& record) {\n    DAWN_UNUSED(record);\n\n    size_t result = 0;\n\n\n\n    {\n    }\n    {\n    }\n    {\n    }\n    {\n    }\n    {\n    }\n\n    return result;\n}\n// GetExtraRequiredSize isn't used for structures that are value members of other structures\n// because we assume they cannot contain pointers themselves.\nDAWN_UNUSED_FUNC(RenderBundleEncoderSetVertexBufferGetExtraRequiredSize);\n\nDAWN_DECLARE_UNUSED WireResult RenderBundleEncoderSetVertexBufferSerialize(\n    const RenderBundleEncoderSetVertexBufferCmd& record,\n    RenderBundleEncoderSetVertexBufferTransfer* transfer,\n    SerializeBuffer* buffer, const ObjectIdProvider& provider) {\n    DAWN_UNUSED(buffer);\n\n    transfer->commandId = WireCmd::RenderBundleEncoderSetVertexBuffer;\n\n    WIRE_TRY(provider.GetId(record.self, &transfer->self));\n    transfer->slot = record.slot;\n    WIRE_TRY(provider.GetId(record.buffer, &transfer->buffer));\n    transfer->offset = record.offset;\n    transfer->size = record.size;\n\n\n\n\n    return WireResult::Success;\n}\nDAWN_UNUSED_FUNC(RenderBundleEncoderSetVertexBufferSerialize);\n\nDAWN_DECLARE_UNUSED WireResult RenderBundleEncoderSetVertexBufferDeserialize(\n    RenderBundleEncoderSetVertexBufferCmd* record,\n    const volatile RenderBundleEncoderSetVertexBufferTransfer* transfer,\n    DeserializeBuffer* deserializeBuffer,\n    DeserializeAllocator* allocator, const ObjectIdResolver& resolver) {\n    DAWN_UNUSED(allocator);\n\n    ASSERT(transfer->commandId == WireCmd::RenderBundleEncoderSetVertexBuffer);\n\n    record->selfId = transfer->self;\n\n    WIRE_TRY(resolver.GetFromId(transfer->self, &record->self));\n    static_assert(sizeof(record->slot) >= sizeof(transfer->slot), \"Deserialize assignment may not narrow.\");\nrecord->slot = transfer->slot;\n    WIRE_TRY(resolver.GetFromId(transfer->buffer, &record->buffer));\n    static_assert(sizeof(record->offset) >= sizeof(transfer->offset), \"Deserialize assignment may not narrow.\");\nrecord->offset = transfer->offset;\n    static_assert(sizeof(record->size) >= sizeof(transfer->size), \"Deserialize assignment may not narrow.\");\nrecord->size = transfer->size;\n\n\n\n\n\n    return WireResult::Success;\n}\nDAWN_UNUSED_FUNC(RenderBundleEncoderSetVertexBufferDeserialize);\n\n            \nstruct RenderPassEncoderBeginOcclusionQueryTransfer : CmdHeader {\n    static_assert(1 <= 1,\n                  \"Record must be at most one of is_cmd, extensible, and chained.\");\n    WireCmd commandId;\n\n    ObjectId self;\n    \nuint32_t queryIndex;\n\n\n};\n\nstatic_assert(offsetof(RenderPassEncoderBeginOcclusionQueryTransfer, commandSize) == 0);\nstatic_assert(offsetof(RenderPassEncoderBeginOcclusionQueryTransfer, commandId) == sizeof(CmdHeader));\n\n\nDAWN_DECLARE_UNUSED size_t RenderPassEncoderBeginOcclusionQueryGetExtraRequiredSize(const RenderPassEncoderBeginOcclusionQueryCmd& record) {\n    DAWN_UNUSED(record);\n\n    size_t result = 0;\n\n\n\n    {\n    }\n    {\n    }\n\n    return result;\n}\n// GetExtraRequiredSize isn't used for structures that are value members of other structures\n// because we assume they cannot contain pointers themselves.\nDAWN_UNUSED_FUNC(RenderPassEncoderBeginOcclusionQueryGetExtraRequiredSize);\n\nDAWN_DECLARE_UNUSED WireResult RenderPassEncoderBeginOcclusionQuerySerialize(\n    const RenderPassEncoderBeginOcclusionQueryCmd& record,\n    RenderPassEncoderBeginOcclusionQueryTransfer* transfer,\n    SerializeBuffer* buffer, const ObjectIdProvider& provider) {\n    DAWN_UNUSED(buffer);\n\n    transfer->commandId = WireCmd::RenderPassEncoderBeginOcclusionQuery;\n\n    WIRE_TRY(provider.GetId(record.self, &transfer->self));\n    transfer->queryIndex = record.queryIndex;\n\n\n\n\n    return WireResult::Success;\n}\nDAWN_UNUSED_FUNC(RenderPassEncoderBeginOcclusionQuerySerialize);\n\nDAWN_DECLARE_UNUSED WireResult RenderPassEncoderBeginOcclusionQueryDeserialize(\n    RenderPassEncoderBeginOcclusionQueryCmd* record,\n    const volatile RenderPassEncoderBeginOcclusionQueryTransfer* transfer,\n    DeserializeBuffer* deserializeBuffer,\n    DeserializeAllocator* allocator, const ObjectIdResolver& resolver) {\n    DAWN_UNUSED(allocator);\n\n    ASSERT(transfer->commandId == WireCmd::RenderPassEncoderBeginOcclusionQuery);\n\n    record->selfId = transfer->self;\n\n    WIRE_TRY(resolver.GetFromId(transfer->self, &record->self));\n    static_assert(sizeof(record->queryIndex) >= sizeof(transfer->queryIndex), \"Deserialize assignment may not narrow.\");\nrecord->queryIndex = transfer->queryIndex;\n\n\n\n\n\n    return WireResult::Success;\n}\nDAWN_UNUSED_FUNC(RenderPassEncoderBeginOcclusionQueryDeserialize);\n\n            \nstruct RenderPassEncoderDrawTransfer : CmdHeader {\n    static_assert(1 <= 1,\n                  \"Record must be at most one of is_cmd, extensible, and chained.\");\n    WireCmd commandId;\n\n    ObjectId self;\n    \nuint32_t vertexCount;\n    \nuint32_t instanceCount;\n    \nuint32_t firstVertex;\n    \nuint32_t firstInstance;\n\n\n};\n\nstatic_assert(offsetof(RenderPassEncoderDrawTransfer, commandSize) == 0);\nstatic_assert(offsetof(RenderPassEncoderDrawTransfer, commandId) == sizeof(CmdHeader));\n\n\nDAWN_DECLARE_UNUSED size_t RenderPassEncoderDrawGetExtraRequiredSize(const RenderPassEncoderDrawCmd& record) {\n    DAWN_UNUSED(record);\n\n    size_t result = 0;\n\n\n\n    {\n    }\n    {\n    }\n    {\n    }\n    {\n    }\n    {\n    }\n\n    return result;\n}\n// GetExtraRequiredSize isn't used for structures that are value members of other structures\n// because we assume they cannot contain pointers themselves.\nDAWN_UNUSED_FUNC(RenderPassEncoderDrawGetExtraRequiredSize);\n\nDAWN_DECLARE_UNUSED WireResult RenderPassEncoderDrawSerialize(\n    const RenderPassEncoderDrawCmd& record,\n    RenderPassEncoderDrawTransfer* transfer,\n    SerializeBuffer* buffer, const ObjectIdProvider& provider) {\n    DAWN_UNUSED(buffer);\n\n    transfer->commandId = WireCmd::RenderPassEncoderDraw;\n\n    WIRE_TRY(provider.GetId(record.self, &transfer->self));\n    transfer->vertexCount = record.vertexCount;\n    transfer->instanceCount = record.instanceCount;\n    transfer->firstVertex = record.firstVertex;\n    transfer->firstInstance = record.firstInstance;\n\n\n\n\n    return WireResult::Success;\n}\nDAWN_UNUSED_FUNC(RenderPassEncoderDrawSerialize);\n\nDAWN_DECLARE_UNUSED WireResult RenderPassEncoderDrawDeserialize(\n    RenderPassEncoderDrawCmd* record,\n    const volatile RenderPassEncoderDrawTransfer* transfer,\n    DeserializeBuffer* deserializeBuffer,\n    DeserializeAllocator* allocator, const ObjectIdResolver& resolver) {\n    DAWN_UNUSED(allocator);\n\n    ASSERT(transfer->commandId == WireCmd::RenderPassEncoderDraw);\n\n    record->selfId = transfer->self;\n\n    WIRE_TRY(resolver.GetFromId(transfer->self, &record->self));\n    static_assert(sizeof(record->vertexCount) >= sizeof(transfer->vertexCount), \"Deserialize assignment may not narrow.\");\nrecord->vertexCount = transfer->vertexCount;\n    static_assert(sizeof(record->instanceCount) >= sizeof(transfer->instanceCount), \"Deserialize assignment may not narrow.\");\nrecord->instanceCount = transfer->instanceCount;\n    static_assert(sizeof(record->firstVertex) >= sizeof(transfer->firstVertex), \"Deserialize assignment may not narrow.\");\nrecord->firstVertex = transfer->firstVertex;\n    static_assert(sizeof(record->firstInstance) >= sizeof(transfer->firstInstance), \"Deserialize assignment may not narrow.\");\nrecord->firstInstance = transfer->firstInstance;\n\n\n\n\n\n    return WireResult::Success;\n}\nDAWN_UNUSED_FUNC(RenderPassEncoderDrawDeserialize);\n\n            \nstruct RenderPassEncoderDrawIndexedTransfer : CmdHeader {\n    static_assert(1 <= 1,\n                  \"Record must be at most one of is_cmd, extensible, and chained.\");\n    WireCmd commandId;\n\n    ObjectId self;\n    \nuint32_t indexCount;\n    \nuint32_t instanceCount;\n    \nuint32_t firstIndex;\n    \nint32_t baseVertex;\n    \nuint32_t firstInstance;\n\n\n};\n\nstatic_assert(offsetof(RenderPassEncoderDrawIndexedTransfer, commandSize) == 0);\nstatic_assert(offsetof(RenderPassEncoderDrawIndexedTransfer, commandId) == sizeof(CmdHeader));\n\n\nDAWN_DECLARE_UNUSED size_t RenderPassEncoderDrawIndexedGetExtraRequiredSize(const RenderPassEncoderDrawIndexedCmd& record) {\n    DAWN_UNUSED(record);\n\n    size_t result = 0;\n\n\n\n    {\n    }\n    {\n    }\n    {\n    }\n    {\n    }\n    {\n    }\n    {\n    }\n\n    return result;\n}\n// GetExtraRequiredSize isn't used for structures that are value members of other structures\n// because we assume they cannot contain pointers themselves.\nDAWN_UNUSED_FUNC(RenderPassEncoderDrawIndexedGetExtraRequiredSize);\n\nDAWN_DECLARE_UNUSED WireResult RenderPassEncoderDrawIndexedSerialize(\n    const RenderPassEncoderDrawIndexedCmd& record,\n    RenderPassEncoderDrawIndexedTransfer* transfer,\n    SerializeBuffer* buffer, const ObjectIdProvider& provider) {\n    DAWN_UNUSED(buffer);\n\n    transfer->commandId = WireCmd::RenderPassEncoderDrawIndexed;\n\n    WIRE_TRY(provider.GetId(record.self, &transfer->self));\n    transfer->indexCount = record.indexCount;\n    transfer->instanceCount = record.instanceCount;\n    transfer->firstIndex = record.firstIndex;\n    transfer->baseVertex = record.baseVertex;\n    transfer->firstInstance = record.firstInstance;\n\n\n\n\n    return WireResult::Success;\n}\nDAWN_UNUSED_FUNC(RenderPassEncoderDrawIndexedSerialize);\n\nDAWN_DECLARE_UNUSED WireResult RenderPassEncoderDrawIndexedDeserialize(\n    RenderPassEncoderDrawIndexedCmd* record,\n    const volatile RenderPassEncoderDrawIndexedTransfer* transfer,\n    DeserializeBuffer* deserializeBuffer,\n    DeserializeAllocator* allocator, const ObjectIdResolver& resolver) {\n    DAWN_UNUSED(allocator);\n\n    ASSERT(transfer->commandId == WireCmd::RenderPassEncoderDrawIndexed);\n\n    record->selfId = transfer->self;\n\n    WIRE_TRY(resolver.GetFromId(transfer->self, &record->self));\n    static_assert(sizeof(record->indexCount) >= sizeof(transfer->indexCount), \"Deserialize assignment may not narrow.\");\nrecord->indexCount = transfer->indexCount;\n    static_assert(sizeof(record->instanceCount) >= sizeof(transfer->instanceCount), \"Deserialize assignment may not narrow.\");\nrecord->instanceCount = transfer->instanceCount;\n    static_assert(sizeof(record->firstIndex) >= sizeof(transfer->firstIndex), \"Deserialize assignment may not narrow.\");\nrecord->firstIndex = transfer->firstIndex;\n    static_assert(sizeof(record->baseVertex) >= sizeof(transfer->baseVertex), \"Deserialize assignment may not narrow.\");\nrecord->baseVertex = transfer->baseVertex;\n    static_assert(sizeof(record->firstInstance) >= sizeof(transfer->firstInstance), \"Deserialize assignment may not narrow.\");\nrecord->firstInstance = transfer->firstInstance;\n\n\n\n\n\n    return WireResult::Success;\n}\nDAWN_UNUSED_FUNC(RenderPassEncoderDrawIndexedDeserialize);\n\n            \nstruct RenderPassEncoderDrawIndexedIndirectTransfer : CmdHeader {\n    static_assert(1 <= 1,\n                  \"Record must be at most one of is_cmd, extensible, and chained.\");\n    WireCmd commandId;\n\n    ObjectId self;\n    ObjectId indirectBuffer;\n    \nuint64_t indirectOffset;\n\n\n};\n\nstatic_assert(offsetof(RenderPassEncoderDrawIndexedIndirectTransfer, commandSize) == 0);\nstatic_assert(offsetof(RenderPassEncoderDrawIndexedIndirectTransfer, commandId) == sizeof(CmdHeader));\n\n\nDAWN_DECLARE_UNUSED size_t RenderPassEncoderDrawIndexedIndirectGetExtraRequiredSize(const RenderPassEncoderDrawIndexedIndirectCmd& record) {\n    DAWN_UNUSED(record);\n\n    size_t result = 0;\n\n\n\n    {\n    }\n    {\n    }\n    {\n    }\n\n    return result;\n}\n// GetExtraRequiredSize isn't used for structures that are value members of other structures\n// because we assume they cannot contain pointers themselves.\nDAWN_UNUSED_FUNC(RenderPassEncoderDrawIndexedIndirectGetExtraRequiredSize);\n\nDAWN_DECLARE_UNUSED WireResult RenderPassEncoderDrawIndexedIndirectSerialize(\n    const RenderPassEncoderDrawIndexedIndirectCmd& record,\n    RenderPassEncoderDrawIndexedIndirectTransfer* transfer,\n    SerializeBuffer* buffer, const ObjectIdProvider& provider) {\n    DAWN_UNUSED(buffer);\n\n    transfer->commandId = WireCmd::RenderPassEncoderDrawIndexedIndirect;\n\n    WIRE_TRY(provider.GetId(record.self, &transfer->self));\n    WIRE_TRY(provider.GetId(record.indirectBuffer, &transfer->indirectBuffer));\n    transfer->indirectOffset = record.indirectOffset;\n\n\n\n\n    return WireResult::Success;\n}\nDAWN_UNUSED_FUNC(RenderPassEncoderDrawIndexedIndirectSerialize);\n\nDAWN_DECLARE_UNUSED WireResult RenderPassEncoderDrawIndexedIndirectDeserialize(\n    RenderPassEncoderDrawIndexedIndirectCmd* record,\n    const volatile RenderPassEncoderDrawIndexedIndirectTransfer* transfer,\n    DeserializeBuffer* deserializeBuffer,\n    DeserializeAllocator* allocator, const ObjectIdResolver& resolver) {\n    DAWN_UNUSED(allocator);\n\n    ASSERT(transfer->commandId == WireCmd::RenderPassEncoderDrawIndexedIndirect);\n\n    record->selfId = transfer->self;\n\n    WIRE_TRY(resolver.GetFromId(transfer->self, &record->self));\n    WIRE_TRY(resolver.GetFromId(transfer->indirectBuffer, &record->indirectBuffer));\n    static_assert(sizeof(record->indirectOffset) >= sizeof(transfer->indirectOffset), \"Deserialize assignment may not narrow.\");\nrecord->indirectOffset = transfer->indirectOffset;\n\n\n\n\n\n    return WireResult::Success;\n}\nDAWN_UNUSED_FUNC(RenderPassEncoderDrawIndexedIndirectDeserialize);\n\n            \nstruct RenderPassEncoderDrawIndirectTransfer : CmdHeader {\n    static_assert(1 <= 1,\n                  \"Record must be at most one of is_cmd, extensible, and chained.\");\n    WireCmd commandId;\n\n    ObjectId self;\n    ObjectId indirectBuffer;\n    \nuint64_t indirectOffset;\n\n\n};\n\nstatic_assert(offsetof(RenderPassEncoderDrawIndirectTransfer, commandSize) == 0);\nstatic_assert(offsetof(RenderPassEncoderDrawIndirectTransfer, commandId) == sizeof(CmdHeader));\n\n\nDAWN_DECLARE_UNUSED size_t RenderPassEncoderDrawIndirectGetExtraRequiredSize(const RenderPassEncoderDrawIndirectCmd& record) {\n    DAWN_UNUSED(record);\n\n    size_t result = 0;\n\n\n\n    {\n    }\n    {\n    }\n    {\n    }\n\n    return result;\n}\n// GetExtraRequiredSize isn't used for structures that are value members of other structures\n// because we assume they cannot contain pointers themselves.\nDAWN_UNUSED_FUNC(RenderPassEncoderDrawIndirectGetExtraRequiredSize);\n\nDAWN_DECLARE_UNUSED WireResult RenderPassEncoderDrawIndirectSerialize(\n    const RenderPassEncoderDrawIndirectCmd& record,\n    RenderPassEncoderDrawIndirectTransfer* transfer,\n    SerializeBuffer* buffer, const ObjectIdProvider& provider) {\n    DAWN_UNUSED(buffer);\n\n    transfer->commandId = WireCmd::RenderPassEncoderDrawIndirect;\n\n    WIRE_TRY(provider.GetId(record.self, &transfer->self));\n    WIRE_TRY(provider.GetId(record.indirectBuffer, &transfer->indirectBuffer));\n    transfer->indirectOffset = record.indirectOffset;\n\n\n\n\n    return WireResult::Success;\n}\nDAWN_UNUSED_FUNC(RenderPassEncoderDrawIndirectSerialize);\n\nDAWN_DECLARE_UNUSED WireResult RenderPassEncoderDrawIndirectDeserialize(\n    RenderPassEncoderDrawIndirectCmd* record,\n    const volatile RenderPassEncoderDrawIndirectTransfer* transfer,\n    DeserializeBuffer* deserializeBuffer,\n    DeserializeAllocator* allocator, const ObjectIdResolver& resolver) {\n    DAWN_UNUSED(allocator);\n\n    ASSERT(transfer->commandId == WireCmd::RenderPassEncoderDrawIndirect);\n\n    record->selfId = transfer->self;\n\n    WIRE_TRY(resolver.GetFromId(transfer->self, &record->self));\n    WIRE_TRY(resolver.GetFromId(transfer->indirectBuffer, &record->indirectBuffer));\n    static_assert(sizeof(record->indirectOffset) >= sizeof(transfer->indirectOffset), \"Deserialize assignment may not narrow.\");\nrecord->indirectOffset = transfer->indirectOffset;\n\n\n\n\n\n    return WireResult::Success;\n}\nDAWN_UNUSED_FUNC(RenderPassEncoderDrawIndirectDeserialize);\n\n            \nstruct RenderPassEncoderEndTransfer : CmdHeader {\n    static_assert(1 <= 1,\n                  \"Record must be at most one of is_cmd, extensible, and chained.\");\n    WireCmd commandId;\n\n    ObjectId self;\n\n\n};\n\nstatic_assert(offsetof(RenderPassEncoderEndTransfer, commandSize) == 0);\nstatic_assert(offsetof(RenderPassEncoderEndTransfer, commandId) == sizeof(CmdHeader));\n\n\nDAWN_DECLARE_UNUSED size_t RenderPassEncoderEndGetExtraRequiredSize(const RenderPassEncoderEndCmd& record) {\n    DAWN_UNUSED(record);\n\n    size_t result = 0;\n\n\n\n    {\n    }\n\n    return result;\n}\n// GetExtraRequiredSize isn't used for structures that are value members of other structures\n// because we assume they cannot contain pointers themselves.\nDAWN_UNUSED_FUNC(RenderPassEncoderEndGetExtraRequiredSize);\n\nDAWN_DECLARE_UNUSED WireResult RenderPassEncoderEndSerialize(\n    const RenderPassEncoderEndCmd& record,\n    RenderPassEncoderEndTransfer* transfer,\n    SerializeBuffer* buffer, const ObjectIdProvider& provider) {\n    DAWN_UNUSED(buffer);\n\n    transfer->commandId = WireCmd::RenderPassEncoderEnd;\n\n    WIRE_TRY(provider.GetId(record.self, &transfer->self));\n\n\n\n\n    return WireResult::Success;\n}\nDAWN_UNUSED_FUNC(RenderPassEncoderEndSerialize);\n\nDAWN_DECLARE_UNUSED WireResult RenderPassEncoderEndDeserialize(\n    RenderPassEncoderEndCmd* record,\n    const volatile RenderPassEncoderEndTransfer* transfer,\n    DeserializeBuffer* deserializeBuffer,\n    DeserializeAllocator* allocator, const ObjectIdResolver& resolver) {\n    DAWN_UNUSED(allocator);\n\n    ASSERT(transfer->commandId == WireCmd::RenderPassEncoderEnd);\n\n    record->selfId = transfer->self;\n\n    WIRE_TRY(resolver.GetFromId(transfer->self, &record->self));\n\n\n\n\n\n    return WireResult::Success;\n}\nDAWN_UNUSED_FUNC(RenderPassEncoderEndDeserialize);\n\n            \nstruct RenderPassEncoderEndOcclusionQueryTransfer : CmdHeader {\n    static_assert(1 <= 1,\n                  \"Record must be at most one of is_cmd, extensible, and chained.\");\n    WireCmd commandId;\n\n    ObjectId self;\n\n\n};\n\nstatic_assert(offsetof(RenderPassEncoderEndOcclusionQueryTransfer, commandSize) == 0);\nstatic_assert(offsetof(RenderPassEncoderEndOcclusionQueryTransfer, commandId) == sizeof(CmdHeader));\n\n\nDAWN_DECLARE_UNUSED size_t RenderPassEncoderEndOcclusionQueryGetExtraRequiredSize(const RenderPassEncoderEndOcclusionQueryCmd& record) {\n    DAWN_UNUSED(record);\n\n    size_t result = 0;\n\n\n\n    {\n    }\n\n    return result;\n}\n// GetExtraRequiredSize isn't used for structures that are value members of other structures\n// because we assume they cannot contain pointers themselves.\nDAWN_UNUSED_FUNC(RenderPassEncoderEndOcclusionQueryGetExtraRequiredSize);\n\nDAWN_DECLARE_UNUSED WireResult RenderPassEncoderEndOcclusionQuerySerialize(\n    const RenderPassEncoderEndOcclusionQueryCmd& record,\n    RenderPassEncoderEndOcclusionQueryTransfer* transfer,\n    SerializeBuffer* buffer, const ObjectIdProvider& provider) {\n    DAWN_UNUSED(buffer);\n\n    transfer->commandId = WireCmd::RenderPassEncoderEndOcclusionQuery;\n\n    WIRE_TRY(provider.GetId(record.self, &transfer->self));\n\n\n\n\n    return WireResult::Success;\n}\nDAWN_UNUSED_FUNC(RenderPassEncoderEndOcclusionQuerySerialize);\n\nDAWN_DECLARE_UNUSED WireResult RenderPassEncoderEndOcclusionQueryDeserialize(\n    RenderPassEncoderEndOcclusionQueryCmd* record,\n    const volatile RenderPassEncoderEndOcclusionQueryTransfer* transfer,\n    DeserializeBuffer* deserializeBuffer,\n    DeserializeAllocator* allocator, const ObjectIdResolver& resolver) {\n    DAWN_UNUSED(allocator);\n\n    ASSERT(transfer->commandId == WireCmd::RenderPassEncoderEndOcclusionQuery);\n\n    record->selfId = transfer->self;\n\n    WIRE_TRY(resolver.GetFromId(transfer->self, &record->self));\n\n\n\n\n\n    return WireResult::Success;\n}\nDAWN_UNUSED_FUNC(RenderPassEncoderEndOcclusionQueryDeserialize);\n\n            \nstruct RenderPassEncoderEndPassTransfer : CmdHeader {\n    static_assert(1 <= 1,\n                  \"Record must be at most one of is_cmd, extensible, and chained.\");\n    WireCmd commandId;\n\n    ObjectId self;\n\n\n};\n\nstatic_assert(offsetof(RenderPassEncoderEndPassTransfer, commandSize) == 0);\nstatic_assert(offsetof(RenderPassEncoderEndPassTransfer, commandId) == sizeof(CmdHeader));\n\n\nDAWN_DECLARE_UNUSED size_t RenderPassEncoderEndPassGetExtraRequiredSize(const RenderPassEncoderEndPassCmd& record) {\n    DAWN_UNUSED(record);\n\n    size_t result = 0;\n\n\n\n    {\n    }\n\n    return result;\n}\n// GetExtraRequiredSize isn't used for structures that are value members of other structures\n// because we assume they cannot contain pointers themselves.\nDAWN_UNUSED_FUNC(RenderPassEncoderEndPassGetExtraRequiredSize);\n\nDAWN_DECLARE_UNUSED WireResult RenderPassEncoderEndPassSerialize(\n    const RenderPassEncoderEndPassCmd& record,\n    RenderPassEncoderEndPassTransfer* transfer,\n    SerializeBuffer* buffer, const ObjectIdProvider& provider) {\n    DAWN_UNUSED(buffer);\n\n    transfer->commandId = WireCmd::RenderPassEncoderEndPass;\n\n    WIRE_TRY(provider.GetId(record.self, &transfer->self));\n\n\n\n\n    return WireResult::Success;\n}\nDAWN_UNUSED_FUNC(RenderPassEncoderEndPassSerialize);\n\nDAWN_DECLARE_UNUSED WireResult RenderPassEncoderEndPassDeserialize(\n    RenderPassEncoderEndPassCmd* record,\n    const volatile RenderPassEncoderEndPassTransfer* transfer,\n    DeserializeBuffer* deserializeBuffer,\n    DeserializeAllocator* allocator, const ObjectIdResolver& resolver) {\n    DAWN_UNUSED(allocator);\n\n    ASSERT(transfer->commandId == WireCmd::RenderPassEncoderEndPass);\n\n    record->selfId = transfer->self;\n\n    WIRE_TRY(resolver.GetFromId(transfer->self, &record->self));\n\n\n\n\n\n    return WireResult::Success;\n}\nDAWN_UNUSED_FUNC(RenderPassEncoderEndPassDeserialize);\n\n            \nstruct RenderPassEncoderExecuteBundlesTransfer : CmdHeader {\n    static_assert(1 <= 1,\n                  \"Record must be at most one of is_cmd, extensible, and chained.\");\n    WireCmd commandId;\n\n    ObjectId self;\n    \nuint32_t bundlesCount;\n\n\n};\n\nstatic_assert(offsetof(RenderPassEncoderExecuteBundlesTransfer, commandSize) == 0);\nstatic_assert(offsetof(RenderPassEncoderExecuteBundlesTransfer, commandId) == sizeof(CmdHeader));\n\n\nDAWN_DECLARE_UNUSED size_t RenderPassEncoderExecuteBundlesGetExtraRequiredSize(const RenderPassEncoderExecuteBundlesCmd& record) {\n    DAWN_UNUSED(record);\n\n    size_t result = 0;\n\n\n\n    {\n    }\n    {\n    }\n    {\n        \n        auto memberLength = record.bundlesCount;\n        result += memberLength * sizeof(ObjectId);\n    }\n\n    return result;\n}\n// GetExtraRequiredSize isn't used for structures that are value members of other structures\n// because we assume they cannot contain pointers themselves.\nDAWN_UNUSED_FUNC(RenderPassEncoderExecuteBundlesGetExtraRequiredSize);\n\nDAWN_DECLARE_UNUSED WireResult RenderPassEncoderExecuteBundlesSerialize(\n    const RenderPassEncoderExecuteBundlesCmd& record,\n    RenderPassEncoderExecuteBundlesTransfer* transfer,\n    SerializeBuffer* buffer, const ObjectIdProvider& provider) {\n    DAWN_UNUSED(buffer);\n\n    transfer->commandId = WireCmd::RenderPassEncoderExecuteBundles;\n\n    WIRE_TRY(provider.GetId(record.self, &transfer->self));\n    transfer->bundlesCount = record.bundlesCount;\n\n\n\n\n    \n\n    {\n        auto memberLength = record.bundlesCount;\n\n        ObjectId* memberBuffer;\n        WIRE_TRY(buffer->NextN(memberLength, &memberBuffer));\n\n        for (decltype(memberLength) i = 0; i < memberLength; ++i) {\n            WIRE_TRY(provider.GetId(record.bundles[i], &memberBuffer[i]));\n        }\n    }\n    return WireResult::Success;\n}\nDAWN_UNUSED_FUNC(RenderPassEncoderExecuteBundlesSerialize);\n\nDAWN_DECLARE_UNUSED WireResult RenderPassEncoderExecuteBundlesDeserialize(\n    RenderPassEncoderExecuteBundlesCmd* record,\n    const volatile RenderPassEncoderExecuteBundlesTransfer* transfer,\n    DeserializeBuffer* deserializeBuffer,\n    DeserializeAllocator* allocator, const ObjectIdResolver& resolver) {\n    DAWN_UNUSED(allocator);\n\n    ASSERT(transfer->commandId == WireCmd::RenderPassEncoderExecuteBundles);\n\n    record->selfId = transfer->self;\n\n    WIRE_TRY(resolver.GetFromId(transfer->self, &record->self));\n    static_assert(sizeof(record->bundlesCount) >= sizeof(transfer->bundlesCount), \"Deserialize assignment may not narrow.\");\nrecord->bundlesCount = transfer->bundlesCount;\n\n\n\n\n    \n\n    {\n        auto memberLength = record->bundlesCount;\n        const volatile ObjectId* memberBuffer;\n        WIRE_TRY(deserializeBuffer->ReadN(memberLength, &memberBuffer));\n\n        WGPURenderBundle* copiedMembers;\n        WIRE_TRY(GetSpace(allocator, memberLength, &copiedMembers));\n        record->bundles = copiedMembers;\n\n        for (decltype(memberLength) i = 0; i < memberLength; ++i) {\n            WIRE_TRY(resolver.GetFromId(memberBuffer[i], &copiedMembers[i]));\n        }\n    }\n\n    return WireResult::Success;\n}\nDAWN_UNUSED_FUNC(RenderPassEncoderExecuteBundlesDeserialize);\n\n            \nstruct RenderPassEncoderInsertDebugMarkerTransfer : CmdHeader {\n    static_assert(1 <= 1,\n                  \"Record must be at most one of is_cmd, extensible, and chained.\");\n    WireCmd commandId;\n\n    ObjectId self;\n\n    uint64_t markerLabelStrlen;\n\n};\n\nstatic_assert(offsetof(RenderPassEncoderInsertDebugMarkerTransfer, commandSize) == 0);\nstatic_assert(offsetof(RenderPassEncoderInsertDebugMarkerTransfer, commandId) == sizeof(CmdHeader));\n\n\nDAWN_DECLARE_UNUSED size_t RenderPassEncoderInsertDebugMarkerGetExtraRequiredSize(const RenderPassEncoderInsertDebugMarkerCmd& record) {\n    DAWN_UNUSED(record);\n\n    size_t result = 0;\n\n\n\n    {\n    result += std::strlen(record.markerLabel);\n    }\n\n    {\n    }\n\n    return result;\n}\n// GetExtraRequiredSize isn't used for structures that are value members of other structures\n// because we assume they cannot contain pointers themselves.\nDAWN_UNUSED_FUNC(RenderPassEncoderInsertDebugMarkerGetExtraRequiredSize);\n\nDAWN_DECLARE_UNUSED WireResult RenderPassEncoderInsertDebugMarkerSerialize(\n    const RenderPassEncoderInsertDebugMarkerCmd& record,\n    RenderPassEncoderInsertDebugMarkerTransfer* transfer,\n    SerializeBuffer* buffer, const ObjectIdProvider& provider) {\n    DAWN_UNUSED(buffer);\n\n    transfer->commandId = WireCmd::RenderPassEncoderInsertDebugMarker;\n\n    WIRE_TRY(provider.GetId(record.self, &transfer->self));\n\n\n\n\n    {\n        transfer->markerLabelStrlen = std::strlen(record.markerLabel);\n\n        char* stringInBuffer;\n        WIRE_TRY(buffer->NextN(transfer->markerLabelStrlen, &stringInBuffer));\n        memcpy(stringInBuffer, record.markerLabel, transfer->markerLabelStrlen);\n    }\n\n    return WireResult::Success;\n}\nDAWN_UNUSED_FUNC(RenderPassEncoderInsertDebugMarkerSerialize);\n\nDAWN_DECLARE_UNUSED WireResult RenderPassEncoderInsertDebugMarkerDeserialize(\n    RenderPassEncoderInsertDebugMarkerCmd* record,\n    const volatile RenderPassEncoderInsertDebugMarkerTransfer* transfer,\n    DeserializeBuffer* deserializeBuffer,\n    DeserializeAllocator* allocator, const ObjectIdResolver& resolver) {\n    DAWN_UNUSED(allocator);\n\n    ASSERT(transfer->commandId == WireCmd::RenderPassEncoderInsertDebugMarker);\n\n    record->selfId = transfer->self;\n\n    WIRE_TRY(resolver.GetFromId(transfer->self, &record->self));\n\n\n\n\n    {\n        uint64_t stringLength64 = transfer->markerLabelStrlen;\n        if (stringLength64 >= std::numeric_limits<size_t>::max()) {\n            return WireResult::FatalError;\n        }\n        size_t stringLength = static_cast<size_t>(stringLength64);\n\n        const volatile char* stringInBuffer;\n        WIRE_TRY(deserializeBuffer->ReadN(stringLength, &stringInBuffer));\n\n        char* copiedString;\n        WIRE_TRY(GetSpace(allocator, stringLength + 1, &copiedString));\n        memcpy(copiedString, const_cast<const char*>(stringInBuffer), stringLength);\n        copiedString[stringLength] = '\\0';\n        record->markerLabel = copiedString;\n    }\n\n\n    return WireResult::Success;\n}\nDAWN_UNUSED_FUNC(RenderPassEncoderInsertDebugMarkerDeserialize);\n\n            \nstruct RenderPassEncoderPopDebugGroupTransfer : CmdHeader {\n    static_assert(1 <= 1,\n                  \"Record must be at most one of is_cmd, extensible, and chained.\");\n    WireCmd commandId;\n\n    ObjectId self;\n\n\n};\n\nstatic_assert(offsetof(RenderPassEncoderPopDebugGroupTransfer, commandSize) == 0);\nstatic_assert(offsetof(RenderPassEncoderPopDebugGroupTransfer, commandId) == sizeof(CmdHeader));\n\n\nDAWN_DECLARE_UNUSED size_t RenderPassEncoderPopDebugGroupGetExtraRequiredSize(const RenderPassEncoderPopDebugGroupCmd& record) {\n    DAWN_UNUSED(record);\n\n    size_t result = 0;\n\n\n\n    {\n    }\n\n    return result;\n}\n// GetExtraRequiredSize isn't used for structures that are value members of other structures\n// because we assume they cannot contain pointers themselves.\nDAWN_UNUSED_FUNC(RenderPassEncoderPopDebugGroupGetExtraRequiredSize);\n\nDAWN_DECLARE_UNUSED WireResult RenderPassEncoderPopDebugGroupSerialize(\n    const RenderPassEncoderPopDebugGroupCmd& record,\n    RenderPassEncoderPopDebugGroupTransfer* transfer,\n    SerializeBuffer* buffer, const ObjectIdProvider& provider) {\n    DAWN_UNUSED(buffer);\n\n    transfer->commandId = WireCmd::RenderPassEncoderPopDebugGroup;\n\n    WIRE_TRY(provider.GetId(record.self, &transfer->self));\n\n\n\n\n    return WireResult::Success;\n}\nDAWN_UNUSED_FUNC(RenderPassEncoderPopDebugGroupSerialize);\n\nDAWN_DECLARE_UNUSED WireResult RenderPassEncoderPopDebugGroupDeserialize(\n    RenderPassEncoderPopDebugGroupCmd* record,\n    const volatile RenderPassEncoderPopDebugGroupTransfer* transfer,\n    DeserializeBuffer* deserializeBuffer,\n    DeserializeAllocator* allocator, const ObjectIdResolver& resolver) {\n    DAWN_UNUSED(allocator);\n\n    ASSERT(transfer->commandId == WireCmd::RenderPassEncoderPopDebugGroup);\n\n    record->selfId = transfer->self;\n\n    WIRE_TRY(resolver.GetFromId(transfer->self, &record->self));\n\n\n\n\n\n    return WireResult::Success;\n}\nDAWN_UNUSED_FUNC(RenderPassEncoderPopDebugGroupDeserialize);\n\n            \nstruct RenderPassEncoderPushDebugGroupTransfer : CmdHeader {\n    static_assert(1 <= 1,\n                  \"Record must be at most one of is_cmd, extensible, and chained.\");\n    WireCmd commandId;\n\n    ObjectId self;\n\n    uint64_t groupLabelStrlen;\n\n};\n\nstatic_assert(offsetof(RenderPassEncoderPushDebugGroupTransfer, commandSize) == 0);\nstatic_assert(offsetof(RenderPassEncoderPushDebugGroupTransfer, commandId) == sizeof(CmdHeader));\n\n\nDAWN_DECLARE_UNUSED size_t RenderPassEncoderPushDebugGroupGetExtraRequiredSize(const RenderPassEncoderPushDebugGroupCmd& record) {\n    DAWN_UNUSED(record);\n\n    size_t result = 0;\n\n\n\n    {\n    result += std::strlen(record.groupLabel);\n    }\n\n    {\n    }\n\n    return result;\n}\n// GetExtraRequiredSize isn't used for structures that are value members of other structures\n// because we assume they cannot contain pointers themselves.\nDAWN_UNUSED_FUNC(RenderPassEncoderPushDebugGroupGetExtraRequiredSize);\n\nDAWN_DECLARE_UNUSED WireResult RenderPassEncoderPushDebugGroupSerialize(\n    const RenderPassEncoderPushDebugGroupCmd& record,\n    RenderPassEncoderPushDebugGroupTransfer* transfer,\n    SerializeBuffer* buffer, const ObjectIdProvider& provider) {\n    DAWN_UNUSED(buffer);\n\n    transfer->commandId = WireCmd::RenderPassEncoderPushDebugGroup;\n\n    WIRE_TRY(provider.GetId(record.self, &transfer->self));\n\n\n\n\n    {\n        transfer->groupLabelStrlen = std::strlen(record.groupLabel);\n\n        char* stringInBuffer;\n        WIRE_TRY(buffer->NextN(transfer->groupLabelStrlen, &stringInBuffer));\n        memcpy(stringInBuffer, record.groupLabel, transfer->groupLabelStrlen);\n    }\n\n    return WireResult::Success;\n}\nDAWN_UNUSED_FUNC(RenderPassEncoderPushDebugGroupSerialize);\n\nDAWN_DECLARE_UNUSED WireResult RenderPassEncoderPushDebugGroupDeserialize(\n    RenderPassEncoderPushDebugGroupCmd* record,\n    const volatile RenderPassEncoderPushDebugGroupTransfer* transfer,\n    DeserializeBuffer* deserializeBuffer,\n    DeserializeAllocator* allocator, const ObjectIdResolver& resolver) {\n    DAWN_UNUSED(allocator);\n\n    ASSERT(transfer->commandId == WireCmd::RenderPassEncoderPushDebugGroup);\n\n    record->selfId = transfer->self;\n\n    WIRE_TRY(resolver.GetFromId(transfer->self, &record->self));\n\n\n\n\n    {\n        uint64_t stringLength64 = transfer->groupLabelStrlen;\n        if (stringLength64 >= std::numeric_limits<size_t>::max()) {\n            return WireResult::FatalError;\n        }\n        size_t stringLength = static_cast<size_t>(stringLength64);\n\n        const volatile char* stringInBuffer;\n        WIRE_TRY(deserializeBuffer->ReadN(stringLength, &stringInBuffer));\n\n        char* copiedString;\n        WIRE_TRY(GetSpace(allocator, stringLength + 1, &copiedString));\n        memcpy(copiedString, const_cast<const char*>(stringInBuffer), stringLength);\n        copiedString[stringLength] = '\\0';\n        record->groupLabel = copiedString;\n    }\n\n\n    return WireResult::Success;\n}\nDAWN_UNUSED_FUNC(RenderPassEncoderPushDebugGroupDeserialize);\n\n            \nstruct RenderPassEncoderSetBindGroupTransfer : CmdHeader {\n    static_assert(1 <= 1,\n                  \"Record must be at most one of is_cmd, extensible, and chained.\");\n    WireCmd commandId;\n\n    ObjectId self;\n    \nuint32_t groupIndex;\n    ObjectId group;\n    \nuint32_t dynamicOffsetCount;\n\n\n};\n\nstatic_assert(offsetof(RenderPassEncoderSetBindGroupTransfer, commandSize) == 0);\nstatic_assert(offsetof(RenderPassEncoderSetBindGroupTransfer, commandId) == sizeof(CmdHeader));\n\n\nDAWN_DECLARE_UNUSED size_t RenderPassEncoderSetBindGroupGetExtraRequiredSize(const RenderPassEncoderSetBindGroupCmd& record) {\n    DAWN_UNUSED(record);\n\n    size_t result = 0;\n\n\n\n    {\n    }\n    {\n    }\n    {\n    }\n    {\n    }\n    {\n        \n        auto memberLength = record.dynamicOffsetCount;\n        result += memberLength * sizeof(\nuint32_t);\n    }\n\n    return result;\n}\n// GetExtraRequiredSize isn't used for structures that are value members of other structures\n// because we assume they cannot contain pointers themselves.\nDAWN_UNUSED_FUNC(RenderPassEncoderSetBindGroupGetExtraRequiredSize);\n\nDAWN_DECLARE_UNUSED WireResult RenderPassEncoderSetBindGroupSerialize(\n    const RenderPassEncoderSetBindGroupCmd& record,\n    RenderPassEncoderSetBindGroupTransfer* transfer,\n    SerializeBuffer* buffer, const ObjectIdProvider& provider) {\n    DAWN_UNUSED(buffer);\n\n    transfer->commandId = WireCmd::RenderPassEncoderSetBindGroup;\n\n    WIRE_TRY(provider.GetId(record.self, &transfer->self));\n    transfer->groupIndex = record.groupIndex;\n    WIRE_TRY(provider.GetId(record.group, &transfer->group));\n    transfer->dynamicOffsetCount = record.dynamicOffsetCount;\n\n\n\n\n    \n\n    {\n        auto memberLength = record.dynamicOffsetCount;\n\n        \nuint32_t* memberBuffer;\n        WIRE_TRY(buffer->NextN(memberLength, &memberBuffer));\n\n        memcpy(\n            memberBuffer, record.dynamicOffsets,\n            sizeof(\nuint32_t) * memberLength);\n    }\n    return WireResult::Success;\n}\nDAWN_UNUSED_FUNC(RenderPassEncoderSetBindGroupSerialize);\n\nDAWN_DECLARE_UNUSED WireResult RenderPassEncoderSetBindGroupDeserialize(\n    RenderPassEncoderSetBindGroupCmd* record,\n    const volatile RenderPassEncoderSetBindGroupTransfer* transfer,\n    DeserializeBuffer* deserializeBuffer,\n    DeserializeAllocator* allocator, const ObjectIdResolver& resolver) {\n    DAWN_UNUSED(allocator);\n\n    ASSERT(transfer->commandId == WireCmd::RenderPassEncoderSetBindGroup);\n\n    record->selfId = transfer->self;\n\n    WIRE_TRY(resolver.GetFromId(transfer->self, &record->self));\n    static_assert(sizeof(record->groupIndex) >= sizeof(transfer->groupIndex), \"Deserialize assignment may not narrow.\");\nrecord->groupIndex = transfer->groupIndex;\n    WIRE_TRY(resolver.GetFromId(transfer->group, &record->group));\n    static_assert(sizeof(record->dynamicOffsetCount) >= sizeof(transfer->dynamicOffsetCount), \"Deserialize assignment may not narrow.\");\nrecord->dynamicOffsetCount = transfer->dynamicOffsetCount;\n\n\n\n\n    \n\n    {\n        auto memberLength = record->dynamicOffsetCount;\n        const volatile \nuint32_t* memberBuffer;\n        WIRE_TRY(deserializeBuffer->ReadN(memberLength, &memberBuffer));\n\n        uint32_t* copiedMembers;\n        WIRE_TRY(GetSpace(allocator, memberLength, &copiedMembers));\n        record->dynamicOffsets = copiedMembers;\n\n        memcpy(\n            copiedMembers,\n            const_cast<const \nuint32_t*>(memberBuffer),\n           sizeof(\nuint32_t) * memberLength);\n    }\n\n    return WireResult::Success;\n}\nDAWN_UNUSED_FUNC(RenderPassEncoderSetBindGroupDeserialize);\n\n            \nstruct RenderPassEncoderSetBlendConstantTransfer : CmdHeader {\n    static_assert(1 <= 1,\n                  \"Record must be at most one of is_cmd, extensible, and chained.\");\n    WireCmd commandId;\n\n    ObjectId self;\n\n\n};\n\nstatic_assert(offsetof(RenderPassEncoderSetBlendConstantTransfer, commandSize) == 0);\nstatic_assert(offsetof(RenderPassEncoderSetBlendConstantTransfer, commandId) == sizeof(CmdHeader));\n\n\nDAWN_DECLARE_UNUSED size_t RenderPassEncoderSetBlendConstantGetExtraRequiredSize(const RenderPassEncoderSetBlendConstantCmd& record) {\n    DAWN_UNUSED(record);\n\n    size_t result = 0;\n\n\n\n    {\n    }\n    {\n        \n        auto memberLength = 1u;\n        result += memberLength * sizeof(WGPUColorTransfer);\n        for (decltype(memberLength) i = 0; i < memberLength; ++i) {\n            \n            result += WGPUColorGetExtraRequiredSize(record.color[i]);\n        }\n    }\n\n    return result;\n}\n// GetExtraRequiredSize isn't used for structures that are value members of other structures\n// because we assume they cannot contain pointers themselves.\nDAWN_UNUSED_FUNC(RenderPassEncoderSetBlendConstantGetExtraRequiredSize);\n\nDAWN_DECLARE_UNUSED WireResult RenderPassEncoderSetBlendConstantSerialize(\n    const RenderPassEncoderSetBlendConstantCmd& record,\n    RenderPassEncoderSetBlendConstantTransfer* transfer,\n    SerializeBuffer* buffer, const ObjectIdProvider& provider) {\n    DAWN_UNUSED(buffer);\n\n    transfer->commandId = WireCmd::RenderPassEncoderSetBlendConstant;\n\n    WIRE_TRY(provider.GetId(record.self, &transfer->self));\n\n\n\n\n    \n\n    {\n        auto memberLength = 1u;\n\n        WGPUColorTransfer* memberBuffer;\n        WIRE_TRY(buffer->NextN(memberLength, &memberBuffer));\n\n        memcpy(\n            memberBuffer, record.color,\n            sizeof(WGPUColorTransfer) * memberLength);\n    }\n    return WireResult::Success;\n}\nDAWN_UNUSED_FUNC(RenderPassEncoderSetBlendConstantSerialize);\n\nDAWN_DECLARE_UNUSED WireResult RenderPassEncoderSetBlendConstantDeserialize(\n    RenderPassEncoderSetBlendConstantCmd* record,\n    const volatile RenderPassEncoderSetBlendConstantTransfer* transfer,\n    DeserializeBuffer* deserializeBuffer,\n    DeserializeAllocator* allocator, const ObjectIdResolver& resolver) {\n    DAWN_UNUSED(allocator);\n\n    ASSERT(transfer->commandId == WireCmd::RenderPassEncoderSetBlendConstant);\n\n    record->selfId = transfer->self;\n\n    WIRE_TRY(resolver.GetFromId(transfer->self, &record->self));\n\n\n\n\n    \n\n    {\n        auto memberLength = 1u;\n        const volatile WGPUColorTransfer* memberBuffer;\n        WIRE_TRY(deserializeBuffer->ReadN(memberLength, &memberBuffer));\n\n        WGPUColor* copiedMembers;\n        WIRE_TRY(GetSpace(allocator, memberLength, &copiedMembers));\n        record->color = copiedMembers;\n\n        memcpy(\n            copiedMembers,\n            const_cast<const WGPUColorTransfer*>(memberBuffer),\n           sizeof(WGPUColorTransfer) * memberLength);\n    }\n\n    return WireResult::Success;\n}\nDAWN_UNUSED_FUNC(RenderPassEncoderSetBlendConstantDeserialize);\n\n            \nstruct RenderPassEncoderSetIndexBufferTransfer : CmdHeader {\n    static_assert(1 <= 1,\n                  \"Record must be at most one of is_cmd, extensible, and chained.\");\n    WireCmd commandId;\n\n    ObjectId self;\n    ObjectId buffer;\n    \nWGPUIndexFormat format;\n    \nuint64_t offset;\n    \nuint64_t size;\n\n\n};\n\nstatic_assert(offsetof(RenderPassEncoderSetIndexBufferTransfer, commandSize) == 0);\nstatic_assert(offsetof(RenderPassEncoderSetIndexBufferTransfer, commandId) == sizeof(CmdHeader));\n\n\nDAWN_DECLARE_UNUSED size_t RenderPassEncoderSetIndexBufferGetExtraRequiredSize(const RenderPassEncoderSetIndexBufferCmd& record) {\n    DAWN_UNUSED(record);\n\n    size_t result = 0;\n\n\n\n    {\n    }\n    {\n    }\n    {\n    }\n    {\n    }\n    {\n    }\n\n    return result;\n}\n// GetExtraRequiredSize isn't used for structures that are value members of other structures\n// because we assume they cannot contain pointers themselves.\nDAWN_UNUSED_FUNC(RenderPassEncoderSetIndexBufferGetExtraRequiredSize);\n\nDAWN_DECLARE_UNUSED WireResult RenderPassEncoderSetIndexBufferSerialize(\n    const RenderPassEncoderSetIndexBufferCmd& record,\n    RenderPassEncoderSetIndexBufferTransfer* transfer,\n    SerializeBuffer* buffer, const ObjectIdProvider& provider) {\n    DAWN_UNUSED(buffer);\n\n    transfer->commandId = WireCmd::RenderPassEncoderSetIndexBuffer;\n\n    WIRE_TRY(provider.GetId(record.self, &transfer->self));\n    WIRE_TRY(provider.GetId(record.buffer, &transfer->buffer));\n    transfer->format = record.format;\n    transfer->offset = record.offset;\n    transfer->size = record.size;\n\n\n\n\n    return WireResult::Success;\n}\nDAWN_UNUSED_FUNC(RenderPassEncoderSetIndexBufferSerialize);\n\nDAWN_DECLARE_UNUSED WireResult RenderPassEncoderSetIndexBufferDeserialize(\n    RenderPassEncoderSetIndexBufferCmd* record,\n    const volatile RenderPassEncoderSetIndexBufferTransfer* transfer,\n    DeserializeBuffer* deserializeBuffer,\n    DeserializeAllocator* allocator, const ObjectIdResolver& resolver) {\n    DAWN_UNUSED(allocator);\n\n    ASSERT(transfer->commandId == WireCmd::RenderPassEncoderSetIndexBuffer);\n\n    record->selfId = transfer->self;\n\n    WIRE_TRY(resolver.GetFromId(transfer->self, &record->self));\n    WIRE_TRY(resolver.GetFromId(transfer->buffer, &record->buffer));\n    static_assert(sizeof(record->format) >= sizeof(transfer->format), \"Deserialize assignment may not narrow.\");\nrecord->format = transfer->format;\n    static_assert(sizeof(record->offset) >= sizeof(transfer->offset), \"Deserialize assignment may not narrow.\");\nrecord->offset = transfer->offset;\n    static_assert(sizeof(record->size) >= sizeof(transfer->size), \"Deserialize assignment may not narrow.\");\nrecord->size = transfer->size;\n\n\n\n\n\n    return WireResult::Success;\n}\nDAWN_UNUSED_FUNC(RenderPassEncoderSetIndexBufferDeserialize);\n\n            \nstruct RenderPassEncoderSetLabelTransfer : CmdHeader {\n    static_assert(1 <= 1,\n                  \"Record must be at most one of is_cmd, extensible, and chained.\");\n    WireCmd commandId;\n\n    ObjectId self;\n\n    uint64_t labelStrlen;\n\n};\n\nstatic_assert(offsetof(RenderPassEncoderSetLabelTransfer, commandSize) == 0);\nstatic_assert(offsetof(RenderPassEncoderSetLabelTransfer, commandId) == sizeof(CmdHeader));\n\n\nDAWN_DECLARE_UNUSED size_t RenderPassEncoderSetLabelGetExtraRequiredSize(const RenderPassEncoderSetLabelCmd& record) {\n    DAWN_UNUSED(record);\n\n    size_t result = 0;\n\n\n\n    {\n    result += std::strlen(record.label);\n    }\n\n    {\n    }\n\n    return result;\n}\n// GetExtraRequiredSize isn't used for structures that are value members of other structures\n// because we assume they cannot contain pointers themselves.\nDAWN_UNUSED_FUNC(RenderPassEncoderSetLabelGetExtraRequiredSize);\n\nDAWN_DECLARE_UNUSED WireResult RenderPassEncoderSetLabelSerialize(\n    const RenderPassEncoderSetLabelCmd& record,\n    RenderPassEncoderSetLabelTransfer* transfer,\n    SerializeBuffer* buffer, const ObjectIdProvider& provider) {\n    DAWN_UNUSED(buffer);\n\n    transfer->commandId = WireCmd::RenderPassEncoderSetLabel;\n\n    WIRE_TRY(provider.GetId(record.self, &transfer->self));\n\n\n\n\n    {\n        transfer->labelStrlen = std::strlen(record.label);\n\n        char* stringInBuffer;\n        WIRE_TRY(buffer->NextN(transfer->labelStrlen, &stringInBuffer));\n        memcpy(stringInBuffer, record.label, transfer->labelStrlen);\n    }\n\n    return WireResult::Success;\n}\nDAWN_UNUSED_FUNC(RenderPassEncoderSetLabelSerialize);\n\nDAWN_DECLARE_UNUSED WireResult RenderPassEncoderSetLabelDeserialize(\n    RenderPassEncoderSetLabelCmd* record,\n    const volatile RenderPassEncoderSetLabelTransfer* transfer,\n    DeserializeBuffer* deserializeBuffer,\n    DeserializeAllocator* allocator, const ObjectIdResolver& resolver) {\n    DAWN_UNUSED(allocator);\n\n    ASSERT(transfer->commandId == WireCmd::RenderPassEncoderSetLabel);\n\n    record->selfId = transfer->self;\n\n    WIRE_TRY(resolver.GetFromId(transfer->self, &record->self));\n\n\n\n\n    {\n        uint64_t stringLength64 = transfer->labelStrlen;\n        if (stringLength64 >= std::numeric_limits<size_t>::max()) {\n            return WireResult::FatalError;\n        }\n        size_t stringLength = static_cast<size_t>(stringLength64);\n\n        const volatile char* stringInBuffer;\n        WIRE_TRY(deserializeBuffer->ReadN(stringLength, &stringInBuffer));\n\n        char* copiedString;\n        WIRE_TRY(GetSpace(allocator, stringLength + 1, &copiedString));\n        memcpy(copiedString, const_cast<const char*>(stringInBuffer), stringLength);\n        copiedString[stringLength] = '\\0';\n        record->label = copiedString;\n    }\n\n\n    return WireResult::Success;\n}\nDAWN_UNUSED_FUNC(RenderPassEncoderSetLabelDeserialize);\n\n            \nstruct RenderPassEncoderSetPipelineTransfer : CmdHeader {\n    static_assert(1 <= 1,\n                  \"Record must be at most one of is_cmd, extensible, and chained.\");\n    WireCmd commandId;\n\n    ObjectId self;\n    ObjectId pipeline;\n\n\n};\n\nstatic_assert(offsetof(RenderPassEncoderSetPipelineTransfer, commandSize) == 0);\nstatic_assert(offsetof(RenderPassEncoderSetPipelineTransfer, commandId) == sizeof(CmdHeader));\n\n\nDAWN_DECLARE_UNUSED size_t RenderPassEncoderSetPipelineGetExtraRequiredSize(const RenderPassEncoderSetPipelineCmd& record) {\n    DAWN_UNUSED(record);\n\n    size_t result = 0;\n\n\n\n    {\n    }\n    {\n    }\n\n    return result;\n}\n// GetExtraRequiredSize isn't used for structures that are value members of other structures\n// because we assume they cannot contain pointers themselves.\nDAWN_UNUSED_FUNC(RenderPassEncoderSetPipelineGetExtraRequiredSize);\n\nDAWN_DECLARE_UNUSED WireResult RenderPassEncoderSetPipelineSerialize(\n    const RenderPassEncoderSetPipelineCmd& record,\n    RenderPassEncoderSetPipelineTransfer* transfer,\n    SerializeBuffer* buffer, const ObjectIdProvider& provider) {\n    DAWN_UNUSED(buffer);\n\n    transfer->commandId = WireCmd::RenderPassEncoderSetPipeline;\n\n    WIRE_TRY(provider.GetId(record.self, &transfer->self));\n    WIRE_TRY(provider.GetId(record.pipeline, &transfer->pipeline));\n\n\n\n\n    return WireResult::Success;\n}\nDAWN_UNUSED_FUNC(RenderPassEncoderSetPipelineSerialize);\n\nDAWN_DECLARE_UNUSED WireResult RenderPassEncoderSetPipelineDeserialize(\n    RenderPassEncoderSetPipelineCmd* record,\n    const volatile RenderPassEncoderSetPipelineTransfer* transfer,\n    DeserializeBuffer* deserializeBuffer,\n    DeserializeAllocator* allocator, const ObjectIdResolver& resolver) {\n    DAWN_UNUSED(allocator);\n\n    ASSERT(transfer->commandId == WireCmd::RenderPassEncoderSetPipeline);\n\n    record->selfId = transfer->self;\n\n    WIRE_TRY(resolver.GetFromId(transfer->self, &record->self));\n    WIRE_TRY(resolver.GetFromId(transfer->pipeline, &record->pipeline));\n\n\n\n\n\n    return WireResult::Success;\n}\nDAWN_UNUSED_FUNC(RenderPassEncoderSetPipelineDeserialize);\n\n            \nstruct RenderPassEncoderSetScissorRectTransfer : CmdHeader {\n    static_assert(1 <= 1,\n                  \"Record must be at most one of is_cmd, extensible, and chained.\");\n    WireCmd commandId;\n\n    ObjectId self;\n    \nuint32_t x;\n    \nuint32_t y;\n    \nuint32_t width;\n    \nuint32_t height;\n\n\n};\n\nstatic_assert(offsetof(RenderPassEncoderSetScissorRectTransfer, commandSize) == 0);\nstatic_assert(offsetof(RenderPassEncoderSetScissorRectTransfer, commandId) == sizeof(CmdHeader));\n\n\nDAWN_DECLARE_UNUSED size_t RenderPassEncoderSetScissorRectGetExtraRequiredSize(const RenderPassEncoderSetScissorRectCmd& record) {\n    DAWN_UNUSED(record);\n\n    size_t result = 0;\n\n\n\n    {\n    }\n    {\n    }\n    {\n    }\n    {\n    }\n    {\n    }\n\n    return result;\n}\n// GetExtraRequiredSize isn't used for structures that are value members of other structures\n// because we assume they cannot contain pointers themselves.\nDAWN_UNUSED_FUNC(RenderPassEncoderSetScissorRectGetExtraRequiredSize);\n\nDAWN_DECLARE_UNUSED WireResult RenderPassEncoderSetScissorRectSerialize(\n    const RenderPassEncoderSetScissorRectCmd& record,\n    RenderPassEncoderSetScissorRectTransfer* transfer,\n    SerializeBuffer* buffer, const ObjectIdProvider& provider) {\n    DAWN_UNUSED(buffer);\n\n    transfer->commandId = WireCmd::RenderPassEncoderSetScissorRect;\n\n    WIRE_TRY(provider.GetId(record.self, &transfer->self));\n    transfer->x = record.x;\n    transfer->y = record.y;\n    transfer->width = record.width;\n    transfer->height = record.height;\n\n\n\n\n    return WireResult::Success;\n}\nDAWN_UNUSED_FUNC(RenderPassEncoderSetScissorRectSerialize);\n\nDAWN_DECLARE_UNUSED WireResult RenderPassEncoderSetScissorRectDeserialize(\n    RenderPassEncoderSetScissorRectCmd* record,\n    const volatile RenderPassEncoderSetScissorRectTransfer* transfer,\n    DeserializeBuffer* deserializeBuffer,\n    DeserializeAllocator* allocator, const ObjectIdResolver& resolver) {\n    DAWN_UNUSED(allocator);\n\n    ASSERT(transfer->commandId == WireCmd::RenderPassEncoderSetScissorRect);\n\n    record->selfId = transfer->self;\n\n    WIRE_TRY(resolver.GetFromId(transfer->self, &record->self));\n    static_assert(sizeof(record->x) >= sizeof(transfer->x), \"Deserialize assignment may not narrow.\");\nrecord->x = transfer->x;\n    static_assert(sizeof(record->y) >= sizeof(transfer->y), \"Deserialize assignment may not narrow.\");\nrecord->y = transfer->y;\n    static_assert(sizeof(record->width) >= sizeof(transfer->width), \"Deserialize assignment may not narrow.\");\nrecord->width = transfer->width;\n    static_assert(sizeof(record->height) >= sizeof(transfer->height), \"Deserialize assignment may not narrow.\");\nrecord->height = transfer->height;\n\n\n\n\n\n    return WireResult::Success;\n}\nDAWN_UNUSED_FUNC(RenderPassEncoderSetScissorRectDeserialize);\n\n            \nstruct RenderPassEncoderSetStencilReferenceTransfer : CmdHeader {\n    static_assert(1 <= 1,\n                  \"Record must be at most one of is_cmd, extensible, and chained.\");\n    WireCmd commandId;\n\n    ObjectId self;\n    \nuint32_t reference;\n\n\n};\n\nstatic_assert(offsetof(RenderPassEncoderSetStencilReferenceTransfer, commandSize) == 0);\nstatic_assert(offsetof(RenderPassEncoderSetStencilReferenceTransfer, commandId) == sizeof(CmdHeader));\n\n\nDAWN_DECLARE_UNUSED size_t RenderPassEncoderSetStencilReferenceGetExtraRequiredSize(const RenderPassEncoderSetStencilReferenceCmd& record) {\n    DAWN_UNUSED(record);\n\n    size_t result = 0;\n\n\n\n    {\n    }\n    {\n    }\n\n    return result;\n}\n// GetExtraRequiredSize isn't used for structures that are value members of other structures\n// because we assume they cannot contain pointers themselves.\nDAWN_UNUSED_FUNC(RenderPassEncoderSetStencilReferenceGetExtraRequiredSize);\n\nDAWN_DECLARE_UNUSED WireResult RenderPassEncoderSetStencilReferenceSerialize(\n    const RenderPassEncoderSetStencilReferenceCmd& record,\n    RenderPassEncoderSetStencilReferenceTransfer* transfer,\n    SerializeBuffer* buffer, const ObjectIdProvider& provider) {\n    DAWN_UNUSED(buffer);\n\n    transfer->commandId = WireCmd::RenderPassEncoderSetStencilReference;\n\n    WIRE_TRY(provider.GetId(record.self, &transfer->self));\n    transfer->reference = record.reference;\n\n\n\n\n    return WireResult::Success;\n}\nDAWN_UNUSED_FUNC(RenderPassEncoderSetStencilReferenceSerialize);\n\nDAWN_DECLARE_UNUSED WireResult RenderPassEncoderSetStencilReferenceDeserialize(\n    RenderPassEncoderSetStencilReferenceCmd* record,\n    const volatile RenderPassEncoderSetStencilReferenceTransfer* transfer,\n    DeserializeBuffer* deserializeBuffer,\n    DeserializeAllocator* allocator, const ObjectIdResolver& resolver) {\n    DAWN_UNUSED(allocator);\n\n    ASSERT(transfer->commandId == WireCmd::RenderPassEncoderSetStencilReference);\n\n    record->selfId = transfer->self;\n\n    WIRE_TRY(resolver.GetFromId(transfer->self, &record->self));\n    static_assert(sizeof(record->reference) >= sizeof(transfer->reference), \"Deserialize assignment may not narrow.\");\nrecord->reference = transfer->reference;\n\n\n\n\n\n    return WireResult::Success;\n}\nDAWN_UNUSED_FUNC(RenderPassEncoderSetStencilReferenceDeserialize);\n\n            \nstruct RenderPassEncoderSetVertexBufferTransfer : CmdHeader {\n    static_assert(1 <= 1,\n                  \"Record must be at most one of is_cmd, extensible, and chained.\");\n    WireCmd commandId;\n\n    ObjectId self;\n    \nuint32_t slot;\n    ObjectId buffer;\n    \nuint64_t offset;\n    \nuint64_t size;\n\n\n};\n\nstatic_assert(offsetof(RenderPassEncoderSetVertexBufferTransfer, commandSize) == 0);\nstatic_assert(offsetof(RenderPassEncoderSetVertexBufferTransfer, commandId) == sizeof(CmdHeader));\n\n\nDAWN_DECLARE_UNUSED size_t RenderPassEncoderSetVertexBufferGetExtraRequiredSize(const RenderPassEncoderSetVertexBufferCmd& record) {\n    DAWN_UNUSED(record);\n\n    size_t result = 0;\n\n\n\n    {\n    }\n    {\n    }\n    {\n    }\n    {\n    }\n    {\n    }\n\n    return result;\n}\n// GetExtraRequiredSize isn't used for structures that are value members of other structures\n// because we assume they cannot contain pointers themselves.\nDAWN_UNUSED_FUNC(RenderPassEncoderSetVertexBufferGetExtraRequiredSize);\n\nDAWN_DECLARE_UNUSED WireResult RenderPassEncoderSetVertexBufferSerialize(\n    const RenderPassEncoderSetVertexBufferCmd& record,\n    RenderPassEncoderSetVertexBufferTransfer* transfer,\n    SerializeBuffer* buffer, const ObjectIdProvider& provider) {\n    DAWN_UNUSED(buffer);\n\n    transfer->commandId = WireCmd::RenderPassEncoderSetVertexBuffer;\n\n    WIRE_TRY(provider.GetId(record.self, &transfer->self));\n    transfer->slot = record.slot;\n    WIRE_TRY(provider.GetId(record.buffer, &transfer->buffer));\n    transfer->offset = record.offset;\n    transfer->size = record.size;\n\n\n\n\n    return WireResult::Success;\n}\nDAWN_UNUSED_FUNC(RenderPassEncoderSetVertexBufferSerialize);\n\nDAWN_DECLARE_UNUSED WireResult RenderPassEncoderSetVertexBufferDeserialize(\n    RenderPassEncoderSetVertexBufferCmd* record,\n    const volatile RenderPassEncoderSetVertexBufferTransfer* transfer,\n    DeserializeBuffer* deserializeBuffer,\n    DeserializeAllocator* allocator, const ObjectIdResolver& resolver) {\n    DAWN_UNUSED(allocator);\n\n    ASSERT(transfer->commandId == WireCmd::RenderPassEncoderSetVertexBuffer);\n\n    record->selfId = transfer->self;\n\n    WIRE_TRY(resolver.GetFromId(transfer->self, &record->self));\n    static_assert(sizeof(record->slot) >= sizeof(transfer->slot), \"Deserialize assignment may not narrow.\");\nrecord->slot = transfer->slot;\n    WIRE_TRY(resolver.GetFromId(transfer->buffer, &record->buffer));\n    static_assert(sizeof(record->offset) >= sizeof(transfer->offset), \"Deserialize assignment may not narrow.\");\nrecord->offset = transfer->offset;\n    static_assert(sizeof(record->size) >= sizeof(transfer->size), \"Deserialize assignment may not narrow.\");\nrecord->size = transfer->size;\n\n\n\n\n\n    return WireResult::Success;\n}\nDAWN_UNUSED_FUNC(RenderPassEncoderSetVertexBufferDeserialize);\n\n            \nstruct RenderPassEncoderSetViewportTransfer : CmdHeader {\n    static_assert(1 <= 1,\n                  \"Record must be at most one of is_cmd, extensible, and chained.\");\n    WireCmd commandId;\n\n    ObjectId self;\n    \nfloat x;\n    \nfloat y;\n    \nfloat width;\n    \nfloat height;\n    \nfloat minDepth;\n    \nfloat maxDepth;\n\n\n};\n\nstatic_assert(offsetof(RenderPassEncoderSetViewportTransfer, commandSize) == 0);\nstatic_assert(offsetof(RenderPassEncoderSetViewportTransfer, commandId) == sizeof(CmdHeader));\n\n\nDAWN_DECLARE_UNUSED size_t RenderPassEncoderSetViewportGetExtraRequiredSize(const RenderPassEncoderSetViewportCmd& record) {\n    DAWN_UNUSED(record);\n\n    size_t result = 0;\n\n\n\n    {\n    }\n    {\n    }\n    {\n    }\n    {\n    }\n    {\n    }\n    {\n    }\n    {\n    }\n\n    return result;\n}\n// GetExtraRequiredSize isn't used for structures that are value members of other structures\n// because we assume they cannot contain pointers themselves.\nDAWN_UNUSED_FUNC(RenderPassEncoderSetViewportGetExtraRequiredSize);\n\nDAWN_DECLARE_UNUSED WireResult RenderPassEncoderSetViewportSerialize(\n    const RenderPassEncoderSetViewportCmd& record,\n    RenderPassEncoderSetViewportTransfer* transfer,\n    SerializeBuffer* buffer, const ObjectIdProvider& provider) {\n    DAWN_UNUSED(buffer);\n\n    transfer->commandId = WireCmd::RenderPassEncoderSetViewport;\n\n    WIRE_TRY(provider.GetId(record.self, &transfer->self));\n    transfer->x = record.x;\n    transfer->y = record.y;\n    transfer->width = record.width;\n    transfer->height = record.height;\n    transfer->minDepth = record.minDepth;\n    transfer->maxDepth = record.maxDepth;\n\n\n\n\n    return WireResult::Success;\n}\nDAWN_UNUSED_FUNC(RenderPassEncoderSetViewportSerialize);\n\nDAWN_DECLARE_UNUSED WireResult RenderPassEncoderSetViewportDeserialize(\n    RenderPassEncoderSetViewportCmd* record,\n    const volatile RenderPassEncoderSetViewportTransfer* transfer,\n    DeserializeBuffer* deserializeBuffer,\n    DeserializeAllocator* allocator, const ObjectIdResolver& resolver) {\n    DAWN_UNUSED(allocator);\n\n    ASSERT(transfer->commandId == WireCmd::RenderPassEncoderSetViewport);\n\n    record->selfId = transfer->self;\n\n    WIRE_TRY(resolver.GetFromId(transfer->self, &record->self));\n    static_assert(sizeof(record->x) >= sizeof(transfer->x), \"Deserialize assignment may not narrow.\");\nrecord->x = transfer->x;\n    static_assert(sizeof(record->y) >= sizeof(transfer->y), \"Deserialize assignment may not narrow.\");\nrecord->y = transfer->y;\n    static_assert(sizeof(record->width) >= sizeof(transfer->width), \"Deserialize assignment may not narrow.\");\nrecord->width = transfer->width;\n    static_assert(sizeof(record->height) >= sizeof(transfer->height), \"Deserialize assignment may not narrow.\");\nrecord->height = transfer->height;\n    static_assert(sizeof(record->minDepth) >= sizeof(transfer->minDepth), \"Deserialize assignment may not narrow.\");\nrecord->minDepth = transfer->minDepth;\n    static_assert(sizeof(record->maxDepth) >= sizeof(transfer->maxDepth), \"Deserialize assignment may not narrow.\");\nrecord->maxDepth = transfer->maxDepth;\n\n\n\n\n\n    return WireResult::Success;\n}\nDAWN_UNUSED_FUNC(RenderPassEncoderSetViewportDeserialize);\n\n            \nstruct RenderPassEncoderWriteTimestampTransfer : CmdHeader {\n    static_assert(1 <= 1,\n                  \"Record must be at most one of is_cmd, extensible, and chained.\");\n    WireCmd commandId;\n\n    ObjectId self;\n    ObjectId querySet;\n    \nuint32_t queryIndex;\n\n\n};\n\nstatic_assert(offsetof(RenderPassEncoderWriteTimestampTransfer, commandSize) == 0);\nstatic_assert(offsetof(RenderPassEncoderWriteTimestampTransfer, commandId) == sizeof(CmdHeader));\n\n\nDAWN_DECLARE_UNUSED size_t RenderPassEncoderWriteTimestampGetExtraRequiredSize(const RenderPassEncoderWriteTimestampCmd& record) {\n    DAWN_UNUSED(record);\n\n    size_t result = 0;\n\n\n\n    {\n    }\n    {\n    }\n    {\n    }\n\n    return result;\n}\n// GetExtraRequiredSize isn't used for structures that are value members of other structures\n// because we assume they cannot contain pointers themselves.\nDAWN_UNUSED_FUNC(RenderPassEncoderWriteTimestampGetExtraRequiredSize);\n\nDAWN_DECLARE_UNUSED WireResult RenderPassEncoderWriteTimestampSerialize(\n    const RenderPassEncoderWriteTimestampCmd& record,\n    RenderPassEncoderWriteTimestampTransfer* transfer,\n    SerializeBuffer* buffer, const ObjectIdProvider& provider) {\n    DAWN_UNUSED(buffer);\n\n    transfer->commandId = WireCmd::RenderPassEncoderWriteTimestamp;\n\n    WIRE_TRY(provider.GetId(record.self, &transfer->self));\n    WIRE_TRY(provider.GetId(record.querySet, &transfer->querySet));\n    transfer->queryIndex = record.queryIndex;\n\n\n\n\n    return WireResult::Success;\n}\nDAWN_UNUSED_FUNC(RenderPassEncoderWriteTimestampSerialize);\n\nDAWN_DECLARE_UNUSED WireResult RenderPassEncoderWriteTimestampDeserialize(\n    RenderPassEncoderWriteTimestampCmd* record,\n    const volatile RenderPassEncoderWriteTimestampTransfer* transfer,\n    DeserializeBuffer* deserializeBuffer,\n    DeserializeAllocator* allocator, const ObjectIdResolver& resolver) {\n    DAWN_UNUSED(allocator);\n\n    ASSERT(transfer->commandId == WireCmd::RenderPassEncoderWriteTimestamp);\n\n    record->selfId = transfer->self;\n\n    WIRE_TRY(resolver.GetFromId(transfer->self, &record->self));\n    WIRE_TRY(resolver.GetFromId(transfer->querySet, &record->querySet));\n    static_assert(sizeof(record->queryIndex) >= sizeof(transfer->queryIndex), \"Deserialize assignment may not narrow.\");\nrecord->queryIndex = transfer->queryIndex;\n\n\n\n\n\n    return WireResult::Success;\n}\nDAWN_UNUSED_FUNC(RenderPassEncoderWriteTimestampDeserialize);\n\n            \nstruct RenderPipelineGetBindGroupLayoutTransfer : CmdHeader {\n    static_assert(1 <= 1,\n                  \"Record must be at most one of is_cmd, extensible, and chained.\");\n    WireCmd commandId;\n\n    ObjectId self;\n    \nuint32_t groupIndex;\n    \nObjectHandle result;\n\n\n};\n\nstatic_assert(offsetof(RenderPipelineGetBindGroupLayoutTransfer, commandSize) == 0);\nstatic_assert(offsetof(RenderPipelineGetBindGroupLayoutTransfer, commandId) == sizeof(CmdHeader));\n\n\nDAWN_DECLARE_UNUSED size_t RenderPipelineGetBindGroupLayoutGetExtraRequiredSize(const RenderPipelineGetBindGroupLayoutCmd& record) {\n    DAWN_UNUSED(record);\n\n    size_t result = 0;\n\n\n\n    {\n    }\n    {\n    }\n    {\n    }\n\n    return result;\n}\n// GetExtraRequiredSize isn't used for structures that are value members of other structures\n// because we assume they cannot contain pointers themselves.\nDAWN_UNUSED_FUNC(RenderPipelineGetBindGroupLayoutGetExtraRequiredSize);\n\nDAWN_DECLARE_UNUSED WireResult RenderPipelineGetBindGroupLayoutSerialize(\n    const RenderPipelineGetBindGroupLayoutCmd& record,\n    RenderPipelineGetBindGroupLayoutTransfer* transfer,\n    SerializeBuffer* buffer, const ObjectIdProvider& provider) {\n    DAWN_UNUSED(buffer);\n\n    transfer->commandId = WireCmd::RenderPipelineGetBindGroupLayout;\n\n    WIRE_TRY(provider.GetId(record.self, &transfer->self));\n    transfer->groupIndex = record.groupIndex;\n    transfer->result = record.result;\n\n\n\n\n    return WireResult::Success;\n}\nDAWN_UNUSED_FUNC(RenderPipelineGetBindGroupLayoutSerialize);\n\nDAWN_DECLARE_UNUSED WireResult RenderPipelineGetBindGroupLayoutDeserialize(\n    RenderPipelineGetBindGroupLayoutCmd* record,\n    const volatile RenderPipelineGetBindGroupLayoutTransfer* transfer,\n    DeserializeBuffer* deserializeBuffer,\n    DeserializeAllocator* allocator, const ObjectIdResolver& resolver) {\n    DAWN_UNUSED(allocator);\n\n    ASSERT(transfer->commandId == WireCmd::RenderPipelineGetBindGroupLayout);\n\n    record->selfId = transfer->self;\n\n    WIRE_TRY(resolver.GetFromId(transfer->self, &record->self));\n    static_assert(sizeof(record->groupIndex) >= sizeof(transfer->groupIndex), \"Deserialize assignment may not narrow.\");\nrecord->groupIndex = transfer->groupIndex;\n    static_assert(sizeof(record->result) >= sizeof(transfer->result), \"Deserialize assignment may not narrow.\");\nrecord->result = transfer->result;\n\n\n\n\n\n    return WireResult::Success;\n}\nDAWN_UNUSED_FUNC(RenderPipelineGetBindGroupLayoutDeserialize);\n\n            \nstruct RenderPipelineSetLabelTransfer : CmdHeader {\n    static_assert(1 <= 1,\n                  \"Record must be at most one of is_cmd, extensible, and chained.\");\n    WireCmd commandId;\n\n    ObjectId self;\n\n    uint64_t labelStrlen;\n\n};\n\nstatic_assert(offsetof(RenderPipelineSetLabelTransfer, commandSize) == 0);\nstatic_assert(offsetof(RenderPipelineSetLabelTransfer, commandId) == sizeof(CmdHeader));\n\n\nDAWN_DECLARE_UNUSED size_t RenderPipelineSetLabelGetExtraRequiredSize(const RenderPipelineSetLabelCmd& record) {\n    DAWN_UNUSED(record);\n\n    size_t result = 0;\n\n\n\n    {\n    result += std::strlen(record.label);\n    }\n\n    {\n    }\n\n    return result;\n}\n// GetExtraRequiredSize isn't used for structures that are value members of other structures\n// because we assume they cannot contain pointers themselves.\nDAWN_UNUSED_FUNC(RenderPipelineSetLabelGetExtraRequiredSize);\n\nDAWN_DECLARE_UNUSED WireResult RenderPipelineSetLabelSerialize(\n    const RenderPipelineSetLabelCmd& record,\n    RenderPipelineSetLabelTransfer* transfer,\n    SerializeBuffer* buffer, const ObjectIdProvider& provider) {\n    DAWN_UNUSED(buffer);\n\n    transfer->commandId = WireCmd::RenderPipelineSetLabel;\n\n    WIRE_TRY(provider.GetId(record.self, &transfer->self));\n\n\n\n\n    {\n        transfer->labelStrlen = std::strlen(record.label);\n\n        char* stringInBuffer;\n        WIRE_TRY(buffer->NextN(transfer->labelStrlen, &stringInBuffer));\n        memcpy(stringInBuffer, record.label, transfer->labelStrlen);\n    }\n\n    return WireResult::Success;\n}\nDAWN_UNUSED_FUNC(RenderPipelineSetLabelSerialize);\n\nDAWN_DECLARE_UNUSED WireResult RenderPipelineSetLabelDeserialize(\n    RenderPipelineSetLabelCmd* record,\n    const volatile RenderPipelineSetLabelTransfer* transfer,\n    DeserializeBuffer* deserializeBuffer,\n    DeserializeAllocator* allocator, const ObjectIdResolver& resolver) {\n    DAWN_UNUSED(allocator);\n\n    ASSERT(transfer->commandId == WireCmd::RenderPipelineSetLabel);\n\n    record->selfId = transfer->self;\n\n    WIRE_TRY(resolver.GetFromId(transfer->self, &record->self));\n\n\n\n\n    {\n        uint64_t stringLength64 = transfer->labelStrlen;\n        if (stringLength64 >= std::numeric_limits<size_t>::max()) {\n            return WireResult::FatalError;\n        }\n        size_t stringLength = static_cast<size_t>(stringLength64);\n\n        const volatile char* stringInBuffer;\n        WIRE_TRY(deserializeBuffer->ReadN(stringLength, &stringInBuffer));\n\n        char* copiedString;\n        WIRE_TRY(GetSpace(allocator, stringLength + 1, &copiedString));\n        memcpy(copiedString, const_cast<const char*>(stringInBuffer), stringLength);\n        copiedString[stringLength] = '\\0';\n        record->label = copiedString;\n    }\n\n\n    return WireResult::Success;\n}\nDAWN_UNUSED_FUNC(RenderPipelineSetLabelDeserialize);\n\n            \nstruct SamplerSetLabelTransfer : CmdHeader {\n    static_assert(1 <= 1,\n                  \"Record must be at most one of is_cmd, extensible, and chained.\");\n    WireCmd commandId;\n\n    ObjectId self;\n\n    uint64_t labelStrlen;\n\n};\n\nstatic_assert(offsetof(SamplerSetLabelTransfer, commandSize) == 0);\nstatic_assert(offsetof(SamplerSetLabelTransfer, commandId) == sizeof(CmdHeader));\n\n\nDAWN_DECLARE_UNUSED size_t SamplerSetLabelGetExtraRequiredSize(const SamplerSetLabelCmd& record) {\n    DAWN_UNUSED(record);\n\n    size_t result = 0;\n\n\n\n    {\n    result += std::strlen(record.label);\n    }\n\n    {\n    }\n\n    return result;\n}\n// GetExtraRequiredSize isn't used for structures that are value members of other structures\n// because we assume they cannot contain pointers themselves.\nDAWN_UNUSED_FUNC(SamplerSetLabelGetExtraRequiredSize);\n\nDAWN_DECLARE_UNUSED WireResult SamplerSetLabelSerialize(\n    const SamplerSetLabelCmd& record,\n    SamplerSetLabelTransfer* transfer,\n    SerializeBuffer* buffer, const ObjectIdProvider& provider) {\n    DAWN_UNUSED(buffer);\n\n    transfer->commandId = WireCmd::SamplerSetLabel;\n\n    WIRE_TRY(provider.GetId(record.self, &transfer->self));\n\n\n\n\n    {\n        transfer->labelStrlen = std::strlen(record.label);\n\n        char* stringInBuffer;\n        WIRE_TRY(buffer->NextN(transfer->labelStrlen, &stringInBuffer));\n        memcpy(stringInBuffer, record.label, transfer->labelStrlen);\n    }\n\n    return WireResult::Success;\n}\nDAWN_UNUSED_FUNC(SamplerSetLabelSerialize);\n\nDAWN_DECLARE_UNUSED WireResult SamplerSetLabelDeserialize(\n    SamplerSetLabelCmd* record,\n    const volatile SamplerSetLabelTransfer* transfer,\n    DeserializeBuffer* deserializeBuffer,\n    DeserializeAllocator* allocator, const ObjectIdResolver& resolver) {\n    DAWN_UNUSED(allocator);\n\n    ASSERT(transfer->commandId == WireCmd::SamplerSetLabel);\n\n    record->selfId = transfer->self;\n\n    WIRE_TRY(resolver.GetFromId(transfer->self, &record->self));\n\n\n\n\n    {\n        uint64_t stringLength64 = transfer->labelStrlen;\n        if (stringLength64 >= std::numeric_limits<size_t>::max()) {\n            return WireResult::FatalError;\n        }\n        size_t stringLength = static_cast<size_t>(stringLength64);\n\n        const volatile char* stringInBuffer;\n        WIRE_TRY(deserializeBuffer->ReadN(stringLength, &stringInBuffer));\n\n        char* copiedString;\n        WIRE_TRY(GetSpace(allocator, stringLength + 1, &copiedString));\n        memcpy(copiedString, const_cast<const char*>(stringInBuffer), stringLength);\n        copiedString[stringLength] = '\\0';\n        record->label = copiedString;\n    }\n\n\n    return WireResult::Success;\n}\nDAWN_UNUSED_FUNC(SamplerSetLabelDeserialize);\n\n            \nstruct ShaderModuleGetCompilationInfoTransfer : CmdHeader {\n    static_assert(1 <= 1,\n                  \"Record must be at most one of is_cmd, extensible, and chained.\");\n    WireCmd commandId;\n\n    \nObjectId shaderModuleId;\n    \nuint64_t requestSerial;\n\n\n};\n\nstatic_assert(offsetof(ShaderModuleGetCompilationInfoTransfer, commandSize) == 0);\nstatic_assert(offsetof(ShaderModuleGetCompilationInfoTransfer, commandId) == sizeof(CmdHeader));\n\n\nDAWN_DECLARE_UNUSED size_t ShaderModuleGetCompilationInfoGetExtraRequiredSize(const ShaderModuleGetCompilationInfoCmd& record) {\n    DAWN_UNUSED(record);\n\n    size_t result = 0;\n\n\n\n    {\n    }\n    {\n    }\n\n    return result;\n}\n// GetExtraRequiredSize isn't used for structures that are value members of other structures\n// because we assume they cannot contain pointers themselves.\nDAWN_UNUSED_FUNC(ShaderModuleGetCompilationInfoGetExtraRequiredSize);\n\nDAWN_DECLARE_UNUSED WireResult ShaderModuleGetCompilationInfoSerialize(\n    const ShaderModuleGetCompilationInfoCmd& record,\n    ShaderModuleGetCompilationInfoTransfer* transfer,\n    SerializeBuffer* buffer) {\n    DAWN_UNUSED(buffer);\n\n    transfer->commandId = WireCmd::ShaderModuleGetCompilationInfo;\n\n    transfer->shaderModuleId = record.shaderModuleId;\n    transfer->requestSerial = record.requestSerial;\n\n\n\n\n    return WireResult::Success;\n}\nDAWN_UNUSED_FUNC(ShaderModuleGetCompilationInfoSerialize);\n\nDAWN_DECLARE_UNUSED WireResult ShaderModuleGetCompilationInfoDeserialize(\n    ShaderModuleGetCompilationInfoCmd* record,\n    const volatile ShaderModuleGetCompilationInfoTransfer* transfer,\n    DeserializeBuffer* deserializeBuffer,\n    DeserializeAllocator* allocator) {\n    DAWN_UNUSED(allocator);\n\n    ASSERT(transfer->commandId == WireCmd::ShaderModuleGetCompilationInfo);\n\n\n    static_assert(sizeof(record->shaderModuleId) >= sizeof(transfer->shaderModuleId), \"Deserialize assignment may not narrow.\");\nrecord->shaderModuleId = transfer->shaderModuleId;\n    static_assert(sizeof(record->requestSerial) >= sizeof(transfer->requestSerial), \"Deserialize assignment may not narrow.\");\nrecord->requestSerial = transfer->requestSerial;\n\n\n\n\n\n    return WireResult::Success;\n}\nDAWN_UNUSED_FUNC(ShaderModuleGetCompilationInfoDeserialize);\n\n            \nstruct ShaderModuleSetLabelTransfer : CmdHeader {\n    static_assert(1 <= 1,\n                  \"Record must be at most one of is_cmd, extensible, and chained.\");\n    WireCmd commandId;\n\n    ObjectId self;\n\n    uint64_t labelStrlen;\n\n};\n\nstatic_assert(offsetof(ShaderModuleSetLabelTransfer, commandSize) == 0);\nstatic_assert(offsetof(ShaderModuleSetLabelTransfer, commandId) == sizeof(CmdHeader));\n\n\nDAWN_DECLARE_UNUSED size_t ShaderModuleSetLabelGetExtraRequiredSize(const ShaderModuleSetLabelCmd& record) {\n    DAWN_UNUSED(record);\n\n    size_t result = 0;\n\n\n\n    {\n    result += std::strlen(record.label);\n    }\n\n    {\n    }\n\n    return result;\n}\n// GetExtraRequiredSize isn't used for structures that are value members of other structures\n// because we assume they cannot contain pointers themselves.\nDAWN_UNUSED_FUNC(ShaderModuleSetLabelGetExtraRequiredSize);\n\nDAWN_DECLARE_UNUSED WireResult ShaderModuleSetLabelSerialize(\n    const ShaderModuleSetLabelCmd& record,\n    ShaderModuleSetLabelTransfer* transfer,\n    SerializeBuffer* buffer, const ObjectIdProvider& provider) {\n    DAWN_UNUSED(buffer);\n\n    transfer->commandId = WireCmd::ShaderModuleSetLabel;\n\n    WIRE_TRY(provider.GetId(record.self, &transfer->self));\n\n\n\n\n    {\n        transfer->labelStrlen = std::strlen(record.label);\n\n        char* stringInBuffer;\n        WIRE_TRY(buffer->NextN(transfer->labelStrlen, &stringInBuffer));\n        memcpy(stringInBuffer, record.label, transfer->labelStrlen);\n    }\n\n    return WireResult::Success;\n}\nDAWN_UNUSED_FUNC(ShaderModuleSetLabelSerialize);\n\nDAWN_DECLARE_UNUSED WireResult ShaderModuleSetLabelDeserialize(\n    ShaderModuleSetLabelCmd* record,\n    const volatile ShaderModuleSetLabelTransfer* transfer,\n    DeserializeBuffer* deserializeBuffer,\n    DeserializeAllocator* allocator, const ObjectIdResolver& resolver) {\n    DAWN_UNUSED(allocator);\n\n    ASSERT(transfer->commandId == WireCmd::ShaderModuleSetLabel);\n\n    record->selfId = transfer->self;\n\n    WIRE_TRY(resolver.GetFromId(transfer->self, &record->self));\n\n\n\n\n    {\n        uint64_t stringLength64 = transfer->labelStrlen;\n        if (stringLength64 >= std::numeric_limits<size_t>::max()) {\n            return WireResult::FatalError;\n        }\n        size_t stringLength = static_cast<size_t>(stringLength64);\n\n        const volatile char* stringInBuffer;\n        WIRE_TRY(deserializeBuffer->ReadN(stringLength, &stringInBuffer));\n\n        char* copiedString;\n        WIRE_TRY(GetSpace(allocator, stringLength + 1, &copiedString));\n        memcpy(copiedString, const_cast<const char*>(stringInBuffer), stringLength);\n        copiedString[stringLength] = '\\0';\n        record->label = copiedString;\n    }\n\n\n    return WireResult::Success;\n}\nDAWN_UNUSED_FUNC(ShaderModuleSetLabelDeserialize);\n\n            \nstruct SwapChainConfigureTransfer : CmdHeader {\n    static_assert(1 <= 1,\n                  \"Record must be at most one of is_cmd, extensible, and chained.\");\n    WireCmd commandId;\n\n    ObjectId self;\n    \nWGPUTextureFormat format;\n    WGPUTextureUsageFlags allowedUsage;\n    \nuint32_t width;\n    \nuint32_t height;\n\n\n};\n\nstatic_assert(offsetof(SwapChainConfigureTransfer, commandSize) == 0);\nstatic_assert(offsetof(SwapChainConfigureTransfer, commandId) == sizeof(CmdHeader));\n\n\nDAWN_DECLARE_UNUSED size_t SwapChainConfigureGetExtraRequiredSize(const SwapChainConfigureCmd& record) {\n    DAWN_UNUSED(record);\n\n    size_t result = 0;\n\n\n\n    {\n    }\n    {\n    }\n    {\n    }\n    {\n    }\n    {\n    }\n\n    return result;\n}\n// GetExtraRequiredSize isn't used for structures that are value members of other structures\n// because we assume they cannot contain pointers themselves.\nDAWN_UNUSED_FUNC(SwapChainConfigureGetExtraRequiredSize);\n\nDAWN_DECLARE_UNUSED WireResult SwapChainConfigureSerialize(\n    const SwapChainConfigureCmd& record,\n    SwapChainConfigureTransfer* transfer,\n    SerializeBuffer* buffer, const ObjectIdProvider& provider) {\n    DAWN_UNUSED(buffer);\n\n    transfer->commandId = WireCmd::SwapChainConfigure;\n\n    WIRE_TRY(provider.GetId(record.self, &transfer->self));\n    transfer->format = record.format;\n    transfer->allowedUsage = record.allowedUsage;\n    transfer->width = record.width;\n    transfer->height = record.height;\n\n\n\n\n    return WireResult::Success;\n}\nDAWN_UNUSED_FUNC(SwapChainConfigureSerialize);\n\nDAWN_DECLARE_UNUSED WireResult SwapChainConfigureDeserialize(\n    SwapChainConfigureCmd* record,\n    const volatile SwapChainConfigureTransfer* transfer,\n    DeserializeBuffer* deserializeBuffer,\n    DeserializeAllocator* allocator, const ObjectIdResolver& resolver) {\n    DAWN_UNUSED(allocator);\n\n    ASSERT(transfer->commandId == WireCmd::SwapChainConfigure);\n\n    record->selfId = transfer->self;\n\n    WIRE_TRY(resolver.GetFromId(transfer->self, &record->self));\n    static_assert(sizeof(record->format) >= sizeof(transfer->format), \"Deserialize assignment may not narrow.\");\nrecord->format = transfer->format;\n    static_assert(sizeof(record->allowedUsage) >= sizeof(transfer->allowedUsage), \"Deserialize assignment may not narrow.\");\nrecord->allowedUsage = transfer->allowedUsage;\n    static_assert(sizeof(record->width) >= sizeof(transfer->width), \"Deserialize assignment may not narrow.\");\nrecord->width = transfer->width;\n    static_assert(sizeof(record->height) >= sizeof(transfer->height), \"Deserialize assignment may not narrow.\");\nrecord->height = transfer->height;\n\n\n\n\n\n    return WireResult::Success;\n}\nDAWN_UNUSED_FUNC(SwapChainConfigureDeserialize);\n\n            \nstruct SwapChainGetCurrentTextureViewTransfer : CmdHeader {\n    static_assert(1 <= 1,\n                  \"Record must be at most one of is_cmd, extensible, and chained.\");\n    WireCmd commandId;\n\n    ObjectId self;\n    \nObjectHandle result;\n\n\n};\n\nstatic_assert(offsetof(SwapChainGetCurrentTextureViewTransfer, commandSize) == 0);\nstatic_assert(offsetof(SwapChainGetCurrentTextureViewTransfer, commandId) == sizeof(CmdHeader));\n\n\nDAWN_DECLARE_UNUSED size_t SwapChainGetCurrentTextureViewGetExtraRequiredSize(const SwapChainGetCurrentTextureViewCmd& record) {\n    DAWN_UNUSED(record);\n\n    size_t result = 0;\n\n\n\n    {\n    }\n    {\n    }\n\n    return result;\n}\n// GetExtraRequiredSize isn't used for structures that are value members of other structures\n// because we assume they cannot contain pointers themselves.\nDAWN_UNUSED_FUNC(SwapChainGetCurrentTextureViewGetExtraRequiredSize);\n\nDAWN_DECLARE_UNUSED WireResult SwapChainGetCurrentTextureViewSerialize(\n    const SwapChainGetCurrentTextureViewCmd& record,\n    SwapChainGetCurrentTextureViewTransfer* transfer,\n    SerializeBuffer* buffer, const ObjectIdProvider& provider) {\n    DAWN_UNUSED(buffer);\n\n    transfer->commandId = WireCmd::SwapChainGetCurrentTextureView;\n\n    WIRE_TRY(provider.GetId(record.self, &transfer->self));\n    transfer->result = record.result;\n\n\n\n\n    return WireResult::Success;\n}\nDAWN_UNUSED_FUNC(SwapChainGetCurrentTextureViewSerialize);\n\nDAWN_DECLARE_UNUSED WireResult SwapChainGetCurrentTextureViewDeserialize(\n    SwapChainGetCurrentTextureViewCmd* record,\n    const volatile SwapChainGetCurrentTextureViewTransfer* transfer,\n    DeserializeBuffer* deserializeBuffer,\n    DeserializeAllocator* allocator, const ObjectIdResolver& resolver) {\n    DAWN_UNUSED(allocator);\n\n    ASSERT(transfer->commandId == WireCmd::SwapChainGetCurrentTextureView);\n\n    record->selfId = transfer->self;\n\n    WIRE_TRY(resolver.GetFromId(transfer->self, &record->self));\n    static_assert(sizeof(record->result) >= sizeof(transfer->result), \"Deserialize assignment may not narrow.\");\nrecord->result = transfer->result;\n\n\n\n\n\n    return WireResult::Success;\n}\nDAWN_UNUSED_FUNC(SwapChainGetCurrentTextureViewDeserialize);\n\n            \nstruct SwapChainPresentTransfer : CmdHeader {\n    static_assert(1 <= 1,\n                  \"Record must be at most one of is_cmd, extensible, and chained.\");\n    WireCmd commandId;\n\n    ObjectId self;\n\n\n};\n\nstatic_assert(offsetof(SwapChainPresentTransfer, commandSize) == 0);\nstatic_assert(offsetof(SwapChainPresentTransfer, commandId) == sizeof(CmdHeader));\n\n\nDAWN_DECLARE_UNUSED size_t SwapChainPresentGetExtraRequiredSize(const SwapChainPresentCmd& record) {\n    DAWN_UNUSED(record);\n\n    size_t result = 0;\n\n\n\n    {\n    }\n\n    return result;\n}\n// GetExtraRequiredSize isn't used for structures that are value members of other structures\n// because we assume they cannot contain pointers themselves.\nDAWN_UNUSED_FUNC(SwapChainPresentGetExtraRequiredSize);\n\nDAWN_DECLARE_UNUSED WireResult SwapChainPresentSerialize(\n    const SwapChainPresentCmd& record,\n    SwapChainPresentTransfer* transfer,\n    SerializeBuffer* buffer, const ObjectIdProvider& provider) {\n    DAWN_UNUSED(buffer);\n\n    transfer->commandId = WireCmd::SwapChainPresent;\n\n    WIRE_TRY(provider.GetId(record.self, &transfer->self));\n\n\n\n\n    return WireResult::Success;\n}\nDAWN_UNUSED_FUNC(SwapChainPresentSerialize);\n\nDAWN_DECLARE_UNUSED WireResult SwapChainPresentDeserialize(\n    SwapChainPresentCmd* record,\n    const volatile SwapChainPresentTransfer* transfer,\n    DeserializeBuffer* deserializeBuffer,\n    DeserializeAllocator* allocator, const ObjectIdResolver& resolver) {\n    DAWN_UNUSED(allocator);\n\n    ASSERT(transfer->commandId == WireCmd::SwapChainPresent);\n\n    record->selfId = transfer->self;\n\n    WIRE_TRY(resolver.GetFromId(transfer->self, &record->self));\n\n\n\n\n\n    return WireResult::Success;\n}\nDAWN_UNUSED_FUNC(SwapChainPresentDeserialize);\n\n            \nstruct TextureCreateViewTransfer : CmdHeader {\n    static_assert(1 <= 1,\n                  \"Record must be at most one of is_cmd, extensible, and chained.\");\n    WireCmd commandId;\n\n    ObjectId self;\n    \nObjectHandle result;\n\n\n    bool has_descriptor;\n};\n\nstatic_assert(offsetof(TextureCreateViewTransfer, commandSize) == 0);\nstatic_assert(offsetof(TextureCreateViewTransfer, commandId) == sizeof(CmdHeader));\n\n\nDAWN_DECLARE_UNUSED size_t TextureCreateViewGetExtraRequiredSize(const TextureCreateViewCmd& record) {\n    DAWN_UNUSED(record);\n\n    size_t result = 0;\n\n\n\n    {\n    }\n    if (record.descriptor != nullptr)\n    {\n        \n        auto memberLength = 1u;\n        result += memberLength * sizeof(WGPUTextureViewDescriptorTransfer);\n        for (decltype(memberLength) i = 0; i < memberLength; ++i) {\n            \n            result += WGPUTextureViewDescriptorGetExtraRequiredSize(record.descriptor[i]);\n        }\n    }\n    {\n    }\n\n    return result;\n}\n// GetExtraRequiredSize isn't used for structures that are value members of other structures\n// because we assume they cannot contain pointers themselves.\nDAWN_UNUSED_FUNC(TextureCreateViewGetExtraRequiredSize);\n\nDAWN_DECLARE_UNUSED WireResult TextureCreateViewSerialize(\n    const TextureCreateViewCmd& record,\n    TextureCreateViewTransfer* transfer,\n    SerializeBuffer* buffer, const ObjectIdProvider& provider) {\n    DAWN_UNUSED(buffer);\n\n    transfer->commandId = WireCmd::TextureCreateView;\n\n    WIRE_TRY(provider.GetId(record.self, &transfer->self));\n    transfer->result = record.result;\n\n\n\n\n    \n\n    bool has_descriptor = record.descriptor != nullptr;\n    transfer->has_descriptor = has_descriptor;\n    if (has_descriptor)\n    {\n        auto memberLength = 1u;\n\n        WGPUTextureViewDescriptorTransfer* memberBuffer;\n        WIRE_TRY(buffer->NextN(memberLength, &memberBuffer));\n\n        for (decltype(memberLength) i = 0; i < memberLength; ++i) {\n            WIRE_TRY(WGPUTextureViewDescriptorSerialize(record.descriptor[i], &memberBuffer[i], buffer, provider));\n        }\n    }\n    return WireResult::Success;\n}\nDAWN_UNUSED_FUNC(TextureCreateViewSerialize);\n\nDAWN_DECLARE_UNUSED WireResult TextureCreateViewDeserialize(\n    TextureCreateViewCmd* record,\n    const volatile TextureCreateViewTransfer* transfer,\n    DeserializeBuffer* deserializeBuffer,\n    DeserializeAllocator* allocator, const ObjectIdResolver& resolver) {\n    DAWN_UNUSED(allocator);\n\n    ASSERT(transfer->commandId == WireCmd::TextureCreateView);\n\n    record->selfId = transfer->self;\n\n    WIRE_TRY(resolver.GetFromId(transfer->self, &record->self));\n    static_assert(sizeof(record->result) >= sizeof(transfer->result), \"Deserialize assignment may not narrow.\");\nrecord->result = transfer->result;\n\n\n\n\n    \n\n    \n    bool has_descriptor = transfer->has_descriptor;\n    record->descriptor = nullptr;\n    if (has_descriptor)\n    {\n        auto memberLength = 1u;\n        const volatile WGPUTextureViewDescriptorTransfer* memberBuffer;\n        WIRE_TRY(deserializeBuffer->ReadN(memberLength, &memberBuffer));\n\n        WGPUTextureViewDescriptor* copiedMembers;\n        WIRE_TRY(GetSpace(allocator, memberLength, &copiedMembers));\n        record->descriptor = copiedMembers;\n\n        for (decltype(memberLength) i = 0; i < memberLength; ++i) {\n            WIRE_TRY(WGPUTextureViewDescriptorDeserialize(&copiedMembers[i], &memberBuffer[i], deserializeBuffer, allocator, resolver));\n        }\n    }\n\n    return WireResult::Success;\n}\nDAWN_UNUSED_FUNC(TextureCreateViewDeserialize);\n\n            \nstruct TextureDestroyTransfer : CmdHeader {\n    static_assert(1 <= 1,\n                  \"Record must be at most one of is_cmd, extensible, and chained.\");\n    WireCmd commandId;\n\n    ObjectId self;\n\n\n};\n\nstatic_assert(offsetof(TextureDestroyTransfer, commandSize) == 0);\nstatic_assert(offsetof(TextureDestroyTransfer, commandId) == sizeof(CmdHeader));\n\n\nDAWN_DECLARE_UNUSED size_t TextureDestroyGetExtraRequiredSize(const TextureDestroyCmd& record) {\n    DAWN_UNUSED(record);\n\n    size_t result = 0;\n\n\n\n    {\n    }\n\n    return result;\n}\n// GetExtraRequiredSize isn't used for structures that are value members of other structures\n// because we assume they cannot contain pointers themselves.\nDAWN_UNUSED_FUNC(TextureDestroyGetExtraRequiredSize);\n\nDAWN_DECLARE_UNUSED WireResult TextureDestroySerialize(\n    const TextureDestroyCmd& record,\n    TextureDestroyTransfer* transfer,\n    SerializeBuffer* buffer, const ObjectIdProvider& provider) {\n    DAWN_UNUSED(buffer);\n\n    transfer->commandId = WireCmd::TextureDestroy;\n\n    WIRE_TRY(provider.GetId(record.self, &transfer->self));\n\n\n\n\n    return WireResult::Success;\n}\nDAWN_UNUSED_FUNC(TextureDestroySerialize);\n\nDAWN_DECLARE_UNUSED WireResult TextureDestroyDeserialize(\n    TextureDestroyCmd* record,\n    const volatile TextureDestroyTransfer* transfer,\n    DeserializeBuffer* deserializeBuffer,\n    DeserializeAllocator* allocator, const ObjectIdResolver& resolver) {\n    DAWN_UNUSED(allocator);\n\n    ASSERT(transfer->commandId == WireCmd::TextureDestroy);\n\n    record->selfId = transfer->self;\n\n    WIRE_TRY(resolver.GetFromId(transfer->self, &record->self));\n\n\n\n\n\n    return WireResult::Success;\n}\nDAWN_UNUSED_FUNC(TextureDestroyDeserialize);\n\n            \nstruct TextureSetLabelTransfer : CmdHeader {\n    static_assert(1 <= 1,\n                  \"Record must be at most one of is_cmd, extensible, and chained.\");\n    WireCmd commandId;\n\n    ObjectId self;\n\n    uint64_t labelStrlen;\n\n};\n\nstatic_assert(offsetof(TextureSetLabelTransfer, commandSize) == 0);\nstatic_assert(offsetof(TextureSetLabelTransfer, commandId) == sizeof(CmdHeader));\n\n\nDAWN_DECLARE_UNUSED size_t TextureSetLabelGetExtraRequiredSize(const TextureSetLabelCmd& record) {\n    DAWN_UNUSED(record);\n\n    size_t result = 0;\n\n\n\n    {\n    result += std::strlen(record.label);\n    }\n\n    {\n    }\n\n    return result;\n}\n// GetExtraRequiredSize isn't used for structures that are value members of other structures\n// because we assume they cannot contain pointers themselves.\nDAWN_UNUSED_FUNC(TextureSetLabelGetExtraRequiredSize);\n\nDAWN_DECLARE_UNUSED WireResult TextureSetLabelSerialize(\n    const TextureSetLabelCmd& record,\n    TextureSetLabelTransfer* transfer,\n    SerializeBuffer* buffer, const ObjectIdProvider& provider) {\n    DAWN_UNUSED(buffer);\n\n    transfer->commandId = WireCmd::TextureSetLabel;\n\n    WIRE_TRY(provider.GetId(record.self, &transfer->self));\n\n\n\n\n    {\n        transfer->labelStrlen = std::strlen(record.label);\n\n        char* stringInBuffer;\n        WIRE_TRY(buffer->NextN(transfer->labelStrlen, &stringInBuffer));\n        memcpy(stringInBuffer, record.label, transfer->labelStrlen);\n    }\n\n    return WireResult::Success;\n}\nDAWN_UNUSED_FUNC(TextureSetLabelSerialize);\n\nDAWN_DECLARE_UNUSED WireResult TextureSetLabelDeserialize(\n    TextureSetLabelCmd* record,\n    const volatile TextureSetLabelTransfer* transfer,\n    DeserializeBuffer* deserializeBuffer,\n    DeserializeAllocator* allocator, const ObjectIdResolver& resolver) {\n    DAWN_UNUSED(allocator);\n\n    ASSERT(transfer->commandId == WireCmd::TextureSetLabel);\n\n    record->selfId = transfer->self;\n\n    WIRE_TRY(resolver.GetFromId(transfer->self, &record->self));\n\n\n\n\n    {\n        uint64_t stringLength64 = transfer->labelStrlen;\n        if (stringLength64 >= std::numeric_limits<size_t>::max()) {\n            return WireResult::FatalError;\n        }\n        size_t stringLength = static_cast<size_t>(stringLength64);\n\n        const volatile char* stringInBuffer;\n        WIRE_TRY(deserializeBuffer->ReadN(stringLength, &stringInBuffer));\n\n        char* copiedString;\n        WIRE_TRY(GetSpace(allocator, stringLength + 1, &copiedString));\n        memcpy(copiedString, const_cast<const char*>(stringInBuffer), stringLength);\n        copiedString[stringLength] = '\\0';\n        record->label = copiedString;\n    }\n\n\n    return WireResult::Success;\n}\nDAWN_UNUSED_FUNC(TextureSetLabelDeserialize);\n\n            \nstruct TextureViewSetLabelTransfer : CmdHeader {\n    static_assert(1 <= 1,\n                  \"Record must be at most one of is_cmd, extensible, and chained.\");\n    WireCmd commandId;\n\n    ObjectId self;\n\n    uint64_t labelStrlen;\n\n};\n\nstatic_assert(offsetof(TextureViewSetLabelTransfer, commandSize) == 0);\nstatic_assert(offsetof(TextureViewSetLabelTransfer, commandId) == sizeof(CmdHeader));\n\n\nDAWN_DECLARE_UNUSED size_t TextureViewSetLabelGetExtraRequiredSize(const TextureViewSetLabelCmd& record) {\n    DAWN_UNUSED(record);\n\n    size_t result = 0;\n\n\n\n    {\n    result += std::strlen(record.label);\n    }\n\n    {\n    }\n\n    return result;\n}\n// GetExtraRequiredSize isn't used for structures that are value members of other structures\n// because we assume they cannot contain pointers themselves.\nDAWN_UNUSED_FUNC(TextureViewSetLabelGetExtraRequiredSize);\n\nDAWN_DECLARE_UNUSED WireResult TextureViewSetLabelSerialize(\n    const TextureViewSetLabelCmd& record,\n    TextureViewSetLabelTransfer* transfer,\n    SerializeBuffer* buffer, const ObjectIdProvider& provider) {\n    DAWN_UNUSED(buffer);\n\n    transfer->commandId = WireCmd::TextureViewSetLabel;\n\n    WIRE_TRY(provider.GetId(record.self, &transfer->self));\n\n\n\n\n    {\n        transfer->labelStrlen = std::strlen(record.label);\n\n        char* stringInBuffer;\n        WIRE_TRY(buffer->NextN(transfer->labelStrlen, &stringInBuffer));\n        memcpy(stringInBuffer, record.label, transfer->labelStrlen);\n    }\n\n    return WireResult::Success;\n}\nDAWN_UNUSED_FUNC(TextureViewSetLabelSerialize);\n\nDAWN_DECLARE_UNUSED WireResult TextureViewSetLabelDeserialize(\n    TextureViewSetLabelCmd* record,\n    const volatile TextureViewSetLabelTransfer* transfer,\n    DeserializeBuffer* deserializeBuffer,\n    DeserializeAllocator* allocator, const ObjectIdResolver& resolver) {\n    DAWN_UNUSED(allocator);\n\n    ASSERT(transfer->commandId == WireCmd::TextureViewSetLabel);\n\n    record->selfId = transfer->self;\n\n    WIRE_TRY(resolver.GetFromId(transfer->self, &record->self));\n\n\n\n\n    {\n        uint64_t stringLength64 = transfer->labelStrlen;\n        if (stringLength64 >= std::numeric_limits<size_t>::max()) {\n            return WireResult::FatalError;\n        }\n        size_t stringLength = static_cast<size_t>(stringLength64);\n\n        const volatile char* stringInBuffer;\n        WIRE_TRY(deserializeBuffer->ReadN(stringLength, &stringInBuffer));\n\n        char* copiedString;\n        WIRE_TRY(GetSpace(allocator, stringLength + 1, &copiedString));\n        memcpy(copiedString, const_cast<const char*>(stringInBuffer), stringLength);\n        copiedString[stringLength] = '\\0';\n        record->label = copiedString;\n    }\n\n\n    return WireResult::Success;\n}\nDAWN_UNUSED_FUNC(TextureViewSetLabelDeserialize);\n\n\n            \nstruct ReturnAdapterRequestDeviceCallbackTransfer : CmdHeader {\n    static_assert(1 <= 1,\n                  \"Record must be at most one of is_cmd, extensible, and chained.\");\n    ReturnWireCmd commandId;\n\n    \nObjectHandle adapter;\n    \nuint64_t requestSerial;\n    \nWGPURequestDeviceStatus status;\n    \nuint32_t featuresCount;\n\n    uint64_t messageStrlen;\n\n    bool has_message;\n    bool has_limits;\n};\n\nstatic_assert(offsetof(ReturnAdapterRequestDeviceCallbackTransfer, commandSize) == 0);\nstatic_assert(offsetof(ReturnAdapterRequestDeviceCallbackTransfer, commandId) == sizeof(CmdHeader));\n\n\nDAWN_DECLARE_UNUSED size_t ReturnAdapterRequestDeviceCallbackGetExtraRequiredSize(const ReturnAdapterRequestDeviceCallbackCmd& record) {\n    DAWN_UNUSED(record);\n\n    size_t result = 0;\n\n\n\n    bool has_message = record.message != nullptr;\n    if (has_message)\n    {\n    result += std::strlen(record.message);\n    }\n\n    {\n    }\n    {\n    }\n    {\n    }\n    if (record.limits != nullptr)\n    {\n        \n        auto memberLength = 1u;\n        result += memberLength * sizeof(WGPUSupportedLimitsTransfer);\n        for (decltype(memberLength) i = 0; i < memberLength; ++i) {\n            \n            result += WGPUSupportedLimitsGetExtraRequiredSize(record.limits[i]);\n        }\n    }\n    {\n    }\n    {\n        \n        auto memberLength = record.featuresCount;\n        result += memberLength * sizeof(\nWGPUFeatureName);\n    }\n\n    return result;\n}\n// GetExtraRequiredSize isn't used for structures that are value members of other structures\n// because we assume they cannot contain pointers themselves.\nDAWN_UNUSED_FUNC(ReturnAdapterRequestDeviceCallbackGetExtraRequiredSize);\n\nDAWN_DECLARE_UNUSED WireResult ReturnAdapterRequestDeviceCallbackSerialize(\n    const ReturnAdapterRequestDeviceCallbackCmd& record,\n    ReturnAdapterRequestDeviceCallbackTransfer* transfer,\n    SerializeBuffer* buffer, const ObjectIdProvider& provider) {\n    DAWN_UNUSED(buffer);\n\n    transfer->commandId = ReturnWireCmd::AdapterRequestDeviceCallback;\n\n    transfer->adapter = record.adapter;\n    transfer->requestSerial = record.requestSerial;\n    transfer->status = record.status;\n    transfer->featuresCount = record.featuresCount;\n\n\n\n\n    bool has_message = record.message != nullptr;\n    transfer->has_message = has_message;\n    if (has_message)\n    {\n        transfer->messageStrlen = std::strlen(record.message);\n\n        char* stringInBuffer;\n        WIRE_TRY(buffer->NextN(transfer->messageStrlen, &stringInBuffer));\n        memcpy(stringInBuffer, record.message, transfer->messageStrlen);\n    }\n\n    \n\n    bool has_limits = record.limits != nullptr;\n    transfer->has_limits = has_limits;\n    if (has_limits)\n    {\n        auto memberLength = 1u;\n\n        WGPUSupportedLimitsTransfer* memberBuffer;\n        WIRE_TRY(buffer->NextN(memberLength, &memberBuffer));\n\n        for (decltype(memberLength) i = 0; i < memberLength; ++i) {\n            WIRE_TRY(WGPUSupportedLimitsSerialize(record.limits[i], &memberBuffer[i], buffer, provider));\n        }\n    }\n    \n\n    {\n        auto memberLength = record.featuresCount;\n\n        \nWGPUFeatureName* memberBuffer;\n        WIRE_TRY(buffer->NextN(memberLength, &memberBuffer));\n\n        memcpy(\n            memberBuffer, record.features,\n            sizeof(\nWGPUFeatureName) * memberLength);\n    }\n    return WireResult::Success;\n}\nDAWN_UNUSED_FUNC(ReturnAdapterRequestDeviceCallbackSerialize);\n\nDAWN_DECLARE_UNUSED WireResult ReturnAdapterRequestDeviceCallbackDeserialize(\n    ReturnAdapterRequestDeviceCallbackCmd* record,\n    const volatile ReturnAdapterRequestDeviceCallbackTransfer* transfer,\n    DeserializeBuffer* deserializeBuffer,\n    DeserializeAllocator* allocator, const ObjectIdResolver& resolver) {\n    DAWN_UNUSED(allocator);\n\n    ASSERT(transfer->commandId == ReturnWireCmd::AdapterRequestDeviceCallback);\n\n\n    static_assert(sizeof(record->adapter) >= sizeof(transfer->adapter), \"Deserialize assignment may not narrow.\");\nrecord->adapter = transfer->adapter;\n    static_assert(sizeof(record->requestSerial) >= sizeof(transfer->requestSerial), \"Deserialize assignment may not narrow.\");\nrecord->requestSerial = transfer->requestSerial;\n    static_assert(sizeof(record->status) >= sizeof(transfer->status), \"Deserialize assignment may not narrow.\");\nrecord->status = transfer->status;\n    static_assert(sizeof(record->featuresCount) >= sizeof(transfer->featuresCount), \"Deserialize assignment may not narrow.\");\nrecord->featuresCount = transfer->featuresCount;\n\n\n\n\n    bool has_message = transfer->has_message;\n    record->message = nullptr;\n    if (has_message)\n    {\n        uint64_t stringLength64 = transfer->messageStrlen;\n        if (stringLength64 >= std::numeric_limits<size_t>::max()) {\n            return WireResult::FatalError;\n        }\n        size_t stringLength = static_cast<size_t>(stringLength64);\n\n        const volatile char* stringInBuffer;\n        WIRE_TRY(deserializeBuffer->ReadN(stringLength, &stringInBuffer));\n\n        char* copiedString;\n        WIRE_TRY(GetSpace(allocator, stringLength + 1, &copiedString));\n        memcpy(copiedString, const_cast<const char*>(stringInBuffer), stringLength);\n        copiedString[stringLength] = '\\0';\n        record->message = copiedString;\n    }\n\n    \n\n    \n    bool has_limits = transfer->has_limits;\n    record->limits = nullptr;\n    if (has_limits)\n    {\n        auto memberLength = 1u;\n        const volatile WGPUSupportedLimitsTransfer* memberBuffer;\n        WIRE_TRY(deserializeBuffer->ReadN(memberLength, &memberBuffer));\n\n        WGPUSupportedLimits* copiedMembers;\n        WIRE_TRY(GetSpace(allocator, memberLength, &copiedMembers));\n        record->limits = copiedMembers;\n\n        for (decltype(memberLength) i = 0; i < memberLength; ++i) {\n            WIRE_TRY(WGPUSupportedLimitsDeserialize(&copiedMembers[i], &memberBuffer[i], deserializeBuffer, allocator, resolver));\n        }\n    }\n    \n\n    {\n        auto memberLength = record->featuresCount;\n        const volatile \nWGPUFeatureName* memberBuffer;\n        WIRE_TRY(deserializeBuffer->ReadN(memberLength, &memberBuffer));\n\n        WGPUFeatureName* copiedMembers;\n        WIRE_TRY(GetSpace(allocator, memberLength, &copiedMembers));\n        record->features = copiedMembers;\n\n        memcpy(\n            copiedMembers,\n            const_cast<const \nWGPUFeatureName*>(memberBuffer),\n           sizeof(\nWGPUFeatureName) * memberLength);\n    }\n\n    return WireResult::Success;\n}\nDAWN_UNUSED_FUNC(ReturnAdapterRequestDeviceCallbackDeserialize);\n\n            \nstruct ReturnBufferMapAsyncCallbackTransfer : CmdHeader {\n    static_assert(1 <= 1,\n                  \"Record must be at most one of is_cmd, extensible, and chained.\");\n    ReturnWireCmd commandId;\n\n    \nObjectHandle buffer;\n    \nuint64_t requestSerial;\n    \nuint32_t status;\n    \nuint64_t readDataUpdateInfoLength;\n\n\n};\n\nstatic_assert(offsetof(ReturnBufferMapAsyncCallbackTransfer, commandSize) == 0);\nstatic_assert(offsetof(ReturnBufferMapAsyncCallbackTransfer, commandId) == sizeof(CmdHeader));\n\n\nDAWN_DECLARE_UNUSED size_t ReturnBufferMapAsyncCallbackGetExtraRequiredSize(const ReturnBufferMapAsyncCallbackCmd& record) {\n    DAWN_UNUSED(record);\n\n    size_t result = 0;\n\n\n\n    {\n    }\n    {\n    }\n    {\n    }\n    {\n    }\n\n    return result;\n}\n// GetExtraRequiredSize isn't used for structures that are value members of other structures\n// because we assume they cannot contain pointers themselves.\nDAWN_UNUSED_FUNC(ReturnBufferMapAsyncCallbackGetExtraRequiredSize);\n\nDAWN_DECLARE_UNUSED WireResult ReturnBufferMapAsyncCallbackSerialize(\n    const ReturnBufferMapAsyncCallbackCmd& record,\n    ReturnBufferMapAsyncCallbackTransfer* transfer,\n    SerializeBuffer* buffer) {\n    DAWN_UNUSED(buffer);\n\n    transfer->commandId = ReturnWireCmd::BufferMapAsyncCallback;\n\n    transfer->buffer = record.buffer;\n    transfer->requestSerial = record.requestSerial;\n    transfer->status = record.status;\n    transfer->readDataUpdateInfoLength = record.readDataUpdateInfoLength;\n\n\n\n\n    return WireResult::Success;\n}\nDAWN_UNUSED_FUNC(ReturnBufferMapAsyncCallbackSerialize);\n\nDAWN_DECLARE_UNUSED WireResult ReturnBufferMapAsyncCallbackDeserialize(\n    ReturnBufferMapAsyncCallbackCmd* record,\n    const volatile ReturnBufferMapAsyncCallbackTransfer* transfer,\n    DeserializeBuffer* deserializeBuffer,\n    DeserializeAllocator* allocator) {\n    DAWN_UNUSED(allocator);\n\n    ASSERT(transfer->commandId == ReturnWireCmd::BufferMapAsyncCallback);\n\n\n    static_assert(sizeof(record->buffer) >= sizeof(transfer->buffer), \"Deserialize assignment may not narrow.\");\nrecord->buffer = transfer->buffer;\n    static_assert(sizeof(record->requestSerial) >= sizeof(transfer->requestSerial), \"Deserialize assignment may not narrow.\");\nrecord->requestSerial = transfer->requestSerial;\n    static_assert(sizeof(record->status) >= sizeof(transfer->status), \"Deserialize assignment may not narrow.\");\nrecord->status = transfer->status;\n    static_assert(sizeof(record->readDataUpdateInfoLength) >= sizeof(transfer->readDataUpdateInfoLength), \"Deserialize assignment may not narrow.\");\nrecord->readDataUpdateInfoLength = transfer->readDataUpdateInfoLength;\n\n\n\n\n    \n\n    {\n        auto memberLength = record->readDataUpdateInfoLength;\n        const volatile \nuint8_t* memberBuffer;\n        WIRE_TRY(deserializeBuffer->ReadN(memberLength, &memberBuffer));\n\n        uint8_t* copiedMembers;\n        WIRE_TRY(GetSpace(allocator, memberLength, &copiedMembers));\n        record->readDataUpdateInfo = copiedMembers;\n\n        memcpy(\n            copiedMembers,\n            const_cast<const \nuint8_t*>(memberBuffer),\n           sizeof(\nuint8_t) * memberLength);\n    }\n\n    return WireResult::Success;\n}\nDAWN_UNUSED_FUNC(ReturnBufferMapAsyncCallbackDeserialize);\n\n            \nstruct ReturnDeviceCreateComputePipelineAsyncCallbackTransfer : CmdHeader {\n    static_assert(1 <= 1,\n                  \"Record must be at most one of is_cmd, extensible, and chained.\");\n    ReturnWireCmd commandId;\n\n    \nObjectHandle device;\n    \nuint64_t requestSerial;\n    \nWGPUCreatePipelineAsyncStatus status;\n\n    uint64_t messageStrlen;\n\n};\n\nstatic_assert(offsetof(ReturnDeviceCreateComputePipelineAsyncCallbackTransfer, commandSize) == 0);\nstatic_assert(offsetof(ReturnDeviceCreateComputePipelineAsyncCallbackTransfer, commandId) == sizeof(CmdHeader));\n\n\nDAWN_DECLARE_UNUSED size_t ReturnDeviceCreateComputePipelineAsyncCallbackGetExtraRequiredSize(const ReturnDeviceCreateComputePipelineAsyncCallbackCmd& record) {\n    DAWN_UNUSED(record);\n\n    size_t result = 0;\n\n\n\n    {\n    result += std::strlen(record.message);\n    }\n\n    {\n    }\n    {\n    }\n    {\n    }\n\n    return result;\n}\n// GetExtraRequiredSize isn't used for structures that are value members of other structures\n// because we assume they cannot contain pointers themselves.\nDAWN_UNUSED_FUNC(ReturnDeviceCreateComputePipelineAsyncCallbackGetExtraRequiredSize);\n\nDAWN_DECLARE_UNUSED WireResult ReturnDeviceCreateComputePipelineAsyncCallbackSerialize(\n    const ReturnDeviceCreateComputePipelineAsyncCallbackCmd& record,\n    ReturnDeviceCreateComputePipelineAsyncCallbackTransfer* transfer,\n    SerializeBuffer* buffer) {\n    DAWN_UNUSED(buffer);\n\n    transfer->commandId = ReturnWireCmd::DeviceCreateComputePipelineAsyncCallback;\n\n    transfer->device = record.device;\n    transfer->requestSerial = record.requestSerial;\n    transfer->status = record.status;\n\n\n\n\n    {\n        transfer->messageStrlen = std::strlen(record.message);\n\n        char* stringInBuffer;\n        WIRE_TRY(buffer->NextN(transfer->messageStrlen, &stringInBuffer));\n        memcpy(stringInBuffer, record.message, transfer->messageStrlen);\n    }\n\n    return WireResult::Success;\n}\nDAWN_UNUSED_FUNC(ReturnDeviceCreateComputePipelineAsyncCallbackSerialize);\n\nDAWN_DECLARE_UNUSED WireResult ReturnDeviceCreateComputePipelineAsyncCallbackDeserialize(\n    ReturnDeviceCreateComputePipelineAsyncCallbackCmd* record,\n    const volatile ReturnDeviceCreateComputePipelineAsyncCallbackTransfer* transfer,\n    DeserializeBuffer* deserializeBuffer,\n    DeserializeAllocator* allocator) {\n    DAWN_UNUSED(allocator);\n\n    ASSERT(transfer->commandId == ReturnWireCmd::DeviceCreateComputePipelineAsyncCallback);\n\n\n    static_assert(sizeof(record->device) >= sizeof(transfer->device), \"Deserialize assignment may not narrow.\");\nrecord->device = transfer->device;\n    static_assert(sizeof(record->requestSerial) >= sizeof(transfer->requestSerial), \"Deserialize assignment may not narrow.\");\nrecord->requestSerial = transfer->requestSerial;\n    static_assert(sizeof(record->status) >= sizeof(transfer->status), \"Deserialize assignment may not narrow.\");\nrecord->status = transfer->status;\n\n\n\n\n    {\n        uint64_t stringLength64 = transfer->messageStrlen;\n        if (stringLength64 >= std::numeric_limits<size_t>::max()) {\n            return WireResult::FatalError;\n        }\n        size_t stringLength = static_cast<size_t>(stringLength64);\n\n        const volatile char* stringInBuffer;\n        WIRE_TRY(deserializeBuffer->ReadN(stringLength, &stringInBuffer));\n\n        char* copiedString;\n        WIRE_TRY(GetSpace(allocator, stringLength + 1, &copiedString));\n        memcpy(copiedString, const_cast<const char*>(stringInBuffer), stringLength);\n        copiedString[stringLength] = '\\0';\n        record->message = copiedString;\n    }\n\n\n    return WireResult::Success;\n}\nDAWN_UNUSED_FUNC(ReturnDeviceCreateComputePipelineAsyncCallbackDeserialize);\n\n            \nstruct ReturnDeviceCreateRenderPipelineAsyncCallbackTransfer : CmdHeader {\n    static_assert(1 <= 1,\n                  \"Record must be at most one of is_cmd, extensible, and chained.\");\n    ReturnWireCmd commandId;\n\n    \nObjectHandle device;\n    \nuint64_t requestSerial;\n    \nWGPUCreatePipelineAsyncStatus status;\n\n    uint64_t messageStrlen;\n\n};\n\nstatic_assert(offsetof(ReturnDeviceCreateRenderPipelineAsyncCallbackTransfer, commandSize) == 0);\nstatic_assert(offsetof(ReturnDeviceCreateRenderPipelineAsyncCallbackTransfer, commandId) == sizeof(CmdHeader));\n\n\nDAWN_DECLARE_UNUSED size_t ReturnDeviceCreateRenderPipelineAsyncCallbackGetExtraRequiredSize(const ReturnDeviceCreateRenderPipelineAsyncCallbackCmd& record) {\n    DAWN_UNUSED(record);\n\n    size_t result = 0;\n\n\n\n    {\n    result += std::strlen(record.message);\n    }\n\n    {\n    }\n    {\n    }\n    {\n    }\n\n    return result;\n}\n// GetExtraRequiredSize isn't used for structures that are value members of other structures\n// because we assume they cannot contain pointers themselves.\nDAWN_UNUSED_FUNC(ReturnDeviceCreateRenderPipelineAsyncCallbackGetExtraRequiredSize);\n\nDAWN_DECLARE_UNUSED WireResult ReturnDeviceCreateRenderPipelineAsyncCallbackSerialize(\n    const ReturnDeviceCreateRenderPipelineAsyncCallbackCmd& record,\n    ReturnDeviceCreateRenderPipelineAsyncCallbackTransfer* transfer,\n    SerializeBuffer* buffer) {\n    DAWN_UNUSED(buffer);\n\n    transfer->commandId = ReturnWireCmd::DeviceCreateRenderPipelineAsyncCallback;\n\n    transfer->device = record.device;\n    transfer->requestSerial = record.requestSerial;\n    transfer->status = record.status;\n\n\n\n\n    {\n        transfer->messageStrlen = std::strlen(record.message);\n\n        char* stringInBuffer;\n        WIRE_TRY(buffer->NextN(transfer->messageStrlen, &stringInBuffer));\n        memcpy(stringInBuffer, record.message, transfer->messageStrlen);\n    }\n\n    return WireResult::Success;\n}\nDAWN_UNUSED_FUNC(ReturnDeviceCreateRenderPipelineAsyncCallbackSerialize);\n\nDAWN_DECLARE_UNUSED WireResult ReturnDeviceCreateRenderPipelineAsyncCallbackDeserialize(\n    ReturnDeviceCreateRenderPipelineAsyncCallbackCmd* record,\n    const volatile ReturnDeviceCreateRenderPipelineAsyncCallbackTransfer* transfer,\n    DeserializeBuffer* deserializeBuffer,\n    DeserializeAllocator* allocator) {\n    DAWN_UNUSED(allocator);\n\n    ASSERT(transfer->commandId == ReturnWireCmd::DeviceCreateRenderPipelineAsyncCallback);\n\n\n    static_assert(sizeof(record->device) >= sizeof(transfer->device), \"Deserialize assignment may not narrow.\");\nrecord->device = transfer->device;\n    static_assert(sizeof(record->requestSerial) >= sizeof(transfer->requestSerial), \"Deserialize assignment may not narrow.\");\nrecord->requestSerial = transfer->requestSerial;\n    static_assert(sizeof(record->status) >= sizeof(transfer->status), \"Deserialize assignment may not narrow.\");\nrecord->status = transfer->status;\n\n\n\n\n    {\n        uint64_t stringLength64 = transfer->messageStrlen;\n        if (stringLength64 >= std::numeric_limits<size_t>::max()) {\n            return WireResult::FatalError;\n        }\n        size_t stringLength = static_cast<size_t>(stringLength64);\n\n        const volatile char* stringInBuffer;\n        WIRE_TRY(deserializeBuffer->ReadN(stringLength, &stringInBuffer));\n\n        char* copiedString;\n        WIRE_TRY(GetSpace(allocator, stringLength + 1, &copiedString));\n        memcpy(copiedString, const_cast<const char*>(stringInBuffer), stringLength);\n        copiedString[stringLength] = '\\0';\n        record->message = copiedString;\n    }\n\n\n    return WireResult::Success;\n}\nDAWN_UNUSED_FUNC(ReturnDeviceCreateRenderPipelineAsyncCallbackDeserialize);\n\n            \nstruct ReturnDeviceLoggingCallbackTransfer : CmdHeader {\n    static_assert(1 <= 1,\n                  \"Record must be at most one of is_cmd, extensible, and chained.\");\n    ReturnWireCmd commandId;\n\n    \nObjectHandle device;\n    \nWGPULoggingType type;\n\n    uint64_t messageStrlen;\n\n};\n\nstatic_assert(offsetof(ReturnDeviceLoggingCallbackTransfer, commandSize) == 0);\nstatic_assert(offsetof(ReturnDeviceLoggingCallbackTransfer, commandId) == sizeof(CmdHeader));\n\n\nDAWN_DECLARE_UNUSED size_t ReturnDeviceLoggingCallbackGetExtraRequiredSize(const ReturnDeviceLoggingCallbackCmd& record) {\n    DAWN_UNUSED(record);\n\n    size_t result = 0;\n\n\n\n    {\n    result += std::strlen(record.message);\n    }\n\n    {\n    }\n    {\n    }\n\n    return result;\n}\n// GetExtraRequiredSize isn't used for structures that are value members of other structures\n// because we assume they cannot contain pointers themselves.\nDAWN_UNUSED_FUNC(ReturnDeviceLoggingCallbackGetExtraRequiredSize);\n\nDAWN_DECLARE_UNUSED WireResult ReturnDeviceLoggingCallbackSerialize(\n    const ReturnDeviceLoggingCallbackCmd& record,\n    ReturnDeviceLoggingCallbackTransfer* transfer,\n    SerializeBuffer* buffer) {\n    DAWN_UNUSED(buffer);\n\n    transfer->commandId = ReturnWireCmd::DeviceLoggingCallback;\n\n    transfer->device = record.device;\n    transfer->type = record.type;\n\n\n\n\n    {\n        transfer->messageStrlen = std::strlen(record.message);\n\n        char* stringInBuffer;\n        WIRE_TRY(buffer->NextN(transfer->messageStrlen, &stringInBuffer));\n        memcpy(stringInBuffer, record.message, transfer->messageStrlen);\n    }\n\n    return WireResult::Success;\n}\nDAWN_UNUSED_FUNC(ReturnDeviceLoggingCallbackSerialize);\n\nDAWN_DECLARE_UNUSED WireResult ReturnDeviceLoggingCallbackDeserialize(\n    ReturnDeviceLoggingCallbackCmd* record,\n    const volatile ReturnDeviceLoggingCallbackTransfer* transfer,\n    DeserializeBuffer* deserializeBuffer,\n    DeserializeAllocator* allocator) {\n    DAWN_UNUSED(allocator);\n\n    ASSERT(transfer->commandId == ReturnWireCmd::DeviceLoggingCallback);\n\n\n    static_assert(sizeof(record->device) >= sizeof(transfer->device), \"Deserialize assignment may not narrow.\");\nrecord->device = transfer->device;\n    static_assert(sizeof(record->type) >= sizeof(transfer->type), \"Deserialize assignment may not narrow.\");\nrecord->type = transfer->type;\n\n\n\n\n    {\n        uint64_t stringLength64 = transfer->messageStrlen;\n        if (stringLength64 >= std::numeric_limits<size_t>::max()) {\n            return WireResult::FatalError;\n        }\n        size_t stringLength = static_cast<size_t>(stringLength64);\n\n        const volatile char* stringInBuffer;\n        WIRE_TRY(deserializeBuffer->ReadN(stringLength, &stringInBuffer));\n\n        char* copiedString;\n        WIRE_TRY(GetSpace(allocator, stringLength + 1, &copiedString));\n        memcpy(copiedString, const_cast<const char*>(stringInBuffer), stringLength);\n        copiedString[stringLength] = '\\0';\n        record->message = copiedString;\n    }\n\n\n    return WireResult::Success;\n}\nDAWN_UNUSED_FUNC(ReturnDeviceLoggingCallbackDeserialize);\n\n            \nstruct ReturnDeviceLostCallbackTransfer : CmdHeader {\n    static_assert(1 <= 1,\n                  \"Record must be at most one of is_cmd, extensible, and chained.\");\n    ReturnWireCmd commandId;\n\n    \nObjectHandle device;\n    \nWGPUDeviceLostReason reason;\n\n    uint64_t messageStrlen;\n\n};\n\nstatic_assert(offsetof(ReturnDeviceLostCallbackTransfer, commandSize) == 0);\nstatic_assert(offsetof(ReturnDeviceLostCallbackTransfer, commandId) == sizeof(CmdHeader));\n\n\nDAWN_DECLARE_UNUSED size_t ReturnDeviceLostCallbackGetExtraRequiredSize(const ReturnDeviceLostCallbackCmd& record) {\n    DAWN_UNUSED(record);\n\n    size_t result = 0;\n\n\n\n    {\n    result += std::strlen(record.message);\n    }\n\n    {\n    }\n    {\n    }\n\n    return result;\n}\n// GetExtraRequiredSize isn't used for structures that are value members of other structures\n// because we assume they cannot contain pointers themselves.\nDAWN_UNUSED_FUNC(ReturnDeviceLostCallbackGetExtraRequiredSize);\n\nDAWN_DECLARE_UNUSED WireResult ReturnDeviceLostCallbackSerialize(\n    const ReturnDeviceLostCallbackCmd& record,\n    ReturnDeviceLostCallbackTransfer* transfer,\n    SerializeBuffer* buffer) {\n    DAWN_UNUSED(buffer);\n\n    transfer->commandId = ReturnWireCmd::DeviceLostCallback;\n\n    transfer->device = record.device;\n    transfer->reason = record.reason;\n\n\n\n\n    {\n        transfer->messageStrlen = std::strlen(record.message);\n\n        char* stringInBuffer;\n        WIRE_TRY(buffer->NextN(transfer->messageStrlen, &stringInBuffer));\n        memcpy(stringInBuffer, record.message, transfer->messageStrlen);\n    }\n\n    return WireResult::Success;\n}\nDAWN_UNUSED_FUNC(ReturnDeviceLostCallbackSerialize);\n\nDAWN_DECLARE_UNUSED WireResult ReturnDeviceLostCallbackDeserialize(\n    ReturnDeviceLostCallbackCmd* record,\n    const volatile ReturnDeviceLostCallbackTransfer* transfer,\n    DeserializeBuffer* deserializeBuffer,\n    DeserializeAllocator* allocator) {\n    DAWN_UNUSED(allocator);\n\n    ASSERT(transfer->commandId == ReturnWireCmd::DeviceLostCallback);\n\n\n    static_assert(sizeof(record->device) >= sizeof(transfer->device), \"Deserialize assignment may not narrow.\");\nrecord->device = transfer->device;\n    static_assert(sizeof(record->reason) >= sizeof(transfer->reason), \"Deserialize assignment may not narrow.\");\nrecord->reason = transfer->reason;\n\n\n\n\n    {\n        uint64_t stringLength64 = transfer->messageStrlen;\n        if (stringLength64 >= std::numeric_limits<size_t>::max()) {\n            return WireResult::FatalError;\n        }\n        size_t stringLength = static_cast<size_t>(stringLength64);\n\n        const volatile char* stringInBuffer;\n        WIRE_TRY(deserializeBuffer->ReadN(stringLength, &stringInBuffer));\n\n        char* copiedString;\n        WIRE_TRY(GetSpace(allocator, stringLength + 1, &copiedString));\n        memcpy(copiedString, const_cast<const char*>(stringInBuffer), stringLength);\n        copiedString[stringLength] = '\\0';\n        record->message = copiedString;\n    }\n\n\n    return WireResult::Success;\n}\nDAWN_UNUSED_FUNC(ReturnDeviceLostCallbackDeserialize);\n\n            \nstruct ReturnDevicePopErrorScopeCallbackTransfer : CmdHeader {\n    static_assert(1 <= 1,\n                  \"Record must be at most one of is_cmd, extensible, and chained.\");\n    ReturnWireCmd commandId;\n\n    \nObjectHandle device;\n    \nuint64_t requestSerial;\n    \nWGPUErrorType type;\n\n    uint64_t messageStrlen;\n\n};\n\nstatic_assert(offsetof(ReturnDevicePopErrorScopeCallbackTransfer, commandSize) == 0);\nstatic_assert(offsetof(ReturnDevicePopErrorScopeCallbackTransfer, commandId) == sizeof(CmdHeader));\n\n\nDAWN_DECLARE_UNUSED size_t ReturnDevicePopErrorScopeCallbackGetExtraRequiredSize(const ReturnDevicePopErrorScopeCallbackCmd& record) {\n    DAWN_UNUSED(record);\n\n    size_t result = 0;\n\n\n\n    {\n    result += std::strlen(record.message);\n    }\n\n    {\n    }\n    {\n    }\n    {\n    }\n\n    return result;\n}\n// GetExtraRequiredSize isn't used for structures that are value members of other structures\n// because we assume they cannot contain pointers themselves.\nDAWN_UNUSED_FUNC(ReturnDevicePopErrorScopeCallbackGetExtraRequiredSize);\n\nDAWN_DECLARE_UNUSED WireResult ReturnDevicePopErrorScopeCallbackSerialize(\n    const ReturnDevicePopErrorScopeCallbackCmd& record,\n    ReturnDevicePopErrorScopeCallbackTransfer* transfer,\n    SerializeBuffer* buffer) {\n    DAWN_UNUSED(buffer);\n\n    transfer->commandId = ReturnWireCmd::DevicePopErrorScopeCallback;\n\n    transfer->device = record.device;\n    transfer->requestSerial = record.requestSerial;\n    transfer->type = record.type;\n\n\n\n\n    {\n        transfer->messageStrlen = std::strlen(record.message);\n\n        char* stringInBuffer;\n        WIRE_TRY(buffer->NextN(transfer->messageStrlen, &stringInBuffer));\n        memcpy(stringInBuffer, record.message, transfer->messageStrlen);\n    }\n\n    return WireResult::Success;\n}\nDAWN_UNUSED_FUNC(ReturnDevicePopErrorScopeCallbackSerialize);\n\nDAWN_DECLARE_UNUSED WireResult ReturnDevicePopErrorScopeCallbackDeserialize(\n    ReturnDevicePopErrorScopeCallbackCmd* record,\n    const volatile ReturnDevicePopErrorScopeCallbackTransfer* transfer,\n    DeserializeBuffer* deserializeBuffer,\n    DeserializeAllocator* allocator) {\n    DAWN_UNUSED(allocator);\n\n    ASSERT(transfer->commandId == ReturnWireCmd::DevicePopErrorScopeCallback);\n\n\n    static_assert(sizeof(record->device) >= sizeof(transfer->device), \"Deserialize assignment may not narrow.\");\nrecord->device = transfer->device;\n    static_assert(sizeof(record->requestSerial) >= sizeof(transfer->requestSerial), \"Deserialize assignment may not narrow.\");\nrecord->requestSerial = transfer->requestSerial;\n    static_assert(sizeof(record->type) >= sizeof(transfer->type), \"Deserialize assignment may not narrow.\");\nrecord->type = transfer->type;\n\n\n\n\n    {\n        uint64_t stringLength64 = transfer->messageStrlen;\n        if (stringLength64 >= std::numeric_limits<size_t>::max()) {\n            return WireResult::FatalError;\n        }\n        size_t stringLength = static_cast<size_t>(stringLength64);\n\n        const volatile char* stringInBuffer;\n        WIRE_TRY(deserializeBuffer->ReadN(stringLength, &stringInBuffer));\n\n        char* copiedString;\n        WIRE_TRY(GetSpace(allocator, stringLength + 1, &copiedString));\n        memcpy(copiedString, const_cast<const char*>(stringInBuffer), stringLength);\n        copiedString[stringLength] = '\\0';\n        record->message = copiedString;\n    }\n\n\n    return WireResult::Success;\n}\nDAWN_UNUSED_FUNC(ReturnDevicePopErrorScopeCallbackDeserialize);\n\n            \nstruct ReturnDeviceUncapturedErrorCallbackTransfer : CmdHeader {\n    static_assert(1 <= 1,\n                  \"Record must be at most one of is_cmd, extensible, and chained.\");\n    ReturnWireCmd commandId;\n\n    \nObjectHandle device;\n    \nWGPUErrorType type;\n\n    uint64_t messageStrlen;\n\n};\n\nstatic_assert(offsetof(ReturnDeviceUncapturedErrorCallbackTransfer, commandSize) == 0);\nstatic_assert(offsetof(ReturnDeviceUncapturedErrorCallbackTransfer, commandId) == sizeof(CmdHeader));\n\n\nDAWN_DECLARE_UNUSED size_t ReturnDeviceUncapturedErrorCallbackGetExtraRequiredSize(const ReturnDeviceUncapturedErrorCallbackCmd& record) {\n    DAWN_UNUSED(record);\n\n    size_t result = 0;\n\n\n\n    {\n    result += std::strlen(record.message);\n    }\n\n    {\n    }\n    {\n    }\n\n    return result;\n}\n// GetExtraRequiredSize isn't used for structures that are value members of other structures\n// because we assume they cannot contain pointers themselves.\nDAWN_UNUSED_FUNC(ReturnDeviceUncapturedErrorCallbackGetExtraRequiredSize);\n\nDAWN_DECLARE_UNUSED WireResult ReturnDeviceUncapturedErrorCallbackSerialize(\n    const ReturnDeviceUncapturedErrorCallbackCmd& record,\n    ReturnDeviceUncapturedErrorCallbackTransfer* transfer,\n    SerializeBuffer* buffer) {\n    DAWN_UNUSED(buffer);\n\n    transfer->commandId = ReturnWireCmd::DeviceUncapturedErrorCallback;\n\n    transfer->device = record.device;\n    transfer->type = record.type;\n\n\n\n\n    {\n        transfer->messageStrlen = std::strlen(record.message);\n\n        char* stringInBuffer;\n        WIRE_TRY(buffer->NextN(transfer->messageStrlen, &stringInBuffer));\n        memcpy(stringInBuffer, record.message, transfer->messageStrlen);\n    }\n\n    return WireResult::Success;\n}\nDAWN_UNUSED_FUNC(ReturnDeviceUncapturedErrorCallbackSerialize);\n\nDAWN_DECLARE_UNUSED WireResult ReturnDeviceUncapturedErrorCallbackDeserialize(\n    ReturnDeviceUncapturedErrorCallbackCmd* record,\n    const volatile ReturnDeviceUncapturedErrorCallbackTransfer* transfer,\n    DeserializeBuffer* deserializeBuffer,\n    DeserializeAllocator* allocator) {\n    DAWN_UNUSED(allocator);\n\n    ASSERT(transfer->commandId == ReturnWireCmd::DeviceUncapturedErrorCallback);\n\n\n    static_assert(sizeof(record->device) >= sizeof(transfer->device), \"Deserialize assignment may not narrow.\");\nrecord->device = transfer->device;\n    static_assert(sizeof(record->type) >= sizeof(transfer->type), \"Deserialize assignment may not narrow.\");\nrecord->type = transfer->type;\n\n\n\n\n    {\n        uint64_t stringLength64 = transfer->messageStrlen;\n        if (stringLength64 >= std::numeric_limits<size_t>::max()) {\n            return WireResult::FatalError;\n        }\n        size_t stringLength = static_cast<size_t>(stringLength64);\n\n        const volatile char* stringInBuffer;\n        WIRE_TRY(deserializeBuffer->ReadN(stringLength, &stringInBuffer));\n\n        char* copiedString;\n        WIRE_TRY(GetSpace(allocator, stringLength + 1, &copiedString));\n        memcpy(copiedString, const_cast<const char*>(stringInBuffer), stringLength);\n        copiedString[stringLength] = '\\0';\n        record->message = copiedString;\n    }\n\n\n    return WireResult::Success;\n}\nDAWN_UNUSED_FUNC(ReturnDeviceUncapturedErrorCallbackDeserialize);\n\n            \nstruct ReturnInstanceRequestAdapterCallbackTransfer : CmdHeader {\n    static_assert(1 <= 1,\n                  \"Record must be at most one of is_cmd, extensible, and chained.\");\n    ReturnWireCmd commandId;\n\n    \nObjectHandle instance;\n    \nuint64_t requestSerial;\n    \nWGPURequestAdapterStatus status;\n    \nuint32_t featuresCount;\n\n    uint64_t messageStrlen;\n\n    bool has_message;\n    bool has_properties;\n    bool has_limits;\n};\n\nstatic_assert(offsetof(ReturnInstanceRequestAdapterCallbackTransfer, commandSize) == 0);\nstatic_assert(offsetof(ReturnInstanceRequestAdapterCallbackTransfer, commandId) == sizeof(CmdHeader));\n\n\nDAWN_DECLARE_UNUSED size_t ReturnInstanceRequestAdapterCallbackGetExtraRequiredSize(const ReturnInstanceRequestAdapterCallbackCmd& record) {\n    DAWN_UNUSED(record);\n\n    size_t result = 0;\n\n\n\n    bool has_message = record.message != nullptr;\n    if (has_message)\n    {\n    result += std::strlen(record.message);\n    }\n\n    {\n    }\n    {\n    }\n    {\n    }\n    if (record.properties != nullptr)\n    {\n        \n        auto memberLength = 1u;\n        result += memberLength * sizeof(WGPUAdapterPropertiesTransfer);\n        for (decltype(memberLength) i = 0; i < memberLength; ++i) {\n            \n            result += WGPUAdapterPropertiesGetExtraRequiredSize(record.properties[i]);\n        }\n    }\n    if (record.limits != nullptr)\n    {\n        \n        auto memberLength = 1u;\n        result += memberLength * sizeof(WGPUSupportedLimitsTransfer);\n        for (decltype(memberLength) i = 0; i < memberLength; ++i) {\n            \n            result += WGPUSupportedLimitsGetExtraRequiredSize(record.limits[i]);\n        }\n    }\n    {\n    }\n    {\n        \n        auto memberLength = record.featuresCount;\n        result += memberLength * sizeof(\nWGPUFeatureName);\n    }\n\n    return result;\n}\n// GetExtraRequiredSize isn't used for structures that are value members of other structures\n// because we assume they cannot contain pointers themselves.\nDAWN_UNUSED_FUNC(ReturnInstanceRequestAdapterCallbackGetExtraRequiredSize);\n\nDAWN_DECLARE_UNUSED WireResult ReturnInstanceRequestAdapterCallbackSerialize(\n    const ReturnInstanceRequestAdapterCallbackCmd& record,\n    ReturnInstanceRequestAdapterCallbackTransfer* transfer,\n    SerializeBuffer* buffer, const ObjectIdProvider& provider) {\n    DAWN_UNUSED(buffer);\n\n    transfer->commandId = ReturnWireCmd::InstanceRequestAdapterCallback;\n\n    transfer->instance = record.instance;\n    transfer->requestSerial = record.requestSerial;\n    transfer->status = record.status;\n    transfer->featuresCount = record.featuresCount;\n\n\n\n\n    bool has_message = record.message != nullptr;\n    transfer->has_message = has_message;\n    if (has_message)\n    {\n        transfer->messageStrlen = std::strlen(record.message);\n\n        char* stringInBuffer;\n        WIRE_TRY(buffer->NextN(transfer->messageStrlen, &stringInBuffer));\n        memcpy(stringInBuffer, record.message, transfer->messageStrlen);\n    }\n\n    \n\n    bool has_properties = record.properties != nullptr;\n    transfer->has_properties = has_properties;\n    if (has_properties)\n    {\n        auto memberLength = 1u;\n\n        WGPUAdapterPropertiesTransfer* memberBuffer;\n        WIRE_TRY(buffer->NextN(memberLength, &memberBuffer));\n\n        for (decltype(memberLength) i = 0; i < memberLength; ++i) {\n            WIRE_TRY(WGPUAdapterPropertiesSerialize(record.properties[i], &memberBuffer[i], buffer, provider));\n        }\n    }\n    \n\n    bool has_limits = record.limits != nullptr;\n    transfer->has_limits = has_limits;\n    if (has_limits)\n    {\n        auto memberLength = 1u;\n\n        WGPUSupportedLimitsTransfer* memberBuffer;\n        WIRE_TRY(buffer->NextN(memberLength, &memberBuffer));\n\n        for (decltype(memberLength) i = 0; i < memberLength; ++i) {\n            WIRE_TRY(WGPUSupportedLimitsSerialize(record.limits[i], &memberBuffer[i], buffer, provider));\n        }\n    }\n    \n\n    {\n        auto memberLength = record.featuresCount;\n\n        \nWGPUFeatureName* memberBuffer;\n        WIRE_TRY(buffer->NextN(memberLength, &memberBuffer));\n\n        memcpy(\n            memberBuffer, record.features,\n            sizeof(\nWGPUFeatureName) * memberLength);\n    }\n    return WireResult::Success;\n}\nDAWN_UNUSED_FUNC(ReturnInstanceRequestAdapterCallbackSerialize);\n\nDAWN_DECLARE_UNUSED WireResult ReturnInstanceRequestAdapterCallbackDeserialize(\n    ReturnInstanceRequestAdapterCallbackCmd* record,\n    const volatile ReturnInstanceRequestAdapterCallbackTransfer* transfer,\n    DeserializeBuffer* deserializeBuffer,\n    DeserializeAllocator* allocator, const ObjectIdResolver& resolver) {\n    DAWN_UNUSED(allocator);\n\n    ASSERT(transfer->commandId == ReturnWireCmd::InstanceRequestAdapterCallback);\n\n\n    static_assert(sizeof(record->instance) >= sizeof(transfer->instance), \"Deserialize assignment may not narrow.\");\nrecord->instance = transfer->instance;\n    static_assert(sizeof(record->requestSerial) >= sizeof(transfer->requestSerial), \"Deserialize assignment may not narrow.\");\nrecord->requestSerial = transfer->requestSerial;\n    static_assert(sizeof(record->status) >= sizeof(transfer->status), \"Deserialize assignment may not narrow.\");\nrecord->status = transfer->status;\n    static_assert(sizeof(record->featuresCount) >= sizeof(transfer->featuresCount), \"Deserialize assignment may not narrow.\");\nrecord->featuresCount = transfer->featuresCount;\n\n\n\n\n    bool has_message = transfer->has_message;\n    record->message = nullptr;\n    if (has_message)\n    {\n        uint64_t stringLength64 = transfer->messageStrlen;\n        if (stringLength64 >= std::numeric_limits<size_t>::max()) {\n            return WireResult::FatalError;\n        }\n        size_t stringLength = static_cast<size_t>(stringLength64);\n\n        const volatile char* stringInBuffer;\n        WIRE_TRY(deserializeBuffer->ReadN(stringLength, &stringInBuffer));\n\n        char* copiedString;\n        WIRE_TRY(GetSpace(allocator, stringLength + 1, &copiedString));\n        memcpy(copiedString, const_cast<const char*>(stringInBuffer), stringLength);\n        copiedString[stringLength] = '\\0';\n        record->message = copiedString;\n    }\n\n    \n\n    \n    bool has_properties = transfer->has_properties;\n    record->properties = nullptr;\n    if (has_properties)\n    {\n        auto memberLength = 1u;\n        const volatile WGPUAdapterPropertiesTransfer* memberBuffer;\n        WIRE_TRY(deserializeBuffer->ReadN(memberLength, &memberBuffer));\n\n        WGPUAdapterProperties* copiedMembers;\n        WIRE_TRY(GetSpace(allocator, memberLength, &copiedMembers));\n        record->properties = copiedMembers;\n\n        for (decltype(memberLength) i = 0; i < memberLength; ++i) {\n            WIRE_TRY(WGPUAdapterPropertiesDeserialize(&copiedMembers[i], &memberBuffer[i], deserializeBuffer, allocator, resolver));\n        }\n    }\n    \n\n    \n    bool has_limits = transfer->has_limits;\n    record->limits = nullptr;\n    if (has_limits)\n    {\n        auto memberLength = 1u;\n        const volatile WGPUSupportedLimitsTransfer* memberBuffer;\n        WIRE_TRY(deserializeBuffer->ReadN(memberLength, &memberBuffer));\n\n        WGPUSupportedLimits* copiedMembers;\n        WIRE_TRY(GetSpace(allocator, memberLength, &copiedMembers));\n        record->limits = copiedMembers;\n\n        for (decltype(memberLength) i = 0; i < memberLength; ++i) {\n            WIRE_TRY(WGPUSupportedLimitsDeserialize(&copiedMembers[i], &memberBuffer[i], deserializeBuffer, allocator, resolver));\n        }\n    }\n    \n\n    {\n        auto memberLength = record->featuresCount;\n        const volatile \nWGPUFeatureName* memberBuffer;\n        WIRE_TRY(deserializeBuffer->ReadN(memberLength, &memberBuffer));\n\n        WGPUFeatureName* copiedMembers;\n        WIRE_TRY(GetSpace(allocator, memberLength, &copiedMembers));\n        record->features = copiedMembers;\n\n        memcpy(\n            copiedMembers,\n            const_cast<const \nWGPUFeatureName*>(memberBuffer),\n           sizeof(\nWGPUFeatureName) * memberLength);\n    }\n\n    return WireResult::Success;\n}\nDAWN_UNUSED_FUNC(ReturnInstanceRequestAdapterCallbackDeserialize);\n\n            \nstruct ReturnQueueWorkDoneCallbackTransfer : CmdHeader {\n    static_assert(1 <= 1,\n                  \"Record must be at most one of is_cmd, extensible, and chained.\");\n    ReturnWireCmd commandId;\n\n    \nObjectHandle queue;\n    \nuint64_t requestSerial;\n    \nWGPUQueueWorkDoneStatus status;\n\n\n};\n\nstatic_assert(offsetof(ReturnQueueWorkDoneCallbackTransfer, commandSize) == 0);\nstatic_assert(offsetof(ReturnQueueWorkDoneCallbackTransfer, commandId) == sizeof(CmdHeader));\n\n\nDAWN_DECLARE_UNUSED size_t ReturnQueueWorkDoneCallbackGetExtraRequiredSize(const ReturnQueueWorkDoneCallbackCmd& record) {\n    DAWN_UNUSED(record);\n\n    size_t result = 0;\n\n\n\n    {\n    }\n    {\n    }\n    {\n    }\n\n    return result;\n}\n// GetExtraRequiredSize isn't used for structures that are value members of other structures\n// because we assume they cannot contain pointers themselves.\nDAWN_UNUSED_FUNC(ReturnQueueWorkDoneCallbackGetExtraRequiredSize);\n\nDAWN_DECLARE_UNUSED WireResult ReturnQueueWorkDoneCallbackSerialize(\n    const ReturnQueueWorkDoneCallbackCmd& record,\n    ReturnQueueWorkDoneCallbackTransfer* transfer,\n    SerializeBuffer* buffer) {\n    DAWN_UNUSED(buffer);\n\n    transfer->commandId = ReturnWireCmd::QueueWorkDoneCallback;\n\n    transfer->queue = record.queue;\n    transfer->requestSerial = record.requestSerial;\n    transfer->status = record.status;\n\n\n\n\n    return WireResult::Success;\n}\nDAWN_UNUSED_FUNC(ReturnQueueWorkDoneCallbackSerialize);\n\nDAWN_DECLARE_UNUSED WireResult ReturnQueueWorkDoneCallbackDeserialize(\n    ReturnQueueWorkDoneCallbackCmd* record,\n    const volatile ReturnQueueWorkDoneCallbackTransfer* transfer,\n    DeserializeBuffer* deserializeBuffer,\n    DeserializeAllocator* allocator) {\n    DAWN_UNUSED(allocator);\n\n    ASSERT(transfer->commandId == ReturnWireCmd::QueueWorkDoneCallback);\n\n\n    static_assert(sizeof(record->queue) >= sizeof(transfer->queue), \"Deserialize assignment may not narrow.\");\nrecord->queue = transfer->queue;\n    static_assert(sizeof(record->requestSerial) >= sizeof(transfer->requestSerial), \"Deserialize assignment may not narrow.\");\nrecord->requestSerial = transfer->requestSerial;\n    static_assert(sizeof(record->status) >= sizeof(transfer->status), \"Deserialize assignment may not narrow.\");\nrecord->status = transfer->status;\n\n\n\n\n\n    return WireResult::Success;\n}\nDAWN_UNUSED_FUNC(ReturnQueueWorkDoneCallbackDeserialize);\n\n            \nstruct ReturnShaderModuleGetCompilationInfoCallbackTransfer : CmdHeader {\n    static_assert(1 <= 1,\n                  \"Record must be at most one of is_cmd, extensible, and chained.\");\n    ReturnWireCmd commandId;\n\n    \nObjectHandle shaderModule;\n    \nuint64_t requestSerial;\n    \nWGPUCompilationInfoRequestStatus status;\n\n\n    bool has_info;\n};\n\nstatic_assert(offsetof(ReturnShaderModuleGetCompilationInfoCallbackTransfer, commandSize) == 0);\nstatic_assert(offsetof(ReturnShaderModuleGetCompilationInfoCallbackTransfer, commandId) == sizeof(CmdHeader));\n\n\nDAWN_DECLARE_UNUSED size_t ReturnShaderModuleGetCompilationInfoCallbackGetExtraRequiredSize(const ReturnShaderModuleGetCompilationInfoCallbackCmd& record) {\n    DAWN_UNUSED(record);\n\n    size_t result = 0;\n\n\n\n    {\n    }\n    {\n    }\n    {\n    }\n    if (record.info != nullptr)\n    {\n        \n        auto memberLength = 1u;\n        result += memberLength * sizeof(WGPUCompilationInfoTransfer);\n        for (decltype(memberLength) i = 0; i < memberLength; ++i) {\n            \n            result += WGPUCompilationInfoGetExtraRequiredSize(record.info[i]);\n        }\n    }\n\n    return result;\n}\n// GetExtraRequiredSize isn't used for structures that are value members of other structures\n// because we assume they cannot contain pointers themselves.\nDAWN_UNUSED_FUNC(ReturnShaderModuleGetCompilationInfoCallbackGetExtraRequiredSize);\n\nDAWN_DECLARE_UNUSED WireResult ReturnShaderModuleGetCompilationInfoCallbackSerialize(\n    const ReturnShaderModuleGetCompilationInfoCallbackCmd& record,\n    ReturnShaderModuleGetCompilationInfoCallbackTransfer* transfer,\n    SerializeBuffer* buffer, const ObjectIdProvider& provider) {\n    DAWN_UNUSED(buffer);\n\n    transfer->commandId = ReturnWireCmd::ShaderModuleGetCompilationInfoCallback;\n\n    transfer->shaderModule = record.shaderModule;\n    transfer->requestSerial = record.requestSerial;\n    transfer->status = record.status;\n\n\n\n\n    \n\n    bool has_info = record.info != nullptr;\n    transfer->has_info = has_info;\n    if (has_info)\n    {\n        auto memberLength = 1u;\n\n        WGPUCompilationInfoTransfer* memberBuffer;\n        WIRE_TRY(buffer->NextN(memberLength, &memberBuffer));\n\n        for (decltype(memberLength) i = 0; i < memberLength; ++i) {\n            WIRE_TRY(WGPUCompilationInfoSerialize(record.info[i], &memberBuffer[i], buffer, provider));\n        }\n    }\n    return WireResult::Success;\n}\nDAWN_UNUSED_FUNC(ReturnShaderModuleGetCompilationInfoCallbackSerialize);\n\nDAWN_DECLARE_UNUSED WireResult ReturnShaderModuleGetCompilationInfoCallbackDeserialize(\n    ReturnShaderModuleGetCompilationInfoCallbackCmd* record,\n    const volatile ReturnShaderModuleGetCompilationInfoCallbackTransfer* transfer,\n    DeserializeBuffer* deserializeBuffer,\n    DeserializeAllocator* allocator, const ObjectIdResolver& resolver) {\n    DAWN_UNUSED(allocator);\n\n    ASSERT(transfer->commandId == ReturnWireCmd::ShaderModuleGetCompilationInfoCallback);\n\n\n    static_assert(sizeof(record->shaderModule) >= sizeof(transfer->shaderModule), \"Deserialize assignment may not narrow.\");\nrecord->shaderModule = transfer->shaderModule;\n    static_assert(sizeof(record->requestSerial) >= sizeof(transfer->requestSerial), \"Deserialize assignment may not narrow.\");\nrecord->requestSerial = transfer->requestSerial;\n    static_assert(sizeof(record->status) >= sizeof(transfer->status), \"Deserialize assignment may not narrow.\");\nrecord->status = transfer->status;\n\n\n\n\n    \n\n    \n    bool has_info = transfer->has_info;\n    record->info = nullptr;\n    if (has_info)\n    {\n        auto memberLength = 1u;\n        const volatile WGPUCompilationInfoTransfer* memberBuffer;\n        WIRE_TRY(deserializeBuffer->ReadN(memberLength, &memberBuffer));\n\n        WGPUCompilationInfo* copiedMembers;\n        WIRE_TRY(GetSpace(allocator, memberLength, &copiedMembers));\n        record->info = copiedMembers;\n\n        for (decltype(memberLength) i = 0; i < memberLength; ++i) {\n            WIRE_TRY(WGPUCompilationInfoDeserialize(&copiedMembers[i], &memberBuffer[i], deserializeBuffer, allocator, resolver));\n        }\n    }\n\n    return WireResult::Success;\n}\nDAWN_UNUSED_FUNC(ReturnShaderModuleGetCompilationInfoCallbackDeserialize);\n\n\n        // Implementation of ObjectIdResolver that always errors.\n        // Used when the generator adds a provider argument because of a chained\n        // struct, but in practice, a chained struct in that location is invalid.\n        class ErrorObjectIdResolver final : public ObjectIdResolver {\n            public:\n                    WireResult GetFromId(ObjectId id, WGPUAdapter* out) const override {\n                        return WireResult::FatalError;\n                    }\n                    WireResult GetOptionalFromId(ObjectId id, WGPUAdapter* out) const override {\n                        return WireResult::FatalError;\n                    }\n                    WireResult GetFromId(ObjectId id, WGPUBindGroup* out) const override {\n                        return WireResult::FatalError;\n                    }\n                    WireResult GetOptionalFromId(ObjectId id, WGPUBindGroup* out) const override {\n                        return WireResult::FatalError;\n                    }\n                    WireResult GetFromId(ObjectId id, WGPUBindGroupLayout* out) const override {\n                        return WireResult::FatalError;\n                    }\n                    WireResult GetOptionalFromId(ObjectId id, WGPUBindGroupLayout* out) const override {\n                        return WireResult::FatalError;\n                    }\n                    WireResult GetFromId(ObjectId id, WGPUBuffer* out) const override {\n                        return WireResult::FatalError;\n                    }\n                    WireResult GetOptionalFromId(ObjectId id, WGPUBuffer* out) const override {\n                        return WireResult::FatalError;\n                    }\n                    WireResult GetFromId(ObjectId id, WGPUCommandBuffer* out) const override {\n                        return WireResult::FatalError;\n                    }\n                    WireResult GetOptionalFromId(ObjectId id, WGPUCommandBuffer* out) const override {\n                        return WireResult::FatalError;\n                    }\n                    WireResult GetFromId(ObjectId id, WGPUCommandEncoder* out) const override {\n                        return WireResult::FatalError;\n                    }\n                    WireResult GetOptionalFromId(ObjectId id, WGPUCommandEncoder* out) const override {\n                        return WireResult::FatalError;\n                    }\n                    WireResult GetFromId(ObjectId id, WGPUComputePassEncoder* out) const override {\n                        return WireResult::FatalError;\n                    }\n                    WireResult GetOptionalFromId(ObjectId id, WGPUComputePassEncoder* out) const override {\n                        return WireResult::FatalError;\n                    }\n                    WireResult GetFromId(ObjectId id, WGPUComputePipeline* out) const override {\n                        return WireResult::FatalError;\n                    }\n                    WireResult GetOptionalFromId(ObjectId id, WGPUComputePipeline* out) const override {\n                        return WireResult::FatalError;\n                    }\n                    WireResult GetFromId(ObjectId id, WGPUDevice* out) const override {\n                        return WireResult::FatalError;\n                    }\n                    WireResult GetOptionalFromId(ObjectId id, WGPUDevice* out) const override {\n                        return WireResult::FatalError;\n                    }\n                    WireResult GetFromId(ObjectId id, WGPUExternalTexture* out) const override {\n                        return WireResult::FatalError;\n                    }\n                    WireResult GetOptionalFromId(ObjectId id, WGPUExternalTexture* out) const override {\n                        return WireResult::FatalError;\n                    }\n                    WireResult GetFromId(ObjectId id, WGPUInstance* out) const override {\n                        return WireResult::FatalError;\n                    }\n                    WireResult GetOptionalFromId(ObjectId id, WGPUInstance* out) const override {\n                        return WireResult::FatalError;\n                    }\n                    WireResult GetFromId(ObjectId id, WGPUPipelineLayout* out) const override {\n                        return WireResult::FatalError;\n                    }\n                    WireResult GetOptionalFromId(ObjectId id, WGPUPipelineLayout* out) const override {\n                        return WireResult::FatalError;\n                    }\n                    WireResult GetFromId(ObjectId id, WGPUQuerySet* out) const override {\n                        return WireResult::FatalError;\n                    }\n                    WireResult GetOptionalFromId(ObjectId id, WGPUQuerySet* out) const override {\n                        return WireResult::FatalError;\n                    }\n                    WireResult GetFromId(ObjectId id, WGPUQueue* out) const override {\n                        return WireResult::FatalError;\n                    }\n                    WireResult GetOptionalFromId(ObjectId id, WGPUQueue* out) const override {\n                        return WireResult::FatalError;\n                    }\n                    WireResult GetFromId(ObjectId id, WGPURenderBundle* out) const override {\n                        return WireResult::FatalError;\n                    }\n                    WireResult GetOptionalFromId(ObjectId id, WGPURenderBundle* out) const override {\n                        return WireResult::FatalError;\n                    }\n                    WireResult GetFromId(ObjectId id, WGPURenderBundleEncoder* out) const override {\n                        return WireResult::FatalError;\n                    }\n                    WireResult GetOptionalFromId(ObjectId id, WGPURenderBundleEncoder* out) const override {\n                        return WireResult::FatalError;\n                    }\n                    WireResult GetFromId(ObjectId id, WGPURenderPassEncoder* out) const override {\n                        return WireResult::FatalError;\n                    }\n                    WireResult GetOptionalFromId(ObjectId id, WGPURenderPassEncoder* out) const override {\n                        return WireResult::FatalError;\n                    }\n                    WireResult GetFromId(ObjectId id, WGPURenderPipeline* out) const override {\n                        return WireResult::FatalError;\n                    }\n                    WireResult GetOptionalFromId(ObjectId id, WGPURenderPipeline* out) const override {\n                        return WireResult::FatalError;\n                    }\n                    WireResult GetFromId(ObjectId id, WGPUSampler* out) const override {\n                        return WireResult::FatalError;\n                    }\n                    WireResult GetOptionalFromId(ObjectId id, WGPUSampler* out) const override {\n                        return WireResult::FatalError;\n                    }\n                    WireResult GetFromId(ObjectId id, WGPUShaderModule* out) const override {\n                        return WireResult::FatalError;\n                    }\n                    WireResult GetOptionalFromId(ObjectId id, WGPUShaderModule* out) const override {\n                        return WireResult::FatalError;\n                    }\n                    WireResult GetFromId(ObjectId id, WGPUSurface* out) const override {\n                        return WireResult::FatalError;\n                    }\n                    WireResult GetOptionalFromId(ObjectId id, WGPUSurface* out) const override {\n                        return WireResult::FatalError;\n                    }\n                    WireResult GetFromId(ObjectId id, WGPUSwapChain* out) const override {\n                        return WireResult::FatalError;\n                    }\n                    WireResult GetOptionalFromId(ObjectId id, WGPUSwapChain* out) const override {\n                        return WireResult::FatalError;\n                    }\n                    WireResult GetFromId(ObjectId id, WGPUTexture* out) const override {\n                        return WireResult::FatalError;\n                    }\n                    WireResult GetOptionalFromId(ObjectId id, WGPUTexture* out) const override {\n                        return WireResult::FatalError;\n                    }\n                    WireResult GetFromId(ObjectId id, WGPUTextureView* out) const override {\n                        return WireResult::FatalError;\n                    }\n                    WireResult GetOptionalFromId(ObjectId id, WGPUTextureView* out) const override {\n                        return WireResult::FatalError;\n                    }\n        };\n\n        // Implementation of ObjectIdProvider that always errors.\n        // Used when the generator adds a provider argument because of a chained\n        // struct, but in practice, a chained struct in that location is invalid.\n        class ErrorObjectIdProvider final : public ObjectIdProvider {\n            public:\n                    WireResult GetId(WGPUAdapter object, ObjectId* out) const override {\n                        return WireResult::FatalError;\n                    }\n                    WireResult GetOptionalId(WGPUAdapter object, ObjectId* out) const override {\n                        return WireResult::FatalError;\n                    }\n                    WireResult GetId(WGPUBindGroup object, ObjectId* out) const override {\n                        return WireResult::FatalError;\n                    }\n                    WireResult GetOptionalId(WGPUBindGroup object, ObjectId* out) const override {\n                        return WireResult::FatalError;\n                    }\n                    WireResult GetId(WGPUBindGroupLayout object, ObjectId* out) const override {\n                        return WireResult::FatalError;\n                    }\n                    WireResult GetOptionalId(WGPUBindGroupLayout object, ObjectId* out) const override {\n                        return WireResult::FatalError;\n                    }\n                    WireResult GetId(WGPUBuffer object, ObjectId* out) const override {\n                        return WireResult::FatalError;\n                    }\n                    WireResult GetOptionalId(WGPUBuffer object, ObjectId* out) const override {\n                        return WireResult::FatalError;\n                    }\n                    WireResult GetId(WGPUCommandBuffer object, ObjectId* out) const override {\n                        return WireResult::FatalError;\n                    }\n                    WireResult GetOptionalId(WGPUCommandBuffer object, ObjectId* out) const override {\n                        return WireResult::FatalError;\n                    }\n                    WireResult GetId(WGPUCommandEncoder object, ObjectId* out) const override {\n                        return WireResult::FatalError;\n                    }\n                    WireResult GetOptionalId(WGPUCommandEncoder object, ObjectId* out) const override {\n                        return WireResult::FatalError;\n                    }\n                    WireResult GetId(WGPUComputePassEncoder object, ObjectId* out) const override {\n                        return WireResult::FatalError;\n                    }\n                    WireResult GetOptionalId(WGPUComputePassEncoder object, ObjectId* out) const override {\n                        return WireResult::FatalError;\n                    }\n                    WireResult GetId(WGPUComputePipeline object, ObjectId* out) const override {\n                        return WireResult::FatalError;\n                    }\n                    WireResult GetOptionalId(WGPUComputePipeline object, ObjectId* out) const override {\n                        return WireResult::FatalError;\n                    }\n                    WireResult GetId(WGPUDevice object, ObjectId* out) const override {\n                        return WireResult::FatalError;\n                    }\n                    WireResult GetOptionalId(WGPUDevice object, ObjectId* out) const override {\n                        return WireResult::FatalError;\n                    }\n                    WireResult GetId(WGPUExternalTexture object, ObjectId* out) const override {\n                        return WireResult::FatalError;\n                    }\n                    WireResult GetOptionalId(WGPUExternalTexture object, ObjectId* out) const override {\n                        return WireResult::FatalError;\n                    }\n                    WireResult GetId(WGPUInstance object, ObjectId* out) const override {\n                        return WireResult::FatalError;\n                    }\n                    WireResult GetOptionalId(WGPUInstance object, ObjectId* out) const override {\n                        return WireResult::FatalError;\n                    }\n                    WireResult GetId(WGPUPipelineLayout object, ObjectId* out) const override {\n                        return WireResult::FatalError;\n                    }\n                    WireResult GetOptionalId(WGPUPipelineLayout object, ObjectId* out) const override {\n                        return WireResult::FatalError;\n                    }\n                    WireResult GetId(WGPUQuerySet object, ObjectId* out) const override {\n                        return WireResult::FatalError;\n                    }\n                    WireResult GetOptionalId(WGPUQuerySet object, ObjectId* out) const override {\n                        return WireResult::FatalError;\n                    }\n                    WireResult GetId(WGPUQueue object, ObjectId* out) const override {\n                        return WireResult::FatalError;\n                    }\n                    WireResult GetOptionalId(WGPUQueue object, ObjectId* out) const override {\n                        return WireResult::FatalError;\n                    }\n                    WireResult GetId(WGPURenderBundle object, ObjectId* out) const override {\n                        return WireResult::FatalError;\n                    }\n                    WireResult GetOptionalId(WGPURenderBundle object, ObjectId* out) const override {\n                        return WireResult::FatalError;\n                    }\n                    WireResult GetId(WGPURenderBundleEncoder object, ObjectId* out) const override {\n                        return WireResult::FatalError;\n                    }\n                    WireResult GetOptionalId(WGPURenderBundleEncoder object, ObjectId* out) const override {\n                        return WireResult::FatalError;\n                    }\n                    WireResult GetId(WGPURenderPassEncoder object, ObjectId* out) const override {\n                        return WireResult::FatalError;\n                    }\n                    WireResult GetOptionalId(WGPURenderPassEncoder object, ObjectId* out) const override {\n                        return WireResult::FatalError;\n                    }\n                    WireResult GetId(WGPURenderPipeline object, ObjectId* out) const override {\n                        return WireResult::FatalError;\n                    }\n                    WireResult GetOptionalId(WGPURenderPipeline object, ObjectId* out) const override {\n                        return WireResult::FatalError;\n                    }\n                    WireResult GetId(WGPUSampler object, ObjectId* out) const override {\n                        return WireResult::FatalError;\n                    }\n                    WireResult GetOptionalId(WGPUSampler object, ObjectId* out) const override {\n                        return WireResult::FatalError;\n                    }\n                    WireResult GetId(WGPUShaderModule object, ObjectId* out) const override {\n                        return WireResult::FatalError;\n                    }\n                    WireResult GetOptionalId(WGPUShaderModule object, ObjectId* out) const override {\n                        return WireResult::FatalError;\n                    }\n                    WireResult GetId(WGPUSurface object, ObjectId* out) const override {\n                        return WireResult::FatalError;\n                    }\n                    WireResult GetOptionalId(WGPUSurface object, ObjectId* out) const override {\n                        return WireResult::FatalError;\n                    }\n                    WireResult GetId(WGPUSwapChain object, ObjectId* out) const override {\n                        return WireResult::FatalError;\n                    }\n                    WireResult GetOptionalId(WGPUSwapChain object, ObjectId* out) const override {\n                        return WireResult::FatalError;\n                    }\n                    WireResult GetId(WGPUTexture object, ObjectId* out) const override {\n                        return WireResult::FatalError;\n                    }\n                    WireResult GetOptionalId(WGPUTexture object, ObjectId* out) const override {\n                        return WireResult::FatalError;\n                    }\n                    WireResult GetId(WGPUTextureView object, ObjectId* out) const override {\n                        return WireResult::FatalError;\n                    }\n                    WireResult GetOptionalId(WGPUTextureView object, ObjectId* out) const override {\n                        return WireResult::FatalError;\n                    }\n        };\n\n    }  // anonymous namespace\n\n        \nsize_t AdapterRequestDeviceCmd::GetRequiredSize() const {\n    size_t size = sizeof(AdapterRequestDeviceTransfer) + AdapterRequestDeviceGetExtraRequiredSize(*this);\n    return size;\n}\n\nWireResult AdapterRequestDeviceCmd::Serialize(\n    size_t commandSize,\n    SerializeBuffer* buffer,\n    const ObjectIdProvider& provider\n) const {\n    AdapterRequestDeviceTransfer* transfer;\n    WIRE_TRY(buffer->Next(&transfer));\n    transfer->commandSize = commandSize;\n    return (AdapterRequestDeviceSerialize(*this, transfer, buffer, provider));\n}\nWireResult AdapterRequestDeviceCmd::Serialize(size_t commandSize, SerializeBuffer* buffer) const {\n    ErrorObjectIdProvider provider;\n    return Serialize(commandSize, buffer, provider);\n}\n\nWireResult AdapterRequestDeviceCmd::Deserialize(\n    DeserializeBuffer* deserializeBuffer,\n    DeserializeAllocator* allocator,\n    const ObjectIdResolver& resolver\n) {\n    const volatile AdapterRequestDeviceTransfer* transfer;\n    WIRE_TRY(deserializeBuffer->Read(&transfer));\n    return AdapterRequestDeviceDeserialize(this, transfer, deserializeBuffer, allocator, resolver);\n}\nWireResult AdapterRequestDeviceCmd::Deserialize(DeserializeBuffer* deserializeBuffer, DeserializeAllocator* allocator) {\n    ErrorObjectIdResolver resolver;\n    return Deserialize(deserializeBuffer, allocator, resolver);\n}\n\n        \nsize_t BindGroupLayoutSetLabelCmd::GetRequiredSize() const {\n    size_t size = sizeof(BindGroupLayoutSetLabelTransfer) + BindGroupLayoutSetLabelGetExtraRequiredSize(*this);\n    return size;\n}\n\nWireResult BindGroupLayoutSetLabelCmd::Serialize(\n    size_t commandSize,\n    SerializeBuffer* buffer,\n    const ObjectIdProvider& provider\n) const {\n    BindGroupLayoutSetLabelTransfer* transfer;\n    WIRE_TRY(buffer->Next(&transfer));\n    transfer->commandSize = commandSize;\n    return (BindGroupLayoutSetLabelSerialize(*this, transfer, buffer, provider));\n}\nWireResult BindGroupLayoutSetLabelCmd::Serialize(size_t commandSize, SerializeBuffer* buffer) const {\n    ErrorObjectIdProvider provider;\n    return Serialize(commandSize, buffer, provider);\n}\n\nWireResult BindGroupLayoutSetLabelCmd::Deserialize(\n    DeserializeBuffer* deserializeBuffer,\n    DeserializeAllocator* allocator,\n    const ObjectIdResolver& resolver\n) {\n    const volatile BindGroupLayoutSetLabelTransfer* transfer;\n    WIRE_TRY(deserializeBuffer->Read(&transfer));\n    return BindGroupLayoutSetLabelDeserialize(this, transfer, deserializeBuffer, allocator, resolver);\n}\nWireResult BindGroupLayoutSetLabelCmd::Deserialize(DeserializeBuffer* deserializeBuffer, DeserializeAllocator* allocator) {\n    ErrorObjectIdResolver resolver;\n    return Deserialize(deserializeBuffer, allocator, resolver);\n}\n\n        \nsize_t BindGroupSetLabelCmd::GetRequiredSize() const {\n    size_t size = sizeof(BindGroupSetLabelTransfer) + BindGroupSetLabelGetExtraRequiredSize(*this);\n    return size;\n}\n\nWireResult BindGroupSetLabelCmd::Serialize(\n    size_t commandSize,\n    SerializeBuffer* buffer,\n    const ObjectIdProvider& provider\n) const {\n    BindGroupSetLabelTransfer* transfer;\n    WIRE_TRY(buffer->Next(&transfer));\n    transfer->commandSize = commandSize;\n    return (BindGroupSetLabelSerialize(*this, transfer, buffer, provider));\n}\nWireResult BindGroupSetLabelCmd::Serialize(size_t commandSize, SerializeBuffer* buffer) const {\n    ErrorObjectIdProvider provider;\n    return Serialize(commandSize, buffer, provider);\n}\n\nWireResult BindGroupSetLabelCmd::Deserialize(\n    DeserializeBuffer* deserializeBuffer,\n    DeserializeAllocator* allocator,\n    const ObjectIdResolver& resolver\n) {\n    const volatile BindGroupSetLabelTransfer* transfer;\n    WIRE_TRY(deserializeBuffer->Read(&transfer));\n    return BindGroupSetLabelDeserialize(this, transfer, deserializeBuffer, allocator, resolver);\n}\nWireResult BindGroupSetLabelCmd::Deserialize(DeserializeBuffer* deserializeBuffer, DeserializeAllocator* allocator) {\n    ErrorObjectIdResolver resolver;\n    return Deserialize(deserializeBuffer, allocator, resolver);\n}\n\n        \nsize_t BufferDestroyCmd::GetRequiredSize() const {\n    size_t size = sizeof(BufferDestroyTransfer) + BufferDestroyGetExtraRequiredSize(*this);\n    return size;\n}\n\nWireResult BufferDestroyCmd::Serialize(\n    size_t commandSize,\n    SerializeBuffer* buffer,\n    const ObjectIdProvider& provider\n) const {\n    BufferDestroyTransfer* transfer;\n    WIRE_TRY(buffer->Next(&transfer));\n    transfer->commandSize = commandSize;\n    return (BufferDestroySerialize(*this, transfer, buffer, provider));\n}\nWireResult BufferDestroyCmd::Serialize(size_t commandSize, SerializeBuffer* buffer) const {\n    ErrorObjectIdProvider provider;\n    return Serialize(commandSize, buffer, provider);\n}\n\nWireResult BufferDestroyCmd::Deserialize(\n    DeserializeBuffer* deserializeBuffer,\n    DeserializeAllocator* allocator,\n    const ObjectIdResolver& resolver\n) {\n    const volatile BufferDestroyTransfer* transfer;\n    WIRE_TRY(deserializeBuffer->Read(&transfer));\n    return BufferDestroyDeserialize(this, transfer, deserializeBuffer, allocator, resolver);\n}\nWireResult BufferDestroyCmd::Deserialize(DeserializeBuffer* deserializeBuffer, DeserializeAllocator* allocator) {\n    ErrorObjectIdResolver resolver;\n    return Deserialize(deserializeBuffer, allocator, resolver);\n}\n\n        \nsize_t BufferMapAsyncCmd::GetRequiredSize() const {\n    size_t size = sizeof(BufferMapAsyncTransfer) + BufferMapAsyncGetExtraRequiredSize(*this);\n    return size;\n}\n\nWireResult BufferMapAsyncCmd::Serialize(size_t commandSize, SerializeBuffer* buffer) const {\n    BufferMapAsyncTransfer* transfer;\n    WIRE_TRY(buffer->Next(&transfer));\n    transfer->commandSize = commandSize;\n    return (BufferMapAsyncSerialize(*this, transfer, buffer));\n}\nWireResult BufferMapAsyncCmd::Serialize(\n    size_t commandSize,\n    SerializeBuffer* buffer,\n    const ObjectIdProvider&\n) const {\n    return Serialize(commandSize, buffer);\n}\n\nWireResult BufferMapAsyncCmd::Deserialize(DeserializeBuffer* deserializeBuffer, DeserializeAllocator* allocator) {\n    const volatile BufferMapAsyncTransfer* transfer;\n    WIRE_TRY(deserializeBuffer->Read(&transfer));\n    return BufferMapAsyncDeserialize(this, transfer, deserializeBuffer, allocator);\n}\nWireResult BufferMapAsyncCmd::Deserialize(\n    DeserializeBuffer* deserializeBuffer,\n    DeserializeAllocator* allocator,\n    const ObjectIdResolver&\n) {\n    return Deserialize(deserializeBuffer, allocator);\n}\n\n        \nsize_t BufferSetLabelCmd::GetRequiredSize() const {\n    size_t size = sizeof(BufferSetLabelTransfer) + BufferSetLabelGetExtraRequiredSize(*this);\n    return size;\n}\n\nWireResult BufferSetLabelCmd::Serialize(\n    size_t commandSize,\n    SerializeBuffer* buffer,\n    const ObjectIdProvider& provider\n) const {\n    BufferSetLabelTransfer* transfer;\n    WIRE_TRY(buffer->Next(&transfer));\n    transfer->commandSize = commandSize;\n    return (BufferSetLabelSerialize(*this, transfer, buffer, provider));\n}\nWireResult BufferSetLabelCmd::Serialize(size_t commandSize, SerializeBuffer* buffer) const {\n    ErrorObjectIdProvider provider;\n    return Serialize(commandSize, buffer, provider);\n}\n\nWireResult BufferSetLabelCmd::Deserialize(\n    DeserializeBuffer* deserializeBuffer,\n    DeserializeAllocator* allocator,\n    const ObjectIdResolver& resolver\n) {\n    const volatile BufferSetLabelTransfer* transfer;\n    WIRE_TRY(deserializeBuffer->Read(&transfer));\n    return BufferSetLabelDeserialize(this, transfer, deserializeBuffer, allocator, resolver);\n}\nWireResult BufferSetLabelCmd::Deserialize(DeserializeBuffer* deserializeBuffer, DeserializeAllocator* allocator) {\n    ErrorObjectIdResolver resolver;\n    return Deserialize(deserializeBuffer, allocator, resolver);\n}\n\n        \nsize_t BufferUnmapCmd::GetRequiredSize() const {\n    size_t size = sizeof(BufferUnmapTransfer) + BufferUnmapGetExtraRequiredSize(*this);\n    return size;\n}\n\nWireResult BufferUnmapCmd::Serialize(\n    size_t commandSize,\n    SerializeBuffer* buffer,\n    const ObjectIdProvider& provider\n) const {\n    BufferUnmapTransfer* transfer;\n    WIRE_TRY(buffer->Next(&transfer));\n    transfer->commandSize = commandSize;\n    return (BufferUnmapSerialize(*this, transfer, buffer, provider));\n}\nWireResult BufferUnmapCmd::Serialize(size_t commandSize, SerializeBuffer* buffer) const {\n    ErrorObjectIdProvider provider;\n    return Serialize(commandSize, buffer, provider);\n}\n\nWireResult BufferUnmapCmd::Deserialize(\n    DeserializeBuffer* deserializeBuffer,\n    DeserializeAllocator* allocator,\n    const ObjectIdResolver& resolver\n) {\n    const volatile BufferUnmapTransfer* transfer;\n    WIRE_TRY(deserializeBuffer->Read(&transfer));\n    return BufferUnmapDeserialize(this, transfer, deserializeBuffer, allocator, resolver);\n}\nWireResult BufferUnmapCmd::Deserialize(DeserializeBuffer* deserializeBuffer, DeserializeAllocator* allocator) {\n    ErrorObjectIdResolver resolver;\n    return Deserialize(deserializeBuffer, allocator, resolver);\n}\n\n        \nsize_t BufferUpdateMappedDataCmd::GetRequiredSize() const {\n    size_t size = sizeof(BufferUpdateMappedDataTransfer) + BufferUpdateMappedDataGetExtraRequiredSize(*this);\n    return size;\n}\n\nWireResult BufferUpdateMappedDataCmd::Serialize(size_t commandSize, SerializeBuffer* buffer) const {\n    BufferUpdateMappedDataTransfer* transfer;\n    WIRE_TRY(buffer->Next(&transfer));\n    transfer->commandSize = commandSize;\n    return (BufferUpdateMappedDataSerialize(*this, transfer, buffer));\n}\nWireResult BufferUpdateMappedDataCmd::Serialize(\n    size_t commandSize,\n    SerializeBuffer* buffer,\n    const ObjectIdProvider&\n) const {\n    return Serialize(commandSize, buffer);\n}\n\nWireResult BufferUpdateMappedDataCmd::Deserialize(DeserializeBuffer* deserializeBuffer, DeserializeAllocator* allocator) {\n    const volatile BufferUpdateMappedDataTransfer* transfer;\n    WIRE_TRY(deserializeBuffer->Read(&transfer));\n    return BufferUpdateMappedDataDeserialize(this, transfer, deserializeBuffer, allocator);\n}\nWireResult BufferUpdateMappedDataCmd::Deserialize(\n    DeserializeBuffer* deserializeBuffer,\n    DeserializeAllocator* allocator,\n    const ObjectIdResolver&\n) {\n    return Deserialize(deserializeBuffer, allocator);\n}\n\n        \nsize_t CommandBufferSetLabelCmd::GetRequiredSize() const {\n    size_t size = sizeof(CommandBufferSetLabelTransfer) + CommandBufferSetLabelGetExtraRequiredSize(*this);\n    return size;\n}\n\nWireResult CommandBufferSetLabelCmd::Serialize(\n    size_t commandSize,\n    SerializeBuffer* buffer,\n    const ObjectIdProvider& provider\n) const {\n    CommandBufferSetLabelTransfer* transfer;\n    WIRE_TRY(buffer->Next(&transfer));\n    transfer->commandSize = commandSize;\n    return (CommandBufferSetLabelSerialize(*this, transfer, buffer, provider));\n}\nWireResult CommandBufferSetLabelCmd::Serialize(size_t commandSize, SerializeBuffer* buffer) const {\n    ErrorObjectIdProvider provider;\n    return Serialize(commandSize, buffer, provider);\n}\n\nWireResult CommandBufferSetLabelCmd::Deserialize(\n    DeserializeBuffer* deserializeBuffer,\n    DeserializeAllocator* allocator,\n    const ObjectIdResolver& resolver\n) {\n    const volatile CommandBufferSetLabelTransfer* transfer;\n    WIRE_TRY(deserializeBuffer->Read(&transfer));\n    return CommandBufferSetLabelDeserialize(this, transfer, deserializeBuffer, allocator, resolver);\n}\nWireResult CommandBufferSetLabelCmd::Deserialize(DeserializeBuffer* deserializeBuffer, DeserializeAllocator* allocator) {\n    ErrorObjectIdResolver resolver;\n    return Deserialize(deserializeBuffer, allocator, resolver);\n}\n\n        \nsize_t CommandEncoderBeginComputePassCmd::GetRequiredSize() const {\n    size_t size = sizeof(CommandEncoderBeginComputePassTransfer) + CommandEncoderBeginComputePassGetExtraRequiredSize(*this);\n    return size;\n}\n\nWireResult CommandEncoderBeginComputePassCmd::Serialize(\n    size_t commandSize,\n    SerializeBuffer* buffer,\n    const ObjectIdProvider& provider\n) const {\n    CommandEncoderBeginComputePassTransfer* transfer;\n    WIRE_TRY(buffer->Next(&transfer));\n    transfer->commandSize = commandSize;\n    return (CommandEncoderBeginComputePassSerialize(*this, transfer, buffer, provider));\n}\nWireResult CommandEncoderBeginComputePassCmd::Serialize(size_t commandSize, SerializeBuffer* buffer) const {\n    ErrorObjectIdProvider provider;\n    return Serialize(commandSize, buffer, provider);\n}\n\nWireResult CommandEncoderBeginComputePassCmd::Deserialize(\n    DeserializeBuffer* deserializeBuffer,\n    DeserializeAllocator* allocator,\n    const ObjectIdResolver& resolver\n) {\n    const volatile CommandEncoderBeginComputePassTransfer* transfer;\n    WIRE_TRY(deserializeBuffer->Read(&transfer));\n    return CommandEncoderBeginComputePassDeserialize(this, transfer, deserializeBuffer, allocator, resolver);\n}\nWireResult CommandEncoderBeginComputePassCmd::Deserialize(DeserializeBuffer* deserializeBuffer, DeserializeAllocator* allocator) {\n    ErrorObjectIdResolver resolver;\n    return Deserialize(deserializeBuffer, allocator, resolver);\n}\n\n        \nsize_t CommandEncoderBeginRenderPassCmd::GetRequiredSize() const {\n    size_t size = sizeof(CommandEncoderBeginRenderPassTransfer) + CommandEncoderBeginRenderPassGetExtraRequiredSize(*this);\n    return size;\n}\n\nWireResult CommandEncoderBeginRenderPassCmd::Serialize(\n    size_t commandSize,\n    SerializeBuffer* buffer,\n    const ObjectIdProvider& provider\n) const {\n    CommandEncoderBeginRenderPassTransfer* transfer;\n    WIRE_TRY(buffer->Next(&transfer));\n    transfer->commandSize = commandSize;\n    return (CommandEncoderBeginRenderPassSerialize(*this, transfer, buffer, provider));\n}\nWireResult CommandEncoderBeginRenderPassCmd::Serialize(size_t commandSize, SerializeBuffer* buffer) const {\n    ErrorObjectIdProvider provider;\n    return Serialize(commandSize, buffer, provider);\n}\n\nWireResult CommandEncoderBeginRenderPassCmd::Deserialize(\n    DeserializeBuffer* deserializeBuffer,\n    DeserializeAllocator* allocator,\n    const ObjectIdResolver& resolver\n) {\n    const volatile CommandEncoderBeginRenderPassTransfer* transfer;\n    WIRE_TRY(deserializeBuffer->Read(&transfer));\n    return CommandEncoderBeginRenderPassDeserialize(this, transfer, deserializeBuffer, allocator, resolver);\n}\nWireResult CommandEncoderBeginRenderPassCmd::Deserialize(DeserializeBuffer* deserializeBuffer, DeserializeAllocator* allocator) {\n    ErrorObjectIdResolver resolver;\n    return Deserialize(deserializeBuffer, allocator, resolver);\n}\n\n        \nsize_t CommandEncoderClearBufferCmd::GetRequiredSize() const {\n    size_t size = sizeof(CommandEncoderClearBufferTransfer) + CommandEncoderClearBufferGetExtraRequiredSize(*this);\n    return size;\n}\n\nWireResult CommandEncoderClearBufferCmd::Serialize(\n    size_t commandSize,\n    SerializeBuffer* buffer,\n    const ObjectIdProvider& provider\n) const {\n    CommandEncoderClearBufferTransfer* transfer;\n    WIRE_TRY(buffer->Next(&transfer));\n    transfer->commandSize = commandSize;\n    return (CommandEncoderClearBufferSerialize(*this, transfer, buffer, provider));\n}\nWireResult CommandEncoderClearBufferCmd::Serialize(size_t commandSize, SerializeBuffer* buffer) const {\n    ErrorObjectIdProvider provider;\n    return Serialize(commandSize, buffer, provider);\n}\n\nWireResult CommandEncoderClearBufferCmd::Deserialize(\n    DeserializeBuffer* deserializeBuffer,\n    DeserializeAllocator* allocator,\n    const ObjectIdResolver& resolver\n) {\n    const volatile CommandEncoderClearBufferTransfer* transfer;\n    WIRE_TRY(deserializeBuffer->Read(&transfer));\n    return CommandEncoderClearBufferDeserialize(this, transfer, deserializeBuffer, allocator, resolver);\n}\nWireResult CommandEncoderClearBufferCmd::Deserialize(DeserializeBuffer* deserializeBuffer, DeserializeAllocator* allocator) {\n    ErrorObjectIdResolver resolver;\n    return Deserialize(deserializeBuffer, allocator, resolver);\n}\n\n        \nsize_t CommandEncoderCopyBufferToBufferCmd::GetRequiredSize() const {\n    size_t size = sizeof(CommandEncoderCopyBufferToBufferTransfer) + CommandEncoderCopyBufferToBufferGetExtraRequiredSize(*this);\n    return size;\n}\n\nWireResult CommandEncoderCopyBufferToBufferCmd::Serialize(\n    size_t commandSize,\n    SerializeBuffer* buffer,\n    const ObjectIdProvider& provider\n) const {\n    CommandEncoderCopyBufferToBufferTransfer* transfer;\n    WIRE_TRY(buffer->Next(&transfer));\n    transfer->commandSize = commandSize;\n    return (CommandEncoderCopyBufferToBufferSerialize(*this, transfer, buffer, provider));\n}\nWireResult CommandEncoderCopyBufferToBufferCmd::Serialize(size_t commandSize, SerializeBuffer* buffer) const {\n    ErrorObjectIdProvider provider;\n    return Serialize(commandSize, buffer, provider);\n}\n\nWireResult CommandEncoderCopyBufferToBufferCmd::Deserialize(\n    DeserializeBuffer* deserializeBuffer,\n    DeserializeAllocator* allocator,\n    const ObjectIdResolver& resolver\n) {\n    const volatile CommandEncoderCopyBufferToBufferTransfer* transfer;\n    WIRE_TRY(deserializeBuffer->Read(&transfer));\n    return CommandEncoderCopyBufferToBufferDeserialize(this, transfer, deserializeBuffer, allocator, resolver);\n}\nWireResult CommandEncoderCopyBufferToBufferCmd::Deserialize(DeserializeBuffer* deserializeBuffer, DeserializeAllocator* allocator) {\n    ErrorObjectIdResolver resolver;\n    return Deserialize(deserializeBuffer, allocator, resolver);\n}\n\n        \nsize_t CommandEncoderCopyBufferToTextureCmd::GetRequiredSize() const {\n    size_t size = sizeof(CommandEncoderCopyBufferToTextureTransfer) + CommandEncoderCopyBufferToTextureGetExtraRequiredSize(*this);\n    return size;\n}\n\nWireResult CommandEncoderCopyBufferToTextureCmd::Serialize(\n    size_t commandSize,\n    SerializeBuffer* buffer,\n    const ObjectIdProvider& provider\n) const {\n    CommandEncoderCopyBufferToTextureTransfer* transfer;\n    WIRE_TRY(buffer->Next(&transfer));\n    transfer->commandSize = commandSize;\n    return (CommandEncoderCopyBufferToTextureSerialize(*this, transfer, buffer, provider));\n}\nWireResult CommandEncoderCopyBufferToTextureCmd::Serialize(size_t commandSize, SerializeBuffer* buffer) const {\n    ErrorObjectIdProvider provider;\n    return Serialize(commandSize, buffer, provider);\n}\n\nWireResult CommandEncoderCopyBufferToTextureCmd::Deserialize(\n    DeserializeBuffer* deserializeBuffer,\n    DeserializeAllocator* allocator,\n    const ObjectIdResolver& resolver\n) {\n    const volatile CommandEncoderCopyBufferToTextureTransfer* transfer;\n    WIRE_TRY(deserializeBuffer->Read(&transfer));\n    return CommandEncoderCopyBufferToTextureDeserialize(this, transfer, deserializeBuffer, allocator, resolver);\n}\nWireResult CommandEncoderCopyBufferToTextureCmd::Deserialize(DeserializeBuffer* deserializeBuffer, DeserializeAllocator* allocator) {\n    ErrorObjectIdResolver resolver;\n    return Deserialize(deserializeBuffer, allocator, resolver);\n}\n\n        \nsize_t CommandEncoderCopyTextureToBufferCmd::GetRequiredSize() const {\n    size_t size = sizeof(CommandEncoderCopyTextureToBufferTransfer) + CommandEncoderCopyTextureToBufferGetExtraRequiredSize(*this);\n    return size;\n}\n\nWireResult CommandEncoderCopyTextureToBufferCmd::Serialize(\n    size_t commandSize,\n    SerializeBuffer* buffer,\n    const ObjectIdProvider& provider\n) const {\n    CommandEncoderCopyTextureToBufferTransfer* transfer;\n    WIRE_TRY(buffer->Next(&transfer));\n    transfer->commandSize = commandSize;\n    return (CommandEncoderCopyTextureToBufferSerialize(*this, transfer, buffer, provider));\n}\nWireResult CommandEncoderCopyTextureToBufferCmd::Serialize(size_t commandSize, SerializeBuffer* buffer) const {\n    ErrorObjectIdProvider provider;\n    return Serialize(commandSize, buffer, provider);\n}\n\nWireResult CommandEncoderCopyTextureToBufferCmd::Deserialize(\n    DeserializeBuffer* deserializeBuffer,\n    DeserializeAllocator* allocator,\n    const ObjectIdResolver& resolver\n) {\n    const volatile CommandEncoderCopyTextureToBufferTransfer* transfer;\n    WIRE_TRY(deserializeBuffer->Read(&transfer));\n    return CommandEncoderCopyTextureToBufferDeserialize(this, transfer, deserializeBuffer, allocator, resolver);\n}\nWireResult CommandEncoderCopyTextureToBufferCmd::Deserialize(DeserializeBuffer* deserializeBuffer, DeserializeAllocator* allocator) {\n    ErrorObjectIdResolver resolver;\n    return Deserialize(deserializeBuffer, allocator, resolver);\n}\n\n        \nsize_t CommandEncoderCopyTextureToTextureCmd::GetRequiredSize() const {\n    size_t size = sizeof(CommandEncoderCopyTextureToTextureTransfer) + CommandEncoderCopyTextureToTextureGetExtraRequiredSize(*this);\n    return size;\n}\n\nWireResult CommandEncoderCopyTextureToTextureCmd::Serialize(\n    size_t commandSize,\n    SerializeBuffer* buffer,\n    const ObjectIdProvider& provider\n) const {\n    CommandEncoderCopyTextureToTextureTransfer* transfer;\n    WIRE_TRY(buffer->Next(&transfer));\n    transfer->commandSize = commandSize;\n    return (CommandEncoderCopyTextureToTextureSerialize(*this, transfer, buffer, provider));\n}\nWireResult CommandEncoderCopyTextureToTextureCmd::Serialize(size_t commandSize, SerializeBuffer* buffer) const {\n    ErrorObjectIdProvider provider;\n    return Serialize(commandSize, buffer, provider);\n}\n\nWireResult CommandEncoderCopyTextureToTextureCmd::Deserialize(\n    DeserializeBuffer* deserializeBuffer,\n    DeserializeAllocator* allocator,\n    const ObjectIdResolver& resolver\n) {\n    const volatile CommandEncoderCopyTextureToTextureTransfer* transfer;\n    WIRE_TRY(deserializeBuffer->Read(&transfer));\n    return CommandEncoderCopyTextureToTextureDeserialize(this, transfer, deserializeBuffer, allocator, resolver);\n}\nWireResult CommandEncoderCopyTextureToTextureCmd::Deserialize(DeserializeBuffer* deserializeBuffer, DeserializeAllocator* allocator) {\n    ErrorObjectIdResolver resolver;\n    return Deserialize(deserializeBuffer, allocator, resolver);\n}\n\n        \nsize_t CommandEncoderCopyTextureToTextureInternalCmd::GetRequiredSize() const {\n    size_t size = sizeof(CommandEncoderCopyTextureToTextureInternalTransfer) + CommandEncoderCopyTextureToTextureInternalGetExtraRequiredSize(*this);\n    return size;\n}\n\nWireResult CommandEncoderCopyTextureToTextureInternalCmd::Serialize(\n    size_t commandSize,\n    SerializeBuffer* buffer,\n    const ObjectIdProvider& provider\n) const {\n    CommandEncoderCopyTextureToTextureInternalTransfer* transfer;\n    WIRE_TRY(buffer->Next(&transfer));\n    transfer->commandSize = commandSize;\n    return (CommandEncoderCopyTextureToTextureInternalSerialize(*this, transfer, buffer, provider));\n}\nWireResult CommandEncoderCopyTextureToTextureInternalCmd::Serialize(size_t commandSize, SerializeBuffer* buffer) const {\n    ErrorObjectIdProvider provider;\n    return Serialize(commandSize, buffer, provider);\n}\n\nWireResult CommandEncoderCopyTextureToTextureInternalCmd::Deserialize(\n    DeserializeBuffer* deserializeBuffer,\n    DeserializeAllocator* allocator,\n    const ObjectIdResolver& resolver\n) {\n    const volatile CommandEncoderCopyTextureToTextureInternalTransfer* transfer;\n    WIRE_TRY(deserializeBuffer->Read(&transfer));\n    return CommandEncoderCopyTextureToTextureInternalDeserialize(this, transfer, deserializeBuffer, allocator, resolver);\n}\nWireResult CommandEncoderCopyTextureToTextureInternalCmd::Deserialize(DeserializeBuffer* deserializeBuffer, DeserializeAllocator* allocator) {\n    ErrorObjectIdResolver resolver;\n    return Deserialize(deserializeBuffer, allocator, resolver);\n}\n\n        \nsize_t CommandEncoderFinishCmd::GetRequiredSize() const {\n    size_t size = sizeof(CommandEncoderFinishTransfer) + CommandEncoderFinishGetExtraRequiredSize(*this);\n    return size;\n}\n\nWireResult CommandEncoderFinishCmd::Serialize(\n    size_t commandSize,\n    SerializeBuffer* buffer,\n    const ObjectIdProvider& provider\n) const {\n    CommandEncoderFinishTransfer* transfer;\n    WIRE_TRY(buffer->Next(&transfer));\n    transfer->commandSize = commandSize;\n    return (CommandEncoderFinishSerialize(*this, transfer, buffer, provider));\n}\nWireResult CommandEncoderFinishCmd::Serialize(size_t commandSize, SerializeBuffer* buffer) const {\n    ErrorObjectIdProvider provider;\n    return Serialize(commandSize, buffer, provider);\n}\n\nWireResult CommandEncoderFinishCmd::Deserialize(\n    DeserializeBuffer* deserializeBuffer,\n    DeserializeAllocator* allocator,\n    const ObjectIdResolver& resolver\n) {\n    const volatile CommandEncoderFinishTransfer* transfer;\n    WIRE_TRY(deserializeBuffer->Read(&transfer));\n    return CommandEncoderFinishDeserialize(this, transfer, deserializeBuffer, allocator, resolver);\n}\nWireResult CommandEncoderFinishCmd::Deserialize(DeserializeBuffer* deserializeBuffer, DeserializeAllocator* allocator) {\n    ErrorObjectIdResolver resolver;\n    return Deserialize(deserializeBuffer, allocator, resolver);\n}\n\n        \nsize_t CommandEncoderInjectValidationErrorCmd::GetRequiredSize() const {\n    size_t size = sizeof(CommandEncoderInjectValidationErrorTransfer) + CommandEncoderInjectValidationErrorGetExtraRequiredSize(*this);\n    return size;\n}\n\nWireResult CommandEncoderInjectValidationErrorCmd::Serialize(\n    size_t commandSize,\n    SerializeBuffer* buffer,\n    const ObjectIdProvider& provider\n) const {\n    CommandEncoderInjectValidationErrorTransfer* transfer;\n    WIRE_TRY(buffer->Next(&transfer));\n    transfer->commandSize = commandSize;\n    return (CommandEncoderInjectValidationErrorSerialize(*this, transfer, buffer, provider));\n}\nWireResult CommandEncoderInjectValidationErrorCmd::Serialize(size_t commandSize, SerializeBuffer* buffer) const {\n    ErrorObjectIdProvider provider;\n    return Serialize(commandSize, buffer, provider);\n}\n\nWireResult CommandEncoderInjectValidationErrorCmd::Deserialize(\n    DeserializeBuffer* deserializeBuffer,\n    DeserializeAllocator* allocator,\n    const ObjectIdResolver& resolver\n) {\n    const volatile CommandEncoderInjectValidationErrorTransfer* transfer;\n    WIRE_TRY(deserializeBuffer->Read(&transfer));\n    return CommandEncoderInjectValidationErrorDeserialize(this, transfer, deserializeBuffer, allocator, resolver);\n}\nWireResult CommandEncoderInjectValidationErrorCmd::Deserialize(DeserializeBuffer* deserializeBuffer, DeserializeAllocator* allocator) {\n    ErrorObjectIdResolver resolver;\n    return Deserialize(deserializeBuffer, allocator, resolver);\n}\n\n        \nsize_t CommandEncoderInsertDebugMarkerCmd::GetRequiredSize() const {\n    size_t size = sizeof(CommandEncoderInsertDebugMarkerTransfer) + CommandEncoderInsertDebugMarkerGetExtraRequiredSize(*this);\n    return size;\n}\n\nWireResult CommandEncoderInsertDebugMarkerCmd::Serialize(\n    size_t commandSize,\n    SerializeBuffer* buffer,\n    const ObjectIdProvider& provider\n) const {\n    CommandEncoderInsertDebugMarkerTransfer* transfer;\n    WIRE_TRY(buffer->Next(&transfer));\n    transfer->commandSize = commandSize;\n    return (CommandEncoderInsertDebugMarkerSerialize(*this, transfer, buffer, provider));\n}\nWireResult CommandEncoderInsertDebugMarkerCmd::Serialize(size_t commandSize, SerializeBuffer* buffer) const {\n    ErrorObjectIdProvider provider;\n    return Serialize(commandSize, buffer, provider);\n}\n\nWireResult CommandEncoderInsertDebugMarkerCmd::Deserialize(\n    DeserializeBuffer* deserializeBuffer,\n    DeserializeAllocator* allocator,\n    const ObjectIdResolver& resolver\n) {\n    const volatile CommandEncoderInsertDebugMarkerTransfer* transfer;\n    WIRE_TRY(deserializeBuffer->Read(&transfer));\n    return CommandEncoderInsertDebugMarkerDeserialize(this, transfer, deserializeBuffer, allocator, resolver);\n}\nWireResult CommandEncoderInsertDebugMarkerCmd::Deserialize(DeserializeBuffer* deserializeBuffer, DeserializeAllocator* allocator) {\n    ErrorObjectIdResolver resolver;\n    return Deserialize(deserializeBuffer, allocator, resolver);\n}\n\n        \nsize_t CommandEncoderPopDebugGroupCmd::GetRequiredSize() const {\n    size_t size = sizeof(CommandEncoderPopDebugGroupTransfer) + CommandEncoderPopDebugGroupGetExtraRequiredSize(*this);\n    return size;\n}\n\nWireResult CommandEncoderPopDebugGroupCmd::Serialize(\n    size_t commandSize,\n    SerializeBuffer* buffer,\n    const ObjectIdProvider& provider\n) const {\n    CommandEncoderPopDebugGroupTransfer* transfer;\n    WIRE_TRY(buffer->Next(&transfer));\n    transfer->commandSize = commandSize;\n    return (CommandEncoderPopDebugGroupSerialize(*this, transfer, buffer, provider));\n}\nWireResult CommandEncoderPopDebugGroupCmd::Serialize(size_t commandSize, SerializeBuffer* buffer) const {\n    ErrorObjectIdProvider provider;\n    return Serialize(commandSize, buffer, provider);\n}\n\nWireResult CommandEncoderPopDebugGroupCmd::Deserialize(\n    DeserializeBuffer* deserializeBuffer,\n    DeserializeAllocator* allocator,\n    const ObjectIdResolver& resolver\n) {\n    const volatile CommandEncoderPopDebugGroupTransfer* transfer;\n    WIRE_TRY(deserializeBuffer->Read(&transfer));\n    return CommandEncoderPopDebugGroupDeserialize(this, transfer, deserializeBuffer, allocator, resolver);\n}\nWireResult CommandEncoderPopDebugGroupCmd::Deserialize(DeserializeBuffer* deserializeBuffer, DeserializeAllocator* allocator) {\n    ErrorObjectIdResolver resolver;\n    return Deserialize(deserializeBuffer, allocator, resolver);\n}\n\n        \nsize_t CommandEncoderPushDebugGroupCmd::GetRequiredSize() const {\n    size_t size = sizeof(CommandEncoderPushDebugGroupTransfer) + CommandEncoderPushDebugGroupGetExtraRequiredSize(*this);\n    return size;\n}\n\nWireResult CommandEncoderPushDebugGroupCmd::Serialize(\n    size_t commandSize,\n    SerializeBuffer* buffer,\n    const ObjectIdProvider& provider\n) const {\n    CommandEncoderPushDebugGroupTransfer* transfer;\n    WIRE_TRY(buffer->Next(&transfer));\n    transfer->commandSize = commandSize;\n    return (CommandEncoderPushDebugGroupSerialize(*this, transfer, buffer, provider));\n}\nWireResult CommandEncoderPushDebugGroupCmd::Serialize(size_t commandSize, SerializeBuffer* buffer) const {\n    ErrorObjectIdProvider provider;\n    return Serialize(commandSize, buffer, provider);\n}\n\nWireResult CommandEncoderPushDebugGroupCmd::Deserialize(\n    DeserializeBuffer* deserializeBuffer,\n    DeserializeAllocator* allocator,\n    const ObjectIdResolver& resolver\n) {\n    const volatile CommandEncoderPushDebugGroupTransfer* transfer;\n    WIRE_TRY(deserializeBuffer->Read(&transfer));\n    return CommandEncoderPushDebugGroupDeserialize(this, transfer, deserializeBuffer, allocator, resolver);\n}\nWireResult CommandEncoderPushDebugGroupCmd::Deserialize(DeserializeBuffer* deserializeBuffer, DeserializeAllocator* allocator) {\n    ErrorObjectIdResolver resolver;\n    return Deserialize(deserializeBuffer, allocator, resolver);\n}\n\n        \nsize_t CommandEncoderResolveQuerySetCmd::GetRequiredSize() const {\n    size_t size = sizeof(CommandEncoderResolveQuerySetTransfer) + CommandEncoderResolveQuerySetGetExtraRequiredSize(*this);\n    return size;\n}\n\nWireResult CommandEncoderResolveQuerySetCmd::Serialize(\n    size_t commandSize,\n    SerializeBuffer* buffer,\n    const ObjectIdProvider& provider\n) const {\n    CommandEncoderResolveQuerySetTransfer* transfer;\n    WIRE_TRY(buffer->Next(&transfer));\n    transfer->commandSize = commandSize;\n    return (CommandEncoderResolveQuerySetSerialize(*this, transfer, buffer, provider));\n}\nWireResult CommandEncoderResolveQuerySetCmd::Serialize(size_t commandSize, SerializeBuffer* buffer) const {\n    ErrorObjectIdProvider provider;\n    return Serialize(commandSize, buffer, provider);\n}\n\nWireResult CommandEncoderResolveQuerySetCmd::Deserialize(\n    DeserializeBuffer* deserializeBuffer,\n    DeserializeAllocator* allocator,\n    const ObjectIdResolver& resolver\n) {\n    const volatile CommandEncoderResolveQuerySetTransfer* transfer;\n    WIRE_TRY(deserializeBuffer->Read(&transfer));\n    return CommandEncoderResolveQuerySetDeserialize(this, transfer, deserializeBuffer, allocator, resolver);\n}\nWireResult CommandEncoderResolveQuerySetCmd::Deserialize(DeserializeBuffer* deserializeBuffer, DeserializeAllocator* allocator) {\n    ErrorObjectIdResolver resolver;\n    return Deserialize(deserializeBuffer, allocator, resolver);\n}\n\n        \nsize_t CommandEncoderSetLabelCmd::GetRequiredSize() const {\n    size_t size = sizeof(CommandEncoderSetLabelTransfer) + CommandEncoderSetLabelGetExtraRequiredSize(*this);\n    return size;\n}\n\nWireResult CommandEncoderSetLabelCmd::Serialize(\n    size_t commandSize,\n    SerializeBuffer* buffer,\n    const ObjectIdProvider& provider\n) const {\n    CommandEncoderSetLabelTransfer* transfer;\n    WIRE_TRY(buffer->Next(&transfer));\n    transfer->commandSize = commandSize;\n    return (CommandEncoderSetLabelSerialize(*this, transfer, buffer, provider));\n}\nWireResult CommandEncoderSetLabelCmd::Serialize(size_t commandSize, SerializeBuffer* buffer) const {\n    ErrorObjectIdProvider provider;\n    return Serialize(commandSize, buffer, provider);\n}\n\nWireResult CommandEncoderSetLabelCmd::Deserialize(\n    DeserializeBuffer* deserializeBuffer,\n    DeserializeAllocator* allocator,\n    const ObjectIdResolver& resolver\n) {\n    const volatile CommandEncoderSetLabelTransfer* transfer;\n    WIRE_TRY(deserializeBuffer->Read(&transfer));\n    return CommandEncoderSetLabelDeserialize(this, transfer, deserializeBuffer, allocator, resolver);\n}\nWireResult CommandEncoderSetLabelCmd::Deserialize(DeserializeBuffer* deserializeBuffer, DeserializeAllocator* allocator) {\n    ErrorObjectIdResolver resolver;\n    return Deserialize(deserializeBuffer, allocator, resolver);\n}\n\n        \nsize_t CommandEncoderWriteBufferCmd::GetRequiredSize() const {\n    size_t size = sizeof(CommandEncoderWriteBufferTransfer) + CommandEncoderWriteBufferGetExtraRequiredSize(*this);\n    return size;\n}\n\nWireResult CommandEncoderWriteBufferCmd::Serialize(\n    size_t commandSize,\n    SerializeBuffer* buffer,\n    const ObjectIdProvider& provider\n) const {\n    CommandEncoderWriteBufferTransfer* transfer;\n    WIRE_TRY(buffer->Next(&transfer));\n    transfer->commandSize = commandSize;\n    return (CommandEncoderWriteBufferSerialize(*this, transfer, buffer, provider));\n}\nWireResult CommandEncoderWriteBufferCmd::Serialize(size_t commandSize, SerializeBuffer* buffer) const {\n    ErrorObjectIdProvider provider;\n    return Serialize(commandSize, buffer, provider);\n}\n\nWireResult CommandEncoderWriteBufferCmd::Deserialize(\n    DeserializeBuffer* deserializeBuffer,\n    DeserializeAllocator* allocator,\n    const ObjectIdResolver& resolver\n) {\n    const volatile CommandEncoderWriteBufferTransfer* transfer;\n    WIRE_TRY(deserializeBuffer->Read(&transfer));\n    return CommandEncoderWriteBufferDeserialize(this, transfer, deserializeBuffer, allocator, resolver);\n}\nWireResult CommandEncoderWriteBufferCmd::Deserialize(DeserializeBuffer* deserializeBuffer, DeserializeAllocator* allocator) {\n    ErrorObjectIdResolver resolver;\n    return Deserialize(deserializeBuffer, allocator, resolver);\n}\n\n        \nsize_t CommandEncoderWriteTimestampCmd::GetRequiredSize() const {\n    size_t size = sizeof(CommandEncoderWriteTimestampTransfer) + CommandEncoderWriteTimestampGetExtraRequiredSize(*this);\n    return size;\n}\n\nWireResult CommandEncoderWriteTimestampCmd::Serialize(\n    size_t commandSize,\n    SerializeBuffer* buffer,\n    const ObjectIdProvider& provider\n) const {\n    CommandEncoderWriteTimestampTransfer* transfer;\n    WIRE_TRY(buffer->Next(&transfer));\n    transfer->commandSize = commandSize;\n    return (CommandEncoderWriteTimestampSerialize(*this, transfer, buffer, provider));\n}\nWireResult CommandEncoderWriteTimestampCmd::Serialize(size_t commandSize, SerializeBuffer* buffer) const {\n    ErrorObjectIdProvider provider;\n    return Serialize(commandSize, buffer, provider);\n}\n\nWireResult CommandEncoderWriteTimestampCmd::Deserialize(\n    DeserializeBuffer* deserializeBuffer,\n    DeserializeAllocator* allocator,\n    const ObjectIdResolver& resolver\n) {\n    const volatile CommandEncoderWriteTimestampTransfer* transfer;\n    WIRE_TRY(deserializeBuffer->Read(&transfer));\n    return CommandEncoderWriteTimestampDeserialize(this, transfer, deserializeBuffer, allocator, resolver);\n}\nWireResult CommandEncoderWriteTimestampCmd::Deserialize(DeserializeBuffer* deserializeBuffer, DeserializeAllocator* allocator) {\n    ErrorObjectIdResolver resolver;\n    return Deserialize(deserializeBuffer, allocator, resolver);\n}\n\n        \nsize_t ComputePassEncoderDispatchCmd::GetRequiredSize() const {\n    size_t size = sizeof(ComputePassEncoderDispatchTransfer) + ComputePassEncoderDispatchGetExtraRequiredSize(*this);\n    return size;\n}\n\nWireResult ComputePassEncoderDispatchCmd::Serialize(\n    size_t commandSize,\n    SerializeBuffer* buffer,\n    const ObjectIdProvider& provider\n) const {\n    ComputePassEncoderDispatchTransfer* transfer;\n    WIRE_TRY(buffer->Next(&transfer));\n    transfer->commandSize = commandSize;\n    return (ComputePassEncoderDispatchSerialize(*this, transfer, buffer, provider));\n}\nWireResult ComputePassEncoderDispatchCmd::Serialize(size_t commandSize, SerializeBuffer* buffer) const {\n    ErrorObjectIdProvider provider;\n    return Serialize(commandSize, buffer, provider);\n}\n\nWireResult ComputePassEncoderDispatchCmd::Deserialize(\n    DeserializeBuffer* deserializeBuffer,\n    DeserializeAllocator* allocator,\n    const ObjectIdResolver& resolver\n) {\n    const volatile ComputePassEncoderDispatchTransfer* transfer;\n    WIRE_TRY(deserializeBuffer->Read(&transfer));\n    return ComputePassEncoderDispatchDeserialize(this, transfer, deserializeBuffer, allocator, resolver);\n}\nWireResult ComputePassEncoderDispatchCmd::Deserialize(DeserializeBuffer* deserializeBuffer, DeserializeAllocator* allocator) {\n    ErrorObjectIdResolver resolver;\n    return Deserialize(deserializeBuffer, allocator, resolver);\n}\n\n        \nsize_t ComputePassEncoderDispatchIndirectCmd::GetRequiredSize() const {\n    size_t size = sizeof(ComputePassEncoderDispatchIndirectTransfer) + ComputePassEncoderDispatchIndirectGetExtraRequiredSize(*this);\n    return size;\n}\n\nWireResult ComputePassEncoderDispatchIndirectCmd::Serialize(\n    size_t commandSize,\n    SerializeBuffer* buffer,\n    const ObjectIdProvider& provider\n) const {\n    ComputePassEncoderDispatchIndirectTransfer* transfer;\n    WIRE_TRY(buffer->Next(&transfer));\n    transfer->commandSize = commandSize;\n    return (ComputePassEncoderDispatchIndirectSerialize(*this, transfer, buffer, provider));\n}\nWireResult ComputePassEncoderDispatchIndirectCmd::Serialize(size_t commandSize, SerializeBuffer* buffer) const {\n    ErrorObjectIdProvider provider;\n    return Serialize(commandSize, buffer, provider);\n}\n\nWireResult ComputePassEncoderDispatchIndirectCmd::Deserialize(\n    DeserializeBuffer* deserializeBuffer,\n    DeserializeAllocator* allocator,\n    const ObjectIdResolver& resolver\n) {\n    const volatile ComputePassEncoderDispatchIndirectTransfer* transfer;\n    WIRE_TRY(deserializeBuffer->Read(&transfer));\n    return ComputePassEncoderDispatchIndirectDeserialize(this, transfer, deserializeBuffer, allocator, resolver);\n}\nWireResult ComputePassEncoderDispatchIndirectCmd::Deserialize(DeserializeBuffer* deserializeBuffer, DeserializeAllocator* allocator) {\n    ErrorObjectIdResolver resolver;\n    return Deserialize(deserializeBuffer, allocator, resolver);\n}\n\n        \nsize_t ComputePassEncoderDispatchWorkgroupsCmd::GetRequiredSize() const {\n    size_t size = sizeof(ComputePassEncoderDispatchWorkgroupsTransfer) + ComputePassEncoderDispatchWorkgroupsGetExtraRequiredSize(*this);\n    return size;\n}\n\nWireResult ComputePassEncoderDispatchWorkgroupsCmd::Serialize(\n    size_t commandSize,\n    SerializeBuffer* buffer,\n    const ObjectIdProvider& provider\n) const {\n    ComputePassEncoderDispatchWorkgroupsTransfer* transfer;\n    WIRE_TRY(buffer->Next(&transfer));\n    transfer->commandSize = commandSize;\n    return (ComputePassEncoderDispatchWorkgroupsSerialize(*this, transfer, buffer, provider));\n}\nWireResult ComputePassEncoderDispatchWorkgroupsCmd::Serialize(size_t commandSize, SerializeBuffer* buffer) const {\n    ErrorObjectIdProvider provider;\n    return Serialize(commandSize, buffer, provider);\n}\n\nWireResult ComputePassEncoderDispatchWorkgroupsCmd::Deserialize(\n    DeserializeBuffer* deserializeBuffer,\n    DeserializeAllocator* allocator,\n    const ObjectIdResolver& resolver\n) {\n    const volatile ComputePassEncoderDispatchWorkgroupsTransfer* transfer;\n    WIRE_TRY(deserializeBuffer->Read(&transfer));\n    return ComputePassEncoderDispatchWorkgroupsDeserialize(this, transfer, deserializeBuffer, allocator, resolver);\n}\nWireResult ComputePassEncoderDispatchWorkgroupsCmd::Deserialize(DeserializeBuffer* deserializeBuffer, DeserializeAllocator* allocator) {\n    ErrorObjectIdResolver resolver;\n    return Deserialize(deserializeBuffer, allocator, resolver);\n}\n\n        \nsize_t ComputePassEncoderDispatchWorkgroupsIndirectCmd::GetRequiredSize() const {\n    size_t size = sizeof(ComputePassEncoderDispatchWorkgroupsIndirectTransfer) + ComputePassEncoderDispatchWorkgroupsIndirectGetExtraRequiredSize(*this);\n    return size;\n}\n\nWireResult ComputePassEncoderDispatchWorkgroupsIndirectCmd::Serialize(\n    size_t commandSize,\n    SerializeBuffer* buffer,\n    const ObjectIdProvider& provider\n) const {\n    ComputePassEncoderDispatchWorkgroupsIndirectTransfer* transfer;\n    WIRE_TRY(buffer->Next(&transfer));\n    transfer->commandSize = commandSize;\n    return (ComputePassEncoderDispatchWorkgroupsIndirectSerialize(*this, transfer, buffer, provider));\n}\nWireResult ComputePassEncoderDispatchWorkgroupsIndirectCmd::Serialize(size_t commandSize, SerializeBuffer* buffer) const {\n    ErrorObjectIdProvider provider;\n    return Serialize(commandSize, buffer, provider);\n}\n\nWireResult ComputePassEncoderDispatchWorkgroupsIndirectCmd::Deserialize(\n    DeserializeBuffer* deserializeBuffer,\n    DeserializeAllocator* allocator,\n    const ObjectIdResolver& resolver\n) {\n    const volatile ComputePassEncoderDispatchWorkgroupsIndirectTransfer* transfer;\n    WIRE_TRY(deserializeBuffer->Read(&transfer));\n    return ComputePassEncoderDispatchWorkgroupsIndirectDeserialize(this, transfer, deserializeBuffer, allocator, resolver);\n}\nWireResult ComputePassEncoderDispatchWorkgroupsIndirectCmd::Deserialize(DeserializeBuffer* deserializeBuffer, DeserializeAllocator* allocator) {\n    ErrorObjectIdResolver resolver;\n    return Deserialize(deserializeBuffer, allocator, resolver);\n}\n\n        \nsize_t ComputePassEncoderEndCmd::GetRequiredSize() const {\n    size_t size = sizeof(ComputePassEncoderEndTransfer) + ComputePassEncoderEndGetExtraRequiredSize(*this);\n    return size;\n}\n\nWireResult ComputePassEncoderEndCmd::Serialize(\n    size_t commandSize,\n    SerializeBuffer* buffer,\n    const ObjectIdProvider& provider\n) const {\n    ComputePassEncoderEndTransfer* transfer;\n    WIRE_TRY(buffer->Next(&transfer));\n    transfer->commandSize = commandSize;\n    return (ComputePassEncoderEndSerialize(*this, transfer, buffer, provider));\n}\nWireResult ComputePassEncoderEndCmd::Serialize(size_t commandSize, SerializeBuffer* buffer) const {\n    ErrorObjectIdProvider provider;\n    return Serialize(commandSize, buffer, provider);\n}\n\nWireResult ComputePassEncoderEndCmd::Deserialize(\n    DeserializeBuffer* deserializeBuffer,\n    DeserializeAllocator* allocator,\n    const ObjectIdResolver& resolver\n) {\n    const volatile ComputePassEncoderEndTransfer* transfer;\n    WIRE_TRY(deserializeBuffer->Read(&transfer));\n    return ComputePassEncoderEndDeserialize(this, transfer, deserializeBuffer, allocator, resolver);\n}\nWireResult ComputePassEncoderEndCmd::Deserialize(DeserializeBuffer* deserializeBuffer, DeserializeAllocator* allocator) {\n    ErrorObjectIdResolver resolver;\n    return Deserialize(deserializeBuffer, allocator, resolver);\n}\n\n        \nsize_t ComputePassEncoderEndPassCmd::GetRequiredSize() const {\n    size_t size = sizeof(ComputePassEncoderEndPassTransfer) + ComputePassEncoderEndPassGetExtraRequiredSize(*this);\n    return size;\n}\n\nWireResult ComputePassEncoderEndPassCmd::Serialize(\n    size_t commandSize,\n    SerializeBuffer* buffer,\n    const ObjectIdProvider& provider\n) const {\n    ComputePassEncoderEndPassTransfer* transfer;\n    WIRE_TRY(buffer->Next(&transfer));\n    transfer->commandSize = commandSize;\n    return (ComputePassEncoderEndPassSerialize(*this, transfer, buffer, provider));\n}\nWireResult ComputePassEncoderEndPassCmd::Serialize(size_t commandSize, SerializeBuffer* buffer) const {\n    ErrorObjectIdProvider provider;\n    return Serialize(commandSize, buffer, provider);\n}\n\nWireResult ComputePassEncoderEndPassCmd::Deserialize(\n    DeserializeBuffer* deserializeBuffer,\n    DeserializeAllocator* allocator,\n    const ObjectIdResolver& resolver\n) {\n    const volatile ComputePassEncoderEndPassTransfer* transfer;\n    WIRE_TRY(deserializeBuffer->Read(&transfer));\n    return ComputePassEncoderEndPassDeserialize(this, transfer, deserializeBuffer, allocator, resolver);\n}\nWireResult ComputePassEncoderEndPassCmd::Deserialize(DeserializeBuffer* deserializeBuffer, DeserializeAllocator* allocator) {\n    ErrorObjectIdResolver resolver;\n    return Deserialize(deserializeBuffer, allocator, resolver);\n}\n\n        \nsize_t ComputePassEncoderInsertDebugMarkerCmd::GetRequiredSize() const {\n    size_t size = sizeof(ComputePassEncoderInsertDebugMarkerTransfer) + ComputePassEncoderInsertDebugMarkerGetExtraRequiredSize(*this);\n    return size;\n}\n\nWireResult ComputePassEncoderInsertDebugMarkerCmd::Serialize(\n    size_t commandSize,\n    SerializeBuffer* buffer,\n    const ObjectIdProvider& provider\n) const {\n    ComputePassEncoderInsertDebugMarkerTransfer* transfer;\n    WIRE_TRY(buffer->Next(&transfer));\n    transfer->commandSize = commandSize;\n    return (ComputePassEncoderInsertDebugMarkerSerialize(*this, transfer, buffer, provider));\n}\nWireResult ComputePassEncoderInsertDebugMarkerCmd::Serialize(size_t commandSize, SerializeBuffer* buffer) const {\n    ErrorObjectIdProvider provider;\n    return Serialize(commandSize, buffer, provider);\n}\n\nWireResult ComputePassEncoderInsertDebugMarkerCmd::Deserialize(\n    DeserializeBuffer* deserializeBuffer,\n    DeserializeAllocator* allocator,\n    const ObjectIdResolver& resolver\n) {\n    const volatile ComputePassEncoderInsertDebugMarkerTransfer* transfer;\n    WIRE_TRY(deserializeBuffer->Read(&transfer));\n    return ComputePassEncoderInsertDebugMarkerDeserialize(this, transfer, deserializeBuffer, allocator, resolver);\n}\nWireResult ComputePassEncoderInsertDebugMarkerCmd::Deserialize(DeserializeBuffer* deserializeBuffer, DeserializeAllocator* allocator) {\n    ErrorObjectIdResolver resolver;\n    return Deserialize(deserializeBuffer, allocator, resolver);\n}\n\n        \nsize_t ComputePassEncoderPopDebugGroupCmd::GetRequiredSize() const {\n    size_t size = sizeof(ComputePassEncoderPopDebugGroupTransfer) + ComputePassEncoderPopDebugGroupGetExtraRequiredSize(*this);\n    return size;\n}\n\nWireResult ComputePassEncoderPopDebugGroupCmd::Serialize(\n    size_t commandSize,\n    SerializeBuffer* buffer,\n    const ObjectIdProvider& provider\n) const {\n    ComputePassEncoderPopDebugGroupTransfer* transfer;\n    WIRE_TRY(buffer->Next(&transfer));\n    transfer->commandSize = commandSize;\n    return (ComputePassEncoderPopDebugGroupSerialize(*this, transfer, buffer, provider));\n}\nWireResult ComputePassEncoderPopDebugGroupCmd::Serialize(size_t commandSize, SerializeBuffer* buffer) const {\n    ErrorObjectIdProvider provider;\n    return Serialize(commandSize, buffer, provider);\n}\n\nWireResult ComputePassEncoderPopDebugGroupCmd::Deserialize(\n    DeserializeBuffer* deserializeBuffer,\n    DeserializeAllocator* allocator,\n    const ObjectIdResolver& resolver\n) {\n    const volatile ComputePassEncoderPopDebugGroupTransfer* transfer;\n    WIRE_TRY(deserializeBuffer->Read(&transfer));\n    return ComputePassEncoderPopDebugGroupDeserialize(this, transfer, deserializeBuffer, allocator, resolver);\n}\nWireResult ComputePassEncoderPopDebugGroupCmd::Deserialize(DeserializeBuffer* deserializeBuffer, DeserializeAllocator* allocator) {\n    ErrorObjectIdResolver resolver;\n    return Deserialize(deserializeBuffer, allocator, resolver);\n}\n\n        \nsize_t ComputePassEncoderPushDebugGroupCmd::GetRequiredSize() const {\n    size_t size = sizeof(ComputePassEncoderPushDebugGroupTransfer) + ComputePassEncoderPushDebugGroupGetExtraRequiredSize(*this);\n    return size;\n}\n\nWireResult ComputePassEncoderPushDebugGroupCmd::Serialize(\n    size_t commandSize,\n    SerializeBuffer* buffer,\n    const ObjectIdProvider& provider\n) const {\n    ComputePassEncoderPushDebugGroupTransfer* transfer;\n    WIRE_TRY(buffer->Next(&transfer));\n    transfer->commandSize = commandSize;\n    return (ComputePassEncoderPushDebugGroupSerialize(*this, transfer, buffer, provider));\n}\nWireResult ComputePassEncoderPushDebugGroupCmd::Serialize(size_t commandSize, SerializeBuffer* buffer) const {\n    ErrorObjectIdProvider provider;\n    return Serialize(commandSize, buffer, provider);\n}\n\nWireResult ComputePassEncoderPushDebugGroupCmd::Deserialize(\n    DeserializeBuffer* deserializeBuffer,\n    DeserializeAllocator* allocator,\n    const ObjectIdResolver& resolver\n) {\n    const volatile ComputePassEncoderPushDebugGroupTransfer* transfer;\n    WIRE_TRY(deserializeBuffer->Read(&transfer));\n    return ComputePassEncoderPushDebugGroupDeserialize(this, transfer, deserializeBuffer, allocator, resolver);\n}\nWireResult ComputePassEncoderPushDebugGroupCmd::Deserialize(DeserializeBuffer* deserializeBuffer, DeserializeAllocator* allocator) {\n    ErrorObjectIdResolver resolver;\n    return Deserialize(deserializeBuffer, allocator, resolver);\n}\n\n        \nsize_t ComputePassEncoderSetBindGroupCmd::GetRequiredSize() const {\n    size_t size = sizeof(ComputePassEncoderSetBindGroupTransfer) + ComputePassEncoderSetBindGroupGetExtraRequiredSize(*this);\n    return size;\n}\n\nWireResult ComputePassEncoderSetBindGroupCmd::Serialize(\n    size_t commandSize,\n    SerializeBuffer* buffer,\n    const ObjectIdProvider& provider\n) const {\n    ComputePassEncoderSetBindGroupTransfer* transfer;\n    WIRE_TRY(buffer->Next(&transfer));\n    transfer->commandSize = commandSize;\n    return (ComputePassEncoderSetBindGroupSerialize(*this, transfer, buffer, provider));\n}\nWireResult ComputePassEncoderSetBindGroupCmd::Serialize(size_t commandSize, SerializeBuffer* buffer) const {\n    ErrorObjectIdProvider provider;\n    return Serialize(commandSize, buffer, provider);\n}\n\nWireResult ComputePassEncoderSetBindGroupCmd::Deserialize(\n    DeserializeBuffer* deserializeBuffer,\n    DeserializeAllocator* allocator,\n    const ObjectIdResolver& resolver\n) {\n    const volatile ComputePassEncoderSetBindGroupTransfer* transfer;\n    WIRE_TRY(deserializeBuffer->Read(&transfer));\n    return ComputePassEncoderSetBindGroupDeserialize(this, transfer, deserializeBuffer, allocator, resolver);\n}\nWireResult ComputePassEncoderSetBindGroupCmd::Deserialize(DeserializeBuffer* deserializeBuffer, DeserializeAllocator* allocator) {\n    ErrorObjectIdResolver resolver;\n    return Deserialize(deserializeBuffer, allocator, resolver);\n}\n\n        \nsize_t ComputePassEncoderSetLabelCmd::GetRequiredSize() const {\n    size_t size = sizeof(ComputePassEncoderSetLabelTransfer) + ComputePassEncoderSetLabelGetExtraRequiredSize(*this);\n    return size;\n}\n\nWireResult ComputePassEncoderSetLabelCmd::Serialize(\n    size_t commandSize,\n    SerializeBuffer* buffer,\n    const ObjectIdProvider& provider\n) const {\n    ComputePassEncoderSetLabelTransfer* transfer;\n    WIRE_TRY(buffer->Next(&transfer));\n    transfer->commandSize = commandSize;\n    return (ComputePassEncoderSetLabelSerialize(*this, transfer, buffer, provider));\n}\nWireResult ComputePassEncoderSetLabelCmd::Serialize(size_t commandSize, SerializeBuffer* buffer) const {\n    ErrorObjectIdProvider provider;\n    return Serialize(commandSize, buffer, provider);\n}\n\nWireResult ComputePassEncoderSetLabelCmd::Deserialize(\n    DeserializeBuffer* deserializeBuffer,\n    DeserializeAllocator* allocator,\n    const ObjectIdResolver& resolver\n) {\n    const volatile ComputePassEncoderSetLabelTransfer* transfer;\n    WIRE_TRY(deserializeBuffer->Read(&transfer));\n    return ComputePassEncoderSetLabelDeserialize(this, transfer, deserializeBuffer, allocator, resolver);\n}\nWireResult ComputePassEncoderSetLabelCmd::Deserialize(DeserializeBuffer* deserializeBuffer, DeserializeAllocator* allocator) {\n    ErrorObjectIdResolver resolver;\n    return Deserialize(deserializeBuffer, allocator, resolver);\n}\n\n        \nsize_t ComputePassEncoderSetPipelineCmd::GetRequiredSize() const {\n    size_t size = sizeof(ComputePassEncoderSetPipelineTransfer) + ComputePassEncoderSetPipelineGetExtraRequiredSize(*this);\n    return size;\n}\n\nWireResult ComputePassEncoderSetPipelineCmd::Serialize(\n    size_t commandSize,\n    SerializeBuffer* buffer,\n    const ObjectIdProvider& provider\n) const {\n    ComputePassEncoderSetPipelineTransfer* transfer;\n    WIRE_TRY(buffer->Next(&transfer));\n    transfer->commandSize = commandSize;\n    return (ComputePassEncoderSetPipelineSerialize(*this, transfer, buffer, provider));\n}\nWireResult ComputePassEncoderSetPipelineCmd::Serialize(size_t commandSize, SerializeBuffer* buffer) const {\n    ErrorObjectIdProvider provider;\n    return Serialize(commandSize, buffer, provider);\n}\n\nWireResult ComputePassEncoderSetPipelineCmd::Deserialize(\n    DeserializeBuffer* deserializeBuffer,\n    DeserializeAllocator* allocator,\n    const ObjectIdResolver& resolver\n) {\n    const volatile ComputePassEncoderSetPipelineTransfer* transfer;\n    WIRE_TRY(deserializeBuffer->Read(&transfer));\n    return ComputePassEncoderSetPipelineDeserialize(this, transfer, deserializeBuffer, allocator, resolver);\n}\nWireResult ComputePassEncoderSetPipelineCmd::Deserialize(DeserializeBuffer* deserializeBuffer, DeserializeAllocator* allocator) {\n    ErrorObjectIdResolver resolver;\n    return Deserialize(deserializeBuffer, allocator, resolver);\n}\n\n        \nsize_t ComputePassEncoderWriteTimestampCmd::GetRequiredSize() const {\n    size_t size = sizeof(ComputePassEncoderWriteTimestampTransfer) + ComputePassEncoderWriteTimestampGetExtraRequiredSize(*this);\n    return size;\n}\n\nWireResult ComputePassEncoderWriteTimestampCmd::Serialize(\n    size_t commandSize,\n    SerializeBuffer* buffer,\n    const ObjectIdProvider& provider\n) const {\n    ComputePassEncoderWriteTimestampTransfer* transfer;\n    WIRE_TRY(buffer->Next(&transfer));\n    transfer->commandSize = commandSize;\n    return (ComputePassEncoderWriteTimestampSerialize(*this, transfer, buffer, provider));\n}\nWireResult ComputePassEncoderWriteTimestampCmd::Serialize(size_t commandSize, SerializeBuffer* buffer) const {\n    ErrorObjectIdProvider provider;\n    return Serialize(commandSize, buffer, provider);\n}\n\nWireResult ComputePassEncoderWriteTimestampCmd::Deserialize(\n    DeserializeBuffer* deserializeBuffer,\n    DeserializeAllocator* allocator,\n    const ObjectIdResolver& resolver\n) {\n    const volatile ComputePassEncoderWriteTimestampTransfer* transfer;\n    WIRE_TRY(deserializeBuffer->Read(&transfer));\n    return ComputePassEncoderWriteTimestampDeserialize(this, transfer, deserializeBuffer, allocator, resolver);\n}\nWireResult ComputePassEncoderWriteTimestampCmd::Deserialize(DeserializeBuffer* deserializeBuffer, DeserializeAllocator* allocator) {\n    ErrorObjectIdResolver resolver;\n    return Deserialize(deserializeBuffer, allocator, resolver);\n}\n\n        \nsize_t ComputePipelineGetBindGroupLayoutCmd::GetRequiredSize() const {\n    size_t size = sizeof(ComputePipelineGetBindGroupLayoutTransfer) + ComputePipelineGetBindGroupLayoutGetExtraRequiredSize(*this);\n    return size;\n}\n\nWireResult ComputePipelineGetBindGroupLayoutCmd::Serialize(\n    size_t commandSize,\n    SerializeBuffer* buffer,\n    const ObjectIdProvider& provider\n) const {\n    ComputePipelineGetBindGroupLayoutTransfer* transfer;\n    WIRE_TRY(buffer->Next(&transfer));\n    transfer->commandSize = commandSize;\n    return (ComputePipelineGetBindGroupLayoutSerialize(*this, transfer, buffer, provider));\n}\nWireResult ComputePipelineGetBindGroupLayoutCmd::Serialize(size_t commandSize, SerializeBuffer* buffer) const {\n    ErrorObjectIdProvider provider;\n    return Serialize(commandSize, buffer, provider);\n}\n\nWireResult ComputePipelineGetBindGroupLayoutCmd::Deserialize(\n    DeserializeBuffer* deserializeBuffer,\n    DeserializeAllocator* allocator,\n    const ObjectIdResolver& resolver\n) {\n    const volatile ComputePipelineGetBindGroupLayoutTransfer* transfer;\n    WIRE_TRY(deserializeBuffer->Read(&transfer));\n    return ComputePipelineGetBindGroupLayoutDeserialize(this, transfer, deserializeBuffer, allocator, resolver);\n}\nWireResult ComputePipelineGetBindGroupLayoutCmd::Deserialize(DeserializeBuffer* deserializeBuffer, DeserializeAllocator* allocator) {\n    ErrorObjectIdResolver resolver;\n    return Deserialize(deserializeBuffer, allocator, resolver);\n}\n\n        \nsize_t ComputePipelineSetLabelCmd::GetRequiredSize() const {\n    size_t size = sizeof(ComputePipelineSetLabelTransfer) + ComputePipelineSetLabelGetExtraRequiredSize(*this);\n    return size;\n}\n\nWireResult ComputePipelineSetLabelCmd::Serialize(\n    size_t commandSize,\n    SerializeBuffer* buffer,\n    const ObjectIdProvider& provider\n) const {\n    ComputePipelineSetLabelTransfer* transfer;\n    WIRE_TRY(buffer->Next(&transfer));\n    transfer->commandSize = commandSize;\n    return (ComputePipelineSetLabelSerialize(*this, transfer, buffer, provider));\n}\nWireResult ComputePipelineSetLabelCmd::Serialize(size_t commandSize, SerializeBuffer* buffer) const {\n    ErrorObjectIdProvider provider;\n    return Serialize(commandSize, buffer, provider);\n}\n\nWireResult ComputePipelineSetLabelCmd::Deserialize(\n    DeserializeBuffer* deserializeBuffer,\n    DeserializeAllocator* allocator,\n    const ObjectIdResolver& resolver\n) {\n    const volatile ComputePipelineSetLabelTransfer* transfer;\n    WIRE_TRY(deserializeBuffer->Read(&transfer));\n    return ComputePipelineSetLabelDeserialize(this, transfer, deserializeBuffer, allocator, resolver);\n}\nWireResult ComputePipelineSetLabelCmd::Deserialize(DeserializeBuffer* deserializeBuffer, DeserializeAllocator* allocator) {\n    ErrorObjectIdResolver resolver;\n    return Deserialize(deserializeBuffer, allocator, resolver);\n}\n\n        \nsize_t DestroyObjectCmd::GetRequiredSize() const {\n    size_t size = sizeof(DestroyObjectTransfer) + DestroyObjectGetExtraRequiredSize(*this);\n    return size;\n}\n\nWireResult DestroyObjectCmd::Serialize(size_t commandSize, SerializeBuffer* buffer) const {\n    DestroyObjectTransfer* transfer;\n    WIRE_TRY(buffer->Next(&transfer));\n    transfer->commandSize = commandSize;\n    return (DestroyObjectSerialize(*this, transfer, buffer));\n}\nWireResult DestroyObjectCmd::Serialize(\n    size_t commandSize,\n    SerializeBuffer* buffer,\n    const ObjectIdProvider&\n) const {\n    return Serialize(commandSize, buffer);\n}\n\nWireResult DestroyObjectCmd::Deserialize(DeserializeBuffer* deserializeBuffer, DeserializeAllocator* allocator) {\n    const volatile DestroyObjectTransfer* transfer;\n    WIRE_TRY(deserializeBuffer->Read(&transfer));\n    return DestroyObjectDeserialize(this, transfer, deserializeBuffer, allocator);\n}\nWireResult DestroyObjectCmd::Deserialize(\n    DeserializeBuffer* deserializeBuffer,\n    DeserializeAllocator* allocator,\n    const ObjectIdResolver&\n) {\n    return Deserialize(deserializeBuffer, allocator);\n}\n\n        \nsize_t DeviceCreateBindGroupCmd::GetRequiredSize() const {\n    size_t size = sizeof(DeviceCreateBindGroupTransfer) + DeviceCreateBindGroupGetExtraRequiredSize(*this);\n    return size;\n}\n\nWireResult DeviceCreateBindGroupCmd::Serialize(\n    size_t commandSize,\n    SerializeBuffer* buffer,\n    const ObjectIdProvider& provider\n) const {\n    DeviceCreateBindGroupTransfer* transfer;\n    WIRE_TRY(buffer->Next(&transfer));\n    transfer->commandSize = commandSize;\n    return (DeviceCreateBindGroupSerialize(*this, transfer, buffer, provider));\n}\nWireResult DeviceCreateBindGroupCmd::Serialize(size_t commandSize, SerializeBuffer* buffer) const {\n    ErrorObjectIdProvider provider;\n    return Serialize(commandSize, buffer, provider);\n}\n\nWireResult DeviceCreateBindGroupCmd::Deserialize(\n    DeserializeBuffer* deserializeBuffer,\n    DeserializeAllocator* allocator,\n    const ObjectIdResolver& resolver\n) {\n    const volatile DeviceCreateBindGroupTransfer* transfer;\n    WIRE_TRY(deserializeBuffer->Read(&transfer));\n    return DeviceCreateBindGroupDeserialize(this, transfer, deserializeBuffer, allocator, resolver);\n}\nWireResult DeviceCreateBindGroupCmd::Deserialize(DeserializeBuffer* deserializeBuffer, DeserializeAllocator* allocator) {\n    ErrorObjectIdResolver resolver;\n    return Deserialize(deserializeBuffer, allocator, resolver);\n}\n\n        \nsize_t DeviceCreateBindGroupLayoutCmd::GetRequiredSize() const {\n    size_t size = sizeof(DeviceCreateBindGroupLayoutTransfer) + DeviceCreateBindGroupLayoutGetExtraRequiredSize(*this);\n    return size;\n}\n\nWireResult DeviceCreateBindGroupLayoutCmd::Serialize(\n    size_t commandSize,\n    SerializeBuffer* buffer,\n    const ObjectIdProvider& provider\n) const {\n    DeviceCreateBindGroupLayoutTransfer* transfer;\n    WIRE_TRY(buffer->Next(&transfer));\n    transfer->commandSize = commandSize;\n    return (DeviceCreateBindGroupLayoutSerialize(*this, transfer, buffer, provider));\n}\nWireResult DeviceCreateBindGroupLayoutCmd::Serialize(size_t commandSize, SerializeBuffer* buffer) const {\n    ErrorObjectIdProvider provider;\n    return Serialize(commandSize, buffer, provider);\n}\n\nWireResult DeviceCreateBindGroupLayoutCmd::Deserialize(\n    DeserializeBuffer* deserializeBuffer,\n    DeserializeAllocator* allocator,\n    const ObjectIdResolver& resolver\n) {\n    const volatile DeviceCreateBindGroupLayoutTransfer* transfer;\n    WIRE_TRY(deserializeBuffer->Read(&transfer));\n    return DeviceCreateBindGroupLayoutDeserialize(this, transfer, deserializeBuffer, allocator, resolver);\n}\nWireResult DeviceCreateBindGroupLayoutCmd::Deserialize(DeserializeBuffer* deserializeBuffer, DeserializeAllocator* allocator) {\n    ErrorObjectIdResolver resolver;\n    return Deserialize(deserializeBuffer, allocator, resolver);\n}\n\n        \nsize_t DeviceCreateBufferCmd::GetRequiredSize() const {\n    size_t size = sizeof(DeviceCreateBufferTransfer) + DeviceCreateBufferGetExtraRequiredSize(*this);\n    return size;\n}\n\nWireResult DeviceCreateBufferCmd::Serialize(\n    size_t commandSize,\n    SerializeBuffer* buffer,\n    const ObjectIdProvider& provider\n) const {\n    DeviceCreateBufferTransfer* transfer;\n    WIRE_TRY(buffer->Next(&transfer));\n    transfer->commandSize = commandSize;\n    return (DeviceCreateBufferSerialize(*this, transfer, buffer, provider));\n}\nWireResult DeviceCreateBufferCmd::Serialize(size_t commandSize, SerializeBuffer* buffer) const {\n    ErrorObjectIdProvider provider;\n    return Serialize(commandSize, buffer, provider);\n}\n\nWireResult DeviceCreateBufferCmd::Deserialize(\n    DeserializeBuffer* deserializeBuffer,\n    DeserializeAllocator* allocator,\n    const ObjectIdResolver& resolver\n) {\n    const volatile DeviceCreateBufferTransfer* transfer;\n    WIRE_TRY(deserializeBuffer->Read(&transfer));\n    return DeviceCreateBufferDeserialize(this, transfer, deserializeBuffer, allocator, resolver);\n}\nWireResult DeviceCreateBufferCmd::Deserialize(DeserializeBuffer* deserializeBuffer, DeserializeAllocator* allocator) {\n    ErrorObjectIdResolver resolver;\n    return Deserialize(deserializeBuffer, allocator, resolver);\n}\n\n        \nsize_t DeviceCreateCommandEncoderCmd::GetRequiredSize() const {\n    size_t size = sizeof(DeviceCreateCommandEncoderTransfer) + DeviceCreateCommandEncoderGetExtraRequiredSize(*this);\n    return size;\n}\n\nWireResult DeviceCreateCommandEncoderCmd::Serialize(\n    size_t commandSize,\n    SerializeBuffer* buffer,\n    const ObjectIdProvider& provider\n) const {\n    DeviceCreateCommandEncoderTransfer* transfer;\n    WIRE_TRY(buffer->Next(&transfer));\n    transfer->commandSize = commandSize;\n    return (DeviceCreateCommandEncoderSerialize(*this, transfer, buffer, provider));\n}\nWireResult DeviceCreateCommandEncoderCmd::Serialize(size_t commandSize, SerializeBuffer* buffer) const {\n    ErrorObjectIdProvider provider;\n    return Serialize(commandSize, buffer, provider);\n}\n\nWireResult DeviceCreateCommandEncoderCmd::Deserialize(\n    DeserializeBuffer* deserializeBuffer,\n    DeserializeAllocator* allocator,\n    const ObjectIdResolver& resolver\n) {\n    const volatile DeviceCreateCommandEncoderTransfer* transfer;\n    WIRE_TRY(deserializeBuffer->Read(&transfer));\n    return DeviceCreateCommandEncoderDeserialize(this, transfer, deserializeBuffer, allocator, resolver);\n}\nWireResult DeviceCreateCommandEncoderCmd::Deserialize(DeserializeBuffer* deserializeBuffer, DeserializeAllocator* allocator) {\n    ErrorObjectIdResolver resolver;\n    return Deserialize(deserializeBuffer, allocator, resolver);\n}\n\n        \nsize_t DeviceCreateComputePipelineCmd::GetRequiredSize() const {\n    size_t size = sizeof(DeviceCreateComputePipelineTransfer) + DeviceCreateComputePipelineGetExtraRequiredSize(*this);\n    return size;\n}\n\nWireResult DeviceCreateComputePipelineCmd::Serialize(\n    size_t commandSize,\n    SerializeBuffer* buffer,\n    const ObjectIdProvider& provider\n) const {\n    DeviceCreateComputePipelineTransfer* transfer;\n    WIRE_TRY(buffer->Next(&transfer));\n    transfer->commandSize = commandSize;\n    return (DeviceCreateComputePipelineSerialize(*this, transfer, buffer, provider));\n}\nWireResult DeviceCreateComputePipelineCmd::Serialize(size_t commandSize, SerializeBuffer* buffer) const {\n    ErrorObjectIdProvider provider;\n    return Serialize(commandSize, buffer, provider);\n}\n\nWireResult DeviceCreateComputePipelineCmd::Deserialize(\n    DeserializeBuffer* deserializeBuffer,\n    DeserializeAllocator* allocator,\n    const ObjectIdResolver& resolver\n) {\n    const volatile DeviceCreateComputePipelineTransfer* transfer;\n    WIRE_TRY(deserializeBuffer->Read(&transfer));\n    return DeviceCreateComputePipelineDeserialize(this, transfer, deserializeBuffer, allocator, resolver);\n}\nWireResult DeviceCreateComputePipelineCmd::Deserialize(DeserializeBuffer* deserializeBuffer, DeserializeAllocator* allocator) {\n    ErrorObjectIdResolver resolver;\n    return Deserialize(deserializeBuffer, allocator, resolver);\n}\n\n        \nsize_t DeviceCreateComputePipelineAsyncCmd::GetRequiredSize() const {\n    size_t size = sizeof(DeviceCreateComputePipelineAsyncTransfer) + DeviceCreateComputePipelineAsyncGetExtraRequiredSize(*this);\n    return size;\n}\n\nWireResult DeviceCreateComputePipelineAsyncCmd::Serialize(\n    size_t commandSize,\n    SerializeBuffer* buffer,\n    const ObjectIdProvider& provider\n) const {\n    DeviceCreateComputePipelineAsyncTransfer* transfer;\n    WIRE_TRY(buffer->Next(&transfer));\n    transfer->commandSize = commandSize;\n    return (DeviceCreateComputePipelineAsyncSerialize(*this, transfer, buffer, provider));\n}\nWireResult DeviceCreateComputePipelineAsyncCmd::Serialize(size_t commandSize, SerializeBuffer* buffer) const {\n    ErrorObjectIdProvider provider;\n    return Serialize(commandSize, buffer, provider);\n}\n\nWireResult DeviceCreateComputePipelineAsyncCmd::Deserialize(\n    DeserializeBuffer* deserializeBuffer,\n    DeserializeAllocator* allocator,\n    const ObjectIdResolver& resolver\n) {\n    const volatile DeviceCreateComputePipelineAsyncTransfer* transfer;\n    WIRE_TRY(deserializeBuffer->Read(&transfer));\n    return DeviceCreateComputePipelineAsyncDeserialize(this, transfer, deserializeBuffer, allocator, resolver);\n}\nWireResult DeviceCreateComputePipelineAsyncCmd::Deserialize(DeserializeBuffer* deserializeBuffer, DeserializeAllocator* allocator) {\n    ErrorObjectIdResolver resolver;\n    return Deserialize(deserializeBuffer, allocator, resolver);\n}\n\n        \nsize_t DeviceCreateErrorBufferCmd::GetRequiredSize() const {\n    size_t size = sizeof(DeviceCreateErrorBufferTransfer) + DeviceCreateErrorBufferGetExtraRequiredSize(*this);\n    return size;\n}\n\nWireResult DeviceCreateErrorBufferCmd::Serialize(\n    size_t commandSize,\n    SerializeBuffer* buffer,\n    const ObjectIdProvider& provider\n) const {\n    DeviceCreateErrorBufferTransfer* transfer;\n    WIRE_TRY(buffer->Next(&transfer));\n    transfer->commandSize = commandSize;\n    return (DeviceCreateErrorBufferSerialize(*this, transfer, buffer, provider));\n}\nWireResult DeviceCreateErrorBufferCmd::Serialize(size_t commandSize, SerializeBuffer* buffer) const {\n    ErrorObjectIdProvider provider;\n    return Serialize(commandSize, buffer, provider);\n}\n\nWireResult DeviceCreateErrorBufferCmd::Deserialize(\n    DeserializeBuffer* deserializeBuffer,\n    DeserializeAllocator* allocator,\n    const ObjectIdResolver& resolver\n) {\n    const volatile DeviceCreateErrorBufferTransfer* transfer;\n    WIRE_TRY(deserializeBuffer->Read(&transfer));\n    return DeviceCreateErrorBufferDeserialize(this, transfer, deserializeBuffer, allocator, resolver);\n}\nWireResult DeviceCreateErrorBufferCmd::Deserialize(DeserializeBuffer* deserializeBuffer, DeserializeAllocator* allocator) {\n    ErrorObjectIdResolver resolver;\n    return Deserialize(deserializeBuffer, allocator, resolver);\n}\n\n        \nsize_t DeviceCreateErrorExternalTextureCmd::GetRequiredSize() const {\n    size_t size = sizeof(DeviceCreateErrorExternalTextureTransfer) + DeviceCreateErrorExternalTextureGetExtraRequiredSize(*this);\n    return size;\n}\n\nWireResult DeviceCreateErrorExternalTextureCmd::Serialize(\n    size_t commandSize,\n    SerializeBuffer* buffer,\n    const ObjectIdProvider& provider\n) const {\n    DeviceCreateErrorExternalTextureTransfer* transfer;\n    WIRE_TRY(buffer->Next(&transfer));\n    transfer->commandSize = commandSize;\n    return (DeviceCreateErrorExternalTextureSerialize(*this, transfer, buffer, provider));\n}\nWireResult DeviceCreateErrorExternalTextureCmd::Serialize(size_t commandSize, SerializeBuffer* buffer) const {\n    ErrorObjectIdProvider provider;\n    return Serialize(commandSize, buffer, provider);\n}\n\nWireResult DeviceCreateErrorExternalTextureCmd::Deserialize(\n    DeserializeBuffer* deserializeBuffer,\n    DeserializeAllocator* allocator,\n    const ObjectIdResolver& resolver\n) {\n    const volatile DeviceCreateErrorExternalTextureTransfer* transfer;\n    WIRE_TRY(deserializeBuffer->Read(&transfer));\n    return DeviceCreateErrorExternalTextureDeserialize(this, transfer, deserializeBuffer, allocator, resolver);\n}\nWireResult DeviceCreateErrorExternalTextureCmd::Deserialize(DeserializeBuffer* deserializeBuffer, DeserializeAllocator* allocator) {\n    ErrorObjectIdResolver resolver;\n    return Deserialize(deserializeBuffer, allocator, resolver);\n}\n\n        \nsize_t DeviceCreateErrorTextureCmd::GetRequiredSize() const {\n    size_t size = sizeof(DeviceCreateErrorTextureTransfer) + DeviceCreateErrorTextureGetExtraRequiredSize(*this);\n    return size;\n}\n\nWireResult DeviceCreateErrorTextureCmd::Serialize(\n    size_t commandSize,\n    SerializeBuffer* buffer,\n    const ObjectIdProvider& provider\n) const {\n    DeviceCreateErrorTextureTransfer* transfer;\n    WIRE_TRY(buffer->Next(&transfer));\n    transfer->commandSize = commandSize;\n    return (DeviceCreateErrorTextureSerialize(*this, transfer, buffer, provider));\n}\nWireResult DeviceCreateErrorTextureCmd::Serialize(size_t commandSize, SerializeBuffer* buffer) const {\n    ErrorObjectIdProvider provider;\n    return Serialize(commandSize, buffer, provider);\n}\n\nWireResult DeviceCreateErrorTextureCmd::Deserialize(\n    DeserializeBuffer* deserializeBuffer,\n    DeserializeAllocator* allocator,\n    const ObjectIdResolver& resolver\n) {\n    const volatile DeviceCreateErrorTextureTransfer* transfer;\n    WIRE_TRY(deserializeBuffer->Read(&transfer));\n    return DeviceCreateErrorTextureDeserialize(this, transfer, deserializeBuffer, allocator, resolver);\n}\nWireResult DeviceCreateErrorTextureCmd::Deserialize(DeserializeBuffer* deserializeBuffer, DeserializeAllocator* allocator) {\n    ErrorObjectIdResolver resolver;\n    return Deserialize(deserializeBuffer, allocator, resolver);\n}\n\n        \nsize_t DeviceCreateExternalTextureCmd::GetRequiredSize() const {\n    size_t size = sizeof(DeviceCreateExternalTextureTransfer) + DeviceCreateExternalTextureGetExtraRequiredSize(*this);\n    return size;\n}\n\nWireResult DeviceCreateExternalTextureCmd::Serialize(\n    size_t commandSize,\n    SerializeBuffer* buffer,\n    const ObjectIdProvider& provider\n) const {\n    DeviceCreateExternalTextureTransfer* transfer;\n    WIRE_TRY(buffer->Next(&transfer));\n    transfer->commandSize = commandSize;\n    return (DeviceCreateExternalTextureSerialize(*this, transfer, buffer, provider));\n}\nWireResult DeviceCreateExternalTextureCmd::Serialize(size_t commandSize, SerializeBuffer* buffer) const {\n    ErrorObjectIdProvider provider;\n    return Serialize(commandSize, buffer, provider);\n}\n\nWireResult DeviceCreateExternalTextureCmd::Deserialize(\n    DeserializeBuffer* deserializeBuffer,\n    DeserializeAllocator* allocator,\n    const ObjectIdResolver& resolver\n) {\n    const volatile DeviceCreateExternalTextureTransfer* transfer;\n    WIRE_TRY(deserializeBuffer->Read(&transfer));\n    return DeviceCreateExternalTextureDeserialize(this, transfer, deserializeBuffer, allocator, resolver);\n}\nWireResult DeviceCreateExternalTextureCmd::Deserialize(DeserializeBuffer* deserializeBuffer, DeserializeAllocator* allocator) {\n    ErrorObjectIdResolver resolver;\n    return Deserialize(deserializeBuffer, allocator, resolver);\n}\n\n        \nsize_t DeviceCreatePipelineLayoutCmd::GetRequiredSize() const {\n    size_t size = sizeof(DeviceCreatePipelineLayoutTransfer) + DeviceCreatePipelineLayoutGetExtraRequiredSize(*this);\n    return size;\n}\n\nWireResult DeviceCreatePipelineLayoutCmd::Serialize(\n    size_t commandSize,\n    SerializeBuffer* buffer,\n    const ObjectIdProvider& provider\n) const {\n    DeviceCreatePipelineLayoutTransfer* transfer;\n    WIRE_TRY(buffer->Next(&transfer));\n    transfer->commandSize = commandSize;\n    return (DeviceCreatePipelineLayoutSerialize(*this, transfer, buffer, provider));\n}\nWireResult DeviceCreatePipelineLayoutCmd::Serialize(size_t commandSize, SerializeBuffer* buffer) const {\n    ErrorObjectIdProvider provider;\n    return Serialize(commandSize, buffer, provider);\n}\n\nWireResult DeviceCreatePipelineLayoutCmd::Deserialize(\n    DeserializeBuffer* deserializeBuffer,\n    DeserializeAllocator* allocator,\n    const ObjectIdResolver& resolver\n) {\n    const volatile DeviceCreatePipelineLayoutTransfer* transfer;\n    WIRE_TRY(deserializeBuffer->Read(&transfer));\n    return DeviceCreatePipelineLayoutDeserialize(this, transfer, deserializeBuffer, allocator, resolver);\n}\nWireResult DeviceCreatePipelineLayoutCmd::Deserialize(DeserializeBuffer* deserializeBuffer, DeserializeAllocator* allocator) {\n    ErrorObjectIdResolver resolver;\n    return Deserialize(deserializeBuffer, allocator, resolver);\n}\n\n        \nsize_t DeviceCreateQuerySetCmd::GetRequiredSize() const {\n    size_t size = sizeof(DeviceCreateQuerySetTransfer) + DeviceCreateQuerySetGetExtraRequiredSize(*this);\n    return size;\n}\n\nWireResult DeviceCreateQuerySetCmd::Serialize(\n    size_t commandSize,\n    SerializeBuffer* buffer,\n    const ObjectIdProvider& provider\n) const {\n    DeviceCreateQuerySetTransfer* transfer;\n    WIRE_TRY(buffer->Next(&transfer));\n    transfer->commandSize = commandSize;\n    return (DeviceCreateQuerySetSerialize(*this, transfer, buffer, provider));\n}\nWireResult DeviceCreateQuerySetCmd::Serialize(size_t commandSize, SerializeBuffer* buffer) const {\n    ErrorObjectIdProvider provider;\n    return Serialize(commandSize, buffer, provider);\n}\n\nWireResult DeviceCreateQuerySetCmd::Deserialize(\n    DeserializeBuffer* deserializeBuffer,\n    DeserializeAllocator* allocator,\n    const ObjectIdResolver& resolver\n) {\n    const volatile DeviceCreateQuerySetTransfer* transfer;\n    WIRE_TRY(deserializeBuffer->Read(&transfer));\n    return DeviceCreateQuerySetDeserialize(this, transfer, deserializeBuffer, allocator, resolver);\n}\nWireResult DeviceCreateQuerySetCmd::Deserialize(DeserializeBuffer* deserializeBuffer, DeserializeAllocator* allocator) {\n    ErrorObjectIdResolver resolver;\n    return Deserialize(deserializeBuffer, allocator, resolver);\n}\n\n        \nsize_t DeviceCreateRenderBundleEncoderCmd::GetRequiredSize() const {\n    size_t size = sizeof(DeviceCreateRenderBundleEncoderTransfer) + DeviceCreateRenderBundleEncoderGetExtraRequiredSize(*this);\n    return size;\n}\n\nWireResult DeviceCreateRenderBundleEncoderCmd::Serialize(\n    size_t commandSize,\n    SerializeBuffer* buffer,\n    const ObjectIdProvider& provider\n) const {\n    DeviceCreateRenderBundleEncoderTransfer* transfer;\n    WIRE_TRY(buffer->Next(&transfer));\n    transfer->commandSize = commandSize;\n    return (DeviceCreateRenderBundleEncoderSerialize(*this, transfer, buffer, provider));\n}\nWireResult DeviceCreateRenderBundleEncoderCmd::Serialize(size_t commandSize, SerializeBuffer* buffer) const {\n    ErrorObjectIdProvider provider;\n    return Serialize(commandSize, buffer, provider);\n}\n\nWireResult DeviceCreateRenderBundleEncoderCmd::Deserialize(\n    DeserializeBuffer* deserializeBuffer,\n    DeserializeAllocator* allocator,\n    const ObjectIdResolver& resolver\n) {\n    const volatile DeviceCreateRenderBundleEncoderTransfer* transfer;\n    WIRE_TRY(deserializeBuffer->Read(&transfer));\n    return DeviceCreateRenderBundleEncoderDeserialize(this, transfer, deserializeBuffer, allocator, resolver);\n}\nWireResult DeviceCreateRenderBundleEncoderCmd::Deserialize(DeserializeBuffer* deserializeBuffer, DeserializeAllocator* allocator) {\n    ErrorObjectIdResolver resolver;\n    return Deserialize(deserializeBuffer, allocator, resolver);\n}\n\n        \nsize_t DeviceCreateRenderPipelineCmd::GetRequiredSize() const {\n    size_t size = sizeof(DeviceCreateRenderPipelineTransfer) + DeviceCreateRenderPipelineGetExtraRequiredSize(*this);\n    return size;\n}\n\nWireResult DeviceCreateRenderPipelineCmd::Serialize(\n    size_t commandSize,\n    SerializeBuffer* buffer,\n    const ObjectIdProvider& provider\n) const {\n    DeviceCreateRenderPipelineTransfer* transfer;\n    WIRE_TRY(buffer->Next(&transfer));\n    transfer->commandSize = commandSize;\n    return (DeviceCreateRenderPipelineSerialize(*this, transfer, buffer, provider));\n}\nWireResult DeviceCreateRenderPipelineCmd::Serialize(size_t commandSize, SerializeBuffer* buffer) const {\n    ErrorObjectIdProvider provider;\n    return Serialize(commandSize, buffer, provider);\n}\n\nWireResult DeviceCreateRenderPipelineCmd::Deserialize(\n    DeserializeBuffer* deserializeBuffer,\n    DeserializeAllocator* allocator,\n    const ObjectIdResolver& resolver\n) {\n    const volatile DeviceCreateRenderPipelineTransfer* transfer;\n    WIRE_TRY(deserializeBuffer->Read(&transfer));\n    return DeviceCreateRenderPipelineDeserialize(this, transfer, deserializeBuffer, allocator, resolver);\n}\nWireResult DeviceCreateRenderPipelineCmd::Deserialize(DeserializeBuffer* deserializeBuffer, DeserializeAllocator* allocator) {\n    ErrorObjectIdResolver resolver;\n    return Deserialize(deserializeBuffer, allocator, resolver);\n}\n\n        \nsize_t DeviceCreateRenderPipelineAsyncCmd::GetRequiredSize() const {\n    size_t size = sizeof(DeviceCreateRenderPipelineAsyncTransfer) + DeviceCreateRenderPipelineAsyncGetExtraRequiredSize(*this);\n    return size;\n}\n\nWireResult DeviceCreateRenderPipelineAsyncCmd::Serialize(\n    size_t commandSize,\n    SerializeBuffer* buffer,\n    const ObjectIdProvider& provider\n) const {\n    DeviceCreateRenderPipelineAsyncTransfer* transfer;\n    WIRE_TRY(buffer->Next(&transfer));\n    transfer->commandSize = commandSize;\n    return (DeviceCreateRenderPipelineAsyncSerialize(*this, transfer, buffer, provider));\n}\nWireResult DeviceCreateRenderPipelineAsyncCmd::Serialize(size_t commandSize, SerializeBuffer* buffer) const {\n    ErrorObjectIdProvider provider;\n    return Serialize(commandSize, buffer, provider);\n}\n\nWireResult DeviceCreateRenderPipelineAsyncCmd::Deserialize(\n    DeserializeBuffer* deserializeBuffer,\n    DeserializeAllocator* allocator,\n    const ObjectIdResolver& resolver\n) {\n    const volatile DeviceCreateRenderPipelineAsyncTransfer* transfer;\n    WIRE_TRY(deserializeBuffer->Read(&transfer));\n    return DeviceCreateRenderPipelineAsyncDeserialize(this, transfer, deserializeBuffer, allocator, resolver);\n}\nWireResult DeviceCreateRenderPipelineAsyncCmd::Deserialize(DeserializeBuffer* deserializeBuffer, DeserializeAllocator* allocator) {\n    ErrorObjectIdResolver resolver;\n    return Deserialize(deserializeBuffer, allocator, resolver);\n}\n\n        \nsize_t DeviceCreateSamplerCmd::GetRequiredSize() const {\n    size_t size = sizeof(DeviceCreateSamplerTransfer) + DeviceCreateSamplerGetExtraRequiredSize(*this);\n    return size;\n}\n\nWireResult DeviceCreateSamplerCmd::Serialize(\n    size_t commandSize,\n    SerializeBuffer* buffer,\n    const ObjectIdProvider& provider\n) const {\n    DeviceCreateSamplerTransfer* transfer;\n    WIRE_TRY(buffer->Next(&transfer));\n    transfer->commandSize = commandSize;\n    return (DeviceCreateSamplerSerialize(*this, transfer, buffer, provider));\n}\nWireResult DeviceCreateSamplerCmd::Serialize(size_t commandSize, SerializeBuffer* buffer) const {\n    ErrorObjectIdProvider provider;\n    return Serialize(commandSize, buffer, provider);\n}\n\nWireResult DeviceCreateSamplerCmd::Deserialize(\n    DeserializeBuffer* deserializeBuffer,\n    DeserializeAllocator* allocator,\n    const ObjectIdResolver& resolver\n) {\n    const volatile DeviceCreateSamplerTransfer* transfer;\n    WIRE_TRY(deserializeBuffer->Read(&transfer));\n    return DeviceCreateSamplerDeserialize(this, transfer, deserializeBuffer, allocator, resolver);\n}\nWireResult DeviceCreateSamplerCmd::Deserialize(DeserializeBuffer* deserializeBuffer, DeserializeAllocator* allocator) {\n    ErrorObjectIdResolver resolver;\n    return Deserialize(deserializeBuffer, allocator, resolver);\n}\n\n        \nsize_t DeviceCreateShaderModuleCmd::GetRequiredSize() const {\n    size_t size = sizeof(DeviceCreateShaderModuleTransfer) + DeviceCreateShaderModuleGetExtraRequiredSize(*this);\n    return size;\n}\n\nWireResult DeviceCreateShaderModuleCmd::Serialize(\n    size_t commandSize,\n    SerializeBuffer* buffer,\n    const ObjectIdProvider& provider\n) const {\n    DeviceCreateShaderModuleTransfer* transfer;\n    WIRE_TRY(buffer->Next(&transfer));\n    transfer->commandSize = commandSize;\n    return (DeviceCreateShaderModuleSerialize(*this, transfer, buffer, provider));\n}\nWireResult DeviceCreateShaderModuleCmd::Serialize(size_t commandSize, SerializeBuffer* buffer) const {\n    ErrorObjectIdProvider provider;\n    return Serialize(commandSize, buffer, provider);\n}\n\nWireResult DeviceCreateShaderModuleCmd::Deserialize(\n    DeserializeBuffer* deserializeBuffer,\n    DeserializeAllocator* allocator,\n    const ObjectIdResolver& resolver\n) {\n    const volatile DeviceCreateShaderModuleTransfer* transfer;\n    WIRE_TRY(deserializeBuffer->Read(&transfer));\n    return DeviceCreateShaderModuleDeserialize(this, transfer, deserializeBuffer, allocator, resolver);\n}\nWireResult DeviceCreateShaderModuleCmd::Deserialize(DeserializeBuffer* deserializeBuffer, DeserializeAllocator* allocator) {\n    ErrorObjectIdResolver resolver;\n    return Deserialize(deserializeBuffer, allocator, resolver);\n}\n\n        \nsize_t DeviceCreateSwapChainCmd::GetRequiredSize() const {\n    size_t size = sizeof(DeviceCreateSwapChainTransfer) + DeviceCreateSwapChainGetExtraRequiredSize(*this);\n    return size;\n}\n\nWireResult DeviceCreateSwapChainCmd::Serialize(\n    size_t commandSize,\n    SerializeBuffer* buffer,\n    const ObjectIdProvider& provider\n) const {\n    DeviceCreateSwapChainTransfer* transfer;\n    WIRE_TRY(buffer->Next(&transfer));\n    transfer->commandSize = commandSize;\n    return (DeviceCreateSwapChainSerialize(*this, transfer, buffer, provider));\n}\nWireResult DeviceCreateSwapChainCmd::Serialize(size_t commandSize, SerializeBuffer* buffer) const {\n    ErrorObjectIdProvider provider;\n    return Serialize(commandSize, buffer, provider);\n}\n\nWireResult DeviceCreateSwapChainCmd::Deserialize(\n    DeserializeBuffer* deserializeBuffer,\n    DeserializeAllocator* allocator,\n    const ObjectIdResolver& resolver\n) {\n    const volatile DeviceCreateSwapChainTransfer* transfer;\n    WIRE_TRY(deserializeBuffer->Read(&transfer));\n    return DeviceCreateSwapChainDeserialize(this, transfer, deserializeBuffer, allocator, resolver);\n}\nWireResult DeviceCreateSwapChainCmd::Deserialize(DeserializeBuffer* deserializeBuffer, DeserializeAllocator* allocator) {\n    ErrorObjectIdResolver resolver;\n    return Deserialize(deserializeBuffer, allocator, resolver);\n}\n\n        \nsize_t DeviceCreateTextureCmd::GetRequiredSize() const {\n    size_t size = sizeof(DeviceCreateTextureTransfer) + DeviceCreateTextureGetExtraRequiredSize(*this);\n    return size;\n}\n\nWireResult DeviceCreateTextureCmd::Serialize(\n    size_t commandSize,\n    SerializeBuffer* buffer,\n    const ObjectIdProvider& provider\n) const {\n    DeviceCreateTextureTransfer* transfer;\n    WIRE_TRY(buffer->Next(&transfer));\n    transfer->commandSize = commandSize;\n    return (DeviceCreateTextureSerialize(*this, transfer, buffer, provider));\n}\nWireResult DeviceCreateTextureCmd::Serialize(size_t commandSize, SerializeBuffer* buffer) const {\n    ErrorObjectIdProvider provider;\n    return Serialize(commandSize, buffer, provider);\n}\n\nWireResult DeviceCreateTextureCmd::Deserialize(\n    DeserializeBuffer* deserializeBuffer,\n    DeserializeAllocator* allocator,\n    const ObjectIdResolver& resolver\n) {\n    const volatile DeviceCreateTextureTransfer* transfer;\n    WIRE_TRY(deserializeBuffer->Read(&transfer));\n    return DeviceCreateTextureDeserialize(this, transfer, deserializeBuffer, allocator, resolver);\n}\nWireResult DeviceCreateTextureCmd::Deserialize(DeserializeBuffer* deserializeBuffer, DeserializeAllocator* allocator) {\n    ErrorObjectIdResolver resolver;\n    return Deserialize(deserializeBuffer, allocator, resolver);\n}\n\n        \nsize_t DeviceDestroyCmd::GetRequiredSize() const {\n    size_t size = sizeof(DeviceDestroyTransfer) + DeviceDestroyGetExtraRequiredSize(*this);\n    return size;\n}\n\nWireResult DeviceDestroyCmd::Serialize(\n    size_t commandSize,\n    SerializeBuffer* buffer,\n    const ObjectIdProvider& provider\n) const {\n    DeviceDestroyTransfer* transfer;\n    WIRE_TRY(buffer->Next(&transfer));\n    transfer->commandSize = commandSize;\n    return (DeviceDestroySerialize(*this, transfer, buffer, provider));\n}\nWireResult DeviceDestroyCmd::Serialize(size_t commandSize, SerializeBuffer* buffer) const {\n    ErrorObjectIdProvider provider;\n    return Serialize(commandSize, buffer, provider);\n}\n\nWireResult DeviceDestroyCmd::Deserialize(\n    DeserializeBuffer* deserializeBuffer,\n    DeserializeAllocator* allocator,\n    const ObjectIdResolver& resolver\n) {\n    const volatile DeviceDestroyTransfer* transfer;\n    WIRE_TRY(deserializeBuffer->Read(&transfer));\n    return DeviceDestroyDeserialize(this, transfer, deserializeBuffer, allocator, resolver);\n}\nWireResult DeviceDestroyCmd::Deserialize(DeserializeBuffer* deserializeBuffer, DeserializeAllocator* allocator) {\n    ErrorObjectIdResolver resolver;\n    return Deserialize(deserializeBuffer, allocator, resolver);\n}\n\n        \nsize_t DeviceGetQueueCmd::GetRequiredSize() const {\n    size_t size = sizeof(DeviceGetQueueTransfer) + DeviceGetQueueGetExtraRequiredSize(*this);\n    return size;\n}\n\nWireResult DeviceGetQueueCmd::Serialize(\n    size_t commandSize,\n    SerializeBuffer* buffer,\n    const ObjectIdProvider& provider\n) const {\n    DeviceGetQueueTransfer* transfer;\n    WIRE_TRY(buffer->Next(&transfer));\n    transfer->commandSize = commandSize;\n    return (DeviceGetQueueSerialize(*this, transfer, buffer, provider));\n}\nWireResult DeviceGetQueueCmd::Serialize(size_t commandSize, SerializeBuffer* buffer) const {\n    ErrorObjectIdProvider provider;\n    return Serialize(commandSize, buffer, provider);\n}\n\nWireResult DeviceGetQueueCmd::Deserialize(\n    DeserializeBuffer* deserializeBuffer,\n    DeserializeAllocator* allocator,\n    const ObjectIdResolver& resolver\n) {\n    const volatile DeviceGetQueueTransfer* transfer;\n    WIRE_TRY(deserializeBuffer->Read(&transfer));\n    return DeviceGetQueueDeserialize(this, transfer, deserializeBuffer, allocator, resolver);\n}\nWireResult DeviceGetQueueCmd::Deserialize(DeserializeBuffer* deserializeBuffer, DeserializeAllocator* allocator) {\n    ErrorObjectIdResolver resolver;\n    return Deserialize(deserializeBuffer, allocator, resolver);\n}\n\n        \nsize_t DeviceInjectErrorCmd::GetRequiredSize() const {\n    size_t size = sizeof(DeviceInjectErrorTransfer) + DeviceInjectErrorGetExtraRequiredSize(*this);\n    return size;\n}\n\nWireResult DeviceInjectErrorCmd::Serialize(\n    size_t commandSize,\n    SerializeBuffer* buffer,\n    const ObjectIdProvider& provider\n) const {\n    DeviceInjectErrorTransfer* transfer;\n    WIRE_TRY(buffer->Next(&transfer));\n    transfer->commandSize = commandSize;\n    return (DeviceInjectErrorSerialize(*this, transfer, buffer, provider));\n}\nWireResult DeviceInjectErrorCmd::Serialize(size_t commandSize, SerializeBuffer* buffer) const {\n    ErrorObjectIdProvider provider;\n    return Serialize(commandSize, buffer, provider);\n}\n\nWireResult DeviceInjectErrorCmd::Deserialize(\n    DeserializeBuffer* deserializeBuffer,\n    DeserializeAllocator* allocator,\n    const ObjectIdResolver& resolver\n) {\n    const volatile DeviceInjectErrorTransfer* transfer;\n    WIRE_TRY(deserializeBuffer->Read(&transfer));\n    return DeviceInjectErrorDeserialize(this, transfer, deserializeBuffer, allocator, resolver);\n}\nWireResult DeviceInjectErrorCmd::Deserialize(DeserializeBuffer* deserializeBuffer, DeserializeAllocator* allocator) {\n    ErrorObjectIdResolver resolver;\n    return Deserialize(deserializeBuffer, allocator, resolver);\n}\n\n        \nsize_t DeviceLoseForTestingCmd::GetRequiredSize() const {\n    size_t size = sizeof(DeviceLoseForTestingTransfer) + DeviceLoseForTestingGetExtraRequiredSize(*this);\n    return size;\n}\n\nWireResult DeviceLoseForTestingCmd::Serialize(\n    size_t commandSize,\n    SerializeBuffer* buffer,\n    const ObjectIdProvider& provider\n) const {\n    DeviceLoseForTestingTransfer* transfer;\n    WIRE_TRY(buffer->Next(&transfer));\n    transfer->commandSize = commandSize;\n    return (DeviceLoseForTestingSerialize(*this, transfer, buffer, provider));\n}\nWireResult DeviceLoseForTestingCmd::Serialize(size_t commandSize, SerializeBuffer* buffer) const {\n    ErrorObjectIdProvider provider;\n    return Serialize(commandSize, buffer, provider);\n}\n\nWireResult DeviceLoseForTestingCmd::Deserialize(\n    DeserializeBuffer* deserializeBuffer,\n    DeserializeAllocator* allocator,\n    const ObjectIdResolver& resolver\n) {\n    const volatile DeviceLoseForTestingTransfer* transfer;\n    WIRE_TRY(deserializeBuffer->Read(&transfer));\n    return DeviceLoseForTestingDeserialize(this, transfer, deserializeBuffer, allocator, resolver);\n}\nWireResult DeviceLoseForTestingCmd::Deserialize(DeserializeBuffer* deserializeBuffer, DeserializeAllocator* allocator) {\n    ErrorObjectIdResolver resolver;\n    return Deserialize(deserializeBuffer, allocator, resolver);\n}\n\n        \nsize_t DevicePopErrorScopeCmd::GetRequiredSize() const {\n    size_t size = sizeof(DevicePopErrorScopeTransfer) + DevicePopErrorScopeGetExtraRequiredSize(*this);\n    return size;\n}\n\nWireResult DevicePopErrorScopeCmd::Serialize(size_t commandSize, SerializeBuffer* buffer) const {\n    DevicePopErrorScopeTransfer* transfer;\n    WIRE_TRY(buffer->Next(&transfer));\n    transfer->commandSize = commandSize;\n    return (DevicePopErrorScopeSerialize(*this, transfer, buffer));\n}\nWireResult DevicePopErrorScopeCmd::Serialize(\n    size_t commandSize,\n    SerializeBuffer* buffer,\n    const ObjectIdProvider&\n) const {\n    return Serialize(commandSize, buffer);\n}\n\nWireResult DevicePopErrorScopeCmd::Deserialize(DeserializeBuffer* deserializeBuffer, DeserializeAllocator* allocator) {\n    const volatile DevicePopErrorScopeTransfer* transfer;\n    WIRE_TRY(deserializeBuffer->Read(&transfer));\n    return DevicePopErrorScopeDeserialize(this, transfer, deserializeBuffer, allocator);\n}\nWireResult DevicePopErrorScopeCmd::Deserialize(\n    DeserializeBuffer* deserializeBuffer,\n    DeserializeAllocator* allocator,\n    const ObjectIdResolver&\n) {\n    return Deserialize(deserializeBuffer, allocator);\n}\n\n        \nsize_t DevicePushErrorScopeCmd::GetRequiredSize() const {\n    size_t size = sizeof(DevicePushErrorScopeTransfer) + DevicePushErrorScopeGetExtraRequiredSize(*this);\n    return size;\n}\n\nWireResult DevicePushErrorScopeCmd::Serialize(\n    size_t commandSize,\n    SerializeBuffer* buffer,\n    const ObjectIdProvider& provider\n) const {\n    DevicePushErrorScopeTransfer* transfer;\n    WIRE_TRY(buffer->Next(&transfer));\n    transfer->commandSize = commandSize;\n    return (DevicePushErrorScopeSerialize(*this, transfer, buffer, provider));\n}\nWireResult DevicePushErrorScopeCmd::Serialize(size_t commandSize, SerializeBuffer* buffer) const {\n    ErrorObjectIdProvider provider;\n    return Serialize(commandSize, buffer, provider);\n}\n\nWireResult DevicePushErrorScopeCmd::Deserialize(\n    DeserializeBuffer* deserializeBuffer,\n    DeserializeAllocator* allocator,\n    const ObjectIdResolver& resolver\n) {\n    const volatile DevicePushErrorScopeTransfer* transfer;\n    WIRE_TRY(deserializeBuffer->Read(&transfer));\n    return DevicePushErrorScopeDeserialize(this, transfer, deserializeBuffer, allocator, resolver);\n}\nWireResult DevicePushErrorScopeCmd::Deserialize(DeserializeBuffer* deserializeBuffer, DeserializeAllocator* allocator) {\n    ErrorObjectIdResolver resolver;\n    return Deserialize(deserializeBuffer, allocator, resolver);\n}\n\n        \nsize_t DeviceSetLabelCmd::GetRequiredSize() const {\n    size_t size = sizeof(DeviceSetLabelTransfer) + DeviceSetLabelGetExtraRequiredSize(*this);\n    return size;\n}\n\nWireResult DeviceSetLabelCmd::Serialize(\n    size_t commandSize,\n    SerializeBuffer* buffer,\n    const ObjectIdProvider& provider\n) const {\n    DeviceSetLabelTransfer* transfer;\n    WIRE_TRY(buffer->Next(&transfer));\n    transfer->commandSize = commandSize;\n    return (DeviceSetLabelSerialize(*this, transfer, buffer, provider));\n}\nWireResult DeviceSetLabelCmd::Serialize(size_t commandSize, SerializeBuffer* buffer) const {\n    ErrorObjectIdProvider provider;\n    return Serialize(commandSize, buffer, provider);\n}\n\nWireResult DeviceSetLabelCmd::Deserialize(\n    DeserializeBuffer* deserializeBuffer,\n    DeserializeAllocator* allocator,\n    const ObjectIdResolver& resolver\n) {\n    const volatile DeviceSetLabelTransfer* transfer;\n    WIRE_TRY(deserializeBuffer->Read(&transfer));\n    return DeviceSetLabelDeserialize(this, transfer, deserializeBuffer, allocator, resolver);\n}\nWireResult DeviceSetLabelCmd::Deserialize(DeserializeBuffer* deserializeBuffer, DeserializeAllocator* allocator) {\n    ErrorObjectIdResolver resolver;\n    return Deserialize(deserializeBuffer, allocator, resolver);\n}\n\n        \nsize_t DeviceTickCmd::GetRequiredSize() const {\n    size_t size = sizeof(DeviceTickTransfer) + DeviceTickGetExtraRequiredSize(*this);\n    return size;\n}\n\nWireResult DeviceTickCmd::Serialize(\n    size_t commandSize,\n    SerializeBuffer* buffer,\n    const ObjectIdProvider& provider\n) const {\n    DeviceTickTransfer* transfer;\n    WIRE_TRY(buffer->Next(&transfer));\n    transfer->commandSize = commandSize;\n    return (DeviceTickSerialize(*this, transfer, buffer, provider));\n}\nWireResult DeviceTickCmd::Serialize(size_t commandSize, SerializeBuffer* buffer) const {\n    ErrorObjectIdProvider provider;\n    return Serialize(commandSize, buffer, provider);\n}\n\nWireResult DeviceTickCmd::Deserialize(\n    DeserializeBuffer* deserializeBuffer,\n    DeserializeAllocator* allocator,\n    const ObjectIdResolver& resolver\n) {\n    const volatile DeviceTickTransfer* transfer;\n    WIRE_TRY(deserializeBuffer->Read(&transfer));\n    return DeviceTickDeserialize(this, transfer, deserializeBuffer, allocator, resolver);\n}\nWireResult DeviceTickCmd::Deserialize(DeserializeBuffer* deserializeBuffer, DeserializeAllocator* allocator) {\n    ErrorObjectIdResolver resolver;\n    return Deserialize(deserializeBuffer, allocator, resolver);\n}\n\n        \nsize_t ExternalTextureDestroyCmd::GetRequiredSize() const {\n    size_t size = sizeof(ExternalTextureDestroyTransfer) + ExternalTextureDestroyGetExtraRequiredSize(*this);\n    return size;\n}\n\nWireResult ExternalTextureDestroyCmd::Serialize(\n    size_t commandSize,\n    SerializeBuffer* buffer,\n    const ObjectIdProvider& provider\n) const {\n    ExternalTextureDestroyTransfer* transfer;\n    WIRE_TRY(buffer->Next(&transfer));\n    transfer->commandSize = commandSize;\n    return (ExternalTextureDestroySerialize(*this, transfer, buffer, provider));\n}\nWireResult ExternalTextureDestroyCmd::Serialize(size_t commandSize, SerializeBuffer* buffer) const {\n    ErrorObjectIdProvider provider;\n    return Serialize(commandSize, buffer, provider);\n}\n\nWireResult ExternalTextureDestroyCmd::Deserialize(\n    DeserializeBuffer* deserializeBuffer,\n    DeserializeAllocator* allocator,\n    const ObjectIdResolver& resolver\n) {\n    const volatile ExternalTextureDestroyTransfer* transfer;\n    WIRE_TRY(deserializeBuffer->Read(&transfer));\n    return ExternalTextureDestroyDeserialize(this, transfer, deserializeBuffer, allocator, resolver);\n}\nWireResult ExternalTextureDestroyCmd::Deserialize(DeserializeBuffer* deserializeBuffer, DeserializeAllocator* allocator) {\n    ErrorObjectIdResolver resolver;\n    return Deserialize(deserializeBuffer, allocator, resolver);\n}\n\n        \nsize_t ExternalTextureSetLabelCmd::GetRequiredSize() const {\n    size_t size = sizeof(ExternalTextureSetLabelTransfer) + ExternalTextureSetLabelGetExtraRequiredSize(*this);\n    return size;\n}\n\nWireResult ExternalTextureSetLabelCmd::Serialize(\n    size_t commandSize,\n    SerializeBuffer* buffer,\n    const ObjectIdProvider& provider\n) const {\n    ExternalTextureSetLabelTransfer* transfer;\n    WIRE_TRY(buffer->Next(&transfer));\n    transfer->commandSize = commandSize;\n    return (ExternalTextureSetLabelSerialize(*this, transfer, buffer, provider));\n}\nWireResult ExternalTextureSetLabelCmd::Serialize(size_t commandSize, SerializeBuffer* buffer) const {\n    ErrorObjectIdProvider provider;\n    return Serialize(commandSize, buffer, provider);\n}\n\nWireResult ExternalTextureSetLabelCmd::Deserialize(\n    DeserializeBuffer* deserializeBuffer,\n    DeserializeAllocator* allocator,\n    const ObjectIdResolver& resolver\n) {\n    const volatile ExternalTextureSetLabelTransfer* transfer;\n    WIRE_TRY(deserializeBuffer->Read(&transfer));\n    return ExternalTextureSetLabelDeserialize(this, transfer, deserializeBuffer, allocator, resolver);\n}\nWireResult ExternalTextureSetLabelCmd::Deserialize(DeserializeBuffer* deserializeBuffer, DeserializeAllocator* allocator) {\n    ErrorObjectIdResolver resolver;\n    return Deserialize(deserializeBuffer, allocator, resolver);\n}\n\n        \nsize_t InstanceCreateSurfaceCmd::GetRequiredSize() const {\n    size_t size = sizeof(InstanceCreateSurfaceTransfer) + InstanceCreateSurfaceGetExtraRequiredSize(*this);\n    return size;\n}\n\nWireResult InstanceCreateSurfaceCmd::Serialize(\n    size_t commandSize,\n    SerializeBuffer* buffer,\n    const ObjectIdProvider& provider\n) const {\n    InstanceCreateSurfaceTransfer* transfer;\n    WIRE_TRY(buffer->Next(&transfer));\n    transfer->commandSize = commandSize;\n    return (InstanceCreateSurfaceSerialize(*this, transfer, buffer, provider));\n}\nWireResult InstanceCreateSurfaceCmd::Serialize(size_t commandSize, SerializeBuffer* buffer) const {\n    ErrorObjectIdProvider provider;\n    return Serialize(commandSize, buffer, provider);\n}\n\nWireResult InstanceCreateSurfaceCmd::Deserialize(\n    DeserializeBuffer* deserializeBuffer,\n    DeserializeAllocator* allocator,\n    const ObjectIdResolver& resolver\n) {\n    const volatile InstanceCreateSurfaceTransfer* transfer;\n    WIRE_TRY(deserializeBuffer->Read(&transfer));\n    return InstanceCreateSurfaceDeserialize(this, transfer, deserializeBuffer, allocator, resolver);\n}\nWireResult InstanceCreateSurfaceCmd::Deserialize(DeserializeBuffer* deserializeBuffer, DeserializeAllocator* allocator) {\n    ErrorObjectIdResolver resolver;\n    return Deserialize(deserializeBuffer, allocator, resolver);\n}\n\n        \nsize_t InstanceRequestAdapterCmd::GetRequiredSize() const {\n    size_t size = sizeof(InstanceRequestAdapterTransfer) + InstanceRequestAdapterGetExtraRequiredSize(*this);\n    return size;\n}\n\nWireResult InstanceRequestAdapterCmd::Serialize(\n    size_t commandSize,\n    SerializeBuffer* buffer,\n    const ObjectIdProvider& provider\n) const {\n    InstanceRequestAdapterTransfer* transfer;\n    WIRE_TRY(buffer->Next(&transfer));\n    transfer->commandSize = commandSize;\n    return (InstanceRequestAdapterSerialize(*this, transfer, buffer, provider));\n}\nWireResult InstanceRequestAdapterCmd::Serialize(size_t commandSize, SerializeBuffer* buffer) const {\n    ErrorObjectIdProvider provider;\n    return Serialize(commandSize, buffer, provider);\n}\n\nWireResult InstanceRequestAdapterCmd::Deserialize(\n    DeserializeBuffer* deserializeBuffer,\n    DeserializeAllocator* allocator,\n    const ObjectIdResolver& resolver\n) {\n    const volatile InstanceRequestAdapterTransfer* transfer;\n    WIRE_TRY(deserializeBuffer->Read(&transfer));\n    return InstanceRequestAdapterDeserialize(this, transfer, deserializeBuffer, allocator, resolver);\n}\nWireResult InstanceRequestAdapterCmd::Deserialize(DeserializeBuffer* deserializeBuffer, DeserializeAllocator* allocator) {\n    ErrorObjectIdResolver resolver;\n    return Deserialize(deserializeBuffer, allocator, resolver);\n}\n\n        \nsize_t PipelineLayoutSetLabelCmd::GetRequiredSize() const {\n    size_t size = sizeof(PipelineLayoutSetLabelTransfer) + PipelineLayoutSetLabelGetExtraRequiredSize(*this);\n    return size;\n}\n\nWireResult PipelineLayoutSetLabelCmd::Serialize(\n    size_t commandSize,\n    SerializeBuffer* buffer,\n    const ObjectIdProvider& provider\n) const {\n    PipelineLayoutSetLabelTransfer* transfer;\n    WIRE_TRY(buffer->Next(&transfer));\n    transfer->commandSize = commandSize;\n    return (PipelineLayoutSetLabelSerialize(*this, transfer, buffer, provider));\n}\nWireResult PipelineLayoutSetLabelCmd::Serialize(size_t commandSize, SerializeBuffer* buffer) const {\n    ErrorObjectIdProvider provider;\n    return Serialize(commandSize, buffer, provider);\n}\n\nWireResult PipelineLayoutSetLabelCmd::Deserialize(\n    DeserializeBuffer* deserializeBuffer,\n    DeserializeAllocator* allocator,\n    const ObjectIdResolver& resolver\n) {\n    const volatile PipelineLayoutSetLabelTransfer* transfer;\n    WIRE_TRY(deserializeBuffer->Read(&transfer));\n    return PipelineLayoutSetLabelDeserialize(this, transfer, deserializeBuffer, allocator, resolver);\n}\nWireResult PipelineLayoutSetLabelCmd::Deserialize(DeserializeBuffer* deserializeBuffer, DeserializeAllocator* allocator) {\n    ErrorObjectIdResolver resolver;\n    return Deserialize(deserializeBuffer, allocator, resolver);\n}\n\n        \nsize_t QuerySetDestroyCmd::GetRequiredSize() const {\n    size_t size = sizeof(QuerySetDestroyTransfer) + QuerySetDestroyGetExtraRequiredSize(*this);\n    return size;\n}\n\nWireResult QuerySetDestroyCmd::Serialize(\n    size_t commandSize,\n    SerializeBuffer* buffer,\n    const ObjectIdProvider& provider\n) const {\n    QuerySetDestroyTransfer* transfer;\n    WIRE_TRY(buffer->Next(&transfer));\n    transfer->commandSize = commandSize;\n    return (QuerySetDestroySerialize(*this, transfer, buffer, provider));\n}\nWireResult QuerySetDestroyCmd::Serialize(size_t commandSize, SerializeBuffer* buffer) const {\n    ErrorObjectIdProvider provider;\n    return Serialize(commandSize, buffer, provider);\n}\n\nWireResult QuerySetDestroyCmd::Deserialize(\n    DeserializeBuffer* deserializeBuffer,\n    DeserializeAllocator* allocator,\n    const ObjectIdResolver& resolver\n) {\n    const volatile QuerySetDestroyTransfer* transfer;\n    WIRE_TRY(deserializeBuffer->Read(&transfer));\n    return QuerySetDestroyDeserialize(this, transfer, deserializeBuffer, allocator, resolver);\n}\nWireResult QuerySetDestroyCmd::Deserialize(DeserializeBuffer* deserializeBuffer, DeserializeAllocator* allocator) {\n    ErrorObjectIdResolver resolver;\n    return Deserialize(deserializeBuffer, allocator, resolver);\n}\n\n        \nsize_t QuerySetSetLabelCmd::GetRequiredSize() const {\n    size_t size = sizeof(QuerySetSetLabelTransfer) + QuerySetSetLabelGetExtraRequiredSize(*this);\n    return size;\n}\n\nWireResult QuerySetSetLabelCmd::Serialize(\n    size_t commandSize,\n    SerializeBuffer* buffer,\n    const ObjectIdProvider& provider\n) const {\n    QuerySetSetLabelTransfer* transfer;\n    WIRE_TRY(buffer->Next(&transfer));\n    transfer->commandSize = commandSize;\n    return (QuerySetSetLabelSerialize(*this, transfer, buffer, provider));\n}\nWireResult QuerySetSetLabelCmd::Serialize(size_t commandSize, SerializeBuffer* buffer) const {\n    ErrorObjectIdProvider provider;\n    return Serialize(commandSize, buffer, provider);\n}\n\nWireResult QuerySetSetLabelCmd::Deserialize(\n    DeserializeBuffer* deserializeBuffer,\n    DeserializeAllocator* allocator,\n    const ObjectIdResolver& resolver\n) {\n    const volatile QuerySetSetLabelTransfer* transfer;\n    WIRE_TRY(deserializeBuffer->Read(&transfer));\n    return QuerySetSetLabelDeserialize(this, transfer, deserializeBuffer, allocator, resolver);\n}\nWireResult QuerySetSetLabelCmd::Deserialize(DeserializeBuffer* deserializeBuffer, DeserializeAllocator* allocator) {\n    ErrorObjectIdResolver resolver;\n    return Deserialize(deserializeBuffer, allocator, resolver);\n}\n\n        \nsize_t QueueCopyTextureForBrowserCmd::GetRequiredSize() const {\n    size_t size = sizeof(QueueCopyTextureForBrowserTransfer) + QueueCopyTextureForBrowserGetExtraRequiredSize(*this);\n    return size;\n}\n\nWireResult QueueCopyTextureForBrowserCmd::Serialize(\n    size_t commandSize,\n    SerializeBuffer* buffer,\n    const ObjectIdProvider& provider\n) const {\n    QueueCopyTextureForBrowserTransfer* transfer;\n    WIRE_TRY(buffer->Next(&transfer));\n    transfer->commandSize = commandSize;\n    return (QueueCopyTextureForBrowserSerialize(*this, transfer, buffer, provider));\n}\nWireResult QueueCopyTextureForBrowserCmd::Serialize(size_t commandSize, SerializeBuffer* buffer) const {\n    ErrorObjectIdProvider provider;\n    return Serialize(commandSize, buffer, provider);\n}\n\nWireResult QueueCopyTextureForBrowserCmd::Deserialize(\n    DeserializeBuffer* deserializeBuffer,\n    DeserializeAllocator* allocator,\n    const ObjectIdResolver& resolver\n) {\n    const volatile QueueCopyTextureForBrowserTransfer* transfer;\n    WIRE_TRY(deserializeBuffer->Read(&transfer));\n    return QueueCopyTextureForBrowserDeserialize(this, transfer, deserializeBuffer, allocator, resolver);\n}\nWireResult QueueCopyTextureForBrowserCmd::Deserialize(DeserializeBuffer* deserializeBuffer, DeserializeAllocator* allocator) {\n    ErrorObjectIdResolver resolver;\n    return Deserialize(deserializeBuffer, allocator, resolver);\n}\n\n        \nsize_t QueueOnSubmittedWorkDoneCmd::GetRequiredSize() const {\n    size_t size = sizeof(QueueOnSubmittedWorkDoneTransfer) + QueueOnSubmittedWorkDoneGetExtraRequiredSize(*this);\n    return size;\n}\n\nWireResult QueueOnSubmittedWorkDoneCmd::Serialize(size_t commandSize, SerializeBuffer* buffer) const {\n    QueueOnSubmittedWorkDoneTransfer* transfer;\n    WIRE_TRY(buffer->Next(&transfer));\n    transfer->commandSize = commandSize;\n    return (QueueOnSubmittedWorkDoneSerialize(*this, transfer, buffer));\n}\nWireResult QueueOnSubmittedWorkDoneCmd::Serialize(\n    size_t commandSize,\n    SerializeBuffer* buffer,\n    const ObjectIdProvider&\n) const {\n    return Serialize(commandSize, buffer);\n}\n\nWireResult QueueOnSubmittedWorkDoneCmd::Deserialize(DeserializeBuffer* deserializeBuffer, DeserializeAllocator* allocator) {\n    const volatile QueueOnSubmittedWorkDoneTransfer* transfer;\n    WIRE_TRY(deserializeBuffer->Read(&transfer));\n    return QueueOnSubmittedWorkDoneDeserialize(this, transfer, deserializeBuffer, allocator);\n}\nWireResult QueueOnSubmittedWorkDoneCmd::Deserialize(\n    DeserializeBuffer* deserializeBuffer,\n    DeserializeAllocator* allocator,\n    const ObjectIdResolver&\n) {\n    return Deserialize(deserializeBuffer, allocator);\n}\n\n        \nsize_t QueueSetLabelCmd::GetRequiredSize() const {\n    size_t size = sizeof(QueueSetLabelTransfer) + QueueSetLabelGetExtraRequiredSize(*this);\n    return size;\n}\n\nWireResult QueueSetLabelCmd::Serialize(\n    size_t commandSize,\n    SerializeBuffer* buffer,\n    const ObjectIdProvider& provider\n) const {\n    QueueSetLabelTransfer* transfer;\n    WIRE_TRY(buffer->Next(&transfer));\n    transfer->commandSize = commandSize;\n    return (QueueSetLabelSerialize(*this, transfer, buffer, provider));\n}\nWireResult QueueSetLabelCmd::Serialize(size_t commandSize, SerializeBuffer* buffer) const {\n    ErrorObjectIdProvider provider;\n    return Serialize(commandSize, buffer, provider);\n}\n\nWireResult QueueSetLabelCmd::Deserialize(\n    DeserializeBuffer* deserializeBuffer,\n    DeserializeAllocator* allocator,\n    const ObjectIdResolver& resolver\n) {\n    const volatile QueueSetLabelTransfer* transfer;\n    WIRE_TRY(deserializeBuffer->Read(&transfer));\n    return QueueSetLabelDeserialize(this, transfer, deserializeBuffer, allocator, resolver);\n}\nWireResult QueueSetLabelCmd::Deserialize(DeserializeBuffer* deserializeBuffer, DeserializeAllocator* allocator) {\n    ErrorObjectIdResolver resolver;\n    return Deserialize(deserializeBuffer, allocator, resolver);\n}\n\n        \nsize_t QueueSubmitCmd::GetRequiredSize() const {\n    size_t size = sizeof(QueueSubmitTransfer) + QueueSubmitGetExtraRequiredSize(*this);\n    return size;\n}\n\nWireResult QueueSubmitCmd::Serialize(\n    size_t commandSize,\n    SerializeBuffer* buffer,\n    const ObjectIdProvider& provider\n) const {\n    QueueSubmitTransfer* transfer;\n    WIRE_TRY(buffer->Next(&transfer));\n    transfer->commandSize = commandSize;\n    return (QueueSubmitSerialize(*this, transfer, buffer, provider));\n}\nWireResult QueueSubmitCmd::Serialize(size_t commandSize, SerializeBuffer* buffer) const {\n    ErrorObjectIdProvider provider;\n    return Serialize(commandSize, buffer, provider);\n}\n\nWireResult QueueSubmitCmd::Deserialize(\n    DeserializeBuffer* deserializeBuffer,\n    DeserializeAllocator* allocator,\n    const ObjectIdResolver& resolver\n) {\n    const volatile QueueSubmitTransfer* transfer;\n    WIRE_TRY(deserializeBuffer->Read(&transfer));\n    return QueueSubmitDeserialize(this, transfer, deserializeBuffer, allocator, resolver);\n}\nWireResult QueueSubmitCmd::Deserialize(DeserializeBuffer* deserializeBuffer, DeserializeAllocator* allocator) {\n    ErrorObjectIdResolver resolver;\n    return Deserialize(deserializeBuffer, allocator, resolver);\n}\n\n        \nsize_t QueueWriteBufferCmd::GetRequiredSize() const {\n    size_t size = sizeof(QueueWriteBufferTransfer) + QueueWriteBufferGetExtraRequiredSize(*this);\n    return size;\n}\n\nWireResult QueueWriteBufferCmd::Serialize(size_t commandSize, SerializeBuffer* buffer) const {\n    QueueWriteBufferTransfer* transfer;\n    WIRE_TRY(buffer->Next(&transfer));\n    transfer->commandSize = commandSize;\n    return (QueueWriteBufferSerialize(*this, transfer, buffer));\n}\nWireResult QueueWriteBufferCmd::Serialize(\n    size_t commandSize,\n    SerializeBuffer* buffer,\n    const ObjectIdProvider&\n) const {\n    return Serialize(commandSize, buffer);\n}\n\nWireResult QueueWriteBufferCmd::Deserialize(DeserializeBuffer* deserializeBuffer, DeserializeAllocator* allocator) {\n    const volatile QueueWriteBufferTransfer* transfer;\n    WIRE_TRY(deserializeBuffer->Read(&transfer));\n    return QueueWriteBufferDeserialize(this, transfer, deserializeBuffer, allocator);\n}\nWireResult QueueWriteBufferCmd::Deserialize(\n    DeserializeBuffer* deserializeBuffer,\n    DeserializeAllocator* allocator,\n    const ObjectIdResolver&\n) {\n    return Deserialize(deserializeBuffer, allocator);\n}\n\n        \nsize_t QueueWriteTextureCmd::GetRequiredSize() const {\n    size_t size = sizeof(QueueWriteTextureTransfer) + QueueWriteTextureGetExtraRequiredSize(*this);\n    return size;\n}\n\nWireResult QueueWriteTextureCmd::Serialize(\n    size_t commandSize,\n    SerializeBuffer* buffer,\n    const ObjectIdProvider& provider\n) const {\n    QueueWriteTextureTransfer* transfer;\n    WIRE_TRY(buffer->Next(&transfer));\n    transfer->commandSize = commandSize;\n    return (QueueWriteTextureSerialize(*this, transfer, buffer, provider));\n}\nWireResult QueueWriteTextureCmd::Serialize(size_t commandSize, SerializeBuffer* buffer) const {\n    ErrorObjectIdProvider provider;\n    return Serialize(commandSize, buffer, provider);\n}\n\nWireResult QueueWriteTextureCmd::Deserialize(\n    DeserializeBuffer* deserializeBuffer,\n    DeserializeAllocator* allocator,\n    const ObjectIdResolver& resolver\n) {\n    const volatile QueueWriteTextureTransfer* transfer;\n    WIRE_TRY(deserializeBuffer->Read(&transfer));\n    return QueueWriteTextureDeserialize(this, transfer, deserializeBuffer, allocator, resolver);\n}\nWireResult QueueWriteTextureCmd::Deserialize(DeserializeBuffer* deserializeBuffer, DeserializeAllocator* allocator) {\n    ErrorObjectIdResolver resolver;\n    return Deserialize(deserializeBuffer, allocator, resolver);\n}\n\n        \nsize_t RenderBundleEncoderDrawCmd::GetRequiredSize() const {\n    size_t size = sizeof(RenderBundleEncoderDrawTransfer) + RenderBundleEncoderDrawGetExtraRequiredSize(*this);\n    return size;\n}\n\nWireResult RenderBundleEncoderDrawCmd::Serialize(\n    size_t commandSize,\n    SerializeBuffer* buffer,\n    const ObjectIdProvider& provider\n) const {\n    RenderBundleEncoderDrawTransfer* transfer;\n    WIRE_TRY(buffer->Next(&transfer));\n    transfer->commandSize = commandSize;\n    return (RenderBundleEncoderDrawSerialize(*this, transfer, buffer, provider));\n}\nWireResult RenderBundleEncoderDrawCmd::Serialize(size_t commandSize, SerializeBuffer* buffer) const {\n    ErrorObjectIdProvider provider;\n    return Serialize(commandSize, buffer, provider);\n}\n\nWireResult RenderBundleEncoderDrawCmd::Deserialize(\n    DeserializeBuffer* deserializeBuffer,\n    DeserializeAllocator* allocator,\n    const ObjectIdResolver& resolver\n) {\n    const volatile RenderBundleEncoderDrawTransfer* transfer;\n    WIRE_TRY(deserializeBuffer->Read(&transfer));\n    return RenderBundleEncoderDrawDeserialize(this, transfer, deserializeBuffer, allocator, resolver);\n}\nWireResult RenderBundleEncoderDrawCmd::Deserialize(DeserializeBuffer* deserializeBuffer, DeserializeAllocator* allocator) {\n    ErrorObjectIdResolver resolver;\n    return Deserialize(deserializeBuffer, allocator, resolver);\n}\n\n        \nsize_t RenderBundleEncoderDrawIndexedCmd::GetRequiredSize() const {\n    size_t size = sizeof(RenderBundleEncoderDrawIndexedTransfer) + RenderBundleEncoderDrawIndexedGetExtraRequiredSize(*this);\n    return size;\n}\n\nWireResult RenderBundleEncoderDrawIndexedCmd::Serialize(\n    size_t commandSize,\n    SerializeBuffer* buffer,\n    const ObjectIdProvider& provider\n) const {\n    RenderBundleEncoderDrawIndexedTransfer* transfer;\n    WIRE_TRY(buffer->Next(&transfer));\n    transfer->commandSize = commandSize;\n    return (RenderBundleEncoderDrawIndexedSerialize(*this, transfer, buffer, provider));\n}\nWireResult RenderBundleEncoderDrawIndexedCmd::Serialize(size_t commandSize, SerializeBuffer* buffer) const {\n    ErrorObjectIdProvider provider;\n    return Serialize(commandSize, buffer, provider);\n}\n\nWireResult RenderBundleEncoderDrawIndexedCmd::Deserialize(\n    DeserializeBuffer* deserializeBuffer,\n    DeserializeAllocator* allocator,\n    const ObjectIdResolver& resolver\n) {\n    const volatile RenderBundleEncoderDrawIndexedTransfer* transfer;\n    WIRE_TRY(deserializeBuffer->Read(&transfer));\n    return RenderBundleEncoderDrawIndexedDeserialize(this, transfer, deserializeBuffer, allocator, resolver);\n}\nWireResult RenderBundleEncoderDrawIndexedCmd::Deserialize(DeserializeBuffer* deserializeBuffer, DeserializeAllocator* allocator) {\n    ErrorObjectIdResolver resolver;\n    return Deserialize(deserializeBuffer, allocator, resolver);\n}\n\n        \nsize_t RenderBundleEncoderDrawIndexedIndirectCmd::GetRequiredSize() const {\n    size_t size = sizeof(RenderBundleEncoderDrawIndexedIndirectTransfer) + RenderBundleEncoderDrawIndexedIndirectGetExtraRequiredSize(*this);\n    return size;\n}\n\nWireResult RenderBundleEncoderDrawIndexedIndirectCmd::Serialize(\n    size_t commandSize,\n    SerializeBuffer* buffer,\n    const ObjectIdProvider& provider\n) const {\n    RenderBundleEncoderDrawIndexedIndirectTransfer* transfer;\n    WIRE_TRY(buffer->Next(&transfer));\n    transfer->commandSize = commandSize;\n    return (RenderBundleEncoderDrawIndexedIndirectSerialize(*this, transfer, buffer, provider));\n}\nWireResult RenderBundleEncoderDrawIndexedIndirectCmd::Serialize(size_t commandSize, SerializeBuffer* buffer) const {\n    ErrorObjectIdProvider provider;\n    return Serialize(commandSize, buffer, provider);\n}\n\nWireResult RenderBundleEncoderDrawIndexedIndirectCmd::Deserialize(\n    DeserializeBuffer* deserializeBuffer,\n    DeserializeAllocator* allocator,\n    const ObjectIdResolver& resolver\n) {\n    const volatile RenderBundleEncoderDrawIndexedIndirectTransfer* transfer;\n    WIRE_TRY(deserializeBuffer->Read(&transfer));\n    return RenderBundleEncoderDrawIndexedIndirectDeserialize(this, transfer, deserializeBuffer, allocator, resolver);\n}\nWireResult RenderBundleEncoderDrawIndexedIndirectCmd::Deserialize(DeserializeBuffer* deserializeBuffer, DeserializeAllocator* allocator) {\n    ErrorObjectIdResolver resolver;\n    return Deserialize(deserializeBuffer, allocator, resolver);\n}\n\n        \nsize_t RenderBundleEncoderDrawIndirectCmd::GetRequiredSize() const {\n    size_t size = sizeof(RenderBundleEncoderDrawIndirectTransfer) + RenderBundleEncoderDrawIndirectGetExtraRequiredSize(*this);\n    return size;\n}\n\nWireResult RenderBundleEncoderDrawIndirectCmd::Serialize(\n    size_t commandSize,\n    SerializeBuffer* buffer,\n    const ObjectIdProvider& provider\n) const {\n    RenderBundleEncoderDrawIndirectTransfer* transfer;\n    WIRE_TRY(buffer->Next(&transfer));\n    transfer->commandSize = commandSize;\n    return (RenderBundleEncoderDrawIndirectSerialize(*this, transfer, buffer, provider));\n}\nWireResult RenderBundleEncoderDrawIndirectCmd::Serialize(size_t commandSize, SerializeBuffer* buffer) const {\n    ErrorObjectIdProvider provider;\n    return Serialize(commandSize, buffer, provider);\n}\n\nWireResult RenderBundleEncoderDrawIndirectCmd::Deserialize(\n    DeserializeBuffer* deserializeBuffer,\n    DeserializeAllocator* allocator,\n    const ObjectIdResolver& resolver\n) {\n    const volatile RenderBundleEncoderDrawIndirectTransfer* transfer;\n    WIRE_TRY(deserializeBuffer->Read(&transfer));\n    return RenderBundleEncoderDrawIndirectDeserialize(this, transfer, deserializeBuffer, allocator, resolver);\n}\nWireResult RenderBundleEncoderDrawIndirectCmd::Deserialize(DeserializeBuffer* deserializeBuffer, DeserializeAllocator* allocator) {\n    ErrorObjectIdResolver resolver;\n    return Deserialize(deserializeBuffer, allocator, resolver);\n}\n\n        \nsize_t RenderBundleEncoderFinishCmd::GetRequiredSize() const {\n    size_t size = sizeof(RenderBundleEncoderFinishTransfer) + RenderBundleEncoderFinishGetExtraRequiredSize(*this);\n    return size;\n}\n\nWireResult RenderBundleEncoderFinishCmd::Serialize(\n    size_t commandSize,\n    SerializeBuffer* buffer,\n    const ObjectIdProvider& provider\n) const {\n    RenderBundleEncoderFinishTransfer* transfer;\n    WIRE_TRY(buffer->Next(&transfer));\n    transfer->commandSize = commandSize;\n    return (RenderBundleEncoderFinishSerialize(*this, transfer, buffer, provider));\n}\nWireResult RenderBundleEncoderFinishCmd::Serialize(size_t commandSize, SerializeBuffer* buffer) const {\n    ErrorObjectIdProvider provider;\n    return Serialize(commandSize, buffer, provider);\n}\n\nWireResult RenderBundleEncoderFinishCmd::Deserialize(\n    DeserializeBuffer* deserializeBuffer,\n    DeserializeAllocator* allocator,\n    const ObjectIdResolver& resolver\n) {\n    const volatile RenderBundleEncoderFinishTransfer* transfer;\n    WIRE_TRY(deserializeBuffer->Read(&transfer));\n    return RenderBundleEncoderFinishDeserialize(this, transfer, deserializeBuffer, allocator, resolver);\n}\nWireResult RenderBundleEncoderFinishCmd::Deserialize(DeserializeBuffer* deserializeBuffer, DeserializeAllocator* allocator) {\n    ErrorObjectIdResolver resolver;\n    return Deserialize(deserializeBuffer, allocator, resolver);\n}\n\n        \nsize_t RenderBundleEncoderInsertDebugMarkerCmd::GetRequiredSize() const {\n    size_t size = sizeof(RenderBundleEncoderInsertDebugMarkerTransfer) + RenderBundleEncoderInsertDebugMarkerGetExtraRequiredSize(*this);\n    return size;\n}\n\nWireResult RenderBundleEncoderInsertDebugMarkerCmd::Serialize(\n    size_t commandSize,\n    SerializeBuffer* buffer,\n    const ObjectIdProvider& provider\n) const {\n    RenderBundleEncoderInsertDebugMarkerTransfer* transfer;\n    WIRE_TRY(buffer->Next(&transfer));\n    transfer->commandSize = commandSize;\n    return (RenderBundleEncoderInsertDebugMarkerSerialize(*this, transfer, buffer, provider));\n}\nWireResult RenderBundleEncoderInsertDebugMarkerCmd::Serialize(size_t commandSize, SerializeBuffer* buffer) const {\n    ErrorObjectIdProvider provider;\n    return Serialize(commandSize, buffer, provider);\n}\n\nWireResult RenderBundleEncoderInsertDebugMarkerCmd::Deserialize(\n    DeserializeBuffer* deserializeBuffer,\n    DeserializeAllocator* allocator,\n    const ObjectIdResolver& resolver\n) {\n    const volatile RenderBundleEncoderInsertDebugMarkerTransfer* transfer;\n    WIRE_TRY(deserializeBuffer->Read(&transfer));\n    return RenderBundleEncoderInsertDebugMarkerDeserialize(this, transfer, deserializeBuffer, allocator, resolver);\n}\nWireResult RenderBundleEncoderInsertDebugMarkerCmd::Deserialize(DeserializeBuffer* deserializeBuffer, DeserializeAllocator* allocator) {\n    ErrorObjectIdResolver resolver;\n    return Deserialize(deserializeBuffer, allocator, resolver);\n}\n\n        \nsize_t RenderBundleEncoderPopDebugGroupCmd::GetRequiredSize() const {\n    size_t size = sizeof(RenderBundleEncoderPopDebugGroupTransfer) + RenderBundleEncoderPopDebugGroupGetExtraRequiredSize(*this);\n    return size;\n}\n\nWireResult RenderBundleEncoderPopDebugGroupCmd::Serialize(\n    size_t commandSize,\n    SerializeBuffer* buffer,\n    const ObjectIdProvider& provider\n) const {\n    RenderBundleEncoderPopDebugGroupTransfer* transfer;\n    WIRE_TRY(buffer->Next(&transfer));\n    transfer->commandSize = commandSize;\n    return (RenderBundleEncoderPopDebugGroupSerialize(*this, transfer, buffer, provider));\n}\nWireResult RenderBundleEncoderPopDebugGroupCmd::Serialize(size_t commandSize, SerializeBuffer* buffer) const {\n    ErrorObjectIdProvider provider;\n    return Serialize(commandSize, buffer, provider);\n}\n\nWireResult RenderBundleEncoderPopDebugGroupCmd::Deserialize(\n    DeserializeBuffer* deserializeBuffer,\n    DeserializeAllocator* allocator,\n    const ObjectIdResolver& resolver\n) {\n    const volatile RenderBundleEncoderPopDebugGroupTransfer* transfer;\n    WIRE_TRY(deserializeBuffer->Read(&transfer));\n    return RenderBundleEncoderPopDebugGroupDeserialize(this, transfer, deserializeBuffer, allocator, resolver);\n}\nWireResult RenderBundleEncoderPopDebugGroupCmd::Deserialize(DeserializeBuffer* deserializeBuffer, DeserializeAllocator* allocator) {\n    ErrorObjectIdResolver resolver;\n    return Deserialize(deserializeBuffer, allocator, resolver);\n}\n\n        \nsize_t RenderBundleEncoderPushDebugGroupCmd::GetRequiredSize() const {\n    size_t size = sizeof(RenderBundleEncoderPushDebugGroupTransfer) + RenderBundleEncoderPushDebugGroupGetExtraRequiredSize(*this);\n    return size;\n}\n\nWireResult RenderBundleEncoderPushDebugGroupCmd::Serialize(\n    size_t commandSize,\n    SerializeBuffer* buffer,\n    const ObjectIdProvider& provider\n) const {\n    RenderBundleEncoderPushDebugGroupTransfer* transfer;\n    WIRE_TRY(buffer->Next(&transfer));\n    transfer->commandSize = commandSize;\n    return (RenderBundleEncoderPushDebugGroupSerialize(*this, transfer, buffer, provider));\n}\nWireResult RenderBundleEncoderPushDebugGroupCmd::Serialize(size_t commandSize, SerializeBuffer* buffer) const {\n    ErrorObjectIdProvider provider;\n    return Serialize(commandSize, buffer, provider);\n}\n\nWireResult RenderBundleEncoderPushDebugGroupCmd::Deserialize(\n    DeserializeBuffer* deserializeBuffer,\n    DeserializeAllocator* allocator,\n    const ObjectIdResolver& resolver\n) {\n    const volatile RenderBundleEncoderPushDebugGroupTransfer* transfer;\n    WIRE_TRY(deserializeBuffer->Read(&transfer));\n    return RenderBundleEncoderPushDebugGroupDeserialize(this, transfer, deserializeBuffer, allocator, resolver);\n}\nWireResult RenderBundleEncoderPushDebugGroupCmd::Deserialize(DeserializeBuffer* deserializeBuffer, DeserializeAllocator* allocator) {\n    ErrorObjectIdResolver resolver;\n    return Deserialize(deserializeBuffer, allocator, resolver);\n}\n\n        \nsize_t RenderBundleEncoderSetBindGroupCmd::GetRequiredSize() const {\n    size_t size = sizeof(RenderBundleEncoderSetBindGroupTransfer) + RenderBundleEncoderSetBindGroupGetExtraRequiredSize(*this);\n    return size;\n}\n\nWireResult RenderBundleEncoderSetBindGroupCmd::Serialize(\n    size_t commandSize,\n    SerializeBuffer* buffer,\n    const ObjectIdProvider& provider\n) const {\n    RenderBundleEncoderSetBindGroupTransfer* transfer;\n    WIRE_TRY(buffer->Next(&transfer));\n    transfer->commandSize = commandSize;\n    return (RenderBundleEncoderSetBindGroupSerialize(*this, transfer, buffer, provider));\n}\nWireResult RenderBundleEncoderSetBindGroupCmd::Serialize(size_t commandSize, SerializeBuffer* buffer) const {\n    ErrorObjectIdProvider provider;\n    return Serialize(commandSize, buffer, provider);\n}\n\nWireResult RenderBundleEncoderSetBindGroupCmd::Deserialize(\n    DeserializeBuffer* deserializeBuffer,\n    DeserializeAllocator* allocator,\n    const ObjectIdResolver& resolver\n) {\n    const volatile RenderBundleEncoderSetBindGroupTransfer* transfer;\n    WIRE_TRY(deserializeBuffer->Read(&transfer));\n    return RenderBundleEncoderSetBindGroupDeserialize(this, transfer, deserializeBuffer, allocator, resolver);\n}\nWireResult RenderBundleEncoderSetBindGroupCmd::Deserialize(DeserializeBuffer* deserializeBuffer, DeserializeAllocator* allocator) {\n    ErrorObjectIdResolver resolver;\n    return Deserialize(deserializeBuffer, allocator, resolver);\n}\n\n        \nsize_t RenderBundleEncoderSetIndexBufferCmd::GetRequiredSize() const {\n    size_t size = sizeof(RenderBundleEncoderSetIndexBufferTransfer) + RenderBundleEncoderSetIndexBufferGetExtraRequiredSize(*this);\n    return size;\n}\n\nWireResult RenderBundleEncoderSetIndexBufferCmd::Serialize(\n    size_t commandSize,\n    SerializeBuffer* buffer,\n    const ObjectIdProvider& provider\n) const {\n    RenderBundleEncoderSetIndexBufferTransfer* transfer;\n    WIRE_TRY(buffer->Next(&transfer));\n    transfer->commandSize = commandSize;\n    return (RenderBundleEncoderSetIndexBufferSerialize(*this, transfer, buffer, provider));\n}\nWireResult RenderBundleEncoderSetIndexBufferCmd::Serialize(size_t commandSize, SerializeBuffer* buffer) const {\n    ErrorObjectIdProvider provider;\n    return Serialize(commandSize, buffer, provider);\n}\n\nWireResult RenderBundleEncoderSetIndexBufferCmd::Deserialize(\n    DeserializeBuffer* deserializeBuffer,\n    DeserializeAllocator* allocator,\n    const ObjectIdResolver& resolver\n) {\n    const volatile RenderBundleEncoderSetIndexBufferTransfer* transfer;\n    WIRE_TRY(deserializeBuffer->Read(&transfer));\n    return RenderBundleEncoderSetIndexBufferDeserialize(this, transfer, deserializeBuffer, allocator, resolver);\n}\nWireResult RenderBundleEncoderSetIndexBufferCmd::Deserialize(DeserializeBuffer* deserializeBuffer, DeserializeAllocator* allocator) {\n    ErrorObjectIdResolver resolver;\n    return Deserialize(deserializeBuffer, allocator, resolver);\n}\n\n        \nsize_t RenderBundleEncoderSetLabelCmd::GetRequiredSize() const {\n    size_t size = sizeof(RenderBundleEncoderSetLabelTransfer) + RenderBundleEncoderSetLabelGetExtraRequiredSize(*this);\n    return size;\n}\n\nWireResult RenderBundleEncoderSetLabelCmd::Serialize(\n    size_t commandSize,\n    SerializeBuffer* buffer,\n    const ObjectIdProvider& provider\n) const {\n    RenderBundleEncoderSetLabelTransfer* transfer;\n    WIRE_TRY(buffer->Next(&transfer));\n    transfer->commandSize = commandSize;\n    return (RenderBundleEncoderSetLabelSerialize(*this, transfer, buffer, provider));\n}\nWireResult RenderBundleEncoderSetLabelCmd::Serialize(size_t commandSize, SerializeBuffer* buffer) const {\n    ErrorObjectIdProvider provider;\n    return Serialize(commandSize, buffer, provider);\n}\n\nWireResult RenderBundleEncoderSetLabelCmd::Deserialize(\n    DeserializeBuffer* deserializeBuffer,\n    DeserializeAllocator* allocator,\n    const ObjectIdResolver& resolver\n) {\n    const volatile RenderBundleEncoderSetLabelTransfer* transfer;\n    WIRE_TRY(deserializeBuffer->Read(&transfer));\n    return RenderBundleEncoderSetLabelDeserialize(this, transfer, deserializeBuffer, allocator, resolver);\n}\nWireResult RenderBundleEncoderSetLabelCmd::Deserialize(DeserializeBuffer* deserializeBuffer, DeserializeAllocator* allocator) {\n    ErrorObjectIdResolver resolver;\n    return Deserialize(deserializeBuffer, allocator, resolver);\n}\n\n        \nsize_t RenderBundleEncoderSetPipelineCmd::GetRequiredSize() const {\n    size_t size = sizeof(RenderBundleEncoderSetPipelineTransfer) + RenderBundleEncoderSetPipelineGetExtraRequiredSize(*this);\n    return size;\n}\n\nWireResult RenderBundleEncoderSetPipelineCmd::Serialize(\n    size_t commandSize,\n    SerializeBuffer* buffer,\n    const ObjectIdProvider& provider\n) const {\n    RenderBundleEncoderSetPipelineTransfer* transfer;\n    WIRE_TRY(buffer->Next(&transfer));\n    transfer->commandSize = commandSize;\n    return (RenderBundleEncoderSetPipelineSerialize(*this, transfer, buffer, provider));\n}\nWireResult RenderBundleEncoderSetPipelineCmd::Serialize(size_t commandSize, SerializeBuffer* buffer) const {\n    ErrorObjectIdProvider provider;\n    return Serialize(commandSize, buffer, provider);\n}\n\nWireResult RenderBundleEncoderSetPipelineCmd::Deserialize(\n    DeserializeBuffer* deserializeBuffer,\n    DeserializeAllocator* allocator,\n    const ObjectIdResolver& resolver\n) {\n    const volatile RenderBundleEncoderSetPipelineTransfer* transfer;\n    WIRE_TRY(deserializeBuffer->Read(&transfer));\n    return RenderBundleEncoderSetPipelineDeserialize(this, transfer, deserializeBuffer, allocator, resolver);\n}\nWireResult RenderBundleEncoderSetPipelineCmd::Deserialize(DeserializeBuffer* deserializeBuffer, DeserializeAllocator* allocator) {\n    ErrorObjectIdResolver resolver;\n    return Deserialize(deserializeBuffer, allocator, resolver);\n}\n\n        \nsize_t RenderBundleEncoderSetVertexBufferCmd::GetRequiredSize() const {\n    size_t size = sizeof(RenderBundleEncoderSetVertexBufferTransfer) + RenderBundleEncoderSetVertexBufferGetExtraRequiredSize(*this);\n    return size;\n}\n\nWireResult RenderBundleEncoderSetVertexBufferCmd::Serialize(\n    size_t commandSize,\n    SerializeBuffer* buffer,\n    const ObjectIdProvider& provider\n) const {\n    RenderBundleEncoderSetVertexBufferTransfer* transfer;\n    WIRE_TRY(buffer->Next(&transfer));\n    transfer->commandSize = commandSize;\n    return (RenderBundleEncoderSetVertexBufferSerialize(*this, transfer, buffer, provider));\n}\nWireResult RenderBundleEncoderSetVertexBufferCmd::Serialize(size_t commandSize, SerializeBuffer* buffer) const {\n    ErrorObjectIdProvider provider;\n    return Serialize(commandSize, buffer, provider);\n}\n\nWireResult RenderBundleEncoderSetVertexBufferCmd::Deserialize(\n    DeserializeBuffer* deserializeBuffer,\n    DeserializeAllocator* allocator,\n    const ObjectIdResolver& resolver\n) {\n    const volatile RenderBundleEncoderSetVertexBufferTransfer* transfer;\n    WIRE_TRY(deserializeBuffer->Read(&transfer));\n    return RenderBundleEncoderSetVertexBufferDeserialize(this, transfer, deserializeBuffer, allocator, resolver);\n}\nWireResult RenderBundleEncoderSetVertexBufferCmd::Deserialize(DeserializeBuffer* deserializeBuffer, DeserializeAllocator* allocator) {\n    ErrorObjectIdResolver resolver;\n    return Deserialize(deserializeBuffer, allocator, resolver);\n}\n\n        \nsize_t RenderPassEncoderBeginOcclusionQueryCmd::GetRequiredSize() const {\n    size_t size = sizeof(RenderPassEncoderBeginOcclusionQueryTransfer) + RenderPassEncoderBeginOcclusionQueryGetExtraRequiredSize(*this);\n    return size;\n}\n\nWireResult RenderPassEncoderBeginOcclusionQueryCmd::Serialize(\n    size_t commandSize,\n    SerializeBuffer* buffer,\n    const ObjectIdProvider& provider\n) const {\n    RenderPassEncoderBeginOcclusionQueryTransfer* transfer;\n    WIRE_TRY(buffer->Next(&transfer));\n    transfer->commandSize = commandSize;\n    return (RenderPassEncoderBeginOcclusionQuerySerialize(*this, transfer, buffer, provider));\n}\nWireResult RenderPassEncoderBeginOcclusionQueryCmd::Serialize(size_t commandSize, SerializeBuffer* buffer) const {\n    ErrorObjectIdProvider provider;\n    return Serialize(commandSize, buffer, provider);\n}\n\nWireResult RenderPassEncoderBeginOcclusionQueryCmd::Deserialize(\n    DeserializeBuffer* deserializeBuffer,\n    DeserializeAllocator* allocator,\n    const ObjectIdResolver& resolver\n) {\n    const volatile RenderPassEncoderBeginOcclusionQueryTransfer* transfer;\n    WIRE_TRY(deserializeBuffer->Read(&transfer));\n    return RenderPassEncoderBeginOcclusionQueryDeserialize(this, transfer, deserializeBuffer, allocator, resolver);\n}\nWireResult RenderPassEncoderBeginOcclusionQueryCmd::Deserialize(DeserializeBuffer* deserializeBuffer, DeserializeAllocator* allocator) {\n    ErrorObjectIdResolver resolver;\n    return Deserialize(deserializeBuffer, allocator, resolver);\n}\n\n        \nsize_t RenderPassEncoderDrawCmd::GetRequiredSize() const {\n    size_t size = sizeof(RenderPassEncoderDrawTransfer) + RenderPassEncoderDrawGetExtraRequiredSize(*this);\n    return size;\n}\n\nWireResult RenderPassEncoderDrawCmd::Serialize(\n    size_t commandSize,\n    SerializeBuffer* buffer,\n    const ObjectIdProvider& provider\n) const {\n    RenderPassEncoderDrawTransfer* transfer;\n    WIRE_TRY(buffer->Next(&transfer));\n    transfer->commandSize = commandSize;\n    return (RenderPassEncoderDrawSerialize(*this, transfer, buffer, provider));\n}\nWireResult RenderPassEncoderDrawCmd::Serialize(size_t commandSize, SerializeBuffer* buffer) const {\n    ErrorObjectIdProvider provider;\n    return Serialize(commandSize, buffer, provider);\n}\n\nWireResult RenderPassEncoderDrawCmd::Deserialize(\n    DeserializeBuffer* deserializeBuffer,\n    DeserializeAllocator* allocator,\n    const ObjectIdResolver& resolver\n) {\n    const volatile RenderPassEncoderDrawTransfer* transfer;\n    WIRE_TRY(deserializeBuffer->Read(&transfer));\n    return RenderPassEncoderDrawDeserialize(this, transfer, deserializeBuffer, allocator, resolver);\n}\nWireResult RenderPassEncoderDrawCmd::Deserialize(DeserializeBuffer* deserializeBuffer, DeserializeAllocator* allocator) {\n    ErrorObjectIdResolver resolver;\n    return Deserialize(deserializeBuffer, allocator, resolver);\n}\n\n        \nsize_t RenderPassEncoderDrawIndexedCmd::GetRequiredSize() const {\n    size_t size = sizeof(RenderPassEncoderDrawIndexedTransfer) + RenderPassEncoderDrawIndexedGetExtraRequiredSize(*this);\n    return size;\n}\n\nWireResult RenderPassEncoderDrawIndexedCmd::Serialize(\n    size_t commandSize,\n    SerializeBuffer* buffer,\n    const ObjectIdProvider& provider\n) const {\n    RenderPassEncoderDrawIndexedTransfer* transfer;\n    WIRE_TRY(buffer->Next(&transfer));\n    transfer->commandSize = commandSize;\n    return (RenderPassEncoderDrawIndexedSerialize(*this, transfer, buffer, provider));\n}\nWireResult RenderPassEncoderDrawIndexedCmd::Serialize(size_t commandSize, SerializeBuffer* buffer) const {\n    ErrorObjectIdProvider provider;\n    return Serialize(commandSize, buffer, provider);\n}\n\nWireResult RenderPassEncoderDrawIndexedCmd::Deserialize(\n    DeserializeBuffer* deserializeBuffer,\n    DeserializeAllocator* allocator,\n    const ObjectIdResolver& resolver\n) {\n    const volatile RenderPassEncoderDrawIndexedTransfer* transfer;\n    WIRE_TRY(deserializeBuffer->Read(&transfer));\n    return RenderPassEncoderDrawIndexedDeserialize(this, transfer, deserializeBuffer, allocator, resolver);\n}\nWireResult RenderPassEncoderDrawIndexedCmd::Deserialize(DeserializeBuffer* deserializeBuffer, DeserializeAllocator* allocator) {\n    ErrorObjectIdResolver resolver;\n    return Deserialize(deserializeBuffer, allocator, resolver);\n}\n\n        \nsize_t RenderPassEncoderDrawIndexedIndirectCmd::GetRequiredSize() const {\n    size_t size = sizeof(RenderPassEncoderDrawIndexedIndirectTransfer) + RenderPassEncoderDrawIndexedIndirectGetExtraRequiredSize(*this);\n    return size;\n}\n\nWireResult RenderPassEncoderDrawIndexedIndirectCmd::Serialize(\n    size_t commandSize,\n    SerializeBuffer* buffer,\n    const ObjectIdProvider& provider\n) const {\n    RenderPassEncoderDrawIndexedIndirectTransfer* transfer;\n    WIRE_TRY(buffer->Next(&transfer));\n    transfer->commandSize = commandSize;\n    return (RenderPassEncoderDrawIndexedIndirectSerialize(*this, transfer, buffer, provider));\n}\nWireResult RenderPassEncoderDrawIndexedIndirectCmd::Serialize(size_t commandSize, SerializeBuffer* buffer) const {\n    ErrorObjectIdProvider provider;\n    return Serialize(commandSize, buffer, provider);\n}\n\nWireResult RenderPassEncoderDrawIndexedIndirectCmd::Deserialize(\n    DeserializeBuffer* deserializeBuffer,\n    DeserializeAllocator* allocator,\n    const ObjectIdResolver& resolver\n) {\n    const volatile RenderPassEncoderDrawIndexedIndirectTransfer* transfer;\n    WIRE_TRY(deserializeBuffer->Read(&transfer));\n    return RenderPassEncoderDrawIndexedIndirectDeserialize(this, transfer, deserializeBuffer, allocator, resolver);\n}\nWireResult RenderPassEncoderDrawIndexedIndirectCmd::Deserialize(DeserializeBuffer* deserializeBuffer, DeserializeAllocator* allocator) {\n    ErrorObjectIdResolver resolver;\n    return Deserialize(deserializeBuffer, allocator, resolver);\n}\n\n        \nsize_t RenderPassEncoderDrawIndirectCmd::GetRequiredSize() const {\n    size_t size = sizeof(RenderPassEncoderDrawIndirectTransfer) + RenderPassEncoderDrawIndirectGetExtraRequiredSize(*this);\n    return size;\n}\n\nWireResult RenderPassEncoderDrawIndirectCmd::Serialize(\n    size_t commandSize,\n    SerializeBuffer* buffer,\n    const ObjectIdProvider& provider\n) const {\n    RenderPassEncoderDrawIndirectTransfer* transfer;\n    WIRE_TRY(buffer->Next(&transfer));\n    transfer->commandSize = commandSize;\n    return (RenderPassEncoderDrawIndirectSerialize(*this, transfer, buffer, provider));\n}\nWireResult RenderPassEncoderDrawIndirectCmd::Serialize(size_t commandSize, SerializeBuffer* buffer) const {\n    ErrorObjectIdProvider provider;\n    return Serialize(commandSize, buffer, provider);\n}\n\nWireResult RenderPassEncoderDrawIndirectCmd::Deserialize(\n    DeserializeBuffer* deserializeBuffer,\n    DeserializeAllocator* allocator,\n    const ObjectIdResolver& resolver\n) {\n    const volatile RenderPassEncoderDrawIndirectTransfer* transfer;\n    WIRE_TRY(deserializeBuffer->Read(&transfer));\n    return RenderPassEncoderDrawIndirectDeserialize(this, transfer, deserializeBuffer, allocator, resolver);\n}\nWireResult RenderPassEncoderDrawIndirectCmd::Deserialize(DeserializeBuffer* deserializeBuffer, DeserializeAllocator* allocator) {\n    ErrorObjectIdResolver resolver;\n    return Deserialize(deserializeBuffer, allocator, resolver);\n}\n\n        \nsize_t RenderPassEncoderEndCmd::GetRequiredSize() const {\n    size_t size = sizeof(RenderPassEncoderEndTransfer) + RenderPassEncoderEndGetExtraRequiredSize(*this);\n    return size;\n}\n\nWireResult RenderPassEncoderEndCmd::Serialize(\n    size_t commandSize,\n    SerializeBuffer* buffer,\n    const ObjectIdProvider& provider\n) const {\n    RenderPassEncoderEndTransfer* transfer;\n    WIRE_TRY(buffer->Next(&transfer));\n    transfer->commandSize = commandSize;\n    return (RenderPassEncoderEndSerialize(*this, transfer, buffer, provider));\n}\nWireResult RenderPassEncoderEndCmd::Serialize(size_t commandSize, SerializeBuffer* buffer) const {\n    ErrorObjectIdProvider provider;\n    return Serialize(commandSize, buffer, provider);\n}\n\nWireResult RenderPassEncoderEndCmd::Deserialize(\n    DeserializeBuffer* deserializeBuffer,\n    DeserializeAllocator* allocator,\n    const ObjectIdResolver& resolver\n) {\n    const volatile RenderPassEncoderEndTransfer* transfer;\n    WIRE_TRY(deserializeBuffer->Read(&transfer));\n    return RenderPassEncoderEndDeserialize(this, transfer, deserializeBuffer, allocator, resolver);\n}\nWireResult RenderPassEncoderEndCmd::Deserialize(DeserializeBuffer* deserializeBuffer, DeserializeAllocator* allocator) {\n    ErrorObjectIdResolver resolver;\n    return Deserialize(deserializeBuffer, allocator, resolver);\n}\n\n        \nsize_t RenderPassEncoderEndOcclusionQueryCmd::GetRequiredSize() const {\n    size_t size = sizeof(RenderPassEncoderEndOcclusionQueryTransfer) + RenderPassEncoderEndOcclusionQueryGetExtraRequiredSize(*this);\n    return size;\n}\n\nWireResult RenderPassEncoderEndOcclusionQueryCmd::Serialize(\n    size_t commandSize,\n    SerializeBuffer* buffer,\n    const ObjectIdProvider& provider\n) const {\n    RenderPassEncoderEndOcclusionQueryTransfer* transfer;\n    WIRE_TRY(buffer->Next(&transfer));\n    transfer->commandSize = commandSize;\n    return (RenderPassEncoderEndOcclusionQuerySerialize(*this, transfer, buffer, provider));\n}\nWireResult RenderPassEncoderEndOcclusionQueryCmd::Serialize(size_t commandSize, SerializeBuffer* buffer) const {\n    ErrorObjectIdProvider provider;\n    return Serialize(commandSize, buffer, provider);\n}\n\nWireResult RenderPassEncoderEndOcclusionQueryCmd::Deserialize(\n    DeserializeBuffer* deserializeBuffer,\n    DeserializeAllocator* allocator,\n    const ObjectIdResolver& resolver\n) {\n    const volatile RenderPassEncoderEndOcclusionQueryTransfer* transfer;\n    WIRE_TRY(deserializeBuffer->Read(&transfer));\n    return RenderPassEncoderEndOcclusionQueryDeserialize(this, transfer, deserializeBuffer, allocator, resolver);\n}\nWireResult RenderPassEncoderEndOcclusionQueryCmd::Deserialize(DeserializeBuffer* deserializeBuffer, DeserializeAllocator* allocator) {\n    ErrorObjectIdResolver resolver;\n    return Deserialize(deserializeBuffer, allocator, resolver);\n}\n\n        \nsize_t RenderPassEncoderEndPassCmd::GetRequiredSize() const {\n    size_t size = sizeof(RenderPassEncoderEndPassTransfer) + RenderPassEncoderEndPassGetExtraRequiredSize(*this);\n    return size;\n}\n\nWireResult RenderPassEncoderEndPassCmd::Serialize(\n    size_t commandSize,\n    SerializeBuffer* buffer,\n    const ObjectIdProvider& provider\n) const {\n    RenderPassEncoderEndPassTransfer* transfer;\n    WIRE_TRY(buffer->Next(&transfer));\n    transfer->commandSize = commandSize;\n    return (RenderPassEncoderEndPassSerialize(*this, transfer, buffer, provider));\n}\nWireResult RenderPassEncoderEndPassCmd::Serialize(size_t commandSize, SerializeBuffer* buffer) const {\n    ErrorObjectIdProvider provider;\n    return Serialize(commandSize, buffer, provider);\n}\n\nWireResult RenderPassEncoderEndPassCmd::Deserialize(\n    DeserializeBuffer* deserializeBuffer,\n    DeserializeAllocator* allocator,\n    const ObjectIdResolver& resolver\n) {\n    const volatile RenderPassEncoderEndPassTransfer* transfer;\n    WIRE_TRY(deserializeBuffer->Read(&transfer));\n    return RenderPassEncoderEndPassDeserialize(this, transfer, deserializeBuffer, allocator, resolver);\n}\nWireResult RenderPassEncoderEndPassCmd::Deserialize(DeserializeBuffer* deserializeBuffer, DeserializeAllocator* allocator) {\n    ErrorObjectIdResolver resolver;\n    return Deserialize(deserializeBuffer, allocator, resolver);\n}\n\n        \nsize_t RenderPassEncoderExecuteBundlesCmd::GetRequiredSize() const {\n    size_t size = sizeof(RenderPassEncoderExecuteBundlesTransfer) + RenderPassEncoderExecuteBundlesGetExtraRequiredSize(*this);\n    return size;\n}\n\nWireResult RenderPassEncoderExecuteBundlesCmd::Serialize(\n    size_t commandSize,\n    SerializeBuffer* buffer,\n    const ObjectIdProvider& provider\n) const {\n    RenderPassEncoderExecuteBundlesTransfer* transfer;\n    WIRE_TRY(buffer->Next(&transfer));\n    transfer->commandSize = commandSize;\n    return (RenderPassEncoderExecuteBundlesSerialize(*this, transfer, buffer, provider));\n}\nWireResult RenderPassEncoderExecuteBundlesCmd::Serialize(size_t commandSize, SerializeBuffer* buffer) const {\n    ErrorObjectIdProvider provider;\n    return Serialize(commandSize, buffer, provider);\n}\n\nWireResult RenderPassEncoderExecuteBundlesCmd::Deserialize(\n    DeserializeBuffer* deserializeBuffer,\n    DeserializeAllocator* allocator,\n    const ObjectIdResolver& resolver\n) {\n    const volatile RenderPassEncoderExecuteBundlesTransfer* transfer;\n    WIRE_TRY(deserializeBuffer->Read(&transfer));\n    return RenderPassEncoderExecuteBundlesDeserialize(this, transfer, deserializeBuffer, allocator, resolver);\n}\nWireResult RenderPassEncoderExecuteBundlesCmd::Deserialize(DeserializeBuffer* deserializeBuffer, DeserializeAllocator* allocator) {\n    ErrorObjectIdResolver resolver;\n    return Deserialize(deserializeBuffer, allocator, resolver);\n}\n\n        \nsize_t RenderPassEncoderInsertDebugMarkerCmd::GetRequiredSize() const {\n    size_t size = sizeof(RenderPassEncoderInsertDebugMarkerTransfer) + RenderPassEncoderInsertDebugMarkerGetExtraRequiredSize(*this);\n    return size;\n}\n\nWireResult RenderPassEncoderInsertDebugMarkerCmd::Serialize(\n    size_t commandSize,\n    SerializeBuffer* buffer,\n    const ObjectIdProvider& provider\n) const {\n    RenderPassEncoderInsertDebugMarkerTransfer* transfer;\n    WIRE_TRY(buffer->Next(&transfer));\n    transfer->commandSize = commandSize;\n    return (RenderPassEncoderInsertDebugMarkerSerialize(*this, transfer, buffer, provider));\n}\nWireResult RenderPassEncoderInsertDebugMarkerCmd::Serialize(size_t commandSize, SerializeBuffer* buffer) const {\n    ErrorObjectIdProvider provider;\n    return Serialize(commandSize, buffer, provider);\n}\n\nWireResult RenderPassEncoderInsertDebugMarkerCmd::Deserialize(\n    DeserializeBuffer* deserializeBuffer,\n    DeserializeAllocator* allocator,\n    const ObjectIdResolver& resolver\n) {\n    const volatile RenderPassEncoderInsertDebugMarkerTransfer* transfer;\n    WIRE_TRY(deserializeBuffer->Read(&transfer));\n    return RenderPassEncoderInsertDebugMarkerDeserialize(this, transfer, deserializeBuffer, allocator, resolver);\n}\nWireResult RenderPassEncoderInsertDebugMarkerCmd::Deserialize(DeserializeBuffer* deserializeBuffer, DeserializeAllocator* allocator) {\n    ErrorObjectIdResolver resolver;\n    return Deserialize(deserializeBuffer, allocator, resolver);\n}\n\n        \nsize_t RenderPassEncoderPopDebugGroupCmd::GetRequiredSize() const {\n    size_t size = sizeof(RenderPassEncoderPopDebugGroupTransfer) + RenderPassEncoderPopDebugGroupGetExtraRequiredSize(*this);\n    return size;\n}\n\nWireResult RenderPassEncoderPopDebugGroupCmd::Serialize(\n    size_t commandSize,\n    SerializeBuffer* buffer,\n    const ObjectIdProvider& provider\n) const {\n    RenderPassEncoderPopDebugGroupTransfer* transfer;\n    WIRE_TRY(buffer->Next(&transfer));\n    transfer->commandSize = commandSize;\n    return (RenderPassEncoderPopDebugGroupSerialize(*this, transfer, buffer, provider));\n}\nWireResult RenderPassEncoderPopDebugGroupCmd::Serialize(size_t commandSize, SerializeBuffer* buffer) const {\n    ErrorObjectIdProvider provider;\n    return Serialize(commandSize, buffer, provider);\n}\n\nWireResult RenderPassEncoderPopDebugGroupCmd::Deserialize(\n    DeserializeBuffer* deserializeBuffer,\n    DeserializeAllocator* allocator,\n    const ObjectIdResolver& resolver\n) {\n    const volatile RenderPassEncoderPopDebugGroupTransfer* transfer;\n    WIRE_TRY(deserializeBuffer->Read(&transfer));\n    return RenderPassEncoderPopDebugGroupDeserialize(this, transfer, deserializeBuffer, allocator, resolver);\n}\nWireResult RenderPassEncoderPopDebugGroupCmd::Deserialize(DeserializeBuffer* deserializeBuffer, DeserializeAllocator* allocator) {\n    ErrorObjectIdResolver resolver;\n    return Deserialize(deserializeBuffer, allocator, resolver);\n}\n\n        \nsize_t RenderPassEncoderPushDebugGroupCmd::GetRequiredSize() const {\n    size_t size = sizeof(RenderPassEncoderPushDebugGroupTransfer) + RenderPassEncoderPushDebugGroupGetExtraRequiredSize(*this);\n    return size;\n}\n\nWireResult RenderPassEncoderPushDebugGroupCmd::Serialize(\n    size_t commandSize,\n    SerializeBuffer* buffer,\n    const ObjectIdProvider& provider\n) const {\n    RenderPassEncoderPushDebugGroupTransfer* transfer;\n    WIRE_TRY(buffer->Next(&transfer));\n    transfer->commandSize = commandSize;\n    return (RenderPassEncoderPushDebugGroupSerialize(*this, transfer, buffer, provider));\n}\nWireResult RenderPassEncoderPushDebugGroupCmd::Serialize(size_t commandSize, SerializeBuffer* buffer) const {\n    ErrorObjectIdProvider provider;\n    return Serialize(commandSize, buffer, provider);\n}\n\nWireResult RenderPassEncoderPushDebugGroupCmd::Deserialize(\n    DeserializeBuffer* deserializeBuffer,\n    DeserializeAllocator* allocator,\n    const ObjectIdResolver& resolver\n) {\n    const volatile RenderPassEncoderPushDebugGroupTransfer* transfer;\n    WIRE_TRY(deserializeBuffer->Read(&transfer));\n    return RenderPassEncoderPushDebugGroupDeserialize(this, transfer, deserializeBuffer, allocator, resolver);\n}\nWireResult RenderPassEncoderPushDebugGroupCmd::Deserialize(DeserializeBuffer* deserializeBuffer, DeserializeAllocator* allocator) {\n    ErrorObjectIdResolver resolver;\n    return Deserialize(deserializeBuffer, allocator, resolver);\n}\n\n        \nsize_t RenderPassEncoderSetBindGroupCmd::GetRequiredSize() const {\n    size_t size = sizeof(RenderPassEncoderSetBindGroupTransfer) + RenderPassEncoderSetBindGroupGetExtraRequiredSize(*this);\n    return size;\n}\n\nWireResult RenderPassEncoderSetBindGroupCmd::Serialize(\n    size_t commandSize,\n    SerializeBuffer* buffer,\n    const ObjectIdProvider& provider\n) const {\n    RenderPassEncoderSetBindGroupTransfer* transfer;\n    WIRE_TRY(buffer->Next(&transfer));\n    transfer->commandSize = commandSize;\n    return (RenderPassEncoderSetBindGroupSerialize(*this, transfer, buffer, provider));\n}\nWireResult RenderPassEncoderSetBindGroupCmd::Serialize(size_t commandSize, SerializeBuffer* buffer) const {\n    ErrorObjectIdProvider provider;\n    return Serialize(commandSize, buffer, provider);\n}\n\nWireResult RenderPassEncoderSetBindGroupCmd::Deserialize(\n    DeserializeBuffer* deserializeBuffer,\n    DeserializeAllocator* allocator,\n    const ObjectIdResolver& resolver\n) {\n    const volatile RenderPassEncoderSetBindGroupTransfer* transfer;\n    WIRE_TRY(deserializeBuffer->Read(&transfer));\n    return RenderPassEncoderSetBindGroupDeserialize(this, transfer, deserializeBuffer, allocator, resolver);\n}\nWireResult RenderPassEncoderSetBindGroupCmd::Deserialize(DeserializeBuffer* deserializeBuffer, DeserializeAllocator* allocator) {\n    ErrorObjectIdResolver resolver;\n    return Deserialize(deserializeBuffer, allocator, resolver);\n}\n\n        \nsize_t RenderPassEncoderSetBlendConstantCmd::GetRequiredSize() const {\n    size_t size = sizeof(RenderPassEncoderSetBlendConstantTransfer) + RenderPassEncoderSetBlendConstantGetExtraRequiredSize(*this);\n    return size;\n}\n\nWireResult RenderPassEncoderSetBlendConstantCmd::Serialize(\n    size_t commandSize,\n    SerializeBuffer* buffer,\n    const ObjectIdProvider& provider\n) const {\n    RenderPassEncoderSetBlendConstantTransfer* transfer;\n    WIRE_TRY(buffer->Next(&transfer));\n    transfer->commandSize = commandSize;\n    return (RenderPassEncoderSetBlendConstantSerialize(*this, transfer, buffer, provider));\n}\nWireResult RenderPassEncoderSetBlendConstantCmd::Serialize(size_t commandSize, SerializeBuffer* buffer) const {\n    ErrorObjectIdProvider provider;\n    return Serialize(commandSize, buffer, provider);\n}\n\nWireResult RenderPassEncoderSetBlendConstantCmd::Deserialize(\n    DeserializeBuffer* deserializeBuffer,\n    DeserializeAllocator* allocator,\n    const ObjectIdResolver& resolver\n) {\n    const volatile RenderPassEncoderSetBlendConstantTransfer* transfer;\n    WIRE_TRY(deserializeBuffer->Read(&transfer));\n    return RenderPassEncoderSetBlendConstantDeserialize(this, transfer, deserializeBuffer, allocator, resolver);\n}\nWireResult RenderPassEncoderSetBlendConstantCmd::Deserialize(DeserializeBuffer* deserializeBuffer, DeserializeAllocator* allocator) {\n    ErrorObjectIdResolver resolver;\n    return Deserialize(deserializeBuffer, allocator, resolver);\n}\n\n        \nsize_t RenderPassEncoderSetIndexBufferCmd::GetRequiredSize() const {\n    size_t size = sizeof(RenderPassEncoderSetIndexBufferTransfer) + RenderPassEncoderSetIndexBufferGetExtraRequiredSize(*this);\n    return size;\n}\n\nWireResult RenderPassEncoderSetIndexBufferCmd::Serialize(\n    size_t commandSize,\n    SerializeBuffer* buffer,\n    const ObjectIdProvider& provider\n) const {\n    RenderPassEncoderSetIndexBufferTransfer* transfer;\n    WIRE_TRY(buffer->Next(&transfer));\n    transfer->commandSize = commandSize;\n    return (RenderPassEncoderSetIndexBufferSerialize(*this, transfer, buffer, provider));\n}\nWireResult RenderPassEncoderSetIndexBufferCmd::Serialize(size_t commandSize, SerializeBuffer* buffer) const {\n    ErrorObjectIdProvider provider;\n    return Serialize(commandSize, buffer, provider);\n}\n\nWireResult RenderPassEncoderSetIndexBufferCmd::Deserialize(\n    DeserializeBuffer* deserializeBuffer,\n    DeserializeAllocator* allocator,\n    const ObjectIdResolver& resolver\n) {\n    const volatile RenderPassEncoderSetIndexBufferTransfer* transfer;\n    WIRE_TRY(deserializeBuffer->Read(&transfer));\n    return RenderPassEncoderSetIndexBufferDeserialize(this, transfer, deserializeBuffer, allocator, resolver);\n}\nWireResult RenderPassEncoderSetIndexBufferCmd::Deserialize(DeserializeBuffer* deserializeBuffer, DeserializeAllocator* allocator) {\n    ErrorObjectIdResolver resolver;\n    return Deserialize(deserializeBuffer, allocator, resolver);\n}\n\n        \nsize_t RenderPassEncoderSetLabelCmd::GetRequiredSize() const {\n    size_t size = sizeof(RenderPassEncoderSetLabelTransfer) + RenderPassEncoderSetLabelGetExtraRequiredSize(*this);\n    return size;\n}\n\nWireResult RenderPassEncoderSetLabelCmd::Serialize(\n    size_t commandSize,\n    SerializeBuffer* buffer,\n    const ObjectIdProvider& provider\n) const {\n    RenderPassEncoderSetLabelTransfer* transfer;\n    WIRE_TRY(buffer->Next(&transfer));\n    transfer->commandSize = commandSize;\n    return (RenderPassEncoderSetLabelSerialize(*this, transfer, buffer, provider));\n}\nWireResult RenderPassEncoderSetLabelCmd::Serialize(size_t commandSize, SerializeBuffer* buffer) const {\n    ErrorObjectIdProvider provider;\n    return Serialize(commandSize, buffer, provider);\n}\n\nWireResult RenderPassEncoderSetLabelCmd::Deserialize(\n    DeserializeBuffer* deserializeBuffer,\n    DeserializeAllocator* allocator,\n    const ObjectIdResolver& resolver\n) {\n    const volatile RenderPassEncoderSetLabelTransfer* transfer;\n    WIRE_TRY(deserializeBuffer->Read(&transfer));\n    return RenderPassEncoderSetLabelDeserialize(this, transfer, deserializeBuffer, allocator, resolver);\n}\nWireResult RenderPassEncoderSetLabelCmd::Deserialize(DeserializeBuffer* deserializeBuffer, DeserializeAllocator* allocator) {\n    ErrorObjectIdResolver resolver;\n    return Deserialize(deserializeBuffer, allocator, resolver);\n}\n\n        \nsize_t RenderPassEncoderSetPipelineCmd::GetRequiredSize() const {\n    size_t size = sizeof(RenderPassEncoderSetPipelineTransfer) + RenderPassEncoderSetPipelineGetExtraRequiredSize(*this);\n    return size;\n}\n\nWireResult RenderPassEncoderSetPipelineCmd::Serialize(\n    size_t commandSize,\n    SerializeBuffer* buffer,\n    const ObjectIdProvider& provider\n) const {\n    RenderPassEncoderSetPipelineTransfer* transfer;\n    WIRE_TRY(buffer->Next(&transfer));\n    transfer->commandSize = commandSize;\n    return (RenderPassEncoderSetPipelineSerialize(*this, transfer, buffer, provider));\n}\nWireResult RenderPassEncoderSetPipelineCmd::Serialize(size_t commandSize, SerializeBuffer* buffer) const {\n    ErrorObjectIdProvider provider;\n    return Serialize(commandSize, buffer, provider);\n}\n\nWireResult RenderPassEncoderSetPipelineCmd::Deserialize(\n    DeserializeBuffer* deserializeBuffer,\n    DeserializeAllocator* allocator,\n    const ObjectIdResolver& resolver\n) {\n    const volatile RenderPassEncoderSetPipelineTransfer* transfer;\n    WIRE_TRY(deserializeBuffer->Read(&transfer));\n    return RenderPassEncoderSetPipelineDeserialize(this, transfer, deserializeBuffer, allocator, resolver);\n}\nWireResult RenderPassEncoderSetPipelineCmd::Deserialize(DeserializeBuffer* deserializeBuffer, DeserializeAllocator* allocator) {\n    ErrorObjectIdResolver resolver;\n    return Deserialize(deserializeBuffer, allocator, resolver);\n}\n\n        \nsize_t RenderPassEncoderSetScissorRectCmd::GetRequiredSize() const {\n    size_t size = sizeof(RenderPassEncoderSetScissorRectTransfer) + RenderPassEncoderSetScissorRectGetExtraRequiredSize(*this);\n    return size;\n}\n\nWireResult RenderPassEncoderSetScissorRectCmd::Serialize(\n    size_t commandSize,\n    SerializeBuffer* buffer,\n    const ObjectIdProvider& provider\n) const {\n    RenderPassEncoderSetScissorRectTransfer* transfer;\n    WIRE_TRY(buffer->Next(&transfer));\n    transfer->commandSize = commandSize;\n    return (RenderPassEncoderSetScissorRectSerialize(*this, transfer, buffer, provider));\n}\nWireResult RenderPassEncoderSetScissorRectCmd::Serialize(size_t commandSize, SerializeBuffer* buffer) const {\n    ErrorObjectIdProvider provider;\n    return Serialize(commandSize, buffer, provider);\n}\n\nWireResult RenderPassEncoderSetScissorRectCmd::Deserialize(\n    DeserializeBuffer* deserializeBuffer,\n    DeserializeAllocator* allocator,\n    const ObjectIdResolver& resolver\n) {\n    const volatile RenderPassEncoderSetScissorRectTransfer* transfer;\n    WIRE_TRY(deserializeBuffer->Read(&transfer));\n    return RenderPassEncoderSetScissorRectDeserialize(this, transfer, deserializeBuffer, allocator, resolver);\n}\nWireResult RenderPassEncoderSetScissorRectCmd::Deserialize(DeserializeBuffer* deserializeBuffer, DeserializeAllocator* allocator) {\n    ErrorObjectIdResolver resolver;\n    return Deserialize(deserializeBuffer, allocator, resolver);\n}\n\n        \nsize_t RenderPassEncoderSetStencilReferenceCmd::GetRequiredSize() const {\n    size_t size = sizeof(RenderPassEncoderSetStencilReferenceTransfer) + RenderPassEncoderSetStencilReferenceGetExtraRequiredSize(*this);\n    return size;\n}\n\nWireResult RenderPassEncoderSetStencilReferenceCmd::Serialize(\n    size_t commandSize,\n    SerializeBuffer* buffer,\n    const ObjectIdProvider& provider\n) const {\n    RenderPassEncoderSetStencilReferenceTransfer* transfer;\n    WIRE_TRY(buffer->Next(&transfer));\n    transfer->commandSize = commandSize;\n    return (RenderPassEncoderSetStencilReferenceSerialize(*this, transfer, buffer, provider));\n}\nWireResult RenderPassEncoderSetStencilReferenceCmd::Serialize(size_t commandSize, SerializeBuffer* buffer) const {\n    ErrorObjectIdProvider provider;\n    return Serialize(commandSize, buffer, provider);\n}\n\nWireResult RenderPassEncoderSetStencilReferenceCmd::Deserialize(\n    DeserializeBuffer* deserializeBuffer,\n    DeserializeAllocator* allocator,\n    const ObjectIdResolver& resolver\n) {\n    const volatile RenderPassEncoderSetStencilReferenceTransfer* transfer;\n    WIRE_TRY(deserializeBuffer->Read(&transfer));\n    return RenderPassEncoderSetStencilReferenceDeserialize(this, transfer, deserializeBuffer, allocator, resolver);\n}\nWireResult RenderPassEncoderSetStencilReferenceCmd::Deserialize(DeserializeBuffer* deserializeBuffer, DeserializeAllocator* allocator) {\n    ErrorObjectIdResolver resolver;\n    return Deserialize(deserializeBuffer, allocator, resolver);\n}\n\n        \nsize_t RenderPassEncoderSetVertexBufferCmd::GetRequiredSize() const {\n    size_t size = sizeof(RenderPassEncoderSetVertexBufferTransfer) + RenderPassEncoderSetVertexBufferGetExtraRequiredSize(*this);\n    return size;\n}\n\nWireResult RenderPassEncoderSetVertexBufferCmd::Serialize(\n    size_t commandSize,\n    SerializeBuffer* buffer,\n    const ObjectIdProvider& provider\n) const {\n    RenderPassEncoderSetVertexBufferTransfer* transfer;\n    WIRE_TRY(buffer->Next(&transfer));\n    transfer->commandSize = commandSize;\n    return (RenderPassEncoderSetVertexBufferSerialize(*this, transfer, buffer, provider));\n}\nWireResult RenderPassEncoderSetVertexBufferCmd::Serialize(size_t commandSize, SerializeBuffer* buffer) const {\n    ErrorObjectIdProvider provider;\n    return Serialize(commandSize, buffer, provider);\n}\n\nWireResult RenderPassEncoderSetVertexBufferCmd::Deserialize(\n    DeserializeBuffer* deserializeBuffer,\n    DeserializeAllocator* allocator,\n    const ObjectIdResolver& resolver\n) {\n    const volatile RenderPassEncoderSetVertexBufferTransfer* transfer;\n    WIRE_TRY(deserializeBuffer->Read(&transfer));\n    return RenderPassEncoderSetVertexBufferDeserialize(this, transfer, deserializeBuffer, allocator, resolver);\n}\nWireResult RenderPassEncoderSetVertexBufferCmd::Deserialize(DeserializeBuffer* deserializeBuffer, DeserializeAllocator* allocator) {\n    ErrorObjectIdResolver resolver;\n    return Deserialize(deserializeBuffer, allocator, resolver);\n}\n\n        \nsize_t RenderPassEncoderSetViewportCmd::GetRequiredSize() const {\n    size_t size = sizeof(RenderPassEncoderSetViewportTransfer) + RenderPassEncoderSetViewportGetExtraRequiredSize(*this);\n    return size;\n}\n\nWireResult RenderPassEncoderSetViewportCmd::Serialize(\n    size_t commandSize,\n    SerializeBuffer* buffer,\n    const ObjectIdProvider& provider\n) const {\n    RenderPassEncoderSetViewportTransfer* transfer;\n    WIRE_TRY(buffer->Next(&transfer));\n    transfer->commandSize = commandSize;\n    return (RenderPassEncoderSetViewportSerialize(*this, transfer, buffer, provider));\n}\nWireResult RenderPassEncoderSetViewportCmd::Serialize(size_t commandSize, SerializeBuffer* buffer) const {\n    ErrorObjectIdProvider provider;\n    return Serialize(commandSize, buffer, provider);\n}\n\nWireResult RenderPassEncoderSetViewportCmd::Deserialize(\n    DeserializeBuffer* deserializeBuffer,\n    DeserializeAllocator* allocator,\n    const ObjectIdResolver& resolver\n) {\n    const volatile RenderPassEncoderSetViewportTransfer* transfer;\n    WIRE_TRY(deserializeBuffer->Read(&transfer));\n    return RenderPassEncoderSetViewportDeserialize(this, transfer, deserializeBuffer, allocator, resolver);\n}\nWireResult RenderPassEncoderSetViewportCmd::Deserialize(DeserializeBuffer* deserializeBuffer, DeserializeAllocator* allocator) {\n    ErrorObjectIdResolver resolver;\n    return Deserialize(deserializeBuffer, allocator, resolver);\n}\n\n        \nsize_t RenderPassEncoderWriteTimestampCmd::GetRequiredSize() const {\n    size_t size = sizeof(RenderPassEncoderWriteTimestampTransfer) + RenderPassEncoderWriteTimestampGetExtraRequiredSize(*this);\n    return size;\n}\n\nWireResult RenderPassEncoderWriteTimestampCmd::Serialize(\n    size_t commandSize,\n    SerializeBuffer* buffer,\n    const ObjectIdProvider& provider\n) const {\n    RenderPassEncoderWriteTimestampTransfer* transfer;\n    WIRE_TRY(buffer->Next(&transfer));\n    transfer->commandSize = commandSize;\n    return (RenderPassEncoderWriteTimestampSerialize(*this, transfer, buffer, provider));\n}\nWireResult RenderPassEncoderWriteTimestampCmd::Serialize(size_t commandSize, SerializeBuffer* buffer) const {\n    ErrorObjectIdProvider provider;\n    return Serialize(commandSize, buffer, provider);\n}\n\nWireResult RenderPassEncoderWriteTimestampCmd::Deserialize(\n    DeserializeBuffer* deserializeBuffer,\n    DeserializeAllocator* allocator,\n    const ObjectIdResolver& resolver\n) {\n    const volatile RenderPassEncoderWriteTimestampTransfer* transfer;\n    WIRE_TRY(deserializeBuffer->Read(&transfer));\n    return RenderPassEncoderWriteTimestampDeserialize(this, transfer, deserializeBuffer, allocator, resolver);\n}\nWireResult RenderPassEncoderWriteTimestampCmd::Deserialize(DeserializeBuffer* deserializeBuffer, DeserializeAllocator* allocator) {\n    ErrorObjectIdResolver resolver;\n    return Deserialize(deserializeBuffer, allocator, resolver);\n}\n\n        \nsize_t RenderPipelineGetBindGroupLayoutCmd::GetRequiredSize() const {\n    size_t size = sizeof(RenderPipelineGetBindGroupLayoutTransfer) + RenderPipelineGetBindGroupLayoutGetExtraRequiredSize(*this);\n    return size;\n}\n\nWireResult RenderPipelineGetBindGroupLayoutCmd::Serialize(\n    size_t commandSize,\n    SerializeBuffer* buffer,\n    const ObjectIdProvider& provider\n) const {\n    RenderPipelineGetBindGroupLayoutTransfer* transfer;\n    WIRE_TRY(buffer->Next(&transfer));\n    transfer->commandSize = commandSize;\n    return (RenderPipelineGetBindGroupLayoutSerialize(*this, transfer, buffer, provider));\n}\nWireResult RenderPipelineGetBindGroupLayoutCmd::Serialize(size_t commandSize, SerializeBuffer* buffer) const {\n    ErrorObjectIdProvider provider;\n    return Serialize(commandSize, buffer, provider);\n}\n\nWireResult RenderPipelineGetBindGroupLayoutCmd::Deserialize(\n    DeserializeBuffer* deserializeBuffer,\n    DeserializeAllocator* allocator,\n    const ObjectIdResolver& resolver\n) {\n    const volatile RenderPipelineGetBindGroupLayoutTransfer* transfer;\n    WIRE_TRY(deserializeBuffer->Read(&transfer));\n    return RenderPipelineGetBindGroupLayoutDeserialize(this, transfer, deserializeBuffer, allocator, resolver);\n}\nWireResult RenderPipelineGetBindGroupLayoutCmd::Deserialize(DeserializeBuffer* deserializeBuffer, DeserializeAllocator* allocator) {\n    ErrorObjectIdResolver resolver;\n    return Deserialize(deserializeBuffer, allocator, resolver);\n}\n\n        \nsize_t RenderPipelineSetLabelCmd::GetRequiredSize() const {\n    size_t size = sizeof(RenderPipelineSetLabelTransfer) + RenderPipelineSetLabelGetExtraRequiredSize(*this);\n    return size;\n}\n\nWireResult RenderPipelineSetLabelCmd::Serialize(\n    size_t commandSize,\n    SerializeBuffer* buffer,\n    const ObjectIdProvider& provider\n) const {\n    RenderPipelineSetLabelTransfer* transfer;\n    WIRE_TRY(buffer->Next(&transfer));\n    transfer->commandSize = commandSize;\n    return (RenderPipelineSetLabelSerialize(*this, transfer, buffer, provider));\n}\nWireResult RenderPipelineSetLabelCmd::Serialize(size_t commandSize, SerializeBuffer* buffer) const {\n    ErrorObjectIdProvider provider;\n    return Serialize(commandSize, buffer, provider);\n}\n\nWireResult RenderPipelineSetLabelCmd::Deserialize(\n    DeserializeBuffer* deserializeBuffer,\n    DeserializeAllocator* allocator,\n    const ObjectIdResolver& resolver\n) {\n    const volatile RenderPipelineSetLabelTransfer* transfer;\n    WIRE_TRY(deserializeBuffer->Read(&transfer));\n    return RenderPipelineSetLabelDeserialize(this, transfer, deserializeBuffer, allocator, resolver);\n}\nWireResult RenderPipelineSetLabelCmd::Deserialize(DeserializeBuffer* deserializeBuffer, DeserializeAllocator* allocator) {\n    ErrorObjectIdResolver resolver;\n    return Deserialize(deserializeBuffer, allocator, resolver);\n}\n\n        \nsize_t SamplerSetLabelCmd::GetRequiredSize() const {\n    size_t size = sizeof(SamplerSetLabelTransfer) + SamplerSetLabelGetExtraRequiredSize(*this);\n    return size;\n}\n\nWireResult SamplerSetLabelCmd::Serialize(\n    size_t commandSize,\n    SerializeBuffer* buffer,\n    const ObjectIdProvider& provider\n) const {\n    SamplerSetLabelTransfer* transfer;\n    WIRE_TRY(buffer->Next(&transfer));\n    transfer->commandSize = commandSize;\n    return (SamplerSetLabelSerialize(*this, transfer, buffer, provider));\n}\nWireResult SamplerSetLabelCmd::Serialize(size_t commandSize, SerializeBuffer* buffer) const {\n    ErrorObjectIdProvider provider;\n    return Serialize(commandSize, buffer, provider);\n}\n\nWireResult SamplerSetLabelCmd::Deserialize(\n    DeserializeBuffer* deserializeBuffer,\n    DeserializeAllocator* allocator,\n    const ObjectIdResolver& resolver\n) {\n    const volatile SamplerSetLabelTransfer* transfer;\n    WIRE_TRY(deserializeBuffer->Read(&transfer));\n    return SamplerSetLabelDeserialize(this, transfer, deserializeBuffer, allocator, resolver);\n}\nWireResult SamplerSetLabelCmd::Deserialize(DeserializeBuffer* deserializeBuffer, DeserializeAllocator* allocator) {\n    ErrorObjectIdResolver resolver;\n    return Deserialize(deserializeBuffer, allocator, resolver);\n}\n\n        \nsize_t ShaderModuleGetCompilationInfoCmd::GetRequiredSize() const {\n    size_t size = sizeof(ShaderModuleGetCompilationInfoTransfer) + ShaderModuleGetCompilationInfoGetExtraRequiredSize(*this);\n    return size;\n}\n\nWireResult ShaderModuleGetCompilationInfoCmd::Serialize(size_t commandSize, SerializeBuffer* buffer) const {\n    ShaderModuleGetCompilationInfoTransfer* transfer;\n    WIRE_TRY(buffer->Next(&transfer));\n    transfer->commandSize = commandSize;\n    return (ShaderModuleGetCompilationInfoSerialize(*this, transfer, buffer));\n}\nWireResult ShaderModuleGetCompilationInfoCmd::Serialize(\n    size_t commandSize,\n    SerializeBuffer* buffer,\n    const ObjectIdProvider&\n) const {\n    return Serialize(commandSize, buffer);\n}\n\nWireResult ShaderModuleGetCompilationInfoCmd::Deserialize(DeserializeBuffer* deserializeBuffer, DeserializeAllocator* allocator) {\n    const volatile ShaderModuleGetCompilationInfoTransfer* transfer;\n    WIRE_TRY(deserializeBuffer->Read(&transfer));\n    return ShaderModuleGetCompilationInfoDeserialize(this, transfer, deserializeBuffer, allocator);\n}\nWireResult ShaderModuleGetCompilationInfoCmd::Deserialize(\n    DeserializeBuffer* deserializeBuffer,\n    DeserializeAllocator* allocator,\n    const ObjectIdResolver&\n) {\n    return Deserialize(deserializeBuffer, allocator);\n}\n\n        \nsize_t ShaderModuleSetLabelCmd::GetRequiredSize() const {\n    size_t size = sizeof(ShaderModuleSetLabelTransfer) + ShaderModuleSetLabelGetExtraRequiredSize(*this);\n    return size;\n}\n\nWireResult ShaderModuleSetLabelCmd::Serialize(\n    size_t commandSize,\n    SerializeBuffer* buffer,\n    const ObjectIdProvider& provider\n) const {\n    ShaderModuleSetLabelTransfer* transfer;\n    WIRE_TRY(buffer->Next(&transfer));\n    transfer->commandSize = commandSize;\n    return (ShaderModuleSetLabelSerialize(*this, transfer, buffer, provider));\n}\nWireResult ShaderModuleSetLabelCmd::Serialize(size_t commandSize, SerializeBuffer* buffer) const {\n    ErrorObjectIdProvider provider;\n    return Serialize(commandSize, buffer, provider);\n}\n\nWireResult ShaderModuleSetLabelCmd::Deserialize(\n    DeserializeBuffer* deserializeBuffer,\n    DeserializeAllocator* allocator,\n    const ObjectIdResolver& resolver\n) {\n    const volatile ShaderModuleSetLabelTransfer* transfer;\n    WIRE_TRY(deserializeBuffer->Read(&transfer));\n    return ShaderModuleSetLabelDeserialize(this, transfer, deserializeBuffer, allocator, resolver);\n}\nWireResult ShaderModuleSetLabelCmd::Deserialize(DeserializeBuffer* deserializeBuffer, DeserializeAllocator* allocator) {\n    ErrorObjectIdResolver resolver;\n    return Deserialize(deserializeBuffer, allocator, resolver);\n}\n\n        \nsize_t SwapChainConfigureCmd::GetRequiredSize() const {\n    size_t size = sizeof(SwapChainConfigureTransfer) + SwapChainConfigureGetExtraRequiredSize(*this);\n    return size;\n}\n\nWireResult SwapChainConfigureCmd::Serialize(\n    size_t commandSize,\n    SerializeBuffer* buffer,\n    const ObjectIdProvider& provider\n) const {\n    SwapChainConfigureTransfer* transfer;\n    WIRE_TRY(buffer->Next(&transfer));\n    transfer->commandSize = commandSize;\n    return (SwapChainConfigureSerialize(*this, transfer, buffer, provider));\n}\nWireResult SwapChainConfigureCmd::Serialize(size_t commandSize, SerializeBuffer* buffer) const {\n    ErrorObjectIdProvider provider;\n    return Serialize(commandSize, buffer, provider);\n}\n\nWireResult SwapChainConfigureCmd::Deserialize(\n    DeserializeBuffer* deserializeBuffer,\n    DeserializeAllocator* allocator,\n    const ObjectIdResolver& resolver\n) {\n    const volatile SwapChainConfigureTransfer* transfer;\n    WIRE_TRY(deserializeBuffer->Read(&transfer));\n    return SwapChainConfigureDeserialize(this, transfer, deserializeBuffer, allocator, resolver);\n}\nWireResult SwapChainConfigureCmd::Deserialize(DeserializeBuffer* deserializeBuffer, DeserializeAllocator* allocator) {\n    ErrorObjectIdResolver resolver;\n    return Deserialize(deserializeBuffer, allocator, resolver);\n}\n\n        \nsize_t SwapChainGetCurrentTextureViewCmd::GetRequiredSize() const {\n    size_t size = sizeof(SwapChainGetCurrentTextureViewTransfer) + SwapChainGetCurrentTextureViewGetExtraRequiredSize(*this);\n    return size;\n}\n\nWireResult SwapChainGetCurrentTextureViewCmd::Serialize(\n    size_t commandSize,\n    SerializeBuffer* buffer,\n    const ObjectIdProvider& provider\n) const {\n    SwapChainGetCurrentTextureViewTransfer* transfer;\n    WIRE_TRY(buffer->Next(&transfer));\n    transfer->commandSize = commandSize;\n    return (SwapChainGetCurrentTextureViewSerialize(*this, transfer, buffer, provider));\n}\nWireResult SwapChainGetCurrentTextureViewCmd::Serialize(size_t commandSize, SerializeBuffer* buffer) const {\n    ErrorObjectIdProvider provider;\n    return Serialize(commandSize, buffer, provider);\n}\n\nWireResult SwapChainGetCurrentTextureViewCmd::Deserialize(\n    DeserializeBuffer* deserializeBuffer,\n    DeserializeAllocator* allocator,\n    const ObjectIdResolver& resolver\n) {\n    const volatile SwapChainGetCurrentTextureViewTransfer* transfer;\n    WIRE_TRY(deserializeBuffer->Read(&transfer));\n    return SwapChainGetCurrentTextureViewDeserialize(this, transfer, deserializeBuffer, allocator, resolver);\n}\nWireResult SwapChainGetCurrentTextureViewCmd::Deserialize(DeserializeBuffer* deserializeBuffer, DeserializeAllocator* allocator) {\n    ErrorObjectIdResolver resolver;\n    return Deserialize(deserializeBuffer, allocator, resolver);\n}\n\n        \nsize_t SwapChainPresentCmd::GetRequiredSize() const {\n    size_t size = sizeof(SwapChainPresentTransfer) + SwapChainPresentGetExtraRequiredSize(*this);\n    return size;\n}\n\nWireResult SwapChainPresentCmd::Serialize(\n    size_t commandSize,\n    SerializeBuffer* buffer,\n    const ObjectIdProvider& provider\n) const {\n    SwapChainPresentTransfer* transfer;\n    WIRE_TRY(buffer->Next(&transfer));\n    transfer->commandSize = commandSize;\n    return (SwapChainPresentSerialize(*this, transfer, buffer, provider));\n}\nWireResult SwapChainPresentCmd::Serialize(size_t commandSize, SerializeBuffer* buffer) const {\n    ErrorObjectIdProvider provider;\n    return Serialize(commandSize, buffer, provider);\n}\n\nWireResult SwapChainPresentCmd::Deserialize(\n    DeserializeBuffer* deserializeBuffer,\n    DeserializeAllocator* allocator,\n    const ObjectIdResolver& resolver\n) {\n    const volatile SwapChainPresentTransfer* transfer;\n    WIRE_TRY(deserializeBuffer->Read(&transfer));\n    return SwapChainPresentDeserialize(this, transfer, deserializeBuffer, allocator, resolver);\n}\nWireResult SwapChainPresentCmd::Deserialize(DeserializeBuffer* deserializeBuffer, DeserializeAllocator* allocator) {\n    ErrorObjectIdResolver resolver;\n    return Deserialize(deserializeBuffer, allocator, resolver);\n}\n\n        \nsize_t TextureCreateViewCmd::GetRequiredSize() const {\n    size_t size = sizeof(TextureCreateViewTransfer) + TextureCreateViewGetExtraRequiredSize(*this);\n    return size;\n}\n\nWireResult TextureCreateViewCmd::Serialize(\n    size_t commandSize,\n    SerializeBuffer* buffer,\n    const ObjectIdProvider& provider\n) const {\n    TextureCreateViewTransfer* transfer;\n    WIRE_TRY(buffer->Next(&transfer));\n    transfer->commandSize = commandSize;\n    return (TextureCreateViewSerialize(*this, transfer, buffer, provider));\n}\nWireResult TextureCreateViewCmd::Serialize(size_t commandSize, SerializeBuffer* buffer) const {\n    ErrorObjectIdProvider provider;\n    return Serialize(commandSize, buffer, provider);\n}\n\nWireResult TextureCreateViewCmd::Deserialize(\n    DeserializeBuffer* deserializeBuffer,\n    DeserializeAllocator* allocator,\n    const ObjectIdResolver& resolver\n) {\n    const volatile TextureCreateViewTransfer* transfer;\n    WIRE_TRY(deserializeBuffer->Read(&transfer));\n    return TextureCreateViewDeserialize(this, transfer, deserializeBuffer, allocator, resolver);\n}\nWireResult TextureCreateViewCmd::Deserialize(DeserializeBuffer* deserializeBuffer, DeserializeAllocator* allocator) {\n    ErrorObjectIdResolver resolver;\n    return Deserialize(deserializeBuffer, allocator, resolver);\n}\n\n        \nsize_t TextureDestroyCmd::GetRequiredSize() const {\n    size_t size = sizeof(TextureDestroyTransfer) + TextureDestroyGetExtraRequiredSize(*this);\n    return size;\n}\n\nWireResult TextureDestroyCmd::Serialize(\n    size_t commandSize,\n    SerializeBuffer* buffer,\n    const ObjectIdProvider& provider\n) const {\n    TextureDestroyTransfer* transfer;\n    WIRE_TRY(buffer->Next(&transfer));\n    transfer->commandSize = commandSize;\n    return (TextureDestroySerialize(*this, transfer, buffer, provider));\n}\nWireResult TextureDestroyCmd::Serialize(size_t commandSize, SerializeBuffer* buffer) const {\n    ErrorObjectIdProvider provider;\n    return Serialize(commandSize, buffer, provider);\n}\n\nWireResult TextureDestroyCmd::Deserialize(\n    DeserializeBuffer* deserializeBuffer,\n    DeserializeAllocator* allocator,\n    const ObjectIdResolver& resolver\n) {\n    const volatile TextureDestroyTransfer* transfer;\n    WIRE_TRY(deserializeBuffer->Read(&transfer));\n    return TextureDestroyDeserialize(this, transfer, deserializeBuffer, allocator, resolver);\n}\nWireResult TextureDestroyCmd::Deserialize(DeserializeBuffer* deserializeBuffer, DeserializeAllocator* allocator) {\n    ErrorObjectIdResolver resolver;\n    return Deserialize(deserializeBuffer, allocator, resolver);\n}\n\n        \nsize_t TextureSetLabelCmd::GetRequiredSize() const {\n    size_t size = sizeof(TextureSetLabelTransfer) + TextureSetLabelGetExtraRequiredSize(*this);\n    return size;\n}\n\nWireResult TextureSetLabelCmd::Serialize(\n    size_t commandSize,\n    SerializeBuffer* buffer,\n    const ObjectIdProvider& provider\n) const {\n    TextureSetLabelTransfer* transfer;\n    WIRE_TRY(buffer->Next(&transfer));\n    transfer->commandSize = commandSize;\n    return (TextureSetLabelSerialize(*this, transfer, buffer, provider));\n}\nWireResult TextureSetLabelCmd::Serialize(size_t commandSize, SerializeBuffer* buffer) const {\n    ErrorObjectIdProvider provider;\n    return Serialize(commandSize, buffer, provider);\n}\n\nWireResult TextureSetLabelCmd::Deserialize(\n    DeserializeBuffer* deserializeBuffer,\n    DeserializeAllocator* allocator,\n    const ObjectIdResolver& resolver\n) {\n    const volatile TextureSetLabelTransfer* transfer;\n    WIRE_TRY(deserializeBuffer->Read(&transfer));\n    return TextureSetLabelDeserialize(this, transfer, deserializeBuffer, allocator, resolver);\n}\nWireResult TextureSetLabelCmd::Deserialize(DeserializeBuffer* deserializeBuffer, DeserializeAllocator* allocator) {\n    ErrorObjectIdResolver resolver;\n    return Deserialize(deserializeBuffer, allocator, resolver);\n}\n\n        \nsize_t TextureViewSetLabelCmd::GetRequiredSize() const {\n    size_t size = sizeof(TextureViewSetLabelTransfer) + TextureViewSetLabelGetExtraRequiredSize(*this);\n    return size;\n}\n\nWireResult TextureViewSetLabelCmd::Serialize(\n    size_t commandSize,\n    SerializeBuffer* buffer,\n    const ObjectIdProvider& provider\n) const {\n    TextureViewSetLabelTransfer* transfer;\n    WIRE_TRY(buffer->Next(&transfer));\n    transfer->commandSize = commandSize;\n    return (TextureViewSetLabelSerialize(*this, transfer, buffer, provider));\n}\nWireResult TextureViewSetLabelCmd::Serialize(size_t commandSize, SerializeBuffer* buffer) const {\n    ErrorObjectIdProvider provider;\n    return Serialize(commandSize, buffer, provider);\n}\n\nWireResult TextureViewSetLabelCmd::Deserialize(\n    DeserializeBuffer* deserializeBuffer,\n    DeserializeAllocator* allocator,\n    const ObjectIdResolver& resolver\n) {\n    const volatile TextureViewSetLabelTransfer* transfer;\n    WIRE_TRY(deserializeBuffer->Read(&transfer));\n    return TextureViewSetLabelDeserialize(this, transfer, deserializeBuffer, allocator, resolver);\n}\nWireResult TextureViewSetLabelCmd::Deserialize(DeserializeBuffer* deserializeBuffer, DeserializeAllocator* allocator) {\n    ErrorObjectIdResolver resolver;\n    return Deserialize(deserializeBuffer, allocator, resolver);\n}\n\n\n        \nsize_t ReturnAdapterRequestDeviceCallbackCmd::GetRequiredSize() const {\n    size_t size = sizeof(ReturnAdapterRequestDeviceCallbackTransfer) + ReturnAdapterRequestDeviceCallbackGetExtraRequiredSize(*this);\n    return size;\n}\n\nWireResult ReturnAdapterRequestDeviceCallbackCmd::Serialize(\n    size_t commandSize,\n    SerializeBuffer* buffer,\n    const ObjectIdProvider& provider\n) const {\n    ReturnAdapterRequestDeviceCallbackTransfer* transfer;\n    WIRE_TRY(buffer->Next(&transfer));\n    transfer->commandSize = commandSize;\n    return (ReturnAdapterRequestDeviceCallbackSerialize(*this, transfer, buffer, provider));\n}\nWireResult ReturnAdapterRequestDeviceCallbackCmd::Serialize(size_t commandSize, SerializeBuffer* buffer) const {\n    ErrorObjectIdProvider provider;\n    return Serialize(commandSize, buffer, provider);\n}\n\nWireResult ReturnAdapterRequestDeviceCallbackCmd::Deserialize(\n    DeserializeBuffer* deserializeBuffer,\n    DeserializeAllocator* allocator,\n    const ObjectIdResolver& resolver\n) {\n    const volatile ReturnAdapterRequestDeviceCallbackTransfer* transfer;\n    WIRE_TRY(deserializeBuffer->Read(&transfer));\n    return ReturnAdapterRequestDeviceCallbackDeserialize(this, transfer, deserializeBuffer, allocator, resolver);\n}\nWireResult ReturnAdapterRequestDeviceCallbackCmd::Deserialize(DeserializeBuffer* deserializeBuffer, DeserializeAllocator* allocator) {\n    ErrorObjectIdResolver resolver;\n    return Deserialize(deserializeBuffer, allocator, resolver);\n}\n\n        \nsize_t ReturnBufferMapAsyncCallbackCmd::GetRequiredSize() const {\n    size_t size = sizeof(ReturnBufferMapAsyncCallbackTransfer) + ReturnBufferMapAsyncCallbackGetExtraRequiredSize(*this);\n    return size;\n}\n\nWireResult ReturnBufferMapAsyncCallbackCmd::Serialize(size_t commandSize, SerializeBuffer* buffer) const {\n    ReturnBufferMapAsyncCallbackTransfer* transfer;\n    WIRE_TRY(buffer->Next(&transfer));\n    transfer->commandSize = commandSize;\n    return (ReturnBufferMapAsyncCallbackSerialize(*this, transfer, buffer));\n}\nWireResult ReturnBufferMapAsyncCallbackCmd::Serialize(\n    size_t commandSize,\n    SerializeBuffer* buffer,\n    const ObjectIdProvider&\n) const {\n    return Serialize(commandSize, buffer);\n}\n\nWireResult ReturnBufferMapAsyncCallbackCmd::Deserialize(DeserializeBuffer* deserializeBuffer, DeserializeAllocator* allocator) {\n    const volatile ReturnBufferMapAsyncCallbackTransfer* transfer;\n    WIRE_TRY(deserializeBuffer->Read(&transfer));\n    return ReturnBufferMapAsyncCallbackDeserialize(this, transfer, deserializeBuffer, allocator);\n}\nWireResult ReturnBufferMapAsyncCallbackCmd::Deserialize(\n    DeserializeBuffer* deserializeBuffer,\n    DeserializeAllocator* allocator,\n    const ObjectIdResolver&\n) {\n    return Deserialize(deserializeBuffer, allocator);\n}\n\n        \nsize_t ReturnDeviceCreateComputePipelineAsyncCallbackCmd::GetRequiredSize() const {\n    size_t size = sizeof(ReturnDeviceCreateComputePipelineAsyncCallbackTransfer) + ReturnDeviceCreateComputePipelineAsyncCallbackGetExtraRequiredSize(*this);\n    return size;\n}\n\nWireResult ReturnDeviceCreateComputePipelineAsyncCallbackCmd::Serialize(size_t commandSize, SerializeBuffer* buffer) const {\n    ReturnDeviceCreateComputePipelineAsyncCallbackTransfer* transfer;\n    WIRE_TRY(buffer->Next(&transfer));\n    transfer->commandSize = commandSize;\n    return (ReturnDeviceCreateComputePipelineAsyncCallbackSerialize(*this, transfer, buffer));\n}\nWireResult ReturnDeviceCreateComputePipelineAsyncCallbackCmd::Serialize(\n    size_t commandSize,\n    SerializeBuffer* buffer,\n    const ObjectIdProvider&\n) const {\n    return Serialize(commandSize, buffer);\n}\n\nWireResult ReturnDeviceCreateComputePipelineAsyncCallbackCmd::Deserialize(DeserializeBuffer* deserializeBuffer, DeserializeAllocator* allocator) {\n    const volatile ReturnDeviceCreateComputePipelineAsyncCallbackTransfer* transfer;\n    WIRE_TRY(deserializeBuffer->Read(&transfer));\n    return ReturnDeviceCreateComputePipelineAsyncCallbackDeserialize(this, transfer, deserializeBuffer, allocator);\n}\nWireResult ReturnDeviceCreateComputePipelineAsyncCallbackCmd::Deserialize(\n    DeserializeBuffer* deserializeBuffer,\n    DeserializeAllocator* allocator,\n    const ObjectIdResolver&\n) {\n    return Deserialize(deserializeBuffer, allocator);\n}\n\n        \nsize_t ReturnDeviceCreateRenderPipelineAsyncCallbackCmd::GetRequiredSize() const {\n    size_t size = sizeof(ReturnDeviceCreateRenderPipelineAsyncCallbackTransfer) + ReturnDeviceCreateRenderPipelineAsyncCallbackGetExtraRequiredSize(*this);\n    return size;\n}\n\nWireResult ReturnDeviceCreateRenderPipelineAsyncCallbackCmd::Serialize(size_t commandSize, SerializeBuffer* buffer) const {\n    ReturnDeviceCreateRenderPipelineAsyncCallbackTransfer* transfer;\n    WIRE_TRY(buffer->Next(&transfer));\n    transfer->commandSize = commandSize;\n    return (ReturnDeviceCreateRenderPipelineAsyncCallbackSerialize(*this, transfer, buffer));\n}\nWireResult ReturnDeviceCreateRenderPipelineAsyncCallbackCmd::Serialize(\n    size_t commandSize,\n    SerializeBuffer* buffer,\n    const ObjectIdProvider&\n) const {\n    return Serialize(commandSize, buffer);\n}\n\nWireResult ReturnDeviceCreateRenderPipelineAsyncCallbackCmd::Deserialize(DeserializeBuffer* deserializeBuffer, DeserializeAllocator* allocator) {\n    const volatile ReturnDeviceCreateRenderPipelineAsyncCallbackTransfer* transfer;\n    WIRE_TRY(deserializeBuffer->Read(&transfer));\n    return ReturnDeviceCreateRenderPipelineAsyncCallbackDeserialize(this, transfer, deserializeBuffer, allocator);\n}\nWireResult ReturnDeviceCreateRenderPipelineAsyncCallbackCmd::Deserialize(\n    DeserializeBuffer* deserializeBuffer,\n    DeserializeAllocator* allocator,\n    const ObjectIdResolver&\n) {\n    return Deserialize(deserializeBuffer, allocator);\n}\n\n        \nsize_t ReturnDeviceLoggingCallbackCmd::GetRequiredSize() const {\n    size_t size = sizeof(ReturnDeviceLoggingCallbackTransfer) + ReturnDeviceLoggingCallbackGetExtraRequiredSize(*this);\n    return size;\n}\n\nWireResult ReturnDeviceLoggingCallbackCmd::Serialize(size_t commandSize, SerializeBuffer* buffer) const {\n    ReturnDeviceLoggingCallbackTransfer* transfer;\n    WIRE_TRY(buffer->Next(&transfer));\n    transfer->commandSize = commandSize;\n    return (ReturnDeviceLoggingCallbackSerialize(*this, transfer, buffer));\n}\nWireResult ReturnDeviceLoggingCallbackCmd::Serialize(\n    size_t commandSize,\n    SerializeBuffer* buffer,\n    const ObjectIdProvider&\n) const {\n    return Serialize(commandSize, buffer);\n}\n\nWireResult ReturnDeviceLoggingCallbackCmd::Deserialize(DeserializeBuffer* deserializeBuffer, DeserializeAllocator* allocator) {\n    const volatile ReturnDeviceLoggingCallbackTransfer* transfer;\n    WIRE_TRY(deserializeBuffer->Read(&transfer));\n    return ReturnDeviceLoggingCallbackDeserialize(this, transfer, deserializeBuffer, allocator);\n}\nWireResult ReturnDeviceLoggingCallbackCmd::Deserialize(\n    DeserializeBuffer* deserializeBuffer,\n    DeserializeAllocator* allocator,\n    const ObjectIdResolver&\n) {\n    return Deserialize(deserializeBuffer, allocator);\n}\n\n        \nsize_t ReturnDeviceLostCallbackCmd::GetRequiredSize() const {\n    size_t size = sizeof(ReturnDeviceLostCallbackTransfer) + ReturnDeviceLostCallbackGetExtraRequiredSize(*this);\n    return size;\n}\n\nWireResult ReturnDeviceLostCallbackCmd::Serialize(size_t commandSize, SerializeBuffer* buffer) const {\n    ReturnDeviceLostCallbackTransfer* transfer;\n    WIRE_TRY(buffer->Next(&transfer));\n    transfer->commandSize = commandSize;\n    return (ReturnDeviceLostCallbackSerialize(*this, transfer, buffer));\n}\nWireResult ReturnDeviceLostCallbackCmd::Serialize(\n    size_t commandSize,\n    SerializeBuffer* buffer,\n    const ObjectIdProvider&\n) const {\n    return Serialize(commandSize, buffer);\n}\n\nWireResult ReturnDeviceLostCallbackCmd::Deserialize(DeserializeBuffer* deserializeBuffer, DeserializeAllocator* allocator) {\n    const volatile ReturnDeviceLostCallbackTransfer* transfer;\n    WIRE_TRY(deserializeBuffer->Read(&transfer));\n    return ReturnDeviceLostCallbackDeserialize(this, transfer, deserializeBuffer, allocator);\n}\nWireResult ReturnDeviceLostCallbackCmd::Deserialize(\n    DeserializeBuffer* deserializeBuffer,\n    DeserializeAllocator* allocator,\n    const ObjectIdResolver&\n) {\n    return Deserialize(deserializeBuffer, allocator);\n}\n\n        \nsize_t ReturnDevicePopErrorScopeCallbackCmd::GetRequiredSize() const {\n    size_t size = sizeof(ReturnDevicePopErrorScopeCallbackTransfer) + ReturnDevicePopErrorScopeCallbackGetExtraRequiredSize(*this);\n    return size;\n}\n\nWireResult ReturnDevicePopErrorScopeCallbackCmd::Serialize(size_t commandSize, SerializeBuffer* buffer) const {\n    ReturnDevicePopErrorScopeCallbackTransfer* transfer;\n    WIRE_TRY(buffer->Next(&transfer));\n    transfer->commandSize = commandSize;\n    return (ReturnDevicePopErrorScopeCallbackSerialize(*this, transfer, buffer));\n}\nWireResult ReturnDevicePopErrorScopeCallbackCmd::Serialize(\n    size_t commandSize,\n    SerializeBuffer* buffer,\n    const ObjectIdProvider&\n) const {\n    return Serialize(commandSize, buffer);\n}\n\nWireResult ReturnDevicePopErrorScopeCallbackCmd::Deserialize(DeserializeBuffer* deserializeBuffer, DeserializeAllocator* allocator) {\n    const volatile ReturnDevicePopErrorScopeCallbackTransfer* transfer;\n    WIRE_TRY(deserializeBuffer->Read(&transfer));\n    return ReturnDevicePopErrorScopeCallbackDeserialize(this, transfer, deserializeBuffer, allocator);\n}\nWireResult ReturnDevicePopErrorScopeCallbackCmd::Deserialize(\n    DeserializeBuffer* deserializeBuffer,\n    DeserializeAllocator* allocator,\n    const ObjectIdResolver&\n) {\n    return Deserialize(deserializeBuffer, allocator);\n}\n\n        \nsize_t ReturnDeviceUncapturedErrorCallbackCmd::GetRequiredSize() const {\n    size_t size = sizeof(ReturnDeviceUncapturedErrorCallbackTransfer) + ReturnDeviceUncapturedErrorCallbackGetExtraRequiredSize(*this);\n    return size;\n}\n\nWireResult ReturnDeviceUncapturedErrorCallbackCmd::Serialize(size_t commandSize, SerializeBuffer* buffer) const {\n    ReturnDeviceUncapturedErrorCallbackTransfer* transfer;\n    WIRE_TRY(buffer->Next(&transfer));\n    transfer->commandSize = commandSize;\n    return (ReturnDeviceUncapturedErrorCallbackSerialize(*this, transfer, buffer));\n}\nWireResult ReturnDeviceUncapturedErrorCallbackCmd::Serialize(\n    size_t commandSize,\n    SerializeBuffer* buffer,\n    const ObjectIdProvider&\n) const {\n    return Serialize(commandSize, buffer);\n}\n\nWireResult ReturnDeviceUncapturedErrorCallbackCmd::Deserialize(DeserializeBuffer* deserializeBuffer, DeserializeAllocator* allocator) {\n    const volatile ReturnDeviceUncapturedErrorCallbackTransfer* transfer;\n    WIRE_TRY(deserializeBuffer->Read(&transfer));\n    return ReturnDeviceUncapturedErrorCallbackDeserialize(this, transfer, deserializeBuffer, allocator);\n}\nWireResult ReturnDeviceUncapturedErrorCallbackCmd::Deserialize(\n    DeserializeBuffer* deserializeBuffer,\n    DeserializeAllocator* allocator,\n    const ObjectIdResolver&\n) {\n    return Deserialize(deserializeBuffer, allocator);\n}\n\n        \nsize_t ReturnInstanceRequestAdapterCallbackCmd::GetRequiredSize() const {\n    size_t size = sizeof(ReturnInstanceRequestAdapterCallbackTransfer) + ReturnInstanceRequestAdapterCallbackGetExtraRequiredSize(*this);\n    return size;\n}\n\nWireResult ReturnInstanceRequestAdapterCallbackCmd::Serialize(\n    size_t commandSize,\n    SerializeBuffer* buffer,\n    const ObjectIdProvider& provider\n) const {\n    ReturnInstanceRequestAdapterCallbackTransfer* transfer;\n    WIRE_TRY(buffer->Next(&transfer));\n    transfer->commandSize = commandSize;\n    return (ReturnInstanceRequestAdapterCallbackSerialize(*this, transfer, buffer, provider));\n}\nWireResult ReturnInstanceRequestAdapterCallbackCmd::Serialize(size_t commandSize, SerializeBuffer* buffer) const {\n    ErrorObjectIdProvider provider;\n    return Serialize(commandSize, buffer, provider);\n}\n\nWireResult ReturnInstanceRequestAdapterCallbackCmd::Deserialize(\n    DeserializeBuffer* deserializeBuffer,\n    DeserializeAllocator* allocator,\n    const ObjectIdResolver& resolver\n) {\n    const volatile ReturnInstanceRequestAdapterCallbackTransfer* transfer;\n    WIRE_TRY(deserializeBuffer->Read(&transfer));\n    return ReturnInstanceRequestAdapterCallbackDeserialize(this, transfer, deserializeBuffer, allocator, resolver);\n}\nWireResult ReturnInstanceRequestAdapterCallbackCmd::Deserialize(DeserializeBuffer* deserializeBuffer, DeserializeAllocator* allocator) {\n    ErrorObjectIdResolver resolver;\n    return Deserialize(deserializeBuffer, allocator, resolver);\n}\n\n        \nsize_t ReturnQueueWorkDoneCallbackCmd::GetRequiredSize() const {\n    size_t size = sizeof(ReturnQueueWorkDoneCallbackTransfer) + ReturnQueueWorkDoneCallbackGetExtraRequiredSize(*this);\n    return size;\n}\n\nWireResult ReturnQueueWorkDoneCallbackCmd::Serialize(size_t commandSize, SerializeBuffer* buffer) const {\n    ReturnQueueWorkDoneCallbackTransfer* transfer;\n    WIRE_TRY(buffer->Next(&transfer));\n    transfer->commandSize = commandSize;\n    return (ReturnQueueWorkDoneCallbackSerialize(*this, transfer, buffer));\n}\nWireResult ReturnQueueWorkDoneCallbackCmd::Serialize(\n    size_t commandSize,\n    SerializeBuffer* buffer,\n    const ObjectIdProvider&\n) const {\n    return Serialize(commandSize, buffer);\n}\n\nWireResult ReturnQueueWorkDoneCallbackCmd::Deserialize(DeserializeBuffer* deserializeBuffer, DeserializeAllocator* allocator) {\n    const volatile ReturnQueueWorkDoneCallbackTransfer* transfer;\n    WIRE_TRY(deserializeBuffer->Read(&transfer));\n    return ReturnQueueWorkDoneCallbackDeserialize(this, transfer, deserializeBuffer, allocator);\n}\nWireResult ReturnQueueWorkDoneCallbackCmd::Deserialize(\n    DeserializeBuffer* deserializeBuffer,\n    DeserializeAllocator* allocator,\n    const ObjectIdResolver&\n) {\n    return Deserialize(deserializeBuffer, allocator);\n}\n\n        \nsize_t ReturnShaderModuleGetCompilationInfoCallbackCmd::GetRequiredSize() const {\n    size_t size = sizeof(ReturnShaderModuleGetCompilationInfoCallbackTransfer) + ReturnShaderModuleGetCompilationInfoCallbackGetExtraRequiredSize(*this);\n    return size;\n}\n\nWireResult ReturnShaderModuleGetCompilationInfoCallbackCmd::Serialize(\n    size_t commandSize,\n    SerializeBuffer* buffer,\n    const ObjectIdProvider& provider\n) const {\n    ReturnShaderModuleGetCompilationInfoCallbackTransfer* transfer;\n    WIRE_TRY(buffer->Next(&transfer));\n    transfer->commandSize = commandSize;\n    return (ReturnShaderModuleGetCompilationInfoCallbackSerialize(*this, transfer, buffer, provider));\n}\nWireResult ReturnShaderModuleGetCompilationInfoCallbackCmd::Serialize(size_t commandSize, SerializeBuffer* buffer) const {\n    ErrorObjectIdProvider provider;\n    return Serialize(commandSize, buffer, provider);\n}\n\nWireResult ReturnShaderModuleGetCompilationInfoCallbackCmd::Deserialize(\n    DeserializeBuffer* deserializeBuffer,\n    DeserializeAllocator* allocator,\n    const ObjectIdResolver& resolver\n) {\n    const volatile ReturnShaderModuleGetCompilationInfoCallbackTransfer* transfer;\n    WIRE_TRY(deserializeBuffer->Read(&transfer));\n    return ReturnShaderModuleGetCompilationInfoCallbackDeserialize(this, transfer, deserializeBuffer, allocator, resolver);\n}\nWireResult ReturnShaderModuleGetCompilationInfoCallbackCmd::Deserialize(DeserializeBuffer* deserializeBuffer, DeserializeAllocator* allocator) {\n    ErrorObjectIdResolver resolver;\n    return Deserialize(deserializeBuffer, allocator, resolver);\n}\n\n\n}  // namespace dawn::wire\n", "src/dawn/wire/client/ApiObjects_autogen.h": "\n#ifndef DAWNWIRE_CLIENT_APIOBJECTS_AUTOGEN_H_\n#define DAWNWIRE_CLIENT_APIOBJECTS_AUTOGEN_H_\n\n#include \"dawn/wire/ObjectType_autogen.h\"\n#include \"dawn/wire/client/ObjectBase.h\"\n\nnamespace dawn::wire::client {\n\n    template<typename T>\n    inline constexpr ObjectType ObjectTypeToTypeEnum = static_cast<ObjectType>(-1);\n\n    class Adapter;\n\n    inline Adapter* FromAPI(WGPUAdapter obj) {\n        return reinterpret_cast<Adapter*>(obj);\n    }\n    inline WGPUAdapter ToAPI(Adapter* obj) {\n        return reinterpret_cast<WGPUAdapter>(obj);\n    }\n\n    template <>\n    inline constexpr ObjectType ObjectTypeToTypeEnum<Adapter> = ObjectType::Adapter;\n\n    struct BindGroup final : ObjectBase {\n        using ObjectBase::ObjectBase;\n    };\n\n    inline BindGroup* FromAPI(WGPUBindGroup obj) {\n        return reinterpret_cast<BindGroup*>(obj);\n    }\n    inline WGPUBindGroup ToAPI(BindGroup* obj) {\n        return reinterpret_cast<WGPUBindGroup>(obj);\n    }\n\n    template <>\n    inline constexpr ObjectType ObjectTypeToTypeEnum<BindGroup> = ObjectType::BindGroup;\n\n    struct BindGroupLayout final : ObjectBase {\n        using ObjectBase::ObjectBase;\n    };\n\n    inline BindGroupLayout* FromAPI(WGPUBindGroupLayout obj) {\n        return reinterpret_cast<BindGroupLayout*>(obj);\n    }\n    inline WGPUBindGroupLayout ToAPI(BindGroupLayout* obj) {\n        return reinterpret_cast<WGPUBindGroupLayout>(obj);\n    }\n\n    template <>\n    inline constexpr ObjectType ObjectTypeToTypeEnum<BindGroupLayout> = ObjectType::BindGroupLayout;\n\n    class Buffer;\n\n    inline Buffer* FromAPI(WGPUBuffer obj) {\n        return reinterpret_cast<Buffer*>(obj);\n    }\n    inline WGPUBuffer ToAPI(Buffer* obj) {\n        return reinterpret_cast<WGPUBuffer>(obj);\n    }\n\n    template <>\n    inline constexpr ObjectType ObjectTypeToTypeEnum<Buffer> = ObjectType::Buffer;\n\n    struct CommandBuffer final : ObjectBase {\n        using ObjectBase::ObjectBase;\n    };\n\n    inline CommandBuffer* FromAPI(WGPUCommandBuffer obj) {\n        return reinterpret_cast<CommandBuffer*>(obj);\n    }\n    inline WGPUCommandBuffer ToAPI(CommandBuffer* obj) {\n        return reinterpret_cast<WGPUCommandBuffer>(obj);\n    }\n\n    template <>\n    inline constexpr ObjectType ObjectTypeToTypeEnum<CommandBuffer> = ObjectType::CommandBuffer;\n\n    struct CommandEncoder final : ObjectBase {\n        using ObjectBase::ObjectBase;\n    };\n\n    inline CommandEncoder* FromAPI(WGPUCommandEncoder obj) {\n        return reinterpret_cast<CommandEncoder*>(obj);\n    }\n    inline WGPUCommandEncoder ToAPI(CommandEncoder* obj) {\n        return reinterpret_cast<WGPUCommandEncoder>(obj);\n    }\n\n    template <>\n    inline constexpr ObjectType ObjectTypeToTypeEnum<CommandEncoder> = ObjectType::CommandEncoder;\n\n    struct ComputePassEncoder final : ObjectBase {\n        using ObjectBase::ObjectBase;\n    };\n\n    inline ComputePassEncoder* FromAPI(WGPUComputePassEncoder obj) {\n        return reinterpret_cast<ComputePassEncoder*>(obj);\n    }\n    inline WGPUComputePassEncoder ToAPI(ComputePassEncoder* obj) {\n        return reinterpret_cast<WGPUComputePassEncoder>(obj);\n    }\n\n    template <>\n    inline constexpr ObjectType ObjectTypeToTypeEnum<ComputePassEncoder> = ObjectType::ComputePassEncoder;\n\n    struct ComputePipeline final : ObjectBase {\n        using ObjectBase::ObjectBase;\n    };\n\n    inline ComputePipeline* FromAPI(WGPUComputePipeline obj) {\n        return reinterpret_cast<ComputePipeline*>(obj);\n    }\n    inline WGPUComputePipeline ToAPI(ComputePipeline* obj) {\n        return reinterpret_cast<WGPUComputePipeline>(obj);\n    }\n\n    template <>\n    inline constexpr ObjectType ObjectTypeToTypeEnum<ComputePipeline> = ObjectType::ComputePipeline;\n\n    class Device;\n\n    inline Device* FromAPI(WGPUDevice obj) {\n        return reinterpret_cast<Device*>(obj);\n    }\n    inline WGPUDevice ToAPI(Device* obj) {\n        return reinterpret_cast<WGPUDevice>(obj);\n    }\n\n    template <>\n    inline constexpr ObjectType ObjectTypeToTypeEnum<Device> = ObjectType::Device;\n\n    struct ExternalTexture final : ObjectBase {\n        using ObjectBase::ObjectBase;\n    };\n\n    inline ExternalTexture* FromAPI(WGPUExternalTexture obj) {\n        return reinterpret_cast<ExternalTexture*>(obj);\n    }\n    inline WGPUExternalTexture ToAPI(ExternalTexture* obj) {\n        return reinterpret_cast<WGPUExternalTexture>(obj);\n    }\n\n    template <>\n    inline constexpr ObjectType ObjectTypeToTypeEnum<ExternalTexture> = ObjectType::ExternalTexture;\n\n    class Instance;\n\n    inline Instance* FromAPI(WGPUInstance obj) {\n        return reinterpret_cast<Instance*>(obj);\n    }\n    inline WGPUInstance ToAPI(Instance* obj) {\n        return reinterpret_cast<WGPUInstance>(obj);\n    }\n\n    template <>\n    inline constexpr ObjectType ObjectTypeToTypeEnum<Instance> = ObjectType::Instance;\n\n    struct PipelineLayout final : ObjectBase {\n        using ObjectBase::ObjectBase;\n    };\n\n    inline PipelineLayout* FromAPI(WGPUPipelineLayout obj) {\n        return reinterpret_cast<PipelineLayout*>(obj);\n    }\n    inline WGPUPipelineLayout ToAPI(PipelineLayout* obj) {\n        return reinterpret_cast<WGPUPipelineLayout>(obj);\n    }\n\n    template <>\n    inline constexpr ObjectType ObjectTypeToTypeEnum<PipelineLayout> = ObjectType::PipelineLayout;\n\n    class QuerySet;\n\n    inline QuerySet* FromAPI(WGPUQuerySet obj) {\n        return reinterpret_cast<QuerySet*>(obj);\n    }\n    inline WGPUQuerySet ToAPI(QuerySet* obj) {\n        return reinterpret_cast<WGPUQuerySet>(obj);\n    }\n\n    template <>\n    inline constexpr ObjectType ObjectTypeToTypeEnum<QuerySet> = ObjectType::QuerySet;\n\n    class Queue;\n\n    inline Queue* FromAPI(WGPUQueue obj) {\n        return reinterpret_cast<Queue*>(obj);\n    }\n    inline WGPUQueue ToAPI(Queue* obj) {\n        return reinterpret_cast<WGPUQueue>(obj);\n    }\n\n    template <>\n    inline constexpr ObjectType ObjectTypeToTypeEnum<Queue> = ObjectType::Queue;\n\n    struct RenderBundle final : ObjectBase {\n        using ObjectBase::ObjectBase;\n    };\n\n    inline RenderBundle* FromAPI(WGPURenderBundle obj) {\n        return reinterpret_cast<RenderBundle*>(obj);\n    }\n    inline WGPURenderBundle ToAPI(RenderBundle* obj) {\n        return reinterpret_cast<WGPURenderBundle>(obj);\n    }\n\n    template <>\n    inline constexpr ObjectType ObjectTypeToTypeEnum<RenderBundle> = ObjectType::RenderBundle;\n\n    struct RenderBundleEncoder final : ObjectBase {\n        using ObjectBase::ObjectBase;\n    };\n\n    inline RenderBundleEncoder* FromAPI(WGPURenderBundleEncoder obj) {\n        return reinterpret_cast<RenderBundleEncoder*>(obj);\n    }\n    inline WGPURenderBundleEncoder ToAPI(RenderBundleEncoder* obj) {\n        return reinterpret_cast<WGPURenderBundleEncoder>(obj);\n    }\n\n    template <>\n    inline constexpr ObjectType ObjectTypeToTypeEnum<RenderBundleEncoder> = ObjectType::RenderBundleEncoder;\n\n    struct RenderPassEncoder final : ObjectBase {\n        using ObjectBase::ObjectBase;\n    };\n\n    inline RenderPassEncoder* FromAPI(WGPURenderPassEncoder obj) {\n        return reinterpret_cast<RenderPassEncoder*>(obj);\n    }\n    inline WGPURenderPassEncoder ToAPI(RenderPassEncoder* obj) {\n        return reinterpret_cast<WGPURenderPassEncoder>(obj);\n    }\n\n    template <>\n    inline constexpr ObjectType ObjectTypeToTypeEnum<RenderPassEncoder> = ObjectType::RenderPassEncoder;\n\n    struct RenderPipeline final : ObjectBase {\n        using ObjectBase::ObjectBase;\n    };\n\n    inline RenderPipeline* FromAPI(WGPURenderPipeline obj) {\n        return reinterpret_cast<RenderPipeline*>(obj);\n    }\n    inline WGPURenderPipeline ToAPI(RenderPipeline* obj) {\n        return reinterpret_cast<WGPURenderPipeline>(obj);\n    }\n\n    template <>\n    inline constexpr ObjectType ObjectTypeToTypeEnum<RenderPipeline> = ObjectType::RenderPipeline;\n\n    struct Sampler final : ObjectBase {\n        using ObjectBase::ObjectBase;\n    };\n\n    inline Sampler* FromAPI(WGPUSampler obj) {\n        return reinterpret_cast<Sampler*>(obj);\n    }\n    inline WGPUSampler ToAPI(Sampler* obj) {\n        return reinterpret_cast<WGPUSampler>(obj);\n    }\n\n    template <>\n    inline constexpr ObjectType ObjectTypeToTypeEnum<Sampler> = ObjectType::Sampler;\n\n    class ShaderModule;\n\n    inline ShaderModule* FromAPI(WGPUShaderModule obj) {\n        return reinterpret_cast<ShaderModule*>(obj);\n    }\n    inline WGPUShaderModule ToAPI(ShaderModule* obj) {\n        return reinterpret_cast<WGPUShaderModule>(obj);\n    }\n\n    template <>\n    inline constexpr ObjectType ObjectTypeToTypeEnum<ShaderModule> = ObjectType::ShaderModule;\n\n    struct Surface final : ObjectBase {\n        using ObjectBase::ObjectBase;\n    };\n\n    inline Surface* FromAPI(WGPUSurface obj) {\n        return reinterpret_cast<Surface*>(obj);\n    }\n    inline WGPUSurface ToAPI(Surface* obj) {\n        return reinterpret_cast<WGPUSurface>(obj);\n    }\n\n    template <>\n    inline constexpr ObjectType ObjectTypeToTypeEnum<Surface> = ObjectType::Surface;\n\n    struct SwapChain final : ObjectBase {\n        using ObjectBase::ObjectBase;\n    };\n\n    inline SwapChain* FromAPI(WGPUSwapChain obj) {\n        return reinterpret_cast<SwapChain*>(obj);\n    }\n    inline WGPUSwapChain ToAPI(SwapChain* obj) {\n        return reinterpret_cast<WGPUSwapChain>(obj);\n    }\n\n    template <>\n    inline constexpr ObjectType ObjectTypeToTypeEnum<SwapChain> = ObjectType::SwapChain;\n\n    class Texture;\n\n    inline Texture* FromAPI(WGPUTexture obj) {\n        return reinterpret_cast<Texture*>(obj);\n    }\n    inline WGPUTexture ToAPI(Texture* obj) {\n        return reinterpret_cast<WGPUTexture>(obj);\n    }\n\n    template <>\n    inline constexpr ObjectType ObjectTypeToTypeEnum<Texture> = ObjectType::Texture;\n\n    struct TextureView final : ObjectBase {\n        using ObjectBase::ObjectBase;\n    };\n\n    inline TextureView* FromAPI(WGPUTextureView obj) {\n        return reinterpret_cast<TextureView*>(obj);\n    }\n    inline WGPUTextureView ToAPI(TextureView* obj) {\n        return reinterpret_cast<WGPUTextureView>(obj);\n    }\n\n    template <>\n    inline constexpr ObjectType ObjectTypeToTypeEnum<TextureView> = ObjectType::TextureView;\n\n}  // namespace dawn::wire::client\n\n#endif  // DAWNWIRE_CLIENT_APIOBJECTS_AUTOGEN_H_\n", "src/dawn/wire/client/ApiProcs_autogen.cpp": "\n#include \"dawn/wire/client/ApiObjects.h\"\n#include \"dawn/wire/client/Client.h\"\n\n#include <algorithm>\n#include <cstring>\n#include <string>\n#include <vector>\n\nnamespace dawn::wire::client {\n\n\n\n\n    static\n    WGPUDevice ClientAdapterCreateDevice(WGPUAdapter cSelf, WGPUDeviceDescriptor const * descriptor) {\n        auto self = reinterpret_cast<Adapter*>(cSelf);\n        return self->CreateDevice( descriptor);\n    }\n\n    static\n    size_t ClientAdapterEnumerateFeatures(WGPUAdapter cSelf, WGPUFeatureName * features) {\n        auto self = reinterpret_cast<Adapter*>(cSelf);\n        return self->EnumerateFeatures( features);\n    }\n\n    static\n    bool ClientAdapterGetLimits(WGPUAdapter cSelf, WGPUSupportedLimits * limits) {\n        auto self = reinterpret_cast<Adapter*>(cSelf);\n        return self->GetLimits( limits);\n    }\n\n    static\n    void ClientAdapterGetProperties(WGPUAdapter cSelf, WGPUAdapterProperties * properties) {\n        auto self = reinterpret_cast<Adapter*>(cSelf);\n        return self->GetProperties( properties);\n    }\n\n    static\n    bool ClientAdapterHasFeature(WGPUAdapter cSelf, WGPUFeatureName feature) {\n        auto self = reinterpret_cast<Adapter*>(cSelf);\n        return self->HasFeature( feature);\n    }\n\n    static\n    void ClientAdapterRequestDevice(WGPUAdapter cSelf, WGPUDeviceDescriptor const * descriptor, WGPURequestDeviceCallback callback, void * userdata) {\n        auto self = reinterpret_cast<Adapter*>(cSelf);\n        return self->RequestDevice( descriptor,  callback,  userdata);\n    }\n\n    void ClientAdapterRelease(WGPUAdapter cObj) {\n        Adapter* obj = reinterpret_cast<Adapter*>(cObj);\n\n        if (!obj->Release()) {\n            return;\n        }\n\n        DestroyObjectCmd cmd;\n        cmd.objectType = ObjectType::Adapter;\n        cmd.objectId = obj->GetWireId();\n\n        Client* client = obj->GetClient();\n        client->SerializeCommand(cmd);\n        client->Free(obj);\n    }\n\n    void ClientAdapterReference(WGPUAdapter cObj) {\n        reinterpret_cast<Adapter*>(cObj)->Reference();\n    }\n\n\n    void ClientBindGroupSetLabel(WGPUBindGroup cSelf, char const * label) {\n        auto self = reinterpret_cast<BindGroup*>(cSelf);\n        BindGroupSetLabelCmd cmd;\n\n        cmd.self = cSelf;\n\n\n        \n        cmd.label = label;\n\n        self->GetClient()->SerializeCommand(cmd);\n\n    }\n\n    void ClientBindGroupRelease(WGPUBindGroup cObj) {\n        BindGroup* obj = reinterpret_cast<BindGroup*>(cObj);\n\n        if (!obj->Release()) {\n            return;\n        }\n\n        DestroyObjectCmd cmd;\n        cmd.objectType = ObjectType::BindGroup;\n        cmd.objectId = obj->GetWireId();\n\n        Client* client = obj->GetClient();\n        client->SerializeCommand(cmd);\n        client->Free(obj);\n    }\n\n    void ClientBindGroupReference(WGPUBindGroup cObj) {\n        reinterpret_cast<BindGroup*>(cObj)->Reference();\n    }\n\n\n    void ClientBindGroupLayoutSetLabel(WGPUBindGroupLayout cSelf, char const * label) {\n        auto self = reinterpret_cast<BindGroupLayout*>(cSelf);\n        BindGroupLayoutSetLabelCmd cmd;\n\n        cmd.self = cSelf;\n\n\n        \n        cmd.label = label;\n\n        self->GetClient()->SerializeCommand(cmd);\n\n    }\n\n    void ClientBindGroupLayoutRelease(WGPUBindGroupLayout cObj) {\n        BindGroupLayout* obj = reinterpret_cast<BindGroupLayout*>(cObj);\n\n        if (!obj->Release()) {\n            return;\n        }\n\n        DestroyObjectCmd cmd;\n        cmd.objectType = ObjectType::BindGroupLayout;\n        cmd.objectId = obj->GetWireId();\n\n        Client* client = obj->GetClient();\n        client->SerializeCommand(cmd);\n        client->Free(obj);\n    }\n\n    void ClientBindGroupLayoutReference(WGPUBindGroupLayout cObj) {\n        reinterpret_cast<BindGroupLayout*>(cObj)->Reference();\n    }\n\n\n    static\n    void ClientBufferDestroy(WGPUBuffer cSelf) {\n        auto self = reinterpret_cast<Buffer*>(cSelf);\n        return self->Destroy();\n    }\n\n    static\n    void const * ClientBufferGetConstMappedRange(WGPUBuffer cSelf, size_t offset, size_t size) {\n        auto self = reinterpret_cast<Buffer*>(cSelf);\n        return self->GetConstMappedRange( offset,  size);\n    }\n\n    static\n    void * ClientBufferGetMappedRange(WGPUBuffer cSelf, size_t offset, size_t size) {\n        auto self = reinterpret_cast<Buffer*>(cSelf);\n        return self->GetMappedRange( offset,  size);\n    }\n\n    static\n    uint64_t ClientBufferGetSize(WGPUBuffer cSelf) {\n        auto self = reinterpret_cast<Buffer*>(cSelf);\n        return self->GetSize();\n    }\n\n    static\n    WGPUBufferUsage ClientBufferGetUsage(WGPUBuffer cSelf) {\n        auto self = reinterpret_cast<Buffer*>(cSelf);\n        return self->GetUsage();\n    }\n\n    static\n    void ClientBufferMapAsync(WGPUBuffer cSelf, WGPUMapModeFlags mode, size_t offset, size_t size, WGPUBufferMapCallback callback, void * userdata) {\n        auto self = reinterpret_cast<Buffer*>(cSelf);\n        return self->MapAsync( mode,  offset,  size,  callback,  userdata);\n    }\n\n    void ClientBufferSetLabel(WGPUBuffer cSelf, char const * label) {\n        auto self = reinterpret_cast<Buffer*>(cSelf);\n        BufferSetLabelCmd cmd;\n\n        cmd.self = cSelf;\n\n\n        \n        cmd.label = label;\n\n        self->GetClient()->SerializeCommand(cmd);\n\n    }\n\n    static\n    void ClientBufferUnmap(WGPUBuffer cSelf) {\n        auto self = reinterpret_cast<Buffer*>(cSelf);\n        return self->Unmap();\n    }\n\n    void ClientBufferRelease(WGPUBuffer cObj) {\n        Buffer* obj = reinterpret_cast<Buffer*>(cObj);\n\n        if (!obj->Release()) {\n            return;\n        }\n\n        DestroyObjectCmd cmd;\n        cmd.objectType = ObjectType::Buffer;\n        cmd.objectId = obj->GetWireId();\n\n        Client* client = obj->GetClient();\n        client->SerializeCommand(cmd);\n        client->Free(obj);\n    }\n\n    void ClientBufferReference(WGPUBuffer cObj) {\n        reinterpret_cast<Buffer*>(cObj)->Reference();\n    }\n\n\n    void ClientCommandBufferSetLabel(WGPUCommandBuffer cSelf, char const * label) {\n        auto self = reinterpret_cast<CommandBuffer*>(cSelf);\n        CommandBufferSetLabelCmd cmd;\n\n        cmd.self = cSelf;\n\n\n        \n        cmd.label = label;\n\n        self->GetClient()->SerializeCommand(cmd);\n\n    }\n\n    void ClientCommandBufferRelease(WGPUCommandBuffer cObj) {\n        CommandBuffer* obj = reinterpret_cast<CommandBuffer*>(cObj);\n\n        if (!obj->Release()) {\n            return;\n        }\n\n        DestroyObjectCmd cmd;\n        cmd.objectType = ObjectType::CommandBuffer;\n        cmd.objectId = obj->GetWireId();\n\n        Client* client = obj->GetClient();\n        client->SerializeCommand(cmd);\n        client->Free(obj);\n    }\n\n    void ClientCommandBufferReference(WGPUCommandBuffer cObj) {\n        reinterpret_cast<CommandBuffer*>(cObj)->Reference();\n    }\n\n\n    WGPUComputePassEncoder ClientCommandEncoderBeginComputePass(WGPUCommandEncoder cSelf, WGPUComputePassDescriptor const * descriptor) {\n        auto self = reinterpret_cast<CommandEncoder*>(cSelf);\n        CommandEncoderBeginComputePassCmd cmd;\n\n        cmd.self = cSelf;\n\n        auto* returnObject = self->GetClient()->Make<ComputePassEncoder>();\n        cmd.result = returnObject->GetWireHandle();\n\n        \n        cmd.descriptor = descriptor;\n\n        self->GetClient()->SerializeCommand(cmd);\n\n        return ToAPI(returnObject);\n    }\n\n    WGPURenderPassEncoder ClientCommandEncoderBeginRenderPass(WGPUCommandEncoder cSelf, WGPURenderPassDescriptor const * descriptor) {\n        auto self = reinterpret_cast<CommandEncoder*>(cSelf);\n        CommandEncoderBeginRenderPassCmd cmd;\n\n        cmd.self = cSelf;\n\n        auto* returnObject = self->GetClient()->Make<RenderPassEncoder>();\n        cmd.result = returnObject->GetWireHandle();\n\n        \n        cmd.descriptor = descriptor;\n\n        self->GetClient()->SerializeCommand(cmd);\n\n        return ToAPI(returnObject);\n    }\n\n    void ClientCommandEncoderClearBuffer(WGPUCommandEncoder cSelf, WGPUBuffer buffer, uint64_t offset, uint64_t size) {\n        auto self = reinterpret_cast<CommandEncoder*>(cSelf);\n        CommandEncoderClearBufferCmd cmd;\n\n        cmd.self = cSelf;\n\n\n        \n        cmd.buffer = buffer;\n        \n        cmd.offset = offset;\n        \n        cmd.size = size;\n\n        self->GetClient()->SerializeCommand(cmd);\n\n    }\n\n    void ClientCommandEncoderCopyBufferToBuffer(WGPUCommandEncoder cSelf, WGPUBuffer source, uint64_t sourceOffset, WGPUBuffer destination, uint64_t destinationOffset, uint64_t size) {\n        auto self = reinterpret_cast<CommandEncoder*>(cSelf);\n        CommandEncoderCopyBufferToBufferCmd cmd;\n\n        cmd.self = cSelf;\n\n\n        \n        cmd.source = source;\n        \n        cmd.sourceOffset = sourceOffset;\n        \n        cmd.destination = destination;\n        \n        cmd.destinationOffset = destinationOffset;\n        \n        cmd.size = size;\n\n        self->GetClient()->SerializeCommand(cmd);\n\n    }\n\n    void ClientCommandEncoderCopyBufferToTexture(WGPUCommandEncoder cSelf, WGPUImageCopyBuffer const * source, WGPUImageCopyTexture const * destination, WGPUExtent3D const * copySize) {\n        auto self = reinterpret_cast<CommandEncoder*>(cSelf);\n        CommandEncoderCopyBufferToTextureCmd cmd;\n\n        cmd.self = cSelf;\n\n\n        \n        cmd.source = source;\n        \n        cmd.destination = destination;\n        \n        cmd.copySize = copySize;\n\n        self->GetClient()->SerializeCommand(cmd);\n\n    }\n\n    void ClientCommandEncoderCopyTextureToBuffer(WGPUCommandEncoder cSelf, WGPUImageCopyTexture const * source, WGPUImageCopyBuffer const * destination, WGPUExtent3D const * copySize) {\n        auto self = reinterpret_cast<CommandEncoder*>(cSelf);\n        CommandEncoderCopyTextureToBufferCmd cmd;\n\n        cmd.self = cSelf;\n\n\n        \n        cmd.source = source;\n        \n        cmd.destination = destination;\n        \n        cmd.copySize = copySize;\n\n        self->GetClient()->SerializeCommand(cmd);\n\n    }\n\n    void ClientCommandEncoderCopyTextureToTexture(WGPUCommandEncoder cSelf, WGPUImageCopyTexture const * source, WGPUImageCopyTexture const * destination, WGPUExtent3D const * copySize) {\n        auto self = reinterpret_cast<CommandEncoder*>(cSelf);\n        CommandEncoderCopyTextureToTextureCmd cmd;\n\n        cmd.self = cSelf;\n\n\n        \n        cmd.source = source;\n        \n        cmd.destination = destination;\n        \n        cmd.copySize = copySize;\n\n        self->GetClient()->SerializeCommand(cmd);\n\n    }\n\n    void ClientCommandEncoderCopyTextureToTextureInternal(WGPUCommandEncoder cSelf, WGPUImageCopyTexture const * source, WGPUImageCopyTexture const * destination, WGPUExtent3D const * copySize) {\n        auto self = reinterpret_cast<CommandEncoder*>(cSelf);\n        CommandEncoderCopyTextureToTextureInternalCmd cmd;\n\n        cmd.self = cSelf;\n\n\n        \n        cmd.source = source;\n        \n        cmd.destination = destination;\n        \n        cmd.copySize = copySize;\n\n        self->GetClient()->SerializeCommand(cmd);\n\n    }\n\n    WGPUCommandBuffer ClientCommandEncoderFinish(WGPUCommandEncoder cSelf, WGPUCommandBufferDescriptor const * descriptor) {\n        auto self = reinterpret_cast<CommandEncoder*>(cSelf);\n        CommandEncoderFinishCmd cmd;\n\n        cmd.self = cSelf;\n\n        auto* returnObject = self->GetClient()->Make<CommandBuffer>();\n        cmd.result = returnObject->GetWireHandle();\n\n        \n        cmd.descriptor = descriptor;\n\n        self->GetClient()->SerializeCommand(cmd);\n\n        return ToAPI(returnObject);\n    }\n\n    void ClientCommandEncoderInjectValidationError(WGPUCommandEncoder cSelf, char const * message) {\n        auto self = reinterpret_cast<CommandEncoder*>(cSelf);\n        CommandEncoderInjectValidationErrorCmd cmd;\n\n        cmd.self = cSelf;\n\n\n        \n        cmd.message = message;\n\n        self->GetClient()->SerializeCommand(cmd);\n\n    }\n\n    void ClientCommandEncoderInsertDebugMarker(WGPUCommandEncoder cSelf, char const * markerLabel) {\n        auto self = reinterpret_cast<CommandEncoder*>(cSelf);\n        CommandEncoderInsertDebugMarkerCmd cmd;\n\n        cmd.self = cSelf;\n\n\n        \n        cmd.markerLabel = markerLabel;\n\n        self->GetClient()->SerializeCommand(cmd);\n\n    }\n\n    void ClientCommandEncoderPopDebugGroup(WGPUCommandEncoder cSelf) {\n        auto self = reinterpret_cast<CommandEncoder*>(cSelf);\n        CommandEncoderPopDebugGroupCmd cmd;\n\n        cmd.self = cSelf;\n\n\n\n        self->GetClient()->SerializeCommand(cmd);\n\n    }\n\n    void ClientCommandEncoderPushDebugGroup(WGPUCommandEncoder cSelf, char const * groupLabel) {\n        auto self = reinterpret_cast<CommandEncoder*>(cSelf);\n        CommandEncoderPushDebugGroupCmd cmd;\n\n        cmd.self = cSelf;\n\n\n        \n        cmd.groupLabel = groupLabel;\n\n        self->GetClient()->SerializeCommand(cmd);\n\n    }\n\n    void ClientCommandEncoderResolveQuerySet(WGPUCommandEncoder cSelf, WGPUQuerySet querySet, uint32_t firstQuery, uint32_t queryCount, WGPUBuffer destination, uint64_t destinationOffset) {\n        auto self = reinterpret_cast<CommandEncoder*>(cSelf);\n        CommandEncoderResolveQuerySetCmd cmd;\n\n        cmd.self = cSelf;\n\n\n        \n        cmd.querySet = querySet;\n        \n        cmd.firstQuery = firstQuery;\n        \n        cmd.queryCount = queryCount;\n        \n        cmd.destination = destination;\n        \n        cmd.destinationOffset = destinationOffset;\n\n        self->GetClient()->SerializeCommand(cmd);\n\n    }\n\n    void ClientCommandEncoderSetLabel(WGPUCommandEncoder cSelf, char const * label) {\n        auto self = reinterpret_cast<CommandEncoder*>(cSelf);\n        CommandEncoderSetLabelCmd cmd;\n\n        cmd.self = cSelf;\n\n\n        \n        cmd.label = label;\n\n        self->GetClient()->SerializeCommand(cmd);\n\n    }\n\n    void ClientCommandEncoderWriteBuffer(WGPUCommandEncoder cSelf, WGPUBuffer buffer, uint64_t bufferOffset, uint8_t const * data, uint64_t size) {\n        auto self = reinterpret_cast<CommandEncoder*>(cSelf);\n        CommandEncoderWriteBufferCmd cmd;\n\n        cmd.self = cSelf;\n\n\n        \n        cmd.buffer = buffer;\n        \n        cmd.bufferOffset = bufferOffset;\n        \n        cmd.data = data;\n        \n        cmd.size = size;\n\n        self->GetClient()->SerializeCommand(cmd);\n\n    }\n\n    void ClientCommandEncoderWriteTimestamp(WGPUCommandEncoder cSelf, WGPUQuerySet querySet, uint32_t queryIndex) {\n        auto self = reinterpret_cast<CommandEncoder*>(cSelf);\n        CommandEncoderWriteTimestampCmd cmd;\n\n        cmd.self = cSelf;\n\n\n        \n        cmd.querySet = querySet;\n        \n        cmd.queryIndex = queryIndex;\n\n        self->GetClient()->SerializeCommand(cmd);\n\n    }\n\n    void ClientCommandEncoderRelease(WGPUCommandEncoder cObj) {\n        CommandEncoder* obj = reinterpret_cast<CommandEncoder*>(cObj);\n\n        if (!obj->Release()) {\n            return;\n        }\n\n        DestroyObjectCmd cmd;\n        cmd.objectType = ObjectType::CommandEncoder;\n        cmd.objectId = obj->GetWireId();\n\n        Client* client = obj->GetClient();\n        client->SerializeCommand(cmd);\n        client->Free(obj);\n    }\n\n    void ClientCommandEncoderReference(WGPUCommandEncoder cObj) {\n        reinterpret_cast<CommandEncoder*>(cObj)->Reference();\n    }\n\n\n    void ClientComputePassEncoderDispatch(WGPUComputePassEncoder cSelf, uint32_t workgroupCountX, uint32_t workgroupCountY, uint32_t workgroupCountZ) {\n        auto self = reinterpret_cast<ComputePassEncoder*>(cSelf);\n        ComputePassEncoderDispatchCmd cmd;\n\n        cmd.self = cSelf;\n\n\n        \n        cmd.workgroupCountX = workgroupCountX;\n        \n        cmd.workgroupCountY = workgroupCountY;\n        \n        cmd.workgroupCountZ = workgroupCountZ;\n\n        self->GetClient()->SerializeCommand(cmd);\n\n    }\n\n    void ClientComputePassEncoderDispatchIndirect(WGPUComputePassEncoder cSelf, WGPUBuffer indirectBuffer, uint64_t indirectOffset) {\n        auto self = reinterpret_cast<ComputePassEncoder*>(cSelf);\n        ComputePassEncoderDispatchIndirectCmd cmd;\n\n        cmd.self = cSelf;\n\n\n        \n        cmd.indirectBuffer = indirectBuffer;\n        \n        cmd.indirectOffset = indirectOffset;\n\n        self->GetClient()->SerializeCommand(cmd);\n\n    }\n\n    void ClientComputePassEncoderDispatchWorkgroups(WGPUComputePassEncoder cSelf, uint32_t workgroupCountX, uint32_t workgroupCountY, uint32_t workgroupCountZ) {\n        auto self = reinterpret_cast<ComputePassEncoder*>(cSelf);\n        ComputePassEncoderDispatchWorkgroupsCmd cmd;\n\n        cmd.self = cSelf;\n\n\n        \n        cmd.workgroupCountX = workgroupCountX;\n        \n        cmd.workgroupCountY = workgroupCountY;\n        \n        cmd.workgroupCountZ = workgroupCountZ;\n\n        self->GetClient()->SerializeCommand(cmd);\n\n    }\n\n    void ClientComputePassEncoderDispatchWorkgroupsIndirect(WGPUComputePassEncoder cSelf, WGPUBuffer indirectBuffer, uint64_t indirectOffset) {\n        auto self = reinterpret_cast<ComputePassEncoder*>(cSelf);\n        ComputePassEncoderDispatchWorkgroupsIndirectCmd cmd;\n\n        cmd.self = cSelf;\n\n\n        \n        cmd.indirectBuffer = indirectBuffer;\n        \n        cmd.indirectOffset = indirectOffset;\n\n        self->GetClient()->SerializeCommand(cmd);\n\n    }\n\n    void ClientComputePassEncoderEnd(WGPUComputePassEncoder cSelf) {\n        auto self = reinterpret_cast<ComputePassEncoder*>(cSelf);\n        ComputePassEncoderEndCmd cmd;\n\n        cmd.self = cSelf;\n\n\n\n        self->GetClient()->SerializeCommand(cmd);\n\n    }\n\n    void ClientComputePassEncoderEndPass(WGPUComputePassEncoder cSelf) {\n        auto self = reinterpret_cast<ComputePassEncoder*>(cSelf);\n        ComputePassEncoderEndPassCmd cmd;\n\n        cmd.self = cSelf;\n\n\n\n        self->GetClient()->SerializeCommand(cmd);\n\n    }\n\n    void ClientComputePassEncoderInsertDebugMarker(WGPUComputePassEncoder cSelf, char const * markerLabel) {\n        auto self = reinterpret_cast<ComputePassEncoder*>(cSelf);\n        ComputePassEncoderInsertDebugMarkerCmd cmd;\n\n        cmd.self = cSelf;\n\n\n        \n        cmd.markerLabel = markerLabel;\n\n        self->GetClient()->SerializeCommand(cmd);\n\n    }\n\n    void ClientComputePassEncoderPopDebugGroup(WGPUComputePassEncoder cSelf) {\n        auto self = reinterpret_cast<ComputePassEncoder*>(cSelf);\n        ComputePassEncoderPopDebugGroupCmd cmd;\n\n        cmd.self = cSelf;\n\n\n\n        self->GetClient()->SerializeCommand(cmd);\n\n    }\n\n    void ClientComputePassEncoderPushDebugGroup(WGPUComputePassEncoder cSelf, char const * groupLabel) {\n        auto self = reinterpret_cast<ComputePassEncoder*>(cSelf);\n        ComputePassEncoderPushDebugGroupCmd cmd;\n\n        cmd.self = cSelf;\n\n\n        \n        cmd.groupLabel = groupLabel;\n\n        self->GetClient()->SerializeCommand(cmd);\n\n    }\n\n    void ClientComputePassEncoderSetBindGroup(WGPUComputePassEncoder cSelf, uint32_t groupIndex, WGPUBindGroup group, uint32_t dynamicOffsetCount, uint32_t const * dynamicOffsets) {\n        auto self = reinterpret_cast<ComputePassEncoder*>(cSelf);\n        ComputePassEncoderSetBindGroupCmd cmd;\n\n        cmd.self = cSelf;\n\n\n        \n        cmd.groupIndex = groupIndex;\n        \n        cmd.group = group;\n        \n        cmd.dynamicOffsetCount = dynamicOffsetCount;\n        \n        cmd.dynamicOffsets = dynamicOffsets;\n\n        self->GetClient()->SerializeCommand(cmd);\n\n    }\n\n    void ClientComputePassEncoderSetLabel(WGPUComputePassEncoder cSelf, char const * label) {\n        auto self = reinterpret_cast<ComputePassEncoder*>(cSelf);\n        ComputePassEncoderSetLabelCmd cmd;\n\n        cmd.self = cSelf;\n\n\n        \n        cmd.label = label;\n\n        self->GetClient()->SerializeCommand(cmd);\n\n    }\n\n    void ClientComputePassEncoderSetPipeline(WGPUComputePassEncoder cSelf, WGPUComputePipeline pipeline) {\n        auto self = reinterpret_cast<ComputePassEncoder*>(cSelf);\n        ComputePassEncoderSetPipelineCmd cmd;\n\n        cmd.self = cSelf;\n\n\n        \n        cmd.pipeline = pipeline;\n\n        self->GetClient()->SerializeCommand(cmd);\n\n    }\n\n    void ClientComputePassEncoderWriteTimestamp(WGPUComputePassEncoder cSelf, WGPUQuerySet querySet, uint32_t queryIndex) {\n        auto self = reinterpret_cast<ComputePassEncoder*>(cSelf);\n        ComputePassEncoderWriteTimestampCmd cmd;\n\n        cmd.self = cSelf;\n\n\n        \n        cmd.querySet = querySet;\n        \n        cmd.queryIndex = queryIndex;\n\n        self->GetClient()->SerializeCommand(cmd);\n\n    }\n\n    void ClientComputePassEncoderRelease(WGPUComputePassEncoder cObj) {\n        ComputePassEncoder* obj = reinterpret_cast<ComputePassEncoder*>(cObj);\n\n        if (!obj->Release()) {\n            return;\n        }\n\n        DestroyObjectCmd cmd;\n        cmd.objectType = ObjectType::ComputePassEncoder;\n        cmd.objectId = obj->GetWireId();\n\n        Client* client = obj->GetClient();\n        client->SerializeCommand(cmd);\n        client->Free(obj);\n    }\n\n    void ClientComputePassEncoderReference(WGPUComputePassEncoder cObj) {\n        reinterpret_cast<ComputePassEncoder*>(cObj)->Reference();\n    }\n\n\n    WGPUBindGroupLayout ClientComputePipelineGetBindGroupLayout(WGPUComputePipeline cSelf, uint32_t groupIndex) {\n        auto self = reinterpret_cast<ComputePipeline*>(cSelf);\n        ComputePipelineGetBindGroupLayoutCmd cmd;\n\n        cmd.self = cSelf;\n\n        auto* returnObject = self->GetClient()->Make<BindGroupLayout>();\n        cmd.result = returnObject->GetWireHandle();\n\n        \n        cmd.groupIndex = groupIndex;\n\n        self->GetClient()->SerializeCommand(cmd);\n\n        return ToAPI(returnObject);\n    }\n\n    void ClientComputePipelineSetLabel(WGPUComputePipeline cSelf, char const * label) {\n        auto self = reinterpret_cast<ComputePipeline*>(cSelf);\n        ComputePipelineSetLabelCmd cmd;\n\n        cmd.self = cSelf;\n\n\n        \n        cmd.label = label;\n\n        self->GetClient()->SerializeCommand(cmd);\n\n    }\n\n    void ClientComputePipelineRelease(WGPUComputePipeline cObj) {\n        ComputePipeline* obj = reinterpret_cast<ComputePipeline*>(cObj);\n\n        if (!obj->Release()) {\n            return;\n        }\n\n        DestroyObjectCmd cmd;\n        cmd.objectType = ObjectType::ComputePipeline;\n        cmd.objectId = obj->GetWireId();\n\n        Client* client = obj->GetClient();\n        client->SerializeCommand(cmd);\n        client->Free(obj);\n    }\n\n    void ClientComputePipelineReference(WGPUComputePipeline cObj) {\n        reinterpret_cast<ComputePipeline*>(cObj)->Reference();\n    }\n\n\n    WGPUBindGroup ClientDeviceCreateBindGroup(WGPUDevice cSelf, WGPUBindGroupDescriptor const * descriptor) {\n        auto self = reinterpret_cast<Device*>(cSelf);\n        DeviceCreateBindGroupCmd cmd;\n\n        cmd.self = cSelf;\n\n        auto* returnObject = self->GetClient()->Make<BindGroup>();\n        cmd.result = returnObject->GetWireHandle();\n\n        \n        cmd.descriptor = descriptor;\n\n        self->GetClient()->SerializeCommand(cmd);\n\n        return ToAPI(returnObject);\n    }\n\n    WGPUBindGroupLayout ClientDeviceCreateBindGroupLayout(WGPUDevice cSelf, WGPUBindGroupLayoutDescriptor const * descriptor) {\n        auto self = reinterpret_cast<Device*>(cSelf);\n        DeviceCreateBindGroupLayoutCmd cmd;\n\n        cmd.self = cSelf;\n\n        auto* returnObject = self->GetClient()->Make<BindGroupLayout>();\n        cmd.result = returnObject->GetWireHandle();\n\n        \n        cmd.descriptor = descriptor;\n\n        self->GetClient()->SerializeCommand(cmd);\n\n        return ToAPI(returnObject);\n    }\n\n    static\n    WGPUBuffer ClientDeviceCreateBuffer(WGPUDevice cSelf, WGPUBufferDescriptor const * descriptor) {\n        auto self = reinterpret_cast<Device*>(cSelf);\n        return self->CreateBuffer( descriptor);\n    }\n\n    WGPUCommandEncoder ClientDeviceCreateCommandEncoder(WGPUDevice cSelf, WGPUCommandEncoderDescriptor const * descriptor) {\n        auto self = reinterpret_cast<Device*>(cSelf);\n        DeviceCreateCommandEncoderCmd cmd;\n\n        cmd.self = cSelf;\n\n        auto* returnObject = self->GetClient()->Make<CommandEncoder>();\n        cmd.result = returnObject->GetWireHandle();\n\n        \n        cmd.descriptor = descriptor;\n\n        self->GetClient()->SerializeCommand(cmd);\n\n        return ToAPI(returnObject);\n    }\n\n    WGPUComputePipeline ClientDeviceCreateComputePipeline(WGPUDevice cSelf, WGPUComputePipelineDescriptor const * descriptor) {\n        auto self = reinterpret_cast<Device*>(cSelf);\n        DeviceCreateComputePipelineCmd cmd;\n\n        cmd.self = cSelf;\n\n        auto* returnObject = self->GetClient()->Make<ComputePipeline>();\n        cmd.result = returnObject->GetWireHandle();\n\n        \n        cmd.descriptor = descriptor;\n\n        self->GetClient()->SerializeCommand(cmd);\n\n        return ToAPI(returnObject);\n    }\n\n    static\n    void ClientDeviceCreateComputePipelineAsync(WGPUDevice cSelf, WGPUComputePipelineDescriptor const * descriptor, WGPUCreateComputePipelineAsyncCallback callback, void * userdata) {\n        auto self = reinterpret_cast<Device*>(cSelf);\n        return self->CreateComputePipelineAsync( descriptor,  callback,  userdata);\n    }\n\n    static\n    WGPUBuffer ClientDeviceCreateErrorBuffer(WGPUDevice cSelf) {\n        auto self = reinterpret_cast<Device*>(cSelf);\n        return self->CreateErrorBuffer();\n    }\n\n    WGPUExternalTexture ClientDeviceCreateErrorExternalTexture(WGPUDevice cSelf) {\n        auto self = reinterpret_cast<Device*>(cSelf);\n        DeviceCreateErrorExternalTextureCmd cmd;\n\n        cmd.self = cSelf;\n\n        auto* returnObject = self->GetClient()->Make<ExternalTexture>();\n        cmd.result = returnObject->GetWireHandle();\n\n\n        self->GetClient()->SerializeCommand(cmd);\n\n        return ToAPI(returnObject);\n    }\n\n    static\n    WGPUTexture ClientDeviceCreateErrorTexture(WGPUDevice cSelf, WGPUTextureDescriptor const * descriptor) {\n        auto self = reinterpret_cast<Device*>(cSelf);\n        return self->CreateErrorTexture( descriptor);\n    }\n\n    WGPUExternalTexture ClientDeviceCreateExternalTexture(WGPUDevice cSelf, WGPUExternalTextureDescriptor const * externalTextureDescriptor) {\n        auto self = reinterpret_cast<Device*>(cSelf);\n        DeviceCreateExternalTextureCmd cmd;\n\n        cmd.self = cSelf;\n\n        auto* returnObject = self->GetClient()->Make<ExternalTexture>();\n        cmd.result = returnObject->GetWireHandle();\n\n        \n        cmd.externalTextureDescriptor = externalTextureDescriptor;\n\n        self->GetClient()->SerializeCommand(cmd);\n\n        return ToAPI(returnObject);\n    }\n\n    WGPUPipelineLayout ClientDeviceCreatePipelineLayout(WGPUDevice cSelf, WGPUPipelineLayoutDescriptor const * descriptor) {\n        auto self = reinterpret_cast<Device*>(cSelf);\n        DeviceCreatePipelineLayoutCmd cmd;\n\n        cmd.self = cSelf;\n\n        auto* returnObject = self->GetClient()->Make<PipelineLayout>();\n        cmd.result = returnObject->GetWireHandle();\n\n        \n        cmd.descriptor = descriptor;\n\n        self->GetClient()->SerializeCommand(cmd);\n\n        return ToAPI(returnObject);\n    }\n\n    static\n    WGPUQuerySet ClientDeviceCreateQuerySet(WGPUDevice cSelf, WGPUQuerySetDescriptor const * descriptor) {\n        auto self = reinterpret_cast<Device*>(cSelf);\n        return self->CreateQuerySet( descriptor);\n    }\n\n    WGPURenderBundleEncoder ClientDeviceCreateRenderBundleEncoder(WGPUDevice cSelf, WGPURenderBundleEncoderDescriptor const * descriptor) {\n        auto self = reinterpret_cast<Device*>(cSelf);\n        DeviceCreateRenderBundleEncoderCmd cmd;\n\n        cmd.self = cSelf;\n\n        auto* returnObject = self->GetClient()->Make<RenderBundleEncoder>();\n        cmd.result = returnObject->GetWireHandle();\n\n        \n        cmd.descriptor = descriptor;\n\n        self->GetClient()->SerializeCommand(cmd);\n\n        return ToAPI(returnObject);\n    }\n\n    WGPURenderPipeline ClientDeviceCreateRenderPipeline(WGPUDevice cSelf, WGPURenderPipelineDescriptor const * descriptor) {\n        auto self = reinterpret_cast<Device*>(cSelf);\n        DeviceCreateRenderPipelineCmd cmd;\n\n        cmd.self = cSelf;\n\n        auto* returnObject = self->GetClient()->Make<RenderPipeline>();\n        cmd.result = returnObject->GetWireHandle();\n\n        \n        cmd.descriptor = descriptor;\n\n        self->GetClient()->SerializeCommand(cmd);\n\n        return ToAPI(returnObject);\n    }\n\n    static\n    void ClientDeviceCreateRenderPipelineAsync(WGPUDevice cSelf, WGPURenderPipelineDescriptor const * descriptor, WGPUCreateRenderPipelineAsyncCallback callback, void * userdata) {\n        auto self = reinterpret_cast<Device*>(cSelf);\n        return self->CreateRenderPipelineAsync( descriptor,  callback,  userdata);\n    }\n\n    WGPUSampler ClientDeviceCreateSampler(WGPUDevice cSelf, WGPUSamplerDescriptor const * descriptor) {\n        auto self = reinterpret_cast<Device*>(cSelf);\n        DeviceCreateSamplerCmd cmd;\n\n        cmd.self = cSelf;\n\n        auto* returnObject = self->GetClient()->Make<Sampler>();\n        cmd.result = returnObject->GetWireHandle();\n\n        \n        cmd.descriptor = descriptor;\n\n        self->GetClient()->SerializeCommand(cmd);\n\n        return ToAPI(returnObject);\n    }\n\n    WGPUShaderModule ClientDeviceCreateShaderModule(WGPUDevice cSelf, WGPUShaderModuleDescriptor const * descriptor) {\n        auto self = reinterpret_cast<Device*>(cSelf);\n        DeviceCreateShaderModuleCmd cmd;\n\n        cmd.self = cSelf;\n\n        auto* returnObject = self->GetClient()->Make<ShaderModule>();\n        cmd.result = returnObject->GetWireHandle();\n\n        \n        cmd.descriptor = descriptor;\n\n        self->GetClient()->SerializeCommand(cmd);\n\n        return ToAPI(returnObject);\n    }\n\n    WGPUSwapChain ClientDeviceCreateSwapChain(WGPUDevice cSelf, WGPUSurface surface, WGPUSwapChainDescriptor const * descriptor) {\n        auto self = reinterpret_cast<Device*>(cSelf);\n        DeviceCreateSwapChainCmd cmd;\n\n        cmd.self = cSelf;\n\n        auto* returnObject = self->GetClient()->Make<SwapChain>();\n        cmd.result = returnObject->GetWireHandle();\n\n        \n        cmd.surface = surface;\n        \n        cmd.descriptor = descriptor;\n\n        self->GetClient()->SerializeCommand(cmd);\n\n        return ToAPI(returnObject);\n    }\n\n    static\n    WGPUTexture ClientDeviceCreateTexture(WGPUDevice cSelf, WGPUTextureDescriptor const * descriptor) {\n        auto self = reinterpret_cast<Device*>(cSelf);\n        return self->CreateTexture( descriptor);\n    }\n\n    void ClientDeviceDestroy(WGPUDevice cSelf) {\n        auto self = reinterpret_cast<Device*>(cSelf);\n        DeviceDestroyCmd cmd;\n\n        cmd.self = cSelf;\n\n\n\n        self->GetClient()->SerializeCommand(cmd);\n\n    }\n\n    static\n    size_t ClientDeviceEnumerateFeatures(WGPUDevice cSelf, WGPUFeatureName * features) {\n        auto self = reinterpret_cast<Device*>(cSelf);\n        return self->EnumerateFeatures( features);\n    }\n\n    static\n    bool ClientDeviceGetLimits(WGPUDevice cSelf, WGPUSupportedLimits * limits) {\n        auto self = reinterpret_cast<Device*>(cSelf);\n        return self->GetLimits( limits);\n    }\n\n    static\n    WGPUQueue ClientDeviceGetQueue(WGPUDevice cSelf) {\n        auto self = reinterpret_cast<Device*>(cSelf);\n        return self->GetQueue();\n    }\n\n    static\n    bool ClientDeviceHasFeature(WGPUDevice cSelf, WGPUFeatureName feature) {\n        auto self = reinterpret_cast<Device*>(cSelf);\n        return self->HasFeature( feature);\n    }\n\n    static\n    void ClientDeviceInjectError(WGPUDevice cSelf, WGPUErrorType type, char const * message) {\n        auto self = reinterpret_cast<Device*>(cSelf);\n        return self->InjectError( type,  message);\n    }\n\n    void ClientDeviceLoseForTesting(WGPUDevice cSelf) {\n        auto self = reinterpret_cast<Device*>(cSelf);\n        DeviceLoseForTestingCmd cmd;\n\n        cmd.self = cSelf;\n\n\n\n        self->GetClient()->SerializeCommand(cmd);\n\n    }\n\n    static\n    bool ClientDevicePopErrorScope(WGPUDevice cSelf, WGPUErrorCallback callback, void * userdata) {\n        auto self = reinterpret_cast<Device*>(cSelf);\n        return self->PopErrorScope( callback,  userdata);\n    }\n\n    void ClientDevicePushErrorScope(WGPUDevice cSelf, WGPUErrorFilter filter) {\n        auto self = reinterpret_cast<Device*>(cSelf);\n        DevicePushErrorScopeCmd cmd;\n\n        cmd.self = cSelf;\n\n\n        \n        cmd.filter = filter;\n\n        self->GetClient()->SerializeCommand(cmd);\n\n    }\n\n    static\n    void ClientDeviceSetDeviceLostCallback(WGPUDevice cSelf, WGPUDeviceLostCallback callback, void * userdata) {\n        auto self = reinterpret_cast<Device*>(cSelf);\n        return self->SetDeviceLostCallback( callback,  userdata);\n    }\n\n    void ClientDeviceSetLabel(WGPUDevice cSelf, char const * label) {\n        auto self = reinterpret_cast<Device*>(cSelf);\n        DeviceSetLabelCmd cmd;\n\n        cmd.self = cSelf;\n\n\n        \n        cmd.label = label;\n\n        self->GetClient()->SerializeCommand(cmd);\n\n    }\n\n    static\n    void ClientDeviceSetLoggingCallback(WGPUDevice cSelf, WGPULoggingCallback callback, void * userdata) {\n        auto self = reinterpret_cast<Device*>(cSelf);\n        return self->SetLoggingCallback( callback,  userdata);\n    }\n\n    static\n    void ClientDeviceSetUncapturedErrorCallback(WGPUDevice cSelf, WGPUErrorCallback callback, void * userdata) {\n        auto self = reinterpret_cast<Device*>(cSelf);\n        return self->SetUncapturedErrorCallback( callback,  userdata);\n    }\n\n    void ClientDeviceTick(WGPUDevice cSelf) {\n        auto self = reinterpret_cast<Device*>(cSelf);\n        DeviceTickCmd cmd;\n\n        cmd.self = cSelf;\n\n\n\n        self->GetClient()->SerializeCommand(cmd);\n\n    }\n\n    void ClientDeviceRelease(WGPUDevice cObj) {\n        Device* obj = reinterpret_cast<Device*>(cObj);\n\n        if (!obj->Release()) {\n            return;\n        }\n\n        DestroyObjectCmd cmd;\n        cmd.objectType = ObjectType::Device;\n        cmd.objectId = obj->GetWireId();\n\n        Client* client = obj->GetClient();\n        client->SerializeCommand(cmd);\n        client->Free(obj);\n    }\n\n    void ClientDeviceReference(WGPUDevice cObj) {\n        reinterpret_cast<Device*>(cObj)->Reference();\n    }\n\n\n    void ClientExternalTextureDestroy(WGPUExternalTexture cSelf) {\n        auto self = reinterpret_cast<ExternalTexture*>(cSelf);\n        ExternalTextureDestroyCmd cmd;\n\n        cmd.self = cSelf;\n\n\n\n        self->GetClient()->SerializeCommand(cmd);\n\n    }\n\n    void ClientExternalTextureSetLabel(WGPUExternalTexture cSelf, char const * label) {\n        auto self = reinterpret_cast<ExternalTexture*>(cSelf);\n        ExternalTextureSetLabelCmd cmd;\n\n        cmd.self = cSelf;\n\n\n        \n        cmd.label = label;\n\n        self->GetClient()->SerializeCommand(cmd);\n\n    }\n\n    void ClientExternalTextureRelease(WGPUExternalTexture cObj) {\n        ExternalTexture* obj = reinterpret_cast<ExternalTexture*>(cObj);\n\n        if (!obj->Release()) {\n            return;\n        }\n\n        DestroyObjectCmd cmd;\n        cmd.objectType = ObjectType::ExternalTexture;\n        cmd.objectId = obj->GetWireId();\n\n        Client* client = obj->GetClient();\n        client->SerializeCommand(cmd);\n        client->Free(obj);\n    }\n\n    void ClientExternalTextureReference(WGPUExternalTexture cObj) {\n        reinterpret_cast<ExternalTexture*>(cObj)->Reference();\n    }\n\n\n    WGPUSurface ClientInstanceCreateSurface(WGPUInstance cSelf, WGPUSurfaceDescriptor const * descriptor) {\n        auto self = reinterpret_cast<Instance*>(cSelf);\n        InstanceCreateSurfaceCmd cmd;\n\n        cmd.self = cSelf;\n\n        auto* returnObject = self->GetClient()->Make<Surface>();\n        cmd.result = returnObject->GetWireHandle();\n\n        \n        cmd.descriptor = descriptor;\n\n        self->GetClient()->SerializeCommand(cmd);\n\n        return ToAPI(returnObject);\n    }\n\n    static\n    void ClientInstanceRequestAdapter(WGPUInstance cSelf, WGPURequestAdapterOptions const * options, WGPURequestAdapterCallback callback, void * userdata) {\n        auto self = reinterpret_cast<Instance*>(cSelf);\n        return self->RequestAdapter( options,  callback,  userdata);\n    }\n\n    void ClientInstanceRelease(WGPUInstance cObj) {\n        Instance* obj = reinterpret_cast<Instance*>(cObj);\n\n        if (!obj->Release()) {\n            return;\n        }\n\n        DestroyObjectCmd cmd;\n        cmd.objectType = ObjectType::Instance;\n        cmd.objectId = obj->GetWireId();\n\n        Client* client = obj->GetClient();\n        client->SerializeCommand(cmd);\n        client->Free(obj);\n    }\n\n    void ClientInstanceReference(WGPUInstance cObj) {\n        reinterpret_cast<Instance*>(cObj)->Reference();\n    }\n\n\n    void ClientPipelineLayoutSetLabel(WGPUPipelineLayout cSelf, char const * label) {\n        auto self = reinterpret_cast<PipelineLayout*>(cSelf);\n        PipelineLayoutSetLabelCmd cmd;\n\n        cmd.self = cSelf;\n\n\n        \n        cmd.label = label;\n\n        self->GetClient()->SerializeCommand(cmd);\n\n    }\n\n    void ClientPipelineLayoutRelease(WGPUPipelineLayout cObj) {\n        PipelineLayout* obj = reinterpret_cast<PipelineLayout*>(cObj);\n\n        if (!obj->Release()) {\n            return;\n        }\n\n        DestroyObjectCmd cmd;\n        cmd.objectType = ObjectType::PipelineLayout;\n        cmd.objectId = obj->GetWireId();\n\n        Client* client = obj->GetClient();\n        client->SerializeCommand(cmd);\n        client->Free(obj);\n    }\n\n    void ClientPipelineLayoutReference(WGPUPipelineLayout cObj) {\n        reinterpret_cast<PipelineLayout*>(cObj)->Reference();\n    }\n\n\n    void ClientQuerySetDestroy(WGPUQuerySet cSelf) {\n        auto self = reinterpret_cast<QuerySet*>(cSelf);\n        QuerySetDestroyCmd cmd;\n\n        cmd.self = cSelf;\n\n\n\n        self->GetClient()->SerializeCommand(cmd);\n\n    }\n\n    static\n    uint32_t ClientQuerySetGetCount(WGPUQuerySet cSelf) {\n        auto self = reinterpret_cast<QuerySet*>(cSelf);\n        return self->GetCount();\n    }\n\n    static\n    WGPUQueryType ClientQuerySetGetType(WGPUQuerySet cSelf) {\n        auto self = reinterpret_cast<QuerySet*>(cSelf);\n        return self->GetType();\n    }\n\n    void ClientQuerySetSetLabel(WGPUQuerySet cSelf, char const * label) {\n        auto self = reinterpret_cast<QuerySet*>(cSelf);\n        QuerySetSetLabelCmd cmd;\n\n        cmd.self = cSelf;\n\n\n        \n        cmd.label = label;\n\n        self->GetClient()->SerializeCommand(cmd);\n\n    }\n\n    void ClientQuerySetRelease(WGPUQuerySet cObj) {\n        QuerySet* obj = reinterpret_cast<QuerySet*>(cObj);\n\n        if (!obj->Release()) {\n            return;\n        }\n\n        DestroyObjectCmd cmd;\n        cmd.objectType = ObjectType::QuerySet;\n        cmd.objectId = obj->GetWireId();\n\n        Client* client = obj->GetClient();\n        client->SerializeCommand(cmd);\n        client->Free(obj);\n    }\n\n    void ClientQuerySetReference(WGPUQuerySet cObj) {\n        reinterpret_cast<QuerySet*>(cObj)->Reference();\n    }\n\n\n    void ClientQueueCopyTextureForBrowser(WGPUQueue cSelf, WGPUImageCopyTexture const * source, WGPUImageCopyTexture const * destination, WGPUExtent3D const * copySize, WGPUCopyTextureForBrowserOptions const * options) {\n        auto self = reinterpret_cast<Queue*>(cSelf);\n        QueueCopyTextureForBrowserCmd cmd;\n\n        cmd.self = cSelf;\n\n\n        \n        cmd.source = source;\n        \n        cmd.destination = destination;\n        \n        cmd.copySize = copySize;\n        \n        cmd.options = options;\n\n        self->GetClient()->SerializeCommand(cmd);\n\n    }\n\n    static\n    void ClientQueueOnSubmittedWorkDone(WGPUQueue cSelf, uint64_t signalValue, WGPUQueueWorkDoneCallback callback, void * userdata) {\n        auto self = reinterpret_cast<Queue*>(cSelf);\n        return self->OnSubmittedWorkDone( signalValue,  callback,  userdata);\n    }\n\n    void ClientQueueSetLabel(WGPUQueue cSelf, char const * label) {\n        auto self = reinterpret_cast<Queue*>(cSelf);\n        QueueSetLabelCmd cmd;\n\n        cmd.self = cSelf;\n\n\n        \n        cmd.label = label;\n\n        self->GetClient()->SerializeCommand(cmd);\n\n    }\n\n    void ClientQueueSubmit(WGPUQueue cSelf, uint32_t commandCount, WGPUCommandBuffer const * commands) {\n        auto self = reinterpret_cast<Queue*>(cSelf);\n        QueueSubmitCmd cmd;\n\n        cmd.self = cSelf;\n\n\n        \n        cmd.commandCount = commandCount;\n        \n        cmd.commands = commands;\n\n        self->GetClient()->SerializeCommand(cmd);\n\n    }\n\n    static\n    void ClientQueueWriteBuffer(WGPUQueue cSelf, WGPUBuffer buffer, uint64_t bufferOffset, void const * data, size_t size) {\n        auto self = reinterpret_cast<Queue*>(cSelf);\n        return self->WriteBuffer( buffer,  bufferOffset,  data,  size);\n    }\n\n    static\n    void ClientQueueWriteTexture(WGPUQueue cSelf, WGPUImageCopyTexture const * destination, void const * data, size_t dataSize, WGPUTextureDataLayout const * dataLayout, WGPUExtent3D const * writeSize) {\n        auto self = reinterpret_cast<Queue*>(cSelf);\n        return self->WriteTexture( destination,  data,  dataSize,  dataLayout,  writeSize);\n    }\n\n    void ClientQueueRelease(WGPUQueue cObj) {\n        Queue* obj = reinterpret_cast<Queue*>(cObj);\n\n        if (!obj->Release()) {\n            return;\n        }\n\n        DestroyObjectCmd cmd;\n        cmd.objectType = ObjectType::Queue;\n        cmd.objectId = obj->GetWireId();\n\n        Client* client = obj->GetClient();\n        client->SerializeCommand(cmd);\n        client->Free(obj);\n    }\n\n    void ClientQueueReference(WGPUQueue cObj) {\n        reinterpret_cast<Queue*>(cObj)->Reference();\n    }\n\n\n    void ClientRenderBundleRelease(WGPURenderBundle cObj) {\n        RenderBundle* obj = reinterpret_cast<RenderBundle*>(cObj);\n\n        if (!obj->Release()) {\n            return;\n        }\n\n        DestroyObjectCmd cmd;\n        cmd.objectType = ObjectType::RenderBundle;\n        cmd.objectId = obj->GetWireId();\n\n        Client* client = obj->GetClient();\n        client->SerializeCommand(cmd);\n        client->Free(obj);\n    }\n\n    void ClientRenderBundleReference(WGPURenderBundle cObj) {\n        reinterpret_cast<RenderBundle*>(cObj)->Reference();\n    }\n\n\n    void ClientRenderBundleEncoderDraw(WGPURenderBundleEncoder cSelf, uint32_t vertexCount, uint32_t instanceCount, uint32_t firstVertex, uint32_t firstInstance) {\n        auto self = reinterpret_cast<RenderBundleEncoder*>(cSelf);\n        RenderBundleEncoderDrawCmd cmd;\n\n        cmd.self = cSelf;\n\n\n        \n        cmd.vertexCount = vertexCount;\n        \n        cmd.instanceCount = instanceCount;\n        \n        cmd.firstVertex = firstVertex;\n        \n        cmd.firstInstance = firstInstance;\n\n        self->GetClient()->SerializeCommand(cmd);\n\n    }\n\n    void ClientRenderBundleEncoderDrawIndexed(WGPURenderBundleEncoder cSelf, uint32_t indexCount, uint32_t instanceCount, uint32_t firstIndex, int32_t baseVertex, uint32_t firstInstance) {\n        auto self = reinterpret_cast<RenderBundleEncoder*>(cSelf);\n        RenderBundleEncoderDrawIndexedCmd cmd;\n\n        cmd.self = cSelf;\n\n\n        \n        cmd.indexCount = indexCount;\n        \n        cmd.instanceCount = instanceCount;\n        \n        cmd.firstIndex = firstIndex;\n        \n        cmd.baseVertex = baseVertex;\n        \n        cmd.firstInstance = firstInstance;\n\n        self->GetClient()->SerializeCommand(cmd);\n\n    }\n\n    void ClientRenderBundleEncoderDrawIndexedIndirect(WGPURenderBundleEncoder cSelf, WGPUBuffer indirectBuffer, uint64_t indirectOffset) {\n        auto self = reinterpret_cast<RenderBundleEncoder*>(cSelf);\n        RenderBundleEncoderDrawIndexedIndirectCmd cmd;\n\n        cmd.self = cSelf;\n\n\n        \n        cmd.indirectBuffer = indirectBuffer;\n        \n        cmd.indirectOffset = indirectOffset;\n\n        self->GetClient()->SerializeCommand(cmd);\n\n    }\n\n    void ClientRenderBundleEncoderDrawIndirect(WGPURenderBundleEncoder cSelf, WGPUBuffer indirectBuffer, uint64_t indirectOffset) {\n        auto self = reinterpret_cast<RenderBundleEncoder*>(cSelf);\n        RenderBundleEncoderDrawIndirectCmd cmd;\n\n        cmd.self = cSelf;\n\n\n        \n        cmd.indirectBuffer = indirectBuffer;\n        \n        cmd.indirectOffset = indirectOffset;\n\n        self->GetClient()->SerializeCommand(cmd);\n\n    }\n\n    WGPURenderBundle ClientRenderBundleEncoderFinish(WGPURenderBundleEncoder cSelf, WGPURenderBundleDescriptor const * descriptor) {\n        auto self = reinterpret_cast<RenderBundleEncoder*>(cSelf);\n        RenderBundleEncoderFinishCmd cmd;\n\n        cmd.self = cSelf;\n\n        auto* returnObject = self->GetClient()->Make<RenderBundle>();\n        cmd.result = returnObject->GetWireHandle();\n\n        \n        cmd.descriptor = descriptor;\n\n        self->GetClient()->SerializeCommand(cmd);\n\n        return ToAPI(returnObject);\n    }\n\n    void ClientRenderBundleEncoderInsertDebugMarker(WGPURenderBundleEncoder cSelf, char const * markerLabel) {\n        auto self = reinterpret_cast<RenderBundleEncoder*>(cSelf);\n        RenderBundleEncoderInsertDebugMarkerCmd cmd;\n\n        cmd.self = cSelf;\n\n\n        \n        cmd.markerLabel = markerLabel;\n\n        self->GetClient()->SerializeCommand(cmd);\n\n    }\n\n    void ClientRenderBundleEncoderPopDebugGroup(WGPURenderBundleEncoder cSelf) {\n        auto self = reinterpret_cast<RenderBundleEncoder*>(cSelf);\n        RenderBundleEncoderPopDebugGroupCmd cmd;\n\n        cmd.self = cSelf;\n\n\n\n        self->GetClient()->SerializeCommand(cmd);\n\n    }\n\n    void ClientRenderBundleEncoderPushDebugGroup(WGPURenderBundleEncoder cSelf, char const * groupLabel) {\n        auto self = reinterpret_cast<RenderBundleEncoder*>(cSelf);\n        RenderBundleEncoderPushDebugGroupCmd cmd;\n\n        cmd.self = cSelf;\n\n\n        \n        cmd.groupLabel = groupLabel;\n\n        self->GetClient()->SerializeCommand(cmd);\n\n    }\n\n    void ClientRenderBundleEncoderSetBindGroup(WGPURenderBundleEncoder cSelf, uint32_t groupIndex, WGPUBindGroup group, uint32_t dynamicOffsetCount, uint32_t const * dynamicOffsets) {\n        auto self = reinterpret_cast<RenderBundleEncoder*>(cSelf);\n        RenderBundleEncoderSetBindGroupCmd cmd;\n\n        cmd.self = cSelf;\n\n\n        \n        cmd.groupIndex = groupIndex;\n        \n        cmd.group = group;\n        \n        cmd.dynamicOffsetCount = dynamicOffsetCount;\n        \n        cmd.dynamicOffsets = dynamicOffsets;\n\n        self->GetClient()->SerializeCommand(cmd);\n\n    }\n\n    void ClientRenderBundleEncoderSetIndexBuffer(WGPURenderBundleEncoder cSelf, WGPUBuffer buffer, WGPUIndexFormat format, uint64_t offset, uint64_t size) {\n        auto self = reinterpret_cast<RenderBundleEncoder*>(cSelf);\n        RenderBundleEncoderSetIndexBufferCmd cmd;\n\n        cmd.self = cSelf;\n\n\n        \n        cmd.buffer = buffer;\n        \n        cmd.format = format;\n        \n        cmd.offset = offset;\n        \n        cmd.size = size;\n\n        self->GetClient()->SerializeCommand(cmd);\n\n    }\n\n    void ClientRenderBundleEncoderSetLabel(WGPURenderBundleEncoder cSelf, char const * label) {\n        auto self = reinterpret_cast<RenderBundleEncoder*>(cSelf);\n        RenderBundleEncoderSetLabelCmd cmd;\n\n        cmd.self = cSelf;\n\n\n        \n        cmd.label = label;\n\n        self->GetClient()->SerializeCommand(cmd);\n\n    }\n\n    void ClientRenderBundleEncoderSetPipeline(WGPURenderBundleEncoder cSelf, WGPURenderPipeline pipeline) {\n        auto self = reinterpret_cast<RenderBundleEncoder*>(cSelf);\n        RenderBundleEncoderSetPipelineCmd cmd;\n\n        cmd.self = cSelf;\n\n\n        \n        cmd.pipeline = pipeline;\n\n        self->GetClient()->SerializeCommand(cmd);\n\n    }\n\n    void ClientRenderBundleEncoderSetVertexBuffer(WGPURenderBundleEncoder cSelf, uint32_t slot, WGPUBuffer buffer, uint64_t offset, uint64_t size) {\n        auto self = reinterpret_cast<RenderBundleEncoder*>(cSelf);\n        RenderBundleEncoderSetVertexBufferCmd cmd;\n\n        cmd.self = cSelf;\n\n\n        \n        cmd.slot = slot;\n        \n        cmd.buffer = buffer;\n        \n        cmd.offset = offset;\n        \n        cmd.size = size;\n\n        self->GetClient()->SerializeCommand(cmd);\n\n    }\n\n    void ClientRenderBundleEncoderRelease(WGPURenderBundleEncoder cObj) {\n        RenderBundleEncoder* obj = reinterpret_cast<RenderBundleEncoder*>(cObj);\n\n        if (!obj->Release()) {\n            return;\n        }\n\n        DestroyObjectCmd cmd;\n        cmd.objectType = ObjectType::RenderBundleEncoder;\n        cmd.objectId = obj->GetWireId();\n\n        Client* client = obj->GetClient();\n        client->SerializeCommand(cmd);\n        client->Free(obj);\n    }\n\n    void ClientRenderBundleEncoderReference(WGPURenderBundleEncoder cObj) {\n        reinterpret_cast<RenderBundleEncoder*>(cObj)->Reference();\n    }\n\n\n    void ClientRenderPassEncoderBeginOcclusionQuery(WGPURenderPassEncoder cSelf, uint32_t queryIndex) {\n        auto self = reinterpret_cast<RenderPassEncoder*>(cSelf);\n        RenderPassEncoderBeginOcclusionQueryCmd cmd;\n\n        cmd.self = cSelf;\n\n\n        \n        cmd.queryIndex = queryIndex;\n\n        self->GetClient()->SerializeCommand(cmd);\n\n    }\n\n    void ClientRenderPassEncoderDraw(WGPURenderPassEncoder cSelf, uint32_t vertexCount, uint32_t instanceCount, uint32_t firstVertex, uint32_t firstInstance) {\n        auto self = reinterpret_cast<RenderPassEncoder*>(cSelf);\n        RenderPassEncoderDrawCmd cmd;\n\n        cmd.self = cSelf;\n\n\n        \n        cmd.vertexCount = vertexCount;\n        \n        cmd.instanceCount = instanceCount;\n        \n        cmd.firstVertex = firstVertex;\n        \n        cmd.firstInstance = firstInstance;\n\n        self->GetClient()->SerializeCommand(cmd);\n\n    }\n\n    void ClientRenderPassEncoderDrawIndexed(WGPURenderPassEncoder cSelf, uint32_t indexCount, uint32_t instanceCount, uint32_t firstIndex, int32_t baseVertex, uint32_t firstInstance) {\n        auto self = reinterpret_cast<RenderPassEncoder*>(cSelf);\n        RenderPassEncoderDrawIndexedCmd cmd;\n\n        cmd.self = cSelf;\n\n\n        \n        cmd.indexCount = indexCount;\n        \n        cmd.instanceCount = instanceCount;\n        \n        cmd.firstIndex = firstIndex;\n        \n        cmd.baseVertex = baseVertex;\n        \n        cmd.firstInstance = firstInstance;\n\n        self->GetClient()->SerializeCommand(cmd);\n\n    }\n\n    void ClientRenderPassEncoderDrawIndexedIndirect(WGPURenderPassEncoder cSelf, WGPUBuffer indirectBuffer, uint64_t indirectOffset) {\n        auto self = reinterpret_cast<RenderPassEncoder*>(cSelf);\n        RenderPassEncoderDrawIndexedIndirectCmd cmd;\n\n        cmd.self = cSelf;\n\n\n        \n        cmd.indirectBuffer = indirectBuffer;\n        \n        cmd.indirectOffset = indirectOffset;\n\n        self->GetClient()->SerializeCommand(cmd);\n\n    }\n\n    void ClientRenderPassEncoderDrawIndirect(WGPURenderPassEncoder cSelf, WGPUBuffer indirectBuffer, uint64_t indirectOffset) {\n        auto self = reinterpret_cast<RenderPassEncoder*>(cSelf);\n        RenderPassEncoderDrawIndirectCmd cmd;\n\n        cmd.self = cSelf;\n\n\n        \n        cmd.indirectBuffer = indirectBuffer;\n        \n        cmd.indirectOffset = indirectOffset;\n\n        self->GetClient()->SerializeCommand(cmd);\n\n    }\n\n    void ClientRenderPassEncoderEnd(WGPURenderPassEncoder cSelf) {\n        auto self = reinterpret_cast<RenderPassEncoder*>(cSelf);\n        RenderPassEncoderEndCmd cmd;\n\n        cmd.self = cSelf;\n\n\n\n        self->GetClient()->SerializeCommand(cmd);\n\n    }\n\n    void ClientRenderPassEncoderEndOcclusionQuery(WGPURenderPassEncoder cSelf) {\n        auto self = reinterpret_cast<RenderPassEncoder*>(cSelf);\n        RenderPassEncoderEndOcclusionQueryCmd cmd;\n\n        cmd.self = cSelf;\n\n\n\n        self->GetClient()->SerializeCommand(cmd);\n\n    }\n\n    void ClientRenderPassEncoderEndPass(WGPURenderPassEncoder cSelf) {\n        auto self = reinterpret_cast<RenderPassEncoder*>(cSelf);\n        RenderPassEncoderEndPassCmd cmd;\n\n        cmd.self = cSelf;\n\n\n\n        self->GetClient()->SerializeCommand(cmd);\n\n    }\n\n    void ClientRenderPassEncoderExecuteBundles(WGPURenderPassEncoder cSelf, uint32_t bundlesCount, WGPURenderBundle const * bundles) {\n        auto self = reinterpret_cast<RenderPassEncoder*>(cSelf);\n        RenderPassEncoderExecuteBundlesCmd cmd;\n\n        cmd.self = cSelf;\n\n\n        \n        cmd.bundlesCount = bundlesCount;\n        \n        cmd.bundles = bundles;\n\n        self->GetClient()->SerializeCommand(cmd);\n\n    }\n\n    void ClientRenderPassEncoderInsertDebugMarker(WGPURenderPassEncoder cSelf, char const * markerLabel) {\n        auto self = reinterpret_cast<RenderPassEncoder*>(cSelf);\n        RenderPassEncoderInsertDebugMarkerCmd cmd;\n\n        cmd.self = cSelf;\n\n\n        \n        cmd.markerLabel = markerLabel;\n\n        self->GetClient()->SerializeCommand(cmd);\n\n    }\n\n    void ClientRenderPassEncoderPopDebugGroup(WGPURenderPassEncoder cSelf) {\n        auto self = reinterpret_cast<RenderPassEncoder*>(cSelf);\n        RenderPassEncoderPopDebugGroupCmd cmd;\n\n        cmd.self = cSelf;\n\n\n\n        self->GetClient()->SerializeCommand(cmd);\n\n    }\n\n    void ClientRenderPassEncoderPushDebugGroup(WGPURenderPassEncoder cSelf, char const * groupLabel) {\n        auto self = reinterpret_cast<RenderPassEncoder*>(cSelf);\n        RenderPassEncoderPushDebugGroupCmd cmd;\n\n        cmd.self = cSelf;\n\n\n        \n        cmd.groupLabel = groupLabel;\n\n        self->GetClient()->SerializeCommand(cmd);\n\n    }\n\n    void ClientRenderPassEncoderSetBindGroup(WGPURenderPassEncoder cSelf, uint32_t groupIndex, WGPUBindGroup group, uint32_t dynamicOffsetCount, uint32_t const * dynamicOffsets) {\n        auto self = reinterpret_cast<RenderPassEncoder*>(cSelf);\n        RenderPassEncoderSetBindGroupCmd cmd;\n\n        cmd.self = cSelf;\n\n\n        \n        cmd.groupIndex = groupIndex;\n        \n        cmd.group = group;\n        \n        cmd.dynamicOffsetCount = dynamicOffsetCount;\n        \n        cmd.dynamicOffsets = dynamicOffsets;\n\n        self->GetClient()->SerializeCommand(cmd);\n\n    }\n\n    void ClientRenderPassEncoderSetBlendConstant(WGPURenderPassEncoder cSelf, WGPUColor const * color) {\n        auto self = reinterpret_cast<RenderPassEncoder*>(cSelf);\n        RenderPassEncoderSetBlendConstantCmd cmd;\n\n        cmd.self = cSelf;\n\n\n        \n        cmd.color = color;\n\n        self->GetClient()->SerializeCommand(cmd);\n\n    }\n\n    void ClientRenderPassEncoderSetIndexBuffer(WGPURenderPassEncoder cSelf, WGPUBuffer buffer, WGPUIndexFormat format, uint64_t offset, uint64_t size) {\n        auto self = reinterpret_cast<RenderPassEncoder*>(cSelf);\n        RenderPassEncoderSetIndexBufferCmd cmd;\n\n        cmd.self = cSelf;\n\n\n        \n        cmd.buffer = buffer;\n        \n        cmd.format = format;\n        \n        cmd.offset = offset;\n        \n        cmd.size = size;\n\n        self->GetClient()->SerializeCommand(cmd);\n\n    }\n\n    void ClientRenderPassEncoderSetLabel(WGPURenderPassEncoder cSelf, char const * label) {\n        auto self = reinterpret_cast<RenderPassEncoder*>(cSelf);\n        RenderPassEncoderSetLabelCmd cmd;\n\n        cmd.self = cSelf;\n\n\n        \n        cmd.label = label;\n\n        self->GetClient()->SerializeCommand(cmd);\n\n    }\n\n    void ClientRenderPassEncoderSetPipeline(WGPURenderPassEncoder cSelf, WGPURenderPipeline pipeline) {\n        auto self = reinterpret_cast<RenderPassEncoder*>(cSelf);\n        RenderPassEncoderSetPipelineCmd cmd;\n\n        cmd.self = cSelf;\n\n\n        \n        cmd.pipeline = pipeline;\n\n        self->GetClient()->SerializeCommand(cmd);\n\n    }\n\n    void ClientRenderPassEncoderSetScissorRect(WGPURenderPassEncoder cSelf, uint32_t x, uint32_t y, uint32_t width, uint32_t height) {\n        auto self = reinterpret_cast<RenderPassEncoder*>(cSelf);\n        RenderPassEncoderSetScissorRectCmd cmd;\n\n        cmd.self = cSelf;\n\n\n        \n        cmd.x = x;\n        \n        cmd.y = y;\n        \n        cmd.width = width;\n        \n        cmd.height = height;\n\n        self->GetClient()->SerializeCommand(cmd);\n\n    }\n\n    void ClientRenderPassEncoderSetStencilReference(WGPURenderPassEncoder cSelf, uint32_t reference) {\n        auto self = reinterpret_cast<RenderPassEncoder*>(cSelf);\n        RenderPassEncoderSetStencilReferenceCmd cmd;\n\n        cmd.self = cSelf;\n\n\n        \n        cmd.reference = reference;\n\n        self->GetClient()->SerializeCommand(cmd);\n\n    }\n\n    void ClientRenderPassEncoderSetVertexBuffer(WGPURenderPassEncoder cSelf, uint32_t slot, WGPUBuffer buffer, uint64_t offset, uint64_t size) {\n        auto self = reinterpret_cast<RenderPassEncoder*>(cSelf);\n        RenderPassEncoderSetVertexBufferCmd cmd;\n\n        cmd.self = cSelf;\n\n\n        \n        cmd.slot = slot;\n        \n        cmd.buffer = buffer;\n        \n        cmd.offset = offset;\n        \n        cmd.size = size;\n\n        self->GetClient()->SerializeCommand(cmd);\n\n    }\n\n    void ClientRenderPassEncoderSetViewport(WGPURenderPassEncoder cSelf, float x, float y, float width, float height, float minDepth, float maxDepth) {\n        auto self = reinterpret_cast<RenderPassEncoder*>(cSelf);\n        RenderPassEncoderSetViewportCmd cmd;\n\n        cmd.self = cSelf;\n\n\n        \n        cmd.x = x;\n        \n        cmd.y = y;\n        \n        cmd.width = width;\n        \n        cmd.height = height;\n        \n        cmd.minDepth = minDepth;\n        \n        cmd.maxDepth = maxDepth;\n\n        self->GetClient()->SerializeCommand(cmd);\n\n    }\n\n    void ClientRenderPassEncoderWriteTimestamp(WGPURenderPassEncoder cSelf, WGPUQuerySet querySet, uint32_t queryIndex) {\n        auto self = reinterpret_cast<RenderPassEncoder*>(cSelf);\n        RenderPassEncoderWriteTimestampCmd cmd;\n\n        cmd.self = cSelf;\n\n\n        \n        cmd.querySet = querySet;\n        \n        cmd.queryIndex = queryIndex;\n\n        self->GetClient()->SerializeCommand(cmd);\n\n    }\n\n    void ClientRenderPassEncoderRelease(WGPURenderPassEncoder cObj) {\n        RenderPassEncoder* obj = reinterpret_cast<RenderPassEncoder*>(cObj);\n\n        if (!obj->Release()) {\n            return;\n        }\n\n        DestroyObjectCmd cmd;\n        cmd.objectType = ObjectType::RenderPassEncoder;\n        cmd.objectId = obj->GetWireId();\n\n        Client* client = obj->GetClient();\n        client->SerializeCommand(cmd);\n        client->Free(obj);\n    }\n\n    void ClientRenderPassEncoderReference(WGPURenderPassEncoder cObj) {\n        reinterpret_cast<RenderPassEncoder*>(cObj)->Reference();\n    }\n\n\n    WGPUBindGroupLayout ClientRenderPipelineGetBindGroupLayout(WGPURenderPipeline cSelf, uint32_t groupIndex) {\n        auto self = reinterpret_cast<RenderPipeline*>(cSelf);\n        RenderPipelineGetBindGroupLayoutCmd cmd;\n\n        cmd.self = cSelf;\n\n        auto* returnObject = self->GetClient()->Make<BindGroupLayout>();\n        cmd.result = returnObject->GetWireHandle();\n\n        \n        cmd.groupIndex = groupIndex;\n\n        self->GetClient()->SerializeCommand(cmd);\n\n        return ToAPI(returnObject);\n    }\n\n    void ClientRenderPipelineSetLabel(WGPURenderPipeline cSelf, char const * label) {\n        auto self = reinterpret_cast<RenderPipeline*>(cSelf);\n        RenderPipelineSetLabelCmd cmd;\n\n        cmd.self = cSelf;\n\n\n        \n        cmd.label = label;\n\n        self->GetClient()->SerializeCommand(cmd);\n\n    }\n\n    void ClientRenderPipelineRelease(WGPURenderPipeline cObj) {\n        RenderPipeline* obj = reinterpret_cast<RenderPipeline*>(cObj);\n\n        if (!obj->Release()) {\n            return;\n        }\n\n        DestroyObjectCmd cmd;\n        cmd.objectType = ObjectType::RenderPipeline;\n        cmd.objectId = obj->GetWireId();\n\n        Client* client = obj->GetClient();\n        client->SerializeCommand(cmd);\n        client->Free(obj);\n    }\n\n    void ClientRenderPipelineReference(WGPURenderPipeline cObj) {\n        reinterpret_cast<RenderPipeline*>(cObj)->Reference();\n    }\n\n\n    void ClientSamplerSetLabel(WGPUSampler cSelf, char const * label) {\n        auto self = reinterpret_cast<Sampler*>(cSelf);\n        SamplerSetLabelCmd cmd;\n\n        cmd.self = cSelf;\n\n\n        \n        cmd.label = label;\n\n        self->GetClient()->SerializeCommand(cmd);\n\n    }\n\n    void ClientSamplerRelease(WGPUSampler cObj) {\n        Sampler* obj = reinterpret_cast<Sampler*>(cObj);\n\n        if (!obj->Release()) {\n            return;\n        }\n\n        DestroyObjectCmd cmd;\n        cmd.objectType = ObjectType::Sampler;\n        cmd.objectId = obj->GetWireId();\n\n        Client* client = obj->GetClient();\n        client->SerializeCommand(cmd);\n        client->Free(obj);\n    }\n\n    void ClientSamplerReference(WGPUSampler cObj) {\n        reinterpret_cast<Sampler*>(cObj)->Reference();\n    }\n\n\n    static\n    void ClientShaderModuleGetCompilationInfo(WGPUShaderModule cSelf, WGPUCompilationInfoCallback callback, void * userdata) {\n        auto self = reinterpret_cast<ShaderModule*>(cSelf);\n        return self->GetCompilationInfo( callback,  userdata);\n    }\n\n    void ClientShaderModuleSetLabel(WGPUShaderModule cSelf, char const * label) {\n        auto self = reinterpret_cast<ShaderModule*>(cSelf);\n        ShaderModuleSetLabelCmd cmd;\n\n        cmd.self = cSelf;\n\n\n        \n        cmd.label = label;\n\n        self->GetClient()->SerializeCommand(cmd);\n\n    }\n\n    void ClientShaderModuleRelease(WGPUShaderModule cObj) {\n        ShaderModule* obj = reinterpret_cast<ShaderModule*>(cObj);\n\n        if (!obj->Release()) {\n            return;\n        }\n\n        DestroyObjectCmd cmd;\n        cmd.objectType = ObjectType::ShaderModule;\n        cmd.objectId = obj->GetWireId();\n\n        Client* client = obj->GetClient();\n        client->SerializeCommand(cmd);\n        client->Free(obj);\n    }\n\n    void ClientShaderModuleReference(WGPUShaderModule cObj) {\n        reinterpret_cast<ShaderModule*>(cObj)->Reference();\n    }\n\n\n    void ClientSurfaceRelease(WGPUSurface cObj) {\n        Surface* obj = reinterpret_cast<Surface*>(cObj);\n\n        if (!obj->Release()) {\n            return;\n        }\n\n        DestroyObjectCmd cmd;\n        cmd.objectType = ObjectType::Surface;\n        cmd.objectId = obj->GetWireId();\n\n        Client* client = obj->GetClient();\n        client->SerializeCommand(cmd);\n        client->Free(obj);\n    }\n\n    void ClientSurfaceReference(WGPUSurface cObj) {\n        reinterpret_cast<Surface*>(cObj)->Reference();\n    }\n\n\n    void ClientSwapChainConfigure(WGPUSwapChain cSelf, WGPUTextureFormat format, WGPUTextureUsageFlags allowedUsage, uint32_t width, uint32_t height) {\n        auto self = reinterpret_cast<SwapChain*>(cSelf);\n        SwapChainConfigureCmd cmd;\n\n        cmd.self = cSelf;\n\n\n        \n        cmd.format = format;\n        \n        cmd.allowedUsage = allowedUsage;\n        \n        cmd.width = width;\n        \n        cmd.height = height;\n\n        self->GetClient()->SerializeCommand(cmd);\n\n    }\n\n    WGPUTextureView ClientSwapChainGetCurrentTextureView(WGPUSwapChain cSelf) {\n        auto self = reinterpret_cast<SwapChain*>(cSelf);\n        SwapChainGetCurrentTextureViewCmd cmd;\n\n        cmd.self = cSelf;\n\n        auto* returnObject = self->GetClient()->Make<TextureView>();\n        cmd.result = returnObject->GetWireHandle();\n\n\n        self->GetClient()->SerializeCommand(cmd);\n\n        return ToAPI(returnObject);\n    }\n\n    void ClientSwapChainPresent(WGPUSwapChain cSelf) {\n        auto self = reinterpret_cast<SwapChain*>(cSelf);\n        SwapChainPresentCmd cmd;\n\n        cmd.self = cSelf;\n\n\n\n        self->GetClient()->SerializeCommand(cmd);\n\n    }\n\n    void ClientSwapChainRelease(WGPUSwapChain cObj) {\n        SwapChain* obj = reinterpret_cast<SwapChain*>(cObj);\n\n        if (!obj->Release()) {\n            return;\n        }\n\n        DestroyObjectCmd cmd;\n        cmd.objectType = ObjectType::SwapChain;\n        cmd.objectId = obj->GetWireId();\n\n        Client* client = obj->GetClient();\n        client->SerializeCommand(cmd);\n        client->Free(obj);\n    }\n\n    void ClientSwapChainReference(WGPUSwapChain cObj) {\n        reinterpret_cast<SwapChain*>(cObj)->Reference();\n    }\n\n\n    WGPUTextureView ClientTextureCreateView(WGPUTexture cSelf, WGPUTextureViewDescriptor const * descriptor) {\n        auto self = reinterpret_cast<Texture*>(cSelf);\n        TextureCreateViewCmd cmd;\n\n        cmd.self = cSelf;\n\n        auto* returnObject = self->GetClient()->Make<TextureView>();\n        cmd.result = returnObject->GetWireHandle();\n\n        \n        cmd.descriptor = descriptor;\n\n        self->GetClient()->SerializeCommand(cmd);\n\n        return ToAPI(returnObject);\n    }\n\n    void ClientTextureDestroy(WGPUTexture cSelf) {\n        auto self = reinterpret_cast<Texture*>(cSelf);\n        TextureDestroyCmd cmd;\n\n        cmd.self = cSelf;\n\n\n\n        self->GetClient()->SerializeCommand(cmd);\n\n    }\n\n    static\n    uint32_t ClientTextureGetDepthOrArrayLayers(WGPUTexture cSelf) {\n        auto self = reinterpret_cast<Texture*>(cSelf);\n        return self->GetDepthOrArrayLayers();\n    }\n\n    static\n    WGPUTextureDimension ClientTextureGetDimension(WGPUTexture cSelf) {\n        auto self = reinterpret_cast<Texture*>(cSelf);\n        return self->GetDimension();\n    }\n\n    static\n    WGPUTextureFormat ClientTextureGetFormat(WGPUTexture cSelf) {\n        auto self = reinterpret_cast<Texture*>(cSelf);\n        return self->GetFormat();\n    }\n\n    static\n    uint32_t ClientTextureGetHeight(WGPUTexture cSelf) {\n        auto self = reinterpret_cast<Texture*>(cSelf);\n        return self->GetHeight();\n    }\n\n    static\n    uint32_t ClientTextureGetMipLevelCount(WGPUTexture cSelf) {\n        auto self = reinterpret_cast<Texture*>(cSelf);\n        return self->GetMipLevelCount();\n    }\n\n    static\n    uint32_t ClientTextureGetSampleCount(WGPUTexture cSelf) {\n        auto self = reinterpret_cast<Texture*>(cSelf);\n        return self->GetSampleCount();\n    }\n\n    static\n    WGPUTextureUsage ClientTextureGetUsage(WGPUTexture cSelf) {\n        auto self = reinterpret_cast<Texture*>(cSelf);\n        return self->GetUsage();\n    }\n\n    static\n    uint32_t ClientTextureGetWidth(WGPUTexture cSelf) {\n        auto self = reinterpret_cast<Texture*>(cSelf);\n        return self->GetWidth();\n    }\n\n    void ClientTextureSetLabel(WGPUTexture cSelf, char const * label) {\n        auto self = reinterpret_cast<Texture*>(cSelf);\n        TextureSetLabelCmd cmd;\n\n        cmd.self = cSelf;\n\n\n        \n        cmd.label = label;\n\n        self->GetClient()->SerializeCommand(cmd);\n\n    }\n\n    void ClientTextureRelease(WGPUTexture cObj) {\n        Texture* obj = reinterpret_cast<Texture*>(cObj);\n\n        if (!obj->Release()) {\n            return;\n        }\n\n        DestroyObjectCmd cmd;\n        cmd.objectType = ObjectType::Texture;\n        cmd.objectId = obj->GetWireId();\n\n        Client* client = obj->GetClient();\n        client->SerializeCommand(cmd);\n        client->Free(obj);\n    }\n\n    void ClientTextureReference(WGPUTexture cObj) {\n        reinterpret_cast<Texture*>(cObj)->Reference();\n    }\n\n\n    void ClientTextureViewSetLabel(WGPUTextureView cSelf, char const * label) {\n        auto self = reinterpret_cast<TextureView*>(cSelf);\n        TextureViewSetLabelCmd cmd;\n\n        cmd.self = cSelf;\n\n\n        \n        cmd.label = label;\n\n        self->GetClient()->SerializeCommand(cmd);\n\n    }\n\n    void ClientTextureViewRelease(WGPUTextureView cObj) {\n        TextureView* obj = reinterpret_cast<TextureView*>(cObj);\n\n        if (!obj->Release()) {\n            return;\n        }\n\n        DestroyObjectCmd cmd;\n        cmd.objectType = ObjectType::TextureView;\n        cmd.objectId = obj->GetWireId();\n\n        Client* client = obj->GetClient();\n        client->SerializeCommand(cmd);\n        client->Free(obj);\n    }\n\n    void ClientTextureViewReference(WGPUTextureView cObj) {\n        reinterpret_cast<TextureView*>(cObj)->Reference();\n    }\n\n    namespace {\n        WGPUInstance ClientCreateInstance(WGPUInstanceDescriptor const* descriptor) {\n            UNREACHABLE();\n            return nullptr;\n        }\n\n        struct ProcEntry {\n            WGPUProc proc;\n            const char* name;\n        };\n        static const ProcEntry sProcMap[] = {\n            { reinterpret_cast<WGPUProc>(ClientAdapterCreateDevice), \"wgpuAdapterCreateDevice\" },\n            { reinterpret_cast<WGPUProc>(ClientAdapterEnumerateFeatures), \"wgpuAdapterEnumerateFeatures\" },\n            { reinterpret_cast<WGPUProc>(ClientAdapterGetLimits), \"wgpuAdapterGetLimits\" },\n            { reinterpret_cast<WGPUProc>(ClientAdapterGetProperties), \"wgpuAdapterGetProperties\" },\n            { reinterpret_cast<WGPUProc>(ClientAdapterHasFeature), \"wgpuAdapterHasFeature\" },\n            { reinterpret_cast<WGPUProc>(ClientAdapterReference), \"wgpuAdapterReference\" },\n            { reinterpret_cast<WGPUProc>(ClientAdapterRelease), \"wgpuAdapterRelease\" },\n            { reinterpret_cast<WGPUProc>(ClientAdapterRequestDevice), \"wgpuAdapterRequestDevice\" },\n            { reinterpret_cast<WGPUProc>(ClientBindGroupLayoutReference), \"wgpuBindGroupLayoutReference\" },\n            { reinterpret_cast<WGPUProc>(ClientBindGroupLayoutRelease), \"wgpuBindGroupLayoutRelease\" },\n            { reinterpret_cast<WGPUProc>(ClientBindGroupLayoutSetLabel), \"wgpuBindGroupLayoutSetLabel\" },\n            { reinterpret_cast<WGPUProc>(ClientBindGroupReference), \"wgpuBindGroupReference\" },\n            { reinterpret_cast<WGPUProc>(ClientBindGroupRelease), \"wgpuBindGroupRelease\" },\n            { reinterpret_cast<WGPUProc>(ClientBindGroupSetLabel), \"wgpuBindGroupSetLabel\" },\n            { reinterpret_cast<WGPUProc>(ClientBufferDestroy), \"wgpuBufferDestroy\" },\n            { reinterpret_cast<WGPUProc>(ClientBufferGetConstMappedRange), \"wgpuBufferGetConstMappedRange\" },\n            { reinterpret_cast<WGPUProc>(ClientBufferGetMappedRange), \"wgpuBufferGetMappedRange\" },\n            { reinterpret_cast<WGPUProc>(ClientBufferGetSize), \"wgpuBufferGetSize\" },\n            { reinterpret_cast<WGPUProc>(ClientBufferGetUsage), \"wgpuBufferGetUsage\" },\n            { reinterpret_cast<WGPUProc>(ClientBufferMapAsync), \"wgpuBufferMapAsync\" },\n            { reinterpret_cast<WGPUProc>(ClientBufferReference), \"wgpuBufferReference\" },\n            { reinterpret_cast<WGPUProc>(ClientBufferRelease), \"wgpuBufferRelease\" },\n            { reinterpret_cast<WGPUProc>(ClientBufferSetLabel), \"wgpuBufferSetLabel\" },\n            { reinterpret_cast<WGPUProc>(ClientBufferUnmap), \"wgpuBufferUnmap\" },\n            { reinterpret_cast<WGPUProc>(ClientCommandBufferReference), \"wgpuCommandBufferReference\" },\n            { reinterpret_cast<WGPUProc>(ClientCommandBufferRelease), \"wgpuCommandBufferRelease\" },\n            { reinterpret_cast<WGPUProc>(ClientCommandBufferSetLabel), \"wgpuCommandBufferSetLabel\" },\n            { reinterpret_cast<WGPUProc>(ClientCommandEncoderBeginComputePass), \"wgpuCommandEncoderBeginComputePass\" },\n            { reinterpret_cast<WGPUProc>(ClientCommandEncoderBeginRenderPass), \"wgpuCommandEncoderBeginRenderPass\" },\n            { reinterpret_cast<WGPUProc>(ClientCommandEncoderClearBuffer), \"wgpuCommandEncoderClearBuffer\" },\n            { reinterpret_cast<WGPUProc>(ClientCommandEncoderCopyBufferToBuffer), \"wgpuCommandEncoderCopyBufferToBuffer\" },\n            { reinterpret_cast<WGPUProc>(ClientCommandEncoderCopyBufferToTexture), \"wgpuCommandEncoderCopyBufferToTexture\" },\n            { reinterpret_cast<WGPUProc>(ClientCommandEncoderCopyTextureToBuffer), \"wgpuCommandEncoderCopyTextureToBuffer\" },\n            { reinterpret_cast<WGPUProc>(ClientCommandEncoderCopyTextureToTexture), \"wgpuCommandEncoderCopyTextureToTexture\" },\n            { reinterpret_cast<WGPUProc>(ClientCommandEncoderCopyTextureToTextureInternal), \"wgpuCommandEncoderCopyTextureToTextureInternal\" },\n            { reinterpret_cast<WGPUProc>(ClientCommandEncoderFinish), \"wgpuCommandEncoderFinish\" },\n            { reinterpret_cast<WGPUProc>(ClientCommandEncoderInjectValidationError), \"wgpuCommandEncoderInjectValidationError\" },\n            { reinterpret_cast<WGPUProc>(ClientCommandEncoderInsertDebugMarker), \"wgpuCommandEncoderInsertDebugMarker\" },\n            { reinterpret_cast<WGPUProc>(ClientCommandEncoderPopDebugGroup), \"wgpuCommandEncoderPopDebugGroup\" },\n            { reinterpret_cast<WGPUProc>(ClientCommandEncoderPushDebugGroup), \"wgpuCommandEncoderPushDebugGroup\" },\n            { reinterpret_cast<WGPUProc>(ClientCommandEncoderReference), \"wgpuCommandEncoderReference\" },\n            { reinterpret_cast<WGPUProc>(ClientCommandEncoderRelease), \"wgpuCommandEncoderRelease\" },\n            { reinterpret_cast<WGPUProc>(ClientCommandEncoderResolveQuerySet), \"wgpuCommandEncoderResolveQuerySet\" },\n            { reinterpret_cast<WGPUProc>(ClientCommandEncoderSetLabel), \"wgpuCommandEncoderSetLabel\" },\n            { reinterpret_cast<WGPUProc>(ClientCommandEncoderWriteBuffer), \"wgpuCommandEncoderWriteBuffer\" },\n            { reinterpret_cast<WGPUProc>(ClientCommandEncoderWriteTimestamp), \"wgpuCommandEncoderWriteTimestamp\" },\n            { reinterpret_cast<WGPUProc>(ClientComputePassEncoderDispatch), \"wgpuComputePassEncoderDispatch\" },\n            { reinterpret_cast<WGPUProc>(ClientComputePassEncoderDispatchIndirect), \"wgpuComputePassEncoderDispatchIndirect\" },\n            { reinterpret_cast<WGPUProc>(ClientComputePassEncoderDispatchWorkgroups), \"wgpuComputePassEncoderDispatchWorkgroups\" },\n            { reinterpret_cast<WGPUProc>(ClientComputePassEncoderDispatchWorkgroupsIndirect), \"wgpuComputePassEncoderDispatchWorkgroupsIndirect\" },\n            { reinterpret_cast<WGPUProc>(ClientComputePassEncoderEnd), \"wgpuComputePassEncoderEnd\" },\n            { reinterpret_cast<WGPUProc>(ClientComputePassEncoderEndPass), \"wgpuComputePassEncoderEndPass\" },\n            { reinterpret_cast<WGPUProc>(ClientComputePassEncoderInsertDebugMarker), \"wgpuComputePassEncoderInsertDebugMarker\" },\n            { reinterpret_cast<WGPUProc>(ClientComputePassEncoderPopDebugGroup), \"wgpuComputePassEncoderPopDebugGroup\" },\n            { reinterpret_cast<WGPUProc>(ClientComputePassEncoderPushDebugGroup), \"wgpuComputePassEncoderPushDebugGroup\" },\n            { reinterpret_cast<WGPUProc>(ClientComputePassEncoderReference), \"wgpuComputePassEncoderReference\" },\n            { reinterpret_cast<WGPUProc>(ClientComputePassEncoderRelease), \"wgpuComputePassEncoderRelease\" },\n            { reinterpret_cast<WGPUProc>(ClientComputePassEncoderSetBindGroup), \"wgpuComputePassEncoderSetBindGroup\" },\n            { reinterpret_cast<WGPUProc>(ClientComputePassEncoderSetLabel), \"wgpuComputePassEncoderSetLabel\" },\n            { reinterpret_cast<WGPUProc>(ClientComputePassEncoderSetPipeline), \"wgpuComputePassEncoderSetPipeline\" },\n            { reinterpret_cast<WGPUProc>(ClientComputePassEncoderWriteTimestamp), \"wgpuComputePassEncoderWriteTimestamp\" },\n            { reinterpret_cast<WGPUProc>(ClientComputePipelineGetBindGroupLayout), \"wgpuComputePipelineGetBindGroupLayout\" },\n            { reinterpret_cast<WGPUProc>(ClientComputePipelineReference), \"wgpuComputePipelineReference\" },\n            { reinterpret_cast<WGPUProc>(ClientComputePipelineRelease), \"wgpuComputePipelineRelease\" },\n            { reinterpret_cast<WGPUProc>(ClientComputePipelineSetLabel), \"wgpuComputePipelineSetLabel\" },\n            { reinterpret_cast<WGPUProc>(ClientDeviceCreateBindGroup), \"wgpuDeviceCreateBindGroup\" },\n            { reinterpret_cast<WGPUProc>(ClientDeviceCreateBindGroupLayout), \"wgpuDeviceCreateBindGroupLayout\" },\n            { reinterpret_cast<WGPUProc>(ClientDeviceCreateBuffer), \"wgpuDeviceCreateBuffer\" },\n            { reinterpret_cast<WGPUProc>(ClientDeviceCreateCommandEncoder), \"wgpuDeviceCreateCommandEncoder\" },\n            { reinterpret_cast<WGPUProc>(ClientDeviceCreateComputePipeline), \"wgpuDeviceCreateComputePipeline\" },\n            { reinterpret_cast<WGPUProc>(ClientDeviceCreateComputePipelineAsync), \"wgpuDeviceCreateComputePipelineAsync\" },\n            { reinterpret_cast<WGPUProc>(ClientDeviceCreateErrorBuffer), \"wgpuDeviceCreateErrorBuffer\" },\n            { reinterpret_cast<WGPUProc>(ClientDeviceCreateErrorExternalTexture), \"wgpuDeviceCreateErrorExternalTexture\" },\n            { reinterpret_cast<WGPUProc>(ClientDeviceCreateErrorTexture), \"wgpuDeviceCreateErrorTexture\" },\n            { reinterpret_cast<WGPUProc>(ClientDeviceCreateExternalTexture), \"wgpuDeviceCreateExternalTexture\" },\n            { reinterpret_cast<WGPUProc>(ClientDeviceCreatePipelineLayout), \"wgpuDeviceCreatePipelineLayout\" },\n            { reinterpret_cast<WGPUProc>(ClientDeviceCreateQuerySet), \"wgpuDeviceCreateQuerySet\" },\n            { reinterpret_cast<WGPUProc>(ClientDeviceCreateRenderBundleEncoder), \"wgpuDeviceCreateRenderBundleEncoder\" },\n            { reinterpret_cast<WGPUProc>(ClientDeviceCreateRenderPipeline), \"wgpuDeviceCreateRenderPipeline\" },\n            { reinterpret_cast<WGPUProc>(ClientDeviceCreateRenderPipelineAsync), \"wgpuDeviceCreateRenderPipelineAsync\" },\n            { reinterpret_cast<WGPUProc>(ClientDeviceCreateSampler), \"wgpuDeviceCreateSampler\" },\n            { reinterpret_cast<WGPUProc>(ClientDeviceCreateShaderModule), \"wgpuDeviceCreateShaderModule\" },\n            { reinterpret_cast<WGPUProc>(ClientDeviceCreateSwapChain), \"wgpuDeviceCreateSwapChain\" },\n            { reinterpret_cast<WGPUProc>(ClientDeviceCreateTexture), \"wgpuDeviceCreateTexture\" },\n            { reinterpret_cast<WGPUProc>(ClientDeviceDestroy), \"wgpuDeviceDestroy\" },\n            { reinterpret_cast<WGPUProc>(ClientDeviceEnumerateFeatures), \"wgpuDeviceEnumerateFeatures\" },\n            { reinterpret_cast<WGPUProc>(ClientDeviceGetLimits), \"wgpuDeviceGetLimits\" },\n            { reinterpret_cast<WGPUProc>(ClientDeviceGetQueue), \"wgpuDeviceGetQueue\" },\n            { reinterpret_cast<WGPUProc>(ClientDeviceHasFeature), \"wgpuDeviceHasFeature\" },\n            { reinterpret_cast<WGPUProc>(ClientDeviceInjectError), \"wgpuDeviceInjectError\" },\n            { reinterpret_cast<WGPUProc>(ClientDeviceLoseForTesting), \"wgpuDeviceLoseForTesting\" },\n            { reinterpret_cast<WGPUProc>(ClientDevicePopErrorScope), \"wgpuDevicePopErrorScope\" },\n            { reinterpret_cast<WGPUProc>(ClientDevicePushErrorScope), \"wgpuDevicePushErrorScope\" },\n            { reinterpret_cast<WGPUProc>(ClientDeviceReference), \"wgpuDeviceReference\" },\n            { reinterpret_cast<WGPUProc>(ClientDeviceRelease), \"wgpuDeviceRelease\" },\n            { reinterpret_cast<WGPUProc>(ClientDeviceSetDeviceLostCallback), \"wgpuDeviceSetDeviceLostCallback\" },\n            { reinterpret_cast<WGPUProc>(ClientDeviceSetLabel), \"wgpuDeviceSetLabel\" },\n            { reinterpret_cast<WGPUProc>(ClientDeviceSetLoggingCallback), \"wgpuDeviceSetLoggingCallback\" },\n            { reinterpret_cast<WGPUProc>(ClientDeviceSetUncapturedErrorCallback), \"wgpuDeviceSetUncapturedErrorCallback\" },\n            { reinterpret_cast<WGPUProc>(ClientDeviceTick), \"wgpuDeviceTick\" },\n            { reinterpret_cast<WGPUProc>(ClientExternalTextureDestroy), \"wgpuExternalTextureDestroy\" },\n            { reinterpret_cast<WGPUProc>(ClientExternalTextureReference), \"wgpuExternalTextureReference\" },\n            { reinterpret_cast<WGPUProc>(ClientExternalTextureRelease), \"wgpuExternalTextureRelease\" },\n            { reinterpret_cast<WGPUProc>(ClientExternalTextureSetLabel), \"wgpuExternalTextureSetLabel\" },\n            { reinterpret_cast<WGPUProc>(ClientInstanceCreateSurface), \"wgpuInstanceCreateSurface\" },\n            { reinterpret_cast<WGPUProc>(ClientInstanceReference), \"wgpuInstanceReference\" },\n            { reinterpret_cast<WGPUProc>(ClientInstanceRelease), \"wgpuInstanceRelease\" },\n            { reinterpret_cast<WGPUProc>(ClientInstanceRequestAdapter), \"wgpuInstanceRequestAdapter\" },\n            { reinterpret_cast<WGPUProc>(ClientPipelineLayoutReference), \"wgpuPipelineLayoutReference\" },\n            { reinterpret_cast<WGPUProc>(ClientPipelineLayoutRelease), \"wgpuPipelineLayoutRelease\" },\n            { reinterpret_cast<WGPUProc>(ClientPipelineLayoutSetLabel), \"wgpuPipelineLayoutSetLabel\" },\n            { reinterpret_cast<WGPUProc>(ClientQuerySetDestroy), \"wgpuQuerySetDestroy\" },\n            { reinterpret_cast<WGPUProc>(ClientQuerySetGetCount), \"wgpuQuerySetGetCount\" },\n            { reinterpret_cast<WGPUProc>(ClientQuerySetGetType), \"wgpuQuerySetGetType\" },\n            { reinterpret_cast<WGPUProc>(ClientQuerySetReference), \"wgpuQuerySetReference\" },\n            { reinterpret_cast<WGPUProc>(ClientQuerySetRelease), \"wgpuQuerySetRelease\" },\n            { reinterpret_cast<WGPUProc>(ClientQuerySetSetLabel), \"wgpuQuerySetSetLabel\" },\n            { reinterpret_cast<WGPUProc>(ClientQueueCopyTextureForBrowser), \"wgpuQueueCopyTextureForBrowser\" },\n            { reinterpret_cast<WGPUProc>(ClientQueueOnSubmittedWorkDone), \"wgpuQueueOnSubmittedWorkDone\" },\n            { reinterpret_cast<WGPUProc>(ClientQueueReference), \"wgpuQueueReference\" },\n            { reinterpret_cast<WGPUProc>(ClientQueueRelease), \"wgpuQueueRelease\" },\n            { reinterpret_cast<WGPUProc>(ClientQueueSetLabel), \"wgpuQueueSetLabel\" },\n            { reinterpret_cast<WGPUProc>(ClientQueueSubmit), \"wgpuQueueSubmit\" },\n            { reinterpret_cast<WGPUProc>(ClientQueueWriteBuffer), \"wgpuQueueWriteBuffer\" },\n            { reinterpret_cast<WGPUProc>(ClientQueueWriteTexture), \"wgpuQueueWriteTexture\" },\n            { reinterpret_cast<WGPUProc>(ClientRenderBundleEncoderDraw), \"wgpuRenderBundleEncoderDraw\" },\n            { reinterpret_cast<WGPUProc>(ClientRenderBundleEncoderDrawIndexed), \"wgpuRenderBundleEncoderDrawIndexed\" },\n            { reinterpret_cast<WGPUProc>(ClientRenderBundleEncoderDrawIndexedIndirect), \"wgpuRenderBundleEncoderDrawIndexedIndirect\" },\n            { reinterpret_cast<WGPUProc>(ClientRenderBundleEncoderDrawIndirect), \"wgpuRenderBundleEncoderDrawIndirect\" },\n            { reinterpret_cast<WGPUProc>(ClientRenderBundleEncoderFinish), \"wgpuRenderBundleEncoderFinish\" },\n            { reinterpret_cast<WGPUProc>(ClientRenderBundleEncoderInsertDebugMarker), \"wgpuRenderBundleEncoderInsertDebugMarker\" },\n            { reinterpret_cast<WGPUProc>(ClientRenderBundleEncoderPopDebugGroup), \"wgpuRenderBundleEncoderPopDebugGroup\" },\n            { reinterpret_cast<WGPUProc>(ClientRenderBundleEncoderPushDebugGroup), \"wgpuRenderBundleEncoderPushDebugGroup\" },\n            { reinterpret_cast<WGPUProc>(ClientRenderBundleEncoderReference), \"wgpuRenderBundleEncoderReference\" },\n            { reinterpret_cast<WGPUProc>(ClientRenderBundleEncoderRelease), \"wgpuRenderBundleEncoderRelease\" },\n            { reinterpret_cast<WGPUProc>(ClientRenderBundleEncoderSetBindGroup), \"wgpuRenderBundleEncoderSetBindGroup\" },\n            { reinterpret_cast<WGPUProc>(ClientRenderBundleEncoderSetIndexBuffer), \"wgpuRenderBundleEncoderSetIndexBuffer\" },\n            { reinterpret_cast<WGPUProc>(ClientRenderBundleEncoderSetLabel), \"wgpuRenderBundleEncoderSetLabel\" },\n            { reinterpret_cast<WGPUProc>(ClientRenderBundleEncoderSetPipeline), \"wgpuRenderBundleEncoderSetPipeline\" },\n            { reinterpret_cast<WGPUProc>(ClientRenderBundleEncoderSetVertexBuffer), \"wgpuRenderBundleEncoderSetVertexBuffer\" },\n            { reinterpret_cast<WGPUProc>(ClientRenderBundleReference), \"wgpuRenderBundleReference\" },\n            { reinterpret_cast<WGPUProc>(ClientRenderBundleRelease), \"wgpuRenderBundleRelease\" },\n            { reinterpret_cast<WGPUProc>(ClientRenderPassEncoderBeginOcclusionQuery), \"wgpuRenderPassEncoderBeginOcclusionQuery\" },\n            { reinterpret_cast<WGPUProc>(ClientRenderPassEncoderDraw), \"wgpuRenderPassEncoderDraw\" },\n            { reinterpret_cast<WGPUProc>(ClientRenderPassEncoderDrawIndexed), \"wgpuRenderPassEncoderDrawIndexed\" },\n            { reinterpret_cast<WGPUProc>(ClientRenderPassEncoderDrawIndexedIndirect), \"wgpuRenderPassEncoderDrawIndexedIndirect\" },\n            { reinterpret_cast<WGPUProc>(ClientRenderPassEncoderDrawIndirect), \"wgpuRenderPassEncoderDrawIndirect\" },\n            { reinterpret_cast<WGPUProc>(ClientRenderPassEncoderEnd), \"wgpuRenderPassEncoderEnd\" },\n            { reinterpret_cast<WGPUProc>(ClientRenderPassEncoderEndOcclusionQuery), \"wgpuRenderPassEncoderEndOcclusionQuery\" },\n            { reinterpret_cast<WGPUProc>(ClientRenderPassEncoderEndPass), \"wgpuRenderPassEncoderEndPass\" },\n            { reinterpret_cast<WGPUProc>(ClientRenderPassEncoderExecuteBundles), \"wgpuRenderPassEncoderExecuteBundles\" },\n            { reinterpret_cast<WGPUProc>(ClientRenderPassEncoderInsertDebugMarker), \"wgpuRenderPassEncoderInsertDebugMarker\" },\n            { reinterpret_cast<WGPUProc>(ClientRenderPassEncoderPopDebugGroup), \"wgpuRenderPassEncoderPopDebugGroup\" },\n            { reinterpret_cast<WGPUProc>(ClientRenderPassEncoderPushDebugGroup), \"wgpuRenderPassEncoderPushDebugGroup\" },\n            { reinterpret_cast<WGPUProc>(ClientRenderPassEncoderReference), \"wgpuRenderPassEncoderReference\" },\n            { reinterpret_cast<WGPUProc>(ClientRenderPassEncoderRelease), \"wgpuRenderPassEncoderRelease\" },\n            { reinterpret_cast<WGPUProc>(ClientRenderPassEncoderSetBindGroup), \"wgpuRenderPassEncoderSetBindGroup\" },\n            { reinterpret_cast<WGPUProc>(ClientRenderPassEncoderSetBlendConstant), \"wgpuRenderPassEncoderSetBlendConstant\" },\n            { reinterpret_cast<WGPUProc>(ClientRenderPassEncoderSetIndexBuffer), \"wgpuRenderPassEncoderSetIndexBuffer\" },\n            { reinterpret_cast<WGPUProc>(ClientRenderPassEncoderSetLabel), \"wgpuRenderPassEncoderSetLabel\" },\n            { reinterpret_cast<WGPUProc>(ClientRenderPassEncoderSetPipeline), \"wgpuRenderPassEncoderSetPipeline\" },\n            { reinterpret_cast<WGPUProc>(ClientRenderPassEncoderSetScissorRect), \"wgpuRenderPassEncoderSetScissorRect\" },\n            { reinterpret_cast<WGPUProc>(ClientRenderPassEncoderSetStencilReference), \"wgpuRenderPassEncoderSetStencilReference\" },\n            { reinterpret_cast<WGPUProc>(ClientRenderPassEncoderSetVertexBuffer), \"wgpuRenderPassEncoderSetVertexBuffer\" },\n            { reinterpret_cast<WGPUProc>(ClientRenderPassEncoderSetViewport), \"wgpuRenderPassEncoderSetViewport\" },\n            { reinterpret_cast<WGPUProc>(ClientRenderPassEncoderWriteTimestamp), \"wgpuRenderPassEncoderWriteTimestamp\" },\n            { reinterpret_cast<WGPUProc>(ClientRenderPipelineGetBindGroupLayout), \"wgpuRenderPipelineGetBindGroupLayout\" },\n            { reinterpret_cast<WGPUProc>(ClientRenderPipelineReference), \"wgpuRenderPipelineReference\" },\n            { reinterpret_cast<WGPUProc>(ClientRenderPipelineRelease), \"wgpuRenderPipelineRelease\" },\n            { reinterpret_cast<WGPUProc>(ClientRenderPipelineSetLabel), \"wgpuRenderPipelineSetLabel\" },\n            { reinterpret_cast<WGPUProc>(ClientSamplerReference), \"wgpuSamplerReference\" },\n            { reinterpret_cast<WGPUProc>(ClientSamplerRelease), \"wgpuSamplerRelease\" },\n            { reinterpret_cast<WGPUProc>(ClientSamplerSetLabel), \"wgpuSamplerSetLabel\" },\n            { reinterpret_cast<WGPUProc>(ClientShaderModuleGetCompilationInfo), \"wgpuShaderModuleGetCompilationInfo\" },\n            { reinterpret_cast<WGPUProc>(ClientShaderModuleReference), \"wgpuShaderModuleReference\" },\n            { reinterpret_cast<WGPUProc>(ClientShaderModuleRelease), \"wgpuShaderModuleRelease\" },\n            { reinterpret_cast<WGPUProc>(ClientShaderModuleSetLabel), \"wgpuShaderModuleSetLabel\" },\n            { reinterpret_cast<WGPUProc>(ClientSurfaceReference), \"wgpuSurfaceReference\" },\n            { reinterpret_cast<WGPUProc>(ClientSurfaceRelease), \"wgpuSurfaceRelease\" },\n            { reinterpret_cast<WGPUProc>(ClientSwapChainConfigure), \"wgpuSwapChainConfigure\" },\n            { reinterpret_cast<WGPUProc>(ClientSwapChainGetCurrentTextureView), \"wgpuSwapChainGetCurrentTextureView\" },\n            { reinterpret_cast<WGPUProc>(ClientSwapChainPresent), \"wgpuSwapChainPresent\" },\n            { reinterpret_cast<WGPUProc>(ClientSwapChainReference), \"wgpuSwapChainReference\" },\n            { reinterpret_cast<WGPUProc>(ClientSwapChainRelease), \"wgpuSwapChainRelease\" },\n            { reinterpret_cast<WGPUProc>(ClientTextureCreateView), \"wgpuTextureCreateView\" },\n            { reinterpret_cast<WGPUProc>(ClientTextureDestroy), \"wgpuTextureDestroy\" },\n            { reinterpret_cast<WGPUProc>(ClientTextureGetDepthOrArrayLayers), \"wgpuTextureGetDepthOrArrayLayers\" },\n            { reinterpret_cast<WGPUProc>(ClientTextureGetDimension), \"wgpuTextureGetDimension\" },\n            { reinterpret_cast<WGPUProc>(ClientTextureGetFormat), \"wgpuTextureGetFormat\" },\n            { reinterpret_cast<WGPUProc>(ClientTextureGetHeight), \"wgpuTextureGetHeight\" },\n            { reinterpret_cast<WGPUProc>(ClientTextureGetMipLevelCount), \"wgpuTextureGetMipLevelCount\" },\n            { reinterpret_cast<WGPUProc>(ClientTextureGetSampleCount), \"wgpuTextureGetSampleCount\" },\n            { reinterpret_cast<WGPUProc>(ClientTextureGetUsage), \"wgpuTextureGetUsage\" },\n            { reinterpret_cast<WGPUProc>(ClientTextureGetWidth), \"wgpuTextureGetWidth\" },\n            { reinterpret_cast<WGPUProc>(ClientTextureReference), \"wgpuTextureReference\" },\n            { reinterpret_cast<WGPUProc>(ClientTextureRelease), \"wgpuTextureRelease\" },\n            { reinterpret_cast<WGPUProc>(ClientTextureSetLabel), \"wgpuTextureSetLabel\" },\n            { reinterpret_cast<WGPUProc>(ClientTextureViewReference), \"wgpuTextureViewReference\" },\n            { reinterpret_cast<WGPUProc>(ClientTextureViewRelease), \"wgpuTextureViewRelease\" },\n            { reinterpret_cast<WGPUProc>(ClientTextureViewSetLabel), \"wgpuTextureViewSetLabel\" },\n        };\n        static constexpr size_t sProcMapSize = sizeof(sProcMap) / sizeof(sProcMap[0]);\n    }  // anonymous namespace\n\n    WGPUProc ClientGetProcAddress(WGPUDevice, const char* procName) {\n        if (procName == nullptr) {\n            return nullptr;\n        }\n\n        const ProcEntry* entry = std::lower_bound(&sProcMap[0], &sProcMap[sProcMapSize], procName,\n            [](const ProcEntry &a, const char *b) -> bool {\n                return strcmp(a.name, b) < 0;\n            }\n        );\n\n        if (entry != &sProcMap[sProcMapSize] && strcmp(entry->name, procName) == 0) {\n            return entry->proc;\n        }\n\n        // Special case the two free-standing functions of the API.\n        if (strcmp(procName, \"wgpuGetProcAddress\") == 0) {\n            return reinterpret_cast<WGPUProc>(ClientGetProcAddress);\n        }\n\n        if (strcmp(procName, \"wgpuCreateInstance\") == 0) {\n            return reinterpret_cast<WGPUProc>(ClientCreateInstance);\n        }\n\n        return nullptr;\n    }\n\n    std::vector<const char*> GetProcMapNamesForTesting() {\n        std::vector<const char*> result;\n        result.reserve(sProcMapSize);\n        for (const ProcEntry& entry : sProcMap) {\n            result.push_back(entry.name);\n        }\n        return result;\n    }\n\n    static DawnProcTable gProcTable = {\n        ClientCreateInstance,\n        ClientGetProcAddress,\n        ClientAdapterCreateDevice,\n        ClientAdapterEnumerateFeatures,\n        ClientAdapterGetLimits,\n        ClientAdapterGetProperties,\n        ClientAdapterHasFeature,\n        ClientAdapterRequestDevice,\n        ClientAdapterReference,\n        ClientAdapterRelease,\n        ClientBindGroupSetLabel,\n        ClientBindGroupReference,\n        ClientBindGroupRelease,\n        ClientBindGroupLayoutSetLabel,\n        ClientBindGroupLayoutReference,\n        ClientBindGroupLayoutRelease,\n        ClientBufferDestroy,\n        ClientBufferGetConstMappedRange,\n        ClientBufferGetMappedRange,\n        ClientBufferGetSize,\n        ClientBufferGetUsage,\n        ClientBufferMapAsync,\n        ClientBufferSetLabel,\n        ClientBufferUnmap,\n        ClientBufferReference,\n        ClientBufferRelease,\n        ClientCommandBufferSetLabel,\n        ClientCommandBufferReference,\n        ClientCommandBufferRelease,\n        ClientCommandEncoderBeginComputePass,\n        ClientCommandEncoderBeginRenderPass,\n        ClientCommandEncoderClearBuffer,\n        ClientCommandEncoderCopyBufferToBuffer,\n        ClientCommandEncoderCopyBufferToTexture,\n        ClientCommandEncoderCopyTextureToBuffer,\n        ClientCommandEncoderCopyTextureToTexture,\n        ClientCommandEncoderCopyTextureToTextureInternal,\n        ClientCommandEncoderFinish,\n        ClientCommandEncoderInjectValidationError,\n        ClientCommandEncoderInsertDebugMarker,\n        ClientCommandEncoderPopDebugGroup,\n        ClientCommandEncoderPushDebugGroup,\n        ClientCommandEncoderResolveQuerySet,\n        ClientCommandEncoderSetLabel,\n        ClientCommandEncoderWriteBuffer,\n        ClientCommandEncoderWriteTimestamp,\n        ClientCommandEncoderReference,\n        ClientCommandEncoderRelease,\n        ClientComputePassEncoderDispatch,\n        ClientComputePassEncoderDispatchIndirect,\n        ClientComputePassEncoderDispatchWorkgroups,\n        ClientComputePassEncoderDispatchWorkgroupsIndirect,\n        ClientComputePassEncoderEnd,\n        ClientComputePassEncoderEndPass,\n        ClientComputePassEncoderInsertDebugMarker,\n        ClientComputePassEncoderPopDebugGroup,\n        ClientComputePassEncoderPushDebugGroup,\n        ClientComputePassEncoderSetBindGroup,\n        ClientComputePassEncoderSetLabel,\n        ClientComputePassEncoderSetPipeline,\n        ClientComputePassEncoderWriteTimestamp,\n        ClientComputePassEncoderReference,\n        ClientComputePassEncoderRelease,\n        ClientComputePipelineGetBindGroupLayout,\n        ClientComputePipelineSetLabel,\n        ClientComputePipelineReference,\n        ClientComputePipelineRelease,\n        ClientDeviceCreateBindGroup,\n        ClientDeviceCreateBindGroupLayout,\n        ClientDeviceCreateBuffer,\n        ClientDeviceCreateCommandEncoder,\n        ClientDeviceCreateComputePipeline,\n        ClientDeviceCreateComputePipelineAsync,\n        ClientDeviceCreateErrorBuffer,\n        ClientDeviceCreateErrorExternalTexture,\n        ClientDeviceCreateErrorTexture,\n        ClientDeviceCreateExternalTexture,\n        ClientDeviceCreatePipelineLayout,\n        ClientDeviceCreateQuerySet,\n        ClientDeviceCreateRenderBundleEncoder,\n        ClientDeviceCreateRenderPipeline,\n        ClientDeviceCreateRenderPipelineAsync,\n        ClientDeviceCreateSampler,\n        ClientDeviceCreateShaderModule,\n        ClientDeviceCreateSwapChain,\n        ClientDeviceCreateTexture,\n        ClientDeviceDestroy,\n        ClientDeviceEnumerateFeatures,\n        ClientDeviceGetLimits,\n        ClientDeviceGetQueue,\n        ClientDeviceHasFeature,\n        ClientDeviceInjectError,\n        ClientDeviceLoseForTesting,\n        ClientDevicePopErrorScope,\n        ClientDevicePushErrorScope,\n        ClientDeviceSetDeviceLostCallback,\n        ClientDeviceSetLabel,\n        ClientDeviceSetLoggingCallback,\n        ClientDeviceSetUncapturedErrorCallback,\n        ClientDeviceTick,\n        ClientDeviceReference,\n        ClientDeviceRelease,\n        ClientExternalTextureDestroy,\n        ClientExternalTextureSetLabel,\n        ClientExternalTextureReference,\n        ClientExternalTextureRelease,\n        ClientInstanceCreateSurface,\n        ClientInstanceRequestAdapter,\n        ClientInstanceReference,\n        ClientInstanceRelease,\n        ClientPipelineLayoutSetLabel,\n        ClientPipelineLayoutReference,\n        ClientPipelineLayoutRelease,\n        ClientQuerySetDestroy,\n        ClientQuerySetGetCount,\n        ClientQuerySetGetType,\n        ClientQuerySetSetLabel,\n        ClientQuerySetReference,\n        ClientQuerySetRelease,\n        ClientQueueCopyTextureForBrowser,\n        ClientQueueOnSubmittedWorkDone,\n        ClientQueueSetLabel,\n        ClientQueueSubmit,\n        ClientQueueWriteBuffer,\n        ClientQueueWriteTexture,\n        ClientQueueReference,\n        ClientQueueRelease,\n        ClientRenderBundleReference,\n        ClientRenderBundleRelease,\n        ClientRenderBundleEncoderDraw,\n        ClientRenderBundleEncoderDrawIndexed,\n        ClientRenderBundleEncoderDrawIndexedIndirect,\n        ClientRenderBundleEncoderDrawIndirect,\n        ClientRenderBundleEncoderFinish,\n        ClientRenderBundleEncoderInsertDebugMarker,\n        ClientRenderBundleEncoderPopDebugGroup,\n        ClientRenderBundleEncoderPushDebugGroup,\n        ClientRenderBundleEncoderSetBindGroup,\n        ClientRenderBundleEncoderSetIndexBuffer,\n        ClientRenderBundleEncoderSetLabel,\n        ClientRenderBundleEncoderSetPipeline,\n        ClientRenderBundleEncoderSetVertexBuffer,\n        ClientRenderBundleEncoderReference,\n        ClientRenderBundleEncoderRelease,\n        ClientRenderPassEncoderBeginOcclusionQuery,\n        ClientRenderPassEncoderDraw,\n        ClientRenderPassEncoderDrawIndexed,\n        ClientRenderPassEncoderDrawIndexedIndirect,\n        ClientRenderPassEncoderDrawIndirect,\n        ClientRenderPassEncoderEnd,\n        ClientRenderPassEncoderEndOcclusionQuery,\n        ClientRenderPassEncoderEndPass,\n        ClientRenderPassEncoderExecuteBundles,\n        ClientRenderPassEncoderInsertDebugMarker,\n        ClientRenderPassEncoderPopDebugGroup,\n        ClientRenderPassEncoderPushDebugGroup,\n        ClientRenderPassEncoderSetBindGroup,\n        ClientRenderPassEncoderSetBlendConstant,\n        ClientRenderPassEncoderSetIndexBuffer,\n        ClientRenderPassEncoderSetLabel,\n        ClientRenderPassEncoderSetPipeline,\n        ClientRenderPassEncoderSetScissorRect,\n        ClientRenderPassEncoderSetStencilReference,\n        ClientRenderPassEncoderSetVertexBuffer,\n        ClientRenderPassEncoderSetViewport,\n        ClientRenderPassEncoderWriteTimestamp,\n        ClientRenderPassEncoderReference,\n        ClientRenderPassEncoderRelease,\n        ClientRenderPipelineGetBindGroupLayout,\n        ClientRenderPipelineSetLabel,\n        ClientRenderPipelineReference,\n        ClientRenderPipelineRelease,\n        ClientSamplerSetLabel,\n        ClientSamplerReference,\n        ClientSamplerRelease,\n        ClientShaderModuleGetCompilationInfo,\n        ClientShaderModuleSetLabel,\n        ClientShaderModuleReference,\n        ClientShaderModuleRelease,\n        ClientSurfaceReference,\n        ClientSurfaceRelease,\n        ClientSwapChainConfigure,\n        ClientSwapChainGetCurrentTextureView,\n        ClientSwapChainPresent,\n        ClientSwapChainReference,\n        ClientSwapChainRelease,\n        ClientTextureCreateView,\n        ClientTextureDestroy,\n        ClientTextureGetDepthOrArrayLayers,\n        ClientTextureGetDimension,\n        ClientTextureGetFormat,\n        ClientTextureGetHeight,\n        ClientTextureGetMipLevelCount,\n        ClientTextureGetSampleCount,\n        ClientTextureGetUsage,\n        ClientTextureGetWidth,\n        ClientTextureSetLabel,\n        ClientTextureReference,\n        ClientTextureRelease,\n        ClientTextureViewSetLabel,\n        ClientTextureViewReference,\n        ClientTextureViewRelease,\n    };\n\n    const DawnProcTable& GetProcs() {\n        return gProcTable;\n    }\n}  // namespace dawn::wire::client\n", "src/dawn/wire/client/ClientBase_autogen.h": "\n#ifndef DAWNWIRE_CLIENT_CLIENTBASE_AUTOGEN_H_\n#define DAWNWIRE_CLIENT_CLIENTBASE_AUTOGEN_H_\n\n#include \"dawn/wire/ChunkedCommandHandler.h\"\n#include \"dawn/wire/WireCmd_autogen.h\"\n#include \"dawn/wire/client/ApiObjects.h\"\n\nnamespace dawn::wire::client {\n\n    class ClientBase : public ChunkedCommandHandler, public ObjectIdProvider {\n      public:\n        ClientBase() = default;\n        ~ClientBase() override = default;\n\n      private:\n        // Implementation of the ObjectIdProvider interface\n        WireResult GetId(WGPUAdapter object, ObjectId* out) const final {\n            ASSERT(out != nullptr);\n            if (object == nullptr) {\n                return WireResult::FatalError;\n            }\n            *out = reinterpret_cast<Adapter*>(object)->GetWireId();\n            return WireResult::Success;\n        }\n        WireResult GetOptionalId(WGPUAdapter object, ObjectId* out) const final {\n            ASSERT(out != nullptr);\n            *out = (object == nullptr ? 0 : reinterpret_cast<Adapter*>(object)->GetWireId());\n            return WireResult::Success;\n        }\n        WireResult GetId(WGPUBindGroup object, ObjectId* out) const final {\n            ASSERT(out != nullptr);\n            if (object == nullptr) {\n                return WireResult::FatalError;\n            }\n            *out = reinterpret_cast<BindGroup*>(object)->GetWireId();\n            return WireResult::Success;\n        }\n        WireResult GetOptionalId(WGPUBindGroup object, ObjectId* out) const final {\n            ASSERT(out != nullptr);\n            *out = (object == nullptr ? 0 : reinterpret_cast<BindGroup*>(object)->GetWireId());\n            return WireResult::Success;\n        }\n        WireResult GetId(WGPUBindGroupLayout object, ObjectId* out) const final {\n            ASSERT(out != nullptr);\n            if (object == nullptr) {\n                return WireResult::FatalError;\n            }\n            *out = reinterpret_cast<BindGroupLayout*>(object)->GetWireId();\n            return WireResult::Success;\n        }\n        WireResult GetOptionalId(WGPUBindGroupLayout object, ObjectId* out) const final {\n            ASSERT(out != nullptr);\n            *out = (object == nullptr ? 0 : reinterpret_cast<BindGroupLayout*>(object)->GetWireId());\n            return WireResult::Success;\n        }\n        WireResult GetId(WGPUBuffer object, ObjectId* out) const final {\n            ASSERT(out != nullptr);\n            if (object == nullptr) {\n                return WireResult::FatalError;\n            }\n            *out = reinterpret_cast<Buffer*>(object)->GetWireId();\n            return WireResult::Success;\n        }\n        WireResult GetOptionalId(WGPUBuffer object, ObjectId* out) const final {\n            ASSERT(out != nullptr);\n            *out = (object == nullptr ? 0 : reinterpret_cast<Buffer*>(object)->GetWireId());\n            return WireResult::Success;\n        }\n        WireResult GetId(WGPUCommandBuffer object, ObjectId* out) const final {\n            ASSERT(out != nullptr);\n            if (object == nullptr) {\n                return WireResult::FatalError;\n            }\n            *out = reinterpret_cast<CommandBuffer*>(object)->GetWireId();\n            return WireResult::Success;\n        }\n        WireResult GetOptionalId(WGPUCommandBuffer object, ObjectId* out) const final {\n            ASSERT(out != nullptr);\n            *out = (object == nullptr ? 0 : reinterpret_cast<CommandBuffer*>(object)->GetWireId());\n            return WireResult::Success;\n        }\n        WireResult GetId(WGPUCommandEncoder object, ObjectId* out) const final {\n            ASSERT(out != nullptr);\n            if (object == nullptr) {\n                return WireResult::FatalError;\n            }\n            *out = reinterpret_cast<CommandEncoder*>(object)->GetWireId();\n            return WireResult::Success;\n        }\n        WireResult GetOptionalId(WGPUCommandEncoder object, ObjectId* out) const final {\n            ASSERT(out != nullptr);\n            *out = (object == nullptr ? 0 : reinterpret_cast<CommandEncoder*>(object)->GetWireId());\n            return WireResult::Success;\n        }\n        WireResult GetId(WGPUComputePassEncoder object, ObjectId* out) const final {\n            ASSERT(out != nullptr);\n            if (object == nullptr) {\n                return WireResult::FatalError;\n            }\n            *out = reinterpret_cast<ComputePassEncoder*>(object)->GetWireId();\n            return WireResult::Success;\n        }\n        WireResult GetOptionalId(WGPUComputePassEncoder object, ObjectId* out) const final {\n            ASSERT(out != nullptr);\n            *out = (object == nullptr ? 0 : reinterpret_cast<ComputePassEncoder*>(object)->GetWireId());\n            return WireResult::Success;\n        }\n        WireResult GetId(WGPUComputePipeline object, ObjectId* out) const final {\n            ASSERT(out != nullptr);\n            if (object == nullptr) {\n                return WireResult::FatalError;\n            }\n            *out = reinterpret_cast<ComputePipeline*>(object)->GetWireId();\n            return WireResult::Success;\n        }\n        WireResult GetOptionalId(WGPUComputePipeline object, ObjectId* out) const final {\n            ASSERT(out != nullptr);\n            *out = (object == nullptr ? 0 : reinterpret_cast<ComputePipeline*>(object)->GetWireId());\n            return WireResult::Success;\n        }\n        WireResult GetId(WGPUDevice object, ObjectId* out) const final {\n            ASSERT(out != nullptr);\n            if (object == nullptr) {\n                return WireResult::FatalError;\n            }\n            *out = reinterpret_cast<Device*>(object)->GetWireId();\n            return WireResult::Success;\n        }\n        WireResult GetOptionalId(WGPUDevice object, ObjectId* out) const final {\n            ASSERT(out != nullptr);\n            *out = (object == nullptr ? 0 : reinterpret_cast<Device*>(object)->GetWireId());\n            return WireResult::Success;\n        }\n        WireResult GetId(WGPUExternalTexture object, ObjectId* out) const final {\n            ASSERT(out != nullptr);\n            if (object == nullptr) {\n                return WireResult::FatalError;\n            }\n            *out = reinterpret_cast<ExternalTexture*>(object)->GetWireId();\n            return WireResult::Success;\n        }\n        WireResult GetOptionalId(WGPUExternalTexture object, ObjectId* out) const final {\n            ASSERT(out != nullptr);\n            *out = (object == nullptr ? 0 : reinterpret_cast<ExternalTexture*>(object)->GetWireId());\n            return WireResult::Success;\n        }\n        WireResult GetId(WGPUInstance object, ObjectId* out) const final {\n            ASSERT(out != nullptr);\n            if (object == nullptr) {\n                return WireResult::FatalError;\n            }\n            *out = reinterpret_cast<Instance*>(object)->GetWireId();\n            return WireResult::Success;\n        }\n        WireResult GetOptionalId(WGPUInstance object, ObjectId* out) const final {\n            ASSERT(out != nullptr);\n            *out = (object == nullptr ? 0 : reinterpret_cast<Instance*>(object)->GetWireId());\n            return WireResult::Success;\n        }\n        WireResult GetId(WGPUPipelineLayout object, ObjectId* out) const final {\n            ASSERT(out != nullptr);\n            if (object == nullptr) {\n                return WireResult::FatalError;\n            }\n            *out = reinterpret_cast<PipelineLayout*>(object)->GetWireId();\n            return WireResult::Success;\n        }\n        WireResult GetOptionalId(WGPUPipelineLayout object, ObjectId* out) const final {\n            ASSERT(out != nullptr);\n            *out = (object == nullptr ? 0 : reinterpret_cast<PipelineLayout*>(object)->GetWireId());\n            return WireResult::Success;\n        }\n        WireResult GetId(WGPUQuerySet object, ObjectId* out) const final {\n            ASSERT(out != nullptr);\n            if (object == nullptr) {\n                return WireResult::FatalError;\n            }\n            *out = reinterpret_cast<QuerySet*>(object)->GetWireId();\n            return WireResult::Success;\n        }\n        WireResult GetOptionalId(WGPUQuerySet object, ObjectId* out) const final {\n            ASSERT(out != nullptr);\n            *out = (object == nullptr ? 0 : reinterpret_cast<QuerySet*>(object)->GetWireId());\n            return WireResult::Success;\n        }\n        WireResult GetId(WGPUQueue object, ObjectId* out) const final {\n            ASSERT(out != nullptr);\n            if (object == nullptr) {\n                return WireResult::FatalError;\n            }\n            *out = reinterpret_cast<Queue*>(object)->GetWireId();\n            return WireResult::Success;\n        }\n        WireResult GetOptionalId(WGPUQueue object, ObjectId* out) const final {\n            ASSERT(out != nullptr);\n            *out = (object == nullptr ? 0 : reinterpret_cast<Queue*>(object)->GetWireId());\n            return WireResult::Success;\n        }\n        WireResult GetId(WGPURenderBundle object, ObjectId* out) const final {\n            ASSERT(out != nullptr);\n            if (object == nullptr) {\n                return WireResult::FatalError;\n            }\n            *out = reinterpret_cast<RenderBundle*>(object)->GetWireId();\n            return WireResult::Success;\n        }\n        WireResult GetOptionalId(WGPURenderBundle object, ObjectId* out) const final {\n            ASSERT(out != nullptr);\n            *out = (object == nullptr ? 0 : reinterpret_cast<RenderBundle*>(object)->GetWireId());\n            return WireResult::Success;\n        }\n        WireResult GetId(WGPURenderBundleEncoder object, ObjectId* out) const final {\n            ASSERT(out != nullptr);\n            if (object == nullptr) {\n                return WireResult::FatalError;\n            }\n            *out = reinterpret_cast<RenderBundleEncoder*>(object)->GetWireId();\n            return WireResult::Success;\n        }\n        WireResult GetOptionalId(WGPURenderBundleEncoder object, ObjectId* out) const final {\n            ASSERT(out != nullptr);\n            *out = (object == nullptr ? 0 : reinterpret_cast<RenderBundleEncoder*>(object)->GetWireId());\n            return WireResult::Success;\n        }\n        WireResult GetId(WGPURenderPassEncoder object, ObjectId* out) const final {\n            ASSERT(out != nullptr);\n            if (object == nullptr) {\n                return WireResult::FatalError;\n            }\n            *out = reinterpret_cast<RenderPassEncoder*>(object)->GetWireId();\n            return WireResult::Success;\n        }\n        WireResult GetOptionalId(WGPURenderPassEncoder object, ObjectId* out) const final {\n            ASSERT(out != nullptr);\n            *out = (object == nullptr ? 0 : reinterpret_cast<RenderPassEncoder*>(object)->GetWireId());\n            return WireResult::Success;\n        }\n        WireResult GetId(WGPURenderPipeline object, ObjectId* out) const final {\n            ASSERT(out != nullptr);\n            if (object == nullptr) {\n                return WireResult::FatalError;\n            }\n            *out = reinterpret_cast<RenderPipeline*>(object)->GetWireId();\n            return WireResult::Success;\n        }\n        WireResult GetOptionalId(WGPURenderPipeline object, ObjectId* out) const final {\n            ASSERT(out != nullptr);\n            *out = (object == nullptr ? 0 : reinterpret_cast<RenderPipeline*>(object)->GetWireId());\n            return WireResult::Success;\n        }\n        WireResult GetId(WGPUSampler object, ObjectId* out) const final {\n            ASSERT(out != nullptr);\n            if (object == nullptr) {\n                return WireResult::FatalError;\n            }\n            *out = reinterpret_cast<Sampler*>(object)->GetWireId();\n            return WireResult::Success;\n        }\n        WireResult GetOptionalId(WGPUSampler object, ObjectId* out) const final {\n            ASSERT(out != nullptr);\n            *out = (object == nullptr ? 0 : reinterpret_cast<Sampler*>(object)->GetWireId());\n            return WireResult::Success;\n        }\n        WireResult GetId(WGPUShaderModule object, ObjectId* out) const final {\n            ASSERT(out != nullptr);\n            if (object == nullptr) {\n                return WireResult::FatalError;\n            }\n            *out = reinterpret_cast<ShaderModule*>(object)->GetWireId();\n            return WireResult::Success;\n        }\n        WireResult GetOptionalId(WGPUShaderModule object, ObjectId* out) const final {\n            ASSERT(out != nullptr);\n            *out = (object == nullptr ? 0 : reinterpret_cast<ShaderModule*>(object)->GetWireId());\n            return WireResult::Success;\n        }\n        WireResult GetId(WGPUSurface object, ObjectId* out) const final {\n            ASSERT(out != nullptr);\n            if (object == nullptr) {\n                return WireResult::FatalError;\n            }\n            *out = reinterpret_cast<Surface*>(object)->GetWireId();\n            return WireResult::Success;\n        }\n        WireResult GetOptionalId(WGPUSurface object, ObjectId* out) const final {\n            ASSERT(out != nullptr);\n            *out = (object == nullptr ? 0 : reinterpret_cast<Surface*>(object)->GetWireId());\n            return WireResult::Success;\n        }\n        WireResult GetId(WGPUSwapChain object, ObjectId* out) const final {\n            ASSERT(out != nullptr);\n            if (object == nullptr) {\n                return WireResult::FatalError;\n            }\n            *out = reinterpret_cast<SwapChain*>(object)->GetWireId();\n            return WireResult::Success;\n        }\n        WireResult GetOptionalId(WGPUSwapChain object, ObjectId* out) const final {\n            ASSERT(out != nullptr);\n            *out = (object == nullptr ? 0 : reinterpret_cast<SwapChain*>(object)->GetWireId());\n            return WireResult::Success;\n        }\n        WireResult GetId(WGPUTexture object, ObjectId* out) const final {\n            ASSERT(out != nullptr);\n            if (object == nullptr) {\n                return WireResult::FatalError;\n            }\n            *out = reinterpret_cast<Texture*>(object)->GetWireId();\n            return WireResult::Success;\n        }\n        WireResult GetOptionalId(WGPUTexture object, ObjectId* out) const final {\n            ASSERT(out != nullptr);\n            *out = (object == nullptr ? 0 : reinterpret_cast<Texture*>(object)->GetWireId());\n            return WireResult::Success;\n        }\n        WireResult GetId(WGPUTextureView object, ObjectId* out) const final {\n            ASSERT(out != nullptr);\n            if (object == nullptr) {\n                return WireResult::FatalError;\n            }\n            *out = reinterpret_cast<TextureView*>(object)->GetWireId();\n            return WireResult::Success;\n        }\n        WireResult GetOptionalId(WGPUTextureView object, ObjectId* out) const final {\n            ASSERT(out != nullptr);\n            *out = (object == nullptr ? 0 : reinterpret_cast<TextureView*>(object)->GetWireId());\n            return WireResult::Success;\n        }\n    };\n\n}  // namespace dawn::wire::client\n\n#endif  // DAWNWIRE_CLIENT_CLIENTBASE_AUTOGEN_H_\n", "src/dawn/wire/client/ClientHandlers_autogen.cpp": "\n#include \"dawn/common/Assert.h\"\n#include \"dawn/wire/client/Client.h\"\n\n#include <string>\n\nnamespace dawn::wire::client {\n    bool Client::HandleAdapterRequestDeviceCallback(DeserializeBuffer* deserializeBuffer) {\n        ReturnAdapterRequestDeviceCallbackCmd cmd;\n        WireResult deserializeResult = cmd.Deserialize(deserializeBuffer, &mWireCommandAllocator);\n\n        if (deserializeResult == WireResult::FatalError) {\n            return false;\n        }\n\n\n        Adapter* adapter = Get<Adapter>(cmd.adapter.id);\n        if (adapter != nullptr && adapter->GetWireGeneration() != cmd.adapter.generation) {\n            adapter = nullptr;\n        }\n\n        return DoAdapterRequestDeviceCallback(adapter, cmd.requestSerial, cmd.status, cmd.message, cmd.limits, cmd.featuresCount, cmd.features);\n    }\n    bool Client::HandleBufferMapAsyncCallback(DeserializeBuffer* deserializeBuffer) {\n        ReturnBufferMapAsyncCallbackCmd cmd;\n        WireResult deserializeResult = cmd.Deserialize(deserializeBuffer, &mWireCommandAllocator);\n\n        if (deserializeResult == WireResult::FatalError) {\n            return false;\n        }\n\n\n        Buffer* buffer = Get<Buffer>(cmd.buffer.id);\n        if (buffer != nullptr && buffer->GetWireGeneration() != cmd.buffer.generation) {\n            buffer = nullptr;\n        }\n\n        return DoBufferMapAsyncCallback(buffer, cmd.requestSerial, cmd.status, cmd.readDataUpdateInfoLength, cmd.readDataUpdateInfo);\n    }\n    bool Client::HandleDeviceCreateComputePipelineAsyncCallback(DeserializeBuffer* deserializeBuffer) {\n        ReturnDeviceCreateComputePipelineAsyncCallbackCmd cmd;\n        WireResult deserializeResult = cmd.Deserialize(deserializeBuffer, &mWireCommandAllocator);\n\n        if (deserializeResult == WireResult::FatalError) {\n            return false;\n        }\n\n\n        Device* device = Get<Device>(cmd.device.id);\n        if (device != nullptr && device->GetWireGeneration() != cmd.device.generation) {\n            device = nullptr;\n        }\n\n        return DoDeviceCreateComputePipelineAsyncCallback(device, cmd.requestSerial, cmd.status, cmd.message);\n    }\n    bool Client::HandleDeviceCreateRenderPipelineAsyncCallback(DeserializeBuffer* deserializeBuffer) {\n        ReturnDeviceCreateRenderPipelineAsyncCallbackCmd cmd;\n        WireResult deserializeResult = cmd.Deserialize(deserializeBuffer, &mWireCommandAllocator);\n\n        if (deserializeResult == WireResult::FatalError) {\n            return false;\n        }\n\n\n        Device* device = Get<Device>(cmd.device.id);\n        if (device != nullptr && device->GetWireGeneration() != cmd.device.generation) {\n            device = nullptr;\n        }\n\n        return DoDeviceCreateRenderPipelineAsyncCallback(device, cmd.requestSerial, cmd.status, cmd.message);\n    }\n    bool Client::HandleDeviceLoggingCallback(DeserializeBuffer* deserializeBuffer) {\n        ReturnDeviceLoggingCallbackCmd cmd;\n        WireResult deserializeResult = cmd.Deserialize(deserializeBuffer, &mWireCommandAllocator);\n\n        if (deserializeResult == WireResult::FatalError) {\n            return false;\n        }\n\n\n        Device* device = Get<Device>(cmd.device.id);\n        if (device != nullptr && device->GetWireGeneration() != cmd.device.generation) {\n            device = nullptr;\n        }\n\n        return DoDeviceLoggingCallback(device, cmd.type, cmd.message);\n    }\n    bool Client::HandleDeviceLostCallback(DeserializeBuffer* deserializeBuffer) {\n        ReturnDeviceLostCallbackCmd cmd;\n        WireResult deserializeResult = cmd.Deserialize(deserializeBuffer, &mWireCommandAllocator);\n\n        if (deserializeResult == WireResult::FatalError) {\n            return false;\n        }\n\n\n        Device* device = Get<Device>(cmd.device.id);\n        if (device != nullptr && device->GetWireGeneration() != cmd.device.generation) {\n            device = nullptr;\n        }\n\n        return DoDeviceLostCallback(device, cmd.reason, cmd.message);\n    }\n    bool Client::HandleDevicePopErrorScopeCallback(DeserializeBuffer* deserializeBuffer) {\n        ReturnDevicePopErrorScopeCallbackCmd cmd;\n        WireResult deserializeResult = cmd.Deserialize(deserializeBuffer, &mWireCommandAllocator);\n\n        if (deserializeResult == WireResult::FatalError) {\n            return false;\n        }\n\n\n        Device* device = Get<Device>(cmd.device.id);\n        if (device != nullptr && device->GetWireGeneration() != cmd.device.generation) {\n            device = nullptr;\n        }\n\n        return DoDevicePopErrorScopeCallback(device, cmd.requestSerial, cmd.type, cmd.message);\n    }\n    bool Client::HandleDeviceUncapturedErrorCallback(DeserializeBuffer* deserializeBuffer) {\n        ReturnDeviceUncapturedErrorCallbackCmd cmd;\n        WireResult deserializeResult = cmd.Deserialize(deserializeBuffer, &mWireCommandAllocator);\n\n        if (deserializeResult == WireResult::FatalError) {\n            return false;\n        }\n\n\n        Device* device = Get<Device>(cmd.device.id);\n        if (device != nullptr && device->GetWireGeneration() != cmd.device.generation) {\n            device = nullptr;\n        }\n\n        return DoDeviceUncapturedErrorCallback(device, cmd.type, cmd.message);\n    }\n    bool Client::HandleInstanceRequestAdapterCallback(DeserializeBuffer* deserializeBuffer) {\n        ReturnInstanceRequestAdapterCallbackCmd cmd;\n        WireResult deserializeResult = cmd.Deserialize(deserializeBuffer, &mWireCommandAllocator);\n\n        if (deserializeResult == WireResult::FatalError) {\n            return false;\n        }\n\n\n        Instance* instance = Get<Instance>(cmd.instance.id);\n        if (instance != nullptr && instance->GetWireGeneration() != cmd.instance.generation) {\n            instance = nullptr;\n        }\n\n        return DoInstanceRequestAdapterCallback(instance, cmd.requestSerial, cmd.status, cmd.message, cmd.properties, cmd.limits, cmd.featuresCount, cmd.features);\n    }\n    bool Client::HandleQueueWorkDoneCallback(DeserializeBuffer* deserializeBuffer) {\n        ReturnQueueWorkDoneCallbackCmd cmd;\n        WireResult deserializeResult = cmd.Deserialize(deserializeBuffer, &mWireCommandAllocator);\n\n        if (deserializeResult == WireResult::FatalError) {\n            return false;\n        }\n\n\n        Queue* queue = Get<Queue>(cmd.queue.id);\n        if (queue != nullptr && queue->GetWireGeneration() != cmd.queue.generation) {\n            queue = nullptr;\n        }\n\n        return DoQueueWorkDoneCallback(queue, cmd.requestSerial, cmd.status);\n    }\n    bool Client::HandleShaderModuleGetCompilationInfoCallback(DeserializeBuffer* deserializeBuffer) {\n        ReturnShaderModuleGetCompilationInfoCallbackCmd cmd;\n        WireResult deserializeResult = cmd.Deserialize(deserializeBuffer, &mWireCommandAllocator);\n\n        if (deserializeResult == WireResult::FatalError) {\n            return false;\n        }\n\n\n        ShaderModule* shaderModule = Get<ShaderModule>(cmd.shaderModule.id);\n        if (shaderModule != nullptr && shaderModule->GetWireGeneration() != cmd.shaderModule.generation) {\n            shaderModule = nullptr;\n        }\n\n        return DoShaderModuleGetCompilationInfoCallback(shaderModule, cmd.requestSerial, cmd.status, cmd.info);\n    }\n\n    const volatile char* Client::HandleCommandsImpl(const volatile char* commands, size_t size) {\n        DeserializeBuffer deserializeBuffer(commands, size);\n\n        while (deserializeBuffer.AvailableSize() >= sizeof(CmdHeader) + sizeof(ReturnWireCmd)) {\n            // Start by chunked command handling, if it is done, then it means the whole buffer\n            // was consumed by it, so we return a pointer to the end of the commands.\n            switch (HandleChunkedCommands(deserializeBuffer.Buffer(), deserializeBuffer.AvailableSize())) {\n                case ChunkedCommandsResult::Consumed:\n                    return commands + size;\n                case ChunkedCommandsResult::Error:\n                    return nullptr;\n                case ChunkedCommandsResult::Passthrough:\n                    break;\n            }\n\n            ReturnWireCmd cmdId = *static_cast<const volatile ReturnWireCmd*>(static_cast<const volatile void*>(\n                deserializeBuffer.Buffer() + sizeof(CmdHeader)));\n            bool success = false;\n            switch (cmdId) {\n                case ReturnWireCmd::AdapterRequestDeviceCallback:\n                    success = HandleAdapterRequestDeviceCallback(&deserializeBuffer);\n                    break;\n                case ReturnWireCmd::BufferMapAsyncCallback:\n                    success = HandleBufferMapAsyncCallback(&deserializeBuffer);\n                    break;\n                case ReturnWireCmd::DeviceCreateComputePipelineAsyncCallback:\n                    success = HandleDeviceCreateComputePipelineAsyncCallback(&deserializeBuffer);\n                    break;\n                case ReturnWireCmd::DeviceCreateRenderPipelineAsyncCallback:\n                    success = HandleDeviceCreateRenderPipelineAsyncCallback(&deserializeBuffer);\n                    break;\n                case ReturnWireCmd::DeviceLoggingCallback:\n                    success = HandleDeviceLoggingCallback(&deserializeBuffer);\n                    break;\n                case ReturnWireCmd::DeviceLostCallback:\n                    success = HandleDeviceLostCallback(&deserializeBuffer);\n                    break;\n                case ReturnWireCmd::DevicePopErrorScopeCallback:\n                    success = HandleDevicePopErrorScopeCallback(&deserializeBuffer);\n                    break;\n                case ReturnWireCmd::DeviceUncapturedErrorCallback:\n                    success = HandleDeviceUncapturedErrorCallback(&deserializeBuffer);\n                    break;\n                case ReturnWireCmd::InstanceRequestAdapterCallback:\n                    success = HandleInstanceRequestAdapterCallback(&deserializeBuffer);\n                    break;\n                case ReturnWireCmd::QueueWorkDoneCallback:\n                    success = HandleQueueWorkDoneCallback(&deserializeBuffer);\n                    break;\n                case ReturnWireCmd::ShaderModuleGetCompilationInfoCallback:\n                    success = HandleShaderModuleGetCompilationInfoCallback(&deserializeBuffer);\n                    break;\n                default:\n                    success = false;\n            }\n\n            if (!success) {\n                return nullptr;\n            }\n            mWireCommandAllocator.Reset();\n        }\n\n        if (deserializeBuffer.AvailableSize() != 0) {\n            return nullptr;\n        }\n\n        return commands;\n    }\n}  // namespace dawn::wire::client\n", "src/dawn/wire/client/ClientPrototypes_autogen.inc": "\nbool HandleAdapterRequestDeviceCallback(DeserializeBuffer* deserializeBuffer);\nbool HandleBufferMapAsyncCallback(DeserializeBuffer* deserializeBuffer);\nbool HandleDeviceCreateComputePipelineAsyncCallback(DeserializeBuffer* deserializeBuffer);\nbool HandleDeviceCreateRenderPipelineAsyncCallback(DeserializeBuffer* deserializeBuffer);\nbool HandleDeviceLoggingCallback(DeserializeBuffer* deserializeBuffer);\nbool HandleDeviceLostCallback(DeserializeBuffer* deserializeBuffer);\nbool HandleDevicePopErrorScopeCallback(DeserializeBuffer* deserializeBuffer);\nbool HandleDeviceUncapturedErrorCallback(DeserializeBuffer* deserializeBuffer);\nbool HandleInstanceRequestAdapterCallback(DeserializeBuffer* deserializeBuffer);\nbool HandleQueueWorkDoneCallback(DeserializeBuffer* deserializeBuffer);\nbool HandleShaderModuleGetCompilationInfoCallback(DeserializeBuffer* deserializeBuffer);\n\nbool DoAdapterRequestDeviceCallback(Adapter* adapter, uint64_t requestSerial, WGPURequestDeviceStatus status, char const * message, WGPUSupportedLimits const * limits, uint32_t featuresCount, WGPUFeatureName const * features);\nbool DoBufferMapAsyncCallback(Buffer* buffer, uint64_t requestSerial, uint32_t status, uint64_t readDataUpdateInfoLength, uint8_t const * readDataUpdateInfo);\nbool DoDeviceCreateComputePipelineAsyncCallback(Device* device, uint64_t requestSerial, WGPUCreatePipelineAsyncStatus status, char const * message);\nbool DoDeviceCreateRenderPipelineAsyncCallback(Device* device, uint64_t requestSerial, WGPUCreatePipelineAsyncStatus status, char const * message);\nbool DoDeviceLoggingCallback(Device* device, WGPULoggingType type, char const * message);\nbool DoDeviceLostCallback(Device* device, WGPUDeviceLostReason reason, char const * message);\nbool DoDevicePopErrorScopeCallback(Device* device, uint64_t requestSerial, WGPUErrorType type, char const * message);\nbool DoDeviceUncapturedErrorCallback(Device* device, WGPUErrorType type, char const * message);\nbool DoInstanceRequestAdapterCallback(Instance* instance, uint64_t requestSerial, WGPURequestAdapterStatus status, char const * message, WGPUAdapterProperties const * properties, WGPUSupportedLimits const * limits, uint32_t featuresCount, WGPUFeatureName const * features);\nbool DoQueueWorkDoneCallback(Queue* queue, uint64_t requestSerial, WGPUQueueWorkDoneStatus status);\nbool DoShaderModuleGetCompilationInfoCallback(ShaderModule* shaderModule, uint64_t requestSerial, WGPUCompilationInfoRequestStatus status, WGPUCompilationInfo const * info);\n", "src/dawn/wire/server/ServerBase_autogen.h": "\n#ifndef DAWNWIRE_SERVER_SERVERBASE_H_\n#define DAWNWIRE_SERVER_SERVERBASE_H_\n\n#include \"dawn/dawn_proc_table.h\"\n#include \"dawn/wire/ChunkedCommandHandler.h\"\n#include \"dawn/wire/Wire.h\"\n#include \"dawn/wire/WireCmd_autogen.h\"\n#include \"dawn/wire/WireDeserializeAllocator.h\"\n#include \"dawn/wire/server/ObjectStorage.h\"\n\nnamespace dawn::wire::server {\n\n    class ServerBase : public ChunkedCommandHandler, public ObjectIdResolver {\n      public:\n        ServerBase() = default;\n        ~ServerBase() override = default;\n\n      protected:\n        void DestroyAllObjects(const DawnProcTable& procs) {\n            {\n                std::vector<WGPUAdapter> handles = mKnownAdapter.AcquireAllHandles();\n                for (WGPUAdapter handle : handles) {\n                    procs.adapterRelease(handle);\n                }\n            }\n            {\n                std::vector<WGPUBindGroup> handles = mKnownBindGroup.AcquireAllHandles();\n                for (WGPUBindGroup handle : handles) {\n                    procs.bindGroupRelease(handle);\n                }\n            }\n            {\n                std::vector<WGPUBindGroupLayout> handles = mKnownBindGroupLayout.AcquireAllHandles();\n                for (WGPUBindGroupLayout handle : handles) {\n                    procs.bindGroupLayoutRelease(handle);\n                }\n            }\n            {\n                std::vector<WGPUBuffer> handles = mKnownBuffer.AcquireAllHandles();\n                for (WGPUBuffer handle : handles) {\n                    procs.bufferRelease(handle);\n                }\n            }\n            {\n                std::vector<WGPUCommandBuffer> handles = mKnownCommandBuffer.AcquireAllHandles();\n                for (WGPUCommandBuffer handle : handles) {\n                    procs.commandBufferRelease(handle);\n                }\n            }\n            {\n                std::vector<WGPUCommandEncoder> handles = mKnownCommandEncoder.AcquireAllHandles();\n                for (WGPUCommandEncoder handle : handles) {\n                    procs.commandEncoderRelease(handle);\n                }\n            }\n            {\n                std::vector<WGPUComputePassEncoder> handles = mKnownComputePassEncoder.AcquireAllHandles();\n                for (WGPUComputePassEncoder handle : handles) {\n                    procs.computePassEncoderRelease(handle);\n                }\n            }\n            {\n                std::vector<WGPUComputePipeline> handles = mKnownComputePipeline.AcquireAllHandles();\n                for (WGPUComputePipeline handle : handles) {\n                    procs.computePipelineRelease(handle);\n                }\n            }\n            {\n                std::vector<WGPUExternalTexture> handles = mKnownExternalTexture.AcquireAllHandles();\n                for (WGPUExternalTexture handle : handles) {\n                    procs.externalTextureRelease(handle);\n                }\n            }\n            {\n                std::vector<WGPUInstance> handles = mKnownInstance.AcquireAllHandles();\n                for (WGPUInstance handle : handles) {\n                    procs.instanceRelease(handle);\n                }\n            }\n            {\n                std::vector<WGPUPipelineLayout> handles = mKnownPipelineLayout.AcquireAllHandles();\n                for (WGPUPipelineLayout handle : handles) {\n                    procs.pipelineLayoutRelease(handle);\n                }\n            }\n            {\n                std::vector<WGPUQuerySet> handles = mKnownQuerySet.AcquireAllHandles();\n                for (WGPUQuerySet handle : handles) {\n                    procs.querySetRelease(handle);\n                }\n            }\n            {\n                std::vector<WGPUQueue> handles = mKnownQueue.AcquireAllHandles();\n                for (WGPUQueue handle : handles) {\n                    procs.queueRelease(handle);\n                }\n            }\n            {\n                std::vector<WGPURenderBundle> handles = mKnownRenderBundle.AcquireAllHandles();\n                for (WGPURenderBundle handle : handles) {\n                    procs.renderBundleRelease(handle);\n                }\n            }\n            {\n                std::vector<WGPURenderBundleEncoder> handles = mKnownRenderBundleEncoder.AcquireAllHandles();\n                for (WGPURenderBundleEncoder handle : handles) {\n                    procs.renderBundleEncoderRelease(handle);\n                }\n            }\n            {\n                std::vector<WGPURenderPassEncoder> handles = mKnownRenderPassEncoder.AcquireAllHandles();\n                for (WGPURenderPassEncoder handle : handles) {\n                    procs.renderPassEncoderRelease(handle);\n                }\n            }\n            {\n                std::vector<WGPURenderPipeline> handles = mKnownRenderPipeline.AcquireAllHandles();\n                for (WGPURenderPipeline handle : handles) {\n                    procs.renderPipelineRelease(handle);\n                }\n            }\n            {\n                std::vector<WGPUSampler> handles = mKnownSampler.AcquireAllHandles();\n                for (WGPUSampler handle : handles) {\n                    procs.samplerRelease(handle);\n                }\n            }\n            {\n                std::vector<WGPUShaderModule> handles = mKnownShaderModule.AcquireAllHandles();\n                for (WGPUShaderModule handle : handles) {\n                    procs.shaderModuleRelease(handle);\n                }\n            }\n            {\n                std::vector<WGPUSurface> handles = mKnownSurface.AcquireAllHandles();\n                for (WGPUSurface handle : handles) {\n                    procs.surfaceRelease(handle);\n                }\n            }\n            {\n                std::vector<WGPUSwapChain> handles = mKnownSwapChain.AcquireAllHandles();\n                for (WGPUSwapChain handle : handles) {\n                    procs.swapChainRelease(handle);\n                }\n            }\n            {\n                std::vector<WGPUTexture> handles = mKnownTexture.AcquireAllHandles();\n                for (WGPUTexture handle : handles) {\n                    procs.textureRelease(handle);\n                }\n            }\n            {\n                std::vector<WGPUTextureView> handles = mKnownTextureView.AcquireAllHandles();\n                for (WGPUTextureView handle : handles) {\n                    procs.textureViewRelease(handle);\n                }\n            }\n            {\n                std::vector<WGPUDevice> handles = mKnownDevice.AcquireAllHandles();\n                for (WGPUDevice handle : handles) {\n                    procs.deviceRelease(handle);\n                }\n            }\n        }\n\n        const KnownObjects<WGPUAdapter>& AdapterObjects() const {\n            return mKnownAdapter;\n        }\n        KnownObjects<WGPUAdapter>& AdapterObjects() {\n            return mKnownAdapter;\n        }\n        const KnownObjects<WGPUBindGroup>& BindGroupObjects() const {\n            return mKnownBindGroup;\n        }\n        KnownObjects<WGPUBindGroup>& BindGroupObjects() {\n            return mKnownBindGroup;\n        }\n        const KnownObjects<WGPUBindGroupLayout>& BindGroupLayoutObjects() const {\n            return mKnownBindGroupLayout;\n        }\n        KnownObjects<WGPUBindGroupLayout>& BindGroupLayoutObjects() {\n            return mKnownBindGroupLayout;\n        }\n        const KnownObjects<WGPUBuffer>& BufferObjects() const {\n            return mKnownBuffer;\n        }\n        KnownObjects<WGPUBuffer>& BufferObjects() {\n            return mKnownBuffer;\n        }\n        const KnownObjects<WGPUCommandBuffer>& CommandBufferObjects() const {\n            return mKnownCommandBuffer;\n        }\n        KnownObjects<WGPUCommandBuffer>& CommandBufferObjects() {\n            return mKnownCommandBuffer;\n        }\n        const KnownObjects<WGPUCommandEncoder>& CommandEncoderObjects() const {\n            return mKnownCommandEncoder;\n        }\n        KnownObjects<WGPUCommandEncoder>& CommandEncoderObjects() {\n            return mKnownCommandEncoder;\n        }\n        const KnownObjects<WGPUComputePassEncoder>& ComputePassEncoderObjects() const {\n            return mKnownComputePassEncoder;\n        }\n        KnownObjects<WGPUComputePassEncoder>& ComputePassEncoderObjects() {\n            return mKnownComputePassEncoder;\n        }\n        const KnownObjects<WGPUComputePipeline>& ComputePipelineObjects() const {\n            return mKnownComputePipeline;\n        }\n        KnownObjects<WGPUComputePipeline>& ComputePipelineObjects() {\n            return mKnownComputePipeline;\n        }\n        const KnownObjects<WGPUDevice>& DeviceObjects() const {\n            return mKnownDevice;\n        }\n        KnownObjects<WGPUDevice>& DeviceObjects() {\n            return mKnownDevice;\n        }\n        const KnownObjects<WGPUExternalTexture>& ExternalTextureObjects() const {\n            return mKnownExternalTexture;\n        }\n        KnownObjects<WGPUExternalTexture>& ExternalTextureObjects() {\n            return mKnownExternalTexture;\n        }\n        const KnownObjects<WGPUInstance>& InstanceObjects() const {\n            return mKnownInstance;\n        }\n        KnownObjects<WGPUInstance>& InstanceObjects() {\n            return mKnownInstance;\n        }\n        const KnownObjects<WGPUPipelineLayout>& PipelineLayoutObjects() const {\n            return mKnownPipelineLayout;\n        }\n        KnownObjects<WGPUPipelineLayout>& PipelineLayoutObjects() {\n            return mKnownPipelineLayout;\n        }\n        const KnownObjects<WGPUQuerySet>& QuerySetObjects() const {\n            return mKnownQuerySet;\n        }\n        KnownObjects<WGPUQuerySet>& QuerySetObjects() {\n            return mKnownQuerySet;\n        }\n        const KnownObjects<WGPUQueue>& QueueObjects() const {\n            return mKnownQueue;\n        }\n        KnownObjects<WGPUQueue>& QueueObjects() {\n            return mKnownQueue;\n        }\n        const KnownObjects<WGPURenderBundle>& RenderBundleObjects() const {\n            return mKnownRenderBundle;\n        }\n        KnownObjects<WGPURenderBundle>& RenderBundleObjects() {\n            return mKnownRenderBundle;\n        }\n        const KnownObjects<WGPURenderBundleEncoder>& RenderBundleEncoderObjects() const {\n            return mKnownRenderBundleEncoder;\n        }\n        KnownObjects<WGPURenderBundleEncoder>& RenderBundleEncoderObjects() {\n            return mKnownRenderBundleEncoder;\n        }\n        const KnownObjects<WGPURenderPassEncoder>& RenderPassEncoderObjects() const {\n            return mKnownRenderPassEncoder;\n        }\n        KnownObjects<WGPURenderPassEncoder>& RenderPassEncoderObjects() {\n            return mKnownRenderPassEncoder;\n        }\n        const KnownObjects<WGPURenderPipeline>& RenderPipelineObjects() const {\n            return mKnownRenderPipeline;\n        }\n        KnownObjects<WGPURenderPipeline>& RenderPipelineObjects() {\n            return mKnownRenderPipeline;\n        }\n        const KnownObjects<WGPUSampler>& SamplerObjects() const {\n            return mKnownSampler;\n        }\n        KnownObjects<WGPUSampler>& SamplerObjects() {\n            return mKnownSampler;\n        }\n        const KnownObjects<WGPUShaderModule>& ShaderModuleObjects() const {\n            return mKnownShaderModule;\n        }\n        KnownObjects<WGPUShaderModule>& ShaderModuleObjects() {\n            return mKnownShaderModule;\n        }\n        const KnownObjects<WGPUSurface>& SurfaceObjects() const {\n            return mKnownSurface;\n        }\n        KnownObjects<WGPUSurface>& SurfaceObjects() {\n            return mKnownSurface;\n        }\n        const KnownObjects<WGPUSwapChain>& SwapChainObjects() const {\n            return mKnownSwapChain;\n        }\n        KnownObjects<WGPUSwapChain>& SwapChainObjects() {\n            return mKnownSwapChain;\n        }\n        const KnownObjects<WGPUTexture>& TextureObjects() const {\n            return mKnownTexture;\n        }\n        KnownObjects<WGPUTexture>& TextureObjects() {\n            return mKnownTexture;\n        }\n        const KnownObjects<WGPUTextureView>& TextureViewObjects() const {\n            return mKnownTextureView;\n        }\n        KnownObjects<WGPUTextureView>& TextureViewObjects() {\n            return mKnownTextureView;\n        }\n\n\n      private:\n        // Implementation of the ObjectIdResolver interface\n        WireResult GetFromId(ObjectId id, WGPUAdapter* out) const final {\n            auto data = mKnownAdapter.Get(id);\n            if (data == nullptr) {\n                return WireResult::FatalError;\n            }\n\n            *out = data->handle;\n            return WireResult::Success;\n        }\n\n        WireResult GetOptionalFromId(ObjectId id, WGPUAdapter* out) const final {\n            if (id == 0) {\n                *out = nullptr;\n                return WireResult::Success;\n            }\n\n            return GetFromId(id, out);\n        }\n        WireResult GetFromId(ObjectId id, WGPUBindGroup* out) const final {\n            auto data = mKnownBindGroup.Get(id);\n            if (data == nullptr) {\n                return WireResult::FatalError;\n            }\n\n            *out = data->handle;\n            return WireResult::Success;\n        }\n\n        WireResult GetOptionalFromId(ObjectId id, WGPUBindGroup* out) const final {\n            if (id == 0) {\n                *out = nullptr;\n                return WireResult::Success;\n            }\n\n            return GetFromId(id, out);\n        }\n        WireResult GetFromId(ObjectId id, WGPUBindGroupLayout* out) const final {\n            auto data = mKnownBindGroupLayout.Get(id);\n            if (data == nullptr) {\n                return WireResult::FatalError;\n            }\n\n            *out = data->handle;\n            return WireResult::Success;\n        }\n\n        WireResult GetOptionalFromId(ObjectId id, WGPUBindGroupLayout* out) const final {\n            if (id == 0) {\n                *out = nullptr;\n                return WireResult::Success;\n            }\n\n            return GetFromId(id, out);\n        }\n        WireResult GetFromId(ObjectId id, WGPUBuffer* out) const final {\n            auto data = mKnownBuffer.Get(id);\n            if (data == nullptr) {\n                return WireResult::FatalError;\n            }\n\n            *out = data->handle;\n            return WireResult::Success;\n        }\n\n        WireResult GetOptionalFromId(ObjectId id, WGPUBuffer* out) const final {\n            if (id == 0) {\n                *out = nullptr;\n                return WireResult::Success;\n            }\n\n            return GetFromId(id, out);\n        }\n        WireResult GetFromId(ObjectId id, WGPUCommandBuffer* out) const final {\n            auto data = mKnownCommandBuffer.Get(id);\n            if (data == nullptr) {\n                return WireResult::FatalError;\n            }\n\n            *out = data->handle;\n            return WireResult::Success;\n        }\n\n        WireResult GetOptionalFromId(ObjectId id, WGPUCommandBuffer* out) const final {\n            if (id == 0) {\n                *out = nullptr;\n                return WireResult::Success;\n            }\n\n            return GetFromId(id, out);\n        }\n        WireResult GetFromId(ObjectId id, WGPUCommandEncoder* out) const final {\n            auto data = mKnownCommandEncoder.Get(id);\n            if (data == nullptr) {\n                return WireResult::FatalError;\n            }\n\n            *out = data->handle;\n            return WireResult::Success;\n        }\n\n        WireResult GetOptionalFromId(ObjectId id, WGPUCommandEncoder* out) const final {\n            if (id == 0) {\n                *out = nullptr;\n                return WireResult::Success;\n            }\n\n            return GetFromId(id, out);\n        }\n        WireResult GetFromId(ObjectId id, WGPUComputePassEncoder* out) const final {\n            auto data = mKnownComputePassEncoder.Get(id);\n            if (data == nullptr) {\n                return WireResult::FatalError;\n            }\n\n            *out = data->handle;\n            return WireResult::Success;\n        }\n\n        WireResult GetOptionalFromId(ObjectId id, WGPUComputePassEncoder* out) const final {\n            if (id == 0) {\n                *out = nullptr;\n                return WireResult::Success;\n            }\n\n            return GetFromId(id, out);\n        }\n        WireResult GetFromId(ObjectId id, WGPUComputePipeline* out) const final {\n            auto data = mKnownComputePipeline.Get(id);\n            if (data == nullptr) {\n                return WireResult::FatalError;\n            }\n\n            *out = data->handle;\n            return WireResult::Success;\n        }\n\n        WireResult GetOptionalFromId(ObjectId id, WGPUComputePipeline* out) const final {\n            if (id == 0) {\n                *out = nullptr;\n                return WireResult::Success;\n            }\n\n            return GetFromId(id, out);\n        }\n        WireResult GetFromId(ObjectId id, WGPUDevice* out) const final {\n            auto data = mKnownDevice.Get(id);\n            if (data == nullptr) {\n                return WireResult::FatalError;\n            }\n\n            *out = data->handle;\n            return WireResult::Success;\n        }\n\n        WireResult GetOptionalFromId(ObjectId id, WGPUDevice* out) const final {\n            if (id == 0) {\n                *out = nullptr;\n                return WireResult::Success;\n            }\n\n            return GetFromId(id, out);\n        }\n        WireResult GetFromId(ObjectId id, WGPUExternalTexture* out) const final {\n            auto data = mKnownExternalTexture.Get(id);\n            if (data == nullptr) {\n                return WireResult::FatalError;\n            }\n\n            *out = data->handle;\n            return WireResult::Success;\n        }\n\n        WireResult GetOptionalFromId(ObjectId id, WGPUExternalTexture* out) const final {\n            if (id == 0) {\n                *out = nullptr;\n                return WireResult::Success;\n            }\n\n            return GetFromId(id, out);\n        }\n        WireResult GetFromId(ObjectId id, WGPUInstance* out) const final {\n            auto data = mKnownInstance.Get(id);\n            if (data == nullptr) {\n                return WireResult::FatalError;\n            }\n\n            *out = data->handle;\n            return WireResult::Success;\n        }\n\n        WireResult GetOptionalFromId(ObjectId id, WGPUInstance* out) const final {\n            if (id == 0) {\n                *out = nullptr;\n                return WireResult::Success;\n            }\n\n            return GetFromId(id, out);\n        }\n        WireResult GetFromId(ObjectId id, WGPUPipelineLayout* out) const final {\n            auto data = mKnownPipelineLayout.Get(id);\n            if (data == nullptr) {\n                return WireResult::FatalError;\n            }\n\n            *out = data->handle;\n            return WireResult::Success;\n        }\n\n        WireResult GetOptionalFromId(ObjectId id, WGPUPipelineLayout* out) const final {\n            if (id == 0) {\n                *out = nullptr;\n                return WireResult::Success;\n            }\n\n            return GetFromId(id, out);\n        }\n        WireResult GetFromId(ObjectId id, WGPUQuerySet* out) const final {\n            auto data = mKnownQuerySet.Get(id);\n            if (data == nullptr) {\n                return WireResult::FatalError;\n            }\n\n            *out = data->handle;\n            return WireResult::Success;\n        }\n\n        WireResult GetOptionalFromId(ObjectId id, WGPUQuerySet* out) const final {\n            if (id == 0) {\n                *out = nullptr;\n                return WireResult::Success;\n            }\n\n            return GetFromId(id, out);\n        }\n        WireResult GetFromId(ObjectId id, WGPUQueue* out) const final {\n            auto data = mKnownQueue.Get(id);\n            if (data == nullptr) {\n                return WireResult::FatalError;\n            }\n\n            *out = data->handle;\n            return WireResult::Success;\n        }\n\n        WireResult GetOptionalFromId(ObjectId id, WGPUQueue* out) const final {\n            if (id == 0) {\n                *out = nullptr;\n                return WireResult::Success;\n            }\n\n            return GetFromId(id, out);\n        }\n        WireResult GetFromId(ObjectId id, WGPURenderBundle* out) const final {\n            auto data = mKnownRenderBundle.Get(id);\n            if (data == nullptr) {\n                return WireResult::FatalError;\n            }\n\n            *out = data->handle;\n            return WireResult::Success;\n        }\n\n        WireResult GetOptionalFromId(ObjectId id, WGPURenderBundle* out) const final {\n            if (id == 0) {\n                *out = nullptr;\n                return WireResult::Success;\n            }\n\n            return GetFromId(id, out);\n        }\n        WireResult GetFromId(ObjectId id, WGPURenderBundleEncoder* out) const final {\n            auto data = mKnownRenderBundleEncoder.Get(id);\n            if (data == nullptr) {\n                return WireResult::FatalError;\n            }\n\n            *out = data->handle;\n            return WireResult::Success;\n        }\n\n        WireResult GetOptionalFromId(ObjectId id, WGPURenderBundleEncoder* out) const final {\n            if (id == 0) {\n                *out = nullptr;\n                return WireResult::Success;\n            }\n\n            return GetFromId(id, out);\n        }\n        WireResult GetFromId(ObjectId id, WGPURenderPassEncoder* out) const final {\n            auto data = mKnownRenderPassEncoder.Get(id);\n            if (data == nullptr) {\n                return WireResult::FatalError;\n            }\n\n            *out = data->handle;\n            return WireResult::Success;\n        }\n\n        WireResult GetOptionalFromId(ObjectId id, WGPURenderPassEncoder* out) const final {\n            if (id == 0) {\n                *out = nullptr;\n                return WireResult::Success;\n            }\n\n            return GetFromId(id, out);\n        }\n        WireResult GetFromId(ObjectId id, WGPURenderPipeline* out) const final {\n            auto data = mKnownRenderPipeline.Get(id);\n            if (data == nullptr) {\n                return WireResult::FatalError;\n            }\n\n            *out = data->handle;\n            return WireResult::Success;\n        }\n\n        WireResult GetOptionalFromId(ObjectId id, WGPURenderPipeline* out) const final {\n            if (id == 0) {\n                *out = nullptr;\n                return WireResult::Success;\n            }\n\n            return GetFromId(id, out);\n        }\n        WireResult GetFromId(ObjectId id, WGPUSampler* out) const final {\n            auto data = mKnownSampler.Get(id);\n            if (data == nullptr) {\n                return WireResult::FatalError;\n            }\n\n            *out = data->handle;\n            return WireResult::Success;\n        }\n\n        WireResult GetOptionalFromId(ObjectId id, WGPUSampler* out) const final {\n            if (id == 0) {\n                *out = nullptr;\n                return WireResult::Success;\n            }\n\n            return GetFromId(id, out);\n        }\n        WireResult GetFromId(ObjectId id, WGPUShaderModule* out) const final {\n            auto data = mKnownShaderModule.Get(id);\n            if (data == nullptr) {\n                return WireResult::FatalError;\n            }\n\n            *out = data->handle;\n            return WireResult::Success;\n        }\n\n        WireResult GetOptionalFromId(ObjectId id, WGPUShaderModule* out) const final {\n            if (id == 0) {\n                *out = nullptr;\n                return WireResult::Success;\n            }\n\n            return GetFromId(id, out);\n        }\n        WireResult GetFromId(ObjectId id, WGPUSurface* out) const final {\n            auto data = mKnownSurface.Get(id);\n            if (data == nullptr) {\n                return WireResult::FatalError;\n            }\n\n            *out = data->handle;\n            return WireResult::Success;\n        }\n\n        WireResult GetOptionalFromId(ObjectId id, WGPUSurface* out) const final {\n            if (id == 0) {\n                *out = nullptr;\n                return WireResult::Success;\n            }\n\n            return GetFromId(id, out);\n        }\n        WireResult GetFromId(ObjectId id, WGPUSwapChain* out) const final {\n            auto data = mKnownSwapChain.Get(id);\n            if (data == nullptr) {\n                return WireResult::FatalError;\n            }\n\n            *out = data->handle;\n            return WireResult::Success;\n        }\n\n        WireResult GetOptionalFromId(ObjectId id, WGPUSwapChain* out) const final {\n            if (id == 0) {\n                *out = nullptr;\n                return WireResult::Success;\n            }\n\n            return GetFromId(id, out);\n        }\n        WireResult GetFromId(ObjectId id, WGPUTexture* out) const final {\n            auto data = mKnownTexture.Get(id);\n            if (data == nullptr) {\n                return WireResult::FatalError;\n            }\n\n            *out = data->handle;\n            return WireResult::Success;\n        }\n\n        WireResult GetOptionalFromId(ObjectId id, WGPUTexture* out) const final {\n            if (id == 0) {\n                *out = nullptr;\n                return WireResult::Success;\n            }\n\n            return GetFromId(id, out);\n        }\n        WireResult GetFromId(ObjectId id, WGPUTextureView* out) const final {\n            auto data = mKnownTextureView.Get(id);\n            if (data == nullptr) {\n                return WireResult::FatalError;\n            }\n\n            *out = data->handle;\n            return WireResult::Success;\n        }\n\n        WireResult GetOptionalFromId(ObjectId id, WGPUTextureView* out) const final {\n            if (id == 0) {\n                *out = nullptr;\n                return WireResult::Success;\n            }\n\n            return GetFromId(id, out);\n        }\n\n        KnownObjects<WGPUAdapter> mKnownAdapter;\n        KnownObjects<WGPUBindGroup> mKnownBindGroup;\n        KnownObjects<WGPUBindGroupLayout> mKnownBindGroupLayout;\n        KnownObjects<WGPUBuffer> mKnownBuffer;\n        KnownObjects<WGPUCommandBuffer> mKnownCommandBuffer;\n        KnownObjects<WGPUCommandEncoder> mKnownCommandEncoder;\n        KnownObjects<WGPUComputePassEncoder> mKnownComputePassEncoder;\n        KnownObjects<WGPUComputePipeline> mKnownComputePipeline;\n        KnownObjects<WGPUDevice> mKnownDevice;\n        KnownObjects<WGPUExternalTexture> mKnownExternalTexture;\n        KnownObjects<WGPUInstance> mKnownInstance;\n        KnownObjects<WGPUPipelineLayout> mKnownPipelineLayout;\n        KnownObjects<WGPUQuerySet> mKnownQuerySet;\n        KnownObjects<WGPUQueue> mKnownQueue;\n        KnownObjects<WGPURenderBundle> mKnownRenderBundle;\n        KnownObjects<WGPURenderBundleEncoder> mKnownRenderBundleEncoder;\n        KnownObjects<WGPURenderPassEncoder> mKnownRenderPassEncoder;\n        KnownObjects<WGPURenderPipeline> mKnownRenderPipeline;\n        KnownObjects<WGPUSampler> mKnownSampler;\n        KnownObjects<WGPUShaderModule> mKnownShaderModule;\n        KnownObjects<WGPUSurface> mKnownSurface;\n        KnownObjects<WGPUSwapChain> mKnownSwapChain;\n        KnownObjects<WGPUTexture> mKnownTexture;\n        KnownObjects<WGPUTextureView> mKnownTextureView;\n\n    };\n\n}  // namespace dawn::wire::server\n\n#endif  // DAWNWIRE_SERVER_SERVERBASE_H_\n", "src/dawn/wire/server/ServerDoers_autogen.cpp": "\n#include \"dawn/common/Assert.h\"\n#include \"dawn/wire/server/Server.h\"\n\nnamespace dawn::wire::server {\n\n\n    bool Server::DoBindGroupLayoutSetLabel(WGPUBindGroupLayout self, char const * label) {\n        \n        mProcs.bindGroupLayoutSetLabel(self, label);\n        return true;\n    }\n\n    bool Server::DoBindGroupSetLabel(WGPUBindGroup self, char const * label) {\n        \n        mProcs.bindGroupSetLabel(self, label);\n        return true;\n    }\n\n    bool Server::DoBufferDestroy(WGPUBuffer self) {\n        \n        mProcs.bufferDestroy(self);\n        return true;\n    }\n\n\n    bool Server::DoBufferSetLabel(WGPUBuffer self, char const * label) {\n        \n        mProcs.bufferSetLabel(self, label);\n        return true;\n    }\n\n    bool Server::DoBufferUnmap(WGPUBuffer self) {\n        \n        mProcs.bufferUnmap(self);\n        return true;\n    }\n\n\n    bool Server::DoCommandBufferSetLabel(WGPUCommandBuffer self, char const * label) {\n        \n        mProcs.commandBufferSetLabel(self, label);\n        return true;\n    }\n\n    bool Server::DoCommandEncoderBeginComputePass(WGPUCommandEncoder self, WGPUComputePassDescriptor const * descriptor, WGPUComputePassEncoder* result) {\n        *result =\n        mProcs.commandEncoderBeginComputePass(self, descriptor);\n        ASSERT(*result != nullptr);\n        return true;\n    }\n\n    bool Server::DoCommandEncoderBeginRenderPass(WGPUCommandEncoder self, WGPURenderPassDescriptor const * descriptor, WGPURenderPassEncoder* result) {\n        *result =\n        mProcs.commandEncoderBeginRenderPass(self, descriptor);\n        ASSERT(*result != nullptr);\n        return true;\n    }\n\n    bool Server::DoCommandEncoderClearBuffer(WGPUCommandEncoder self, WGPUBuffer buffer, uint64_t offset, uint64_t size) {\n        \n        mProcs.commandEncoderClearBuffer(self, buffer, offset, size);\n        return true;\n    }\n\n    bool Server::DoCommandEncoderCopyBufferToBuffer(WGPUCommandEncoder self, WGPUBuffer source, uint64_t sourceOffset, WGPUBuffer destination, uint64_t destinationOffset, uint64_t size) {\n        \n        mProcs.commandEncoderCopyBufferToBuffer(self, source, sourceOffset, destination, destinationOffset, size);\n        return true;\n    }\n\n    bool Server::DoCommandEncoderCopyBufferToTexture(WGPUCommandEncoder self, WGPUImageCopyBuffer const * source, WGPUImageCopyTexture const * destination, WGPUExtent3D const * copySize) {\n        \n        mProcs.commandEncoderCopyBufferToTexture(self, source, destination, copySize);\n        return true;\n    }\n\n    bool Server::DoCommandEncoderCopyTextureToBuffer(WGPUCommandEncoder self, WGPUImageCopyTexture const * source, WGPUImageCopyBuffer const * destination, WGPUExtent3D const * copySize) {\n        \n        mProcs.commandEncoderCopyTextureToBuffer(self, source, destination, copySize);\n        return true;\n    }\n\n    bool Server::DoCommandEncoderCopyTextureToTexture(WGPUCommandEncoder self, WGPUImageCopyTexture const * source, WGPUImageCopyTexture const * destination, WGPUExtent3D const * copySize) {\n        \n        mProcs.commandEncoderCopyTextureToTexture(self, source, destination, copySize);\n        return true;\n    }\n\n    bool Server::DoCommandEncoderCopyTextureToTextureInternal(WGPUCommandEncoder self, WGPUImageCopyTexture const * source, WGPUImageCopyTexture const * destination, WGPUExtent3D const * copySize) {\n        \n        mProcs.commandEncoderCopyTextureToTextureInternal(self, source, destination, copySize);\n        return true;\n    }\n\n    bool Server::DoCommandEncoderFinish(WGPUCommandEncoder self, WGPUCommandBufferDescriptor const * descriptor, WGPUCommandBuffer* result) {\n        *result =\n        mProcs.commandEncoderFinish(self, descriptor);\n        ASSERT(*result != nullptr);\n        return true;\n    }\n\n    bool Server::DoCommandEncoderInjectValidationError(WGPUCommandEncoder self, char const * message) {\n        \n        mProcs.commandEncoderInjectValidationError(self, message);\n        return true;\n    }\n\n    bool Server::DoCommandEncoderInsertDebugMarker(WGPUCommandEncoder self, char const * markerLabel) {\n        \n        mProcs.commandEncoderInsertDebugMarker(self, markerLabel);\n        return true;\n    }\n\n    bool Server::DoCommandEncoderPopDebugGroup(WGPUCommandEncoder self) {\n        \n        mProcs.commandEncoderPopDebugGroup(self);\n        return true;\n    }\n\n    bool Server::DoCommandEncoderPushDebugGroup(WGPUCommandEncoder self, char const * groupLabel) {\n        \n        mProcs.commandEncoderPushDebugGroup(self, groupLabel);\n        return true;\n    }\n\n    bool Server::DoCommandEncoderResolveQuerySet(WGPUCommandEncoder self, WGPUQuerySet querySet, uint32_t firstQuery, uint32_t queryCount, WGPUBuffer destination, uint64_t destinationOffset) {\n        \n        mProcs.commandEncoderResolveQuerySet(self, querySet, firstQuery, queryCount, destination, destinationOffset);\n        return true;\n    }\n\n    bool Server::DoCommandEncoderSetLabel(WGPUCommandEncoder self, char const * label) {\n        \n        mProcs.commandEncoderSetLabel(self, label);\n        return true;\n    }\n\n    bool Server::DoCommandEncoderWriteBuffer(WGPUCommandEncoder self, WGPUBuffer buffer, uint64_t bufferOffset, uint8_t const * data, uint64_t size) {\n        \n        mProcs.commandEncoderWriteBuffer(self, buffer, bufferOffset, data, size);\n        return true;\n    }\n\n    bool Server::DoCommandEncoderWriteTimestamp(WGPUCommandEncoder self, WGPUQuerySet querySet, uint32_t queryIndex) {\n        \n        mProcs.commandEncoderWriteTimestamp(self, querySet, queryIndex);\n        return true;\n    }\n\n    bool Server::DoComputePassEncoderDispatch(WGPUComputePassEncoder self, uint32_t workgroupCountX, uint32_t workgroupCountY, uint32_t workgroupCountZ) {\n        \n        mProcs.computePassEncoderDispatch(self, workgroupCountX, workgroupCountY, workgroupCountZ);\n        return true;\n    }\n\n    bool Server::DoComputePassEncoderDispatchIndirect(WGPUComputePassEncoder self, WGPUBuffer indirectBuffer, uint64_t indirectOffset) {\n        \n        mProcs.computePassEncoderDispatchIndirect(self, indirectBuffer, indirectOffset);\n        return true;\n    }\n\n    bool Server::DoComputePassEncoderDispatchWorkgroups(WGPUComputePassEncoder self, uint32_t workgroupCountX, uint32_t workgroupCountY, uint32_t workgroupCountZ) {\n        \n        mProcs.computePassEncoderDispatchWorkgroups(self, workgroupCountX, workgroupCountY, workgroupCountZ);\n        return true;\n    }\n\n    bool Server::DoComputePassEncoderDispatchWorkgroupsIndirect(WGPUComputePassEncoder self, WGPUBuffer indirectBuffer, uint64_t indirectOffset) {\n        \n        mProcs.computePassEncoderDispatchWorkgroupsIndirect(self, indirectBuffer, indirectOffset);\n        return true;\n    }\n\n    bool Server::DoComputePassEncoderEnd(WGPUComputePassEncoder self) {\n        \n        mProcs.computePassEncoderEnd(self);\n        return true;\n    }\n\n    bool Server::DoComputePassEncoderEndPass(WGPUComputePassEncoder self) {\n        \n        mProcs.computePassEncoderEndPass(self);\n        return true;\n    }\n\n    bool Server::DoComputePassEncoderInsertDebugMarker(WGPUComputePassEncoder self, char const * markerLabel) {\n        \n        mProcs.computePassEncoderInsertDebugMarker(self, markerLabel);\n        return true;\n    }\n\n    bool Server::DoComputePassEncoderPopDebugGroup(WGPUComputePassEncoder self) {\n        \n        mProcs.computePassEncoderPopDebugGroup(self);\n        return true;\n    }\n\n    bool Server::DoComputePassEncoderPushDebugGroup(WGPUComputePassEncoder self, char const * groupLabel) {\n        \n        mProcs.computePassEncoderPushDebugGroup(self, groupLabel);\n        return true;\n    }\n\n    bool Server::DoComputePassEncoderSetBindGroup(WGPUComputePassEncoder self, uint32_t groupIndex, WGPUBindGroup group, uint32_t dynamicOffsetCount, uint32_t const * dynamicOffsets) {\n        \n        mProcs.computePassEncoderSetBindGroup(self, groupIndex, group, dynamicOffsetCount, dynamicOffsets);\n        return true;\n    }\n\n    bool Server::DoComputePassEncoderSetLabel(WGPUComputePassEncoder self, char const * label) {\n        \n        mProcs.computePassEncoderSetLabel(self, label);\n        return true;\n    }\n\n    bool Server::DoComputePassEncoderSetPipeline(WGPUComputePassEncoder self, WGPUComputePipeline pipeline) {\n        \n        mProcs.computePassEncoderSetPipeline(self, pipeline);\n        return true;\n    }\n\n    bool Server::DoComputePassEncoderWriteTimestamp(WGPUComputePassEncoder self, WGPUQuerySet querySet, uint32_t queryIndex) {\n        \n        mProcs.computePassEncoderWriteTimestamp(self, querySet, queryIndex);\n        return true;\n    }\n\n    bool Server::DoComputePipelineGetBindGroupLayout(WGPUComputePipeline self, uint32_t groupIndex, WGPUBindGroupLayout* result) {\n        *result =\n        mProcs.computePipelineGetBindGroupLayout(self, groupIndex);\n        ASSERT(*result != nullptr);\n        return true;\n    }\n\n    bool Server::DoComputePipelineSetLabel(WGPUComputePipeline self, char const * label) {\n        \n        mProcs.computePipelineSetLabel(self, label);\n        return true;\n    }\n\n\n    bool Server::DoDeviceCreateBindGroup(WGPUDevice self, WGPUBindGroupDescriptor const * descriptor, WGPUBindGroup* result) {\n        *result =\n        mProcs.deviceCreateBindGroup(self, descriptor);\n        ASSERT(*result != nullptr);\n        return true;\n    }\n\n    bool Server::DoDeviceCreateBindGroupLayout(WGPUDevice self, WGPUBindGroupLayoutDescriptor const * descriptor, WGPUBindGroupLayout* result) {\n        *result =\n        mProcs.deviceCreateBindGroupLayout(self, descriptor);\n        ASSERT(*result != nullptr);\n        return true;\n    }\n\n\n    bool Server::DoDeviceCreateCommandEncoder(WGPUDevice self, WGPUCommandEncoderDescriptor const * descriptor, WGPUCommandEncoder* result) {\n        *result =\n        mProcs.deviceCreateCommandEncoder(self, descriptor);\n        ASSERT(*result != nullptr);\n        return true;\n    }\n\n    bool Server::DoDeviceCreateComputePipeline(WGPUDevice self, WGPUComputePipelineDescriptor const * descriptor, WGPUComputePipeline* result) {\n        *result =\n        mProcs.deviceCreateComputePipeline(self, descriptor);\n        ASSERT(*result != nullptr);\n        return true;\n    }\n\n\n    bool Server::DoDeviceCreateErrorBuffer(WGPUDevice self, WGPUBuffer* result) {\n        *result =\n        mProcs.deviceCreateErrorBuffer(self);\n        ASSERT(*result != nullptr);\n        return true;\n    }\n\n    bool Server::DoDeviceCreateErrorExternalTexture(WGPUDevice self, WGPUExternalTexture* result) {\n        *result =\n        mProcs.deviceCreateErrorExternalTexture(self);\n        ASSERT(*result != nullptr);\n        return true;\n    }\n\n    bool Server::DoDeviceCreateErrorTexture(WGPUDevice self, WGPUTextureDescriptor const * descriptor, WGPUTexture* result) {\n        *result =\n        mProcs.deviceCreateErrorTexture(self, descriptor);\n        ASSERT(*result != nullptr);\n        return true;\n    }\n\n    bool Server::DoDeviceCreateExternalTexture(WGPUDevice self, WGPUExternalTextureDescriptor const * externalTextureDescriptor, WGPUExternalTexture* result) {\n        *result =\n        mProcs.deviceCreateExternalTexture(self, externalTextureDescriptor);\n        ASSERT(*result != nullptr);\n        return true;\n    }\n\n    bool Server::DoDeviceCreatePipelineLayout(WGPUDevice self, WGPUPipelineLayoutDescriptor const * descriptor, WGPUPipelineLayout* result) {\n        *result =\n        mProcs.deviceCreatePipelineLayout(self, descriptor);\n        ASSERT(*result != nullptr);\n        return true;\n    }\n\n    bool Server::DoDeviceCreateQuerySet(WGPUDevice self, WGPUQuerySetDescriptor const * descriptor, WGPUQuerySet* result) {\n        *result =\n        mProcs.deviceCreateQuerySet(self, descriptor);\n        ASSERT(*result != nullptr);\n        return true;\n    }\n\n    bool Server::DoDeviceCreateRenderBundleEncoder(WGPUDevice self, WGPURenderBundleEncoderDescriptor const * descriptor, WGPURenderBundleEncoder* result) {\n        *result =\n        mProcs.deviceCreateRenderBundleEncoder(self, descriptor);\n        ASSERT(*result != nullptr);\n        return true;\n    }\n\n    bool Server::DoDeviceCreateRenderPipeline(WGPUDevice self, WGPURenderPipelineDescriptor const * descriptor, WGPURenderPipeline* result) {\n        *result =\n        mProcs.deviceCreateRenderPipeline(self, descriptor);\n        ASSERT(*result != nullptr);\n        return true;\n    }\n\n\n    bool Server::DoDeviceCreateSampler(WGPUDevice self, WGPUSamplerDescriptor const * descriptor, WGPUSampler* result) {\n        *result =\n        mProcs.deviceCreateSampler(self, descriptor);\n        ASSERT(*result != nullptr);\n        return true;\n    }\n\n    bool Server::DoDeviceCreateShaderModule(WGPUDevice self, WGPUShaderModuleDescriptor const * descriptor, WGPUShaderModule* result) {\n        *result =\n        mProcs.deviceCreateShaderModule(self, descriptor);\n        ASSERT(*result != nullptr);\n        return true;\n    }\n\n    bool Server::DoDeviceCreateSwapChain(WGPUDevice self, WGPUSurface surface, WGPUSwapChainDescriptor const * descriptor, WGPUSwapChain* result) {\n        *result =\n        mProcs.deviceCreateSwapChain(self, surface, descriptor);\n        ASSERT(*result != nullptr);\n        return true;\n    }\n\n    bool Server::DoDeviceCreateTexture(WGPUDevice self, WGPUTextureDescriptor const * descriptor, WGPUTexture* result) {\n        *result =\n        mProcs.deviceCreateTexture(self, descriptor);\n        ASSERT(*result != nullptr);\n        return true;\n    }\n\n    bool Server::DoDeviceDestroy(WGPUDevice self) {\n        \n        mProcs.deviceDestroy(self);\n        return true;\n    }\n\n    bool Server::DoDeviceGetQueue(WGPUDevice self, WGPUQueue* result) {\n        *result =\n        mProcs.deviceGetQueue(self);\n        ASSERT(*result != nullptr);\n        return true;\n    }\n\n    bool Server::DoDeviceInjectError(WGPUDevice self, WGPUErrorType type, char const * message) {\n        \n        mProcs.deviceInjectError(self, type, message);\n        return true;\n    }\n\n    bool Server::DoDeviceLoseForTesting(WGPUDevice self) {\n        \n        mProcs.deviceLoseForTesting(self);\n        return true;\n    }\n\n\n    bool Server::DoDevicePushErrorScope(WGPUDevice self, WGPUErrorFilter filter) {\n        \n        mProcs.devicePushErrorScope(self, filter);\n        return true;\n    }\n\n    bool Server::DoDeviceSetLabel(WGPUDevice self, char const * label) {\n        \n        mProcs.deviceSetLabel(self, label);\n        return true;\n    }\n\n    bool Server::DoDeviceTick(WGPUDevice self) {\n        \n        mProcs.deviceTick(self);\n        return true;\n    }\n\n    bool Server::DoExternalTextureDestroy(WGPUExternalTexture self) {\n        \n        mProcs.externalTextureDestroy(self);\n        return true;\n    }\n\n    bool Server::DoExternalTextureSetLabel(WGPUExternalTexture self, char const * label) {\n        \n        mProcs.externalTextureSetLabel(self, label);\n        return true;\n    }\n\n    bool Server::DoInstanceCreateSurface(WGPUInstance self, WGPUSurfaceDescriptor const * descriptor, WGPUSurface* result) {\n        *result =\n        mProcs.instanceCreateSurface(self, descriptor);\n        ASSERT(*result != nullptr);\n        return true;\n    }\n\n\n    bool Server::DoPipelineLayoutSetLabel(WGPUPipelineLayout self, char const * label) {\n        \n        mProcs.pipelineLayoutSetLabel(self, label);\n        return true;\n    }\n\n    bool Server::DoQuerySetDestroy(WGPUQuerySet self) {\n        \n        mProcs.querySetDestroy(self);\n        return true;\n    }\n\n    bool Server::DoQuerySetSetLabel(WGPUQuerySet self, char const * label) {\n        \n        mProcs.querySetSetLabel(self, label);\n        return true;\n    }\n\n    bool Server::DoQueueCopyTextureForBrowser(WGPUQueue self, WGPUImageCopyTexture const * source, WGPUImageCopyTexture const * destination, WGPUExtent3D const * copySize, WGPUCopyTextureForBrowserOptions const * options) {\n        \n        mProcs.queueCopyTextureForBrowser(self, source, destination, copySize, options);\n        return true;\n    }\n\n\n    bool Server::DoQueueSetLabel(WGPUQueue self, char const * label) {\n        \n        mProcs.queueSetLabel(self, label);\n        return true;\n    }\n\n    bool Server::DoQueueSubmit(WGPUQueue self, uint32_t commandCount, WGPUCommandBuffer const * commands) {\n        \n        mProcs.queueSubmit(self, commandCount, commands);\n        return true;\n    }\n\n\n\n    bool Server::DoRenderBundleEncoderDraw(WGPURenderBundleEncoder self, uint32_t vertexCount, uint32_t instanceCount, uint32_t firstVertex, uint32_t firstInstance) {\n        \n        mProcs.renderBundleEncoderDraw(self, vertexCount, instanceCount, firstVertex, firstInstance);\n        return true;\n    }\n\n    bool Server::DoRenderBundleEncoderDrawIndexed(WGPURenderBundleEncoder self, uint32_t indexCount, uint32_t instanceCount, uint32_t firstIndex, int32_t baseVertex, uint32_t firstInstance) {\n        \n        mProcs.renderBundleEncoderDrawIndexed(self, indexCount, instanceCount, firstIndex, baseVertex, firstInstance);\n        return true;\n    }\n\n    bool Server::DoRenderBundleEncoderDrawIndexedIndirect(WGPURenderBundleEncoder self, WGPUBuffer indirectBuffer, uint64_t indirectOffset) {\n        \n        mProcs.renderBundleEncoderDrawIndexedIndirect(self, indirectBuffer, indirectOffset);\n        return true;\n    }\n\n    bool Server::DoRenderBundleEncoderDrawIndirect(WGPURenderBundleEncoder self, WGPUBuffer indirectBuffer, uint64_t indirectOffset) {\n        \n        mProcs.renderBundleEncoderDrawIndirect(self, indirectBuffer, indirectOffset);\n        return true;\n    }\n\n    bool Server::DoRenderBundleEncoderFinish(WGPURenderBundleEncoder self, WGPURenderBundleDescriptor const * descriptor, WGPURenderBundle* result) {\n        *result =\n        mProcs.renderBundleEncoderFinish(self, descriptor);\n        ASSERT(*result != nullptr);\n        return true;\n    }\n\n    bool Server::DoRenderBundleEncoderInsertDebugMarker(WGPURenderBundleEncoder self, char const * markerLabel) {\n        \n        mProcs.renderBundleEncoderInsertDebugMarker(self, markerLabel);\n        return true;\n    }\n\n    bool Server::DoRenderBundleEncoderPopDebugGroup(WGPURenderBundleEncoder self) {\n        \n        mProcs.renderBundleEncoderPopDebugGroup(self);\n        return true;\n    }\n\n    bool Server::DoRenderBundleEncoderPushDebugGroup(WGPURenderBundleEncoder self, char const * groupLabel) {\n        \n        mProcs.renderBundleEncoderPushDebugGroup(self, groupLabel);\n        return true;\n    }\n\n    bool Server::DoRenderBundleEncoderSetBindGroup(WGPURenderBundleEncoder self, uint32_t groupIndex, WGPUBindGroup group, uint32_t dynamicOffsetCount, uint32_t const * dynamicOffsets) {\n        \n        mProcs.renderBundleEncoderSetBindGroup(self, groupIndex, group, dynamicOffsetCount, dynamicOffsets);\n        return true;\n    }\n\n    bool Server::DoRenderBundleEncoderSetIndexBuffer(WGPURenderBundleEncoder self, WGPUBuffer buffer, WGPUIndexFormat format, uint64_t offset, uint64_t size) {\n        \n        mProcs.renderBundleEncoderSetIndexBuffer(self, buffer, format, offset, size);\n        return true;\n    }\n\n    bool Server::DoRenderBundleEncoderSetLabel(WGPURenderBundleEncoder self, char const * label) {\n        \n        mProcs.renderBundleEncoderSetLabel(self, label);\n        return true;\n    }\n\n    bool Server::DoRenderBundleEncoderSetPipeline(WGPURenderBundleEncoder self, WGPURenderPipeline pipeline) {\n        \n        mProcs.renderBundleEncoderSetPipeline(self, pipeline);\n        return true;\n    }\n\n    bool Server::DoRenderBundleEncoderSetVertexBuffer(WGPURenderBundleEncoder self, uint32_t slot, WGPUBuffer buffer, uint64_t offset, uint64_t size) {\n        \n        mProcs.renderBundleEncoderSetVertexBuffer(self, slot, buffer, offset, size);\n        return true;\n    }\n\n    bool Server::DoRenderPassEncoderBeginOcclusionQuery(WGPURenderPassEncoder self, uint32_t queryIndex) {\n        \n        mProcs.renderPassEncoderBeginOcclusionQuery(self, queryIndex);\n        return true;\n    }\n\n    bool Server::DoRenderPassEncoderDraw(WGPURenderPassEncoder self, uint32_t vertexCount, uint32_t instanceCount, uint32_t firstVertex, uint32_t firstInstance) {\n        \n        mProcs.renderPassEncoderDraw(self, vertexCount, instanceCount, firstVertex, firstInstance);\n        return true;\n    }\n\n    bool Server::DoRenderPassEncoderDrawIndexed(WGPURenderPassEncoder self, uint32_t indexCount, uint32_t instanceCount, uint32_t firstIndex, int32_t baseVertex, uint32_t firstInstance) {\n        \n        mProcs.renderPassEncoderDrawIndexed(self, indexCount, instanceCount, firstIndex, baseVertex, firstInstance);\n        return true;\n    }\n\n    bool Server::DoRenderPassEncoderDrawIndexedIndirect(WGPURenderPassEncoder self, WGPUBuffer indirectBuffer, uint64_t indirectOffset) {\n        \n        mProcs.renderPassEncoderDrawIndexedIndirect(self, indirectBuffer, indirectOffset);\n        return true;\n    }\n\n    bool Server::DoRenderPassEncoderDrawIndirect(WGPURenderPassEncoder self, WGPUBuffer indirectBuffer, uint64_t indirectOffset) {\n        \n        mProcs.renderPassEncoderDrawIndirect(self, indirectBuffer, indirectOffset);\n        return true;\n    }\n\n    bool Server::DoRenderPassEncoderEnd(WGPURenderPassEncoder self) {\n        \n        mProcs.renderPassEncoderEnd(self);\n        return true;\n    }\n\n    bool Server::DoRenderPassEncoderEndOcclusionQuery(WGPURenderPassEncoder self) {\n        \n        mProcs.renderPassEncoderEndOcclusionQuery(self);\n        return true;\n    }\n\n    bool Server::DoRenderPassEncoderEndPass(WGPURenderPassEncoder self) {\n        \n        mProcs.renderPassEncoderEndPass(self);\n        return true;\n    }\n\n    bool Server::DoRenderPassEncoderExecuteBundles(WGPURenderPassEncoder self, uint32_t bundlesCount, WGPURenderBundle const * bundles) {\n        \n        mProcs.renderPassEncoderExecuteBundles(self, bundlesCount, bundles);\n        return true;\n    }\n\n    bool Server::DoRenderPassEncoderInsertDebugMarker(WGPURenderPassEncoder self, char const * markerLabel) {\n        \n        mProcs.renderPassEncoderInsertDebugMarker(self, markerLabel);\n        return true;\n    }\n\n    bool Server::DoRenderPassEncoderPopDebugGroup(WGPURenderPassEncoder self) {\n        \n        mProcs.renderPassEncoderPopDebugGroup(self);\n        return true;\n    }\n\n    bool Server::DoRenderPassEncoderPushDebugGroup(WGPURenderPassEncoder self, char const * groupLabel) {\n        \n        mProcs.renderPassEncoderPushDebugGroup(self, groupLabel);\n        return true;\n    }\n\n    bool Server::DoRenderPassEncoderSetBindGroup(WGPURenderPassEncoder self, uint32_t groupIndex, WGPUBindGroup group, uint32_t dynamicOffsetCount, uint32_t const * dynamicOffsets) {\n        \n        mProcs.renderPassEncoderSetBindGroup(self, groupIndex, group, dynamicOffsetCount, dynamicOffsets);\n        return true;\n    }\n\n    bool Server::DoRenderPassEncoderSetBlendConstant(WGPURenderPassEncoder self, WGPUColor const * color) {\n        \n        mProcs.renderPassEncoderSetBlendConstant(self, color);\n        return true;\n    }\n\n    bool Server::DoRenderPassEncoderSetIndexBuffer(WGPURenderPassEncoder self, WGPUBuffer buffer, WGPUIndexFormat format, uint64_t offset, uint64_t size) {\n        \n        mProcs.renderPassEncoderSetIndexBuffer(self, buffer, format, offset, size);\n        return true;\n    }\n\n    bool Server::DoRenderPassEncoderSetLabel(WGPURenderPassEncoder self, char const * label) {\n        \n        mProcs.renderPassEncoderSetLabel(self, label);\n        return true;\n    }\n\n    bool Server::DoRenderPassEncoderSetPipeline(WGPURenderPassEncoder self, WGPURenderPipeline pipeline) {\n        \n        mProcs.renderPassEncoderSetPipeline(self, pipeline);\n        return true;\n    }\n\n    bool Server::DoRenderPassEncoderSetScissorRect(WGPURenderPassEncoder self, uint32_t x, uint32_t y, uint32_t width, uint32_t height) {\n        \n        mProcs.renderPassEncoderSetScissorRect(self, x, y, width, height);\n        return true;\n    }\n\n    bool Server::DoRenderPassEncoderSetStencilReference(WGPURenderPassEncoder self, uint32_t reference) {\n        \n        mProcs.renderPassEncoderSetStencilReference(self, reference);\n        return true;\n    }\n\n    bool Server::DoRenderPassEncoderSetVertexBuffer(WGPURenderPassEncoder self, uint32_t slot, WGPUBuffer buffer, uint64_t offset, uint64_t size) {\n        \n        mProcs.renderPassEncoderSetVertexBuffer(self, slot, buffer, offset, size);\n        return true;\n    }\n\n    bool Server::DoRenderPassEncoderSetViewport(WGPURenderPassEncoder self, float x, float y, float width, float height, float minDepth, float maxDepth) {\n        \n        mProcs.renderPassEncoderSetViewport(self, x, y, width, height, minDepth, maxDepth);\n        return true;\n    }\n\n    bool Server::DoRenderPassEncoderWriteTimestamp(WGPURenderPassEncoder self, WGPUQuerySet querySet, uint32_t queryIndex) {\n        \n        mProcs.renderPassEncoderWriteTimestamp(self, querySet, queryIndex);\n        return true;\n    }\n\n    bool Server::DoRenderPipelineGetBindGroupLayout(WGPURenderPipeline self, uint32_t groupIndex, WGPUBindGroupLayout* result) {\n        *result =\n        mProcs.renderPipelineGetBindGroupLayout(self, groupIndex);\n        ASSERT(*result != nullptr);\n        return true;\n    }\n\n    bool Server::DoRenderPipelineSetLabel(WGPURenderPipeline self, char const * label) {\n        \n        mProcs.renderPipelineSetLabel(self, label);\n        return true;\n    }\n\n    bool Server::DoSamplerSetLabel(WGPUSampler self, char const * label) {\n        \n        mProcs.samplerSetLabel(self, label);\n        return true;\n    }\n\n\n    bool Server::DoShaderModuleSetLabel(WGPUShaderModule self, char const * label) {\n        \n        mProcs.shaderModuleSetLabel(self, label);\n        return true;\n    }\n\n    bool Server::DoSwapChainConfigure(WGPUSwapChain self, WGPUTextureFormat format, WGPUTextureUsageFlags allowedUsage, uint32_t width, uint32_t height) {\n        \n        mProcs.swapChainConfigure(self, format, allowedUsage, width, height);\n        return true;\n    }\n\n    bool Server::DoSwapChainGetCurrentTextureView(WGPUSwapChain self, WGPUTextureView* result) {\n        *result =\n        mProcs.swapChainGetCurrentTextureView(self);\n        ASSERT(*result != nullptr);\n        return true;\n    }\n\n    bool Server::DoSwapChainPresent(WGPUSwapChain self) {\n        \n        mProcs.swapChainPresent(self);\n        return true;\n    }\n\n    bool Server::DoTextureCreateView(WGPUTexture self, WGPUTextureViewDescriptor const * descriptor, WGPUTextureView* result) {\n        *result =\n        mProcs.textureCreateView(self, descriptor);\n        ASSERT(*result != nullptr);\n        return true;\n    }\n\n    bool Server::DoTextureDestroy(WGPUTexture self) {\n        \n        mProcs.textureDestroy(self);\n        return true;\n    }\n\n    bool Server::DoTextureSetLabel(WGPUTexture self, char const * label) {\n        \n        mProcs.textureSetLabel(self, label);\n        return true;\n    }\n\n    bool Server::DoTextureViewSetLabel(WGPUTextureView self, char const * label) {\n        \n        mProcs.textureViewSetLabel(self, label);\n        return true;\n    }\n\n    bool Server::DoDestroyObject(ObjectType objectType, ObjectId objectId) {\n        if (objectId == 0) {\n            return false;\n        }\n\n        switch(objectType) {\n            case ObjectType::Adapter: {\n                auto* data = AdapterObjects().Get(objectId);\n                if (data == nullptr) {\n                    return false;\n                }\n                if (data->state == AllocationState::Allocated) {\n                    ASSERT(data->handle != nullptr);\n\n\n                    mProcs.adapterRelease(data->handle);\n                }\n                AdapterObjects().Free(objectId);\n                return true;\n            }\n            case ObjectType::BindGroup: {\n                auto* data = BindGroupObjects().Get(objectId);\n                if (data == nullptr) {\n                    return false;\n                }\n                if (data->state == AllocationState::Allocated) {\n                    ASSERT(data->handle != nullptr);\n\n\n                    mProcs.bindGroupRelease(data->handle);\n                }\n                BindGroupObjects().Free(objectId);\n                return true;\n            }\n            case ObjectType::BindGroupLayout: {\n                auto* data = BindGroupLayoutObjects().Get(objectId);\n                if (data == nullptr) {\n                    return false;\n                }\n                if (data->state == AllocationState::Allocated) {\n                    ASSERT(data->handle != nullptr);\n\n\n                    mProcs.bindGroupLayoutRelease(data->handle);\n                }\n                BindGroupLayoutObjects().Free(objectId);\n                return true;\n            }\n            case ObjectType::Buffer: {\n                auto* data = BufferObjects().Get(objectId);\n                if (data == nullptr) {\n                    return false;\n                }\n                if (data->state == AllocationState::Allocated) {\n                    ASSERT(data->handle != nullptr);\n\n\n                    mProcs.bufferRelease(data->handle);\n                }\n                BufferObjects().Free(objectId);\n                return true;\n            }\n            case ObjectType::CommandBuffer: {\n                auto* data = CommandBufferObjects().Get(objectId);\n                if (data == nullptr) {\n                    return false;\n                }\n                if (data->state == AllocationState::Allocated) {\n                    ASSERT(data->handle != nullptr);\n\n\n                    mProcs.commandBufferRelease(data->handle);\n                }\n                CommandBufferObjects().Free(objectId);\n                return true;\n            }\n            case ObjectType::CommandEncoder: {\n                auto* data = CommandEncoderObjects().Get(objectId);\n                if (data == nullptr) {\n                    return false;\n                }\n                if (data->state == AllocationState::Allocated) {\n                    ASSERT(data->handle != nullptr);\n\n\n                    mProcs.commandEncoderRelease(data->handle);\n                }\n                CommandEncoderObjects().Free(objectId);\n                return true;\n            }\n            case ObjectType::ComputePassEncoder: {\n                auto* data = ComputePassEncoderObjects().Get(objectId);\n                if (data == nullptr) {\n                    return false;\n                }\n                if (data->state == AllocationState::Allocated) {\n                    ASSERT(data->handle != nullptr);\n\n\n                    mProcs.computePassEncoderRelease(data->handle);\n                }\n                ComputePassEncoderObjects().Free(objectId);\n                return true;\n            }\n            case ObjectType::ComputePipeline: {\n                auto* data = ComputePipelineObjects().Get(objectId);\n                if (data == nullptr) {\n                    return false;\n                }\n                if (data->state == AllocationState::Allocated) {\n                    ASSERT(data->handle != nullptr);\n\n\n                    mProcs.computePipelineRelease(data->handle);\n                }\n                ComputePipelineObjects().Free(objectId);\n                return true;\n            }\n            case ObjectType::Device: {\n                auto* data = DeviceObjects().Get(objectId);\n                if (data == nullptr) {\n                    return false;\n                }\n                if (data->state == AllocationState::Allocated) {\n                    ASSERT(data->handle != nullptr);\n\n                    if (data->handle != nullptr) {\n                        ClearDeviceCallbacks(data->handle);\n                    }\n\n                    mProcs.deviceRelease(data->handle);\n                }\n                DeviceObjects().Free(objectId);\n                return true;\n            }\n            case ObjectType::ExternalTexture: {\n                auto* data = ExternalTextureObjects().Get(objectId);\n                if (data == nullptr) {\n                    return false;\n                }\n                if (data->state == AllocationState::Allocated) {\n                    ASSERT(data->handle != nullptr);\n\n\n                    mProcs.externalTextureRelease(data->handle);\n                }\n                ExternalTextureObjects().Free(objectId);\n                return true;\n            }\n            case ObjectType::Instance: {\n                auto* data = InstanceObjects().Get(objectId);\n                if (data == nullptr) {\n                    return false;\n                }\n                if (data->state == AllocationState::Allocated) {\n                    ASSERT(data->handle != nullptr);\n\n\n                    mProcs.instanceRelease(data->handle);\n                }\n                InstanceObjects().Free(objectId);\n                return true;\n            }\n            case ObjectType::PipelineLayout: {\n                auto* data = PipelineLayoutObjects().Get(objectId);\n                if (data == nullptr) {\n                    return false;\n                }\n                if (data->state == AllocationState::Allocated) {\n                    ASSERT(data->handle != nullptr);\n\n\n                    mProcs.pipelineLayoutRelease(data->handle);\n                }\n                PipelineLayoutObjects().Free(objectId);\n                return true;\n            }\n            case ObjectType::QuerySet: {\n                auto* data = QuerySetObjects().Get(objectId);\n                if (data == nullptr) {\n                    return false;\n                }\n                if (data->state == AllocationState::Allocated) {\n                    ASSERT(data->handle != nullptr);\n\n\n                    mProcs.querySetRelease(data->handle);\n                }\n                QuerySetObjects().Free(objectId);\n                return true;\n            }\n            case ObjectType::Queue: {\n                auto* data = QueueObjects().Get(objectId);\n                if (data == nullptr) {\n                    return false;\n                }\n                if (data->state == AllocationState::Allocated) {\n                    ASSERT(data->handle != nullptr);\n\n\n                    mProcs.queueRelease(data->handle);\n                }\n                QueueObjects().Free(objectId);\n                return true;\n            }\n            case ObjectType::RenderBundle: {\n                auto* data = RenderBundleObjects().Get(objectId);\n                if (data == nullptr) {\n                    return false;\n                }\n                if (data->state == AllocationState::Allocated) {\n                    ASSERT(data->handle != nullptr);\n\n\n                    mProcs.renderBundleRelease(data->handle);\n                }\n                RenderBundleObjects().Free(objectId);\n                return true;\n            }\n            case ObjectType::RenderBundleEncoder: {\n                auto* data = RenderBundleEncoderObjects().Get(objectId);\n                if (data == nullptr) {\n                    return false;\n                }\n                if (data->state == AllocationState::Allocated) {\n                    ASSERT(data->handle != nullptr);\n\n\n                    mProcs.renderBundleEncoderRelease(data->handle);\n                }\n                RenderBundleEncoderObjects().Free(objectId);\n                return true;\n            }\n            case ObjectType::RenderPassEncoder: {\n                auto* data = RenderPassEncoderObjects().Get(objectId);\n                if (data == nullptr) {\n                    return false;\n                }\n                if (data->state == AllocationState::Allocated) {\n                    ASSERT(data->handle != nullptr);\n\n\n                    mProcs.renderPassEncoderRelease(data->handle);\n                }\n                RenderPassEncoderObjects().Free(objectId);\n                return true;\n            }\n            case ObjectType::RenderPipeline: {\n                auto* data = RenderPipelineObjects().Get(objectId);\n                if (data == nullptr) {\n                    return false;\n                }\n                if (data->state == AllocationState::Allocated) {\n                    ASSERT(data->handle != nullptr);\n\n\n                    mProcs.renderPipelineRelease(data->handle);\n                }\n                RenderPipelineObjects().Free(objectId);\n                return true;\n            }\n            case ObjectType::Sampler: {\n                auto* data = SamplerObjects().Get(objectId);\n                if (data == nullptr) {\n                    return false;\n                }\n                if (data->state == AllocationState::Allocated) {\n                    ASSERT(data->handle != nullptr);\n\n\n                    mProcs.samplerRelease(data->handle);\n                }\n                SamplerObjects().Free(objectId);\n                return true;\n            }\n            case ObjectType::ShaderModule: {\n                auto* data = ShaderModuleObjects().Get(objectId);\n                if (data == nullptr) {\n                    return false;\n                }\n                if (data->state == AllocationState::Allocated) {\n                    ASSERT(data->handle != nullptr);\n\n\n                    mProcs.shaderModuleRelease(data->handle);\n                }\n                ShaderModuleObjects().Free(objectId);\n                return true;\n            }\n            case ObjectType::Surface: {\n                auto* data = SurfaceObjects().Get(objectId);\n                if (data == nullptr) {\n                    return false;\n                }\n                if (data->state == AllocationState::Allocated) {\n                    ASSERT(data->handle != nullptr);\n\n\n                    mProcs.surfaceRelease(data->handle);\n                }\n                SurfaceObjects().Free(objectId);\n                return true;\n            }\n            case ObjectType::SwapChain: {\n                auto* data = SwapChainObjects().Get(objectId);\n                if (data == nullptr) {\n                    return false;\n                }\n                if (data->state == AllocationState::Allocated) {\n                    ASSERT(data->handle != nullptr);\n\n\n                    mProcs.swapChainRelease(data->handle);\n                }\n                SwapChainObjects().Free(objectId);\n                return true;\n            }\n            case ObjectType::Texture: {\n                auto* data = TextureObjects().Get(objectId);\n                if (data == nullptr) {\n                    return false;\n                }\n                if (data->state == AllocationState::Allocated) {\n                    ASSERT(data->handle != nullptr);\n\n\n                    mProcs.textureRelease(data->handle);\n                }\n                TextureObjects().Free(objectId);\n                return true;\n            }\n            case ObjectType::TextureView: {\n                auto* data = TextureViewObjects().Get(objectId);\n                if (data == nullptr) {\n                    return false;\n                }\n                if (data->state == AllocationState::Allocated) {\n                    ASSERT(data->handle != nullptr);\n\n\n                    mProcs.textureViewRelease(data->handle);\n                }\n                TextureViewObjects().Free(objectId);\n                return true;\n            }\n            default:\n                return false;\n        }\n    }\n\n}  // namespace dawn::wire::server\n", "src/dawn/wire/server/ServerHandlers_autogen.cpp": "\n#include \"dawn/common/Assert.h\"\n#include \"dawn/wire/server/Server.h\"\n\nnamespace dawn::wire::server {\n\n    bool Server::HandleAdapterRequestDevice(DeserializeBuffer* deserializeBuffer) {\n        AdapterRequestDeviceCmd cmd;\n        WireResult deserializeResult = cmd.Deserialize(deserializeBuffer, &mAllocator, *this);\n\n        if (deserializeResult == WireResult::FatalError) {\n            return false;\n        }\n\n\n        bool success = DoAdapterRequestDevice(cmd.adapterId, cmd.requestSerial, cmd.deviceObjectHandle, cmd.descriptor);\n\n        if (!success) {\n            return false;\n        }\n        return true;\n    }\n\n    bool Server::HandleBindGroupLayoutSetLabel(DeserializeBuffer* deserializeBuffer) {\n        BindGroupLayoutSetLabelCmd cmd;\n        WireResult deserializeResult = cmd.Deserialize(deserializeBuffer, &mAllocator, *this);\n\n        if (deserializeResult == WireResult::FatalError) {\n            return false;\n        }\n\n\n        bool success = DoBindGroupLayoutSetLabel(cmd.self, cmd.label);\n\n        if (!success) {\n            return false;\n        }\n        return true;\n    }\n\n    bool Server::HandleBindGroupSetLabel(DeserializeBuffer* deserializeBuffer) {\n        BindGroupSetLabelCmd cmd;\n        WireResult deserializeResult = cmd.Deserialize(deserializeBuffer, &mAllocator, *this);\n\n        if (deserializeResult == WireResult::FatalError) {\n            return false;\n        }\n\n\n        bool success = DoBindGroupSetLabel(cmd.self, cmd.label);\n\n        if (!success) {\n            return false;\n        }\n        return true;\n    }\n\n    bool Server::HandleBufferDestroy(DeserializeBuffer* deserializeBuffer) {\n        BufferDestroyCmd cmd;\n        WireResult deserializeResult = cmd.Deserialize(deserializeBuffer, &mAllocator, *this);\n\n        if (deserializeResult == WireResult::FatalError) {\n            return false;\n        }\n\n        if (!PreHandleBufferDestroy(cmd)) {\n            return false;\n        }\n\n        bool success = DoBufferDestroy(cmd.self);\n\n        if (!success) {\n            return false;\n        }\n        return true;\n    }\n\n    bool Server::HandleBufferMapAsync(DeserializeBuffer* deserializeBuffer) {\n        BufferMapAsyncCmd cmd;\n        WireResult deserializeResult = cmd.Deserialize(deserializeBuffer, &mAllocator);\n\n        if (deserializeResult == WireResult::FatalError) {\n            return false;\n        }\n\n\n        bool success = DoBufferMapAsync(cmd.bufferId, cmd.requestSerial, cmd.mode, cmd.offset, cmd.size);\n\n        if (!success) {\n            return false;\n        }\n        return true;\n    }\n\n    bool Server::HandleBufferSetLabel(DeserializeBuffer* deserializeBuffer) {\n        BufferSetLabelCmd cmd;\n        WireResult deserializeResult = cmd.Deserialize(deserializeBuffer, &mAllocator, *this);\n\n        if (deserializeResult == WireResult::FatalError) {\n            return false;\n        }\n\n\n        bool success = DoBufferSetLabel(cmd.self, cmd.label);\n\n        if (!success) {\n            return false;\n        }\n        return true;\n    }\n\n    bool Server::HandleBufferUnmap(DeserializeBuffer* deserializeBuffer) {\n        BufferUnmapCmd cmd;\n        WireResult deserializeResult = cmd.Deserialize(deserializeBuffer, &mAllocator, *this);\n\n        if (deserializeResult == WireResult::FatalError) {\n            return false;\n        }\n\n        if (!PreHandleBufferUnmap(cmd)) {\n            return false;\n        }\n\n        bool success = DoBufferUnmap(cmd.self);\n\n        if (!success) {\n            return false;\n        }\n        return true;\n    }\n\n    bool Server::HandleBufferUpdateMappedData(DeserializeBuffer* deserializeBuffer) {\n        BufferUpdateMappedDataCmd cmd;\n        WireResult deserializeResult = cmd.Deserialize(deserializeBuffer, &mAllocator);\n\n        if (deserializeResult == WireResult::FatalError) {\n            return false;\n        }\n\n\n        bool success = DoBufferUpdateMappedData(cmd.bufferId, cmd.writeDataUpdateInfoLength, cmd.writeDataUpdateInfo, cmd.offset, cmd.size);\n\n        if (!success) {\n            return false;\n        }\n        return true;\n    }\n\n    bool Server::HandleCommandBufferSetLabel(DeserializeBuffer* deserializeBuffer) {\n        CommandBufferSetLabelCmd cmd;\n        WireResult deserializeResult = cmd.Deserialize(deserializeBuffer, &mAllocator, *this);\n\n        if (deserializeResult == WireResult::FatalError) {\n            return false;\n        }\n\n\n        bool success = DoCommandBufferSetLabel(cmd.self, cmd.label);\n\n        if (!success) {\n            return false;\n        }\n        return true;\n    }\n\n    bool Server::HandleCommandEncoderBeginComputePass(DeserializeBuffer* deserializeBuffer) {\n        CommandEncoderBeginComputePassCmd cmd;\n        WireResult deserializeResult = cmd.Deserialize(deserializeBuffer, &mAllocator, *this);\n\n        if (deserializeResult == WireResult::FatalError) {\n            return false;\n        }\n\n\n\n        auto* resultData = ComputePassEncoderObjects().Allocate(cmd.result.id);\n        if (resultData == nullptr) {\n            return false;\n        }\n        resultData->generation = cmd.result.generation;\n\n        bool success = DoCommandEncoderBeginComputePass(cmd.self, cmd.descriptor, &resultData->handle);\n\n        if (!success) {\n            return false;\n        }\n\n        return true;\n    }\n\n    bool Server::HandleCommandEncoderBeginRenderPass(DeserializeBuffer* deserializeBuffer) {\n        CommandEncoderBeginRenderPassCmd cmd;\n        WireResult deserializeResult = cmd.Deserialize(deserializeBuffer, &mAllocator, *this);\n\n        if (deserializeResult == WireResult::FatalError) {\n            return false;\n        }\n\n\n\n        auto* resultData = RenderPassEncoderObjects().Allocate(cmd.result.id);\n        if (resultData == nullptr) {\n            return false;\n        }\n        resultData->generation = cmd.result.generation;\n\n        bool success = DoCommandEncoderBeginRenderPass(cmd.self, cmd.descriptor, &resultData->handle);\n\n        if (!success) {\n            return false;\n        }\n\n        return true;\n    }\n\n    bool Server::HandleCommandEncoderClearBuffer(DeserializeBuffer* deserializeBuffer) {\n        CommandEncoderClearBufferCmd cmd;\n        WireResult deserializeResult = cmd.Deserialize(deserializeBuffer, &mAllocator, *this);\n\n        if (deserializeResult == WireResult::FatalError) {\n            return false;\n        }\n\n\n        bool success = DoCommandEncoderClearBuffer(cmd.self, cmd.buffer, cmd.offset, cmd.size);\n\n        if (!success) {\n            return false;\n        }\n        return true;\n    }\n\n    bool Server::HandleCommandEncoderCopyBufferToBuffer(DeserializeBuffer* deserializeBuffer) {\n        CommandEncoderCopyBufferToBufferCmd cmd;\n        WireResult deserializeResult = cmd.Deserialize(deserializeBuffer, &mAllocator, *this);\n\n        if (deserializeResult == WireResult::FatalError) {\n            return false;\n        }\n\n\n        bool success = DoCommandEncoderCopyBufferToBuffer(cmd.self, cmd.source, cmd.sourceOffset, cmd.destination, cmd.destinationOffset, cmd.size);\n\n        if (!success) {\n            return false;\n        }\n        return true;\n    }\n\n    bool Server::HandleCommandEncoderCopyBufferToTexture(DeserializeBuffer* deserializeBuffer) {\n        CommandEncoderCopyBufferToTextureCmd cmd;\n        WireResult deserializeResult = cmd.Deserialize(deserializeBuffer, &mAllocator, *this);\n\n        if (deserializeResult == WireResult::FatalError) {\n            return false;\n        }\n\n\n        bool success = DoCommandEncoderCopyBufferToTexture(cmd.self, cmd.source, cmd.destination, cmd.copySize);\n\n        if (!success) {\n            return false;\n        }\n        return true;\n    }\n\n    bool Server::HandleCommandEncoderCopyTextureToBuffer(DeserializeBuffer* deserializeBuffer) {\n        CommandEncoderCopyTextureToBufferCmd cmd;\n        WireResult deserializeResult = cmd.Deserialize(deserializeBuffer, &mAllocator, *this);\n\n        if (deserializeResult == WireResult::FatalError) {\n            return false;\n        }\n\n\n        bool success = DoCommandEncoderCopyTextureToBuffer(cmd.self, cmd.source, cmd.destination, cmd.copySize);\n\n        if (!success) {\n            return false;\n        }\n        return true;\n    }\n\n    bool Server::HandleCommandEncoderCopyTextureToTexture(DeserializeBuffer* deserializeBuffer) {\n        CommandEncoderCopyTextureToTextureCmd cmd;\n        WireResult deserializeResult = cmd.Deserialize(deserializeBuffer, &mAllocator, *this);\n\n        if (deserializeResult == WireResult::FatalError) {\n            return false;\n        }\n\n\n        bool success = DoCommandEncoderCopyTextureToTexture(cmd.self, cmd.source, cmd.destination, cmd.copySize);\n\n        if (!success) {\n            return false;\n        }\n        return true;\n    }\n\n    bool Server::HandleCommandEncoderCopyTextureToTextureInternal(DeserializeBuffer* deserializeBuffer) {\n        CommandEncoderCopyTextureToTextureInternalCmd cmd;\n        WireResult deserializeResult = cmd.Deserialize(deserializeBuffer, &mAllocator, *this);\n\n        if (deserializeResult == WireResult::FatalError) {\n            return false;\n        }\n\n\n        bool success = DoCommandEncoderCopyTextureToTextureInternal(cmd.self, cmd.source, cmd.destination, cmd.copySize);\n\n        if (!success) {\n            return false;\n        }\n        return true;\n    }\n\n    bool Server::HandleCommandEncoderFinish(DeserializeBuffer* deserializeBuffer) {\n        CommandEncoderFinishCmd cmd;\n        WireResult deserializeResult = cmd.Deserialize(deserializeBuffer, &mAllocator, *this);\n\n        if (deserializeResult == WireResult::FatalError) {\n            return false;\n        }\n\n\n\n        auto* resultData = CommandBufferObjects().Allocate(cmd.result.id);\n        if (resultData == nullptr) {\n            return false;\n        }\n        resultData->generation = cmd.result.generation;\n\n        bool success = DoCommandEncoderFinish(cmd.self, cmd.descriptor, &resultData->handle);\n\n        if (!success) {\n            return false;\n        }\n\n        return true;\n    }\n\n    bool Server::HandleCommandEncoderInjectValidationError(DeserializeBuffer* deserializeBuffer) {\n        CommandEncoderInjectValidationErrorCmd cmd;\n        WireResult deserializeResult = cmd.Deserialize(deserializeBuffer, &mAllocator, *this);\n\n        if (deserializeResult == WireResult::FatalError) {\n            return false;\n        }\n\n\n        bool success = DoCommandEncoderInjectValidationError(cmd.self, cmd.message);\n\n        if (!success) {\n            return false;\n        }\n        return true;\n    }\n\n    bool Server::HandleCommandEncoderInsertDebugMarker(DeserializeBuffer* deserializeBuffer) {\n        CommandEncoderInsertDebugMarkerCmd cmd;\n        WireResult deserializeResult = cmd.Deserialize(deserializeBuffer, &mAllocator, *this);\n\n        if (deserializeResult == WireResult::FatalError) {\n            return false;\n        }\n\n\n        bool success = DoCommandEncoderInsertDebugMarker(cmd.self, cmd.markerLabel);\n\n        if (!success) {\n            return false;\n        }\n        return true;\n    }\n\n    bool Server::HandleCommandEncoderPopDebugGroup(DeserializeBuffer* deserializeBuffer) {\n        CommandEncoderPopDebugGroupCmd cmd;\n        WireResult deserializeResult = cmd.Deserialize(deserializeBuffer, &mAllocator, *this);\n\n        if (deserializeResult == WireResult::FatalError) {\n            return false;\n        }\n\n\n        bool success = DoCommandEncoderPopDebugGroup(cmd.self);\n\n        if (!success) {\n            return false;\n        }\n        return true;\n    }\n\n    bool Server::HandleCommandEncoderPushDebugGroup(DeserializeBuffer* deserializeBuffer) {\n        CommandEncoderPushDebugGroupCmd cmd;\n        WireResult deserializeResult = cmd.Deserialize(deserializeBuffer, &mAllocator, *this);\n\n        if (deserializeResult == WireResult::FatalError) {\n            return false;\n        }\n\n\n        bool success = DoCommandEncoderPushDebugGroup(cmd.self, cmd.groupLabel);\n\n        if (!success) {\n            return false;\n        }\n        return true;\n    }\n\n    bool Server::HandleCommandEncoderResolveQuerySet(DeserializeBuffer* deserializeBuffer) {\n        CommandEncoderResolveQuerySetCmd cmd;\n        WireResult deserializeResult = cmd.Deserialize(deserializeBuffer, &mAllocator, *this);\n\n        if (deserializeResult == WireResult::FatalError) {\n            return false;\n        }\n\n\n        bool success = DoCommandEncoderResolveQuerySet(cmd.self, cmd.querySet, cmd.firstQuery, cmd.queryCount, cmd.destination, cmd.destinationOffset);\n\n        if (!success) {\n            return false;\n        }\n        return true;\n    }\n\n    bool Server::HandleCommandEncoderSetLabel(DeserializeBuffer* deserializeBuffer) {\n        CommandEncoderSetLabelCmd cmd;\n        WireResult deserializeResult = cmd.Deserialize(deserializeBuffer, &mAllocator, *this);\n\n        if (deserializeResult == WireResult::FatalError) {\n            return false;\n        }\n\n\n        bool success = DoCommandEncoderSetLabel(cmd.self, cmd.label);\n\n        if (!success) {\n            return false;\n        }\n        return true;\n    }\n\n    bool Server::HandleCommandEncoderWriteBuffer(DeserializeBuffer* deserializeBuffer) {\n        CommandEncoderWriteBufferCmd cmd;\n        WireResult deserializeResult = cmd.Deserialize(deserializeBuffer, &mAllocator, *this);\n\n        if (deserializeResult == WireResult::FatalError) {\n            return false;\n        }\n\n\n        bool success = DoCommandEncoderWriteBuffer(cmd.self, cmd.buffer, cmd.bufferOffset, cmd.data, cmd.size);\n\n        if (!success) {\n            return false;\n        }\n        return true;\n    }\n\n    bool Server::HandleCommandEncoderWriteTimestamp(DeserializeBuffer* deserializeBuffer) {\n        CommandEncoderWriteTimestampCmd cmd;\n        WireResult deserializeResult = cmd.Deserialize(deserializeBuffer, &mAllocator, *this);\n\n        if (deserializeResult == WireResult::FatalError) {\n            return false;\n        }\n\n\n        bool success = DoCommandEncoderWriteTimestamp(cmd.self, cmd.querySet, cmd.queryIndex);\n\n        if (!success) {\n            return false;\n        }\n        return true;\n    }\n\n    bool Server::HandleComputePassEncoderDispatch(DeserializeBuffer* deserializeBuffer) {\n        ComputePassEncoderDispatchCmd cmd;\n        WireResult deserializeResult = cmd.Deserialize(deserializeBuffer, &mAllocator, *this);\n\n        if (deserializeResult == WireResult::FatalError) {\n            return false;\n        }\n\n\n        bool success = DoComputePassEncoderDispatch(cmd.self, cmd.workgroupCountX, cmd.workgroupCountY, cmd.workgroupCountZ);\n\n        if (!success) {\n            return false;\n        }\n        return true;\n    }\n\n    bool Server::HandleComputePassEncoderDispatchIndirect(DeserializeBuffer* deserializeBuffer) {\n        ComputePassEncoderDispatchIndirectCmd cmd;\n        WireResult deserializeResult = cmd.Deserialize(deserializeBuffer, &mAllocator, *this);\n\n        if (deserializeResult == WireResult::FatalError) {\n            return false;\n        }\n\n\n        bool success = DoComputePassEncoderDispatchIndirect(cmd.self, cmd.indirectBuffer, cmd.indirectOffset);\n\n        if (!success) {\n            return false;\n        }\n        return true;\n    }\n\n    bool Server::HandleComputePassEncoderDispatchWorkgroups(DeserializeBuffer* deserializeBuffer) {\n        ComputePassEncoderDispatchWorkgroupsCmd cmd;\n        WireResult deserializeResult = cmd.Deserialize(deserializeBuffer, &mAllocator, *this);\n\n        if (deserializeResult == WireResult::FatalError) {\n            return false;\n        }\n\n\n        bool success = DoComputePassEncoderDispatchWorkgroups(cmd.self, cmd.workgroupCountX, cmd.workgroupCountY, cmd.workgroupCountZ);\n\n        if (!success) {\n            return false;\n        }\n        return true;\n    }\n\n    bool Server::HandleComputePassEncoderDispatchWorkgroupsIndirect(DeserializeBuffer* deserializeBuffer) {\n        ComputePassEncoderDispatchWorkgroupsIndirectCmd cmd;\n        WireResult deserializeResult = cmd.Deserialize(deserializeBuffer, &mAllocator, *this);\n\n        if (deserializeResult == WireResult::FatalError) {\n            return false;\n        }\n\n\n        bool success = DoComputePassEncoderDispatchWorkgroupsIndirect(cmd.self, cmd.indirectBuffer, cmd.indirectOffset);\n\n        if (!success) {\n            return false;\n        }\n        return true;\n    }\n\n    bool Server::HandleComputePassEncoderEnd(DeserializeBuffer* deserializeBuffer) {\n        ComputePassEncoderEndCmd cmd;\n        WireResult deserializeResult = cmd.Deserialize(deserializeBuffer, &mAllocator, *this);\n\n        if (deserializeResult == WireResult::FatalError) {\n            return false;\n        }\n\n\n        bool success = DoComputePassEncoderEnd(cmd.self);\n\n        if (!success) {\n            return false;\n        }\n        return true;\n    }\n\n    bool Server::HandleComputePassEncoderEndPass(DeserializeBuffer* deserializeBuffer) {\n        ComputePassEncoderEndPassCmd cmd;\n        WireResult deserializeResult = cmd.Deserialize(deserializeBuffer, &mAllocator, *this);\n\n        if (deserializeResult == WireResult::FatalError) {\n            return false;\n        }\n\n\n        bool success = DoComputePassEncoderEndPass(cmd.self);\n\n        if (!success) {\n            return false;\n        }\n        return true;\n    }\n\n    bool Server::HandleComputePassEncoderInsertDebugMarker(DeserializeBuffer* deserializeBuffer) {\n        ComputePassEncoderInsertDebugMarkerCmd cmd;\n        WireResult deserializeResult = cmd.Deserialize(deserializeBuffer, &mAllocator, *this);\n\n        if (deserializeResult == WireResult::FatalError) {\n            return false;\n        }\n\n\n        bool success = DoComputePassEncoderInsertDebugMarker(cmd.self, cmd.markerLabel);\n\n        if (!success) {\n            return false;\n        }\n        return true;\n    }\n\n    bool Server::HandleComputePassEncoderPopDebugGroup(DeserializeBuffer* deserializeBuffer) {\n        ComputePassEncoderPopDebugGroupCmd cmd;\n        WireResult deserializeResult = cmd.Deserialize(deserializeBuffer, &mAllocator, *this);\n\n        if (deserializeResult == WireResult::FatalError) {\n            return false;\n        }\n\n\n        bool success = DoComputePassEncoderPopDebugGroup(cmd.self);\n\n        if (!success) {\n            return false;\n        }\n        return true;\n    }\n\n    bool Server::HandleComputePassEncoderPushDebugGroup(DeserializeBuffer* deserializeBuffer) {\n        ComputePassEncoderPushDebugGroupCmd cmd;\n        WireResult deserializeResult = cmd.Deserialize(deserializeBuffer, &mAllocator, *this);\n\n        if (deserializeResult == WireResult::FatalError) {\n            return false;\n        }\n\n\n        bool success = DoComputePassEncoderPushDebugGroup(cmd.self, cmd.groupLabel);\n\n        if (!success) {\n            return false;\n        }\n        return true;\n    }\n\n    bool Server::HandleComputePassEncoderSetBindGroup(DeserializeBuffer* deserializeBuffer) {\n        ComputePassEncoderSetBindGroupCmd cmd;\n        WireResult deserializeResult = cmd.Deserialize(deserializeBuffer, &mAllocator, *this);\n\n        if (deserializeResult == WireResult::FatalError) {\n            return false;\n        }\n\n\n        bool success = DoComputePassEncoderSetBindGroup(cmd.self, cmd.groupIndex, cmd.group, cmd.dynamicOffsetCount, cmd.dynamicOffsets);\n\n        if (!success) {\n            return false;\n        }\n        return true;\n    }\n\n    bool Server::HandleComputePassEncoderSetLabel(DeserializeBuffer* deserializeBuffer) {\n        ComputePassEncoderSetLabelCmd cmd;\n        WireResult deserializeResult = cmd.Deserialize(deserializeBuffer, &mAllocator, *this);\n\n        if (deserializeResult == WireResult::FatalError) {\n            return false;\n        }\n\n\n        bool success = DoComputePassEncoderSetLabel(cmd.self, cmd.label);\n\n        if (!success) {\n            return false;\n        }\n        return true;\n    }\n\n    bool Server::HandleComputePassEncoderSetPipeline(DeserializeBuffer* deserializeBuffer) {\n        ComputePassEncoderSetPipelineCmd cmd;\n        WireResult deserializeResult = cmd.Deserialize(deserializeBuffer, &mAllocator, *this);\n\n        if (deserializeResult == WireResult::FatalError) {\n            return false;\n        }\n\n\n        bool success = DoComputePassEncoderSetPipeline(cmd.self, cmd.pipeline);\n\n        if (!success) {\n            return false;\n        }\n        return true;\n    }\n\n    bool Server::HandleComputePassEncoderWriteTimestamp(DeserializeBuffer* deserializeBuffer) {\n        ComputePassEncoderWriteTimestampCmd cmd;\n        WireResult deserializeResult = cmd.Deserialize(deserializeBuffer, &mAllocator, *this);\n\n        if (deserializeResult == WireResult::FatalError) {\n            return false;\n        }\n\n\n        bool success = DoComputePassEncoderWriteTimestamp(cmd.self, cmd.querySet, cmd.queryIndex);\n\n        if (!success) {\n            return false;\n        }\n        return true;\n    }\n\n    bool Server::HandleComputePipelineGetBindGroupLayout(DeserializeBuffer* deserializeBuffer) {\n        ComputePipelineGetBindGroupLayoutCmd cmd;\n        WireResult deserializeResult = cmd.Deserialize(deserializeBuffer, &mAllocator, *this);\n\n        if (deserializeResult == WireResult::FatalError) {\n            return false;\n        }\n\n\n\n        auto* resultData = BindGroupLayoutObjects().Allocate(cmd.result.id);\n        if (resultData == nullptr) {\n            return false;\n        }\n        resultData->generation = cmd.result.generation;\n\n        bool success = DoComputePipelineGetBindGroupLayout(cmd.self, cmd.groupIndex, &resultData->handle);\n\n        if (!success) {\n            return false;\n        }\n\n        return true;\n    }\n\n    bool Server::HandleComputePipelineSetLabel(DeserializeBuffer* deserializeBuffer) {\n        ComputePipelineSetLabelCmd cmd;\n        WireResult deserializeResult = cmd.Deserialize(deserializeBuffer, &mAllocator, *this);\n\n        if (deserializeResult == WireResult::FatalError) {\n            return false;\n        }\n\n\n        bool success = DoComputePipelineSetLabel(cmd.self, cmd.label);\n\n        if (!success) {\n            return false;\n        }\n        return true;\n    }\n\n    bool Server::HandleDestroyObject(DeserializeBuffer* deserializeBuffer) {\n        DestroyObjectCmd cmd;\n        WireResult deserializeResult = cmd.Deserialize(deserializeBuffer, &mAllocator);\n\n        if (deserializeResult == WireResult::FatalError) {\n            return false;\n        }\n\n\n        bool success = DoDestroyObject(cmd.objectType, cmd.objectId);\n\n        if (!success) {\n            return false;\n        }\n        return true;\n    }\n\n    bool Server::HandleDeviceCreateBindGroup(DeserializeBuffer* deserializeBuffer) {\n        DeviceCreateBindGroupCmd cmd;\n        WireResult deserializeResult = cmd.Deserialize(deserializeBuffer, &mAllocator, *this);\n\n        if (deserializeResult == WireResult::FatalError) {\n            return false;\n        }\n\n\n\n        auto* resultData = BindGroupObjects().Allocate(cmd.result.id);\n        if (resultData == nullptr) {\n            return false;\n        }\n        resultData->generation = cmd.result.generation;\n\n        bool success = DoDeviceCreateBindGroup(cmd.self, cmd.descriptor, &resultData->handle);\n\n        if (!success) {\n            return false;\n        }\n\n        return true;\n    }\n\n    bool Server::HandleDeviceCreateBindGroupLayout(DeserializeBuffer* deserializeBuffer) {\n        DeviceCreateBindGroupLayoutCmd cmd;\n        WireResult deserializeResult = cmd.Deserialize(deserializeBuffer, &mAllocator, *this);\n\n        if (deserializeResult == WireResult::FatalError) {\n            return false;\n        }\n\n\n\n        auto* resultData = BindGroupLayoutObjects().Allocate(cmd.result.id);\n        if (resultData == nullptr) {\n            return false;\n        }\n        resultData->generation = cmd.result.generation;\n\n        bool success = DoDeviceCreateBindGroupLayout(cmd.self, cmd.descriptor, &resultData->handle);\n\n        if (!success) {\n            return false;\n        }\n\n        return true;\n    }\n\n    bool Server::HandleDeviceCreateBuffer(DeserializeBuffer* deserializeBuffer) {\n        DeviceCreateBufferCmd cmd;\n        WireResult deserializeResult = cmd.Deserialize(deserializeBuffer, &mAllocator, *this);\n\n        if (deserializeResult == WireResult::FatalError) {\n            return false;\n        }\n\n\n        bool success = DoDeviceCreateBuffer(cmd.deviceId, cmd.descriptor, cmd.result, cmd.readHandleCreateInfoLength, cmd.readHandleCreateInfo, cmd.writeHandleCreateInfoLength, cmd.writeHandleCreateInfo);\n\n        if (!success) {\n            return false;\n        }\n        return true;\n    }\n\n    bool Server::HandleDeviceCreateCommandEncoder(DeserializeBuffer* deserializeBuffer) {\n        DeviceCreateCommandEncoderCmd cmd;\n        WireResult deserializeResult = cmd.Deserialize(deserializeBuffer, &mAllocator, *this);\n\n        if (deserializeResult == WireResult::FatalError) {\n            return false;\n        }\n\n\n\n        auto* resultData = CommandEncoderObjects().Allocate(cmd.result.id);\n        if (resultData == nullptr) {\n            return false;\n        }\n        resultData->generation = cmd.result.generation;\n\n        bool success = DoDeviceCreateCommandEncoder(cmd.self, cmd.descriptor, &resultData->handle);\n\n        if (!success) {\n            return false;\n        }\n\n        return true;\n    }\n\n    bool Server::HandleDeviceCreateComputePipeline(DeserializeBuffer* deserializeBuffer) {\n        DeviceCreateComputePipelineCmd cmd;\n        WireResult deserializeResult = cmd.Deserialize(deserializeBuffer, &mAllocator, *this);\n\n        if (deserializeResult == WireResult::FatalError) {\n            return false;\n        }\n\n\n\n        auto* resultData = ComputePipelineObjects().Allocate(cmd.result.id);\n        if (resultData == nullptr) {\n            return false;\n        }\n        resultData->generation = cmd.result.generation;\n\n        bool success = DoDeviceCreateComputePipeline(cmd.self, cmd.descriptor, &resultData->handle);\n\n        if (!success) {\n            return false;\n        }\n\n        return true;\n    }\n\n    bool Server::HandleDeviceCreateComputePipelineAsync(DeserializeBuffer* deserializeBuffer) {\n        DeviceCreateComputePipelineAsyncCmd cmd;\n        WireResult deserializeResult = cmd.Deserialize(deserializeBuffer, &mAllocator, *this);\n\n        if (deserializeResult == WireResult::FatalError) {\n            return false;\n        }\n\n\n        bool success = DoDeviceCreateComputePipelineAsync(cmd.deviceId, cmd.requestSerial, cmd.pipelineObjectHandle, cmd.descriptor);\n\n        if (!success) {\n            return false;\n        }\n        return true;\n    }\n\n    bool Server::HandleDeviceCreateErrorBuffer(DeserializeBuffer* deserializeBuffer) {\n        DeviceCreateErrorBufferCmd cmd;\n        WireResult deserializeResult = cmd.Deserialize(deserializeBuffer, &mAllocator, *this);\n\n        if (deserializeResult == WireResult::FatalError) {\n            return false;\n        }\n\n\n\n        auto* resultData = BufferObjects().Allocate(cmd.result.id);\n        if (resultData == nullptr) {\n            return false;\n        }\n        resultData->generation = cmd.result.generation;\n\n        bool success = DoDeviceCreateErrorBuffer(cmd.self, &resultData->handle);\n\n        if (!success) {\n            return false;\n        }\n\n        return true;\n    }\n\n    bool Server::HandleDeviceCreateErrorExternalTexture(DeserializeBuffer* deserializeBuffer) {\n        DeviceCreateErrorExternalTextureCmd cmd;\n        WireResult deserializeResult = cmd.Deserialize(deserializeBuffer, &mAllocator, *this);\n\n        if (deserializeResult == WireResult::FatalError) {\n            return false;\n        }\n\n\n\n        auto* resultData = ExternalTextureObjects().Allocate(cmd.result.id);\n        if (resultData == nullptr) {\n            return false;\n        }\n        resultData->generation = cmd.result.generation;\n\n        bool success = DoDeviceCreateErrorExternalTexture(cmd.self, &resultData->handle);\n\n        if (!success) {\n            return false;\n        }\n\n        return true;\n    }\n\n    bool Server::HandleDeviceCreateErrorTexture(DeserializeBuffer* deserializeBuffer) {\n        DeviceCreateErrorTextureCmd cmd;\n        WireResult deserializeResult = cmd.Deserialize(deserializeBuffer, &mAllocator, *this);\n\n        if (deserializeResult == WireResult::FatalError) {\n            return false;\n        }\n\n\n\n        auto* resultData = TextureObjects().Allocate(cmd.result.id);\n        if (resultData == nullptr) {\n            return false;\n        }\n        resultData->generation = cmd.result.generation;\n\n        bool success = DoDeviceCreateErrorTexture(cmd.self, cmd.descriptor, &resultData->handle);\n\n        if (!success) {\n            return false;\n        }\n\n        return true;\n    }\n\n    bool Server::HandleDeviceCreateExternalTexture(DeserializeBuffer* deserializeBuffer) {\n        DeviceCreateExternalTextureCmd cmd;\n        WireResult deserializeResult = cmd.Deserialize(deserializeBuffer, &mAllocator, *this);\n\n        if (deserializeResult == WireResult::FatalError) {\n            return false;\n        }\n\n\n\n        auto* resultData = ExternalTextureObjects().Allocate(cmd.result.id);\n        if (resultData == nullptr) {\n            return false;\n        }\n        resultData->generation = cmd.result.generation;\n\n        bool success = DoDeviceCreateExternalTexture(cmd.self, cmd.externalTextureDescriptor, &resultData->handle);\n\n        if (!success) {\n            return false;\n        }\n\n        return true;\n    }\n\n    bool Server::HandleDeviceCreatePipelineLayout(DeserializeBuffer* deserializeBuffer) {\n        DeviceCreatePipelineLayoutCmd cmd;\n        WireResult deserializeResult = cmd.Deserialize(deserializeBuffer, &mAllocator, *this);\n\n        if (deserializeResult == WireResult::FatalError) {\n            return false;\n        }\n\n\n\n        auto* resultData = PipelineLayoutObjects().Allocate(cmd.result.id);\n        if (resultData == nullptr) {\n            return false;\n        }\n        resultData->generation = cmd.result.generation;\n\n        bool success = DoDeviceCreatePipelineLayout(cmd.self, cmd.descriptor, &resultData->handle);\n\n        if (!success) {\n            return false;\n        }\n\n        return true;\n    }\n\n    bool Server::HandleDeviceCreateQuerySet(DeserializeBuffer* deserializeBuffer) {\n        DeviceCreateQuerySetCmd cmd;\n        WireResult deserializeResult = cmd.Deserialize(deserializeBuffer, &mAllocator, *this);\n\n        if (deserializeResult == WireResult::FatalError) {\n            return false;\n        }\n\n\n\n        auto* resultData = QuerySetObjects().Allocate(cmd.result.id);\n        if (resultData == nullptr) {\n            return false;\n        }\n        resultData->generation = cmd.result.generation;\n\n        bool success = DoDeviceCreateQuerySet(cmd.self, cmd.descriptor, &resultData->handle);\n\n        if (!success) {\n            return false;\n        }\n\n        return true;\n    }\n\n    bool Server::HandleDeviceCreateRenderBundleEncoder(DeserializeBuffer* deserializeBuffer) {\n        DeviceCreateRenderBundleEncoderCmd cmd;\n        WireResult deserializeResult = cmd.Deserialize(deserializeBuffer, &mAllocator, *this);\n\n        if (deserializeResult == WireResult::FatalError) {\n            return false;\n        }\n\n\n\n        auto* resultData = RenderBundleEncoderObjects().Allocate(cmd.result.id);\n        if (resultData == nullptr) {\n            return false;\n        }\n        resultData->generation = cmd.result.generation;\n\n        bool success = DoDeviceCreateRenderBundleEncoder(cmd.self, cmd.descriptor, &resultData->handle);\n\n        if (!success) {\n            return false;\n        }\n\n        return true;\n    }\n\n    bool Server::HandleDeviceCreateRenderPipeline(DeserializeBuffer* deserializeBuffer) {\n        DeviceCreateRenderPipelineCmd cmd;\n        WireResult deserializeResult = cmd.Deserialize(deserializeBuffer, &mAllocator, *this);\n\n        if (deserializeResult == WireResult::FatalError) {\n            return false;\n        }\n\n\n\n        auto* resultData = RenderPipelineObjects().Allocate(cmd.result.id);\n        if (resultData == nullptr) {\n            return false;\n        }\n        resultData->generation = cmd.result.generation;\n\n        bool success = DoDeviceCreateRenderPipeline(cmd.self, cmd.descriptor, &resultData->handle);\n\n        if (!success) {\n            return false;\n        }\n\n        return true;\n    }\n\n    bool Server::HandleDeviceCreateRenderPipelineAsync(DeserializeBuffer* deserializeBuffer) {\n        DeviceCreateRenderPipelineAsyncCmd cmd;\n        WireResult deserializeResult = cmd.Deserialize(deserializeBuffer, &mAllocator, *this);\n\n        if (deserializeResult == WireResult::FatalError) {\n            return false;\n        }\n\n\n        bool success = DoDeviceCreateRenderPipelineAsync(cmd.deviceId, cmd.requestSerial, cmd.pipelineObjectHandle, cmd.descriptor);\n\n        if (!success) {\n            return false;\n        }\n        return true;\n    }\n\n    bool Server::HandleDeviceCreateSampler(DeserializeBuffer* deserializeBuffer) {\n        DeviceCreateSamplerCmd cmd;\n        WireResult deserializeResult = cmd.Deserialize(deserializeBuffer, &mAllocator, *this);\n\n        if (deserializeResult == WireResult::FatalError) {\n            return false;\n        }\n\n\n\n        auto* resultData = SamplerObjects().Allocate(cmd.result.id);\n        if (resultData == nullptr) {\n            return false;\n        }\n        resultData->generation = cmd.result.generation;\n\n        bool success = DoDeviceCreateSampler(cmd.self, cmd.descriptor, &resultData->handle);\n\n        if (!success) {\n            return false;\n        }\n\n        return true;\n    }\n\n    bool Server::HandleDeviceCreateShaderModule(DeserializeBuffer* deserializeBuffer) {\n        DeviceCreateShaderModuleCmd cmd;\n        WireResult deserializeResult = cmd.Deserialize(deserializeBuffer, &mAllocator, *this);\n\n        if (deserializeResult == WireResult::FatalError) {\n            return false;\n        }\n\n\n\n        auto* resultData = ShaderModuleObjects().Allocate(cmd.result.id);\n        if (resultData == nullptr) {\n            return false;\n        }\n        resultData->generation = cmd.result.generation;\n\n        bool success = DoDeviceCreateShaderModule(cmd.self, cmd.descriptor, &resultData->handle);\n\n        if (!success) {\n            return false;\n        }\n\n        return true;\n    }\n\n    bool Server::HandleDeviceCreateSwapChain(DeserializeBuffer* deserializeBuffer) {\n        DeviceCreateSwapChainCmd cmd;\n        WireResult deserializeResult = cmd.Deserialize(deserializeBuffer, &mAllocator, *this);\n\n        if (deserializeResult == WireResult::FatalError) {\n            return false;\n        }\n\n\n\n        auto* resultData = SwapChainObjects().Allocate(cmd.result.id);\n        if (resultData == nullptr) {\n            return false;\n        }\n        resultData->generation = cmd.result.generation;\n\n        bool success = DoDeviceCreateSwapChain(cmd.self, cmd.surface, cmd.descriptor, &resultData->handle);\n\n        if (!success) {\n            return false;\n        }\n\n        return true;\n    }\n\n    bool Server::HandleDeviceCreateTexture(DeserializeBuffer* deserializeBuffer) {\n        DeviceCreateTextureCmd cmd;\n        WireResult deserializeResult = cmd.Deserialize(deserializeBuffer, &mAllocator, *this);\n\n        if (deserializeResult == WireResult::FatalError) {\n            return false;\n        }\n\n\n\n        auto* resultData = TextureObjects().Allocate(cmd.result.id);\n        if (resultData == nullptr) {\n            return false;\n        }\n        resultData->generation = cmd.result.generation;\n\n        bool success = DoDeviceCreateTexture(cmd.self, cmd.descriptor, &resultData->handle);\n\n        if (!success) {\n            return false;\n        }\n\n        return true;\n    }\n\n    bool Server::HandleDeviceDestroy(DeserializeBuffer* deserializeBuffer) {\n        DeviceDestroyCmd cmd;\n        WireResult deserializeResult = cmd.Deserialize(deserializeBuffer, &mAllocator, *this);\n\n        if (deserializeResult == WireResult::FatalError) {\n            return false;\n        }\n\n\n        bool success = DoDeviceDestroy(cmd.self);\n\n        if (!success) {\n            return false;\n        }\n        return true;\n    }\n\n    bool Server::HandleDeviceGetQueue(DeserializeBuffer* deserializeBuffer) {\n        DeviceGetQueueCmd cmd;\n        WireResult deserializeResult = cmd.Deserialize(deserializeBuffer, &mAllocator, *this);\n\n        if (deserializeResult == WireResult::FatalError) {\n            return false;\n        }\n\n\n\n        auto* resultData = QueueObjects().Allocate(cmd.result.id);\n        if (resultData == nullptr) {\n            return false;\n        }\n        resultData->generation = cmd.result.generation;\n\n        bool success = DoDeviceGetQueue(cmd.self, &resultData->handle);\n\n        if (!success) {\n            return false;\n        }\n\n        return true;\n    }\n\n    bool Server::HandleDeviceInjectError(DeserializeBuffer* deserializeBuffer) {\n        DeviceInjectErrorCmd cmd;\n        WireResult deserializeResult = cmd.Deserialize(deserializeBuffer, &mAllocator, *this);\n\n        if (deserializeResult == WireResult::FatalError) {\n            return false;\n        }\n\n\n        bool success = DoDeviceInjectError(cmd.self, cmd.type, cmd.message);\n\n        if (!success) {\n            return false;\n        }\n        return true;\n    }\n\n    bool Server::HandleDeviceLoseForTesting(DeserializeBuffer* deserializeBuffer) {\n        DeviceLoseForTestingCmd cmd;\n        WireResult deserializeResult = cmd.Deserialize(deserializeBuffer, &mAllocator, *this);\n\n        if (deserializeResult == WireResult::FatalError) {\n            return false;\n        }\n\n\n        bool success = DoDeviceLoseForTesting(cmd.self);\n\n        if (!success) {\n            return false;\n        }\n        return true;\n    }\n\n    bool Server::HandleDevicePopErrorScope(DeserializeBuffer* deserializeBuffer) {\n        DevicePopErrorScopeCmd cmd;\n        WireResult deserializeResult = cmd.Deserialize(deserializeBuffer, &mAllocator);\n\n        if (deserializeResult == WireResult::FatalError) {\n            return false;\n        }\n\n\n        bool success = DoDevicePopErrorScope(cmd.deviceId, cmd.requestSerial);\n\n        if (!success) {\n            return false;\n        }\n        return true;\n    }\n\n    bool Server::HandleDevicePushErrorScope(DeserializeBuffer* deserializeBuffer) {\n        DevicePushErrorScopeCmd cmd;\n        WireResult deserializeResult = cmd.Deserialize(deserializeBuffer, &mAllocator, *this);\n\n        if (deserializeResult == WireResult::FatalError) {\n            return false;\n        }\n\n\n        bool success = DoDevicePushErrorScope(cmd.self, cmd.filter);\n\n        if (!success) {\n            return false;\n        }\n        return true;\n    }\n\n    bool Server::HandleDeviceSetLabel(DeserializeBuffer* deserializeBuffer) {\n        DeviceSetLabelCmd cmd;\n        WireResult deserializeResult = cmd.Deserialize(deserializeBuffer, &mAllocator, *this);\n\n        if (deserializeResult == WireResult::FatalError) {\n            return false;\n        }\n\n\n        bool success = DoDeviceSetLabel(cmd.self, cmd.label);\n\n        if (!success) {\n            return false;\n        }\n        return true;\n    }\n\n    bool Server::HandleDeviceTick(DeserializeBuffer* deserializeBuffer) {\n        DeviceTickCmd cmd;\n        WireResult deserializeResult = cmd.Deserialize(deserializeBuffer, &mAllocator, *this);\n\n        if (deserializeResult == WireResult::FatalError) {\n            return false;\n        }\n\n\n        bool success = DoDeviceTick(cmd.self);\n\n        if (!success) {\n            return false;\n        }\n        return true;\n    }\n\n    bool Server::HandleExternalTextureDestroy(DeserializeBuffer* deserializeBuffer) {\n        ExternalTextureDestroyCmd cmd;\n        WireResult deserializeResult = cmd.Deserialize(deserializeBuffer, &mAllocator, *this);\n\n        if (deserializeResult == WireResult::FatalError) {\n            return false;\n        }\n\n\n        bool success = DoExternalTextureDestroy(cmd.self);\n\n        if (!success) {\n            return false;\n        }\n        return true;\n    }\n\n    bool Server::HandleExternalTextureSetLabel(DeserializeBuffer* deserializeBuffer) {\n        ExternalTextureSetLabelCmd cmd;\n        WireResult deserializeResult = cmd.Deserialize(deserializeBuffer, &mAllocator, *this);\n\n        if (deserializeResult == WireResult::FatalError) {\n            return false;\n        }\n\n\n        bool success = DoExternalTextureSetLabel(cmd.self, cmd.label);\n\n        if (!success) {\n            return false;\n        }\n        return true;\n    }\n\n    bool Server::HandleInstanceCreateSurface(DeserializeBuffer* deserializeBuffer) {\n        InstanceCreateSurfaceCmd cmd;\n        WireResult deserializeResult = cmd.Deserialize(deserializeBuffer, &mAllocator, *this);\n\n        if (deserializeResult == WireResult::FatalError) {\n            return false;\n        }\n\n\n\n        auto* resultData = SurfaceObjects().Allocate(cmd.result.id);\n        if (resultData == nullptr) {\n            return false;\n        }\n        resultData->generation = cmd.result.generation;\n\n        bool success = DoInstanceCreateSurface(cmd.self, cmd.descriptor, &resultData->handle);\n\n        if (!success) {\n            return false;\n        }\n\n        return true;\n    }\n\n    bool Server::HandleInstanceRequestAdapter(DeserializeBuffer* deserializeBuffer) {\n        InstanceRequestAdapterCmd cmd;\n        WireResult deserializeResult = cmd.Deserialize(deserializeBuffer, &mAllocator, *this);\n\n        if (deserializeResult == WireResult::FatalError) {\n            return false;\n        }\n\n\n        bool success = DoInstanceRequestAdapter(cmd.instanceId, cmd.requestSerial, cmd.adapterObjectHandle, cmd.options);\n\n        if (!success) {\n            return false;\n        }\n        return true;\n    }\n\n    bool Server::HandlePipelineLayoutSetLabel(DeserializeBuffer* deserializeBuffer) {\n        PipelineLayoutSetLabelCmd cmd;\n        WireResult deserializeResult = cmd.Deserialize(deserializeBuffer, &mAllocator, *this);\n\n        if (deserializeResult == WireResult::FatalError) {\n            return false;\n        }\n\n\n        bool success = DoPipelineLayoutSetLabel(cmd.self, cmd.label);\n\n        if (!success) {\n            return false;\n        }\n        return true;\n    }\n\n    bool Server::HandleQuerySetDestroy(DeserializeBuffer* deserializeBuffer) {\n        QuerySetDestroyCmd cmd;\n        WireResult deserializeResult = cmd.Deserialize(deserializeBuffer, &mAllocator, *this);\n\n        if (deserializeResult == WireResult::FatalError) {\n            return false;\n        }\n\n\n        bool success = DoQuerySetDestroy(cmd.self);\n\n        if (!success) {\n            return false;\n        }\n        return true;\n    }\n\n    bool Server::HandleQuerySetSetLabel(DeserializeBuffer* deserializeBuffer) {\n        QuerySetSetLabelCmd cmd;\n        WireResult deserializeResult = cmd.Deserialize(deserializeBuffer, &mAllocator, *this);\n\n        if (deserializeResult == WireResult::FatalError) {\n            return false;\n        }\n\n\n        bool success = DoQuerySetSetLabel(cmd.self, cmd.label);\n\n        if (!success) {\n            return false;\n        }\n        return true;\n    }\n\n    bool Server::HandleQueueCopyTextureForBrowser(DeserializeBuffer* deserializeBuffer) {\n        QueueCopyTextureForBrowserCmd cmd;\n        WireResult deserializeResult = cmd.Deserialize(deserializeBuffer, &mAllocator, *this);\n\n        if (deserializeResult == WireResult::FatalError) {\n            return false;\n        }\n\n\n        bool success = DoQueueCopyTextureForBrowser(cmd.self, cmd.source, cmd.destination, cmd.copySize, cmd.options);\n\n        if (!success) {\n            return false;\n        }\n        return true;\n    }\n\n    bool Server::HandleQueueOnSubmittedWorkDone(DeserializeBuffer* deserializeBuffer) {\n        QueueOnSubmittedWorkDoneCmd cmd;\n        WireResult deserializeResult = cmd.Deserialize(deserializeBuffer, &mAllocator);\n\n        if (deserializeResult == WireResult::FatalError) {\n            return false;\n        }\n\n\n        bool success = DoQueueOnSubmittedWorkDone(cmd.queueId, cmd.signalValue, cmd.requestSerial);\n\n        if (!success) {\n            return false;\n        }\n        return true;\n    }\n\n    bool Server::HandleQueueSetLabel(DeserializeBuffer* deserializeBuffer) {\n        QueueSetLabelCmd cmd;\n        WireResult deserializeResult = cmd.Deserialize(deserializeBuffer, &mAllocator, *this);\n\n        if (deserializeResult == WireResult::FatalError) {\n            return false;\n        }\n\n\n        bool success = DoQueueSetLabel(cmd.self, cmd.label);\n\n        if (!success) {\n            return false;\n        }\n        return true;\n    }\n\n    bool Server::HandleQueueSubmit(DeserializeBuffer* deserializeBuffer) {\n        QueueSubmitCmd cmd;\n        WireResult deserializeResult = cmd.Deserialize(deserializeBuffer, &mAllocator, *this);\n\n        if (deserializeResult == WireResult::FatalError) {\n            return false;\n        }\n\n\n        bool success = DoQueueSubmit(cmd.self, cmd.commandCount, cmd.commands);\n\n        if (!success) {\n            return false;\n        }\n        return true;\n    }\n\n    bool Server::HandleQueueWriteBuffer(DeserializeBuffer* deserializeBuffer) {\n        QueueWriteBufferCmd cmd;\n        WireResult deserializeResult = cmd.Deserialize(deserializeBuffer, &mAllocator);\n\n        if (deserializeResult == WireResult::FatalError) {\n            return false;\n        }\n\n\n        bool success = DoQueueWriteBuffer(cmd.queueId, cmd.bufferId, cmd.bufferOffset, cmd.data, cmd.size);\n\n        if (!success) {\n            return false;\n        }\n        return true;\n    }\n\n    bool Server::HandleQueueWriteTexture(DeserializeBuffer* deserializeBuffer) {\n        QueueWriteTextureCmd cmd;\n        WireResult deserializeResult = cmd.Deserialize(deserializeBuffer, &mAllocator, *this);\n\n        if (deserializeResult == WireResult::FatalError) {\n            return false;\n        }\n\n\n        bool success = DoQueueWriteTexture(cmd.queueId, cmd.destination, cmd.data, cmd.dataSize, cmd.dataLayout, cmd.writeSize);\n\n        if (!success) {\n            return false;\n        }\n        return true;\n    }\n\n    bool Server::HandleRenderBundleEncoderDraw(DeserializeBuffer* deserializeBuffer) {\n        RenderBundleEncoderDrawCmd cmd;\n        WireResult deserializeResult = cmd.Deserialize(deserializeBuffer, &mAllocator, *this);\n\n        if (deserializeResult == WireResult::FatalError) {\n            return false;\n        }\n\n\n        bool success = DoRenderBundleEncoderDraw(cmd.self, cmd.vertexCount, cmd.instanceCount, cmd.firstVertex, cmd.firstInstance);\n\n        if (!success) {\n            return false;\n        }\n        return true;\n    }\n\n    bool Server::HandleRenderBundleEncoderDrawIndexed(DeserializeBuffer* deserializeBuffer) {\n        RenderBundleEncoderDrawIndexedCmd cmd;\n        WireResult deserializeResult = cmd.Deserialize(deserializeBuffer, &mAllocator, *this);\n\n        if (deserializeResult == WireResult::FatalError) {\n            return false;\n        }\n\n\n        bool success = DoRenderBundleEncoderDrawIndexed(cmd.self, cmd.indexCount, cmd.instanceCount, cmd.firstIndex, cmd.baseVertex, cmd.firstInstance);\n\n        if (!success) {\n            return false;\n        }\n        return true;\n    }\n\n    bool Server::HandleRenderBundleEncoderDrawIndexedIndirect(DeserializeBuffer* deserializeBuffer) {\n        RenderBundleEncoderDrawIndexedIndirectCmd cmd;\n        WireResult deserializeResult = cmd.Deserialize(deserializeBuffer, &mAllocator, *this);\n\n        if (deserializeResult == WireResult::FatalError) {\n            return false;\n        }\n\n\n        bool success = DoRenderBundleEncoderDrawIndexedIndirect(cmd.self, cmd.indirectBuffer, cmd.indirectOffset);\n\n        if (!success) {\n            return false;\n        }\n        return true;\n    }\n\n    bool Server::HandleRenderBundleEncoderDrawIndirect(DeserializeBuffer* deserializeBuffer) {\n        RenderBundleEncoderDrawIndirectCmd cmd;\n        WireResult deserializeResult = cmd.Deserialize(deserializeBuffer, &mAllocator, *this);\n\n        if (deserializeResult == WireResult::FatalError) {\n            return false;\n        }\n\n\n        bool success = DoRenderBundleEncoderDrawIndirect(cmd.self, cmd.indirectBuffer, cmd.indirectOffset);\n\n        if (!success) {\n            return false;\n        }\n        return true;\n    }\n\n    bool Server::HandleRenderBundleEncoderFinish(DeserializeBuffer* deserializeBuffer) {\n        RenderBundleEncoderFinishCmd cmd;\n        WireResult deserializeResult = cmd.Deserialize(deserializeBuffer, &mAllocator, *this);\n\n        if (deserializeResult == WireResult::FatalError) {\n            return false;\n        }\n\n\n\n        auto* resultData = RenderBundleObjects().Allocate(cmd.result.id);\n        if (resultData == nullptr) {\n            return false;\n        }\n        resultData->generation = cmd.result.generation;\n\n        bool success = DoRenderBundleEncoderFinish(cmd.self, cmd.descriptor, &resultData->handle);\n\n        if (!success) {\n            return false;\n        }\n\n        return true;\n    }\n\n    bool Server::HandleRenderBundleEncoderInsertDebugMarker(DeserializeBuffer* deserializeBuffer) {\n        RenderBundleEncoderInsertDebugMarkerCmd cmd;\n        WireResult deserializeResult = cmd.Deserialize(deserializeBuffer, &mAllocator, *this);\n\n        if (deserializeResult == WireResult::FatalError) {\n            return false;\n        }\n\n\n        bool success = DoRenderBundleEncoderInsertDebugMarker(cmd.self, cmd.markerLabel);\n\n        if (!success) {\n            return false;\n        }\n        return true;\n    }\n\n    bool Server::HandleRenderBundleEncoderPopDebugGroup(DeserializeBuffer* deserializeBuffer) {\n        RenderBundleEncoderPopDebugGroupCmd cmd;\n        WireResult deserializeResult = cmd.Deserialize(deserializeBuffer, &mAllocator, *this);\n\n        if (deserializeResult == WireResult::FatalError) {\n            return false;\n        }\n\n\n        bool success = DoRenderBundleEncoderPopDebugGroup(cmd.self);\n\n        if (!success) {\n            return false;\n        }\n        return true;\n    }\n\n    bool Server::HandleRenderBundleEncoderPushDebugGroup(DeserializeBuffer* deserializeBuffer) {\n        RenderBundleEncoderPushDebugGroupCmd cmd;\n        WireResult deserializeResult = cmd.Deserialize(deserializeBuffer, &mAllocator, *this);\n\n        if (deserializeResult == WireResult::FatalError) {\n            return false;\n        }\n\n\n        bool success = DoRenderBundleEncoderPushDebugGroup(cmd.self, cmd.groupLabel);\n\n        if (!success) {\n            return false;\n        }\n        return true;\n    }\n\n    bool Server::HandleRenderBundleEncoderSetBindGroup(DeserializeBuffer* deserializeBuffer) {\n        RenderBundleEncoderSetBindGroupCmd cmd;\n        WireResult deserializeResult = cmd.Deserialize(deserializeBuffer, &mAllocator, *this);\n\n        if (deserializeResult == WireResult::FatalError) {\n            return false;\n        }\n\n\n        bool success = DoRenderBundleEncoderSetBindGroup(cmd.self, cmd.groupIndex, cmd.group, cmd.dynamicOffsetCount, cmd.dynamicOffsets);\n\n        if (!success) {\n            return false;\n        }\n        return true;\n    }\n\n    bool Server::HandleRenderBundleEncoderSetIndexBuffer(DeserializeBuffer* deserializeBuffer) {\n        RenderBundleEncoderSetIndexBufferCmd cmd;\n        WireResult deserializeResult = cmd.Deserialize(deserializeBuffer, &mAllocator, *this);\n\n        if (deserializeResult == WireResult::FatalError) {\n            return false;\n        }\n\n\n        bool success = DoRenderBundleEncoderSetIndexBuffer(cmd.self, cmd.buffer, cmd.format, cmd.offset, cmd.size);\n\n        if (!success) {\n            return false;\n        }\n        return true;\n    }\n\n    bool Server::HandleRenderBundleEncoderSetLabel(DeserializeBuffer* deserializeBuffer) {\n        RenderBundleEncoderSetLabelCmd cmd;\n        WireResult deserializeResult = cmd.Deserialize(deserializeBuffer, &mAllocator, *this);\n\n        if (deserializeResult == WireResult::FatalError) {\n            return false;\n        }\n\n\n        bool success = DoRenderBundleEncoderSetLabel(cmd.self, cmd.label);\n\n        if (!success) {\n            return false;\n        }\n        return true;\n    }\n\n    bool Server::HandleRenderBundleEncoderSetPipeline(DeserializeBuffer* deserializeBuffer) {\n        RenderBundleEncoderSetPipelineCmd cmd;\n        WireResult deserializeResult = cmd.Deserialize(deserializeBuffer, &mAllocator, *this);\n\n        if (deserializeResult == WireResult::FatalError) {\n            return false;\n        }\n\n\n        bool success = DoRenderBundleEncoderSetPipeline(cmd.self, cmd.pipeline);\n\n        if (!success) {\n            return false;\n        }\n        return true;\n    }\n\n    bool Server::HandleRenderBundleEncoderSetVertexBuffer(DeserializeBuffer* deserializeBuffer) {\n        RenderBundleEncoderSetVertexBufferCmd cmd;\n        WireResult deserializeResult = cmd.Deserialize(deserializeBuffer, &mAllocator, *this);\n\n        if (deserializeResult == WireResult::FatalError) {\n            return false;\n        }\n\n\n        bool success = DoRenderBundleEncoderSetVertexBuffer(cmd.self, cmd.slot, cmd.buffer, cmd.offset, cmd.size);\n\n        if (!success) {\n            return false;\n        }\n        return true;\n    }\n\n    bool Server::HandleRenderPassEncoderBeginOcclusionQuery(DeserializeBuffer* deserializeBuffer) {\n        RenderPassEncoderBeginOcclusionQueryCmd cmd;\n        WireResult deserializeResult = cmd.Deserialize(deserializeBuffer, &mAllocator, *this);\n\n        if (deserializeResult == WireResult::FatalError) {\n            return false;\n        }\n\n\n        bool success = DoRenderPassEncoderBeginOcclusionQuery(cmd.self, cmd.queryIndex);\n\n        if (!success) {\n            return false;\n        }\n        return true;\n    }\n\n    bool Server::HandleRenderPassEncoderDraw(DeserializeBuffer* deserializeBuffer) {\n        RenderPassEncoderDrawCmd cmd;\n        WireResult deserializeResult = cmd.Deserialize(deserializeBuffer, &mAllocator, *this);\n\n        if (deserializeResult == WireResult::FatalError) {\n            return false;\n        }\n\n\n        bool success = DoRenderPassEncoderDraw(cmd.self, cmd.vertexCount, cmd.instanceCount, cmd.firstVertex, cmd.firstInstance);\n\n        if (!success) {\n            return false;\n        }\n        return true;\n    }\n\n    bool Server::HandleRenderPassEncoderDrawIndexed(DeserializeBuffer* deserializeBuffer) {\n        RenderPassEncoderDrawIndexedCmd cmd;\n        WireResult deserializeResult = cmd.Deserialize(deserializeBuffer, &mAllocator, *this);\n\n        if (deserializeResult == WireResult::FatalError) {\n            return false;\n        }\n\n\n        bool success = DoRenderPassEncoderDrawIndexed(cmd.self, cmd.indexCount, cmd.instanceCount, cmd.firstIndex, cmd.baseVertex, cmd.firstInstance);\n\n        if (!success) {\n            return false;\n        }\n        return true;\n    }\n\n    bool Server::HandleRenderPassEncoderDrawIndexedIndirect(DeserializeBuffer* deserializeBuffer) {\n        RenderPassEncoderDrawIndexedIndirectCmd cmd;\n        WireResult deserializeResult = cmd.Deserialize(deserializeBuffer, &mAllocator, *this);\n\n        if (deserializeResult == WireResult::FatalError) {\n            return false;\n        }\n\n\n        bool success = DoRenderPassEncoderDrawIndexedIndirect(cmd.self, cmd.indirectBuffer, cmd.indirectOffset);\n\n        if (!success) {\n            return false;\n        }\n        return true;\n    }\n\n    bool Server::HandleRenderPassEncoderDrawIndirect(DeserializeBuffer* deserializeBuffer) {\n        RenderPassEncoderDrawIndirectCmd cmd;\n        WireResult deserializeResult = cmd.Deserialize(deserializeBuffer, &mAllocator, *this);\n\n        if (deserializeResult == WireResult::FatalError) {\n            return false;\n        }\n\n\n        bool success = DoRenderPassEncoderDrawIndirect(cmd.self, cmd.indirectBuffer, cmd.indirectOffset);\n\n        if (!success) {\n            return false;\n        }\n        return true;\n    }\n\n    bool Server::HandleRenderPassEncoderEnd(DeserializeBuffer* deserializeBuffer) {\n        RenderPassEncoderEndCmd cmd;\n        WireResult deserializeResult = cmd.Deserialize(deserializeBuffer, &mAllocator, *this);\n\n        if (deserializeResult == WireResult::FatalError) {\n            return false;\n        }\n\n\n        bool success = DoRenderPassEncoderEnd(cmd.self);\n\n        if (!success) {\n            return false;\n        }\n        return true;\n    }\n\n    bool Server::HandleRenderPassEncoderEndOcclusionQuery(DeserializeBuffer* deserializeBuffer) {\n        RenderPassEncoderEndOcclusionQueryCmd cmd;\n        WireResult deserializeResult = cmd.Deserialize(deserializeBuffer, &mAllocator, *this);\n\n        if (deserializeResult == WireResult::FatalError) {\n            return false;\n        }\n\n\n        bool success = DoRenderPassEncoderEndOcclusionQuery(cmd.self);\n\n        if (!success) {\n            return false;\n        }\n        return true;\n    }\n\n    bool Server::HandleRenderPassEncoderEndPass(DeserializeBuffer* deserializeBuffer) {\n        RenderPassEncoderEndPassCmd cmd;\n        WireResult deserializeResult = cmd.Deserialize(deserializeBuffer, &mAllocator, *this);\n\n        if (deserializeResult == WireResult::FatalError) {\n            return false;\n        }\n\n\n        bool success = DoRenderPassEncoderEndPass(cmd.self);\n\n        if (!success) {\n            return false;\n        }\n        return true;\n    }\n\n    bool Server::HandleRenderPassEncoderExecuteBundles(DeserializeBuffer* deserializeBuffer) {\n        RenderPassEncoderExecuteBundlesCmd cmd;\n        WireResult deserializeResult = cmd.Deserialize(deserializeBuffer, &mAllocator, *this);\n\n        if (deserializeResult == WireResult::FatalError) {\n            return false;\n        }\n\n\n        bool success = DoRenderPassEncoderExecuteBundles(cmd.self, cmd.bundlesCount, cmd.bundles);\n\n        if (!success) {\n            return false;\n        }\n        return true;\n    }\n\n    bool Server::HandleRenderPassEncoderInsertDebugMarker(DeserializeBuffer* deserializeBuffer) {\n        RenderPassEncoderInsertDebugMarkerCmd cmd;\n        WireResult deserializeResult = cmd.Deserialize(deserializeBuffer, &mAllocator, *this);\n\n        if (deserializeResult == WireResult::FatalError) {\n            return false;\n        }\n\n\n        bool success = DoRenderPassEncoderInsertDebugMarker(cmd.self, cmd.markerLabel);\n\n        if (!success) {\n            return false;\n        }\n        return true;\n    }\n\n    bool Server::HandleRenderPassEncoderPopDebugGroup(DeserializeBuffer* deserializeBuffer) {\n        RenderPassEncoderPopDebugGroupCmd cmd;\n        WireResult deserializeResult = cmd.Deserialize(deserializeBuffer, &mAllocator, *this);\n\n        if (deserializeResult == WireResult::FatalError) {\n            return false;\n        }\n\n\n        bool success = DoRenderPassEncoderPopDebugGroup(cmd.self);\n\n        if (!success) {\n            return false;\n        }\n        return true;\n    }\n\n    bool Server::HandleRenderPassEncoderPushDebugGroup(DeserializeBuffer* deserializeBuffer) {\n        RenderPassEncoderPushDebugGroupCmd cmd;\n        WireResult deserializeResult = cmd.Deserialize(deserializeBuffer, &mAllocator, *this);\n\n        if (deserializeResult == WireResult::FatalError) {\n            return false;\n        }\n\n\n        bool success = DoRenderPassEncoderPushDebugGroup(cmd.self, cmd.groupLabel);\n\n        if (!success) {\n            return false;\n        }\n        return true;\n    }\n\n    bool Server::HandleRenderPassEncoderSetBindGroup(DeserializeBuffer* deserializeBuffer) {\n        RenderPassEncoderSetBindGroupCmd cmd;\n        WireResult deserializeResult = cmd.Deserialize(deserializeBuffer, &mAllocator, *this);\n\n        if (deserializeResult == WireResult::FatalError) {\n            return false;\n        }\n\n\n        bool success = DoRenderPassEncoderSetBindGroup(cmd.self, cmd.groupIndex, cmd.group, cmd.dynamicOffsetCount, cmd.dynamicOffsets);\n\n        if (!success) {\n            return false;\n        }\n        return true;\n    }\n\n    bool Server::HandleRenderPassEncoderSetBlendConstant(DeserializeBuffer* deserializeBuffer) {\n        RenderPassEncoderSetBlendConstantCmd cmd;\n        WireResult deserializeResult = cmd.Deserialize(deserializeBuffer, &mAllocator, *this);\n\n        if (deserializeResult == WireResult::FatalError) {\n            return false;\n        }\n\n\n        bool success = DoRenderPassEncoderSetBlendConstant(cmd.self, cmd.color);\n\n        if (!success) {\n            return false;\n        }\n        return true;\n    }\n\n    bool Server::HandleRenderPassEncoderSetIndexBuffer(DeserializeBuffer* deserializeBuffer) {\n        RenderPassEncoderSetIndexBufferCmd cmd;\n        WireResult deserializeResult = cmd.Deserialize(deserializeBuffer, &mAllocator, *this);\n\n        if (deserializeResult == WireResult::FatalError) {\n            return false;\n        }\n\n\n        bool success = DoRenderPassEncoderSetIndexBuffer(cmd.self, cmd.buffer, cmd.format, cmd.offset, cmd.size);\n\n        if (!success) {\n            return false;\n        }\n        return true;\n    }\n\n    bool Server::HandleRenderPassEncoderSetLabel(DeserializeBuffer* deserializeBuffer) {\n        RenderPassEncoderSetLabelCmd cmd;\n        WireResult deserializeResult = cmd.Deserialize(deserializeBuffer, &mAllocator, *this);\n\n        if (deserializeResult == WireResult::FatalError) {\n            return false;\n        }\n\n\n        bool success = DoRenderPassEncoderSetLabel(cmd.self, cmd.label);\n\n        if (!success) {\n            return false;\n        }\n        return true;\n    }\n\n    bool Server::HandleRenderPassEncoderSetPipeline(DeserializeBuffer* deserializeBuffer) {\n        RenderPassEncoderSetPipelineCmd cmd;\n        WireResult deserializeResult = cmd.Deserialize(deserializeBuffer, &mAllocator, *this);\n\n        if (deserializeResult == WireResult::FatalError) {\n            return false;\n        }\n\n\n        bool success = DoRenderPassEncoderSetPipeline(cmd.self, cmd.pipeline);\n\n        if (!success) {\n            return false;\n        }\n        return true;\n    }\n\n    bool Server::HandleRenderPassEncoderSetScissorRect(DeserializeBuffer* deserializeBuffer) {\n        RenderPassEncoderSetScissorRectCmd cmd;\n        WireResult deserializeResult = cmd.Deserialize(deserializeBuffer, &mAllocator, *this);\n\n        if (deserializeResult == WireResult::FatalError) {\n            return false;\n        }\n\n\n        bool success = DoRenderPassEncoderSetScissorRect(cmd.self, cmd.x, cmd.y, cmd.width, cmd.height);\n\n        if (!success) {\n            return false;\n        }\n        return true;\n    }\n\n    bool Server::HandleRenderPassEncoderSetStencilReference(DeserializeBuffer* deserializeBuffer) {\n        RenderPassEncoderSetStencilReferenceCmd cmd;\n        WireResult deserializeResult = cmd.Deserialize(deserializeBuffer, &mAllocator, *this);\n\n        if (deserializeResult == WireResult::FatalError) {\n            return false;\n        }\n\n\n        bool success = DoRenderPassEncoderSetStencilReference(cmd.self, cmd.reference);\n\n        if (!success) {\n            return false;\n        }\n        return true;\n    }\n\n    bool Server::HandleRenderPassEncoderSetVertexBuffer(DeserializeBuffer* deserializeBuffer) {\n        RenderPassEncoderSetVertexBufferCmd cmd;\n        WireResult deserializeResult = cmd.Deserialize(deserializeBuffer, &mAllocator, *this);\n\n        if (deserializeResult == WireResult::FatalError) {\n            return false;\n        }\n\n\n        bool success = DoRenderPassEncoderSetVertexBuffer(cmd.self, cmd.slot, cmd.buffer, cmd.offset, cmd.size);\n\n        if (!success) {\n            return false;\n        }\n        return true;\n    }\n\n    bool Server::HandleRenderPassEncoderSetViewport(DeserializeBuffer* deserializeBuffer) {\n        RenderPassEncoderSetViewportCmd cmd;\n        WireResult deserializeResult = cmd.Deserialize(deserializeBuffer, &mAllocator, *this);\n\n        if (deserializeResult == WireResult::FatalError) {\n            return false;\n        }\n\n\n        bool success = DoRenderPassEncoderSetViewport(cmd.self, cmd.x, cmd.y, cmd.width, cmd.height, cmd.minDepth, cmd.maxDepth);\n\n        if (!success) {\n            return false;\n        }\n        return true;\n    }\n\n    bool Server::HandleRenderPassEncoderWriteTimestamp(DeserializeBuffer* deserializeBuffer) {\n        RenderPassEncoderWriteTimestampCmd cmd;\n        WireResult deserializeResult = cmd.Deserialize(deserializeBuffer, &mAllocator, *this);\n\n        if (deserializeResult == WireResult::FatalError) {\n            return false;\n        }\n\n\n        bool success = DoRenderPassEncoderWriteTimestamp(cmd.self, cmd.querySet, cmd.queryIndex);\n\n        if (!success) {\n            return false;\n        }\n        return true;\n    }\n\n    bool Server::HandleRenderPipelineGetBindGroupLayout(DeserializeBuffer* deserializeBuffer) {\n        RenderPipelineGetBindGroupLayoutCmd cmd;\n        WireResult deserializeResult = cmd.Deserialize(deserializeBuffer, &mAllocator, *this);\n\n        if (deserializeResult == WireResult::FatalError) {\n            return false;\n        }\n\n\n\n        auto* resultData = BindGroupLayoutObjects().Allocate(cmd.result.id);\n        if (resultData == nullptr) {\n            return false;\n        }\n        resultData->generation = cmd.result.generation;\n\n        bool success = DoRenderPipelineGetBindGroupLayout(cmd.self, cmd.groupIndex, &resultData->handle);\n\n        if (!success) {\n            return false;\n        }\n\n        return true;\n    }\n\n    bool Server::HandleRenderPipelineSetLabel(DeserializeBuffer* deserializeBuffer) {\n        RenderPipelineSetLabelCmd cmd;\n        WireResult deserializeResult = cmd.Deserialize(deserializeBuffer, &mAllocator, *this);\n\n        if (deserializeResult == WireResult::FatalError) {\n            return false;\n        }\n\n\n        bool success = DoRenderPipelineSetLabel(cmd.self, cmd.label);\n\n        if (!success) {\n            return false;\n        }\n        return true;\n    }\n\n    bool Server::HandleSamplerSetLabel(DeserializeBuffer* deserializeBuffer) {\n        SamplerSetLabelCmd cmd;\n        WireResult deserializeResult = cmd.Deserialize(deserializeBuffer, &mAllocator, *this);\n\n        if (deserializeResult == WireResult::FatalError) {\n            return false;\n        }\n\n\n        bool success = DoSamplerSetLabel(cmd.self, cmd.label);\n\n        if (!success) {\n            return false;\n        }\n        return true;\n    }\n\n    bool Server::HandleShaderModuleGetCompilationInfo(DeserializeBuffer* deserializeBuffer) {\n        ShaderModuleGetCompilationInfoCmd cmd;\n        WireResult deserializeResult = cmd.Deserialize(deserializeBuffer, &mAllocator);\n\n        if (deserializeResult == WireResult::FatalError) {\n            return false;\n        }\n\n\n        bool success = DoShaderModuleGetCompilationInfo(cmd.shaderModuleId, cmd.requestSerial);\n\n        if (!success) {\n            return false;\n        }\n        return true;\n    }\n\n    bool Server::HandleShaderModuleSetLabel(DeserializeBuffer* deserializeBuffer) {\n        ShaderModuleSetLabelCmd cmd;\n        WireResult deserializeResult = cmd.Deserialize(deserializeBuffer, &mAllocator, *this);\n\n        if (deserializeResult == WireResult::FatalError) {\n            return false;\n        }\n\n\n        bool success = DoShaderModuleSetLabel(cmd.self, cmd.label);\n\n        if (!success) {\n            return false;\n        }\n        return true;\n    }\n\n    bool Server::HandleSwapChainConfigure(DeserializeBuffer* deserializeBuffer) {\n        SwapChainConfigureCmd cmd;\n        WireResult deserializeResult = cmd.Deserialize(deserializeBuffer, &mAllocator, *this);\n\n        if (deserializeResult == WireResult::FatalError) {\n            return false;\n        }\n\n\n        bool success = DoSwapChainConfigure(cmd.self, cmd.format, cmd.allowedUsage, cmd.width, cmd.height);\n\n        if (!success) {\n            return false;\n        }\n        return true;\n    }\n\n    bool Server::HandleSwapChainGetCurrentTextureView(DeserializeBuffer* deserializeBuffer) {\n        SwapChainGetCurrentTextureViewCmd cmd;\n        WireResult deserializeResult = cmd.Deserialize(deserializeBuffer, &mAllocator, *this);\n\n        if (deserializeResult == WireResult::FatalError) {\n            return false;\n        }\n\n\n\n        auto* resultData = TextureViewObjects().Allocate(cmd.result.id);\n        if (resultData == nullptr) {\n            return false;\n        }\n        resultData->generation = cmd.result.generation;\n\n        bool success = DoSwapChainGetCurrentTextureView(cmd.self, &resultData->handle);\n\n        if (!success) {\n            return false;\n        }\n\n        return true;\n    }\n\n    bool Server::HandleSwapChainPresent(DeserializeBuffer* deserializeBuffer) {\n        SwapChainPresentCmd cmd;\n        WireResult deserializeResult = cmd.Deserialize(deserializeBuffer, &mAllocator, *this);\n\n        if (deserializeResult == WireResult::FatalError) {\n            return false;\n        }\n\n\n        bool success = DoSwapChainPresent(cmd.self);\n\n        if (!success) {\n            return false;\n        }\n        return true;\n    }\n\n    bool Server::HandleTextureCreateView(DeserializeBuffer* deserializeBuffer) {\n        TextureCreateViewCmd cmd;\n        WireResult deserializeResult = cmd.Deserialize(deserializeBuffer, &mAllocator, *this);\n\n        if (deserializeResult == WireResult::FatalError) {\n            return false;\n        }\n\n\n\n        auto* resultData = TextureViewObjects().Allocate(cmd.result.id);\n        if (resultData == nullptr) {\n            return false;\n        }\n        resultData->generation = cmd.result.generation;\n\n        bool success = DoTextureCreateView(cmd.self, cmd.descriptor, &resultData->handle);\n\n        if (!success) {\n            return false;\n        }\n\n        return true;\n    }\n\n    bool Server::HandleTextureDestroy(DeserializeBuffer* deserializeBuffer) {\n        TextureDestroyCmd cmd;\n        WireResult deserializeResult = cmd.Deserialize(deserializeBuffer, &mAllocator, *this);\n\n        if (deserializeResult == WireResult::FatalError) {\n            return false;\n        }\n\n\n        bool success = DoTextureDestroy(cmd.self);\n\n        if (!success) {\n            return false;\n        }\n        return true;\n    }\n\n    bool Server::HandleTextureSetLabel(DeserializeBuffer* deserializeBuffer) {\n        TextureSetLabelCmd cmd;\n        WireResult deserializeResult = cmd.Deserialize(deserializeBuffer, &mAllocator, *this);\n\n        if (deserializeResult == WireResult::FatalError) {\n            return false;\n        }\n\n\n        bool success = DoTextureSetLabel(cmd.self, cmd.label);\n\n        if (!success) {\n            return false;\n        }\n        return true;\n    }\n\n    bool Server::HandleTextureViewSetLabel(DeserializeBuffer* deserializeBuffer) {\n        TextureViewSetLabelCmd cmd;\n        WireResult deserializeResult = cmd.Deserialize(deserializeBuffer, &mAllocator, *this);\n\n        if (deserializeResult == WireResult::FatalError) {\n            return false;\n        }\n\n\n        bool success = DoTextureViewSetLabel(cmd.self, cmd.label);\n\n        if (!success) {\n            return false;\n        }\n        return true;\n    }\n\n    const volatile char* Server::HandleCommandsImpl(const volatile char* commands, size_t size) {\n        DeserializeBuffer deserializeBuffer(commands, size);\n\n        while (deserializeBuffer.AvailableSize() >= sizeof(CmdHeader) + sizeof(WireCmd)) {\n            // Start by chunked command handling, if it is done, then it means the whole buffer\n            // was consumed by it, so we return a pointer to the end of the commands.\n            switch (HandleChunkedCommands(deserializeBuffer.Buffer(), deserializeBuffer.AvailableSize())) {\n                case ChunkedCommandsResult::Consumed:\n                    return commands + size;\n                case ChunkedCommandsResult::Error:\n                    return nullptr;\n                case ChunkedCommandsResult::Passthrough:\n                    break;\n            }\n\n            WireCmd cmdId = *static_cast<const volatile WireCmd*>(static_cast<const volatile void*>(\n                deserializeBuffer.Buffer() + sizeof(CmdHeader)));\n            bool success = false;\n            switch (cmdId) {\n                case WireCmd::AdapterRequestDevice:\n                    success = HandleAdapterRequestDevice(&deserializeBuffer);\n                    break;\n                case WireCmd::BindGroupLayoutSetLabel:\n                    success = HandleBindGroupLayoutSetLabel(&deserializeBuffer);\n                    break;\n                case WireCmd::BindGroupSetLabel:\n                    success = HandleBindGroupSetLabel(&deserializeBuffer);\n                    break;\n                case WireCmd::BufferDestroy:\n                    success = HandleBufferDestroy(&deserializeBuffer);\n                    break;\n                case WireCmd::BufferMapAsync:\n                    success = HandleBufferMapAsync(&deserializeBuffer);\n                    break;\n                case WireCmd::BufferSetLabel:\n                    success = HandleBufferSetLabel(&deserializeBuffer);\n                    break;\n                case WireCmd::BufferUnmap:\n                    success = HandleBufferUnmap(&deserializeBuffer);\n                    break;\n                case WireCmd::BufferUpdateMappedData:\n                    success = HandleBufferUpdateMappedData(&deserializeBuffer);\n                    break;\n                case WireCmd::CommandBufferSetLabel:\n                    success = HandleCommandBufferSetLabel(&deserializeBuffer);\n                    break;\n                case WireCmd::CommandEncoderBeginComputePass:\n                    success = HandleCommandEncoderBeginComputePass(&deserializeBuffer);\n                    break;\n                case WireCmd::CommandEncoderBeginRenderPass:\n                    success = HandleCommandEncoderBeginRenderPass(&deserializeBuffer);\n                    break;\n                case WireCmd::CommandEncoderClearBuffer:\n                    success = HandleCommandEncoderClearBuffer(&deserializeBuffer);\n                    break;\n                case WireCmd::CommandEncoderCopyBufferToBuffer:\n                    success = HandleCommandEncoderCopyBufferToBuffer(&deserializeBuffer);\n                    break;\n                case WireCmd::CommandEncoderCopyBufferToTexture:\n                    success = HandleCommandEncoderCopyBufferToTexture(&deserializeBuffer);\n                    break;\n                case WireCmd::CommandEncoderCopyTextureToBuffer:\n                    success = HandleCommandEncoderCopyTextureToBuffer(&deserializeBuffer);\n                    break;\n                case WireCmd::CommandEncoderCopyTextureToTexture:\n                    success = HandleCommandEncoderCopyTextureToTexture(&deserializeBuffer);\n                    break;\n                case WireCmd::CommandEncoderCopyTextureToTextureInternal:\n                    success = HandleCommandEncoderCopyTextureToTextureInternal(&deserializeBuffer);\n                    break;\n                case WireCmd::CommandEncoderFinish:\n                    success = HandleCommandEncoderFinish(&deserializeBuffer);\n                    break;\n                case WireCmd::CommandEncoderInjectValidationError:\n                    success = HandleCommandEncoderInjectValidationError(&deserializeBuffer);\n                    break;\n                case WireCmd::CommandEncoderInsertDebugMarker:\n                    success = HandleCommandEncoderInsertDebugMarker(&deserializeBuffer);\n                    break;\n                case WireCmd::CommandEncoderPopDebugGroup:\n                    success = HandleCommandEncoderPopDebugGroup(&deserializeBuffer);\n                    break;\n                case WireCmd::CommandEncoderPushDebugGroup:\n                    success = HandleCommandEncoderPushDebugGroup(&deserializeBuffer);\n                    break;\n                case WireCmd::CommandEncoderResolveQuerySet:\n                    success = HandleCommandEncoderResolveQuerySet(&deserializeBuffer);\n                    break;\n                case WireCmd::CommandEncoderSetLabel:\n                    success = HandleCommandEncoderSetLabel(&deserializeBuffer);\n                    break;\n                case WireCmd::CommandEncoderWriteBuffer:\n                    success = HandleCommandEncoderWriteBuffer(&deserializeBuffer);\n                    break;\n                case WireCmd::CommandEncoderWriteTimestamp:\n                    success = HandleCommandEncoderWriteTimestamp(&deserializeBuffer);\n                    break;\n                case WireCmd::ComputePassEncoderDispatch:\n                    success = HandleComputePassEncoderDispatch(&deserializeBuffer);\n                    break;\n                case WireCmd::ComputePassEncoderDispatchIndirect:\n                    success = HandleComputePassEncoderDispatchIndirect(&deserializeBuffer);\n                    break;\n                case WireCmd::ComputePassEncoderDispatchWorkgroups:\n                    success = HandleComputePassEncoderDispatchWorkgroups(&deserializeBuffer);\n                    break;\n                case WireCmd::ComputePassEncoderDispatchWorkgroupsIndirect:\n                    success = HandleComputePassEncoderDispatchWorkgroupsIndirect(&deserializeBuffer);\n                    break;\n                case WireCmd::ComputePassEncoderEnd:\n                    success = HandleComputePassEncoderEnd(&deserializeBuffer);\n                    break;\n                case WireCmd::ComputePassEncoderEndPass:\n                    success = HandleComputePassEncoderEndPass(&deserializeBuffer);\n                    break;\n                case WireCmd::ComputePassEncoderInsertDebugMarker:\n                    success = HandleComputePassEncoderInsertDebugMarker(&deserializeBuffer);\n                    break;\n                case WireCmd::ComputePassEncoderPopDebugGroup:\n                    success = HandleComputePassEncoderPopDebugGroup(&deserializeBuffer);\n                    break;\n                case WireCmd::ComputePassEncoderPushDebugGroup:\n                    success = HandleComputePassEncoderPushDebugGroup(&deserializeBuffer);\n                    break;\n                case WireCmd::ComputePassEncoderSetBindGroup:\n                    success = HandleComputePassEncoderSetBindGroup(&deserializeBuffer);\n                    break;\n                case WireCmd::ComputePassEncoderSetLabel:\n                    success = HandleComputePassEncoderSetLabel(&deserializeBuffer);\n                    break;\n                case WireCmd::ComputePassEncoderSetPipeline:\n                    success = HandleComputePassEncoderSetPipeline(&deserializeBuffer);\n                    break;\n                case WireCmd::ComputePassEncoderWriteTimestamp:\n                    success = HandleComputePassEncoderWriteTimestamp(&deserializeBuffer);\n                    break;\n                case WireCmd::ComputePipelineGetBindGroupLayout:\n                    success = HandleComputePipelineGetBindGroupLayout(&deserializeBuffer);\n                    break;\n                case WireCmd::ComputePipelineSetLabel:\n                    success = HandleComputePipelineSetLabel(&deserializeBuffer);\n                    break;\n                case WireCmd::DestroyObject:\n                    success = HandleDestroyObject(&deserializeBuffer);\n                    break;\n                case WireCmd::DeviceCreateBindGroup:\n                    success = HandleDeviceCreateBindGroup(&deserializeBuffer);\n                    break;\n                case WireCmd::DeviceCreateBindGroupLayout:\n                    success = HandleDeviceCreateBindGroupLayout(&deserializeBuffer);\n                    break;\n                case WireCmd::DeviceCreateBuffer:\n                    success = HandleDeviceCreateBuffer(&deserializeBuffer);\n                    break;\n                case WireCmd::DeviceCreateCommandEncoder:\n                    success = HandleDeviceCreateCommandEncoder(&deserializeBuffer);\n                    break;\n                case WireCmd::DeviceCreateComputePipeline:\n                    success = HandleDeviceCreateComputePipeline(&deserializeBuffer);\n                    break;\n                case WireCmd::DeviceCreateComputePipelineAsync:\n                    success = HandleDeviceCreateComputePipelineAsync(&deserializeBuffer);\n                    break;\n                case WireCmd::DeviceCreateErrorBuffer:\n                    success = HandleDeviceCreateErrorBuffer(&deserializeBuffer);\n                    break;\n                case WireCmd::DeviceCreateErrorExternalTexture:\n                    success = HandleDeviceCreateErrorExternalTexture(&deserializeBuffer);\n                    break;\n                case WireCmd::DeviceCreateErrorTexture:\n                    success = HandleDeviceCreateErrorTexture(&deserializeBuffer);\n                    break;\n                case WireCmd::DeviceCreateExternalTexture:\n                    success = HandleDeviceCreateExternalTexture(&deserializeBuffer);\n                    break;\n                case WireCmd::DeviceCreatePipelineLayout:\n                    success = HandleDeviceCreatePipelineLayout(&deserializeBuffer);\n                    break;\n                case WireCmd::DeviceCreateQuerySet:\n                    success = HandleDeviceCreateQuerySet(&deserializeBuffer);\n                    break;\n                case WireCmd::DeviceCreateRenderBundleEncoder:\n                    success = HandleDeviceCreateRenderBundleEncoder(&deserializeBuffer);\n                    break;\n                case WireCmd::DeviceCreateRenderPipeline:\n                    success = HandleDeviceCreateRenderPipeline(&deserializeBuffer);\n                    break;\n                case WireCmd::DeviceCreateRenderPipelineAsync:\n                    success = HandleDeviceCreateRenderPipelineAsync(&deserializeBuffer);\n                    break;\n                case WireCmd::DeviceCreateSampler:\n                    success = HandleDeviceCreateSampler(&deserializeBuffer);\n                    break;\n                case WireCmd::DeviceCreateShaderModule:\n                    success = HandleDeviceCreateShaderModule(&deserializeBuffer);\n                    break;\n                case WireCmd::DeviceCreateSwapChain:\n                    success = HandleDeviceCreateSwapChain(&deserializeBuffer);\n                    break;\n                case WireCmd::DeviceCreateTexture:\n                    success = HandleDeviceCreateTexture(&deserializeBuffer);\n                    break;\n                case WireCmd::DeviceDestroy:\n                    success = HandleDeviceDestroy(&deserializeBuffer);\n                    break;\n                case WireCmd::DeviceGetQueue:\n                    success = HandleDeviceGetQueue(&deserializeBuffer);\n                    break;\n                case WireCmd::DeviceInjectError:\n                    success = HandleDeviceInjectError(&deserializeBuffer);\n                    break;\n                case WireCmd::DeviceLoseForTesting:\n                    success = HandleDeviceLoseForTesting(&deserializeBuffer);\n                    break;\n                case WireCmd::DevicePopErrorScope:\n                    success = HandleDevicePopErrorScope(&deserializeBuffer);\n                    break;\n                case WireCmd::DevicePushErrorScope:\n                    success = HandleDevicePushErrorScope(&deserializeBuffer);\n                    break;\n                case WireCmd::DeviceSetLabel:\n                    success = HandleDeviceSetLabel(&deserializeBuffer);\n                    break;\n                case WireCmd::DeviceTick:\n                    success = HandleDeviceTick(&deserializeBuffer);\n                    break;\n                case WireCmd::ExternalTextureDestroy:\n                    success = HandleExternalTextureDestroy(&deserializeBuffer);\n                    break;\n                case WireCmd::ExternalTextureSetLabel:\n                    success = HandleExternalTextureSetLabel(&deserializeBuffer);\n                    break;\n                case WireCmd::InstanceCreateSurface:\n                    success = HandleInstanceCreateSurface(&deserializeBuffer);\n                    break;\n                case WireCmd::InstanceRequestAdapter:\n                    success = HandleInstanceRequestAdapter(&deserializeBuffer);\n                    break;\n                case WireCmd::PipelineLayoutSetLabel:\n                    success = HandlePipelineLayoutSetLabel(&deserializeBuffer);\n                    break;\n                case WireCmd::QuerySetDestroy:\n                    success = HandleQuerySetDestroy(&deserializeBuffer);\n                    break;\n                case WireCmd::QuerySetSetLabel:\n                    success = HandleQuerySetSetLabel(&deserializeBuffer);\n                    break;\n                case WireCmd::QueueCopyTextureForBrowser:\n                    success = HandleQueueCopyTextureForBrowser(&deserializeBuffer);\n                    break;\n                case WireCmd::QueueOnSubmittedWorkDone:\n                    success = HandleQueueOnSubmittedWorkDone(&deserializeBuffer);\n                    break;\n                case WireCmd::QueueSetLabel:\n                    success = HandleQueueSetLabel(&deserializeBuffer);\n                    break;\n                case WireCmd::QueueSubmit:\n                    success = HandleQueueSubmit(&deserializeBuffer);\n                    break;\n                case WireCmd::QueueWriteBuffer:\n                    success = HandleQueueWriteBuffer(&deserializeBuffer);\n                    break;\n                case WireCmd::QueueWriteTexture:\n                    success = HandleQueueWriteTexture(&deserializeBuffer);\n                    break;\n                case WireCmd::RenderBundleEncoderDraw:\n                    success = HandleRenderBundleEncoderDraw(&deserializeBuffer);\n                    break;\n                case WireCmd::RenderBundleEncoderDrawIndexed:\n                    success = HandleRenderBundleEncoderDrawIndexed(&deserializeBuffer);\n                    break;\n                case WireCmd::RenderBundleEncoderDrawIndexedIndirect:\n                    success = HandleRenderBundleEncoderDrawIndexedIndirect(&deserializeBuffer);\n                    break;\n                case WireCmd::RenderBundleEncoderDrawIndirect:\n                    success = HandleRenderBundleEncoderDrawIndirect(&deserializeBuffer);\n                    break;\n                case WireCmd::RenderBundleEncoderFinish:\n                    success = HandleRenderBundleEncoderFinish(&deserializeBuffer);\n                    break;\n                case WireCmd::RenderBundleEncoderInsertDebugMarker:\n                    success = HandleRenderBundleEncoderInsertDebugMarker(&deserializeBuffer);\n                    break;\n                case WireCmd::RenderBundleEncoderPopDebugGroup:\n                    success = HandleRenderBundleEncoderPopDebugGroup(&deserializeBuffer);\n                    break;\n                case WireCmd::RenderBundleEncoderPushDebugGroup:\n                    success = HandleRenderBundleEncoderPushDebugGroup(&deserializeBuffer);\n                    break;\n                case WireCmd::RenderBundleEncoderSetBindGroup:\n                    success = HandleRenderBundleEncoderSetBindGroup(&deserializeBuffer);\n                    break;\n                case WireCmd::RenderBundleEncoderSetIndexBuffer:\n                    success = HandleRenderBundleEncoderSetIndexBuffer(&deserializeBuffer);\n                    break;\n                case WireCmd::RenderBundleEncoderSetLabel:\n                    success = HandleRenderBundleEncoderSetLabel(&deserializeBuffer);\n                    break;\n                case WireCmd::RenderBundleEncoderSetPipeline:\n                    success = HandleRenderBundleEncoderSetPipeline(&deserializeBuffer);\n                    break;\n                case WireCmd::RenderBundleEncoderSetVertexBuffer:\n                    success = HandleRenderBundleEncoderSetVertexBuffer(&deserializeBuffer);\n                    break;\n                case WireCmd::RenderPassEncoderBeginOcclusionQuery:\n                    success = HandleRenderPassEncoderBeginOcclusionQuery(&deserializeBuffer);\n                    break;\n                case WireCmd::RenderPassEncoderDraw:\n                    success = HandleRenderPassEncoderDraw(&deserializeBuffer);\n                    break;\n                case WireCmd::RenderPassEncoderDrawIndexed:\n                    success = HandleRenderPassEncoderDrawIndexed(&deserializeBuffer);\n                    break;\n                case WireCmd::RenderPassEncoderDrawIndexedIndirect:\n                    success = HandleRenderPassEncoderDrawIndexedIndirect(&deserializeBuffer);\n                    break;\n                case WireCmd::RenderPassEncoderDrawIndirect:\n                    success = HandleRenderPassEncoderDrawIndirect(&deserializeBuffer);\n                    break;\n                case WireCmd::RenderPassEncoderEnd:\n                    success = HandleRenderPassEncoderEnd(&deserializeBuffer);\n                    break;\n                case WireCmd::RenderPassEncoderEndOcclusionQuery:\n                    success = HandleRenderPassEncoderEndOcclusionQuery(&deserializeBuffer);\n                    break;\n                case WireCmd::RenderPassEncoderEndPass:\n                    success = HandleRenderPassEncoderEndPass(&deserializeBuffer);\n                    break;\n                case WireCmd::RenderPassEncoderExecuteBundles:\n                    success = HandleRenderPassEncoderExecuteBundles(&deserializeBuffer);\n                    break;\n                case WireCmd::RenderPassEncoderInsertDebugMarker:\n                    success = HandleRenderPassEncoderInsertDebugMarker(&deserializeBuffer);\n                    break;\n                case WireCmd::RenderPassEncoderPopDebugGroup:\n                    success = HandleRenderPassEncoderPopDebugGroup(&deserializeBuffer);\n                    break;\n                case WireCmd::RenderPassEncoderPushDebugGroup:\n                    success = HandleRenderPassEncoderPushDebugGroup(&deserializeBuffer);\n                    break;\n                case WireCmd::RenderPassEncoderSetBindGroup:\n                    success = HandleRenderPassEncoderSetBindGroup(&deserializeBuffer);\n                    break;\n                case WireCmd::RenderPassEncoderSetBlendConstant:\n                    success = HandleRenderPassEncoderSetBlendConstant(&deserializeBuffer);\n                    break;\n                case WireCmd::RenderPassEncoderSetIndexBuffer:\n                    success = HandleRenderPassEncoderSetIndexBuffer(&deserializeBuffer);\n                    break;\n                case WireCmd::RenderPassEncoderSetLabel:\n                    success = HandleRenderPassEncoderSetLabel(&deserializeBuffer);\n                    break;\n                case WireCmd::RenderPassEncoderSetPipeline:\n                    success = HandleRenderPassEncoderSetPipeline(&deserializeBuffer);\n                    break;\n                case WireCmd::RenderPassEncoderSetScissorRect:\n                    success = HandleRenderPassEncoderSetScissorRect(&deserializeBuffer);\n                    break;\n                case WireCmd::RenderPassEncoderSetStencilReference:\n                    success = HandleRenderPassEncoderSetStencilReference(&deserializeBuffer);\n                    break;\n                case WireCmd::RenderPassEncoderSetVertexBuffer:\n                    success = HandleRenderPassEncoderSetVertexBuffer(&deserializeBuffer);\n                    break;\n                case WireCmd::RenderPassEncoderSetViewport:\n                    success = HandleRenderPassEncoderSetViewport(&deserializeBuffer);\n                    break;\n                case WireCmd::RenderPassEncoderWriteTimestamp:\n                    success = HandleRenderPassEncoderWriteTimestamp(&deserializeBuffer);\n                    break;\n                case WireCmd::RenderPipelineGetBindGroupLayout:\n                    success = HandleRenderPipelineGetBindGroupLayout(&deserializeBuffer);\n                    break;\n                case WireCmd::RenderPipelineSetLabel:\n                    success = HandleRenderPipelineSetLabel(&deserializeBuffer);\n                    break;\n                case WireCmd::SamplerSetLabel:\n                    success = HandleSamplerSetLabel(&deserializeBuffer);\n                    break;\n                case WireCmd::ShaderModuleGetCompilationInfo:\n                    success = HandleShaderModuleGetCompilationInfo(&deserializeBuffer);\n                    break;\n                case WireCmd::ShaderModuleSetLabel:\n                    success = HandleShaderModuleSetLabel(&deserializeBuffer);\n                    break;\n                case WireCmd::SwapChainConfigure:\n                    success = HandleSwapChainConfigure(&deserializeBuffer);\n                    break;\n                case WireCmd::SwapChainGetCurrentTextureView:\n                    success = HandleSwapChainGetCurrentTextureView(&deserializeBuffer);\n                    break;\n                case WireCmd::SwapChainPresent:\n                    success = HandleSwapChainPresent(&deserializeBuffer);\n                    break;\n                case WireCmd::TextureCreateView:\n                    success = HandleTextureCreateView(&deserializeBuffer);\n                    break;\n                case WireCmd::TextureDestroy:\n                    success = HandleTextureDestroy(&deserializeBuffer);\n                    break;\n                case WireCmd::TextureSetLabel:\n                    success = HandleTextureSetLabel(&deserializeBuffer);\n                    break;\n                case WireCmd::TextureViewSetLabel:\n                    success = HandleTextureViewSetLabel(&deserializeBuffer);\n                    break;\n                default:\n                    success = false;\n            }\n\n            if (!success) {\n                return nullptr;\n            }\n            mAllocator.Reset();\n        }\n\n        if (deserializeBuffer.AvailableSize() != 0) {\n            return nullptr;\n        }\n\n        return commands;\n    }\n\n}  // namespace dawn::wire::server\n", "src/dawn/wire/server/ServerPrototypes_autogen.inc": "\n// Command handlers & doers\nbool HandleAdapterRequestDevice(DeserializeBuffer* deserializeBuffer);\n\nbool DoAdapterRequestDevice(ObjectId adapterId, uint64_t requestSerial, ObjectHandle deviceObjectHandle, WGPUDeviceDescriptor const * descriptor);\nbool HandleBindGroupLayoutSetLabel(DeserializeBuffer* deserializeBuffer);\n\nbool DoBindGroupLayoutSetLabel(WGPUBindGroupLayout self, char const * label);\nbool HandleBindGroupSetLabel(DeserializeBuffer* deserializeBuffer);\n\nbool DoBindGroupSetLabel(WGPUBindGroup self, char const * label);\nbool HandleBufferDestroy(DeserializeBuffer* deserializeBuffer);\n\nbool DoBufferDestroy(WGPUBuffer self);\nbool HandleBufferMapAsync(DeserializeBuffer* deserializeBuffer);\n\nbool DoBufferMapAsync(ObjectId bufferId, uint64_t requestSerial, WGPUMapModeFlags mode, uint64_t offset, uint64_t size);\nbool HandleBufferSetLabel(DeserializeBuffer* deserializeBuffer);\n\nbool DoBufferSetLabel(WGPUBuffer self, char const * label);\nbool HandleBufferUnmap(DeserializeBuffer* deserializeBuffer);\n\nbool DoBufferUnmap(WGPUBuffer self);\nbool HandleBufferUpdateMappedData(DeserializeBuffer* deserializeBuffer);\n\nbool DoBufferUpdateMappedData(ObjectId bufferId, uint64_t writeDataUpdateInfoLength, uint8_t const * writeDataUpdateInfo, uint64_t offset, uint64_t size);\nbool HandleCommandBufferSetLabel(DeserializeBuffer* deserializeBuffer);\n\nbool DoCommandBufferSetLabel(WGPUCommandBuffer self, char const * label);\nbool HandleCommandEncoderBeginComputePass(DeserializeBuffer* deserializeBuffer);\n\nbool DoCommandEncoderBeginComputePass(WGPUCommandEncoder self, WGPUComputePassDescriptor const * descriptor, WGPUComputePassEncoder* result);\nbool HandleCommandEncoderBeginRenderPass(DeserializeBuffer* deserializeBuffer);\n\nbool DoCommandEncoderBeginRenderPass(WGPUCommandEncoder self, WGPURenderPassDescriptor const * descriptor, WGPURenderPassEncoder* result);\nbool HandleCommandEncoderClearBuffer(DeserializeBuffer* deserializeBuffer);\n\nbool DoCommandEncoderClearBuffer(WGPUCommandEncoder self, WGPUBuffer buffer, uint64_t offset, uint64_t size);\nbool HandleCommandEncoderCopyBufferToBuffer(DeserializeBuffer* deserializeBuffer);\n\nbool DoCommandEncoderCopyBufferToBuffer(WGPUCommandEncoder self, WGPUBuffer source, uint64_t sourceOffset, WGPUBuffer destination, uint64_t destinationOffset, uint64_t size);\nbool HandleCommandEncoderCopyBufferToTexture(DeserializeBuffer* deserializeBuffer);\n\nbool DoCommandEncoderCopyBufferToTexture(WGPUCommandEncoder self, WGPUImageCopyBuffer const * source, WGPUImageCopyTexture const * destination, WGPUExtent3D const * copySize);\nbool HandleCommandEncoderCopyTextureToBuffer(DeserializeBuffer* deserializeBuffer);\n\nbool DoCommandEncoderCopyTextureToBuffer(WGPUCommandEncoder self, WGPUImageCopyTexture const * source, WGPUImageCopyBuffer const * destination, WGPUExtent3D const * copySize);\nbool HandleCommandEncoderCopyTextureToTexture(DeserializeBuffer* deserializeBuffer);\n\nbool DoCommandEncoderCopyTextureToTexture(WGPUCommandEncoder self, WGPUImageCopyTexture const * source, WGPUImageCopyTexture const * destination, WGPUExtent3D const * copySize);\nbool HandleCommandEncoderCopyTextureToTextureInternal(DeserializeBuffer* deserializeBuffer);\n\nbool DoCommandEncoderCopyTextureToTextureInternal(WGPUCommandEncoder self, WGPUImageCopyTexture const * source, WGPUImageCopyTexture const * destination, WGPUExtent3D const * copySize);\nbool HandleCommandEncoderFinish(DeserializeBuffer* deserializeBuffer);\n\nbool DoCommandEncoderFinish(WGPUCommandEncoder self, WGPUCommandBufferDescriptor const * descriptor, WGPUCommandBuffer* result);\nbool HandleCommandEncoderInjectValidationError(DeserializeBuffer* deserializeBuffer);\n\nbool DoCommandEncoderInjectValidationError(WGPUCommandEncoder self, char const * message);\nbool HandleCommandEncoderInsertDebugMarker(DeserializeBuffer* deserializeBuffer);\n\nbool DoCommandEncoderInsertDebugMarker(WGPUCommandEncoder self, char const * markerLabel);\nbool HandleCommandEncoderPopDebugGroup(DeserializeBuffer* deserializeBuffer);\n\nbool DoCommandEncoderPopDebugGroup(WGPUCommandEncoder self);\nbool HandleCommandEncoderPushDebugGroup(DeserializeBuffer* deserializeBuffer);\n\nbool DoCommandEncoderPushDebugGroup(WGPUCommandEncoder self, char const * groupLabel);\nbool HandleCommandEncoderResolveQuerySet(DeserializeBuffer* deserializeBuffer);\n\nbool DoCommandEncoderResolveQuerySet(WGPUCommandEncoder self, WGPUQuerySet querySet, uint32_t firstQuery, uint32_t queryCount, WGPUBuffer destination, uint64_t destinationOffset);\nbool HandleCommandEncoderSetLabel(DeserializeBuffer* deserializeBuffer);\n\nbool DoCommandEncoderSetLabel(WGPUCommandEncoder self, char const * label);\nbool HandleCommandEncoderWriteBuffer(DeserializeBuffer* deserializeBuffer);\n\nbool DoCommandEncoderWriteBuffer(WGPUCommandEncoder self, WGPUBuffer buffer, uint64_t bufferOffset, uint8_t const * data, uint64_t size);\nbool HandleCommandEncoderWriteTimestamp(DeserializeBuffer* deserializeBuffer);\n\nbool DoCommandEncoderWriteTimestamp(WGPUCommandEncoder self, WGPUQuerySet querySet, uint32_t queryIndex);\nbool HandleComputePassEncoderDispatch(DeserializeBuffer* deserializeBuffer);\n\nbool DoComputePassEncoderDispatch(WGPUComputePassEncoder self, uint32_t workgroupCountX, uint32_t workgroupCountY, uint32_t workgroupCountZ);\nbool HandleComputePassEncoderDispatchIndirect(DeserializeBuffer* deserializeBuffer);\n\nbool DoComputePassEncoderDispatchIndirect(WGPUComputePassEncoder self, WGPUBuffer indirectBuffer, uint64_t indirectOffset);\nbool HandleComputePassEncoderDispatchWorkgroups(DeserializeBuffer* deserializeBuffer);\n\nbool DoComputePassEncoderDispatchWorkgroups(WGPUComputePassEncoder self, uint32_t workgroupCountX, uint32_t workgroupCountY, uint32_t workgroupCountZ);\nbool HandleComputePassEncoderDispatchWorkgroupsIndirect(DeserializeBuffer* deserializeBuffer);\n\nbool DoComputePassEncoderDispatchWorkgroupsIndirect(WGPUComputePassEncoder self, WGPUBuffer indirectBuffer, uint64_t indirectOffset);\nbool HandleComputePassEncoderEnd(DeserializeBuffer* deserializeBuffer);\n\nbool DoComputePassEncoderEnd(WGPUComputePassEncoder self);\nbool HandleComputePassEncoderEndPass(DeserializeBuffer* deserializeBuffer);\n\nbool DoComputePassEncoderEndPass(WGPUComputePassEncoder self);\nbool HandleComputePassEncoderInsertDebugMarker(DeserializeBuffer* deserializeBuffer);\n\nbool DoComputePassEncoderInsertDebugMarker(WGPUComputePassEncoder self, char const * markerLabel);\nbool HandleComputePassEncoderPopDebugGroup(DeserializeBuffer* deserializeBuffer);\n\nbool DoComputePassEncoderPopDebugGroup(WGPUComputePassEncoder self);\nbool HandleComputePassEncoderPushDebugGroup(DeserializeBuffer* deserializeBuffer);\n\nbool DoComputePassEncoderPushDebugGroup(WGPUComputePassEncoder self, char const * groupLabel);\nbool HandleComputePassEncoderSetBindGroup(DeserializeBuffer* deserializeBuffer);\n\nbool DoComputePassEncoderSetBindGroup(WGPUComputePassEncoder self, uint32_t groupIndex, WGPUBindGroup group, uint32_t dynamicOffsetCount, uint32_t const * dynamicOffsets);\nbool HandleComputePassEncoderSetLabel(DeserializeBuffer* deserializeBuffer);\n\nbool DoComputePassEncoderSetLabel(WGPUComputePassEncoder self, char const * label);\nbool HandleComputePassEncoderSetPipeline(DeserializeBuffer* deserializeBuffer);\n\nbool DoComputePassEncoderSetPipeline(WGPUComputePassEncoder self, WGPUComputePipeline pipeline);\nbool HandleComputePassEncoderWriteTimestamp(DeserializeBuffer* deserializeBuffer);\n\nbool DoComputePassEncoderWriteTimestamp(WGPUComputePassEncoder self, WGPUQuerySet querySet, uint32_t queryIndex);\nbool HandleComputePipelineGetBindGroupLayout(DeserializeBuffer* deserializeBuffer);\n\nbool DoComputePipelineGetBindGroupLayout(WGPUComputePipeline self, uint32_t groupIndex, WGPUBindGroupLayout* result);\nbool HandleComputePipelineSetLabel(DeserializeBuffer* deserializeBuffer);\n\nbool DoComputePipelineSetLabel(WGPUComputePipeline self, char const * label);\nbool HandleDestroyObject(DeserializeBuffer* deserializeBuffer);\n\nbool DoDestroyObject(ObjectType objectType, ObjectId objectId);\nbool HandleDeviceCreateBindGroup(DeserializeBuffer* deserializeBuffer);\n\nbool DoDeviceCreateBindGroup(WGPUDevice self, WGPUBindGroupDescriptor const * descriptor, WGPUBindGroup* result);\nbool HandleDeviceCreateBindGroupLayout(DeserializeBuffer* deserializeBuffer);\n\nbool DoDeviceCreateBindGroupLayout(WGPUDevice self, WGPUBindGroupLayoutDescriptor const * descriptor, WGPUBindGroupLayout* result);\nbool HandleDeviceCreateBuffer(DeserializeBuffer* deserializeBuffer);\n\nbool DoDeviceCreateBuffer(ObjectId deviceId, WGPUBufferDescriptor const * descriptor, ObjectHandle result, uint64_t readHandleCreateInfoLength, uint8_t const * readHandleCreateInfo, uint64_t writeHandleCreateInfoLength, uint8_t const * writeHandleCreateInfo);\nbool HandleDeviceCreateCommandEncoder(DeserializeBuffer* deserializeBuffer);\n\nbool DoDeviceCreateCommandEncoder(WGPUDevice self, WGPUCommandEncoderDescriptor const * descriptor, WGPUCommandEncoder* result);\nbool HandleDeviceCreateComputePipeline(DeserializeBuffer* deserializeBuffer);\n\nbool DoDeviceCreateComputePipeline(WGPUDevice self, WGPUComputePipelineDescriptor const * descriptor, WGPUComputePipeline* result);\nbool HandleDeviceCreateComputePipelineAsync(DeserializeBuffer* deserializeBuffer);\n\nbool DoDeviceCreateComputePipelineAsync(ObjectId deviceId, uint64_t requestSerial, ObjectHandle pipelineObjectHandle, WGPUComputePipelineDescriptor const * descriptor);\nbool HandleDeviceCreateErrorBuffer(DeserializeBuffer* deserializeBuffer);\n\nbool DoDeviceCreateErrorBuffer(WGPUDevice self, WGPUBuffer* result);\nbool HandleDeviceCreateErrorExternalTexture(DeserializeBuffer* deserializeBuffer);\n\nbool DoDeviceCreateErrorExternalTexture(WGPUDevice self, WGPUExternalTexture* result);\nbool HandleDeviceCreateErrorTexture(DeserializeBuffer* deserializeBuffer);\n\nbool DoDeviceCreateErrorTexture(WGPUDevice self, WGPUTextureDescriptor const * descriptor, WGPUTexture* result);\nbool HandleDeviceCreateExternalTexture(DeserializeBuffer* deserializeBuffer);\n\nbool DoDeviceCreateExternalTexture(WGPUDevice self, WGPUExternalTextureDescriptor const * externalTextureDescriptor, WGPUExternalTexture* result);\nbool HandleDeviceCreatePipelineLayout(DeserializeBuffer* deserializeBuffer);\n\nbool DoDeviceCreatePipelineLayout(WGPUDevice self, WGPUPipelineLayoutDescriptor const * descriptor, WGPUPipelineLayout* result);\nbool HandleDeviceCreateQuerySet(DeserializeBuffer* deserializeBuffer);\n\nbool DoDeviceCreateQuerySet(WGPUDevice self, WGPUQuerySetDescriptor const * descriptor, WGPUQuerySet* result);\nbool HandleDeviceCreateRenderBundleEncoder(DeserializeBuffer* deserializeBuffer);\n\nbool DoDeviceCreateRenderBundleEncoder(WGPUDevice self, WGPURenderBundleEncoderDescriptor const * descriptor, WGPURenderBundleEncoder* result);\nbool HandleDeviceCreateRenderPipeline(DeserializeBuffer* deserializeBuffer);\n\nbool DoDeviceCreateRenderPipeline(WGPUDevice self, WGPURenderPipelineDescriptor const * descriptor, WGPURenderPipeline* result);\nbool HandleDeviceCreateRenderPipelineAsync(DeserializeBuffer* deserializeBuffer);\n\nbool DoDeviceCreateRenderPipelineAsync(ObjectId deviceId, uint64_t requestSerial, ObjectHandle pipelineObjectHandle, WGPURenderPipelineDescriptor const * descriptor);\nbool HandleDeviceCreateSampler(DeserializeBuffer* deserializeBuffer);\n\nbool DoDeviceCreateSampler(WGPUDevice self, WGPUSamplerDescriptor const * descriptor, WGPUSampler* result);\nbool HandleDeviceCreateShaderModule(DeserializeBuffer* deserializeBuffer);\n\nbool DoDeviceCreateShaderModule(WGPUDevice self, WGPUShaderModuleDescriptor const * descriptor, WGPUShaderModule* result);\nbool HandleDeviceCreateSwapChain(DeserializeBuffer* deserializeBuffer);\n\nbool DoDeviceCreateSwapChain(WGPUDevice self, WGPUSurface surface, WGPUSwapChainDescriptor const * descriptor, WGPUSwapChain* result);\nbool HandleDeviceCreateTexture(DeserializeBuffer* deserializeBuffer);\n\nbool DoDeviceCreateTexture(WGPUDevice self, WGPUTextureDescriptor const * descriptor, WGPUTexture* result);\nbool HandleDeviceDestroy(DeserializeBuffer* deserializeBuffer);\n\nbool DoDeviceDestroy(WGPUDevice self);\nbool HandleDeviceGetQueue(DeserializeBuffer* deserializeBuffer);\n\nbool DoDeviceGetQueue(WGPUDevice self, WGPUQueue* result);\nbool HandleDeviceInjectError(DeserializeBuffer* deserializeBuffer);\n\nbool DoDeviceInjectError(WGPUDevice self, WGPUErrorType type, char const * message);\nbool HandleDeviceLoseForTesting(DeserializeBuffer* deserializeBuffer);\n\nbool DoDeviceLoseForTesting(WGPUDevice self);\nbool HandleDevicePopErrorScope(DeserializeBuffer* deserializeBuffer);\n\nbool DoDevicePopErrorScope(ObjectId deviceId, uint64_t requestSerial);\nbool HandleDevicePushErrorScope(DeserializeBuffer* deserializeBuffer);\n\nbool DoDevicePushErrorScope(WGPUDevice self, WGPUErrorFilter filter);\nbool HandleDeviceSetLabel(DeserializeBuffer* deserializeBuffer);\n\nbool DoDeviceSetLabel(WGPUDevice self, char const * label);\nbool HandleDeviceTick(DeserializeBuffer* deserializeBuffer);\n\nbool DoDeviceTick(WGPUDevice self);\nbool HandleExternalTextureDestroy(DeserializeBuffer* deserializeBuffer);\n\nbool DoExternalTextureDestroy(WGPUExternalTexture self);\nbool HandleExternalTextureSetLabel(DeserializeBuffer* deserializeBuffer);\n\nbool DoExternalTextureSetLabel(WGPUExternalTexture self, char const * label);\nbool HandleInstanceCreateSurface(DeserializeBuffer* deserializeBuffer);\n\nbool DoInstanceCreateSurface(WGPUInstance self, WGPUSurfaceDescriptor const * descriptor, WGPUSurface* result);\nbool HandleInstanceRequestAdapter(DeserializeBuffer* deserializeBuffer);\n\nbool DoInstanceRequestAdapter(ObjectId instanceId, uint64_t requestSerial, ObjectHandle adapterObjectHandle, WGPURequestAdapterOptions const * options);\nbool HandlePipelineLayoutSetLabel(DeserializeBuffer* deserializeBuffer);\n\nbool DoPipelineLayoutSetLabel(WGPUPipelineLayout self, char const * label);\nbool HandleQuerySetDestroy(DeserializeBuffer* deserializeBuffer);\n\nbool DoQuerySetDestroy(WGPUQuerySet self);\nbool HandleQuerySetSetLabel(DeserializeBuffer* deserializeBuffer);\n\nbool DoQuerySetSetLabel(WGPUQuerySet self, char const * label);\nbool HandleQueueCopyTextureForBrowser(DeserializeBuffer* deserializeBuffer);\n\nbool DoQueueCopyTextureForBrowser(WGPUQueue self, WGPUImageCopyTexture const * source, WGPUImageCopyTexture const * destination, WGPUExtent3D const * copySize, WGPUCopyTextureForBrowserOptions const * options);\nbool HandleQueueOnSubmittedWorkDone(DeserializeBuffer* deserializeBuffer);\n\nbool DoQueueOnSubmittedWorkDone(ObjectId queueId, uint64_t signalValue, uint64_t requestSerial);\nbool HandleQueueSetLabel(DeserializeBuffer* deserializeBuffer);\n\nbool DoQueueSetLabel(WGPUQueue self, char const * label);\nbool HandleQueueSubmit(DeserializeBuffer* deserializeBuffer);\n\nbool DoQueueSubmit(WGPUQueue self, uint32_t commandCount, WGPUCommandBuffer const * commands);\nbool HandleQueueWriteBuffer(DeserializeBuffer* deserializeBuffer);\n\nbool DoQueueWriteBuffer(ObjectId queueId, ObjectId bufferId, uint64_t bufferOffset, uint8_t const * data, uint64_t size);\nbool HandleQueueWriteTexture(DeserializeBuffer* deserializeBuffer);\n\nbool DoQueueWriteTexture(ObjectId queueId, WGPUImageCopyTexture const * destination, uint8_t const * data, uint64_t dataSize, WGPUTextureDataLayout const * dataLayout, WGPUExtent3D const * writeSize);\nbool HandleRenderBundleEncoderDraw(DeserializeBuffer* deserializeBuffer);\n\nbool DoRenderBundleEncoderDraw(WGPURenderBundleEncoder self, uint32_t vertexCount, uint32_t instanceCount, uint32_t firstVertex, uint32_t firstInstance);\nbool HandleRenderBundleEncoderDrawIndexed(DeserializeBuffer* deserializeBuffer);\n\nbool DoRenderBundleEncoderDrawIndexed(WGPURenderBundleEncoder self, uint32_t indexCount, uint32_t instanceCount, uint32_t firstIndex, int32_t baseVertex, uint32_t firstInstance);\nbool HandleRenderBundleEncoderDrawIndexedIndirect(DeserializeBuffer* deserializeBuffer);\n\nbool DoRenderBundleEncoderDrawIndexedIndirect(WGPURenderBundleEncoder self, WGPUBuffer indirectBuffer, uint64_t indirectOffset);\nbool HandleRenderBundleEncoderDrawIndirect(DeserializeBuffer* deserializeBuffer);\n\nbool DoRenderBundleEncoderDrawIndirect(WGPURenderBundleEncoder self, WGPUBuffer indirectBuffer, uint64_t indirectOffset);\nbool HandleRenderBundleEncoderFinish(DeserializeBuffer* deserializeBuffer);\n\nbool DoRenderBundleEncoderFinish(WGPURenderBundleEncoder self, WGPURenderBundleDescriptor const * descriptor, WGPURenderBundle* result);\nbool HandleRenderBundleEncoderInsertDebugMarker(DeserializeBuffer* deserializeBuffer);\n\nbool DoRenderBundleEncoderInsertDebugMarker(WGPURenderBundleEncoder self, char const * markerLabel);\nbool HandleRenderBundleEncoderPopDebugGroup(DeserializeBuffer* deserializeBuffer);\n\nbool DoRenderBundleEncoderPopDebugGroup(WGPURenderBundleEncoder self);\nbool HandleRenderBundleEncoderPushDebugGroup(DeserializeBuffer* deserializeBuffer);\n\nbool DoRenderBundleEncoderPushDebugGroup(WGPURenderBundleEncoder self, char const * groupLabel);\nbool HandleRenderBundleEncoderSetBindGroup(DeserializeBuffer* deserializeBuffer);\n\nbool DoRenderBundleEncoderSetBindGroup(WGPURenderBundleEncoder self, uint32_t groupIndex, WGPUBindGroup group, uint32_t dynamicOffsetCount, uint32_t const * dynamicOffsets);\nbool HandleRenderBundleEncoderSetIndexBuffer(DeserializeBuffer* deserializeBuffer);\n\nbool DoRenderBundleEncoderSetIndexBuffer(WGPURenderBundleEncoder self, WGPUBuffer buffer, WGPUIndexFormat format, uint64_t offset, uint64_t size);\nbool HandleRenderBundleEncoderSetLabel(DeserializeBuffer* deserializeBuffer);\n\nbool DoRenderBundleEncoderSetLabel(WGPURenderBundleEncoder self, char const * label);\nbool HandleRenderBundleEncoderSetPipeline(DeserializeBuffer* deserializeBuffer);\n\nbool DoRenderBundleEncoderSetPipeline(WGPURenderBundleEncoder self, WGPURenderPipeline pipeline);\nbool HandleRenderBundleEncoderSetVertexBuffer(DeserializeBuffer* deserializeBuffer);\n\nbool DoRenderBundleEncoderSetVertexBuffer(WGPURenderBundleEncoder self, uint32_t slot, WGPUBuffer buffer, uint64_t offset, uint64_t size);\nbool HandleRenderPassEncoderBeginOcclusionQuery(DeserializeBuffer* deserializeBuffer);\n\nbool DoRenderPassEncoderBeginOcclusionQuery(WGPURenderPassEncoder self, uint32_t queryIndex);\nbool HandleRenderPassEncoderDraw(DeserializeBuffer* deserializeBuffer);\n\nbool DoRenderPassEncoderDraw(WGPURenderPassEncoder self, uint32_t vertexCount, uint32_t instanceCount, uint32_t firstVertex, uint32_t firstInstance);\nbool HandleRenderPassEncoderDrawIndexed(DeserializeBuffer* deserializeBuffer);\n\nbool DoRenderPassEncoderDrawIndexed(WGPURenderPassEncoder self, uint32_t indexCount, uint32_t instanceCount, uint32_t firstIndex, int32_t baseVertex, uint32_t firstInstance);\nbool HandleRenderPassEncoderDrawIndexedIndirect(DeserializeBuffer* deserializeBuffer);\n\nbool DoRenderPassEncoderDrawIndexedIndirect(WGPURenderPassEncoder self, WGPUBuffer indirectBuffer, uint64_t indirectOffset);\nbool HandleRenderPassEncoderDrawIndirect(DeserializeBuffer* deserializeBuffer);\n\nbool DoRenderPassEncoderDrawIndirect(WGPURenderPassEncoder self, WGPUBuffer indirectBuffer, uint64_t indirectOffset);\nbool HandleRenderPassEncoderEnd(DeserializeBuffer* deserializeBuffer);\n\nbool DoRenderPassEncoderEnd(WGPURenderPassEncoder self);\nbool HandleRenderPassEncoderEndOcclusionQuery(DeserializeBuffer* deserializeBuffer);\n\nbool DoRenderPassEncoderEndOcclusionQuery(WGPURenderPassEncoder self);\nbool HandleRenderPassEncoderEndPass(DeserializeBuffer* deserializeBuffer);\n\nbool DoRenderPassEncoderEndPass(WGPURenderPassEncoder self);\nbool HandleRenderPassEncoderExecuteBundles(DeserializeBuffer* deserializeBuffer);\n\nbool DoRenderPassEncoderExecuteBundles(WGPURenderPassEncoder self, uint32_t bundlesCount, WGPURenderBundle const * bundles);\nbool HandleRenderPassEncoderInsertDebugMarker(DeserializeBuffer* deserializeBuffer);\n\nbool DoRenderPassEncoderInsertDebugMarker(WGPURenderPassEncoder self, char const * markerLabel);\nbool HandleRenderPassEncoderPopDebugGroup(DeserializeBuffer* deserializeBuffer);\n\nbool DoRenderPassEncoderPopDebugGroup(WGPURenderPassEncoder self);\nbool HandleRenderPassEncoderPushDebugGroup(DeserializeBuffer* deserializeBuffer);\n\nbool DoRenderPassEncoderPushDebugGroup(WGPURenderPassEncoder self, char const * groupLabel);\nbool HandleRenderPassEncoderSetBindGroup(DeserializeBuffer* deserializeBuffer);\n\nbool DoRenderPassEncoderSetBindGroup(WGPURenderPassEncoder self, uint32_t groupIndex, WGPUBindGroup group, uint32_t dynamicOffsetCount, uint32_t const * dynamicOffsets);\nbool HandleRenderPassEncoderSetBlendConstant(DeserializeBuffer* deserializeBuffer);\n\nbool DoRenderPassEncoderSetBlendConstant(WGPURenderPassEncoder self, WGPUColor const * color);\nbool HandleRenderPassEncoderSetIndexBuffer(DeserializeBuffer* deserializeBuffer);\n\nbool DoRenderPassEncoderSetIndexBuffer(WGPURenderPassEncoder self, WGPUBuffer buffer, WGPUIndexFormat format, uint64_t offset, uint64_t size);\nbool HandleRenderPassEncoderSetLabel(DeserializeBuffer* deserializeBuffer);\n\nbool DoRenderPassEncoderSetLabel(WGPURenderPassEncoder self, char const * label);\nbool HandleRenderPassEncoderSetPipeline(DeserializeBuffer* deserializeBuffer);\n\nbool DoRenderPassEncoderSetPipeline(WGPURenderPassEncoder self, WGPURenderPipeline pipeline);\nbool HandleRenderPassEncoderSetScissorRect(DeserializeBuffer* deserializeBuffer);\n\nbool DoRenderPassEncoderSetScissorRect(WGPURenderPassEncoder self, uint32_t x, uint32_t y, uint32_t width, uint32_t height);\nbool HandleRenderPassEncoderSetStencilReference(DeserializeBuffer* deserializeBuffer);\n\nbool DoRenderPassEncoderSetStencilReference(WGPURenderPassEncoder self, uint32_t reference);\nbool HandleRenderPassEncoderSetVertexBuffer(DeserializeBuffer* deserializeBuffer);\n\nbool DoRenderPassEncoderSetVertexBuffer(WGPURenderPassEncoder self, uint32_t slot, WGPUBuffer buffer, uint64_t offset, uint64_t size);\nbool HandleRenderPassEncoderSetViewport(DeserializeBuffer* deserializeBuffer);\n\nbool DoRenderPassEncoderSetViewport(WGPURenderPassEncoder self, float x, float y, float width, float height, float minDepth, float maxDepth);\nbool HandleRenderPassEncoderWriteTimestamp(DeserializeBuffer* deserializeBuffer);\n\nbool DoRenderPassEncoderWriteTimestamp(WGPURenderPassEncoder self, WGPUQuerySet querySet, uint32_t queryIndex);\nbool HandleRenderPipelineGetBindGroupLayout(DeserializeBuffer* deserializeBuffer);\n\nbool DoRenderPipelineGetBindGroupLayout(WGPURenderPipeline self, uint32_t groupIndex, WGPUBindGroupLayout* result);\nbool HandleRenderPipelineSetLabel(DeserializeBuffer* deserializeBuffer);\n\nbool DoRenderPipelineSetLabel(WGPURenderPipeline self, char const * label);\nbool HandleSamplerSetLabel(DeserializeBuffer* deserializeBuffer);\n\nbool DoSamplerSetLabel(WGPUSampler self, char const * label);\nbool HandleShaderModuleGetCompilationInfo(DeserializeBuffer* deserializeBuffer);\n\nbool DoShaderModuleGetCompilationInfo(ObjectId shaderModuleId, uint64_t requestSerial);\nbool HandleShaderModuleSetLabel(DeserializeBuffer* deserializeBuffer);\n\nbool DoShaderModuleSetLabel(WGPUShaderModule self, char const * label);\nbool HandleSwapChainConfigure(DeserializeBuffer* deserializeBuffer);\n\nbool DoSwapChainConfigure(WGPUSwapChain self, WGPUTextureFormat format, WGPUTextureUsageFlags allowedUsage, uint32_t width, uint32_t height);\nbool HandleSwapChainGetCurrentTextureView(DeserializeBuffer* deserializeBuffer);\n\nbool DoSwapChainGetCurrentTextureView(WGPUSwapChain self, WGPUTextureView* result);\nbool HandleSwapChainPresent(DeserializeBuffer* deserializeBuffer);\n\nbool DoSwapChainPresent(WGPUSwapChain self);\nbool HandleTextureCreateView(DeserializeBuffer* deserializeBuffer);\n\nbool DoTextureCreateView(WGPUTexture self, WGPUTextureViewDescriptor const * descriptor, WGPUTextureView* result);\nbool HandleTextureDestroy(DeserializeBuffer* deserializeBuffer);\n\nbool DoTextureDestroy(WGPUTexture self);\nbool HandleTextureSetLabel(DeserializeBuffer* deserializeBuffer);\n\nbool DoTextureSetLabel(WGPUTexture self, char const * label);\nbool HandleTextureViewSetLabel(DeserializeBuffer* deserializeBuffer);\n\nbool DoTextureViewSetLabel(WGPUTextureView self, char const * label);\n\nbool PreHandleBufferDestroy(const BufferDestroyCmd& cmd);\nbool PreHandleBufferUnmap(const BufferUnmapCmd& cmd);\n"}