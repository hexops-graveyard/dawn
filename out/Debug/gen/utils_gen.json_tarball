{"src/dawn/native/ValidationUtils_autogen.h": "\n#ifndef BACKEND_VALIDATIONUTILS_H_\n#define BACKEND_VALIDATIONUTILS_H_\n\n#include \"dawn/webgpu_cpp.h\"\n\n#include \"dawn/native/Error.h\"\n\nnamespace dawn::native {\n\n    // Helper functions to check the value of enums and bitmasks\n    MaybeError ValidateAdapterType(wgpu::AdapterType value);\n    MaybeError ValidateAddressMode(wgpu::AddressMode value);\n    MaybeError ValidateAlphaMode(wgpu::AlphaMode value);\n    MaybeError ValidateBackendType(wgpu::BackendType value);\n    MaybeError ValidateBlendFactor(wgpu::BlendFactor value);\n    MaybeError ValidateBlendOperation(wgpu::BlendOperation value);\n    MaybeError ValidateBufferBindingType(wgpu::BufferBindingType value);\n    MaybeError ValidateBufferMapAsyncStatus(wgpu::BufferMapAsyncStatus value);\n    MaybeError ValidateBufferMapState(wgpu::BufferMapState value);\n    MaybeError ValidateCompareFunction(wgpu::CompareFunction value);\n    MaybeError ValidateCompilationInfoRequestStatus(wgpu::CompilationInfoRequestStatus value);\n    MaybeError ValidateCompilationMessageType(wgpu::CompilationMessageType value);\n    MaybeError ValidateComputePassTimestampLocation(wgpu::ComputePassTimestampLocation value);\n    MaybeError ValidateCreatePipelineAsyncStatus(wgpu::CreatePipelineAsyncStatus value);\n    MaybeError ValidateCullMode(wgpu::CullMode value);\n    MaybeError ValidateDeviceLostReason(wgpu::DeviceLostReason value);\n    MaybeError ValidateErrorFilter(wgpu::ErrorFilter value);\n    MaybeError ValidateErrorType(wgpu::ErrorType value);\n    MaybeError ValidateExternalTextureRotation(wgpu::ExternalTextureRotation value);\n    MaybeError ValidateFeatureName(wgpu::FeatureName value);\n    MaybeError ValidateFilterMode(wgpu::FilterMode value);\n    MaybeError ValidateFrontFace(wgpu::FrontFace value);\n    MaybeError ValidateIndexFormat(wgpu::IndexFormat value);\n    MaybeError ValidateLoadOp(wgpu::LoadOp value);\n    MaybeError ValidateLoggingType(wgpu::LoggingType value);\n    MaybeError ValidateMipmapFilterMode(wgpu::MipmapFilterMode value);\n    MaybeError ValidatePipelineStatisticName(wgpu::PipelineStatisticName value);\n    MaybeError ValidatePowerPreference(wgpu::PowerPreference value);\n    MaybeError ValidatePresentMode(wgpu::PresentMode value);\n    MaybeError ValidatePrimitiveTopology(wgpu::PrimitiveTopology value);\n    MaybeError ValidateQueryType(wgpu::QueryType value);\n    MaybeError ValidateQueueWorkDoneStatus(wgpu::QueueWorkDoneStatus value);\n    MaybeError ValidateRenderPassTimestampLocation(wgpu::RenderPassTimestampLocation value);\n    MaybeError ValidateRequestAdapterStatus(wgpu::RequestAdapterStatus value);\n    MaybeError ValidateRequestDeviceStatus(wgpu::RequestDeviceStatus value);\n    MaybeError ValidateSType(wgpu::SType value);\n    MaybeError ValidateSamplerBindingType(wgpu::SamplerBindingType value);\n    MaybeError ValidateStencilOperation(wgpu::StencilOperation value);\n    MaybeError ValidateStorageTextureAccess(wgpu::StorageTextureAccess value);\n    MaybeError ValidateStoreOp(wgpu::StoreOp value);\n    MaybeError ValidateTextureAspect(wgpu::TextureAspect value);\n    MaybeError ValidateTextureDimension(wgpu::TextureDimension value);\n    MaybeError ValidateTextureFormat(wgpu::TextureFormat value);\n    MaybeError ValidateTextureSampleType(wgpu::TextureSampleType value);\n    MaybeError ValidateTextureViewDimension(wgpu::TextureViewDimension value);\n    MaybeError ValidateVertexFormat(wgpu::VertexFormat value);\n    MaybeError ValidateVertexStepMode(wgpu::VertexStepMode value);\n    MaybeError ValidateBufferUsage(wgpu::BufferUsage value);\n    MaybeError ValidateColorWriteMask(wgpu::ColorWriteMask value);\n    MaybeError ValidateMapMode(wgpu::MapMode value);\n    MaybeError ValidateShaderStage(wgpu::ShaderStage value);\n    MaybeError ValidateTextureUsage(wgpu::TextureUsage value);\n\n} // namespace dawn::native\n\n#endif  // BACKEND_VALIDATIONUTILS_H_\n", "src/dawn/native/ValidationUtils_autogen.cpp": "\n#include \"dawn/native/ValidationUtils_autogen.h\"\n\nnamespace dawn::native {\n\n    MaybeError ValidateAdapterType(wgpu::AdapterType value) {\n        switch (value) {\n            case wgpu::AdapterType::DiscreteGPU:\n                return {};\n            case wgpu::AdapterType::IntegratedGPU:\n                return {};\n            case wgpu::AdapterType::CPU:\n                return {};\n            case wgpu::AdapterType::Unknown:\n                return {};\n            default:\n                return DAWN_VALIDATION_ERROR(\"Value %i is invalid for WGPUAdapterType.\", static_cast<uint32_t>(value));\n        }\n    }\n\n    MaybeError ValidateAddressMode(wgpu::AddressMode value) {\n        switch (value) {\n            case wgpu::AddressMode::Repeat:\n                return {};\n            case wgpu::AddressMode::MirrorRepeat:\n                return {};\n            case wgpu::AddressMode::ClampToEdge:\n                return {};\n            default:\n                return DAWN_VALIDATION_ERROR(\"Value %i is invalid for WGPUAddressMode.\", static_cast<uint32_t>(value));\n        }\n    }\n\n    MaybeError ValidateAlphaMode(wgpu::AlphaMode value) {\n        switch (value) {\n            case wgpu::AlphaMode::Premultiplied:\n                return {};\n            case wgpu::AlphaMode::Unpremultiplied:\n                return {};\n            case wgpu::AlphaMode::Opaque:\n                return {};\n            default:\n                return DAWN_VALIDATION_ERROR(\"Value %i is invalid for WGPUAlphaMode.\", static_cast<uint32_t>(value));\n        }\n    }\n\n    MaybeError ValidateBackendType(wgpu::BackendType value) {\n        switch (value) {\n            case wgpu::BackendType::Null:\n                return {};\n            case wgpu::BackendType::WebGPU:\n                return {};\n            case wgpu::BackendType::D3D11:\n                return {};\n            case wgpu::BackendType::D3D12:\n                return {};\n            case wgpu::BackendType::Metal:\n                return {};\n            case wgpu::BackendType::Vulkan:\n                return {};\n            case wgpu::BackendType::OpenGL:\n                return {};\n            case wgpu::BackendType::OpenGLES:\n                return {};\n            default:\n                return DAWN_VALIDATION_ERROR(\"Value %i is invalid for WGPUBackendType.\", static_cast<uint32_t>(value));\n        }\n    }\n\n    MaybeError ValidateBlendFactor(wgpu::BlendFactor value) {\n        switch (value) {\n            case wgpu::BlendFactor::Zero:\n                return {};\n            case wgpu::BlendFactor::One:\n                return {};\n            case wgpu::BlendFactor::Src:\n                return {};\n            case wgpu::BlendFactor::OneMinusSrc:\n                return {};\n            case wgpu::BlendFactor::SrcAlpha:\n                return {};\n            case wgpu::BlendFactor::OneMinusSrcAlpha:\n                return {};\n            case wgpu::BlendFactor::Dst:\n                return {};\n            case wgpu::BlendFactor::OneMinusDst:\n                return {};\n            case wgpu::BlendFactor::DstAlpha:\n                return {};\n            case wgpu::BlendFactor::OneMinusDstAlpha:\n                return {};\n            case wgpu::BlendFactor::SrcAlphaSaturated:\n                return {};\n            case wgpu::BlendFactor::Constant:\n                return {};\n            case wgpu::BlendFactor::OneMinusConstant:\n                return {};\n            default:\n                return DAWN_VALIDATION_ERROR(\"Value %i is invalid for WGPUBlendFactor.\", static_cast<uint32_t>(value));\n        }\n    }\n\n    MaybeError ValidateBlendOperation(wgpu::BlendOperation value) {\n        switch (value) {\n            case wgpu::BlendOperation::Add:\n                return {};\n            case wgpu::BlendOperation::Subtract:\n                return {};\n            case wgpu::BlendOperation::ReverseSubtract:\n                return {};\n            case wgpu::BlendOperation::Min:\n                return {};\n            case wgpu::BlendOperation::Max:\n                return {};\n            default:\n                return DAWN_VALIDATION_ERROR(\"Value %i is invalid for WGPUBlendOperation.\", static_cast<uint32_t>(value));\n        }\n    }\n\n    MaybeError ValidateBufferBindingType(wgpu::BufferBindingType value) {\n        switch (value) {\n            case wgpu::BufferBindingType::Uniform:\n                return {};\n            case wgpu::BufferBindingType::Storage:\n                return {};\n            case wgpu::BufferBindingType::ReadOnlyStorage:\n                return {};\n            default:\n                return DAWN_VALIDATION_ERROR(\"Value %i is invalid for WGPUBufferBindingType.\", static_cast<uint32_t>(value));\n        }\n    }\n\n    MaybeError ValidateBufferMapAsyncStatus(wgpu::BufferMapAsyncStatus value) {\n        switch (value) {\n            case wgpu::BufferMapAsyncStatus::Success:\n                return {};\n            case wgpu::BufferMapAsyncStatus::ValidationError:\n                return {};\n            case wgpu::BufferMapAsyncStatus::Unknown:\n                return {};\n            case wgpu::BufferMapAsyncStatus::DeviceLost:\n                return {};\n            case wgpu::BufferMapAsyncStatus::DestroyedBeforeCallback:\n                return {};\n            case wgpu::BufferMapAsyncStatus::UnmappedBeforeCallback:\n                return {};\n            case wgpu::BufferMapAsyncStatus::MappingAlreadyPending:\n                return {};\n            case wgpu::BufferMapAsyncStatus::OffsetOutOfRange:\n                return {};\n            case wgpu::BufferMapAsyncStatus::SizeOutOfRange:\n                return {};\n            default:\n                return DAWN_VALIDATION_ERROR(\"Value %i is invalid for WGPUBufferMapAsyncStatus.\", static_cast<uint32_t>(value));\n        }\n    }\n\n    MaybeError ValidateBufferMapState(wgpu::BufferMapState value) {\n        switch (value) {\n            case wgpu::BufferMapState::Unmapped:\n                return {};\n            case wgpu::BufferMapState::Pending:\n                return {};\n            case wgpu::BufferMapState::Mapped:\n                return {};\n            default:\n                return DAWN_VALIDATION_ERROR(\"Value %i is invalid for WGPUBufferMapState.\", static_cast<uint32_t>(value));\n        }\n    }\n\n    MaybeError ValidateCompareFunction(wgpu::CompareFunction value) {\n        switch (value) {\n            case wgpu::CompareFunction::Never:\n                return {};\n            case wgpu::CompareFunction::Less:\n                return {};\n            case wgpu::CompareFunction::LessEqual:\n                return {};\n            case wgpu::CompareFunction::Greater:\n                return {};\n            case wgpu::CompareFunction::GreaterEqual:\n                return {};\n            case wgpu::CompareFunction::Equal:\n                return {};\n            case wgpu::CompareFunction::NotEqual:\n                return {};\n            case wgpu::CompareFunction::Always:\n                return {};\n            default:\n                return DAWN_VALIDATION_ERROR(\"Value %i is invalid for WGPUCompareFunction.\", static_cast<uint32_t>(value));\n        }\n    }\n\n    MaybeError ValidateCompilationInfoRequestStatus(wgpu::CompilationInfoRequestStatus value) {\n        switch (value) {\n            case wgpu::CompilationInfoRequestStatus::Success:\n                return {};\n            case wgpu::CompilationInfoRequestStatus::Error:\n                return {};\n            case wgpu::CompilationInfoRequestStatus::DeviceLost:\n                return {};\n            case wgpu::CompilationInfoRequestStatus::Unknown:\n                return {};\n            default:\n                return DAWN_VALIDATION_ERROR(\"Value %i is invalid for WGPUCompilationInfoRequestStatus.\", static_cast<uint32_t>(value));\n        }\n    }\n\n    MaybeError ValidateCompilationMessageType(wgpu::CompilationMessageType value) {\n        switch (value) {\n            case wgpu::CompilationMessageType::Error:\n                return {};\n            case wgpu::CompilationMessageType::Warning:\n                return {};\n            case wgpu::CompilationMessageType::Info:\n                return {};\n            default:\n                return DAWN_VALIDATION_ERROR(\"Value %i is invalid for WGPUCompilationMessageType.\", static_cast<uint32_t>(value));\n        }\n    }\n\n    MaybeError ValidateComputePassTimestampLocation(wgpu::ComputePassTimestampLocation value) {\n        switch (value) {\n            case wgpu::ComputePassTimestampLocation::Beginning:\n                return {};\n            case wgpu::ComputePassTimestampLocation::End:\n                return {};\n            default:\n                return DAWN_VALIDATION_ERROR(\"Value %i is invalid for WGPUComputePassTimestampLocation.\", static_cast<uint32_t>(value));\n        }\n    }\n\n    MaybeError ValidateCreatePipelineAsyncStatus(wgpu::CreatePipelineAsyncStatus value) {\n        switch (value) {\n            case wgpu::CreatePipelineAsyncStatus::Success:\n                return {};\n            case wgpu::CreatePipelineAsyncStatus::ValidationError:\n                return {};\n            case wgpu::CreatePipelineAsyncStatus::InternalError:\n                return {};\n            case wgpu::CreatePipelineAsyncStatus::DeviceLost:\n                return {};\n            case wgpu::CreatePipelineAsyncStatus::DeviceDestroyed:\n                return {};\n            case wgpu::CreatePipelineAsyncStatus::Unknown:\n                return {};\n            default:\n                return DAWN_VALIDATION_ERROR(\"Value %i is invalid for WGPUCreatePipelineAsyncStatus.\", static_cast<uint32_t>(value));\n        }\n    }\n\n    MaybeError ValidateCullMode(wgpu::CullMode value) {\n        switch (value) {\n            case wgpu::CullMode::None:\n                return {};\n            case wgpu::CullMode::Front:\n                return {};\n            case wgpu::CullMode::Back:\n                return {};\n            default:\n                return DAWN_VALIDATION_ERROR(\"Value %i is invalid for WGPUCullMode.\", static_cast<uint32_t>(value));\n        }\n    }\n\n    MaybeError ValidateDeviceLostReason(wgpu::DeviceLostReason value) {\n        switch (value) {\n            case wgpu::DeviceLostReason::Undefined:\n                return {};\n            case wgpu::DeviceLostReason::Destroyed:\n                return {};\n            default:\n                return DAWN_VALIDATION_ERROR(\"Value %i is invalid for WGPUDeviceLostReason.\", static_cast<uint32_t>(value));\n        }\n    }\n\n    MaybeError ValidateErrorFilter(wgpu::ErrorFilter value) {\n        switch (value) {\n            case wgpu::ErrorFilter::Validation:\n                return {};\n            case wgpu::ErrorFilter::OutOfMemory:\n                return {};\n            case wgpu::ErrorFilter::Internal:\n                return {};\n            default:\n                return DAWN_VALIDATION_ERROR(\"Value %i is invalid for WGPUErrorFilter.\", static_cast<uint32_t>(value));\n        }\n    }\n\n    MaybeError ValidateErrorType(wgpu::ErrorType value) {\n        switch (value) {\n            case wgpu::ErrorType::NoError:\n                return {};\n            case wgpu::ErrorType::Validation:\n                return {};\n            case wgpu::ErrorType::OutOfMemory:\n                return {};\n            case wgpu::ErrorType::Internal:\n                return {};\n            case wgpu::ErrorType::Unknown:\n                return {};\n            case wgpu::ErrorType::DeviceLost:\n                return {};\n            default:\n                return DAWN_VALIDATION_ERROR(\"Value %i is invalid for WGPUErrorType.\", static_cast<uint32_t>(value));\n        }\n    }\n\n    MaybeError ValidateExternalTextureRotation(wgpu::ExternalTextureRotation value) {\n        switch (value) {\n            case wgpu::ExternalTextureRotation::Rotate0Degrees:\n                return {};\n            case wgpu::ExternalTextureRotation::Rotate90Degrees:\n                return {};\n            case wgpu::ExternalTextureRotation::Rotate180Degrees:\n                return {};\n            case wgpu::ExternalTextureRotation::Rotate270Degrees:\n                return {};\n            default:\n                return DAWN_VALIDATION_ERROR(\"Value %i is invalid for WGPUExternalTextureRotation.\", static_cast<uint32_t>(value));\n        }\n    }\n\n    MaybeError ValidateFeatureName(wgpu::FeatureName value) {\n        switch (value) {\n            case wgpu::FeatureName::Undefined:\n                return {};\n            case wgpu::FeatureName::DepthClipControl:\n                return {};\n            case wgpu::FeatureName::Depth32FloatStencil8:\n                return {};\n            case wgpu::FeatureName::TimestampQuery:\n                return {};\n            case wgpu::FeatureName::PipelineStatisticsQuery:\n                return {};\n            case wgpu::FeatureName::TextureCompressionBC:\n                return {};\n            case wgpu::FeatureName::TextureCompressionETC2:\n                return {};\n            case wgpu::FeatureName::TextureCompressionASTC:\n                return {};\n            case wgpu::FeatureName::IndirectFirstInstance:\n                return {};\n            case wgpu::FeatureName::ShaderF16:\n                return {};\n            case wgpu::FeatureName::RG11B10UfloatRenderable:\n                return {};\n            case wgpu::FeatureName::BGRA8UnormStorage:\n                return {};\n            case wgpu::FeatureName::Float32Filterable:\n                return {};\n            case wgpu::FeatureName::DawnShaderFloat16:\n                return {};\n            case wgpu::FeatureName::DawnInternalUsages:\n                return {};\n            case wgpu::FeatureName::DawnMultiPlanarFormats:\n                return {};\n            case wgpu::FeatureName::DawnNative:\n                return {};\n            case wgpu::FeatureName::ChromiumExperimentalDp4a:\n                return {};\n            case wgpu::FeatureName::TimestampQueryInsidePasses:\n                return {};\n            case wgpu::FeatureName::ImplicitDeviceSynchronization:\n                return {};\n            case wgpu::FeatureName::SurfaceCapabilities:\n                return {};\n            case wgpu::FeatureName::TransientAttachments:\n                return {};\n            case wgpu::FeatureName::MSAARenderToSingleSampled:\n                return {};\n            default:\n                return DAWN_VALIDATION_ERROR(\"Value %i is invalid for WGPUFeatureName.\", static_cast<uint32_t>(value));\n        }\n    }\n\n    MaybeError ValidateFilterMode(wgpu::FilterMode value) {\n        switch (value) {\n            case wgpu::FilterMode::Nearest:\n                return {};\n            case wgpu::FilterMode::Linear:\n                return {};\n            default:\n                return DAWN_VALIDATION_ERROR(\"Value %i is invalid for WGPUFilterMode.\", static_cast<uint32_t>(value));\n        }\n    }\n\n    MaybeError ValidateFrontFace(wgpu::FrontFace value) {\n        switch (value) {\n            case wgpu::FrontFace::CCW:\n                return {};\n            case wgpu::FrontFace::CW:\n                return {};\n            default:\n                return DAWN_VALIDATION_ERROR(\"Value %i is invalid for WGPUFrontFace.\", static_cast<uint32_t>(value));\n        }\n    }\n\n    MaybeError ValidateIndexFormat(wgpu::IndexFormat value) {\n        switch (value) {\n            case wgpu::IndexFormat::Undefined:\n                return {};\n            case wgpu::IndexFormat::Uint16:\n                return {};\n            case wgpu::IndexFormat::Uint32:\n                return {};\n            default:\n                return DAWN_VALIDATION_ERROR(\"Value %i is invalid for WGPUIndexFormat.\", static_cast<uint32_t>(value));\n        }\n    }\n\n    MaybeError ValidateLoadOp(wgpu::LoadOp value) {\n        switch (value) {\n            case wgpu::LoadOp::Undefined:\n                return {};\n            case wgpu::LoadOp::Clear:\n                return {};\n            case wgpu::LoadOp::Load:\n                return {};\n            default:\n                return DAWN_VALIDATION_ERROR(\"Value %i is invalid for WGPULoadOp.\", static_cast<uint32_t>(value));\n        }\n    }\n\n    MaybeError ValidateLoggingType(wgpu::LoggingType value) {\n        switch (value) {\n            case wgpu::LoggingType::Verbose:\n                return {};\n            case wgpu::LoggingType::Info:\n                return {};\n            case wgpu::LoggingType::Warning:\n                return {};\n            case wgpu::LoggingType::Error:\n                return {};\n            default:\n                return DAWN_VALIDATION_ERROR(\"Value %i is invalid for WGPULoggingType.\", static_cast<uint32_t>(value));\n        }\n    }\n\n    MaybeError ValidateMipmapFilterMode(wgpu::MipmapFilterMode value) {\n        switch (value) {\n            case wgpu::MipmapFilterMode::Nearest:\n                return {};\n            case wgpu::MipmapFilterMode::Linear:\n                return {};\n            default:\n                return DAWN_VALIDATION_ERROR(\"Value %i is invalid for WGPUMipmapFilterMode.\", static_cast<uint32_t>(value));\n        }\n    }\n\n    MaybeError ValidatePipelineStatisticName(wgpu::PipelineStatisticName value) {\n        switch (value) {\n            case wgpu::PipelineStatisticName::VertexShaderInvocations:\n                return {};\n            case wgpu::PipelineStatisticName::ClipperInvocations:\n                return {};\n            case wgpu::PipelineStatisticName::ClipperPrimitivesOut:\n                return {};\n            case wgpu::PipelineStatisticName::FragmentShaderInvocations:\n                return {};\n            case wgpu::PipelineStatisticName::ComputeShaderInvocations:\n                return {};\n            default:\n                return DAWN_VALIDATION_ERROR(\"Value %i is invalid for WGPUPipelineStatisticName.\", static_cast<uint32_t>(value));\n        }\n    }\n\n    MaybeError ValidatePowerPreference(wgpu::PowerPreference value) {\n        switch (value) {\n            case wgpu::PowerPreference::Undefined:\n                return {};\n            case wgpu::PowerPreference::LowPower:\n                return {};\n            case wgpu::PowerPreference::HighPerformance:\n                return {};\n            default:\n                return DAWN_VALIDATION_ERROR(\"Value %i is invalid for WGPUPowerPreference.\", static_cast<uint32_t>(value));\n        }\n    }\n\n    MaybeError ValidatePresentMode(wgpu::PresentMode value) {\n        switch (value) {\n            case wgpu::PresentMode::Immediate:\n                return {};\n            case wgpu::PresentMode::Mailbox:\n                return {};\n            case wgpu::PresentMode::Fifo:\n                return {};\n            default:\n                return DAWN_VALIDATION_ERROR(\"Value %i is invalid for WGPUPresentMode.\", static_cast<uint32_t>(value));\n        }\n    }\n\n    MaybeError ValidatePrimitiveTopology(wgpu::PrimitiveTopology value) {\n        switch (value) {\n            case wgpu::PrimitiveTopology::PointList:\n                return {};\n            case wgpu::PrimitiveTopology::LineList:\n                return {};\n            case wgpu::PrimitiveTopology::LineStrip:\n                return {};\n            case wgpu::PrimitiveTopology::TriangleList:\n                return {};\n            case wgpu::PrimitiveTopology::TriangleStrip:\n                return {};\n            default:\n                return DAWN_VALIDATION_ERROR(\"Value %i is invalid for WGPUPrimitiveTopology.\", static_cast<uint32_t>(value));\n        }\n    }\n\n    MaybeError ValidateQueryType(wgpu::QueryType value) {\n        switch (value) {\n            case wgpu::QueryType::Occlusion:\n                return {};\n            case wgpu::QueryType::PipelineStatistics:\n                return {};\n            case wgpu::QueryType::Timestamp:\n                return {};\n            default:\n                return DAWN_VALIDATION_ERROR(\"Value %i is invalid for WGPUQueryType.\", static_cast<uint32_t>(value));\n        }\n    }\n\n    MaybeError ValidateQueueWorkDoneStatus(wgpu::QueueWorkDoneStatus value) {\n        switch (value) {\n            case wgpu::QueueWorkDoneStatus::Success:\n                return {};\n            case wgpu::QueueWorkDoneStatus::Error:\n                return {};\n            case wgpu::QueueWorkDoneStatus::Unknown:\n                return {};\n            case wgpu::QueueWorkDoneStatus::DeviceLost:\n                return {};\n            default:\n                return DAWN_VALIDATION_ERROR(\"Value %i is invalid for WGPUQueueWorkDoneStatus.\", static_cast<uint32_t>(value));\n        }\n    }\n\n    MaybeError ValidateRenderPassTimestampLocation(wgpu::RenderPassTimestampLocation value) {\n        switch (value) {\n            case wgpu::RenderPassTimestampLocation::Beginning:\n                return {};\n            case wgpu::RenderPassTimestampLocation::End:\n                return {};\n            default:\n                return DAWN_VALIDATION_ERROR(\"Value %i is invalid for WGPURenderPassTimestampLocation.\", static_cast<uint32_t>(value));\n        }\n    }\n\n    MaybeError ValidateRequestAdapterStatus(wgpu::RequestAdapterStatus value) {\n        switch (value) {\n            case wgpu::RequestAdapterStatus::Success:\n                return {};\n            case wgpu::RequestAdapterStatus::Unavailable:\n                return {};\n            case wgpu::RequestAdapterStatus::Error:\n                return {};\n            case wgpu::RequestAdapterStatus::Unknown:\n                return {};\n            default:\n                return DAWN_VALIDATION_ERROR(\"Value %i is invalid for WGPURequestAdapterStatus.\", static_cast<uint32_t>(value));\n        }\n    }\n\n    MaybeError ValidateRequestDeviceStatus(wgpu::RequestDeviceStatus value) {\n        switch (value) {\n            case wgpu::RequestDeviceStatus::Success:\n                return {};\n            case wgpu::RequestDeviceStatus::Error:\n                return {};\n            case wgpu::RequestDeviceStatus::Unknown:\n                return {};\n            default:\n                return DAWN_VALIDATION_ERROR(\"Value %i is invalid for WGPURequestDeviceStatus.\", static_cast<uint32_t>(value));\n        }\n    }\n\n    MaybeError ValidateSType(wgpu::SType value) {\n        switch (value) {\n            case wgpu::SType::SurfaceDescriptorFromMetalLayer:\n                return {};\n            case wgpu::SType::SurfaceDescriptorFromWindowsHWND:\n                return {};\n            case wgpu::SType::SurfaceDescriptorFromXlibWindow:\n                return {};\n            case wgpu::SType::SurfaceDescriptorFromCanvasHTMLSelector:\n                return {};\n            case wgpu::SType::ShaderModuleSPIRVDescriptor:\n                return {};\n            case wgpu::SType::ShaderModuleWGSLDescriptor:\n                return {};\n            case wgpu::SType::PrimitiveDepthClipControl:\n                return {};\n            case wgpu::SType::SurfaceDescriptorFromWaylandSurface:\n                return {};\n            case wgpu::SType::SurfaceDescriptorFromAndroidNativeWindow:\n                return {};\n            case wgpu::SType::SurfaceDescriptorFromWindowsCoreWindow:\n                return {};\n            case wgpu::SType::ExternalTextureBindingEntry:\n                return {};\n            case wgpu::SType::ExternalTextureBindingLayout:\n                return {};\n            case wgpu::SType::SurfaceDescriptorFromWindowsSwapChainPanel:\n                return {};\n            case wgpu::SType::RenderPassDescriptorMaxDrawCount:\n                return {};\n            case wgpu::SType::DawnTextureInternalUsageDescriptor:\n                return {};\n            case wgpu::SType::DawnEncoderInternalUsageDescriptor:\n                return {};\n            case wgpu::SType::DawnInstanceDescriptor:\n                return {};\n            case wgpu::SType::DawnCacheDeviceDescriptor:\n                return {};\n            case wgpu::SType::DawnAdapterPropertiesPowerPreference:\n                return {};\n            case wgpu::SType::DawnBufferDescriptorErrorInfoFromWireClient:\n                return {};\n            case wgpu::SType::DawnTogglesDescriptor:\n                return {};\n            case wgpu::SType::DawnShaderModuleSPIRVOptionsDescriptor:\n                return {};\n            case wgpu::SType::RequestAdapterOptionsLUID:\n                return {};\n            case wgpu::SType::RequestAdapterOptionsGetGLProc:\n                return {};\n            case wgpu::SType::DawnMultisampleStateRenderToSingleSampled:\n                return {};\n            case wgpu::SType::DawnRenderPassColorAttachmentRenderToSingleSampled:\n                return {};\n            default:\n                return DAWN_VALIDATION_ERROR(\"Value %i is invalid for WGPUSType.\", static_cast<uint32_t>(value));\n        }\n    }\n\n    MaybeError ValidateSamplerBindingType(wgpu::SamplerBindingType value) {\n        switch (value) {\n            case wgpu::SamplerBindingType::Filtering:\n                return {};\n            case wgpu::SamplerBindingType::NonFiltering:\n                return {};\n            case wgpu::SamplerBindingType::Comparison:\n                return {};\n            default:\n                return DAWN_VALIDATION_ERROR(\"Value %i is invalid for WGPUSamplerBindingType.\", static_cast<uint32_t>(value));\n        }\n    }\n\n    MaybeError ValidateStencilOperation(wgpu::StencilOperation value) {\n        switch (value) {\n            case wgpu::StencilOperation::Keep:\n                return {};\n            case wgpu::StencilOperation::Zero:\n                return {};\n            case wgpu::StencilOperation::Replace:\n                return {};\n            case wgpu::StencilOperation::Invert:\n                return {};\n            case wgpu::StencilOperation::IncrementClamp:\n                return {};\n            case wgpu::StencilOperation::DecrementClamp:\n                return {};\n            case wgpu::StencilOperation::IncrementWrap:\n                return {};\n            case wgpu::StencilOperation::DecrementWrap:\n                return {};\n            default:\n                return DAWN_VALIDATION_ERROR(\"Value %i is invalid for WGPUStencilOperation.\", static_cast<uint32_t>(value));\n        }\n    }\n\n    MaybeError ValidateStorageTextureAccess(wgpu::StorageTextureAccess value) {\n        switch (value) {\n            case wgpu::StorageTextureAccess::WriteOnly:\n                return {};\n            default:\n                return DAWN_VALIDATION_ERROR(\"Value %i is invalid for WGPUStorageTextureAccess.\", static_cast<uint32_t>(value));\n        }\n    }\n\n    MaybeError ValidateStoreOp(wgpu::StoreOp value) {\n        switch (value) {\n            case wgpu::StoreOp::Undefined:\n                return {};\n            case wgpu::StoreOp::Store:\n                return {};\n            case wgpu::StoreOp::Discard:\n                return {};\n            default:\n                return DAWN_VALIDATION_ERROR(\"Value %i is invalid for WGPUStoreOp.\", static_cast<uint32_t>(value));\n        }\n    }\n\n    MaybeError ValidateTextureAspect(wgpu::TextureAspect value) {\n        switch (value) {\n            case wgpu::TextureAspect::All:\n                return {};\n            case wgpu::TextureAspect::StencilOnly:\n                return {};\n            case wgpu::TextureAspect::DepthOnly:\n                return {};\n            case wgpu::TextureAspect::Plane0Only:\n                return {};\n            case wgpu::TextureAspect::Plane1Only:\n                return {};\n            default:\n                return DAWN_VALIDATION_ERROR(\"Value %i is invalid for WGPUTextureAspect.\", static_cast<uint32_t>(value));\n        }\n    }\n\n    MaybeError ValidateTextureDimension(wgpu::TextureDimension value) {\n        switch (value) {\n            case wgpu::TextureDimension::e1D:\n                return {};\n            case wgpu::TextureDimension::e2D:\n                return {};\n            case wgpu::TextureDimension::e3D:\n                return {};\n            default:\n                return DAWN_VALIDATION_ERROR(\"Value %i is invalid for WGPUTextureDimension.\", static_cast<uint32_t>(value));\n        }\n    }\n\n    MaybeError ValidateTextureFormat(wgpu::TextureFormat value) {\n        switch (value) {\n            case wgpu::TextureFormat::R8Unorm:\n                return {};\n            case wgpu::TextureFormat::R8Snorm:\n                return {};\n            case wgpu::TextureFormat::R8Uint:\n                return {};\n            case wgpu::TextureFormat::R8Sint:\n                return {};\n            case wgpu::TextureFormat::R16Uint:\n                return {};\n            case wgpu::TextureFormat::R16Sint:\n                return {};\n            case wgpu::TextureFormat::R16Float:\n                return {};\n            case wgpu::TextureFormat::RG8Unorm:\n                return {};\n            case wgpu::TextureFormat::RG8Snorm:\n                return {};\n            case wgpu::TextureFormat::RG8Uint:\n                return {};\n            case wgpu::TextureFormat::RG8Sint:\n                return {};\n            case wgpu::TextureFormat::R32Float:\n                return {};\n            case wgpu::TextureFormat::R32Uint:\n                return {};\n            case wgpu::TextureFormat::R32Sint:\n                return {};\n            case wgpu::TextureFormat::RG16Uint:\n                return {};\n            case wgpu::TextureFormat::RG16Sint:\n                return {};\n            case wgpu::TextureFormat::RG16Float:\n                return {};\n            case wgpu::TextureFormat::RGBA8Unorm:\n                return {};\n            case wgpu::TextureFormat::RGBA8UnormSrgb:\n                return {};\n            case wgpu::TextureFormat::RGBA8Snorm:\n                return {};\n            case wgpu::TextureFormat::RGBA8Uint:\n                return {};\n            case wgpu::TextureFormat::RGBA8Sint:\n                return {};\n            case wgpu::TextureFormat::BGRA8Unorm:\n                return {};\n            case wgpu::TextureFormat::BGRA8UnormSrgb:\n                return {};\n            case wgpu::TextureFormat::RGB10A2Unorm:\n                return {};\n            case wgpu::TextureFormat::RG11B10Ufloat:\n                return {};\n            case wgpu::TextureFormat::RGB9E5Ufloat:\n                return {};\n            case wgpu::TextureFormat::RG32Float:\n                return {};\n            case wgpu::TextureFormat::RG32Uint:\n                return {};\n            case wgpu::TextureFormat::RG32Sint:\n                return {};\n            case wgpu::TextureFormat::RGBA16Uint:\n                return {};\n            case wgpu::TextureFormat::RGBA16Sint:\n                return {};\n            case wgpu::TextureFormat::RGBA16Float:\n                return {};\n            case wgpu::TextureFormat::RGBA32Float:\n                return {};\n            case wgpu::TextureFormat::RGBA32Uint:\n                return {};\n            case wgpu::TextureFormat::RGBA32Sint:\n                return {};\n            case wgpu::TextureFormat::Stencil8:\n                return {};\n            case wgpu::TextureFormat::Depth16Unorm:\n                return {};\n            case wgpu::TextureFormat::Depth24Plus:\n                return {};\n            case wgpu::TextureFormat::Depth24PlusStencil8:\n                return {};\n            case wgpu::TextureFormat::Depth32Float:\n                return {};\n            case wgpu::TextureFormat::Depth32FloatStencil8:\n                return {};\n            case wgpu::TextureFormat::BC1RGBAUnorm:\n                return {};\n            case wgpu::TextureFormat::BC1RGBAUnormSrgb:\n                return {};\n            case wgpu::TextureFormat::BC2RGBAUnorm:\n                return {};\n            case wgpu::TextureFormat::BC2RGBAUnormSrgb:\n                return {};\n            case wgpu::TextureFormat::BC3RGBAUnorm:\n                return {};\n            case wgpu::TextureFormat::BC3RGBAUnormSrgb:\n                return {};\n            case wgpu::TextureFormat::BC4RUnorm:\n                return {};\n            case wgpu::TextureFormat::BC4RSnorm:\n                return {};\n            case wgpu::TextureFormat::BC5RGUnorm:\n                return {};\n            case wgpu::TextureFormat::BC5RGSnorm:\n                return {};\n            case wgpu::TextureFormat::BC6HRGBUfloat:\n                return {};\n            case wgpu::TextureFormat::BC6HRGBFloat:\n                return {};\n            case wgpu::TextureFormat::BC7RGBAUnorm:\n                return {};\n            case wgpu::TextureFormat::BC7RGBAUnormSrgb:\n                return {};\n            case wgpu::TextureFormat::ETC2RGB8Unorm:\n                return {};\n            case wgpu::TextureFormat::ETC2RGB8UnormSrgb:\n                return {};\n            case wgpu::TextureFormat::ETC2RGB8A1Unorm:\n                return {};\n            case wgpu::TextureFormat::ETC2RGB8A1UnormSrgb:\n                return {};\n            case wgpu::TextureFormat::ETC2RGBA8Unorm:\n                return {};\n            case wgpu::TextureFormat::ETC2RGBA8UnormSrgb:\n                return {};\n            case wgpu::TextureFormat::EACR11Unorm:\n                return {};\n            case wgpu::TextureFormat::EACR11Snorm:\n                return {};\n            case wgpu::TextureFormat::EACRG11Unorm:\n                return {};\n            case wgpu::TextureFormat::EACRG11Snorm:\n                return {};\n            case wgpu::TextureFormat::ASTC4x4Unorm:\n                return {};\n            case wgpu::TextureFormat::ASTC4x4UnormSrgb:\n                return {};\n            case wgpu::TextureFormat::ASTC5x4Unorm:\n                return {};\n            case wgpu::TextureFormat::ASTC5x4UnormSrgb:\n                return {};\n            case wgpu::TextureFormat::ASTC5x5Unorm:\n                return {};\n            case wgpu::TextureFormat::ASTC5x5UnormSrgb:\n                return {};\n            case wgpu::TextureFormat::ASTC6x5Unorm:\n                return {};\n            case wgpu::TextureFormat::ASTC6x5UnormSrgb:\n                return {};\n            case wgpu::TextureFormat::ASTC6x6Unorm:\n                return {};\n            case wgpu::TextureFormat::ASTC6x6UnormSrgb:\n                return {};\n            case wgpu::TextureFormat::ASTC8x5Unorm:\n                return {};\n            case wgpu::TextureFormat::ASTC8x5UnormSrgb:\n                return {};\n            case wgpu::TextureFormat::ASTC8x6Unorm:\n                return {};\n            case wgpu::TextureFormat::ASTC8x6UnormSrgb:\n                return {};\n            case wgpu::TextureFormat::ASTC8x8Unorm:\n                return {};\n            case wgpu::TextureFormat::ASTC8x8UnormSrgb:\n                return {};\n            case wgpu::TextureFormat::ASTC10x5Unorm:\n                return {};\n            case wgpu::TextureFormat::ASTC10x5UnormSrgb:\n                return {};\n            case wgpu::TextureFormat::ASTC10x6Unorm:\n                return {};\n            case wgpu::TextureFormat::ASTC10x6UnormSrgb:\n                return {};\n            case wgpu::TextureFormat::ASTC10x8Unorm:\n                return {};\n            case wgpu::TextureFormat::ASTC10x8UnormSrgb:\n                return {};\n            case wgpu::TextureFormat::ASTC10x10Unorm:\n                return {};\n            case wgpu::TextureFormat::ASTC10x10UnormSrgb:\n                return {};\n            case wgpu::TextureFormat::ASTC12x10Unorm:\n                return {};\n            case wgpu::TextureFormat::ASTC12x10UnormSrgb:\n                return {};\n            case wgpu::TextureFormat::ASTC12x12Unorm:\n                return {};\n            case wgpu::TextureFormat::ASTC12x12UnormSrgb:\n                return {};\n            case wgpu::TextureFormat::R8BG8Biplanar420Unorm:\n                return {};\n            default:\n                return DAWN_VALIDATION_ERROR(\"Value %i is invalid for WGPUTextureFormat.\", static_cast<uint32_t>(value));\n        }\n    }\n\n    MaybeError ValidateTextureSampleType(wgpu::TextureSampleType value) {\n        switch (value) {\n            case wgpu::TextureSampleType::Float:\n                return {};\n            case wgpu::TextureSampleType::UnfilterableFloat:\n                return {};\n            case wgpu::TextureSampleType::Depth:\n                return {};\n            case wgpu::TextureSampleType::Sint:\n                return {};\n            case wgpu::TextureSampleType::Uint:\n                return {};\n            default:\n                return DAWN_VALIDATION_ERROR(\"Value %i is invalid for WGPUTextureSampleType.\", static_cast<uint32_t>(value));\n        }\n    }\n\n    MaybeError ValidateTextureViewDimension(wgpu::TextureViewDimension value) {\n        switch (value) {\n            case wgpu::TextureViewDimension::e1D:\n                return {};\n            case wgpu::TextureViewDimension::e2D:\n                return {};\n            case wgpu::TextureViewDimension::e2DArray:\n                return {};\n            case wgpu::TextureViewDimension::Cube:\n                return {};\n            case wgpu::TextureViewDimension::CubeArray:\n                return {};\n            case wgpu::TextureViewDimension::e3D:\n                return {};\n            default:\n                return DAWN_VALIDATION_ERROR(\"Value %i is invalid for WGPUTextureViewDimension.\", static_cast<uint32_t>(value));\n        }\n    }\n\n    MaybeError ValidateVertexFormat(wgpu::VertexFormat value) {\n        switch (value) {\n            case wgpu::VertexFormat::Uint8x2:\n                return {};\n            case wgpu::VertexFormat::Uint8x4:\n                return {};\n            case wgpu::VertexFormat::Sint8x2:\n                return {};\n            case wgpu::VertexFormat::Sint8x4:\n                return {};\n            case wgpu::VertexFormat::Unorm8x2:\n                return {};\n            case wgpu::VertexFormat::Unorm8x4:\n                return {};\n            case wgpu::VertexFormat::Snorm8x2:\n                return {};\n            case wgpu::VertexFormat::Snorm8x4:\n                return {};\n            case wgpu::VertexFormat::Uint16x2:\n                return {};\n            case wgpu::VertexFormat::Uint16x4:\n                return {};\n            case wgpu::VertexFormat::Sint16x2:\n                return {};\n            case wgpu::VertexFormat::Sint16x4:\n                return {};\n            case wgpu::VertexFormat::Unorm16x2:\n                return {};\n            case wgpu::VertexFormat::Unorm16x4:\n                return {};\n            case wgpu::VertexFormat::Snorm16x2:\n                return {};\n            case wgpu::VertexFormat::Snorm16x4:\n                return {};\n            case wgpu::VertexFormat::Float16x2:\n                return {};\n            case wgpu::VertexFormat::Float16x4:\n                return {};\n            case wgpu::VertexFormat::Float32:\n                return {};\n            case wgpu::VertexFormat::Float32x2:\n                return {};\n            case wgpu::VertexFormat::Float32x3:\n                return {};\n            case wgpu::VertexFormat::Float32x4:\n                return {};\n            case wgpu::VertexFormat::Uint32:\n                return {};\n            case wgpu::VertexFormat::Uint32x2:\n                return {};\n            case wgpu::VertexFormat::Uint32x3:\n                return {};\n            case wgpu::VertexFormat::Uint32x4:\n                return {};\n            case wgpu::VertexFormat::Sint32:\n                return {};\n            case wgpu::VertexFormat::Sint32x2:\n                return {};\n            case wgpu::VertexFormat::Sint32x3:\n                return {};\n            case wgpu::VertexFormat::Sint32x4:\n                return {};\n            default:\n                return DAWN_VALIDATION_ERROR(\"Value %i is invalid for WGPUVertexFormat.\", static_cast<uint32_t>(value));\n        }\n    }\n\n    MaybeError ValidateVertexStepMode(wgpu::VertexStepMode value) {\n        switch (value) {\n            case wgpu::VertexStepMode::Vertex:\n                return {};\n            case wgpu::VertexStepMode::Instance:\n                return {};\n            case wgpu::VertexStepMode::VertexBufferNotUsed:\n                return {};\n            default:\n                return DAWN_VALIDATION_ERROR(\"Value %i is invalid for WGPUVertexStepMode.\", static_cast<uint32_t>(value));\n        }\n    }\n\n\n    MaybeError ValidateBufferUsage(wgpu::BufferUsage value) {\n        if ((value & static_cast<wgpu::BufferUsage>(~1023)) == 0) {\n            return {};\n        }\n        return DAWN_VALIDATION_ERROR(\"Value %i is invalid for WGPUBufferUsage.\", static_cast<uint32_t>(value));\n    }\n\n    MaybeError ValidateColorWriteMask(wgpu::ColorWriteMask value) {\n        if ((value & static_cast<wgpu::ColorWriteMask>(~15)) == 0) {\n            return {};\n        }\n        return DAWN_VALIDATION_ERROR(\"Value %i is invalid for WGPUColorWriteMask.\", static_cast<uint32_t>(value));\n    }\n\n    MaybeError ValidateMapMode(wgpu::MapMode value) {\n        if ((value & static_cast<wgpu::MapMode>(~3)) == 0) {\n            return {};\n        }\n        return DAWN_VALIDATION_ERROR(\"Value %i is invalid for WGPUMapMode.\", static_cast<uint32_t>(value));\n    }\n\n    MaybeError ValidateShaderStage(wgpu::ShaderStage value) {\n        if ((value & static_cast<wgpu::ShaderStage>(~7)) == 0) {\n            return {};\n        }\n        return DAWN_VALIDATION_ERROR(\"Value %i is invalid for WGPUShaderStage.\", static_cast<uint32_t>(value));\n    }\n\n    MaybeError ValidateTextureUsage(wgpu::TextureUsage value) {\n        if ((value & static_cast<wgpu::TextureUsage>(~63)) == 0) {\n            return {};\n        }\n        return DAWN_VALIDATION_ERROR(\"Value %i is invalid for WGPUTextureUsage.\", static_cast<uint32_t>(value));\n    }\n\n\n} // namespace dawn::native\n", "src/dawn/native/dawn_platform_autogen.h": "\n#ifndef DAWNNATIVE_DAWN_PLATFORM_AUTOGEN_H_\n#define DAWNNATIVE_DAWN_PLATFORM_AUTOGEN_H_\n\n#include \"dawn/webgpu_cpp.h\"\n#include \"dawn/native/Forward.h\"\n\n// Use our autogenerated version of the wgpu structures that point to dawn::native object types\n// (wgpu::Buffer is dawn::native::BufferBase*)\n#include <dawn/native/wgpu_structs_autogen.h>\n\nnamespace dawn::native {\n\n    inline const WGPUAdapterProperties* ToAPI(const AdapterProperties* rhs) {\n        return reinterpret_cast<const WGPUAdapterProperties*>(rhs);\n    }\n\n    inline WGPUAdapterProperties* ToAPI(AdapterProperties* rhs) {\n        return reinterpret_cast<WGPUAdapterProperties*>(rhs);\n    }\n\n    inline const AdapterProperties* FromAPI(const WGPUAdapterProperties* rhs) {\n        return reinterpret_cast<const AdapterProperties*>(rhs);\n    }\n\n    inline AdapterProperties* FromAPI(WGPUAdapterProperties* rhs) {\n        return reinterpret_cast<AdapterProperties*>(rhs);\n    }\n\n    inline const wgpu::AdapterProperties* ToCppAPI(const AdapterProperties* rhs) {\n        return reinterpret_cast<const wgpu::AdapterProperties*>(rhs);\n    }\n\n    inline wgpu::AdapterProperties* ToCppAPI(AdapterProperties* rhs) {\n        return reinterpret_cast<wgpu::AdapterProperties*>(rhs);\n    }\n\n    inline const AdapterProperties* FromCppAPI(const wgpu::AdapterProperties* rhs) {\n        return reinterpret_cast<const AdapterProperties*>(rhs);\n    }\n\n    inline AdapterProperties* FromCppAPI(wgpu::AdapterProperties* rhs) {\n        return reinterpret_cast<AdapterProperties*>(rhs);\n    }\n\n    inline const WGPUBindGroupEntry* ToAPI(const BindGroupEntry* rhs) {\n        return reinterpret_cast<const WGPUBindGroupEntry*>(rhs);\n    }\n\n    inline WGPUBindGroupEntry* ToAPI(BindGroupEntry* rhs) {\n        return reinterpret_cast<WGPUBindGroupEntry*>(rhs);\n    }\n\n    inline const BindGroupEntry* FromAPI(const WGPUBindGroupEntry* rhs) {\n        return reinterpret_cast<const BindGroupEntry*>(rhs);\n    }\n\n    inline BindGroupEntry* FromAPI(WGPUBindGroupEntry* rhs) {\n        return reinterpret_cast<BindGroupEntry*>(rhs);\n    }\n\n    inline const wgpu::BindGroupEntry* ToCppAPI(const BindGroupEntry* rhs) {\n        return reinterpret_cast<const wgpu::BindGroupEntry*>(rhs);\n    }\n\n    inline wgpu::BindGroupEntry* ToCppAPI(BindGroupEntry* rhs) {\n        return reinterpret_cast<wgpu::BindGroupEntry*>(rhs);\n    }\n\n    inline const BindGroupEntry* FromCppAPI(const wgpu::BindGroupEntry* rhs) {\n        return reinterpret_cast<const BindGroupEntry*>(rhs);\n    }\n\n    inline BindGroupEntry* FromCppAPI(wgpu::BindGroupEntry* rhs) {\n        return reinterpret_cast<BindGroupEntry*>(rhs);\n    }\n\n    inline const WGPUBlendComponent* ToAPI(const BlendComponent* rhs) {\n        return reinterpret_cast<const WGPUBlendComponent*>(rhs);\n    }\n\n    inline WGPUBlendComponent* ToAPI(BlendComponent* rhs) {\n        return reinterpret_cast<WGPUBlendComponent*>(rhs);\n    }\n\n    inline const BlendComponent* FromAPI(const WGPUBlendComponent* rhs) {\n        return reinterpret_cast<const BlendComponent*>(rhs);\n    }\n\n    inline BlendComponent* FromAPI(WGPUBlendComponent* rhs) {\n        return reinterpret_cast<BlendComponent*>(rhs);\n    }\n\n    inline const wgpu::BlendComponent* ToCppAPI(const BlendComponent* rhs) {\n        return reinterpret_cast<const wgpu::BlendComponent*>(rhs);\n    }\n\n    inline wgpu::BlendComponent* ToCppAPI(BlendComponent* rhs) {\n        return reinterpret_cast<wgpu::BlendComponent*>(rhs);\n    }\n\n    inline const BlendComponent* FromCppAPI(const wgpu::BlendComponent* rhs) {\n        return reinterpret_cast<const BlendComponent*>(rhs);\n    }\n\n    inline BlendComponent* FromCppAPI(wgpu::BlendComponent* rhs) {\n        return reinterpret_cast<BlendComponent*>(rhs);\n    }\n\n    inline const WGPUBufferBindingLayout* ToAPI(const BufferBindingLayout* rhs) {\n        return reinterpret_cast<const WGPUBufferBindingLayout*>(rhs);\n    }\n\n    inline WGPUBufferBindingLayout* ToAPI(BufferBindingLayout* rhs) {\n        return reinterpret_cast<WGPUBufferBindingLayout*>(rhs);\n    }\n\n    inline const BufferBindingLayout* FromAPI(const WGPUBufferBindingLayout* rhs) {\n        return reinterpret_cast<const BufferBindingLayout*>(rhs);\n    }\n\n    inline BufferBindingLayout* FromAPI(WGPUBufferBindingLayout* rhs) {\n        return reinterpret_cast<BufferBindingLayout*>(rhs);\n    }\n\n    inline const wgpu::BufferBindingLayout* ToCppAPI(const BufferBindingLayout* rhs) {\n        return reinterpret_cast<const wgpu::BufferBindingLayout*>(rhs);\n    }\n\n    inline wgpu::BufferBindingLayout* ToCppAPI(BufferBindingLayout* rhs) {\n        return reinterpret_cast<wgpu::BufferBindingLayout*>(rhs);\n    }\n\n    inline const BufferBindingLayout* FromCppAPI(const wgpu::BufferBindingLayout* rhs) {\n        return reinterpret_cast<const BufferBindingLayout*>(rhs);\n    }\n\n    inline BufferBindingLayout* FromCppAPI(wgpu::BufferBindingLayout* rhs) {\n        return reinterpret_cast<BufferBindingLayout*>(rhs);\n    }\n\n    inline const WGPUBufferDescriptor* ToAPI(const BufferDescriptor* rhs) {\n        return reinterpret_cast<const WGPUBufferDescriptor*>(rhs);\n    }\n\n    inline WGPUBufferDescriptor* ToAPI(BufferDescriptor* rhs) {\n        return reinterpret_cast<WGPUBufferDescriptor*>(rhs);\n    }\n\n    inline const BufferDescriptor* FromAPI(const WGPUBufferDescriptor* rhs) {\n        return reinterpret_cast<const BufferDescriptor*>(rhs);\n    }\n\n    inline BufferDescriptor* FromAPI(WGPUBufferDescriptor* rhs) {\n        return reinterpret_cast<BufferDescriptor*>(rhs);\n    }\n\n    inline const wgpu::BufferDescriptor* ToCppAPI(const BufferDescriptor* rhs) {\n        return reinterpret_cast<const wgpu::BufferDescriptor*>(rhs);\n    }\n\n    inline wgpu::BufferDescriptor* ToCppAPI(BufferDescriptor* rhs) {\n        return reinterpret_cast<wgpu::BufferDescriptor*>(rhs);\n    }\n\n    inline const BufferDescriptor* FromCppAPI(const wgpu::BufferDescriptor* rhs) {\n        return reinterpret_cast<const BufferDescriptor*>(rhs);\n    }\n\n    inline BufferDescriptor* FromCppAPI(wgpu::BufferDescriptor* rhs) {\n        return reinterpret_cast<BufferDescriptor*>(rhs);\n    }\n\n    inline const WGPUColor* ToAPI(const Color* rhs) {\n        return reinterpret_cast<const WGPUColor*>(rhs);\n    }\n\n    inline WGPUColor* ToAPI(Color* rhs) {\n        return reinterpret_cast<WGPUColor*>(rhs);\n    }\n\n    inline const Color* FromAPI(const WGPUColor* rhs) {\n        return reinterpret_cast<const Color*>(rhs);\n    }\n\n    inline Color* FromAPI(WGPUColor* rhs) {\n        return reinterpret_cast<Color*>(rhs);\n    }\n\n    inline const wgpu::Color* ToCppAPI(const Color* rhs) {\n        return reinterpret_cast<const wgpu::Color*>(rhs);\n    }\n\n    inline wgpu::Color* ToCppAPI(Color* rhs) {\n        return reinterpret_cast<wgpu::Color*>(rhs);\n    }\n\n    inline const Color* FromCppAPI(const wgpu::Color* rhs) {\n        return reinterpret_cast<const Color*>(rhs);\n    }\n\n    inline Color* FromCppAPI(wgpu::Color* rhs) {\n        return reinterpret_cast<Color*>(rhs);\n    }\n\n    inline const WGPUCommandBufferDescriptor* ToAPI(const CommandBufferDescriptor* rhs) {\n        return reinterpret_cast<const WGPUCommandBufferDescriptor*>(rhs);\n    }\n\n    inline WGPUCommandBufferDescriptor* ToAPI(CommandBufferDescriptor* rhs) {\n        return reinterpret_cast<WGPUCommandBufferDescriptor*>(rhs);\n    }\n\n    inline const CommandBufferDescriptor* FromAPI(const WGPUCommandBufferDescriptor* rhs) {\n        return reinterpret_cast<const CommandBufferDescriptor*>(rhs);\n    }\n\n    inline CommandBufferDescriptor* FromAPI(WGPUCommandBufferDescriptor* rhs) {\n        return reinterpret_cast<CommandBufferDescriptor*>(rhs);\n    }\n\n    inline const wgpu::CommandBufferDescriptor* ToCppAPI(const CommandBufferDescriptor* rhs) {\n        return reinterpret_cast<const wgpu::CommandBufferDescriptor*>(rhs);\n    }\n\n    inline wgpu::CommandBufferDescriptor* ToCppAPI(CommandBufferDescriptor* rhs) {\n        return reinterpret_cast<wgpu::CommandBufferDescriptor*>(rhs);\n    }\n\n    inline const CommandBufferDescriptor* FromCppAPI(const wgpu::CommandBufferDescriptor* rhs) {\n        return reinterpret_cast<const CommandBufferDescriptor*>(rhs);\n    }\n\n    inline CommandBufferDescriptor* FromCppAPI(wgpu::CommandBufferDescriptor* rhs) {\n        return reinterpret_cast<CommandBufferDescriptor*>(rhs);\n    }\n\n    inline const WGPUCommandEncoderDescriptor* ToAPI(const CommandEncoderDescriptor* rhs) {\n        return reinterpret_cast<const WGPUCommandEncoderDescriptor*>(rhs);\n    }\n\n    inline WGPUCommandEncoderDescriptor* ToAPI(CommandEncoderDescriptor* rhs) {\n        return reinterpret_cast<WGPUCommandEncoderDescriptor*>(rhs);\n    }\n\n    inline const CommandEncoderDescriptor* FromAPI(const WGPUCommandEncoderDescriptor* rhs) {\n        return reinterpret_cast<const CommandEncoderDescriptor*>(rhs);\n    }\n\n    inline CommandEncoderDescriptor* FromAPI(WGPUCommandEncoderDescriptor* rhs) {\n        return reinterpret_cast<CommandEncoderDescriptor*>(rhs);\n    }\n\n    inline const wgpu::CommandEncoderDescriptor* ToCppAPI(const CommandEncoderDescriptor* rhs) {\n        return reinterpret_cast<const wgpu::CommandEncoderDescriptor*>(rhs);\n    }\n\n    inline wgpu::CommandEncoderDescriptor* ToCppAPI(CommandEncoderDescriptor* rhs) {\n        return reinterpret_cast<wgpu::CommandEncoderDescriptor*>(rhs);\n    }\n\n    inline const CommandEncoderDescriptor* FromCppAPI(const wgpu::CommandEncoderDescriptor* rhs) {\n        return reinterpret_cast<const CommandEncoderDescriptor*>(rhs);\n    }\n\n    inline CommandEncoderDescriptor* FromCppAPI(wgpu::CommandEncoderDescriptor* rhs) {\n        return reinterpret_cast<CommandEncoderDescriptor*>(rhs);\n    }\n\n    inline const WGPUCompilationMessage* ToAPI(const CompilationMessage* rhs) {\n        return reinterpret_cast<const WGPUCompilationMessage*>(rhs);\n    }\n\n    inline WGPUCompilationMessage* ToAPI(CompilationMessage* rhs) {\n        return reinterpret_cast<WGPUCompilationMessage*>(rhs);\n    }\n\n    inline const CompilationMessage* FromAPI(const WGPUCompilationMessage* rhs) {\n        return reinterpret_cast<const CompilationMessage*>(rhs);\n    }\n\n    inline CompilationMessage* FromAPI(WGPUCompilationMessage* rhs) {\n        return reinterpret_cast<CompilationMessage*>(rhs);\n    }\n\n    inline const wgpu::CompilationMessage* ToCppAPI(const CompilationMessage* rhs) {\n        return reinterpret_cast<const wgpu::CompilationMessage*>(rhs);\n    }\n\n    inline wgpu::CompilationMessage* ToCppAPI(CompilationMessage* rhs) {\n        return reinterpret_cast<wgpu::CompilationMessage*>(rhs);\n    }\n\n    inline const CompilationMessage* FromCppAPI(const wgpu::CompilationMessage* rhs) {\n        return reinterpret_cast<const CompilationMessage*>(rhs);\n    }\n\n    inline CompilationMessage* FromCppAPI(wgpu::CompilationMessage* rhs) {\n        return reinterpret_cast<CompilationMessage*>(rhs);\n    }\n\n    inline const WGPUComputePassTimestampWrite* ToAPI(const ComputePassTimestampWrite* rhs) {\n        return reinterpret_cast<const WGPUComputePassTimestampWrite*>(rhs);\n    }\n\n    inline WGPUComputePassTimestampWrite* ToAPI(ComputePassTimestampWrite* rhs) {\n        return reinterpret_cast<WGPUComputePassTimestampWrite*>(rhs);\n    }\n\n    inline const ComputePassTimestampWrite* FromAPI(const WGPUComputePassTimestampWrite* rhs) {\n        return reinterpret_cast<const ComputePassTimestampWrite*>(rhs);\n    }\n\n    inline ComputePassTimestampWrite* FromAPI(WGPUComputePassTimestampWrite* rhs) {\n        return reinterpret_cast<ComputePassTimestampWrite*>(rhs);\n    }\n\n    inline const wgpu::ComputePassTimestampWrite* ToCppAPI(const ComputePassTimestampWrite* rhs) {\n        return reinterpret_cast<const wgpu::ComputePassTimestampWrite*>(rhs);\n    }\n\n    inline wgpu::ComputePassTimestampWrite* ToCppAPI(ComputePassTimestampWrite* rhs) {\n        return reinterpret_cast<wgpu::ComputePassTimestampWrite*>(rhs);\n    }\n\n    inline const ComputePassTimestampWrite* FromCppAPI(const wgpu::ComputePassTimestampWrite* rhs) {\n        return reinterpret_cast<const ComputePassTimestampWrite*>(rhs);\n    }\n\n    inline ComputePassTimestampWrite* FromCppAPI(wgpu::ComputePassTimestampWrite* rhs) {\n        return reinterpret_cast<ComputePassTimestampWrite*>(rhs);\n    }\n\n    inline const WGPUConstantEntry* ToAPI(const ConstantEntry* rhs) {\n        return reinterpret_cast<const WGPUConstantEntry*>(rhs);\n    }\n\n    inline WGPUConstantEntry* ToAPI(ConstantEntry* rhs) {\n        return reinterpret_cast<WGPUConstantEntry*>(rhs);\n    }\n\n    inline const ConstantEntry* FromAPI(const WGPUConstantEntry* rhs) {\n        return reinterpret_cast<const ConstantEntry*>(rhs);\n    }\n\n    inline ConstantEntry* FromAPI(WGPUConstantEntry* rhs) {\n        return reinterpret_cast<ConstantEntry*>(rhs);\n    }\n\n    inline const wgpu::ConstantEntry* ToCppAPI(const ConstantEntry* rhs) {\n        return reinterpret_cast<const wgpu::ConstantEntry*>(rhs);\n    }\n\n    inline wgpu::ConstantEntry* ToCppAPI(ConstantEntry* rhs) {\n        return reinterpret_cast<wgpu::ConstantEntry*>(rhs);\n    }\n\n    inline const ConstantEntry* FromCppAPI(const wgpu::ConstantEntry* rhs) {\n        return reinterpret_cast<const ConstantEntry*>(rhs);\n    }\n\n    inline ConstantEntry* FromCppAPI(wgpu::ConstantEntry* rhs) {\n        return reinterpret_cast<ConstantEntry*>(rhs);\n    }\n\n    inline const WGPUCopyTextureForBrowserOptions* ToAPI(const CopyTextureForBrowserOptions* rhs) {\n        return reinterpret_cast<const WGPUCopyTextureForBrowserOptions*>(rhs);\n    }\n\n    inline WGPUCopyTextureForBrowserOptions* ToAPI(CopyTextureForBrowserOptions* rhs) {\n        return reinterpret_cast<WGPUCopyTextureForBrowserOptions*>(rhs);\n    }\n\n    inline const CopyTextureForBrowserOptions* FromAPI(const WGPUCopyTextureForBrowserOptions* rhs) {\n        return reinterpret_cast<const CopyTextureForBrowserOptions*>(rhs);\n    }\n\n    inline CopyTextureForBrowserOptions* FromAPI(WGPUCopyTextureForBrowserOptions* rhs) {\n        return reinterpret_cast<CopyTextureForBrowserOptions*>(rhs);\n    }\n\n    inline const wgpu::CopyTextureForBrowserOptions* ToCppAPI(const CopyTextureForBrowserOptions* rhs) {\n        return reinterpret_cast<const wgpu::CopyTextureForBrowserOptions*>(rhs);\n    }\n\n    inline wgpu::CopyTextureForBrowserOptions* ToCppAPI(CopyTextureForBrowserOptions* rhs) {\n        return reinterpret_cast<wgpu::CopyTextureForBrowserOptions*>(rhs);\n    }\n\n    inline const CopyTextureForBrowserOptions* FromCppAPI(const wgpu::CopyTextureForBrowserOptions* rhs) {\n        return reinterpret_cast<const CopyTextureForBrowserOptions*>(rhs);\n    }\n\n    inline CopyTextureForBrowserOptions* FromCppAPI(wgpu::CopyTextureForBrowserOptions* rhs) {\n        return reinterpret_cast<CopyTextureForBrowserOptions*>(rhs);\n    }\n\n    inline const WGPUDawnAdapterPropertiesPowerPreference* ToAPI(const DawnAdapterPropertiesPowerPreference* rhs) {\n        return reinterpret_cast<const WGPUDawnAdapterPropertiesPowerPreference*>(rhs);\n    }\n\n    inline WGPUDawnAdapterPropertiesPowerPreference* ToAPI(DawnAdapterPropertiesPowerPreference* rhs) {\n        return reinterpret_cast<WGPUDawnAdapterPropertiesPowerPreference*>(rhs);\n    }\n\n    inline const DawnAdapterPropertiesPowerPreference* FromAPI(const WGPUDawnAdapterPropertiesPowerPreference* rhs) {\n        return reinterpret_cast<const DawnAdapterPropertiesPowerPreference*>(rhs);\n    }\n\n    inline DawnAdapterPropertiesPowerPreference* FromAPI(WGPUDawnAdapterPropertiesPowerPreference* rhs) {\n        return reinterpret_cast<DawnAdapterPropertiesPowerPreference*>(rhs);\n    }\n\n    inline const wgpu::DawnAdapterPropertiesPowerPreference* ToCppAPI(const DawnAdapterPropertiesPowerPreference* rhs) {\n        return reinterpret_cast<const wgpu::DawnAdapterPropertiesPowerPreference*>(rhs);\n    }\n\n    inline wgpu::DawnAdapterPropertiesPowerPreference* ToCppAPI(DawnAdapterPropertiesPowerPreference* rhs) {\n        return reinterpret_cast<wgpu::DawnAdapterPropertiesPowerPreference*>(rhs);\n    }\n\n    inline const DawnAdapterPropertiesPowerPreference* FromCppAPI(const wgpu::DawnAdapterPropertiesPowerPreference* rhs) {\n        return reinterpret_cast<const DawnAdapterPropertiesPowerPreference*>(rhs);\n    }\n\n    inline DawnAdapterPropertiesPowerPreference* FromCppAPI(wgpu::DawnAdapterPropertiesPowerPreference* rhs) {\n        return reinterpret_cast<DawnAdapterPropertiesPowerPreference*>(rhs);\n    }\n\n    inline const WGPUDawnBufferDescriptorErrorInfoFromWireClient* ToAPI(const DawnBufferDescriptorErrorInfoFromWireClient* rhs) {\n        return reinterpret_cast<const WGPUDawnBufferDescriptorErrorInfoFromWireClient*>(rhs);\n    }\n\n    inline WGPUDawnBufferDescriptorErrorInfoFromWireClient* ToAPI(DawnBufferDescriptorErrorInfoFromWireClient* rhs) {\n        return reinterpret_cast<WGPUDawnBufferDescriptorErrorInfoFromWireClient*>(rhs);\n    }\n\n    inline const DawnBufferDescriptorErrorInfoFromWireClient* FromAPI(const WGPUDawnBufferDescriptorErrorInfoFromWireClient* rhs) {\n        return reinterpret_cast<const DawnBufferDescriptorErrorInfoFromWireClient*>(rhs);\n    }\n\n    inline DawnBufferDescriptorErrorInfoFromWireClient* FromAPI(WGPUDawnBufferDescriptorErrorInfoFromWireClient* rhs) {\n        return reinterpret_cast<DawnBufferDescriptorErrorInfoFromWireClient*>(rhs);\n    }\n\n    inline const wgpu::DawnBufferDescriptorErrorInfoFromWireClient* ToCppAPI(const DawnBufferDescriptorErrorInfoFromWireClient* rhs) {\n        return reinterpret_cast<const wgpu::DawnBufferDescriptorErrorInfoFromWireClient*>(rhs);\n    }\n\n    inline wgpu::DawnBufferDescriptorErrorInfoFromWireClient* ToCppAPI(DawnBufferDescriptorErrorInfoFromWireClient* rhs) {\n        return reinterpret_cast<wgpu::DawnBufferDescriptorErrorInfoFromWireClient*>(rhs);\n    }\n\n    inline const DawnBufferDescriptorErrorInfoFromWireClient* FromCppAPI(const wgpu::DawnBufferDescriptorErrorInfoFromWireClient* rhs) {\n        return reinterpret_cast<const DawnBufferDescriptorErrorInfoFromWireClient*>(rhs);\n    }\n\n    inline DawnBufferDescriptorErrorInfoFromWireClient* FromCppAPI(wgpu::DawnBufferDescriptorErrorInfoFromWireClient* rhs) {\n        return reinterpret_cast<DawnBufferDescriptorErrorInfoFromWireClient*>(rhs);\n    }\n\n    inline const WGPUDawnCacheDeviceDescriptor* ToAPI(const DawnCacheDeviceDescriptor* rhs) {\n        return reinterpret_cast<const WGPUDawnCacheDeviceDescriptor*>(rhs);\n    }\n\n    inline WGPUDawnCacheDeviceDescriptor* ToAPI(DawnCacheDeviceDescriptor* rhs) {\n        return reinterpret_cast<WGPUDawnCacheDeviceDescriptor*>(rhs);\n    }\n\n    inline const DawnCacheDeviceDescriptor* FromAPI(const WGPUDawnCacheDeviceDescriptor* rhs) {\n        return reinterpret_cast<const DawnCacheDeviceDescriptor*>(rhs);\n    }\n\n    inline DawnCacheDeviceDescriptor* FromAPI(WGPUDawnCacheDeviceDescriptor* rhs) {\n        return reinterpret_cast<DawnCacheDeviceDescriptor*>(rhs);\n    }\n\n    inline const wgpu::DawnCacheDeviceDescriptor* ToCppAPI(const DawnCacheDeviceDescriptor* rhs) {\n        return reinterpret_cast<const wgpu::DawnCacheDeviceDescriptor*>(rhs);\n    }\n\n    inline wgpu::DawnCacheDeviceDescriptor* ToCppAPI(DawnCacheDeviceDescriptor* rhs) {\n        return reinterpret_cast<wgpu::DawnCacheDeviceDescriptor*>(rhs);\n    }\n\n    inline const DawnCacheDeviceDescriptor* FromCppAPI(const wgpu::DawnCacheDeviceDescriptor* rhs) {\n        return reinterpret_cast<const DawnCacheDeviceDescriptor*>(rhs);\n    }\n\n    inline DawnCacheDeviceDescriptor* FromCppAPI(wgpu::DawnCacheDeviceDescriptor* rhs) {\n        return reinterpret_cast<DawnCacheDeviceDescriptor*>(rhs);\n    }\n\n    inline const WGPUDawnEncoderInternalUsageDescriptor* ToAPI(const DawnEncoderInternalUsageDescriptor* rhs) {\n        return reinterpret_cast<const WGPUDawnEncoderInternalUsageDescriptor*>(rhs);\n    }\n\n    inline WGPUDawnEncoderInternalUsageDescriptor* ToAPI(DawnEncoderInternalUsageDescriptor* rhs) {\n        return reinterpret_cast<WGPUDawnEncoderInternalUsageDescriptor*>(rhs);\n    }\n\n    inline const DawnEncoderInternalUsageDescriptor* FromAPI(const WGPUDawnEncoderInternalUsageDescriptor* rhs) {\n        return reinterpret_cast<const DawnEncoderInternalUsageDescriptor*>(rhs);\n    }\n\n    inline DawnEncoderInternalUsageDescriptor* FromAPI(WGPUDawnEncoderInternalUsageDescriptor* rhs) {\n        return reinterpret_cast<DawnEncoderInternalUsageDescriptor*>(rhs);\n    }\n\n    inline const wgpu::DawnEncoderInternalUsageDescriptor* ToCppAPI(const DawnEncoderInternalUsageDescriptor* rhs) {\n        return reinterpret_cast<const wgpu::DawnEncoderInternalUsageDescriptor*>(rhs);\n    }\n\n    inline wgpu::DawnEncoderInternalUsageDescriptor* ToCppAPI(DawnEncoderInternalUsageDescriptor* rhs) {\n        return reinterpret_cast<wgpu::DawnEncoderInternalUsageDescriptor*>(rhs);\n    }\n\n    inline const DawnEncoderInternalUsageDescriptor* FromCppAPI(const wgpu::DawnEncoderInternalUsageDescriptor* rhs) {\n        return reinterpret_cast<const DawnEncoderInternalUsageDescriptor*>(rhs);\n    }\n\n    inline DawnEncoderInternalUsageDescriptor* FromCppAPI(wgpu::DawnEncoderInternalUsageDescriptor* rhs) {\n        return reinterpret_cast<DawnEncoderInternalUsageDescriptor*>(rhs);\n    }\n\n    inline const WGPUDawnMultisampleStateRenderToSingleSampled* ToAPI(const DawnMultisampleStateRenderToSingleSampled* rhs) {\n        return reinterpret_cast<const WGPUDawnMultisampleStateRenderToSingleSampled*>(rhs);\n    }\n\n    inline WGPUDawnMultisampleStateRenderToSingleSampled* ToAPI(DawnMultisampleStateRenderToSingleSampled* rhs) {\n        return reinterpret_cast<WGPUDawnMultisampleStateRenderToSingleSampled*>(rhs);\n    }\n\n    inline const DawnMultisampleStateRenderToSingleSampled* FromAPI(const WGPUDawnMultisampleStateRenderToSingleSampled* rhs) {\n        return reinterpret_cast<const DawnMultisampleStateRenderToSingleSampled*>(rhs);\n    }\n\n    inline DawnMultisampleStateRenderToSingleSampled* FromAPI(WGPUDawnMultisampleStateRenderToSingleSampled* rhs) {\n        return reinterpret_cast<DawnMultisampleStateRenderToSingleSampled*>(rhs);\n    }\n\n    inline const wgpu::DawnMultisampleStateRenderToSingleSampled* ToCppAPI(const DawnMultisampleStateRenderToSingleSampled* rhs) {\n        return reinterpret_cast<const wgpu::DawnMultisampleStateRenderToSingleSampled*>(rhs);\n    }\n\n    inline wgpu::DawnMultisampleStateRenderToSingleSampled* ToCppAPI(DawnMultisampleStateRenderToSingleSampled* rhs) {\n        return reinterpret_cast<wgpu::DawnMultisampleStateRenderToSingleSampled*>(rhs);\n    }\n\n    inline const DawnMultisampleStateRenderToSingleSampled* FromCppAPI(const wgpu::DawnMultisampleStateRenderToSingleSampled* rhs) {\n        return reinterpret_cast<const DawnMultisampleStateRenderToSingleSampled*>(rhs);\n    }\n\n    inline DawnMultisampleStateRenderToSingleSampled* FromCppAPI(wgpu::DawnMultisampleStateRenderToSingleSampled* rhs) {\n        return reinterpret_cast<DawnMultisampleStateRenderToSingleSampled*>(rhs);\n    }\n\n    inline const WGPUDawnRenderPassColorAttachmentRenderToSingleSampled* ToAPI(const DawnRenderPassColorAttachmentRenderToSingleSampled* rhs) {\n        return reinterpret_cast<const WGPUDawnRenderPassColorAttachmentRenderToSingleSampled*>(rhs);\n    }\n\n    inline WGPUDawnRenderPassColorAttachmentRenderToSingleSampled* ToAPI(DawnRenderPassColorAttachmentRenderToSingleSampled* rhs) {\n        return reinterpret_cast<WGPUDawnRenderPassColorAttachmentRenderToSingleSampled*>(rhs);\n    }\n\n    inline const DawnRenderPassColorAttachmentRenderToSingleSampled* FromAPI(const WGPUDawnRenderPassColorAttachmentRenderToSingleSampled* rhs) {\n        return reinterpret_cast<const DawnRenderPassColorAttachmentRenderToSingleSampled*>(rhs);\n    }\n\n    inline DawnRenderPassColorAttachmentRenderToSingleSampled* FromAPI(WGPUDawnRenderPassColorAttachmentRenderToSingleSampled* rhs) {\n        return reinterpret_cast<DawnRenderPassColorAttachmentRenderToSingleSampled*>(rhs);\n    }\n\n    inline const wgpu::DawnRenderPassColorAttachmentRenderToSingleSampled* ToCppAPI(const DawnRenderPassColorAttachmentRenderToSingleSampled* rhs) {\n        return reinterpret_cast<const wgpu::DawnRenderPassColorAttachmentRenderToSingleSampled*>(rhs);\n    }\n\n    inline wgpu::DawnRenderPassColorAttachmentRenderToSingleSampled* ToCppAPI(DawnRenderPassColorAttachmentRenderToSingleSampled* rhs) {\n        return reinterpret_cast<wgpu::DawnRenderPassColorAttachmentRenderToSingleSampled*>(rhs);\n    }\n\n    inline const DawnRenderPassColorAttachmentRenderToSingleSampled* FromCppAPI(const wgpu::DawnRenderPassColorAttachmentRenderToSingleSampled* rhs) {\n        return reinterpret_cast<const DawnRenderPassColorAttachmentRenderToSingleSampled*>(rhs);\n    }\n\n    inline DawnRenderPassColorAttachmentRenderToSingleSampled* FromCppAPI(wgpu::DawnRenderPassColorAttachmentRenderToSingleSampled* rhs) {\n        return reinterpret_cast<DawnRenderPassColorAttachmentRenderToSingleSampled*>(rhs);\n    }\n\n    inline const WGPUDawnShaderModuleSPIRVOptionsDescriptor* ToAPI(const DawnShaderModuleSPIRVOptionsDescriptor* rhs) {\n        return reinterpret_cast<const WGPUDawnShaderModuleSPIRVOptionsDescriptor*>(rhs);\n    }\n\n    inline WGPUDawnShaderModuleSPIRVOptionsDescriptor* ToAPI(DawnShaderModuleSPIRVOptionsDescriptor* rhs) {\n        return reinterpret_cast<WGPUDawnShaderModuleSPIRVOptionsDescriptor*>(rhs);\n    }\n\n    inline const DawnShaderModuleSPIRVOptionsDescriptor* FromAPI(const WGPUDawnShaderModuleSPIRVOptionsDescriptor* rhs) {\n        return reinterpret_cast<const DawnShaderModuleSPIRVOptionsDescriptor*>(rhs);\n    }\n\n    inline DawnShaderModuleSPIRVOptionsDescriptor* FromAPI(WGPUDawnShaderModuleSPIRVOptionsDescriptor* rhs) {\n        return reinterpret_cast<DawnShaderModuleSPIRVOptionsDescriptor*>(rhs);\n    }\n\n    inline const wgpu::DawnShaderModuleSPIRVOptionsDescriptor* ToCppAPI(const DawnShaderModuleSPIRVOptionsDescriptor* rhs) {\n        return reinterpret_cast<const wgpu::DawnShaderModuleSPIRVOptionsDescriptor*>(rhs);\n    }\n\n    inline wgpu::DawnShaderModuleSPIRVOptionsDescriptor* ToCppAPI(DawnShaderModuleSPIRVOptionsDescriptor* rhs) {\n        return reinterpret_cast<wgpu::DawnShaderModuleSPIRVOptionsDescriptor*>(rhs);\n    }\n\n    inline const DawnShaderModuleSPIRVOptionsDescriptor* FromCppAPI(const wgpu::DawnShaderModuleSPIRVOptionsDescriptor* rhs) {\n        return reinterpret_cast<const DawnShaderModuleSPIRVOptionsDescriptor*>(rhs);\n    }\n\n    inline DawnShaderModuleSPIRVOptionsDescriptor* FromCppAPI(wgpu::DawnShaderModuleSPIRVOptionsDescriptor* rhs) {\n        return reinterpret_cast<DawnShaderModuleSPIRVOptionsDescriptor*>(rhs);\n    }\n\n    inline const WGPUDawnTextureInternalUsageDescriptor* ToAPI(const DawnTextureInternalUsageDescriptor* rhs) {\n        return reinterpret_cast<const WGPUDawnTextureInternalUsageDescriptor*>(rhs);\n    }\n\n    inline WGPUDawnTextureInternalUsageDescriptor* ToAPI(DawnTextureInternalUsageDescriptor* rhs) {\n        return reinterpret_cast<WGPUDawnTextureInternalUsageDescriptor*>(rhs);\n    }\n\n    inline const DawnTextureInternalUsageDescriptor* FromAPI(const WGPUDawnTextureInternalUsageDescriptor* rhs) {\n        return reinterpret_cast<const DawnTextureInternalUsageDescriptor*>(rhs);\n    }\n\n    inline DawnTextureInternalUsageDescriptor* FromAPI(WGPUDawnTextureInternalUsageDescriptor* rhs) {\n        return reinterpret_cast<DawnTextureInternalUsageDescriptor*>(rhs);\n    }\n\n    inline const wgpu::DawnTextureInternalUsageDescriptor* ToCppAPI(const DawnTextureInternalUsageDescriptor* rhs) {\n        return reinterpret_cast<const wgpu::DawnTextureInternalUsageDescriptor*>(rhs);\n    }\n\n    inline wgpu::DawnTextureInternalUsageDescriptor* ToCppAPI(DawnTextureInternalUsageDescriptor* rhs) {\n        return reinterpret_cast<wgpu::DawnTextureInternalUsageDescriptor*>(rhs);\n    }\n\n    inline const DawnTextureInternalUsageDescriptor* FromCppAPI(const wgpu::DawnTextureInternalUsageDescriptor* rhs) {\n        return reinterpret_cast<const DawnTextureInternalUsageDescriptor*>(rhs);\n    }\n\n    inline DawnTextureInternalUsageDescriptor* FromCppAPI(wgpu::DawnTextureInternalUsageDescriptor* rhs) {\n        return reinterpret_cast<DawnTextureInternalUsageDescriptor*>(rhs);\n    }\n\n    inline const WGPUDawnTogglesDescriptor* ToAPI(const DawnTogglesDescriptor* rhs) {\n        return reinterpret_cast<const WGPUDawnTogglesDescriptor*>(rhs);\n    }\n\n    inline WGPUDawnTogglesDescriptor* ToAPI(DawnTogglesDescriptor* rhs) {\n        return reinterpret_cast<WGPUDawnTogglesDescriptor*>(rhs);\n    }\n\n    inline const DawnTogglesDescriptor* FromAPI(const WGPUDawnTogglesDescriptor* rhs) {\n        return reinterpret_cast<const DawnTogglesDescriptor*>(rhs);\n    }\n\n    inline DawnTogglesDescriptor* FromAPI(WGPUDawnTogglesDescriptor* rhs) {\n        return reinterpret_cast<DawnTogglesDescriptor*>(rhs);\n    }\n\n    inline const wgpu::DawnTogglesDescriptor* ToCppAPI(const DawnTogglesDescriptor* rhs) {\n        return reinterpret_cast<const wgpu::DawnTogglesDescriptor*>(rhs);\n    }\n\n    inline wgpu::DawnTogglesDescriptor* ToCppAPI(DawnTogglesDescriptor* rhs) {\n        return reinterpret_cast<wgpu::DawnTogglesDescriptor*>(rhs);\n    }\n\n    inline const DawnTogglesDescriptor* FromCppAPI(const wgpu::DawnTogglesDescriptor* rhs) {\n        return reinterpret_cast<const DawnTogglesDescriptor*>(rhs);\n    }\n\n    inline DawnTogglesDescriptor* FromCppAPI(wgpu::DawnTogglesDescriptor* rhs) {\n        return reinterpret_cast<DawnTogglesDescriptor*>(rhs);\n    }\n\n    inline const WGPUExtent2D* ToAPI(const Extent2D* rhs) {\n        return reinterpret_cast<const WGPUExtent2D*>(rhs);\n    }\n\n    inline WGPUExtent2D* ToAPI(Extent2D* rhs) {\n        return reinterpret_cast<WGPUExtent2D*>(rhs);\n    }\n\n    inline const Extent2D* FromAPI(const WGPUExtent2D* rhs) {\n        return reinterpret_cast<const Extent2D*>(rhs);\n    }\n\n    inline Extent2D* FromAPI(WGPUExtent2D* rhs) {\n        return reinterpret_cast<Extent2D*>(rhs);\n    }\n\n    inline const wgpu::Extent2D* ToCppAPI(const Extent2D* rhs) {\n        return reinterpret_cast<const wgpu::Extent2D*>(rhs);\n    }\n\n    inline wgpu::Extent2D* ToCppAPI(Extent2D* rhs) {\n        return reinterpret_cast<wgpu::Extent2D*>(rhs);\n    }\n\n    inline const Extent2D* FromCppAPI(const wgpu::Extent2D* rhs) {\n        return reinterpret_cast<const Extent2D*>(rhs);\n    }\n\n    inline Extent2D* FromCppAPI(wgpu::Extent2D* rhs) {\n        return reinterpret_cast<Extent2D*>(rhs);\n    }\n\n    inline const WGPUExtent3D* ToAPI(const Extent3D* rhs) {\n        return reinterpret_cast<const WGPUExtent3D*>(rhs);\n    }\n\n    inline WGPUExtent3D* ToAPI(Extent3D* rhs) {\n        return reinterpret_cast<WGPUExtent3D*>(rhs);\n    }\n\n    inline const Extent3D* FromAPI(const WGPUExtent3D* rhs) {\n        return reinterpret_cast<const Extent3D*>(rhs);\n    }\n\n    inline Extent3D* FromAPI(WGPUExtent3D* rhs) {\n        return reinterpret_cast<Extent3D*>(rhs);\n    }\n\n    inline const wgpu::Extent3D* ToCppAPI(const Extent3D* rhs) {\n        return reinterpret_cast<const wgpu::Extent3D*>(rhs);\n    }\n\n    inline wgpu::Extent3D* ToCppAPI(Extent3D* rhs) {\n        return reinterpret_cast<wgpu::Extent3D*>(rhs);\n    }\n\n    inline const Extent3D* FromCppAPI(const wgpu::Extent3D* rhs) {\n        return reinterpret_cast<const Extent3D*>(rhs);\n    }\n\n    inline Extent3D* FromCppAPI(wgpu::Extent3D* rhs) {\n        return reinterpret_cast<Extent3D*>(rhs);\n    }\n\n    inline const WGPUExternalTextureBindingEntry* ToAPI(const ExternalTextureBindingEntry* rhs) {\n        return reinterpret_cast<const WGPUExternalTextureBindingEntry*>(rhs);\n    }\n\n    inline WGPUExternalTextureBindingEntry* ToAPI(ExternalTextureBindingEntry* rhs) {\n        return reinterpret_cast<WGPUExternalTextureBindingEntry*>(rhs);\n    }\n\n    inline const ExternalTextureBindingEntry* FromAPI(const WGPUExternalTextureBindingEntry* rhs) {\n        return reinterpret_cast<const ExternalTextureBindingEntry*>(rhs);\n    }\n\n    inline ExternalTextureBindingEntry* FromAPI(WGPUExternalTextureBindingEntry* rhs) {\n        return reinterpret_cast<ExternalTextureBindingEntry*>(rhs);\n    }\n\n    inline const wgpu::ExternalTextureBindingEntry* ToCppAPI(const ExternalTextureBindingEntry* rhs) {\n        return reinterpret_cast<const wgpu::ExternalTextureBindingEntry*>(rhs);\n    }\n\n    inline wgpu::ExternalTextureBindingEntry* ToCppAPI(ExternalTextureBindingEntry* rhs) {\n        return reinterpret_cast<wgpu::ExternalTextureBindingEntry*>(rhs);\n    }\n\n    inline const ExternalTextureBindingEntry* FromCppAPI(const wgpu::ExternalTextureBindingEntry* rhs) {\n        return reinterpret_cast<const ExternalTextureBindingEntry*>(rhs);\n    }\n\n    inline ExternalTextureBindingEntry* FromCppAPI(wgpu::ExternalTextureBindingEntry* rhs) {\n        return reinterpret_cast<ExternalTextureBindingEntry*>(rhs);\n    }\n\n    inline const WGPUExternalTextureBindingLayout* ToAPI(const ExternalTextureBindingLayout* rhs) {\n        return reinterpret_cast<const WGPUExternalTextureBindingLayout*>(rhs);\n    }\n\n    inline WGPUExternalTextureBindingLayout* ToAPI(ExternalTextureBindingLayout* rhs) {\n        return reinterpret_cast<WGPUExternalTextureBindingLayout*>(rhs);\n    }\n\n    inline const ExternalTextureBindingLayout* FromAPI(const WGPUExternalTextureBindingLayout* rhs) {\n        return reinterpret_cast<const ExternalTextureBindingLayout*>(rhs);\n    }\n\n    inline ExternalTextureBindingLayout* FromAPI(WGPUExternalTextureBindingLayout* rhs) {\n        return reinterpret_cast<ExternalTextureBindingLayout*>(rhs);\n    }\n\n    inline const wgpu::ExternalTextureBindingLayout* ToCppAPI(const ExternalTextureBindingLayout* rhs) {\n        return reinterpret_cast<const wgpu::ExternalTextureBindingLayout*>(rhs);\n    }\n\n    inline wgpu::ExternalTextureBindingLayout* ToCppAPI(ExternalTextureBindingLayout* rhs) {\n        return reinterpret_cast<wgpu::ExternalTextureBindingLayout*>(rhs);\n    }\n\n    inline const ExternalTextureBindingLayout* FromCppAPI(const wgpu::ExternalTextureBindingLayout* rhs) {\n        return reinterpret_cast<const ExternalTextureBindingLayout*>(rhs);\n    }\n\n    inline ExternalTextureBindingLayout* FromCppAPI(wgpu::ExternalTextureBindingLayout* rhs) {\n        return reinterpret_cast<ExternalTextureBindingLayout*>(rhs);\n    }\n\n    inline const WGPUInstanceDescriptor* ToAPI(const InstanceDescriptor* rhs) {\n        return reinterpret_cast<const WGPUInstanceDescriptor*>(rhs);\n    }\n\n    inline WGPUInstanceDescriptor* ToAPI(InstanceDescriptor* rhs) {\n        return reinterpret_cast<WGPUInstanceDescriptor*>(rhs);\n    }\n\n    inline const InstanceDescriptor* FromAPI(const WGPUInstanceDescriptor* rhs) {\n        return reinterpret_cast<const InstanceDescriptor*>(rhs);\n    }\n\n    inline InstanceDescriptor* FromAPI(WGPUInstanceDescriptor* rhs) {\n        return reinterpret_cast<InstanceDescriptor*>(rhs);\n    }\n\n    inline const wgpu::InstanceDescriptor* ToCppAPI(const InstanceDescriptor* rhs) {\n        return reinterpret_cast<const wgpu::InstanceDescriptor*>(rhs);\n    }\n\n    inline wgpu::InstanceDescriptor* ToCppAPI(InstanceDescriptor* rhs) {\n        return reinterpret_cast<wgpu::InstanceDescriptor*>(rhs);\n    }\n\n    inline const InstanceDescriptor* FromCppAPI(const wgpu::InstanceDescriptor* rhs) {\n        return reinterpret_cast<const InstanceDescriptor*>(rhs);\n    }\n\n    inline InstanceDescriptor* FromCppAPI(wgpu::InstanceDescriptor* rhs) {\n        return reinterpret_cast<InstanceDescriptor*>(rhs);\n    }\n\n    inline const WGPULimits* ToAPI(const Limits* rhs) {\n        return reinterpret_cast<const WGPULimits*>(rhs);\n    }\n\n    inline WGPULimits* ToAPI(Limits* rhs) {\n        return reinterpret_cast<WGPULimits*>(rhs);\n    }\n\n    inline const Limits* FromAPI(const WGPULimits* rhs) {\n        return reinterpret_cast<const Limits*>(rhs);\n    }\n\n    inline Limits* FromAPI(WGPULimits* rhs) {\n        return reinterpret_cast<Limits*>(rhs);\n    }\n\n    inline const wgpu::Limits* ToCppAPI(const Limits* rhs) {\n        return reinterpret_cast<const wgpu::Limits*>(rhs);\n    }\n\n    inline wgpu::Limits* ToCppAPI(Limits* rhs) {\n        return reinterpret_cast<wgpu::Limits*>(rhs);\n    }\n\n    inline const Limits* FromCppAPI(const wgpu::Limits* rhs) {\n        return reinterpret_cast<const Limits*>(rhs);\n    }\n\n    inline Limits* FromCppAPI(wgpu::Limits* rhs) {\n        return reinterpret_cast<Limits*>(rhs);\n    }\n\n    inline const WGPUMultisampleState* ToAPI(const MultisampleState* rhs) {\n        return reinterpret_cast<const WGPUMultisampleState*>(rhs);\n    }\n\n    inline WGPUMultisampleState* ToAPI(MultisampleState* rhs) {\n        return reinterpret_cast<WGPUMultisampleState*>(rhs);\n    }\n\n    inline const MultisampleState* FromAPI(const WGPUMultisampleState* rhs) {\n        return reinterpret_cast<const MultisampleState*>(rhs);\n    }\n\n    inline MultisampleState* FromAPI(WGPUMultisampleState* rhs) {\n        return reinterpret_cast<MultisampleState*>(rhs);\n    }\n\n    inline const wgpu::MultisampleState* ToCppAPI(const MultisampleState* rhs) {\n        return reinterpret_cast<const wgpu::MultisampleState*>(rhs);\n    }\n\n    inline wgpu::MultisampleState* ToCppAPI(MultisampleState* rhs) {\n        return reinterpret_cast<wgpu::MultisampleState*>(rhs);\n    }\n\n    inline const MultisampleState* FromCppAPI(const wgpu::MultisampleState* rhs) {\n        return reinterpret_cast<const MultisampleState*>(rhs);\n    }\n\n    inline MultisampleState* FromCppAPI(wgpu::MultisampleState* rhs) {\n        return reinterpret_cast<MultisampleState*>(rhs);\n    }\n\n    inline const WGPUOrigin2D* ToAPI(const Origin2D* rhs) {\n        return reinterpret_cast<const WGPUOrigin2D*>(rhs);\n    }\n\n    inline WGPUOrigin2D* ToAPI(Origin2D* rhs) {\n        return reinterpret_cast<WGPUOrigin2D*>(rhs);\n    }\n\n    inline const Origin2D* FromAPI(const WGPUOrigin2D* rhs) {\n        return reinterpret_cast<const Origin2D*>(rhs);\n    }\n\n    inline Origin2D* FromAPI(WGPUOrigin2D* rhs) {\n        return reinterpret_cast<Origin2D*>(rhs);\n    }\n\n    inline const wgpu::Origin2D* ToCppAPI(const Origin2D* rhs) {\n        return reinterpret_cast<const wgpu::Origin2D*>(rhs);\n    }\n\n    inline wgpu::Origin2D* ToCppAPI(Origin2D* rhs) {\n        return reinterpret_cast<wgpu::Origin2D*>(rhs);\n    }\n\n    inline const Origin2D* FromCppAPI(const wgpu::Origin2D* rhs) {\n        return reinterpret_cast<const Origin2D*>(rhs);\n    }\n\n    inline Origin2D* FromCppAPI(wgpu::Origin2D* rhs) {\n        return reinterpret_cast<Origin2D*>(rhs);\n    }\n\n    inline const WGPUOrigin3D* ToAPI(const Origin3D* rhs) {\n        return reinterpret_cast<const WGPUOrigin3D*>(rhs);\n    }\n\n    inline WGPUOrigin3D* ToAPI(Origin3D* rhs) {\n        return reinterpret_cast<WGPUOrigin3D*>(rhs);\n    }\n\n    inline const Origin3D* FromAPI(const WGPUOrigin3D* rhs) {\n        return reinterpret_cast<const Origin3D*>(rhs);\n    }\n\n    inline Origin3D* FromAPI(WGPUOrigin3D* rhs) {\n        return reinterpret_cast<Origin3D*>(rhs);\n    }\n\n    inline const wgpu::Origin3D* ToCppAPI(const Origin3D* rhs) {\n        return reinterpret_cast<const wgpu::Origin3D*>(rhs);\n    }\n\n    inline wgpu::Origin3D* ToCppAPI(Origin3D* rhs) {\n        return reinterpret_cast<wgpu::Origin3D*>(rhs);\n    }\n\n    inline const Origin3D* FromCppAPI(const wgpu::Origin3D* rhs) {\n        return reinterpret_cast<const Origin3D*>(rhs);\n    }\n\n    inline Origin3D* FromCppAPI(wgpu::Origin3D* rhs) {\n        return reinterpret_cast<Origin3D*>(rhs);\n    }\n\n    inline const WGPUPipelineLayoutDescriptor* ToAPI(const PipelineLayoutDescriptor* rhs) {\n        return reinterpret_cast<const WGPUPipelineLayoutDescriptor*>(rhs);\n    }\n\n    inline WGPUPipelineLayoutDescriptor* ToAPI(PipelineLayoutDescriptor* rhs) {\n        return reinterpret_cast<WGPUPipelineLayoutDescriptor*>(rhs);\n    }\n\n    inline const PipelineLayoutDescriptor* FromAPI(const WGPUPipelineLayoutDescriptor* rhs) {\n        return reinterpret_cast<const PipelineLayoutDescriptor*>(rhs);\n    }\n\n    inline PipelineLayoutDescriptor* FromAPI(WGPUPipelineLayoutDescriptor* rhs) {\n        return reinterpret_cast<PipelineLayoutDescriptor*>(rhs);\n    }\n\n    inline const wgpu::PipelineLayoutDescriptor* ToCppAPI(const PipelineLayoutDescriptor* rhs) {\n        return reinterpret_cast<const wgpu::PipelineLayoutDescriptor*>(rhs);\n    }\n\n    inline wgpu::PipelineLayoutDescriptor* ToCppAPI(PipelineLayoutDescriptor* rhs) {\n        return reinterpret_cast<wgpu::PipelineLayoutDescriptor*>(rhs);\n    }\n\n    inline const PipelineLayoutDescriptor* FromCppAPI(const wgpu::PipelineLayoutDescriptor* rhs) {\n        return reinterpret_cast<const PipelineLayoutDescriptor*>(rhs);\n    }\n\n    inline PipelineLayoutDescriptor* FromCppAPI(wgpu::PipelineLayoutDescriptor* rhs) {\n        return reinterpret_cast<PipelineLayoutDescriptor*>(rhs);\n    }\n\n    inline const WGPUPrimitiveDepthClipControl* ToAPI(const PrimitiveDepthClipControl* rhs) {\n        return reinterpret_cast<const WGPUPrimitiveDepthClipControl*>(rhs);\n    }\n\n    inline WGPUPrimitiveDepthClipControl* ToAPI(PrimitiveDepthClipControl* rhs) {\n        return reinterpret_cast<WGPUPrimitiveDepthClipControl*>(rhs);\n    }\n\n    inline const PrimitiveDepthClipControl* FromAPI(const WGPUPrimitiveDepthClipControl* rhs) {\n        return reinterpret_cast<const PrimitiveDepthClipControl*>(rhs);\n    }\n\n    inline PrimitiveDepthClipControl* FromAPI(WGPUPrimitiveDepthClipControl* rhs) {\n        return reinterpret_cast<PrimitiveDepthClipControl*>(rhs);\n    }\n\n    inline const wgpu::PrimitiveDepthClipControl* ToCppAPI(const PrimitiveDepthClipControl* rhs) {\n        return reinterpret_cast<const wgpu::PrimitiveDepthClipControl*>(rhs);\n    }\n\n    inline wgpu::PrimitiveDepthClipControl* ToCppAPI(PrimitiveDepthClipControl* rhs) {\n        return reinterpret_cast<wgpu::PrimitiveDepthClipControl*>(rhs);\n    }\n\n    inline const PrimitiveDepthClipControl* FromCppAPI(const wgpu::PrimitiveDepthClipControl* rhs) {\n        return reinterpret_cast<const PrimitiveDepthClipControl*>(rhs);\n    }\n\n    inline PrimitiveDepthClipControl* FromCppAPI(wgpu::PrimitiveDepthClipControl* rhs) {\n        return reinterpret_cast<PrimitiveDepthClipControl*>(rhs);\n    }\n\n    inline const WGPUPrimitiveState* ToAPI(const PrimitiveState* rhs) {\n        return reinterpret_cast<const WGPUPrimitiveState*>(rhs);\n    }\n\n    inline WGPUPrimitiveState* ToAPI(PrimitiveState* rhs) {\n        return reinterpret_cast<WGPUPrimitiveState*>(rhs);\n    }\n\n    inline const PrimitiveState* FromAPI(const WGPUPrimitiveState* rhs) {\n        return reinterpret_cast<const PrimitiveState*>(rhs);\n    }\n\n    inline PrimitiveState* FromAPI(WGPUPrimitiveState* rhs) {\n        return reinterpret_cast<PrimitiveState*>(rhs);\n    }\n\n    inline const wgpu::PrimitiveState* ToCppAPI(const PrimitiveState* rhs) {\n        return reinterpret_cast<const wgpu::PrimitiveState*>(rhs);\n    }\n\n    inline wgpu::PrimitiveState* ToCppAPI(PrimitiveState* rhs) {\n        return reinterpret_cast<wgpu::PrimitiveState*>(rhs);\n    }\n\n    inline const PrimitiveState* FromCppAPI(const wgpu::PrimitiveState* rhs) {\n        return reinterpret_cast<const PrimitiveState*>(rhs);\n    }\n\n    inline PrimitiveState* FromCppAPI(wgpu::PrimitiveState* rhs) {\n        return reinterpret_cast<PrimitiveState*>(rhs);\n    }\n\n    inline const WGPUQuerySetDescriptor* ToAPI(const QuerySetDescriptor* rhs) {\n        return reinterpret_cast<const WGPUQuerySetDescriptor*>(rhs);\n    }\n\n    inline WGPUQuerySetDescriptor* ToAPI(QuerySetDescriptor* rhs) {\n        return reinterpret_cast<WGPUQuerySetDescriptor*>(rhs);\n    }\n\n    inline const QuerySetDescriptor* FromAPI(const WGPUQuerySetDescriptor* rhs) {\n        return reinterpret_cast<const QuerySetDescriptor*>(rhs);\n    }\n\n    inline QuerySetDescriptor* FromAPI(WGPUQuerySetDescriptor* rhs) {\n        return reinterpret_cast<QuerySetDescriptor*>(rhs);\n    }\n\n    inline const wgpu::QuerySetDescriptor* ToCppAPI(const QuerySetDescriptor* rhs) {\n        return reinterpret_cast<const wgpu::QuerySetDescriptor*>(rhs);\n    }\n\n    inline wgpu::QuerySetDescriptor* ToCppAPI(QuerySetDescriptor* rhs) {\n        return reinterpret_cast<wgpu::QuerySetDescriptor*>(rhs);\n    }\n\n    inline const QuerySetDescriptor* FromCppAPI(const wgpu::QuerySetDescriptor* rhs) {\n        return reinterpret_cast<const QuerySetDescriptor*>(rhs);\n    }\n\n    inline QuerySetDescriptor* FromCppAPI(wgpu::QuerySetDescriptor* rhs) {\n        return reinterpret_cast<QuerySetDescriptor*>(rhs);\n    }\n\n    inline const WGPUQueueDescriptor* ToAPI(const QueueDescriptor* rhs) {\n        return reinterpret_cast<const WGPUQueueDescriptor*>(rhs);\n    }\n\n    inline WGPUQueueDescriptor* ToAPI(QueueDescriptor* rhs) {\n        return reinterpret_cast<WGPUQueueDescriptor*>(rhs);\n    }\n\n    inline const QueueDescriptor* FromAPI(const WGPUQueueDescriptor* rhs) {\n        return reinterpret_cast<const QueueDescriptor*>(rhs);\n    }\n\n    inline QueueDescriptor* FromAPI(WGPUQueueDescriptor* rhs) {\n        return reinterpret_cast<QueueDescriptor*>(rhs);\n    }\n\n    inline const wgpu::QueueDescriptor* ToCppAPI(const QueueDescriptor* rhs) {\n        return reinterpret_cast<const wgpu::QueueDescriptor*>(rhs);\n    }\n\n    inline wgpu::QueueDescriptor* ToCppAPI(QueueDescriptor* rhs) {\n        return reinterpret_cast<wgpu::QueueDescriptor*>(rhs);\n    }\n\n    inline const QueueDescriptor* FromCppAPI(const wgpu::QueueDescriptor* rhs) {\n        return reinterpret_cast<const QueueDescriptor*>(rhs);\n    }\n\n    inline QueueDescriptor* FromCppAPI(wgpu::QueueDescriptor* rhs) {\n        return reinterpret_cast<QueueDescriptor*>(rhs);\n    }\n\n    inline const WGPURenderBundleDescriptor* ToAPI(const RenderBundleDescriptor* rhs) {\n        return reinterpret_cast<const WGPURenderBundleDescriptor*>(rhs);\n    }\n\n    inline WGPURenderBundleDescriptor* ToAPI(RenderBundleDescriptor* rhs) {\n        return reinterpret_cast<WGPURenderBundleDescriptor*>(rhs);\n    }\n\n    inline const RenderBundleDescriptor* FromAPI(const WGPURenderBundleDescriptor* rhs) {\n        return reinterpret_cast<const RenderBundleDescriptor*>(rhs);\n    }\n\n    inline RenderBundleDescriptor* FromAPI(WGPURenderBundleDescriptor* rhs) {\n        return reinterpret_cast<RenderBundleDescriptor*>(rhs);\n    }\n\n    inline const wgpu::RenderBundleDescriptor* ToCppAPI(const RenderBundleDescriptor* rhs) {\n        return reinterpret_cast<const wgpu::RenderBundleDescriptor*>(rhs);\n    }\n\n    inline wgpu::RenderBundleDescriptor* ToCppAPI(RenderBundleDescriptor* rhs) {\n        return reinterpret_cast<wgpu::RenderBundleDescriptor*>(rhs);\n    }\n\n    inline const RenderBundleDescriptor* FromCppAPI(const wgpu::RenderBundleDescriptor* rhs) {\n        return reinterpret_cast<const RenderBundleDescriptor*>(rhs);\n    }\n\n    inline RenderBundleDescriptor* FromCppAPI(wgpu::RenderBundleDescriptor* rhs) {\n        return reinterpret_cast<RenderBundleDescriptor*>(rhs);\n    }\n\n    inline const WGPURenderBundleEncoderDescriptor* ToAPI(const RenderBundleEncoderDescriptor* rhs) {\n        return reinterpret_cast<const WGPURenderBundleEncoderDescriptor*>(rhs);\n    }\n\n    inline WGPURenderBundleEncoderDescriptor* ToAPI(RenderBundleEncoderDescriptor* rhs) {\n        return reinterpret_cast<WGPURenderBundleEncoderDescriptor*>(rhs);\n    }\n\n    inline const RenderBundleEncoderDescriptor* FromAPI(const WGPURenderBundleEncoderDescriptor* rhs) {\n        return reinterpret_cast<const RenderBundleEncoderDescriptor*>(rhs);\n    }\n\n    inline RenderBundleEncoderDescriptor* FromAPI(WGPURenderBundleEncoderDescriptor* rhs) {\n        return reinterpret_cast<RenderBundleEncoderDescriptor*>(rhs);\n    }\n\n    inline const wgpu::RenderBundleEncoderDescriptor* ToCppAPI(const RenderBundleEncoderDescriptor* rhs) {\n        return reinterpret_cast<const wgpu::RenderBundleEncoderDescriptor*>(rhs);\n    }\n\n    inline wgpu::RenderBundleEncoderDescriptor* ToCppAPI(RenderBundleEncoderDescriptor* rhs) {\n        return reinterpret_cast<wgpu::RenderBundleEncoderDescriptor*>(rhs);\n    }\n\n    inline const RenderBundleEncoderDescriptor* FromCppAPI(const wgpu::RenderBundleEncoderDescriptor* rhs) {\n        return reinterpret_cast<const RenderBundleEncoderDescriptor*>(rhs);\n    }\n\n    inline RenderBundleEncoderDescriptor* FromCppAPI(wgpu::RenderBundleEncoderDescriptor* rhs) {\n        return reinterpret_cast<RenderBundleEncoderDescriptor*>(rhs);\n    }\n\n    inline const WGPURenderPassDepthStencilAttachment* ToAPI(const RenderPassDepthStencilAttachment* rhs) {\n        return reinterpret_cast<const WGPURenderPassDepthStencilAttachment*>(rhs);\n    }\n\n    inline WGPURenderPassDepthStencilAttachment* ToAPI(RenderPassDepthStencilAttachment* rhs) {\n        return reinterpret_cast<WGPURenderPassDepthStencilAttachment*>(rhs);\n    }\n\n    inline const RenderPassDepthStencilAttachment* FromAPI(const WGPURenderPassDepthStencilAttachment* rhs) {\n        return reinterpret_cast<const RenderPassDepthStencilAttachment*>(rhs);\n    }\n\n    inline RenderPassDepthStencilAttachment* FromAPI(WGPURenderPassDepthStencilAttachment* rhs) {\n        return reinterpret_cast<RenderPassDepthStencilAttachment*>(rhs);\n    }\n\n    inline const wgpu::RenderPassDepthStencilAttachment* ToCppAPI(const RenderPassDepthStencilAttachment* rhs) {\n        return reinterpret_cast<const wgpu::RenderPassDepthStencilAttachment*>(rhs);\n    }\n\n    inline wgpu::RenderPassDepthStencilAttachment* ToCppAPI(RenderPassDepthStencilAttachment* rhs) {\n        return reinterpret_cast<wgpu::RenderPassDepthStencilAttachment*>(rhs);\n    }\n\n    inline const RenderPassDepthStencilAttachment* FromCppAPI(const wgpu::RenderPassDepthStencilAttachment* rhs) {\n        return reinterpret_cast<const RenderPassDepthStencilAttachment*>(rhs);\n    }\n\n    inline RenderPassDepthStencilAttachment* FromCppAPI(wgpu::RenderPassDepthStencilAttachment* rhs) {\n        return reinterpret_cast<RenderPassDepthStencilAttachment*>(rhs);\n    }\n\n    inline const WGPURenderPassDescriptorMaxDrawCount* ToAPI(const RenderPassDescriptorMaxDrawCount* rhs) {\n        return reinterpret_cast<const WGPURenderPassDescriptorMaxDrawCount*>(rhs);\n    }\n\n    inline WGPURenderPassDescriptorMaxDrawCount* ToAPI(RenderPassDescriptorMaxDrawCount* rhs) {\n        return reinterpret_cast<WGPURenderPassDescriptorMaxDrawCount*>(rhs);\n    }\n\n    inline const RenderPassDescriptorMaxDrawCount* FromAPI(const WGPURenderPassDescriptorMaxDrawCount* rhs) {\n        return reinterpret_cast<const RenderPassDescriptorMaxDrawCount*>(rhs);\n    }\n\n    inline RenderPassDescriptorMaxDrawCount* FromAPI(WGPURenderPassDescriptorMaxDrawCount* rhs) {\n        return reinterpret_cast<RenderPassDescriptorMaxDrawCount*>(rhs);\n    }\n\n    inline const wgpu::RenderPassDescriptorMaxDrawCount* ToCppAPI(const RenderPassDescriptorMaxDrawCount* rhs) {\n        return reinterpret_cast<const wgpu::RenderPassDescriptorMaxDrawCount*>(rhs);\n    }\n\n    inline wgpu::RenderPassDescriptorMaxDrawCount* ToCppAPI(RenderPassDescriptorMaxDrawCount* rhs) {\n        return reinterpret_cast<wgpu::RenderPassDescriptorMaxDrawCount*>(rhs);\n    }\n\n    inline const RenderPassDescriptorMaxDrawCount* FromCppAPI(const wgpu::RenderPassDescriptorMaxDrawCount* rhs) {\n        return reinterpret_cast<const RenderPassDescriptorMaxDrawCount*>(rhs);\n    }\n\n    inline RenderPassDescriptorMaxDrawCount* FromCppAPI(wgpu::RenderPassDescriptorMaxDrawCount* rhs) {\n        return reinterpret_cast<RenderPassDescriptorMaxDrawCount*>(rhs);\n    }\n\n    inline const WGPURenderPassTimestampWrite* ToAPI(const RenderPassTimestampWrite* rhs) {\n        return reinterpret_cast<const WGPURenderPassTimestampWrite*>(rhs);\n    }\n\n    inline WGPURenderPassTimestampWrite* ToAPI(RenderPassTimestampWrite* rhs) {\n        return reinterpret_cast<WGPURenderPassTimestampWrite*>(rhs);\n    }\n\n    inline const RenderPassTimestampWrite* FromAPI(const WGPURenderPassTimestampWrite* rhs) {\n        return reinterpret_cast<const RenderPassTimestampWrite*>(rhs);\n    }\n\n    inline RenderPassTimestampWrite* FromAPI(WGPURenderPassTimestampWrite* rhs) {\n        return reinterpret_cast<RenderPassTimestampWrite*>(rhs);\n    }\n\n    inline const wgpu::RenderPassTimestampWrite* ToCppAPI(const RenderPassTimestampWrite* rhs) {\n        return reinterpret_cast<const wgpu::RenderPassTimestampWrite*>(rhs);\n    }\n\n    inline wgpu::RenderPassTimestampWrite* ToCppAPI(RenderPassTimestampWrite* rhs) {\n        return reinterpret_cast<wgpu::RenderPassTimestampWrite*>(rhs);\n    }\n\n    inline const RenderPassTimestampWrite* FromCppAPI(const wgpu::RenderPassTimestampWrite* rhs) {\n        return reinterpret_cast<const RenderPassTimestampWrite*>(rhs);\n    }\n\n    inline RenderPassTimestampWrite* FromCppAPI(wgpu::RenderPassTimestampWrite* rhs) {\n        return reinterpret_cast<RenderPassTimestampWrite*>(rhs);\n    }\n\n    inline const WGPURequestAdapterOptions* ToAPI(const RequestAdapterOptions* rhs) {\n        return reinterpret_cast<const WGPURequestAdapterOptions*>(rhs);\n    }\n\n    inline WGPURequestAdapterOptions* ToAPI(RequestAdapterOptions* rhs) {\n        return reinterpret_cast<WGPURequestAdapterOptions*>(rhs);\n    }\n\n    inline const RequestAdapterOptions* FromAPI(const WGPURequestAdapterOptions* rhs) {\n        return reinterpret_cast<const RequestAdapterOptions*>(rhs);\n    }\n\n    inline RequestAdapterOptions* FromAPI(WGPURequestAdapterOptions* rhs) {\n        return reinterpret_cast<RequestAdapterOptions*>(rhs);\n    }\n\n    inline const wgpu::RequestAdapterOptions* ToCppAPI(const RequestAdapterOptions* rhs) {\n        return reinterpret_cast<const wgpu::RequestAdapterOptions*>(rhs);\n    }\n\n    inline wgpu::RequestAdapterOptions* ToCppAPI(RequestAdapterOptions* rhs) {\n        return reinterpret_cast<wgpu::RequestAdapterOptions*>(rhs);\n    }\n\n    inline const RequestAdapterOptions* FromCppAPI(const wgpu::RequestAdapterOptions* rhs) {\n        return reinterpret_cast<const RequestAdapterOptions*>(rhs);\n    }\n\n    inline RequestAdapterOptions* FromCppAPI(wgpu::RequestAdapterOptions* rhs) {\n        return reinterpret_cast<RequestAdapterOptions*>(rhs);\n    }\n\n    inline const WGPUSamplerBindingLayout* ToAPI(const SamplerBindingLayout* rhs) {\n        return reinterpret_cast<const WGPUSamplerBindingLayout*>(rhs);\n    }\n\n    inline WGPUSamplerBindingLayout* ToAPI(SamplerBindingLayout* rhs) {\n        return reinterpret_cast<WGPUSamplerBindingLayout*>(rhs);\n    }\n\n    inline const SamplerBindingLayout* FromAPI(const WGPUSamplerBindingLayout* rhs) {\n        return reinterpret_cast<const SamplerBindingLayout*>(rhs);\n    }\n\n    inline SamplerBindingLayout* FromAPI(WGPUSamplerBindingLayout* rhs) {\n        return reinterpret_cast<SamplerBindingLayout*>(rhs);\n    }\n\n    inline const wgpu::SamplerBindingLayout* ToCppAPI(const SamplerBindingLayout* rhs) {\n        return reinterpret_cast<const wgpu::SamplerBindingLayout*>(rhs);\n    }\n\n    inline wgpu::SamplerBindingLayout* ToCppAPI(SamplerBindingLayout* rhs) {\n        return reinterpret_cast<wgpu::SamplerBindingLayout*>(rhs);\n    }\n\n    inline const SamplerBindingLayout* FromCppAPI(const wgpu::SamplerBindingLayout* rhs) {\n        return reinterpret_cast<const SamplerBindingLayout*>(rhs);\n    }\n\n    inline SamplerBindingLayout* FromCppAPI(wgpu::SamplerBindingLayout* rhs) {\n        return reinterpret_cast<SamplerBindingLayout*>(rhs);\n    }\n\n    inline const WGPUSamplerDescriptor* ToAPI(const SamplerDescriptor* rhs) {\n        return reinterpret_cast<const WGPUSamplerDescriptor*>(rhs);\n    }\n\n    inline WGPUSamplerDescriptor* ToAPI(SamplerDescriptor* rhs) {\n        return reinterpret_cast<WGPUSamplerDescriptor*>(rhs);\n    }\n\n    inline const SamplerDescriptor* FromAPI(const WGPUSamplerDescriptor* rhs) {\n        return reinterpret_cast<const SamplerDescriptor*>(rhs);\n    }\n\n    inline SamplerDescriptor* FromAPI(WGPUSamplerDescriptor* rhs) {\n        return reinterpret_cast<SamplerDescriptor*>(rhs);\n    }\n\n    inline const wgpu::SamplerDescriptor* ToCppAPI(const SamplerDescriptor* rhs) {\n        return reinterpret_cast<const wgpu::SamplerDescriptor*>(rhs);\n    }\n\n    inline wgpu::SamplerDescriptor* ToCppAPI(SamplerDescriptor* rhs) {\n        return reinterpret_cast<wgpu::SamplerDescriptor*>(rhs);\n    }\n\n    inline const SamplerDescriptor* FromCppAPI(const wgpu::SamplerDescriptor* rhs) {\n        return reinterpret_cast<const SamplerDescriptor*>(rhs);\n    }\n\n    inline SamplerDescriptor* FromCppAPI(wgpu::SamplerDescriptor* rhs) {\n        return reinterpret_cast<SamplerDescriptor*>(rhs);\n    }\n\n    inline const WGPUShaderModuleDescriptor* ToAPI(const ShaderModuleDescriptor* rhs) {\n        return reinterpret_cast<const WGPUShaderModuleDescriptor*>(rhs);\n    }\n\n    inline WGPUShaderModuleDescriptor* ToAPI(ShaderModuleDescriptor* rhs) {\n        return reinterpret_cast<WGPUShaderModuleDescriptor*>(rhs);\n    }\n\n    inline const ShaderModuleDescriptor* FromAPI(const WGPUShaderModuleDescriptor* rhs) {\n        return reinterpret_cast<const ShaderModuleDescriptor*>(rhs);\n    }\n\n    inline ShaderModuleDescriptor* FromAPI(WGPUShaderModuleDescriptor* rhs) {\n        return reinterpret_cast<ShaderModuleDescriptor*>(rhs);\n    }\n\n    inline const wgpu::ShaderModuleDescriptor* ToCppAPI(const ShaderModuleDescriptor* rhs) {\n        return reinterpret_cast<const wgpu::ShaderModuleDescriptor*>(rhs);\n    }\n\n    inline wgpu::ShaderModuleDescriptor* ToCppAPI(ShaderModuleDescriptor* rhs) {\n        return reinterpret_cast<wgpu::ShaderModuleDescriptor*>(rhs);\n    }\n\n    inline const ShaderModuleDescriptor* FromCppAPI(const wgpu::ShaderModuleDescriptor* rhs) {\n        return reinterpret_cast<const ShaderModuleDescriptor*>(rhs);\n    }\n\n    inline ShaderModuleDescriptor* FromCppAPI(wgpu::ShaderModuleDescriptor* rhs) {\n        return reinterpret_cast<ShaderModuleDescriptor*>(rhs);\n    }\n\n    inline const WGPUShaderModuleSPIRVDescriptor* ToAPI(const ShaderModuleSPIRVDescriptor* rhs) {\n        return reinterpret_cast<const WGPUShaderModuleSPIRVDescriptor*>(rhs);\n    }\n\n    inline WGPUShaderModuleSPIRVDescriptor* ToAPI(ShaderModuleSPIRVDescriptor* rhs) {\n        return reinterpret_cast<WGPUShaderModuleSPIRVDescriptor*>(rhs);\n    }\n\n    inline const ShaderModuleSPIRVDescriptor* FromAPI(const WGPUShaderModuleSPIRVDescriptor* rhs) {\n        return reinterpret_cast<const ShaderModuleSPIRVDescriptor*>(rhs);\n    }\n\n    inline ShaderModuleSPIRVDescriptor* FromAPI(WGPUShaderModuleSPIRVDescriptor* rhs) {\n        return reinterpret_cast<ShaderModuleSPIRVDescriptor*>(rhs);\n    }\n\n    inline const wgpu::ShaderModuleSPIRVDescriptor* ToCppAPI(const ShaderModuleSPIRVDescriptor* rhs) {\n        return reinterpret_cast<const wgpu::ShaderModuleSPIRVDescriptor*>(rhs);\n    }\n\n    inline wgpu::ShaderModuleSPIRVDescriptor* ToCppAPI(ShaderModuleSPIRVDescriptor* rhs) {\n        return reinterpret_cast<wgpu::ShaderModuleSPIRVDescriptor*>(rhs);\n    }\n\n    inline const ShaderModuleSPIRVDescriptor* FromCppAPI(const wgpu::ShaderModuleSPIRVDescriptor* rhs) {\n        return reinterpret_cast<const ShaderModuleSPIRVDescriptor*>(rhs);\n    }\n\n    inline ShaderModuleSPIRVDescriptor* FromCppAPI(wgpu::ShaderModuleSPIRVDescriptor* rhs) {\n        return reinterpret_cast<ShaderModuleSPIRVDescriptor*>(rhs);\n    }\n\n    inline const WGPUShaderModuleWGSLDescriptor* ToAPI(const ShaderModuleWGSLDescriptor* rhs) {\n        return reinterpret_cast<const WGPUShaderModuleWGSLDescriptor*>(rhs);\n    }\n\n    inline WGPUShaderModuleWGSLDescriptor* ToAPI(ShaderModuleWGSLDescriptor* rhs) {\n        return reinterpret_cast<WGPUShaderModuleWGSLDescriptor*>(rhs);\n    }\n\n    inline const ShaderModuleWGSLDescriptor* FromAPI(const WGPUShaderModuleWGSLDescriptor* rhs) {\n        return reinterpret_cast<const ShaderModuleWGSLDescriptor*>(rhs);\n    }\n\n    inline ShaderModuleWGSLDescriptor* FromAPI(WGPUShaderModuleWGSLDescriptor* rhs) {\n        return reinterpret_cast<ShaderModuleWGSLDescriptor*>(rhs);\n    }\n\n    inline const wgpu::ShaderModuleWGSLDescriptor* ToCppAPI(const ShaderModuleWGSLDescriptor* rhs) {\n        return reinterpret_cast<const wgpu::ShaderModuleWGSLDescriptor*>(rhs);\n    }\n\n    inline wgpu::ShaderModuleWGSLDescriptor* ToCppAPI(ShaderModuleWGSLDescriptor* rhs) {\n        return reinterpret_cast<wgpu::ShaderModuleWGSLDescriptor*>(rhs);\n    }\n\n    inline const ShaderModuleWGSLDescriptor* FromCppAPI(const wgpu::ShaderModuleWGSLDescriptor* rhs) {\n        return reinterpret_cast<const ShaderModuleWGSLDescriptor*>(rhs);\n    }\n\n    inline ShaderModuleWGSLDescriptor* FromCppAPI(wgpu::ShaderModuleWGSLDescriptor* rhs) {\n        return reinterpret_cast<ShaderModuleWGSLDescriptor*>(rhs);\n    }\n\n    inline const WGPUStencilFaceState* ToAPI(const StencilFaceState* rhs) {\n        return reinterpret_cast<const WGPUStencilFaceState*>(rhs);\n    }\n\n    inline WGPUStencilFaceState* ToAPI(StencilFaceState* rhs) {\n        return reinterpret_cast<WGPUStencilFaceState*>(rhs);\n    }\n\n    inline const StencilFaceState* FromAPI(const WGPUStencilFaceState* rhs) {\n        return reinterpret_cast<const StencilFaceState*>(rhs);\n    }\n\n    inline StencilFaceState* FromAPI(WGPUStencilFaceState* rhs) {\n        return reinterpret_cast<StencilFaceState*>(rhs);\n    }\n\n    inline const wgpu::StencilFaceState* ToCppAPI(const StencilFaceState* rhs) {\n        return reinterpret_cast<const wgpu::StencilFaceState*>(rhs);\n    }\n\n    inline wgpu::StencilFaceState* ToCppAPI(StencilFaceState* rhs) {\n        return reinterpret_cast<wgpu::StencilFaceState*>(rhs);\n    }\n\n    inline const StencilFaceState* FromCppAPI(const wgpu::StencilFaceState* rhs) {\n        return reinterpret_cast<const StencilFaceState*>(rhs);\n    }\n\n    inline StencilFaceState* FromCppAPI(wgpu::StencilFaceState* rhs) {\n        return reinterpret_cast<StencilFaceState*>(rhs);\n    }\n\n    inline const WGPUStorageTextureBindingLayout* ToAPI(const StorageTextureBindingLayout* rhs) {\n        return reinterpret_cast<const WGPUStorageTextureBindingLayout*>(rhs);\n    }\n\n    inline WGPUStorageTextureBindingLayout* ToAPI(StorageTextureBindingLayout* rhs) {\n        return reinterpret_cast<WGPUStorageTextureBindingLayout*>(rhs);\n    }\n\n    inline const StorageTextureBindingLayout* FromAPI(const WGPUStorageTextureBindingLayout* rhs) {\n        return reinterpret_cast<const StorageTextureBindingLayout*>(rhs);\n    }\n\n    inline StorageTextureBindingLayout* FromAPI(WGPUStorageTextureBindingLayout* rhs) {\n        return reinterpret_cast<StorageTextureBindingLayout*>(rhs);\n    }\n\n    inline const wgpu::StorageTextureBindingLayout* ToCppAPI(const StorageTextureBindingLayout* rhs) {\n        return reinterpret_cast<const wgpu::StorageTextureBindingLayout*>(rhs);\n    }\n\n    inline wgpu::StorageTextureBindingLayout* ToCppAPI(StorageTextureBindingLayout* rhs) {\n        return reinterpret_cast<wgpu::StorageTextureBindingLayout*>(rhs);\n    }\n\n    inline const StorageTextureBindingLayout* FromCppAPI(const wgpu::StorageTextureBindingLayout* rhs) {\n        return reinterpret_cast<const StorageTextureBindingLayout*>(rhs);\n    }\n\n    inline StorageTextureBindingLayout* FromCppAPI(wgpu::StorageTextureBindingLayout* rhs) {\n        return reinterpret_cast<StorageTextureBindingLayout*>(rhs);\n    }\n\n    inline const WGPUSurfaceDescriptor* ToAPI(const SurfaceDescriptor* rhs) {\n        return reinterpret_cast<const WGPUSurfaceDescriptor*>(rhs);\n    }\n\n    inline WGPUSurfaceDescriptor* ToAPI(SurfaceDescriptor* rhs) {\n        return reinterpret_cast<WGPUSurfaceDescriptor*>(rhs);\n    }\n\n    inline const SurfaceDescriptor* FromAPI(const WGPUSurfaceDescriptor* rhs) {\n        return reinterpret_cast<const SurfaceDescriptor*>(rhs);\n    }\n\n    inline SurfaceDescriptor* FromAPI(WGPUSurfaceDescriptor* rhs) {\n        return reinterpret_cast<SurfaceDescriptor*>(rhs);\n    }\n\n    inline const wgpu::SurfaceDescriptor* ToCppAPI(const SurfaceDescriptor* rhs) {\n        return reinterpret_cast<const wgpu::SurfaceDescriptor*>(rhs);\n    }\n\n    inline wgpu::SurfaceDescriptor* ToCppAPI(SurfaceDescriptor* rhs) {\n        return reinterpret_cast<wgpu::SurfaceDescriptor*>(rhs);\n    }\n\n    inline const SurfaceDescriptor* FromCppAPI(const wgpu::SurfaceDescriptor* rhs) {\n        return reinterpret_cast<const SurfaceDescriptor*>(rhs);\n    }\n\n    inline SurfaceDescriptor* FromCppAPI(wgpu::SurfaceDescriptor* rhs) {\n        return reinterpret_cast<SurfaceDescriptor*>(rhs);\n    }\n\n    inline const WGPUSurfaceDescriptorFromAndroidNativeWindow* ToAPI(const SurfaceDescriptorFromAndroidNativeWindow* rhs) {\n        return reinterpret_cast<const WGPUSurfaceDescriptorFromAndroidNativeWindow*>(rhs);\n    }\n\n    inline WGPUSurfaceDescriptorFromAndroidNativeWindow* ToAPI(SurfaceDescriptorFromAndroidNativeWindow* rhs) {\n        return reinterpret_cast<WGPUSurfaceDescriptorFromAndroidNativeWindow*>(rhs);\n    }\n\n    inline const SurfaceDescriptorFromAndroidNativeWindow* FromAPI(const WGPUSurfaceDescriptorFromAndroidNativeWindow* rhs) {\n        return reinterpret_cast<const SurfaceDescriptorFromAndroidNativeWindow*>(rhs);\n    }\n\n    inline SurfaceDescriptorFromAndroidNativeWindow* FromAPI(WGPUSurfaceDescriptorFromAndroidNativeWindow* rhs) {\n        return reinterpret_cast<SurfaceDescriptorFromAndroidNativeWindow*>(rhs);\n    }\n\n    inline const wgpu::SurfaceDescriptorFromAndroidNativeWindow* ToCppAPI(const SurfaceDescriptorFromAndroidNativeWindow* rhs) {\n        return reinterpret_cast<const wgpu::SurfaceDescriptorFromAndroidNativeWindow*>(rhs);\n    }\n\n    inline wgpu::SurfaceDescriptorFromAndroidNativeWindow* ToCppAPI(SurfaceDescriptorFromAndroidNativeWindow* rhs) {\n        return reinterpret_cast<wgpu::SurfaceDescriptorFromAndroidNativeWindow*>(rhs);\n    }\n\n    inline const SurfaceDescriptorFromAndroidNativeWindow* FromCppAPI(const wgpu::SurfaceDescriptorFromAndroidNativeWindow* rhs) {\n        return reinterpret_cast<const SurfaceDescriptorFromAndroidNativeWindow*>(rhs);\n    }\n\n    inline SurfaceDescriptorFromAndroidNativeWindow* FromCppAPI(wgpu::SurfaceDescriptorFromAndroidNativeWindow* rhs) {\n        return reinterpret_cast<SurfaceDescriptorFromAndroidNativeWindow*>(rhs);\n    }\n\n    inline const WGPUSurfaceDescriptorFromCanvasHTMLSelector* ToAPI(const SurfaceDescriptorFromCanvasHTMLSelector* rhs) {\n        return reinterpret_cast<const WGPUSurfaceDescriptorFromCanvasHTMLSelector*>(rhs);\n    }\n\n    inline WGPUSurfaceDescriptorFromCanvasHTMLSelector* ToAPI(SurfaceDescriptorFromCanvasHTMLSelector* rhs) {\n        return reinterpret_cast<WGPUSurfaceDescriptorFromCanvasHTMLSelector*>(rhs);\n    }\n\n    inline const SurfaceDescriptorFromCanvasHTMLSelector* FromAPI(const WGPUSurfaceDescriptorFromCanvasHTMLSelector* rhs) {\n        return reinterpret_cast<const SurfaceDescriptorFromCanvasHTMLSelector*>(rhs);\n    }\n\n    inline SurfaceDescriptorFromCanvasHTMLSelector* FromAPI(WGPUSurfaceDescriptorFromCanvasHTMLSelector* rhs) {\n        return reinterpret_cast<SurfaceDescriptorFromCanvasHTMLSelector*>(rhs);\n    }\n\n    inline const wgpu::SurfaceDescriptorFromCanvasHTMLSelector* ToCppAPI(const SurfaceDescriptorFromCanvasHTMLSelector* rhs) {\n        return reinterpret_cast<const wgpu::SurfaceDescriptorFromCanvasHTMLSelector*>(rhs);\n    }\n\n    inline wgpu::SurfaceDescriptorFromCanvasHTMLSelector* ToCppAPI(SurfaceDescriptorFromCanvasHTMLSelector* rhs) {\n        return reinterpret_cast<wgpu::SurfaceDescriptorFromCanvasHTMLSelector*>(rhs);\n    }\n\n    inline const SurfaceDescriptorFromCanvasHTMLSelector* FromCppAPI(const wgpu::SurfaceDescriptorFromCanvasHTMLSelector* rhs) {\n        return reinterpret_cast<const SurfaceDescriptorFromCanvasHTMLSelector*>(rhs);\n    }\n\n    inline SurfaceDescriptorFromCanvasHTMLSelector* FromCppAPI(wgpu::SurfaceDescriptorFromCanvasHTMLSelector* rhs) {\n        return reinterpret_cast<SurfaceDescriptorFromCanvasHTMLSelector*>(rhs);\n    }\n\n    inline const WGPUSurfaceDescriptorFromMetalLayer* ToAPI(const SurfaceDescriptorFromMetalLayer* rhs) {\n        return reinterpret_cast<const WGPUSurfaceDescriptorFromMetalLayer*>(rhs);\n    }\n\n    inline WGPUSurfaceDescriptorFromMetalLayer* ToAPI(SurfaceDescriptorFromMetalLayer* rhs) {\n        return reinterpret_cast<WGPUSurfaceDescriptorFromMetalLayer*>(rhs);\n    }\n\n    inline const SurfaceDescriptorFromMetalLayer* FromAPI(const WGPUSurfaceDescriptorFromMetalLayer* rhs) {\n        return reinterpret_cast<const SurfaceDescriptorFromMetalLayer*>(rhs);\n    }\n\n    inline SurfaceDescriptorFromMetalLayer* FromAPI(WGPUSurfaceDescriptorFromMetalLayer* rhs) {\n        return reinterpret_cast<SurfaceDescriptorFromMetalLayer*>(rhs);\n    }\n\n    inline const wgpu::SurfaceDescriptorFromMetalLayer* ToCppAPI(const SurfaceDescriptorFromMetalLayer* rhs) {\n        return reinterpret_cast<const wgpu::SurfaceDescriptorFromMetalLayer*>(rhs);\n    }\n\n    inline wgpu::SurfaceDescriptorFromMetalLayer* ToCppAPI(SurfaceDescriptorFromMetalLayer* rhs) {\n        return reinterpret_cast<wgpu::SurfaceDescriptorFromMetalLayer*>(rhs);\n    }\n\n    inline const SurfaceDescriptorFromMetalLayer* FromCppAPI(const wgpu::SurfaceDescriptorFromMetalLayer* rhs) {\n        return reinterpret_cast<const SurfaceDescriptorFromMetalLayer*>(rhs);\n    }\n\n    inline SurfaceDescriptorFromMetalLayer* FromCppAPI(wgpu::SurfaceDescriptorFromMetalLayer* rhs) {\n        return reinterpret_cast<SurfaceDescriptorFromMetalLayer*>(rhs);\n    }\n\n    inline const WGPUSurfaceDescriptorFromWaylandSurface* ToAPI(const SurfaceDescriptorFromWaylandSurface* rhs) {\n        return reinterpret_cast<const WGPUSurfaceDescriptorFromWaylandSurface*>(rhs);\n    }\n\n    inline WGPUSurfaceDescriptorFromWaylandSurface* ToAPI(SurfaceDescriptorFromWaylandSurface* rhs) {\n        return reinterpret_cast<WGPUSurfaceDescriptorFromWaylandSurface*>(rhs);\n    }\n\n    inline const SurfaceDescriptorFromWaylandSurface* FromAPI(const WGPUSurfaceDescriptorFromWaylandSurface* rhs) {\n        return reinterpret_cast<const SurfaceDescriptorFromWaylandSurface*>(rhs);\n    }\n\n    inline SurfaceDescriptorFromWaylandSurface* FromAPI(WGPUSurfaceDescriptorFromWaylandSurface* rhs) {\n        return reinterpret_cast<SurfaceDescriptorFromWaylandSurface*>(rhs);\n    }\n\n    inline const wgpu::SurfaceDescriptorFromWaylandSurface* ToCppAPI(const SurfaceDescriptorFromWaylandSurface* rhs) {\n        return reinterpret_cast<const wgpu::SurfaceDescriptorFromWaylandSurface*>(rhs);\n    }\n\n    inline wgpu::SurfaceDescriptorFromWaylandSurface* ToCppAPI(SurfaceDescriptorFromWaylandSurface* rhs) {\n        return reinterpret_cast<wgpu::SurfaceDescriptorFromWaylandSurface*>(rhs);\n    }\n\n    inline const SurfaceDescriptorFromWaylandSurface* FromCppAPI(const wgpu::SurfaceDescriptorFromWaylandSurface* rhs) {\n        return reinterpret_cast<const SurfaceDescriptorFromWaylandSurface*>(rhs);\n    }\n\n    inline SurfaceDescriptorFromWaylandSurface* FromCppAPI(wgpu::SurfaceDescriptorFromWaylandSurface* rhs) {\n        return reinterpret_cast<SurfaceDescriptorFromWaylandSurface*>(rhs);\n    }\n\n    inline const WGPUSurfaceDescriptorFromWindowsCoreWindow* ToAPI(const SurfaceDescriptorFromWindowsCoreWindow* rhs) {\n        return reinterpret_cast<const WGPUSurfaceDescriptorFromWindowsCoreWindow*>(rhs);\n    }\n\n    inline WGPUSurfaceDescriptorFromWindowsCoreWindow* ToAPI(SurfaceDescriptorFromWindowsCoreWindow* rhs) {\n        return reinterpret_cast<WGPUSurfaceDescriptorFromWindowsCoreWindow*>(rhs);\n    }\n\n    inline const SurfaceDescriptorFromWindowsCoreWindow* FromAPI(const WGPUSurfaceDescriptorFromWindowsCoreWindow* rhs) {\n        return reinterpret_cast<const SurfaceDescriptorFromWindowsCoreWindow*>(rhs);\n    }\n\n    inline SurfaceDescriptorFromWindowsCoreWindow* FromAPI(WGPUSurfaceDescriptorFromWindowsCoreWindow* rhs) {\n        return reinterpret_cast<SurfaceDescriptorFromWindowsCoreWindow*>(rhs);\n    }\n\n    inline const wgpu::SurfaceDescriptorFromWindowsCoreWindow* ToCppAPI(const SurfaceDescriptorFromWindowsCoreWindow* rhs) {\n        return reinterpret_cast<const wgpu::SurfaceDescriptorFromWindowsCoreWindow*>(rhs);\n    }\n\n    inline wgpu::SurfaceDescriptorFromWindowsCoreWindow* ToCppAPI(SurfaceDescriptorFromWindowsCoreWindow* rhs) {\n        return reinterpret_cast<wgpu::SurfaceDescriptorFromWindowsCoreWindow*>(rhs);\n    }\n\n    inline const SurfaceDescriptorFromWindowsCoreWindow* FromCppAPI(const wgpu::SurfaceDescriptorFromWindowsCoreWindow* rhs) {\n        return reinterpret_cast<const SurfaceDescriptorFromWindowsCoreWindow*>(rhs);\n    }\n\n    inline SurfaceDescriptorFromWindowsCoreWindow* FromCppAPI(wgpu::SurfaceDescriptorFromWindowsCoreWindow* rhs) {\n        return reinterpret_cast<SurfaceDescriptorFromWindowsCoreWindow*>(rhs);\n    }\n\n    inline const WGPUSurfaceDescriptorFromWindowsHWND* ToAPI(const SurfaceDescriptorFromWindowsHWND* rhs) {\n        return reinterpret_cast<const WGPUSurfaceDescriptorFromWindowsHWND*>(rhs);\n    }\n\n    inline WGPUSurfaceDescriptorFromWindowsHWND* ToAPI(SurfaceDescriptorFromWindowsHWND* rhs) {\n        return reinterpret_cast<WGPUSurfaceDescriptorFromWindowsHWND*>(rhs);\n    }\n\n    inline const SurfaceDescriptorFromWindowsHWND* FromAPI(const WGPUSurfaceDescriptorFromWindowsHWND* rhs) {\n        return reinterpret_cast<const SurfaceDescriptorFromWindowsHWND*>(rhs);\n    }\n\n    inline SurfaceDescriptorFromWindowsHWND* FromAPI(WGPUSurfaceDescriptorFromWindowsHWND* rhs) {\n        return reinterpret_cast<SurfaceDescriptorFromWindowsHWND*>(rhs);\n    }\n\n    inline const wgpu::SurfaceDescriptorFromWindowsHWND* ToCppAPI(const SurfaceDescriptorFromWindowsHWND* rhs) {\n        return reinterpret_cast<const wgpu::SurfaceDescriptorFromWindowsHWND*>(rhs);\n    }\n\n    inline wgpu::SurfaceDescriptorFromWindowsHWND* ToCppAPI(SurfaceDescriptorFromWindowsHWND* rhs) {\n        return reinterpret_cast<wgpu::SurfaceDescriptorFromWindowsHWND*>(rhs);\n    }\n\n    inline const SurfaceDescriptorFromWindowsHWND* FromCppAPI(const wgpu::SurfaceDescriptorFromWindowsHWND* rhs) {\n        return reinterpret_cast<const SurfaceDescriptorFromWindowsHWND*>(rhs);\n    }\n\n    inline SurfaceDescriptorFromWindowsHWND* FromCppAPI(wgpu::SurfaceDescriptorFromWindowsHWND* rhs) {\n        return reinterpret_cast<SurfaceDescriptorFromWindowsHWND*>(rhs);\n    }\n\n    inline const WGPUSurfaceDescriptorFromWindowsSwapChainPanel* ToAPI(const SurfaceDescriptorFromWindowsSwapChainPanel* rhs) {\n        return reinterpret_cast<const WGPUSurfaceDescriptorFromWindowsSwapChainPanel*>(rhs);\n    }\n\n    inline WGPUSurfaceDescriptorFromWindowsSwapChainPanel* ToAPI(SurfaceDescriptorFromWindowsSwapChainPanel* rhs) {\n        return reinterpret_cast<WGPUSurfaceDescriptorFromWindowsSwapChainPanel*>(rhs);\n    }\n\n    inline const SurfaceDescriptorFromWindowsSwapChainPanel* FromAPI(const WGPUSurfaceDescriptorFromWindowsSwapChainPanel* rhs) {\n        return reinterpret_cast<const SurfaceDescriptorFromWindowsSwapChainPanel*>(rhs);\n    }\n\n    inline SurfaceDescriptorFromWindowsSwapChainPanel* FromAPI(WGPUSurfaceDescriptorFromWindowsSwapChainPanel* rhs) {\n        return reinterpret_cast<SurfaceDescriptorFromWindowsSwapChainPanel*>(rhs);\n    }\n\n    inline const wgpu::SurfaceDescriptorFromWindowsSwapChainPanel* ToCppAPI(const SurfaceDescriptorFromWindowsSwapChainPanel* rhs) {\n        return reinterpret_cast<const wgpu::SurfaceDescriptorFromWindowsSwapChainPanel*>(rhs);\n    }\n\n    inline wgpu::SurfaceDescriptorFromWindowsSwapChainPanel* ToCppAPI(SurfaceDescriptorFromWindowsSwapChainPanel* rhs) {\n        return reinterpret_cast<wgpu::SurfaceDescriptorFromWindowsSwapChainPanel*>(rhs);\n    }\n\n    inline const SurfaceDescriptorFromWindowsSwapChainPanel* FromCppAPI(const wgpu::SurfaceDescriptorFromWindowsSwapChainPanel* rhs) {\n        return reinterpret_cast<const SurfaceDescriptorFromWindowsSwapChainPanel*>(rhs);\n    }\n\n    inline SurfaceDescriptorFromWindowsSwapChainPanel* FromCppAPI(wgpu::SurfaceDescriptorFromWindowsSwapChainPanel* rhs) {\n        return reinterpret_cast<SurfaceDescriptorFromWindowsSwapChainPanel*>(rhs);\n    }\n\n    inline const WGPUSurfaceDescriptorFromXlibWindow* ToAPI(const SurfaceDescriptorFromXlibWindow* rhs) {\n        return reinterpret_cast<const WGPUSurfaceDescriptorFromXlibWindow*>(rhs);\n    }\n\n    inline WGPUSurfaceDescriptorFromXlibWindow* ToAPI(SurfaceDescriptorFromXlibWindow* rhs) {\n        return reinterpret_cast<WGPUSurfaceDescriptorFromXlibWindow*>(rhs);\n    }\n\n    inline const SurfaceDescriptorFromXlibWindow* FromAPI(const WGPUSurfaceDescriptorFromXlibWindow* rhs) {\n        return reinterpret_cast<const SurfaceDescriptorFromXlibWindow*>(rhs);\n    }\n\n    inline SurfaceDescriptorFromXlibWindow* FromAPI(WGPUSurfaceDescriptorFromXlibWindow* rhs) {\n        return reinterpret_cast<SurfaceDescriptorFromXlibWindow*>(rhs);\n    }\n\n    inline const wgpu::SurfaceDescriptorFromXlibWindow* ToCppAPI(const SurfaceDescriptorFromXlibWindow* rhs) {\n        return reinterpret_cast<const wgpu::SurfaceDescriptorFromXlibWindow*>(rhs);\n    }\n\n    inline wgpu::SurfaceDescriptorFromXlibWindow* ToCppAPI(SurfaceDescriptorFromXlibWindow* rhs) {\n        return reinterpret_cast<wgpu::SurfaceDescriptorFromXlibWindow*>(rhs);\n    }\n\n    inline const SurfaceDescriptorFromXlibWindow* FromCppAPI(const wgpu::SurfaceDescriptorFromXlibWindow* rhs) {\n        return reinterpret_cast<const SurfaceDescriptorFromXlibWindow*>(rhs);\n    }\n\n    inline SurfaceDescriptorFromXlibWindow* FromCppAPI(wgpu::SurfaceDescriptorFromXlibWindow* rhs) {\n        return reinterpret_cast<SurfaceDescriptorFromXlibWindow*>(rhs);\n    }\n\n    inline const WGPUSwapChainDescriptor* ToAPI(const SwapChainDescriptor* rhs) {\n        return reinterpret_cast<const WGPUSwapChainDescriptor*>(rhs);\n    }\n\n    inline WGPUSwapChainDescriptor* ToAPI(SwapChainDescriptor* rhs) {\n        return reinterpret_cast<WGPUSwapChainDescriptor*>(rhs);\n    }\n\n    inline const SwapChainDescriptor* FromAPI(const WGPUSwapChainDescriptor* rhs) {\n        return reinterpret_cast<const SwapChainDescriptor*>(rhs);\n    }\n\n    inline SwapChainDescriptor* FromAPI(WGPUSwapChainDescriptor* rhs) {\n        return reinterpret_cast<SwapChainDescriptor*>(rhs);\n    }\n\n    inline const wgpu::SwapChainDescriptor* ToCppAPI(const SwapChainDescriptor* rhs) {\n        return reinterpret_cast<const wgpu::SwapChainDescriptor*>(rhs);\n    }\n\n    inline wgpu::SwapChainDescriptor* ToCppAPI(SwapChainDescriptor* rhs) {\n        return reinterpret_cast<wgpu::SwapChainDescriptor*>(rhs);\n    }\n\n    inline const SwapChainDescriptor* FromCppAPI(const wgpu::SwapChainDescriptor* rhs) {\n        return reinterpret_cast<const SwapChainDescriptor*>(rhs);\n    }\n\n    inline SwapChainDescriptor* FromCppAPI(wgpu::SwapChainDescriptor* rhs) {\n        return reinterpret_cast<SwapChainDescriptor*>(rhs);\n    }\n\n    inline const WGPUTextureBindingLayout* ToAPI(const TextureBindingLayout* rhs) {\n        return reinterpret_cast<const WGPUTextureBindingLayout*>(rhs);\n    }\n\n    inline WGPUTextureBindingLayout* ToAPI(TextureBindingLayout* rhs) {\n        return reinterpret_cast<WGPUTextureBindingLayout*>(rhs);\n    }\n\n    inline const TextureBindingLayout* FromAPI(const WGPUTextureBindingLayout* rhs) {\n        return reinterpret_cast<const TextureBindingLayout*>(rhs);\n    }\n\n    inline TextureBindingLayout* FromAPI(WGPUTextureBindingLayout* rhs) {\n        return reinterpret_cast<TextureBindingLayout*>(rhs);\n    }\n\n    inline const wgpu::TextureBindingLayout* ToCppAPI(const TextureBindingLayout* rhs) {\n        return reinterpret_cast<const wgpu::TextureBindingLayout*>(rhs);\n    }\n\n    inline wgpu::TextureBindingLayout* ToCppAPI(TextureBindingLayout* rhs) {\n        return reinterpret_cast<wgpu::TextureBindingLayout*>(rhs);\n    }\n\n    inline const TextureBindingLayout* FromCppAPI(const wgpu::TextureBindingLayout* rhs) {\n        return reinterpret_cast<const TextureBindingLayout*>(rhs);\n    }\n\n    inline TextureBindingLayout* FromCppAPI(wgpu::TextureBindingLayout* rhs) {\n        return reinterpret_cast<TextureBindingLayout*>(rhs);\n    }\n\n    inline const WGPUTextureDataLayout* ToAPI(const TextureDataLayout* rhs) {\n        return reinterpret_cast<const WGPUTextureDataLayout*>(rhs);\n    }\n\n    inline WGPUTextureDataLayout* ToAPI(TextureDataLayout* rhs) {\n        return reinterpret_cast<WGPUTextureDataLayout*>(rhs);\n    }\n\n    inline const TextureDataLayout* FromAPI(const WGPUTextureDataLayout* rhs) {\n        return reinterpret_cast<const TextureDataLayout*>(rhs);\n    }\n\n    inline TextureDataLayout* FromAPI(WGPUTextureDataLayout* rhs) {\n        return reinterpret_cast<TextureDataLayout*>(rhs);\n    }\n\n    inline const wgpu::TextureDataLayout* ToCppAPI(const TextureDataLayout* rhs) {\n        return reinterpret_cast<const wgpu::TextureDataLayout*>(rhs);\n    }\n\n    inline wgpu::TextureDataLayout* ToCppAPI(TextureDataLayout* rhs) {\n        return reinterpret_cast<wgpu::TextureDataLayout*>(rhs);\n    }\n\n    inline const TextureDataLayout* FromCppAPI(const wgpu::TextureDataLayout* rhs) {\n        return reinterpret_cast<const TextureDataLayout*>(rhs);\n    }\n\n    inline TextureDataLayout* FromCppAPI(wgpu::TextureDataLayout* rhs) {\n        return reinterpret_cast<TextureDataLayout*>(rhs);\n    }\n\n    inline const WGPUTextureViewDescriptor* ToAPI(const TextureViewDescriptor* rhs) {\n        return reinterpret_cast<const WGPUTextureViewDescriptor*>(rhs);\n    }\n\n    inline WGPUTextureViewDescriptor* ToAPI(TextureViewDescriptor* rhs) {\n        return reinterpret_cast<WGPUTextureViewDescriptor*>(rhs);\n    }\n\n    inline const TextureViewDescriptor* FromAPI(const WGPUTextureViewDescriptor* rhs) {\n        return reinterpret_cast<const TextureViewDescriptor*>(rhs);\n    }\n\n    inline TextureViewDescriptor* FromAPI(WGPUTextureViewDescriptor* rhs) {\n        return reinterpret_cast<TextureViewDescriptor*>(rhs);\n    }\n\n    inline const wgpu::TextureViewDescriptor* ToCppAPI(const TextureViewDescriptor* rhs) {\n        return reinterpret_cast<const wgpu::TextureViewDescriptor*>(rhs);\n    }\n\n    inline wgpu::TextureViewDescriptor* ToCppAPI(TextureViewDescriptor* rhs) {\n        return reinterpret_cast<wgpu::TextureViewDescriptor*>(rhs);\n    }\n\n    inline const TextureViewDescriptor* FromCppAPI(const wgpu::TextureViewDescriptor* rhs) {\n        return reinterpret_cast<const TextureViewDescriptor*>(rhs);\n    }\n\n    inline TextureViewDescriptor* FromCppAPI(wgpu::TextureViewDescriptor* rhs) {\n        return reinterpret_cast<TextureViewDescriptor*>(rhs);\n    }\n\n    inline const WGPUVertexAttribute* ToAPI(const VertexAttribute* rhs) {\n        return reinterpret_cast<const WGPUVertexAttribute*>(rhs);\n    }\n\n    inline WGPUVertexAttribute* ToAPI(VertexAttribute* rhs) {\n        return reinterpret_cast<WGPUVertexAttribute*>(rhs);\n    }\n\n    inline const VertexAttribute* FromAPI(const WGPUVertexAttribute* rhs) {\n        return reinterpret_cast<const VertexAttribute*>(rhs);\n    }\n\n    inline VertexAttribute* FromAPI(WGPUVertexAttribute* rhs) {\n        return reinterpret_cast<VertexAttribute*>(rhs);\n    }\n\n    inline const wgpu::VertexAttribute* ToCppAPI(const VertexAttribute* rhs) {\n        return reinterpret_cast<const wgpu::VertexAttribute*>(rhs);\n    }\n\n    inline wgpu::VertexAttribute* ToCppAPI(VertexAttribute* rhs) {\n        return reinterpret_cast<wgpu::VertexAttribute*>(rhs);\n    }\n\n    inline const VertexAttribute* FromCppAPI(const wgpu::VertexAttribute* rhs) {\n        return reinterpret_cast<const VertexAttribute*>(rhs);\n    }\n\n    inline VertexAttribute* FromCppAPI(wgpu::VertexAttribute* rhs) {\n        return reinterpret_cast<VertexAttribute*>(rhs);\n    }\n\n    inline const WGPUBindGroupDescriptor* ToAPI(const BindGroupDescriptor* rhs) {\n        return reinterpret_cast<const WGPUBindGroupDescriptor*>(rhs);\n    }\n\n    inline WGPUBindGroupDescriptor* ToAPI(BindGroupDescriptor* rhs) {\n        return reinterpret_cast<WGPUBindGroupDescriptor*>(rhs);\n    }\n\n    inline const BindGroupDescriptor* FromAPI(const WGPUBindGroupDescriptor* rhs) {\n        return reinterpret_cast<const BindGroupDescriptor*>(rhs);\n    }\n\n    inline BindGroupDescriptor* FromAPI(WGPUBindGroupDescriptor* rhs) {\n        return reinterpret_cast<BindGroupDescriptor*>(rhs);\n    }\n\n    inline const wgpu::BindGroupDescriptor* ToCppAPI(const BindGroupDescriptor* rhs) {\n        return reinterpret_cast<const wgpu::BindGroupDescriptor*>(rhs);\n    }\n\n    inline wgpu::BindGroupDescriptor* ToCppAPI(BindGroupDescriptor* rhs) {\n        return reinterpret_cast<wgpu::BindGroupDescriptor*>(rhs);\n    }\n\n    inline const BindGroupDescriptor* FromCppAPI(const wgpu::BindGroupDescriptor* rhs) {\n        return reinterpret_cast<const BindGroupDescriptor*>(rhs);\n    }\n\n    inline BindGroupDescriptor* FromCppAPI(wgpu::BindGroupDescriptor* rhs) {\n        return reinterpret_cast<BindGroupDescriptor*>(rhs);\n    }\n\n    inline const WGPUBindGroupLayoutEntry* ToAPI(const BindGroupLayoutEntry* rhs) {\n        return reinterpret_cast<const WGPUBindGroupLayoutEntry*>(rhs);\n    }\n\n    inline WGPUBindGroupLayoutEntry* ToAPI(BindGroupLayoutEntry* rhs) {\n        return reinterpret_cast<WGPUBindGroupLayoutEntry*>(rhs);\n    }\n\n    inline const BindGroupLayoutEntry* FromAPI(const WGPUBindGroupLayoutEntry* rhs) {\n        return reinterpret_cast<const BindGroupLayoutEntry*>(rhs);\n    }\n\n    inline BindGroupLayoutEntry* FromAPI(WGPUBindGroupLayoutEntry* rhs) {\n        return reinterpret_cast<BindGroupLayoutEntry*>(rhs);\n    }\n\n    inline const wgpu::BindGroupLayoutEntry* ToCppAPI(const BindGroupLayoutEntry* rhs) {\n        return reinterpret_cast<const wgpu::BindGroupLayoutEntry*>(rhs);\n    }\n\n    inline wgpu::BindGroupLayoutEntry* ToCppAPI(BindGroupLayoutEntry* rhs) {\n        return reinterpret_cast<wgpu::BindGroupLayoutEntry*>(rhs);\n    }\n\n    inline const BindGroupLayoutEntry* FromCppAPI(const wgpu::BindGroupLayoutEntry* rhs) {\n        return reinterpret_cast<const BindGroupLayoutEntry*>(rhs);\n    }\n\n    inline BindGroupLayoutEntry* FromCppAPI(wgpu::BindGroupLayoutEntry* rhs) {\n        return reinterpret_cast<BindGroupLayoutEntry*>(rhs);\n    }\n\n    inline const WGPUBlendState* ToAPI(const BlendState* rhs) {\n        return reinterpret_cast<const WGPUBlendState*>(rhs);\n    }\n\n    inline WGPUBlendState* ToAPI(BlendState* rhs) {\n        return reinterpret_cast<WGPUBlendState*>(rhs);\n    }\n\n    inline const BlendState* FromAPI(const WGPUBlendState* rhs) {\n        return reinterpret_cast<const BlendState*>(rhs);\n    }\n\n    inline BlendState* FromAPI(WGPUBlendState* rhs) {\n        return reinterpret_cast<BlendState*>(rhs);\n    }\n\n    inline const wgpu::BlendState* ToCppAPI(const BlendState* rhs) {\n        return reinterpret_cast<const wgpu::BlendState*>(rhs);\n    }\n\n    inline wgpu::BlendState* ToCppAPI(BlendState* rhs) {\n        return reinterpret_cast<wgpu::BlendState*>(rhs);\n    }\n\n    inline const BlendState* FromCppAPI(const wgpu::BlendState* rhs) {\n        return reinterpret_cast<const BlendState*>(rhs);\n    }\n\n    inline BlendState* FromCppAPI(wgpu::BlendState* rhs) {\n        return reinterpret_cast<BlendState*>(rhs);\n    }\n\n    inline const WGPUCompilationInfo* ToAPI(const CompilationInfo* rhs) {\n        return reinterpret_cast<const WGPUCompilationInfo*>(rhs);\n    }\n\n    inline WGPUCompilationInfo* ToAPI(CompilationInfo* rhs) {\n        return reinterpret_cast<WGPUCompilationInfo*>(rhs);\n    }\n\n    inline const CompilationInfo* FromAPI(const WGPUCompilationInfo* rhs) {\n        return reinterpret_cast<const CompilationInfo*>(rhs);\n    }\n\n    inline CompilationInfo* FromAPI(WGPUCompilationInfo* rhs) {\n        return reinterpret_cast<CompilationInfo*>(rhs);\n    }\n\n    inline const wgpu::CompilationInfo* ToCppAPI(const CompilationInfo* rhs) {\n        return reinterpret_cast<const wgpu::CompilationInfo*>(rhs);\n    }\n\n    inline wgpu::CompilationInfo* ToCppAPI(CompilationInfo* rhs) {\n        return reinterpret_cast<wgpu::CompilationInfo*>(rhs);\n    }\n\n    inline const CompilationInfo* FromCppAPI(const wgpu::CompilationInfo* rhs) {\n        return reinterpret_cast<const CompilationInfo*>(rhs);\n    }\n\n    inline CompilationInfo* FromCppAPI(wgpu::CompilationInfo* rhs) {\n        return reinterpret_cast<CompilationInfo*>(rhs);\n    }\n\n    inline const WGPUComputePassDescriptor* ToAPI(const ComputePassDescriptor* rhs) {\n        return reinterpret_cast<const WGPUComputePassDescriptor*>(rhs);\n    }\n\n    inline WGPUComputePassDescriptor* ToAPI(ComputePassDescriptor* rhs) {\n        return reinterpret_cast<WGPUComputePassDescriptor*>(rhs);\n    }\n\n    inline const ComputePassDescriptor* FromAPI(const WGPUComputePassDescriptor* rhs) {\n        return reinterpret_cast<const ComputePassDescriptor*>(rhs);\n    }\n\n    inline ComputePassDescriptor* FromAPI(WGPUComputePassDescriptor* rhs) {\n        return reinterpret_cast<ComputePassDescriptor*>(rhs);\n    }\n\n    inline const wgpu::ComputePassDescriptor* ToCppAPI(const ComputePassDescriptor* rhs) {\n        return reinterpret_cast<const wgpu::ComputePassDescriptor*>(rhs);\n    }\n\n    inline wgpu::ComputePassDescriptor* ToCppAPI(ComputePassDescriptor* rhs) {\n        return reinterpret_cast<wgpu::ComputePassDescriptor*>(rhs);\n    }\n\n    inline const ComputePassDescriptor* FromCppAPI(const wgpu::ComputePassDescriptor* rhs) {\n        return reinterpret_cast<const ComputePassDescriptor*>(rhs);\n    }\n\n    inline ComputePassDescriptor* FromCppAPI(wgpu::ComputePassDescriptor* rhs) {\n        return reinterpret_cast<ComputePassDescriptor*>(rhs);\n    }\n\n    inline const WGPUDepthStencilState* ToAPI(const DepthStencilState* rhs) {\n        return reinterpret_cast<const WGPUDepthStencilState*>(rhs);\n    }\n\n    inline WGPUDepthStencilState* ToAPI(DepthStencilState* rhs) {\n        return reinterpret_cast<WGPUDepthStencilState*>(rhs);\n    }\n\n    inline const DepthStencilState* FromAPI(const WGPUDepthStencilState* rhs) {\n        return reinterpret_cast<const DepthStencilState*>(rhs);\n    }\n\n    inline DepthStencilState* FromAPI(WGPUDepthStencilState* rhs) {\n        return reinterpret_cast<DepthStencilState*>(rhs);\n    }\n\n    inline const wgpu::DepthStencilState* ToCppAPI(const DepthStencilState* rhs) {\n        return reinterpret_cast<const wgpu::DepthStencilState*>(rhs);\n    }\n\n    inline wgpu::DepthStencilState* ToCppAPI(DepthStencilState* rhs) {\n        return reinterpret_cast<wgpu::DepthStencilState*>(rhs);\n    }\n\n    inline const DepthStencilState* FromCppAPI(const wgpu::DepthStencilState* rhs) {\n        return reinterpret_cast<const DepthStencilState*>(rhs);\n    }\n\n    inline DepthStencilState* FromCppAPI(wgpu::DepthStencilState* rhs) {\n        return reinterpret_cast<DepthStencilState*>(rhs);\n    }\n\n    inline const WGPUExternalTextureDescriptor* ToAPI(const ExternalTextureDescriptor* rhs) {\n        return reinterpret_cast<const WGPUExternalTextureDescriptor*>(rhs);\n    }\n\n    inline WGPUExternalTextureDescriptor* ToAPI(ExternalTextureDescriptor* rhs) {\n        return reinterpret_cast<WGPUExternalTextureDescriptor*>(rhs);\n    }\n\n    inline const ExternalTextureDescriptor* FromAPI(const WGPUExternalTextureDescriptor* rhs) {\n        return reinterpret_cast<const ExternalTextureDescriptor*>(rhs);\n    }\n\n    inline ExternalTextureDescriptor* FromAPI(WGPUExternalTextureDescriptor* rhs) {\n        return reinterpret_cast<ExternalTextureDescriptor*>(rhs);\n    }\n\n    inline const wgpu::ExternalTextureDescriptor* ToCppAPI(const ExternalTextureDescriptor* rhs) {\n        return reinterpret_cast<const wgpu::ExternalTextureDescriptor*>(rhs);\n    }\n\n    inline wgpu::ExternalTextureDescriptor* ToCppAPI(ExternalTextureDescriptor* rhs) {\n        return reinterpret_cast<wgpu::ExternalTextureDescriptor*>(rhs);\n    }\n\n    inline const ExternalTextureDescriptor* FromCppAPI(const wgpu::ExternalTextureDescriptor* rhs) {\n        return reinterpret_cast<const ExternalTextureDescriptor*>(rhs);\n    }\n\n    inline ExternalTextureDescriptor* FromCppAPI(wgpu::ExternalTextureDescriptor* rhs) {\n        return reinterpret_cast<ExternalTextureDescriptor*>(rhs);\n    }\n\n    inline const WGPUImageCopyBuffer* ToAPI(const ImageCopyBuffer* rhs) {\n        return reinterpret_cast<const WGPUImageCopyBuffer*>(rhs);\n    }\n\n    inline WGPUImageCopyBuffer* ToAPI(ImageCopyBuffer* rhs) {\n        return reinterpret_cast<WGPUImageCopyBuffer*>(rhs);\n    }\n\n    inline const ImageCopyBuffer* FromAPI(const WGPUImageCopyBuffer* rhs) {\n        return reinterpret_cast<const ImageCopyBuffer*>(rhs);\n    }\n\n    inline ImageCopyBuffer* FromAPI(WGPUImageCopyBuffer* rhs) {\n        return reinterpret_cast<ImageCopyBuffer*>(rhs);\n    }\n\n    inline const wgpu::ImageCopyBuffer* ToCppAPI(const ImageCopyBuffer* rhs) {\n        return reinterpret_cast<const wgpu::ImageCopyBuffer*>(rhs);\n    }\n\n    inline wgpu::ImageCopyBuffer* ToCppAPI(ImageCopyBuffer* rhs) {\n        return reinterpret_cast<wgpu::ImageCopyBuffer*>(rhs);\n    }\n\n    inline const ImageCopyBuffer* FromCppAPI(const wgpu::ImageCopyBuffer* rhs) {\n        return reinterpret_cast<const ImageCopyBuffer*>(rhs);\n    }\n\n    inline ImageCopyBuffer* FromCppAPI(wgpu::ImageCopyBuffer* rhs) {\n        return reinterpret_cast<ImageCopyBuffer*>(rhs);\n    }\n\n    inline const WGPUImageCopyExternalTexture* ToAPI(const ImageCopyExternalTexture* rhs) {\n        return reinterpret_cast<const WGPUImageCopyExternalTexture*>(rhs);\n    }\n\n    inline WGPUImageCopyExternalTexture* ToAPI(ImageCopyExternalTexture* rhs) {\n        return reinterpret_cast<WGPUImageCopyExternalTexture*>(rhs);\n    }\n\n    inline const ImageCopyExternalTexture* FromAPI(const WGPUImageCopyExternalTexture* rhs) {\n        return reinterpret_cast<const ImageCopyExternalTexture*>(rhs);\n    }\n\n    inline ImageCopyExternalTexture* FromAPI(WGPUImageCopyExternalTexture* rhs) {\n        return reinterpret_cast<ImageCopyExternalTexture*>(rhs);\n    }\n\n    inline const wgpu::ImageCopyExternalTexture* ToCppAPI(const ImageCopyExternalTexture* rhs) {\n        return reinterpret_cast<const wgpu::ImageCopyExternalTexture*>(rhs);\n    }\n\n    inline wgpu::ImageCopyExternalTexture* ToCppAPI(ImageCopyExternalTexture* rhs) {\n        return reinterpret_cast<wgpu::ImageCopyExternalTexture*>(rhs);\n    }\n\n    inline const ImageCopyExternalTexture* FromCppAPI(const wgpu::ImageCopyExternalTexture* rhs) {\n        return reinterpret_cast<const ImageCopyExternalTexture*>(rhs);\n    }\n\n    inline ImageCopyExternalTexture* FromCppAPI(wgpu::ImageCopyExternalTexture* rhs) {\n        return reinterpret_cast<ImageCopyExternalTexture*>(rhs);\n    }\n\n    inline const WGPUImageCopyTexture* ToAPI(const ImageCopyTexture* rhs) {\n        return reinterpret_cast<const WGPUImageCopyTexture*>(rhs);\n    }\n\n    inline WGPUImageCopyTexture* ToAPI(ImageCopyTexture* rhs) {\n        return reinterpret_cast<WGPUImageCopyTexture*>(rhs);\n    }\n\n    inline const ImageCopyTexture* FromAPI(const WGPUImageCopyTexture* rhs) {\n        return reinterpret_cast<const ImageCopyTexture*>(rhs);\n    }\n\n    inline ImageCopyTexture* FromAPI(WGPUImageCopyTexture* rhs) {\n        return reinterpret_cast<ImageCopyTexture*>(rhs);\n    }\n\n    inline const wgpu::ImageCopyTexture* ToCppAPI(const ImageCopyTexture* rhs) {\n        return reinterpret_cast<const wgpu::ImageCopyTexture*>(rhs);\n    }\n\n    inline wgpu::ImageCopyTexture* ToCppAPI(ImageCopyTexture* rhs) {\n        return reinterpret_cast<wgpu::ImageCopyTexture*>(rhs);\n    }\n\n    inline const ImageCopyTexture* FromCppAPI(const wgpu::ImageCopyTexture* rhs) {\n        return reinterpret_cast<const ImageCopyTexture*>(rhs);\n    }\n\n    inline ImageCopyTexture* FromCppAPI(wgpu::ImageCopyTexture* rhs) {\n        return reinterpret_cast<ImageCopyTexture*>(rhs);\n    }\n\n    inline const WGPUProgrammableStageDescriptor* ToAPI(const ProgrammableStageDescriptor* rhs) {\n        return reinterpret_cast<const WGPUProgrammableStageDescriptor*>(rhs);\n    }\n\n    inline WGPUProgrammableStageDescriptor* ToAPI(ProgrammableStageDescriptor* rhs) {\n        return reinterpret_cast<WGPUProgrammableStageDescriptor*>(rhs);\n    }\n\n    inline const ProgrammableStageDescriptor* FromAPI(const WGPUProgrammableStageDescriptor* rhs) {\n        return reinterpret_cast<const ProgrammableStageDescriptor*>(rhs);\n    }\n\n    inline ProgrammableStageDescriptor* FromAPI(WGPUProgrammableStageDescriptor* rhs) {\n        return reinterpret_cast<ProgrammableStageDescriptor*>(rhs);\n    }\n\n    inline const wgpu::ProgrammableStageDescriptor* ToCppAPI(const ProgrammableStageDescriptor* rhs) {\n        return reinterpret_cast<const wgpu::ProgrammableStageDescriptor*>(rhs);\n    }\n\n    inline wgpu::ProgrammableStageDescriptor* ToCppAPI(ProgrammableStageDescriptor* rhs) {\n        return reinterpret_cast<wgpu::ProgrammableStageDescriptor*>(rhs);\n    }\n\n    inline const ProgrammableStageDescriptor* FromCppAPI(const wgpu::ProgrammableStageDescriptor* rhs) {\n        return reinterpret_cast<const ProgrammableStageDescriptor*>(rhs);\n    }\n\n    inline ProgrammableStageDescriptor* FromCppAPI(wgpu::ProgrammableStageDescriptor* rhs) {\n        return reinterpret_cast<ProgrammableStageDescriptor*>(rhs);\n    }\n\n    inline const WGPURenderPassColorAttachment* ToAPI(const RenderPassColorAttachment* rhs) {\n        return reinterpret_cast<const WGPURenderPassColorAttachment*>(rhs);\n    }\n\n    inline WGPURenderPassColorAttachment* ToAPI(RenderPassColorAttachment* rhs) {\n        return reinterpret_cast<WGPURenderPassColorAttachment*>(rhs);\n    }\n\n    inline const RenderPassColorAttachment* FromAPI(const WGPURenderPassColorAttachment* rhs) {\n        return reinterpret_cast<const RenderPassColorAttachment*>(rhs);\n    }\n\n    inline RenderPassColorAttachment* FromAPI(WGPURenderPassColorAttachment* rhs) {\n        return reinterpret_cast<RenderPassColorAttachment*>(rhs);\n    }\n\n    inline const wgpu::RenderPassColorAttachment* ToCppAPI(const RenderPassColorAttachment* rhs) {\n        return reinterpret_cast<const wgpu::RenderPassColorAttachment*>(rhs);\n    }\n\n    inline wgpu::RenderPassColorAttachment* ToCppAPI(RenderPassColorAttachment* rhs) {\n        return reinterpret_cast<wgpu::RenderPassColorAttachment*>(rhs);\n    }\n\n    inline const RenderPassColorAttachment* FromCppAPI(const wgpu::RenderPassColorAttachment* rhs) {\n        return reinterpret_cast<const RenderPassColorAttachment*>(rhs);\n    }\n\n    inline RenderPassColorAttachment* FromCppAPI(wgpu::RenderPassColorAttachment* rhs) {\n        return reinterpret_cast<RenderPassColorAttachment*>(rhs);\n    }\n\n    inline const WGPURequiredLimits* ToAPI(const RequiredLimits* rhs) {\n        return reinterpret_cast<const WGPURequiredLimits*>(rhs);\n    }\n\n    inline WGPURequiredLimits* ToAPI(RequiredLimits* rhs) {\n        return reinterpret_cast<WGPURequiredLimits*>(rhs);\n    }\n\n    inline const RequiredLimits* FromAPI(const WGPURequiredLimits* rhs) {\n        return reinterpret_cast<const RequiredLimits*>(rhs);\n    }\n\n    inline RequiredLimits* FromAPI(WGPURequiredLimits* rhs) {\n        return reinterpret_cast<RequiredLimits*>(rhs);\n    }\n\n    inline const wgpu::RequiredLimits* ToCppAPI(const RequiredLimits* rhs) {\n        return reinterpret_cast<const wgpu::RequiredLimits*>(rhs);\n    }\n\n    inline wgpu::RequiredLimits* ToCppAPI(RequiredLimits* rhs) {\n        return reinterpret_cast<wgpu::RequiredLimits*>(rhs);\n    }\n\n    inline const RequiredLimits* FromCppAPI(const wgpu::RequiredLimits* rhs) {\n        return reinterpret_cast<const RequiredLimits*>(rhs);\n    }\n\n    inline RequiredLimits* FromCppAPI(wgpu::RequiredLimits* rhs) {\n        return reinterpret_cast<RequiredLimits*>(rhs);\n    }\n\n    inline const WGPUSupportedLimits* ToAPI(const SupportedLimits* rhs) {\n        return reinterpret_cast<const WGPUSupportedLimits*>(rhs);\n    }\n\n    inline WGPUSupportedLimits* ToAPI(SupportedLimits* rhs) {\n        return reinterpret_cast<WGPUSupportedLimits*>(rhs);\n    }\n\n    inline const SupportedLimits* FromAPI(const WGPUSupportedLimits* rhs) {\n        return reinterpret_cast<const SupportedLimits*>(rhs);\n    }\n\n    inline SupportedLimits* FromAPI(WGPUSupportedLimits* rhs) {\n        return reinterpret_cast<SupportedLimits*>(rhs);\n    }\n\n    inline const wgpu::SupportedLimits* ToCppAPI(const SupportedLimits* rhs) {\n        return reinterpret_cast<const wgpu::SupportedLimits*>(rhs);\n    }\n\n    inline wgpu::SupportedLimits* ToCppAPI(SupportedLimits* rhs) {\n        return reinterpret_cast<wgpu::SupportedLimits*>(rhs);\n    }\n\n    inline const SupportedLimits* FromCppAPI(const wgpu::SupportedLimits* rhs) {\n        return reinterpret_cast<const SupportedLimits*>(rhs);\n    }\n\n    inline SupportedLimits* FromCppAPI(wgpu::SupportedLimits* rhs) {\n        return reinterpret_cast<SupportedLimits*>(rhs);\n    }\n\n    inline const WGPUTextureDescriptor* ToAPI(const TextureDescriptor* rhs) {\n        return reinterpret_cast<const WGPUTextureDescriptor*>(rhs);\n    }\n\n    inline WGPUTextureDescriptor* ToAPI(TextureDescriptor* rhs) {\n        return reinterpret_cast<WGPUTextureDescriptor*>(rhs);\n    }\n\n    inline const TextureDescriptor* FromAPI(const WGPUTextureDescriptor* rhs) {\n        return reinterpret_cast<const TextureDescriptor*>(rhs);\n    }\n\n    inline TextureDescriptor* FromAPI(WGPUTextureDescriptor* rhs) {\n        return reinterpret_cast<TextureDescriptor*>(rhs);\n    }\n\n    inline const wgpu::TextureDescriptor* ToCppAPI(const TextureDescriptor* rhs) {\n        return reinterpret_cast<const wgpu::TextureDescriptor*>(rhs);\n    }\n\n    inline wgpu::TextureDescriptor* ToCppAPI(TextureDescriptor* rhs) {\n        return reinterpret_cast<wgpu::TextureDescriptor*>(rhs);\n    }\n\n    inline const TextureDescriptor* FromCppAPI(const wgpu::TextureDescriptor* rhs) {\n        return reinterpret_cast<const TextureDescriptor*>(rhs);\n    }\n\n    inline TextureDescriptor* FromCppAPI(wgpu::TextureDescriptor* rhs) {\n        return reinterpret_cast<TextureDescriptor*>(rhs);\n    }\n\n    inline const WGPUVertexBufferLayout* ToAPI(const VertexBufferLayout* rhs) {\n        return reinterpret_cast<const WGPUVertexBufferLayout*>(rhs);\n    }\n\n    inline WGPUVertexBufferLayout* ToAPI(VertexBufferLayout* rhs) {\n        return reinterpret_cast<WGPUVertexBufferLayout*>(rhs);\n    }\n\n    inline const VertexBufferLayout* FromAPI(const WGPUVertexBufferLayout* rhs) {\n        return reinterpret_cast<const VertexBufferLayout*>(rhs);\n    }\n\n    inline VertexBufferLayout* FromAPI(WGPUVertexBufferLayout* rhs) {\n        return reinterpret_cast<VertexBufferLayout*>(rhs);\n    }\n\n    inline const wgpu::VertexBufferLayout* ToCppAPI(const VertexBufferLayout* rhs) {\n        return reinterpret_cast<const wgpu::VertexBufferLayout*>(rhs);\n    }\n\n    inline wgpu::VertexBufferLayout* ToCppAPI(VertexBufferLayout* rhs) {\n        return reinterpret_cast<wgpu::VertexBufferLayout*>(rhs);\n    }\n\n    inline const VertexBufferLayout* FromCppAPI(const wgpu::VertexBufferLayout* rhs) {\n        return reinterpret_cast<const VertexBufferLayout*>(rhs);\n    }\n\n    inline VertexBufferLayout* FromCppAPI(wgpu::VertexBufferLayout* rhs) {\n        return reinterpret_cast<VertexBufferLayout*>(rhs);\n    }\n\n    inline const WGPUBindGroupLayoutDescriptor* ToAPI(const BindGroupLayoutDescriptor* rhs) {\n        return reinterpret_cast<const WGPUBindGroupLayoutDescriptor*>(rhs);\n    }\n\n    inline WGPUBindGroupLayoutDescriptor* ToAPI(BindGroupLayoutDescriptor* rhs) {\n        return reinterpret_cast<WGPUBindGroupLayoutDescriptor*>(rhs);\n    }\n\n    inline const BindGroupLayoutDescriptor* FromAPI(const WGPUBindGroupLayoutDescriptor* rhs) {\n        return reinterpret_cast<const BindGroupLayoutDescriptor*>(rhs);\n    }\n\n    inline BindGroupLayoutDescriptor* FromAPI(WGPUBindGroupLayoutDescriptor* rhs) {\n        return reinterpret_cast<BindGroupLayoutDescriptor*>(rhs);\n    }\n\n    inline const wgpu::BindGroupLayoutDescriptor* ToCppAPI(const BindGroupLayoutDescriptor* rhs) {\n        return reinterpret_cast<const wgpu::BindGroupLayoutDescriptor*>(rhs);\n    }\n\n    inline wgpu::BindGroupLayoutDescriptor* ToCppAPI(BindGroupLayoutDescriptor* rhs) {\n        return reinterpret_cast<wgpu::BindGroupLayoutDescriptor*>(rhs);\n    }\n\n    inline const BindGroupLayoutDescriptor* FromCppAPI(const wgpu::BindGroupLayoutDescriptor* rhs) {\n        return reinterpret_cast<const BindGroupLayoutDescriptor*>(rhs);\n    }\n\n    inline BindGroupLayoutDescriptor* FromCppAPI(wgpu::BindGroupLayoutDescriptor* rhs) {\n        return reinterpret_cast<BindGroupLayoutDescriptor*>(rhs);\n    }\n\n    inline const WGPUColorTargetState* ToAPI(const ColorTargetState* rhs) {\n        return reinterpret_cast<const WGPUColorTargetState*>(rhs);\n    }\n\n    inline WGPUColorTargetState* ToAPI(ColorTargetState* rhs) {\n        return reinterpret_cast<WGPUColorTargetState*>(rhs);\n    }\n\n    inline const ColorTargetState* FromAPI(const WGPUColorTargetState* rhs) {\n        return reinterpret_cast<const ColorTargetState*>(rhs);\n    }\n\n    inline ColorTargetState* FromAPI(WGPUColorTargetState* rhs) {\n        return reinterpret_cast<ColorTargetState*>(rhs);\n    }\n\n    inline const wgpu::ColorTargetState* ToCppAPI(const ColorTargetState* rhs) {\n        return reinterpret_cast<const wgpu::ColorTargetState*>(rhs);\n    }\n\n    inline wgpu::ColorTargetState* ToCppAPI(ColorTargetState* rhs) {\n        return reinterpret_cast<wgpu::ColorTargetState*>(rhs);\n    }\n\n    inline const ColorTargetState* FromCppAPI(const wgpu::ColorTargetState* rhs) {\n        return reinterpret_cast<const ColorTargetState*>(rhs);\n    }\n\n    inline ColorTargetState* FromCppAPI(wgpu::ColorTargetState* rhs) {\n        return reinterpret_cast<ColorTargetState*>(rhs);\n    }\n\n    inline const WGPUComputePipelineDescriptor* ToAPI(const ComputePipelineDescriptor* rhs) {\n        return reinterpret_cast<const WGPUComputePipelineDescriptor*>(rhs);\n    }\n\n    inline WGPUComputePipelineDescriptor* ToAPI(ComputePipelineDescriptor* rhs) {\n        return reinterpret_cast<WGPUComputePipelineDescriptor*>(rhs);\n    }\n\n    inline const ComputePipelineDescriptor* FromAPI(const WGPUComputePipelineDescriptor* rhs) {\n        return reinterpret_cast<const ComputePipelineDescriptor*>(rhs);\n    }\n\n    inline ComputePipelineDescriptor* FromAPI(WGPUComputePipelineDescriptor* rhs) {\n        return reinterpret_cast<ComputePipelineDescriptor*>(rhs);\n    }\n\n    inline const wgpu::ComputePipelineDescriptor* ToCppAPI(const ComputePipelineDescriptor* rhs) {\n        return reinterpret_cast<const wgpu::ComputePipelineDescriptor*>(rhs);\n    }\n\n    inline wgpu::ComputePipelineDescriptor* ToCppAPI(ComputePipelineDescriptor* rhs) {\n        return reinterpret_cast<wgpu::ComputePipelineDescriptor*>(rhs);\n    }\n\n    inline const ComputePipelineDescriptor* FromCppAPI(const wgpu::ComputePipelineDescriptor* rhs) {\n        return reinterpret_cast<const ComputePipelineDescriptor*>(rhs);\n    }\n\n    inline ComputePipelineDescriptor* FromCppAPI(wgpu::ComputePipelineDescriptor* rhs) {\n        return reinterpret_cast<ComputePipelineDescriptor*>(rhs);\n    }\n\n    inline const WGPUDeviceDescriptor* ToAPI(const DeviceDescriptor* rhs) {\n        return reinterpret_cast<const WGPUDeviceDescriptor*>(rhs);\n    }\n\n    inline WGPUDeviceDescriptor* ToAPI(DeviceDescriptor* rhs) {\n        return reinterpret_cast<WGPUDeviceDescriptor*>(rhs);\n    }\n\n    inline const DeviceDescriptor* FromAPI(const WGPUDeviceDescriptor* rhs) {\n        return reinterpret_cast<const DeviceDescriptor*>(rhs);\n    }\n\n    inline DeviceDescriptor* FromAPI(WGPUDeviceDescriptor* rhs) {\n        return reinterpret_cast<DeviceDescriptor*>(rhs);\n    }\n\n    inline const wgpu::DeviceDescriptor* ToCppAPI(const DeviceDescriptor* rhs) {\n        return reinterpret_cast<const wgpu::DeviceDescriptor*>(rhs);\n    }\n\n    inline wgpu::DeviceDescriptor* ToCppAPI(DeviceDescriptor* rhs) {\n        return reinterpret_cast<wgpu::DeviceDescriptor*>(rhs);\n    }\n\n    inline const DeviceDescriptor* FromCppAPI(const wgpu::DeviceDescriptor* rhs) {\n        return reinterpret_cast<const DeviceDescriptor*>(rhs);\n    }\n\n    inline DeviceDescriptor* FromCppAPI(wgpu::DeviceDescriptor* rhs) {\n        return reinterpret_cast<DeviceDescriptor*>(rhs);\n    }\n\n    inline const WGPURenderPassDescriptor* ToAPI(const RenderPassDescriptor* rhs) {\n        return reinterpret_cast<const WGPURenderPassDescriptor*>(rhs);\n    }\n\n    inline WGPURenderPassDescriptor* ToAPI(RenderPassDescriptor* rhs) {\n        return reinterpret_cast<WGPURenderPassDescriptor*>(rhs);\n    }\n\n    inline const RenderPassDescriptor* FromAPI(const WGPURenderPassDescriptor* rhs) {\n        return reinterpret_cast<const RenderPassDescriptor*>(rhs);\n    }\n\n    inline RenderPassDescriptor* FromAPI(WGPURenderPassDescriptor* rhs) {\n        return reinterpret_cast<RenderPassDescriptor*>(rhs);\n    }\n\n    inline const wgpu::RenderPassDescriptor* ToCppAPI(const RenderPassDescriptor* rhs) {\n        return reinterpret_cast<const wgpu::RenderPassDescriptor*>(rhs);\n    }\n\n    inline wgpu::RenderPassDescriptor* ToCppAPI(RenderPassDescriptor* rhs) {\n        return reinterpret_cast<wgpu::RenderPassDescriptor*>(rhs);\n    }\n\n    inline const RenderPassDescriptor* FromCppAPI(const wgpu::RenderPassDescriptor* rhs) {\n        return reinterpret_cast<const RenderPassDescriptor*>(rhs);\n    }\n\n    inline RenderPassDescriptor* FromCppAPI(wgpu::RenderPassDescriptor* rhs) {\n        return reinterpret_cast<RenderPassDescriptor*>(rhs);\n    }\n\n    inline const WGPUVertexState* ToAPI(const VertexState* rhs) {\n        return reinterpret_cast<const WGPUVertexState*>(rhs);\n    }\n\n    inline WGPUVertexState* ToAPI(VertexState* rhs) {\n        return reinterpret_cast<WGPUVertexState*>(rhs);\n    }\n\n    inline const VertexState* FromAPI(const WGPUVertexState* rhs) {\n        return reinterpret_cast<const VertexState*>(rhs);\n    }\n\n    inline VertexState* FromAPI(WGPUVertexState* rhs) {\n        return reinterpret_cast<VertexState*>(rhs);\n    }\n\n    inline const wgpu::VertexState* ToCppAPI(const VertexState* rhs) {\n        return reinterpret_cast<const wgpu::VertexState*>(rhs);\n    }\n\n    inline wgpu::VertexState* ToCppAPI(VertexState* rhs) {\n        return reinterpret_cast<wgpu::VertexState*>(rhs);\n    }\n\n    inline const VertexState* FromCppAPI(const wgpu::VertexState* rhs) {\n        return reinterpret_cast<const VertexState*>(rhs);\n    }\n\n    inline VertexState* FromCppAPI(wgpu::VertexState* rhs) {\n        return reinterpret_cast<VertexState*>(rhs);\n    }\n\n    inline const WGPUFragmentState* ToAPI(const FragmentState* rhs) {\n        return reinterpret_cast<const WGPUFragmentState*>(rhs);\n    }\n\n    inline WGPUFragmentState* ToAPI(FragmentState* rhs) {\n        return reinterpret_cast<WGPUFragmentState*>(rhs);\n    }\n\n    inline const FragmentState* FromAPI(const WGPUFragmentState* rhs) {\n        return reinterpret_cast<const FragmentState*>(rhs);\n    }\n\n    inline FragmentState* FromAPI(WGPUFragmentState* rhs) {\n        return reinterpret_cast<FragmentState*>(rhs);\n    }\n\n    inline const wgpu::FragmentState* ToCppAPI(const FragmentState* rhs) {\n        return reinterpret_cast<const wgpu::FragmentState*>(rhs);\n    }\n\n    inline wgpu::FragmentState* ToCppAPI(FragmentState* rhs) {\n        return reinterpret_cast<wgpu::FragmentState*>(rhs);\n    }\n\n    inline const FragmentState* FromCppAPI(const wgpu::FragmentState* rhs) {\n        return reinterpret_cast<const FragmentState*>(rhs);\n    }\n\n    inline FragmentState* FromCppAPI(wgpu::FragmentState* rhs) {\n        return reinterpret_cast<FragmentState*>(rhs);\n    }\n\n    inline const WGPURenderPipelineDescriptor* ToAPI(const RenderPipelineDescriptor* rhs) {\n        return reinterpret_cast<const WGPURenderPipelineDescriptor*>(rhs);\n    }\n\n    inline WGPURenderPipelineDescriptor* ToAPI(RenderPipelineDescriptor* rhs) {\n        return reinterpret_cast<WGPURenderPipelineDescriptor*>(rhs);\n    }\n\n    inline const RenderPipelineDescriptor* FromAPI(const WGPURenderPipelineDescriptor* rhs) {\n        return reinterpret_cast<const RenderPipelineDescriptor*>(rhs);\n    }\n\n    inline RenderPipelineDescriptor* FromAPI(WGPURenderPipelineDescriptor* rhs) {\n        return reinterpret_cast<RenderPipelineDescriptor*>(rhs);\n    }\n\n    inline const wgpu::RenderPipelineDescriptor* ToCppAPI(const RenderPipelineDescriptor* rhs) {\n        return reinterpret_cast<const wgpu::RenderPipelineDescriptor*>(rhs);\n    }\n\n    inline wgpu::RenderPipelineDescriptor* ToCppAPI(RenderPipelineDescriptor* rhs) {\n        return reinterpret_cast<wgpu::RenderPipelineDescriptor*>(rhs);\n    }\n\n    inline const RenderPipelineDescriptor* FromCppAPI(const wgpu::RenderPipelineDescriptor* rhs) {\n        return reinterpret_cast<const RenderPipelineDescriptor*>(rhs);\n    }\n\n    inline RenderPipelineDescriptor* FromCppAPI(wgpu::RenderPipelineDescriptor* rhs) {\n        return reinterpret_cast<RenderPipelineDescriptor*>(rhs);\n    }\n\n\n    inline const WGPUAdapterImpl* ToAPI(const AdapterBase* rhs) {\n        return reinterpret_cast<const WGPUAdapterImpl*>(rhs);\n    }\n\n    inline WGPUAdapterImpl* ToAPI(AdapterBase* rhs) {\n        return reinterpret_cast<WGPUAdapterImpl*>(rhs);\n    }\n\n    inline const AdapterBase* FromAPI(const WGPUAdapterImpl* rhs) {\n        return reinterpret_cast<const AdapterBase*>(rhs);\n    }\n\n    inline AdapterBase* FromAPI(WGPUAdapterImpl* rhs) {\n        return reinterpret_cast<AdapterBase*>(rhs);\n    }\n    inline const WGPUBindGroupImpl* ToAPI(const BindGroupBase* rhs) {\n        return reinterpret_cast<const WGPUBindGroupImpl*>(rhs);\n    }\n\n    inline WGPUBindGroupImpl* ToAPI(BindGroupBase* rhs) {\n        return reinterpret_cast<WGPUBindGroupImpl*>(rhs);\n    }\n\n    inline const BindGroupBase* FromAPI(const WGPUBindGroupImpl* rhs) {\n        return reinterpret_cast<const BindGroupBase*>(rhs);\n    }\n\n    inline BindGroupBase* FromAPI(WGPUBindGroupImpl* rhs) {\n        return reinterpret_cast<BindGroupBase*>(rhs);\n    }\n    inline const WGPUBindGroupLayoutImpl* ToAPI(const BindGroupLayoutBase* rhs) {\n        return reinterpret_cast<const WGPUBindGroupLayoutImpl*>(rhs);\n    }\n\n    inline WGPUBindGroupLayoutImpl* ToAPI(BindGroupLayoutBase* rhs) {\n        return reinterpret_cast<WGPUBindGroupLayoutImpl*>(rhs);\n    }\n\n    inline const BindGroupLayoutBase* FromAPI(const WGPUBindGroupLayoutImpl* rhs) {\n        return reinterpret_cast<const BindGroupLayoutBase*>(rhs);\n    }\n\n    inline BindGroupLayoutBase* FromAPI(WGPUBindGroupLayoutImpl* rhs) {\n        return reinterpret_cast<BindGroupLayoutBase*>(rhs);\n    }\n    inline const WGPUBufferImpl* ToAPI(const BufferBase* rhs) {\n        return reinterpret_cast<const WGPUBufferImpl*>(rhs);\n    }\n\n    inline WGPUBufferImpl* ToAPI(BufferBase* rhs) {\n        return reinterpret_cast<WGPUBufferImpl*>(rhs);\n    }\n\n    inline const BufferBase* FromAPI(const WGPUBufferImpl* rhs) {\n        return reinterpret_cast<const BufferBase*>(rhs);\n    }\n\n    inline BufferBase* FromAPI(WGPUBufferImpl* rhs) {\n        return reinterpret_cast<BufferBase*>(rhs);\n    }\n    inline const WGPUCommandBufferImpl* ToAPI(const CommandBufferBase* rhs) {\n        return reinterpret_cast<const WGPUCommandBufferImpl*>(rhs);\n    }\n\n    inline WGPUCommandBufferImpl* ToAPI(CommandBufferBase* rhs) {\n        return reinterpret_cast<WGPUCommandBufferImpl*>(rhs);\n    }\n\n    inline const CommandBufferBase* FromAPI(const WGPUCommandBufferImpl* rhs) {\n        return reinterpret_cast<const CommandBufferBase*>(rhs);\n    }\n\n    inline CommandBufferBase* FromAPI(WGPUCommandBufferImpl* rhs) {\n        return reinterpret_cast<CommandBufferBase*>(rhs);\n    }\n    inline const WGPUCommandEncoderImpl* ToAPI(const CommandEncoderBase* rhs) {\n        return reinterpret_cast<const WGPUCommandEncoderImpl*>(rhs);\n    }\n\n    inline WGPUCommandEncoderImpl* ToAPI(CommandEncoderBase* rhs) {\n        return reinterpret_cast<WGPUCommandEncoderImpl*>(rhs);\n    }\n\n    inline const CommandEncoderBase* FromAPI(const WGPUCommandEncoderImpl* rhs) {\n        return reinterpret_cast<const CommandEncoderBase*>(rhs);\n    }\n\n    inline CommandEncoderBase* FromAPI(WGPUCommandEncoderImpl* rhs) {\n        return reinterpret_cast<CommandEncoderBase*>(rhs);\n    }\n    inline const WGPUComputePassEncoderImpl* ToAPI(const ComputePassEncoderBase* rhs) {\n        return reinterpret_cast<const WGPUComputePassEncoderImpl*>(rhs);\n    }\n\n    inline WGPUComputePassEncoderImpl* ToAPI(ComputePassEncoderBase* rhs) {\n        return reinterpret_cast<WGPUComputePassEncoderImpl*>(rhs);\n    }\n\n    inline const ComputePassEncoderBase* FromAPI(const WGPUComputePassEncoderImpl* rhs) {\n        return reinterpret_cast<const ComputePassEncoderBase*>(rhs);\n    }\n\n    inline ComputePassEncoderBase* FromAPI(WGPUComputePassEncoderImpl* rhs) {\n        return reinterpret_cast<ComputePassEncoderBase*>(rhs);\n    }\n    inline const WGPUComputePipelineImpl* ToAPI(const ComputePipelineBase* rhs) {\n        return reinterpret_cast<const WGPUComputePipelineImpl*>(rhs);\n    }\n\n    inline WGPUComputePipelineImpl* ToAPI(ComputePipelineBase* rhs) {\n        return reinterpret_cast<WGPUComputePipelineImpl*>(rhs);\n    }\n\n    inline const ComputePipelineBase* FromAPI(const WGPUComputePipelineImpl* rhs) {\n        return reinterpret_cast<const ComputePipelineBase*>(rhs);\n    }\n\n    inline ComputePipelineBase* FromAPI(WGPUComputePipelineImpl* rhs) {\n        return reinterpret_cast<ComputePipelineBase*>(rhs);\n    }\n    inline const WGPUDeviceImpl* ToAPI(const DeviceBase* rhs) {\n        return reinterpret_cast<const WGPUDeviceImpl*>(rhs);\n    }\n\n    inline WGPUDeviceImpl* ToAPI(DeviceBase* rhs) {\n        return reinterpret_cast<WGPUDeviceImpl*>(rhs);\n    }\n\n    inline const DeviceBase* FromAPI(const WGPUDeviceImpl* rhs) {\n        return reinterpret_cast<const DeviceBase*>(rhs);\n    }\n\n    inline DeviceBase* FromAPI(WGPUDeviceImpl* rhs) {\n        return reinterpret_cast<DeviceBase*>(rhs);\n    }\n    inline const WGPUExternalTextureImpl* ToAPI(const ExternalTextureBase* rhs) {\n        return reinterpret_cast<const WGPUExternalTextureImpl*>(rhs);\n    }\n\n    inline WGPUExternalTextureImpl* ToAPI(ExternalTextureBase* rhs) {\n        return reinterpret_cast<WGPUExternalTextureImpl*>(rhs);\n    }\n\n    inline const ExternalTextureBase* FromAPI(const WGPUExternalTextureImpl* rhs) {\n        return reinterpret_cast<const ExternalTextureBase*>(rhs);\n    }\n\n    inline ExternalTextureBase* FromAPI(WGPUExternalTextureImpl* rhs) {\n        return reinterpret_cast<ExternalTextureBase*>(rhs);\n    }\n    inline const WGPUInstanceImpl* ToAPI(const InstanceBase* rhs) {\n        return reinterpret_cast<const WGPUInstanceImpl*>(rhs);\n    }\n\n    inline WGPUInstanceImpl* ToAPI(InstanceBase* rhs) {\n        return reinterpret_cast<WGPUInstanceImpl*>(rhs);\n    }\n\n    inline const InstanceBase* FromAPI(const WGPUInstanceImpl* rhs) {\n        return reinterpret_cast<const InstanceBase*>(rhs);\n    }\n\n    inline InstanceBase* FromAPI(WGPUInstanceImpl* rhs) {\n        return reinterpret_cast<InstanceBase*>(rhs);\n    }\n    inline const WGPUPipelineLayoutImpl* ToAPI(const PipelineLayoutBase* rhs) {\n        return reinterpret_cast<const WGPUPipelineLayoutImpl*>(rhs);\n    }\n\n    inline WGPUPipelineLayoutImpl* ToAPI(PipelineLayoutBase* rhs) {\n        return reinterpret_cast<WGPUPipelineLayoutImpl*>(rhs);\n    }\n\n    inline const PipelineLayoutBase* FromAPI(const WGPUPipelineLayoutImpl* rhs) {\n        return reinterpret_cast<const PipelineLayoutBase*>(rhs);\n    }\n\n    inline PipelineLayoutBase* FromAPI(WGPUPipelineLayoutImpl* rhs) {\n        return reinterpret_cast<PipelineLayoutBase*>(rhs);\n    }\n    inline const WGPUQuerySetImpl* ToAPI(const QuerySetBase* rhs) {\n        return reinterpret_cast<const WGPUQuerySetImpl*>(rhs);\n    }\n\n    inline WGPUQuerySetImpl* ToAPI(QuerySetBase* rhs) {\n        return reinterpret_cast<WGPUQuerySetImpl*>(rhs);\n    }\n\n    inline const QuerySetBase* FromAPI(const WGPUQuerySetImpl* rhs) {\n        return reinterpret_cast<const QuerySetBase*>(rhs);\n    }\n\n    inline QuerySetBase* FromAPI(WGPUQuerySetImpl* rhs) {\n        return reinterpret_cast<QuerySetBase*>(rhs);\n    }\n    inline const WGPUQueueImpl* ToAPI(const QueueBase* rhs) {\n        return reinterpret_cast<const WGPUQueueImpl*>(rhs);\n    }\n\n    inline WGPUQueueImpl* ToAPI(QueueBase* rhs) {\n        return reinterpret_cast<WGPUQueueImpl*>(rhs);\n    }\n\n    inline const QueueBase* FromAPI(const WGPUQueueImpl* rhs) {\n        return reinterpret_cast<const QueueBase*>(rhs);\n    }\n\n    inline QueueBase* FromAPI(WGPUQueueImpl* rhs) {\n        return reinterpret_cast<QueueBase*>(rhs);\n    }\n    inline const WGPURenderBundleImpl* ToAPI(const RenderBundleBase* rhs) {\n        return reinterpret_cast<const WGPURenderBundleImpl*>(rhs);\n    }\n\n    inline WGPURenderBundleImpl* ToAPI(RenderBundleBase* rhs) {\n        return reinterpret_cast<WGPURenderBundleImpl*>(rhs);\n    }\n\n    inline const RenderBundleBase* FromAPI(const WGPURenderBundleImpl* rhs) {\n        return reinterpret_cast<const RenderBundleBase*>(rhs);\n    }\n\n    inline RenderBundleBase* FromAPI(WGPURenderBundleImpl* rhs) {\n        return reinterpret_cast<RenderBundleBase*>(rhs);\n    }\n    inline const WGPURenderBundleEncoderImpl* ToAPI(const RenderBundleEncoderBase* rhs) {\n        return reinterpret_cast<const WGPURenderBundleEncoderImpl*>(rhs);\n    }\n\n    inline WGPURenderBundleEncoderImpl* ToAPI(RenderBundleEncoderBase* rhs) {\n        return reinterpret_cast<WGPURenderBundleEncoderImpl*>(rhs);\n    }\n\n    inline const RenderBundleEncoderBase* FromAPI(const WGPURenderBundleEncoderImpl* rhs) {\n        return reinterpret_cast<const RenderBundleEncoderBase*>(rhs);\n    }\n\n    inline RenderBundleEncoderBase* FromAPI(WGPURenderBundleEncoderImpl* rhs) {\n        return reinterpret_cast<RenderBundleEncoderBase*>(rhs);\n    }\n    inline const WGPURenderPassEncoderImpl* ToAPI(const RenderPassEncoderBase* rhs) {\n        return reinterpret_cast<const WGPURenderPassEncoderImpl*>(rhs);\n    }\n\n    inline WGPURenderPassEncoderImpl* ToAPI(RenderPassEncoderBase* rhs) {\n        return reinterpret_cast<WGPURenderPassEncoderImpl*>(rhs);\n    }\n\n    inline const RenderPassEncoderBase* FromAPI(const WGPURenderPassEncoderImpl* rhs) {\n        return reinterpret_cast<const RenderPassEncoderBase*>(rhs);\n    }\n\n    inline RenderPassEncoderBase* FromAPI(WGPURenderPassEncoderImpl* rhs) {\n        return reinterpret_cast<RenderPassEncoderBase*>(rhs);\n    }\n    inline const WGPURenderPipelineImpl* ToAPI(const RenderPipelineBase* rhs) {\n        return reinterpret_cast<const WGPURenderPipelineImpl*>(rhs);\n    }\n\n    inline WGPURenderPipelineImpl* ToAPI(RenderPipelineBase* rhs) {\n        return reinterpret_cast<WGPURenderPipelineImpl*>(rhs);\n    }\n\n    inline const RenderPipelineBase* FromAPI(const WGPURenderPipelineImpl* rhs) {\n        return reinterpret_cast<const RenderPipelineBase*>(rhs);\n    }\n\n    inline RenderPipelineBase* FromAPI(WGPURenderPipelineImpl* rhs) {\n        return reinterpret_cast<RenderPipelineBase*>(rhs);\n    }\n    inline const WGPUSamplerImpl* ToAPI(const SamplerBase* rhs) {\n        return reinterpret_cast<const WGPUSamplerImpl*>(rhs);\n    }\n\n    inline WGPUSamplerImpl* ToAPI(SamplerBase* rhs) {\n        return reinterpret_cast<WGPUSamplerImpl*>(rhs);\n    }\n\n    inline const SamplerBase* FromAPI(const WGPUSamplerImpl* rhs) {\n        return reinterpret_cast<const SamplerBase*>(rhs);\n    }\n\n    inline SamplerBase* FromAPI(WGPUSamplerImpl* rhs) {\n        return reinterpret_cast<SamplerBase*>(rhs);\n    }\n    inline const WGPUShaderModuleImpl* ToAPI(const ShaderModuleBase* rhs) {\n        return reinterpret_cast<const WGPUShaderModuleImpl*>(rhs);\n    }\n\n    inline WGPUShaderModuleImpl* ToAPI(ShaderModuleBase* rhs) {\n        return reinterpret_cast<WGPUShaderModuleImpl*>(rhs);\n    }\n\n    inline const ShaderModuleBase* FromAPI(const WGPUShaderModuleImpl* rhs) {\n        return reinterpret_cast<const ShaderModuleBase*>(rhs);\n    }\n\n    inline ShaderModuleBase* FromAPI(WGPUShaderModuleImpl* rhs) {\n        return reinterpret_cast<ShaderModuleBase*>(rhs);\n    }\n    inline const WGPUSurfaceImpl* ToAPI(const SurfaceBase* rhs) {\n        return reinterpret_cast<const WGPUSurfaceImpl*>(rhs);\n    }\n\n    inline WGPUSurfaceImpl* ToAPI(SurfaceBase* rhs) {\n        return reinterpret_cast<WGPUSurfaceImpl*>(rhs);\n    }\n\n    inline const SurfaceBase* FromAPI(const WGPUSurfaceImpl* rhs) {\n        return reinterpret_cast<const SurfaceBase*>(rhs);\n    }\n\n    inline SurfaceBase* FromAPI(WGPUSurfaceImpl* rhs) {\n        return reinterpret_cast<SurfaceBase*>(rhs);\n    }\n    inline const WGPUSwapChainImpl* ToAPI(const SwapChainBase* rhs) {\n        return reinterpret_cast<const WGPUSwapChainImpl*>(rhs);\n    }\n\n    inline WGPUSwapChainImpl* ToAPI(SwapChainBase* rhs) {\n        return reinterpret_cast<WGPUSwapChainImpl*>(rhs);\n    }\n\n    inline const SwapChainBase* FromAPI(const WGPUSwapChainImpl* rhs) {\n        return reinterpret_cast<const SwapChainBase*>(rhs);\n    }\n\n    inline SwapChainBase* FromAPI(WGPUSwapChainImpl* rhs) {\n        return reinterpret_cast<SwapChainBase*>(rhs);\n    }\n    inline const WGPUTextureImpl* ToAPI(const TextureBase* rhs) {\n        return reinterpret_cast<const WGPUTextureImpl*>(rhs);\n    }\n\n    inline WGPUTextureImpl* ToAPI(TextureBase* rhs) {\n        return reinterpret_cast<WGPUTextureImpl*>(rhs);\n    }\n\n    inline const TextureBase* FromAPI(const WGPUTextureImpl* rhs) {\n        return reinterpret_cast<const TextureBase*>(rhs);\n    }\n\n    inline TextureBase* FromAPI(WGPUTextureImpl* rhs) {\n        return reinterpret_cast<TextureBase*>(rhs);\n    }\n    inline const WGPUTextureViewImpl* ToAPI(const TextureViewBase* rhs) {\n        return reinterpret_cast<const WGPUTextureViewImpl*>(rhs);\n    }\n\n    inline WGPUTextureViewImpl* ToAPI(TextureViewBase* rhs) {\n        return reinterpret_cast<WGPUTextureViewImpl*>(rhs);\n    }\n\n    inline const TextureViewBase* FromAPI(const WGPUTextureViewImpl* rhs) {\n        return reinterpret_cast<const TextureViewBase*>(rhs);\n    }\n\n    inline TextureViewBase* FromAPI(WGPUTextureViewImpl* rhs) {\n        return reinterpret_cast<TextureViewBase*>(rhs);\n    }\n\n    template <typename T>\n    struct EnumCount;\n\n    template<>\n    struct EnumCount<wgpu::AdapterType> {\n        static constexpr uint32_t value = 4;\n    };\n    template<>\n    struct EnumCount<wgpu::AddressMode> {\n        static constexpr uint32_t value = 3;\n    };\n    template<>\n    struct EnumCount<wgpu::AlphaMode> {\n        static constexpr uint32_t value = 3;\n    };\n    template<>\n    struct EnumCount<wgpu::BackendType> {\n        static constexpr uint32_t value = 9;\n    };\n    template<>\n    struct EnumCount<wgpu::BlendFactor> {\n        static constexpr uint32_t value = 13;\n    };\n    template<>\n    struct EnumCount<wgpu::BlendOperation> {\n        static constexpr uint32_t value = 5;\n    };\n    template<>\n    struct EnumCount<wgpu::BufferBindingType> {\n        static constexpr uint32_t value = 4;\n    };\n    template<>\n    struct EnumCount<wgpu::BufferMapAsyncStatus> {\n        static constexpr uint32_t value = 9;\n    };\n    template<>\n    struct EnumCount<wgpu::BufferMapState> {\n        static constexpr uint32_t value = 3;\n    };\n    template<>\n    struct EnumCount<wgpu::CompareFunction> {\n        static constexpr uint32_t value = 9;\n    };\n    template<>\n    struct EnumCount<wgpu::CompilationInfoRequestStatus> {\n        static constexpr uint32_t value = 4;\n    };\n    template<>\n    struct EnumCount<wgpu::CompilationMessageType> {\n        static constexpr uint32_t value = 3;\n    };\n    template<>\n    struct EnumCount<wgpu::ComputePassTimestampLocation> {\n        static constexpr uint32_t value = 2;\n    };\n    template<>\n    struct EnumCount<wgpu::CreatePipelineAsyncStatus> {\n        static constexpr uint32_t value = 6;\n    };\n    template<>\n    struct EnumCount<wgpu::CullMode> {\n        static constexpr uint32_t value = 3;\n    };\n    template<>\n    struct EnumCount<wgpu::DeviceLostReason> {\n        static constexpr uint32_t value = 2;\n    };\n    template<>\n    struct EnumCount<wgpu::ErrorFilter> {\n        static constexpr uint32_t value = 3;\n    };\n    template<>\n    struct EnumCount<wgpu::ErrorType> {\n        static constexpr uint32_t value = 6;\n    };\n    template<>\n    struct EnumCount<wgpu::ExternalTextureRotation> {\n        static constexpr uint32_t value = 4;\n    };\n    template<>\n    struct EnumCount<wgpu::FilterMode> {\n        static constexpr uint32_t value = 2;\n    };\n    template<>\n    struct EnumCount<wgpu::FrontFace> {\n        static constexpr uint32_t value = 2;\n    };\n    template<>\n    struct EnumCount<wgpu::IndexFormat> {\n        static constexpr uint32_t value = 3;\n    };\n    template<>\n    struct EnumCount<wgpu::LoadOp> {\n        static constexpr uint32_t value = 3;\n    };\n    template<>\n    struct EnumCount<wgpu::LoggingType> {\n        static constexpr uint32_t value = 4;\n    };\n    template<>\n    struct EnumCount<wgpu::MipmapFilterMode> {\n        static constexpr uint32_t value = 2;\n    };\n    template<>\n    struct EnumCount<wgpu::PipelineStatisticName> {\n        static constexpr uint32_t value = 5;\n    };\n    template<>\n    struct EnumCount<wgpu::PowerPreference> {\n        static constexpr uint32_t value = 3;\n    };\n    template<>\n    struct EnumCount<wgpu::PresentMode> {\n        static constexpr uint32_t value = 3;\n    };\n    template<>\n    struct EnumCount<wgpu::PrimitiveTopology> {\n        static constexpr uint32_t value = 5;\n    };\n    template<>\n    struct EnumCount<wgpu::QueryType> {\n        static constexpr uint32_t value = 3;\n    };\n    template<>\n    struct EnumCount<wgpu::QueueWorkDoneStatus> {\n        static constexpr uint32_t value = 4;\n    };\n    template<>\n    struct EnumCount<wgpu::RenderPassTimestampLocation> {\n        static constexpr uint32_t value = 2;\n    };\n    template<>\n    struct EnumCount<wgpu::RequestAdapterStatus> {\n        static constexpr uint32_t value = 4;\n    };\n    template<>\n    struct EnumCount<wgpu::RequestDeviceStatus> {\n        static constexpr uint32_t value = 3;\n    };\n    template<>\n    struct EnumCount<wgpu::SamplerBindingType> {\n        static constexpr uint32_t value = 4;\n    };\n    template<>\n    struct EnumCount<wgpu::StencilOperation> {\n        static constexpr uint32_t value = 8;\n    };\n    template<>\n    struct EnumCount<wgpu::StorageTextureAccess> {\n        static constexpr uint32_t value = 2;\n    };\n    template<>\n    struct EnumCount<wgpu::StoreOp> {\n        static constexpr uint32_t value = 3;\n    };\n    template<>\n    struct EnumCount<wgpu::TextureAspect> {\n        static constexpr uint32_t value = 5;\n    };\n    template<>\n    struct EnumCount<wgpu::TextureDimension> {\n        static constexpr uint32_t value = 3;\n    };\n    template<>\n    struct EnumCount<wgpu::TextureFormat> {\n        static constexpr uint32_t value = 96;\n    };\n    template<>\n    struct EnumCount<wgpu::TextureSampleType> {\n        static constexpr uint32_t value = 6;\n    };\n    template<>\n    struct EnumCount<wgpu::TextureViewDimension> {\n        static constexpr uint32_t value = 7;\n    };\n    template<>\n    struct EnumCount<wgpu::VertexFormat> {\n        static constexpr uint32_t value = 31;\n    };\n    template<>\n    struct EnumCount<wgpu::VertexStepMode> {\n        static constexpr uint32_t value = 3;\n    };\n\n    inline WGPUAdapterType ToAPI(wgpu::AdapterType rhs) {\n        return static_cast<WGPUAdapterType>(rhs);\n    }\n\n    inline wgpu::AdapterType FromAPI(WGPUAdapterType rhs) {\n        return static_cast<wgpu::AdapterType>(rhs);\n    }\n    inline WGPUAddressMode ToAPI(wgpu::AddressMode rhs) {\n        return static_cast<WGPUAddressMode>(rhs);\n    }\n\n    inline wgpu::AddressMode FromAPI(WGPUAddressMode rhs) {\n        return static_cast<wgpu::AddressMode>(rhs);\n    }\n    inline WGPUAlphaMode ToAPI(wgpu::AlphaMode rhs) {\n        return static_cast<WGPUAlphaMode>(rhs);\n    }\n\n    inline wgpu::AlphaMode FromAPI(WGPUAlphaMode rhs) {\n        return static_cast<wgpu::AlphaMode>(rhs);\n    }\n    inline WGPUBackendType ToAPI(wgpu::BackendType rhs) {\n        return static_cast<WGPUBackendType>(rhs);\n    }\n\n    inline wgpu::BackendType FromAPI(WGPUBackendType rhs) {\n        return static_cast<wgpu::BackendType>(rhs);\n    }\n    inline WGPUBlendFactor ToAPI(wgpu::BlendFactor rhs) {\n        return static_cast<WGPUBlendFactor>(rhs);\n    }\n\n    inline wgpu::BlendFactor FromAPI(WGPUBlendFactor rhs) {\n        return static_cast<wgpu::BlendFactor>(rhs);\n    }\n    inline WGPUBlendOperation ToAPI(wgpu::BlendOperation rhs) {\n        return static_cast<WGPUBlendOperation>(rhs);\n    }\n\n    inline wgpu::BlendOperation FromAPI(WGPUBlendOperation rhs) {\n        return static_cast<wgpu::BlendOperation>(rhs);\n    }\n    inline WGPUBufferBindingType ToAPI(wgpu::BufferBindingType rhs) {\n        return static_cast<WGPUBufferBindingType>(rhs);\n    }\n\n    inline wgpu::BufferBindingType FromAPI(WGPUBufferBindingType rhs) {\n        return static_cast<wgpu::BufferBindingType>(rhs);\n    }\n    inline WGPUBufferMapAsyncStatus ToAPI(wgpu::BufferMapAsyncStatus rhs) {\n        return static_cast<WGPUBufferMapAsyncStatus>(rhs);\n    }\n\n    inline wgpu::BufferMapAsyncStatus FromAPI(WGPUBufferMapAsyncStatus rhs) {\n        return static_cast<wgpu::BufferMapAsyncStatus>(rhs);\n    }\n    inline WGPUBufferMapState ToAPI(wgpu::BufferMapState rhs) {\n        return static_cast<WGPUBufferMapState>(rhs);\n    }\n\n    inline wgpu::BufferMapState FromAPI(WGPUBufferMapState rhs) {\n        return static_cast<wgpu::BufferMapState>(rhs);\n    }\n    inline WGPUCompareFunction ToAPI(wgpu::CompareFunction rhs) {\n        return static_cast<WGPUCompareFunction>(rhs);\n    }\n\n    inline wgpu::CompareFunction FromAPI(WGPUCompareFunction rhs) {\n        return static_cast<wgpu::CompareFunction>(rhs);\n    }\n    inline WGPUCompilationInfoRequestStatus ToAPI(wgpu::CompilationInfoRequestStatus rhs) {\n        return static_cast<WGPUCompilationInfoRequestStatus>(rhs);\n    }\n\n    inline wgpu::CompilationInfoRequestStatus FromAPI(WGPUCompilationInfoRequestStatus rhs) {\n        return static_cast<wgpu::CompilationInfoRequestStatus>(rhs);\n    }\n    inline WGPUCompilationMessageType ToAPI(wgpu::CompilationMessageType rhs) {\n        return static_cast<WGPUCompilationMessageType>(rhs);\n    }\n\n    inline wgpu::CompilationMessageType FromAPI(WGPUCompilationMessageType rhs) {\n        return static_cast<wgpu::CompilationMessageType>(rhs);\n    }\n    inline WGPUComputePassTimestampLocation ToAPI(wgpu::ComputePassTimestampLocation rhs) {\n        return static_cast<WGPUComputePassTimestampLocation>(rhs);\n    }\n\n    inline wgpu::ComputePassTimestampLocation FromAPI(WGPUComputePassTimestampLocation rhs) {\n        return static_cast<wgpu::ComputePassTimestampLocation>(rhs);\n    }\n    inline WGPUCreatePipelineAsyncStatus ToAPI(wgpu::CreatePipelineAsyncStatus rhs) {\n        return static_cast<WGPUCreatePipelineAsyncStatus>(rhs);\n    }\n\n    inline wgpu::CreatePipelineAsyncStatus FromAPI(WGPUCreatePipelineAsyncStatus rhs) {\n        return static_cast<wgpu::CreatePipelineAsyncStatus>(rhs);\n    }\n    inline WGPUCullMode ToAPI(wgpu::CullMode rhs) {\n        return static_cast<WGPUCullMode>(rhs);\n    }\n\n    inline wgpu::CullMode FromAPI(WGPUCullMode rhs) {\n        return static_cast<wgpu::CullMode>(rhs);\n    }\n    inline WGPUDeviceLostReason ToAPI(wgpu::DeviceLostReason rhs) {\n        return static_cast<WGPUDeviceLostReason>(rhs);\n    }\n\n    inline wgpu::DeviceLostReason FromAPI(WGPUDeviceLostReason rhs) {\n        return static_cast<wgpu::DeviceLostReason>(rhs);\n    }\n    inline WGPUErrorFilter ToAPI(wgpu::ErrorFilter rhs) {\n        return static_cast<WGPUErrorFilter>(rhs);\n    }\n\n    inline wgpu::ErrorFilter FromAPI(WGPUErrorFilter rhs) {\n        return static_cast<wgpu::ErrorFilter>(rhs);\n    }\n    inline WGPUErrorType ToAPI(wgpu::ErrorType rhs) {\n        return static_cast<WGPUErrorType>(rhs);\n    }\n\n    inline wgpu::ErrorType FromAPI(WGPUErrorType rhs) {\n        return static_cast<wgpu::ErrorType>(rhs);\n    }\n    inline WGPUExternalTextureRotation ToAPI(wgpu::ExternalTextureRotation rhs) {\n        return static_cast<WGPUExternalTextureRotation>(rhs);\n    }\n\n    inline wgpu::ExternalTextureRotation FromAPI(WGPUExternalTextureRotation rhs) {\n        return static_cast<wgpu::ExternalTextureRotation>(rhs);\n    }\n    inline WGPUFeatureName ToAPI(wgpu::FeatureName rhs) {\n        return static_cast<WGPUFeatureName>(rhs);\n    }\n\n    inline wgpu::FeatureName FromAPI(WGPUFeatureName rhs) {\n        return static_cast<wgpu::FeatureName>(rhs);\n    }\n    inline WGPUFilterMode ToAPI(wgpu::FilterMode rhs) {\n        return static_cast<WGPUFilterMode>(rhs);\n    }\n\n    inline wgpu::FilterMode FromAPI(WGPUFilterMode rhs) {\n        return static_cast<wgpu::FilterMode>(rhs);\n    }\n    inline WGPUFrontFace ToAPI(wgpu::FrontFace rhs) {\n        return static_cast<WGPUFrontFace>(rhs);\n    }\n\n    inline wgpu::FrontFace FromAPI(WGPUFrontFace rhs) {\n        return static_cast<wgpu::FrontFace>(rhs);\n    }\n    inline WGPUIndexFormat ToAPI(wgpu::IndexFormat rhs) {\n        return static_cast<WGPUIndexFormat>(rhs);\n    }\n\n    inline wgpu::IndexFormat FromAPI(WGPUIndexFormat rhs) {\n        return static_cast<wgpu::IndexFormat>(rhs);\n    }\n    inline WGPULoadOp ToAPI(wgpu::LoadOp rhs) {\n        return static_cast<WGPULoadOp>(rhs);\n    }\n\n    inline wgpu::LoadOp FromAPI(WGPULoadOp rhs) {\n        return static_cast<wgpu::LoadOp>(rhs);\n    }\n    inline WGPULoggingType ToAPI(wgpu::LoggingType rhs) {\n        return static_cast<WGPULoggingType>(rhs);\n    }\n\n    inline wgpu::LoggingType FromAPI(WGPULoggingType rhs) {\n        return static_cast<wgpu::LoggingType>(rhs);\n    }\n    inline WGPUMipmapFilterMode ToAPI(wgpu::MipmapFilterMode rhs) {\n        return static_cast<WGPUMipmapFilterMode>(rhs);\n    }\n\n    inline wgpu::MipmapFilterMode FromAPI(WGPUMipmapFilterMode rhs) {\n        return static_cast<wgpu::MipmapFilterMode>(rhs);\n    }\n    inline WGPUPipelineStatisticName ToAPI(wgpu::PipelineStatisticName rhs) {\n        return static_cast<WGPUPipelineStatisticName>(rhs);\n    }\n\n    inline wgpu::PipelineStatisticName FromAPI(WGPUPipelineStatisticName rhs) {\n        return static_cast<wgpu::PipelineStatisticName>(rhs);\n    }\n    inline WGPUPowerPreference ToAPI(wgpu::PowerPreference rhs) {\n        return static_cast<WGPUPowerPreference>(rhs);\n    }\n\n    inline wgpu::PowerPreference FromAPI(WGPUPowerPreference rhs) {\n        return static_cast<wgpu::PowerPreference>(rhs);\n    }\n    inline WGPUPresentMode ToAPI(wgpu::PresentMode rhs) {\n        return static_cast<WGPUPresentMode>(rhs);\n    }\n\n    inline wgpu::PresentMode FromAPI(WGPUPresentMode rhs) {\n        return static_cast<wgpu::PresentMode>(rhs);\n    }\n    inline WGPUPrimitiveTopology ToAPI(wgpu::PrimitiveTopology rhs) {\n        return static_cast<WGPUPrimitiveTopology>(rhs);\n    }\n\n    inline wgpu::PrimitiveTopology FromAPI(WGPUPrimitiveTopology rhs) {\n        return static_cast<wgpu::PrimitiveTopology>(rhs);\n    }\n    inline WGPUQueryType ToAPI(wgpu::QueryType rhs) {\n        return static_cast<WGPUQueryType>(rhs);\n    }\n\n    inline wgpu::QueryType FromAPI(WGPUQueryType rhs) {\n        return static_cast<wgpu::QueryType>(rhs);\n    }\n    inline WGPUQueueWorkDoneStatus ToAPI(wgpu::QueueWorkDoneStatus rhs) {\n        return static_cast<WGPUQueueWorkDoneStatus>(rhs);\n    }\n\n    inline wgpu::QueueWorkDoneStatus FromAPI(WGPUQueueWorkDoneStatus rhs) {\n        return static_cast<wgpu::QueueWorkDoneStatus>(rhs);\n    }\n    inline WGPURenderPassTimestampLocation ToAPI(wgpu::RenderPassTimestampLocation rhs) {\n        return static_cast<WGPURenderPassTimestampLocation>(rhs);\n    }\n\n    inline wgpu::RenderPassTimestampLocation FromAPI(WGPURenderPassTimestampLocation rhs) {\n        return static_cast<wgpu::RenderPassTimestampLocation>(rhs);\n    }\n    inline WGPURequestAdapterStatus ToAPI(wgpu::RequestAdapterStatus rhs) {\n        return static_cast<WGPURequestAdapterStatus>(rhs);\n    }\n\n    inline wgpu::RequestAdapterStatus FromAPI(WGPURequestAdapterStatus rhs) {\n        return static_cast<wgpu::RequestAdapterStatus>(rhs);\n    }\n    inline WGPURequestDeviceStatus ToAPI(wgpu::RequestDeviceStatus rhs) {\n        return static_cast<WGPURequestDeviceStatus>(rhs);\n    }\n\n    inline wgpu::RequestDeviceStatus FromAPI(WGPURequestDeviceStatus rhs) {\n        return static_cast<wgpu::RequestDeviceStatus>(rhs);\n    }\n    inline WGPUSType ToAPI(wgpu::SType rhs) {\n        return static_cast<WGPUSType>(rhs);\n    }\n\n    inline wgpu::SType FromAPI(WGPUSType rhs) {\n        return static_cast<wgpu::SType>(rhs);\n    }\n    inline WGPUSamplerBindingType ToAPI(wgpu::SamplerBindingType rhs) {\n        return static_cast<WGPUSamplerBindingType>(rhs);\n    }\n\n    inline wgpu::SamplerBindingType FromAPI(WGPUSamplerBindingType rhs) {\n        return static_cast<wgpu::SamplerBindingType>(rhs);\n    }\n    inline WGPUStencilOperation ToAPI(wgpu::StencilOperation rhs) {\n        return static_cast<WGPUStencilOperation>(rhs);\n    }\n\n    inline wgpu::StencilOperation FromAPI(WGPUStencilOperation rhs) {\n        return static_cast<wgpu::StencilOperation>(rhs);\n    }\n    inline WGPUStorageTextureAccess ToAPI(wgpu::StorageTextureAccess rhs) {\n        return static_cast<WGPUStorageTextureAccess>(rhs);\n    }\n\n    inline wgpu::StorageTextureAccess FromAPI(WGPUStorageTextureAccess rhs) {\n        return static_cast<wgpu::StorageTextureAccess>(rhs);\n    }\n    inline WGPUStoreOp ToAPI(wgpu::StoreOp rhs) {\n        return static_cast<WGPUStoreOp>(rhs);\n    }\n\n    inline wgpu::StoreOp FromAPI(WGPUStoreOp rhs) {\n        return static_cast<wgpu::StoreOp>(rhs);\n    }\n    inline WGPUTextureAspect ToAPI(wgpu::TextureAspect rhs) {\n        return static_cast<WGPUTextureAspect>(rhs);\n    }\n\n    inline wgpu::TextureAspect FromAPI(WGPUTextureAspect rhs) {\n        return static_cast<wgpu::TextureAspect>(rhs);\n    }\n    inline WGPUTextureDimension ToAPI(wgpu::TextureDimension rhs) {\n        return static_cast<WGPUTextureDimension>(rhs);\n    }\n\n    inline wgpu::TextureDimension FromAPI(WGPUTextureDimension rhs) {\n        return static_cast<wgpu::TextureDimension>(rhs);\n    }\n    inline WGPUTextureFormat ToAPI(wgpu::TextureFormat rhs) {\n        return static_cast<WGPUTextureFormat>(rhs);\n    }\n\n    inline wgpu::TextureFormat FromAPI(WGPUTextureFormat rhs) {\n        return static_cast<wgpu::TextureFormat>(rhs);\n    }\n    inline WGPUTextureSampleType ToAPI(wgpu::TextureSampleType rhs) {\n        return static_cast<WGPUTextureSampleType>(rhs);\n    }\n\n    inline wgpu::TextureSampleType FromAPI(WGPUTextureSampleType rhs) {\n        return static_cast<wgpu::TextureSampleType>(rhs);\n    }\n    inline WGPUTextureViewDimension ToAPI(wgpu::TextureViewDimension rhs) {\n        return static_cast<WGPUTextureViewDimension>(rhs);\n    }\n\n    inline wgpu::TextureViewDimension FromAPI(WGPUTextureViewDimension rhs) {\n        return static_cast<wgpu::TextureViewDimension>(rhs);\n    }\n    inline WGPUVertexFormat ToAPI(wgpu::VertexFormat rhs) {\n        return static_cast<WGPUVertexFormat>(rhs);\n    }\n\n    inline wgpu::VertexFormat FromAPI(WGPUVertexFormat rhs) {\n        return static_cast<wgpu::VertexFormat>(rhs);\n    }\n    inline WGPUVertexStepMode ToAPI(wgpu::VertexStepMode rhs) {\n        return static_cast<WGPUVertexStepMode>(rhs);\n    }\n\n    inline wgpu::VertexStepMode FromAPI(WGPUVertexStepMode rhs) {\n        return static_cast<wgpu::VertexStepMode>(rhs);\n    }\n    inline WGPUBufferUsage ToAPI(wgpu::BufferUsage rhs) {\n        return static_cast<WGPUBufferUsage>(rhs);\n    }\n\n    inline wgpu::BufferUsage FromAPI(WGPUBufferUsage rhs) {\n        return static_cast<wgpu::BufferUsage>(rhs);\n    }\n    inline WGPUColorWriteMask ToAPI(wgpu::ColorWriteMask rhs) {\n        return static_cast<WGPUColorWriteMask>(rhs);\n    }\n\n    inline wgpu::ColorWriteMask FromAPI(WGPUColorWriteMask rhs) {\n        return static_cast<wgpu::ColorWriteMask>(rhs);\n    }\n    inline WGPUMapMode ToAPI(wgpu::MapMode rhs) {\n        return static_cast<WGPUMapMode>(rhs);\n    }\n\n    inline wgpu::MapMode FromAPI(WGPUMapMode rhs) {\n        return static_cast<wgpu::MapMode>(rhs);\n    }\n    inline WGPUShaderStage ToAPI(wgpu::ShaderStage rhs) {\n        return static_cast<WGPUShaderStage>(rhs);\n    }\n\n    inline wgpu::ShaderStage FromAPI(WGPUShaderStage rhs) {\n        return static_cast<wgpu::ShaderStage>(rhs);\n    }\n    inline WGPUTextureUsage ToAPI(wgpu::TextureUsage rhs) {\n        return static_cast<WGPUTextureUsage>(rhs);\n    }\n\n    inline wgpu::TextureUsage FromAPI(WGPUTextureUsage rhs) {\n        return static_cast<wgpu::TextureUsage>(rhs);\n    }\n}  // namespace dawn::native\n\n#endif  // DAWNNATIVE_DAWN_PLATFORM_AUTOGEN_H_\n", "src/dawn/native/wgpu_structs_autogen.h": "\n#ifndef DAWNNATIVE_WGPU_STRUCTS_H_\n#define DAWNNATIVE_WGPU_STRUCTS_H_\n\n#include \"dawn/webgpu_cpp.h\"\n#include \"dawn/native/Forward.h\"\n#include <cmath>\n\nnamespace dawn::native {\n\n\n    using wgpu::ChainedStruct;\n    using wgpu::ChainedStructOut;\n\n    struct AdapterProperties {\n        ChainedStructOut * nextInChain = nullptr;\n        uint32_t vendorID;\n        char const * vendorName;\n        char const * architecture;\n        uint32_t deviceID;\n        char const * name;\n        char const * driverDescription;\n        wgpu::AdapterType adapterType;\n        wgpu::BackendType backendType;\n        bool compatibilityMode = false;\n\n        // Equality operators, mostly for testing. Note that this tests\n        // strict pointer-pointer equality if the struct contains member pointers.\n        bool operator==(const AdapterProperties& rhs) const;\n    };\n\n    struct BindGroupEntry {\n        ChainedStruct const * nextInChain = nullptr;\n        uint32_t binding;\n        BufferBase* buffer = nullptr;\n        uint64_t offset = 0;\n        uint64_t size = WGPU_WHOLE_SIZE;\n        SamplerBase* sampler = nullptr;\n        TextureViewBase* textureView = nullptr;\n\n        // Equality operators, mostly for testing. Note that this tests\n        // strict pointer-pointer equality if the struct contains member pointers.\n        bool operator==(const BindGroupEntry& rhs) const;\n    };\n\n    struct BlendComponent {\n        wgpu::BlendOperation operation = wgpu::BlendOperation::Add;\n        wgpu::BlendFactor srcFactor = wgpu::BlendFactor::One;\n        wgpu::BlendFactor dstFactor = wgpu::BlendFactor::Zero;\n\n        // Equality operators, mostly for testing. Note that this tests\n        // strict pointer-pointer equality if the struct contains member pointers.\n        bool operator==(const BlendComponent& rhs) const;\n    };\n\n    struct BufferBindingLayout {\n        ChainedStruct const * nextInChain = nullptr;\n        wgpu::BufferBindingType type = wgpu::BufferBindingType::Undefined;\n        bool hasDynamicOffset = false;\n        uint64_t minBindingSize = 0;\n\n        // Equality operators, mostly for testing. Note that this tests\n        // strict pointer-pointer equality if the struct contains member pointers.\n        bool operator==(const BufferBindingLayout& rhs) const;\n    };\n\n    struct BufferDescriptor {\n        ChainedStruct const * nextInChain = nullptr;\n        char const * label = nullptr;\n        wgpu::BufferUsage usage;\n        uint64_t size;\n        bool mappedAtCreation = false;\n\n        // Equality operators, mostly for testing. Note that this tests\n        // strict pointer-pointer equality if the struct contains member pointers.\n        bool operator==(const BufferDescriptor& rhs) const;\n    };\n\n    struct Color {\n        double r;\n        double g;\n        double b;\n        double a;\n\n        // Equality operators, mostly for testing. Note that this tests\n        // strict pointer-pointer equality if the struct contains member pointers.\n        bool operator==(const Color& rhs) const;\n    };\n\n    struct CommandBufferDescriptor {\n        ChainedStruct const * nextInChain = nullptr;\n        char const * label = nullptr;\n\n        // Equality operators, mostly for testing. Note that this tests\n        // strict pointer-pointer equality if the struct contains member pointers.\n        bool operator==(const CommandBufferDescriptor& rhs) const;\n    };\n\n    struct CommandEncoderDescriptor {\n        ChainedStruct const * nextInChain = nullptr;\n        char const * label = nullptr;\n\n        // Equality operators, mostly for testing. Note that this tests\n        // strict pointer-pointer equality if the struct contains member pointers.\n        bool operator==(const CommandEncoderDescriptor& rhs) const;\n    };\n\n    struct CompilationMessage {\n        ChainedStruct const * nextInChain = nullptr;\n        char const * message = nullptr;\n        wgpu::CompilationMessageType type;\n        uint64_t lineNum;\n        uint64_t linePos;\n        uint64_t offset;\n        uint64_t length;\n        uint64_t utf16LinePos;\n        uint64_t utf16Offset;\n        uint64_t utf16Length;\n\n        // Equality operators, mostly for testing. Note that this tests\n        // strict pointer-pointer equality if the struct contains member pointers.\n        bool operator==(const CompilationMessage& rhs) const;\n    };\n\n    struct ComputePassTimestampWrite {\n        QuerySetBase* querySet;\n        uint32_t queryIndex;\n        wgpu::ComputePassTimestampLocation location;\n\n        // Equality operators, mostly for testing. Note that this tests\n        // strict pointer-pointer equality if the struct contains member pointers.\n        bool operator==(const ComputePassTimestampWrite& rhs) const;\n    };\n\n    struct ConstantEntry {\n        ChainedStruct const * nextInChain = nullptr;\n        char const * key;\n        double value;\n\n        // Equality operators, mostly for testing. Note that this tests\n        // strict pointer-pointer equality if the struct contains member pointers.\n        bool operator==(const ConstantEntry& rhs) const;\n    };\n\n    struct CopyTextureForBrowserOptions {\n        ChainedStruct const * nextInChain = nullptr;\n        bool flipY = false;\n        bool needsColorSpaceConversion = false;\n        wgpu::AlphaMode srcAlphaMode = wgpu::AlphaMode::Unpremultiplied;\n        float const * srcTransferFunctionParameters = nullptr;\n        float const * conversionMatrix = nullptr;\n        float const * dstTransferFunctionParameters = nullptr;\n        wgpu::AlphaMode dstAlphaMode = wgpu::AlphaMode::Unpremultiplied;\n        bool internalUsage = false;\n\n        // Equality operators, mostly for testing. Note that this tests\n        // strict pointer-pointer equality if the struct contains member pointers.\n        bool operator==(const CopyTextureForBrowserOptions& rhs) const;\n    };\n\n    struct DawnAdapterPropertiesPowerPreference : ChainedStructOut {\n        DawnAdapterPropertiesPowerPreference() {\n            sType = wgpu::SType::DawnAdapterPropertiesPowerPreference;\n        }\n        alignas(wgpu::DawnAdapterPropertiesPowerPreference::kFirstMemberAlignment) wgpu::PowerPreference powerPreference = wgpu::PowerPreference::Undefined;\n\n        // Equality operators, mostly for testing. Note that this tests\n        // strict pointer-pointer equality if the struct contains member pointers.\n        bool operator==(const DawnAdapterPropertiesPowerPreference& rhs) const;\n    };\n\n    struct DawnBufferDescriptorErrorInfoFromWireClient : ChainedStruct {\n        DawnBufferDescriptorErrorInfoFromWireClient() {\n            sType = wgpu::SType::DawnBufferDescriptorErrorInfoFromWireClient;\n        }\n        alignas(wgpu::DawnBufferDescriptorErrorInfoFromWireClient::kFirstMemberAlignment) bool outOfMemory = false;\n\n        // Equality operators, mostly for testing. Note that this tests\n        // strict pointer-pointer equality if the struct contains member pointers.\n        bool operator==(const DawnBufferDescriptorErrorInfoFromWireClient& rhs) const;\n    };\n\n    struct DawnCacheDeviceDescriptor : ChainedStruct {\n        DawnCacheDeviceDescriptor() {\n            sType = wgpu::SType::DawnCacheDeviceDescriptor;\n        }\n        alignas(wgpu::DawnCacheDeviceDescriptor::kFirstMemberAlignment) char const * isolationKey = \"\";\n\n        // Equality operators, mostly for testing. Note that this tests\n        // strict pointer-pointer equality if the struct contains member pointers.\n        bool operator==(const DawnCacheDeviceDescriptor& rhs) const;\n    };\n\n    struct DawnEncoderInternalUsageDescriptor : ChainedStruct {\n        DawnEncoderInternalUsageDescriptor() {\n            sType = wgpu::SType::DawnEncoderInternalUsageDescriptor;\n        }\n        alignas(wgpu::DawnEncoderInternalUsageDescriptor::kFirstMemberAlignment) bool useInternalUsages = false;\n\n        // Equality operators, mostly for testing. Note that this tests\n        // strict pointer-pointer equality if the struct contains member pointers.\n        bool operator==(const DawnEncoderInternalUsageDescriptor& rhs) const;\n    };\n\n    struct DawnMultisampleStateRenderToSingleSampled : ChainedStruct {\n        DawnMultisampleStateRenderToSingleSampled() {\n            sType = wgpu::SType::DawnMultisampleStateRenderToSingleSampled;\n        }\n        alignas(wgpu::DawnMultisampleStateRenderToSingleSampled::kFirstMemberAlignment) bool enabled = false;\n\n        // Equality operators, mostly for testing. Note that this tests\n        // strict pointer-pointer equality if the struct contains member pointers.\n        bool operator==(const DawnMultisampleStateRenderToSingleSampled& rhs) const;\n    };\n\n    struct DawnRenderPassColorAttachmentRenderToSingleSampled : ChainedStruct {\n        DawnRenderPassColorAttachmentRenderToSingleSampled() {\n            sType = wgpu::SType::DawnRenderPassColorAttachmentRenderToSingleSampled;\n        }\n        alignas(wgpu::DawnRenderPassColorAttachmentRenderToSingleSampled::kFirstMemberAlignment) uint32_t implicitSampleCount = 1;\n\n        // Equality operators, mostly for testing. Note that this tests\n        // strict pointer-pointer equality if the struct contains member pointers.\n        bool operator==(const DawnRenderPassColorAttachmentRenderToSingleSampled& rhs) const;\n    };\n\n    struct DawnShaderModuleSPIRVOptionsDescriptor : ChainedStruct {\n        DawnShaderModuleSPIRVOptionsDescriptor() {\n            sType = wgpu::SType::DawnShaderModuleSPIRVOptionsDescriptor;\n        }\n        alignas(wgpu::DawnShaderModuleSPIRVOptionsDescriptor::kFirstMemberAlignment) bool allowNonUniformDerivatives = false;\n\n        // Equality operators, mostly for testing. Note that this tests\n        // strict pointer-pointer equality if the struct contains member pointers.\n        bool operator==(const DawnShaderModuleSPIRVOptionsDescriptor& rhs) const;\n    };\n\n    struct DawnTextureInternalUsageDescriptor : ChainedStruct {\n        DawnTextureInternalUsageDescriptor() {\n            sType = wgpu::SType::DawnTextureInternalUsageDescriptor;\n        }\n        alignas(wgpu::DawnTextureInternalUsageDescriptor::kFirstMemberAlignment) wgpu::TextureUsage internalUsage = wgpu::TextureUsage::None;\n\n        // Equality operators, mostly for testing. Note that this tests\n        // strict pointer-pointer equality if the struct contains member pointers.\n        bool operator==(const DawnTextureInternalUsageDescriptor& rhs) const;\n    };\n\n    struct DawnTogglesDescriptor : ChainedStruct {\n        DawnTogglesDescriptor() {\n            sType = wgpu::SType::DawnTogglesDescriptor;\n        }\n        alignas(wgpu::DawnTogglesDescriptor::kFirstMemberAlignment) size_t enabledTogglesCount = 0;\n        const char* const * enabledToggles;\n        size_t disabledTogglesCount = 0;\n        const char* const * disabledToggles;\n\n        // Equality operators, mostly for testing. Note that this tests\n        // strict pointer-pointer equality if the struct contains member pointers.\n        bool operator==(const DawnTogglesDescriptor& rhs) const;\n    };\n\n    struct Extent2D {\n        uint32_t width = 0;\n        uint32_t height = 1;\n\n        // Equality operators, mostly for testing. Note that this tests\n        // strict pointer-pointer equality if the struct contains member pointers.\n        bool operator==(const Extent2D& rhs) const;\n    };\n\n    struct Extent3D {\n        uint32_t width;\n        uint32_t height = 1;\n        uint32_t depthOrArrayLayers = 1;\n\n        // Equality operators, mostly for testing. Note that this tests\n        // strict pointer-pointer equality if the struct contains member pointers.\n        bool operator==(const Extent3D& rhs) const;\n    };\n\n    struct ExternalTextureBindingEntry : ChainedStruct {\n        ExternalTextureBindingEntry() {\n            sType = wgpu::SType::ExternalTextureBindingEntry;\n        }\n        alignas(wgpu::ExternalTextureBindingEntry::kFirstMemberAlignment) ExternalTextureBase* externalTexture;\n\n        // Equality operators, mostly for testing. Note that this tests\n        // strict pointer-pointer equality if the struct contains member pointers.\n        bool operator==(const ExternalTextureBindingEntry& rhs) const;\n    };\n\n    struct ExternalTextureBindingLayout : ChainedStruct {\n        ExternalTextureBindingLayout() {\n            sType = wgpu::SType::ExternalTextureBindingLayout;\n        }\n\n        // Equality operators, mostly for testing. Note that this tests\n        // strict pointer-pointer equality if the struct contains member pointers.\n        bool operator==(const ExternalTextureBindingLayout& rhs) const;\n    };\n\n    struct InstanceDescriptor {\n        ChainedStruct const * nextInChain = nullptr;\n\n        // Equality operators, mostly for testing. Note that this tests\n        // strict pointer-pointer equality if the struct contains member pointers.\n        bool operator==(const InstanceDescriptor& rhs) const;\n    };\n\n    struct Limits {\n        uint32_t maxTextureDimension1D = WGPU_LIMIT_U32_UNDEFINED;\n        uint32_t maxTextureDimension2D = WGPU_LIMIT_U32_UNDEFINED;\n        uint32_t maxTextureDimension3D = WGPU_LIMIT_U32_UNDEFINED;\n        uint32_t maxTextureArrayLayers = WGPU_LIMIT_U32_UNDEFINED;\n        uint32_t maxBindGroups = WGPU_LIMIT_U32_UNDEFINED;\n        uint32_t maxBindGroupsPlusVertexBuffers = WGPU_LIMIT_U32_UNDEFINED;\n        uint32_t maxBindingsPerBindGroup = WGPU_LIMIT_U32_UNDEFINED;\n        uint32_t maxDynamicUniformBuffersPerPipelineLayout = WGPU_LIMIT_U32_UNDEFINED;\n        uint32_t maxDynamicStorageBuffersPerPipelineLayout = WGPU_LIMIT_U32_UNDEFINED;\n        uint32_t maxSampledTexturesPerShaderStage = WGPU_LIMIT_U32_UNDEFINED;\n        uint32_t maxSamplersPerShaderStage = WGPU_LIMIT_U32_UNDEFINED;\n        uint32_t maxStorageBuffersPerShaderStage = WGPU_LIMIT_U32_UNDEFINED;\n        uint32_t maxStorageTexturesPerShaderStage = WGPU_LIMIT_U32_UNDEFINED;\n        uint32_t maxUniformBuffersPerShaderStage = WGPU_LIMIT_U32_UNDEFINED;\n        uint64_t maxUniformBufferBindingSize = WGPU_LIMIT_U64_UNDEFINED;\n        uint64_t maxStorageBufferBindingSize = WGPU_LIMIT_U64_UNDEFINED;\n        uint32_t minUniformBufferOffsetAlignment = WGPU_LIMIT_U32_UNDEFINED;\n        uint32_t minStorageBufferOffsetAlignment = WGPU_LIMIT_U32_UNDEFINED;\n        uint32_t maxVertexBuffers = WGPU_LIMIT_U32_UNDEFINED;\n        uint64_t maxBufferSize = WGPU_LIMIT_U64_UNDEFINED;\n        uint32_t maxVertexAttributes = WGPU_LIMIT_U32_UNDEFINED;\n        uint32_t maxVertexBufferArrayStride = WGPU_LIMIT_U32_UNDEFINED;\n        uint32_t maxInterStageShaderComponents = WGPU_LIMIT_U32_UNDEFINED;\n        uint32_t maxInterStageShaderVariables = WGPU_LIMIT_U32_UNDEFINED;\n        uint32_t maxColorAttachments = WGPU_LIMIT_U32_UNDEFINED;\n        uint32_t maxColorAttachmentBytesPerSample = WGPU_LIMIT_U32_UNDEFINED;\n        uint32_t maxComputeWorkgroupStorageSize = WGPU_LIMIT_U32_UNDEFINED;\n        uint32_t maxComputeInvocationsPerWorkgroup = WGPU_LIMIT_U32_UNDEFINED;\n        uint32_t maxComputeWorkgroupSizeX = WGPU_LIMIT_U32_UNDEFINED;\n        uint32_t maxComputeWorkgroupSizeY = WGPU_LIMIT_U32_UNDEFINED;\n        uint32_t maxComputeWorkgroupSizeZ = WGPU_LIMIT_U32_UNDEFINED;\n        uint32_t maxComputeWorkgroupsPerDimension = WGPU_LIMIT_U32_UNDEFINED;\n\n        // Equality operators, mostly for testing. Note that this tests\n        // strict pointer-pointer equality if the struct contains member pointers.\n        bool operator==(const Limits& rhs) const;\n    };\n\n    struct MultisampleState {\n        ChainedStruct const * nextInChain = nullptr;\n        uint32_t count = 1;\n        uint32_t mask = 0xFFFFFFFF;\n        bool alphaToCoverageEnabled = false;\n\n        // Equality operators, mostly for testing. Note that this tests\n        // strict pointer-pointer equality if the struct contains member pointers.\n        bool operator==(const MultisampleState& rhs) const;\n    };\n\n    struct Origin2D {\n        uint32_t x = 0;\n        uint32_t y = 0;\n\n        // Equality operators, mostly for testing. Note that this tests\n        // strict pointer-pointer equality if the struct contains member pointers.\n        bool operator==(const Origin2D& rhs) const;\n    };\n\n    struct Origin3D {\n        uint32_t x = 0;\n        uint32_t y = 0;\n        uint32_t z = 0;\n\n        // Equality operators, mostly for testing. Note that this tests\n        // strict pointer-pointer equality if the struct contains member pointers.\n        bool operator==(const Origin3D& rhs) const;\n    };\n\n    struct PipelineLayoutDescriptor {\n        ChainedStruct const * nextInChain = nullptr;\n        char const * label = nullptr;\n        size_t bindGroupLayoutCount;\n        BindGroupLayoutBase* const * bindGroupLayouts;\n\n        // Equality operators, mostly for testing. Note that this tests\n        // strict pointer-pointer equality if the struct contains member pointers.\n        bool operator==(const PipelineLayoutDescriptor& rhs) const;\n    };\n\n    struct PrimitiveDepthClipControl : ChainedStruct {\n        PrimitiveDepthClipControl() {\n            sType = wgpu::SType::PrimitiveDepthClipControl;\n        }\n        alignas(wgpu::PrimitiveDepthClipControl::kFirstMemberAlignment) bool unclippedDepth = false;\n\n        // Equality operators, mostly for testing. Note that this tests\n        // strict pointer-pointer equality if the struct contains member pointers.\n        bool operator==(const PrimitiveDepthClipControl& rhs) const;\n    };\n\n    struct PrimitiveState {\n        ChainedStruct const * nextInChain = nullptr;\n        wgpu::PrimitiveTopology topology = wgpu::PrimitiveTopology::TriangleList;\n        wgpu::IndexFormat stripIndexFormat = wgpu::IndexFormat::Undefined;\n        wgpu::FrontFace frontFace = wgpu::FrontFace::CCW;\n        wgpu::CullMode cullMode = wgpu::CullMode::None;\n\n        // Equality operators, mostly for testing. Note that this tests\n        // strict pointer-pointer equality if the struct contains member pointers.\n        bool operator==(const PrimitiveState& rhs) const;\n    };\n\n    struct QuerySetDescriptor {\n        ChainedStruct const * nextInChain = nullptr;\n        char const * label = nullptr;\n        wgpu::QueryType type;\n        uint32_t count;\n        wgpu::PipelineStatisticName const * pipelineStatistics;\n        size_t pipelineStatisticsCount = 0;\n\n        // Equality operators, mostly for testing. Note that this tests\n        // strict pointer-pointer equality if the struct contains member pointers.\n        bool operator==(const QuerySetDescriptor& rhs) const;\n    };\n\n    struct QueueDescriptor {\n        ChainedStruct const * nextInChain = nullptr;\n        char const * label = nullptr;\n\n        // Equality operators, mostly for testing. Note that this tests\n        // strict pointer-pointer equality if the struct contains member pointers.\n        bool operator==(const QueueDescriptor& rhs) const;\n    };\n\n    struct RenderBundleDescriptor {\n        ChainedStruct const * nextInChain = nullptr;\n        char const * label = nullptr;\n\n        // Equality operators, mostly for testing. Note that this tests\n        // strict pointer-pointer equality if the struct contains member pointers.\n        bool operator==(const RenderBundleDescriptor& rhs) const;\n    };\n\n    struct RenderBundleEncoderDescriptor {\n        ChainedStruct const * nextInChain = nullptr;\n        char const * label = nullptr;\n        size_t colorFormatsCount;\n        wgpu::TextureFormat const * colorFormats;\n        wgpu::TextureFormat depthStencilFormat = wgpu::TextureFormat::Undefined;\n        uint32_t sampleCount = 1;\n        bool depthReadOnly = false;\n        bool stencilReadOnly = false;\n\n        // Equality operators, mostly for testing. Note that this tests\n        // strict pointer-pointer equality if the struct contains member pointers.\n        bool operator==(const RenderBundleEncoderDescriptor& rhs) const;\n    };\n\n    struct RenderPassDepthStencilAttachment {\n        TextureViewBase* view;\n        wgpu::LoadOp depthLoadOp = wgpu::LoadOp::Undefined;\n        wgpu::StoreOp depthStoreOp = wgpu::StoreOp::Undefined;\n        float depthClearValue = NAN;\n        bool depthReadOnly = false;\n        wgpu::LoadOp stencilLoadOp = wgpu::LoadOp::Undefined;\n        wgpu::StoreOp stencilStoreOp = wgpu::StoreOp::Undefined;\n        uint32_t stencilClearValue = 0;\n        bool stencilReadOnly = false;\n\n        // Equality operators, mostly for testing. Note that this tests\n        // strict pointer-pointer equality if the struct contains member pointers.\n        bool operator==(const RenderPassDepthStencilAttachment& rhs) const;\n    };\n\n    struct RenderPassDescriptorMaxDrawCount : ChainedStruct {\n        RenderPassDescriptorMaxDrawCount() {\n            sType = wgpu::SType::RenderPassDescriptorMaxDrawCount;\n        }\n        alignas(wgpu::RenderPassDescriptorMaxDrawCount::kFirstMemberAlignment) uint64_t maxDrawCount = 50000000;\n\n        // Equality operators, mostly for testing. Note that this tests\n        // strict pointer-pointer equality if the struct contains member pointers.\n        bool operator==(const RenderPassDescriptorMaxDrawCount& rhs) const;\n    };\n\n    struct RenderPassTimestampWrite {\n        QuerySetBase* querySet;\n        uint32_t queryIndex;\n        wgpu::RenderPassTimestampLocation location;\n\n        // Equality operators, mostly for testing. Note that this tests\n        // strict pointer-pointer equality if the struct contains member pointers.\n        bool operator==(const RenderPassTimestampWrite& rhs) const;\n    };\n\n    struct RequestAdapterOptions {\n        ChainedStruct const * nextInChain = nullptr;\n        SurfaceBase* compatibleSurface = nullptr;\n        wgpu::PowerPreference powerPreference = wgpu::PowerPreference::Undefined;\n        wgpu::BackendType backendType = wgpu::BackendType::Undefined;\n        bool forceFallbackAdapter = false;\n        bool compatibilityMode = false;\n\n        // Equality operators, mostly for testing. Note that this tests\n        // strict pointer-pointer equality if the struct contains member pointers.\n        bool operator==(const RequestAdapterOptions& rhs) const;\n    };\n\n    struct SamplerBindingLayout {\n        ChainedStruct const * nextInChain = nullptr;\n        wgpu::SamplerBindingType type = wgpu::SamplerBindingType::Undefined;\n\n        // Equality operators, mostly for testing. Note that this tests\n        // strict pointer-pointer equality if the struct contains member pointers.\n        bool operator==(const SamplerBindingLayout& rhs) const;\n    };\n\n    struct SamplerDescriptor {\n        ChainedStruct const * nextInChain = nullptr;\n        char const * label = nullptr;\n        wgpu::AddressMode addressModeU = wgpu::AddressMode::ClampToEdge;\n        wgpu::AddressMode addressModeV = wgpu::AddressMode::ClampToEdge;\n        wgpu::AddressMode addressModeW = wgpu::AddressMode::ClampToEdge;\n        wgpu::FilterMode magFilter = wgpu::FilterMode::Nearest;\n        wgpu::FilterMode minFilter = wgpu::FilterMode::Nearest;\n        wgpu::MipmapFilterMode mipmapFilter = wgpu::MipmapFilterMode::Nearest;\n        float lodMinClamp = 0.0f;\n        float lodMaxClamp = 32.0f;\n        wgpu::CompareFunction compare = wgpu::CompareFunction::Undefined;\n        uint16_t maxAnisotropy = 1;\n\n        // Equality operators, mostly for testing. Note that this tests\n        // strict pointer-pointer equality if the struct contains member pointers.\n        bool operator==(const SamplerDescriptor& rhs) const;\n    };\n\n    struct ShaderModuleDescriptor {\n        ChainedStruct const * nextInChain = nullptr;\n        char const * label = nullptr;\n\n        // Equality operators, mostly for testing. Note that this tests\n        // strict pointer-pointer equality if the struct contains member pointers.\n        bool operator==(const ShaderModuleDescriptor& rhs) const;\n    };\n\n    struct ShaderModuleSPIRVDescriptor : ChainedStruct {\n        ShaderModuleSPIRVDescriptor() {\n            sType = wgpu::SType::ShaderModuleSPIRVDescriptor;\n        }\n        alignas(wgpu::ShaderModuleSPIRVDescriptor::kFirstMemberAlignment) uint32_t codeSize;\n        uint32_t const * code;\n\n        // Equality operators, mostly for testing. Note that this tests\n        // strict pointer-pointer equality if the struct contains member pointers.\n        bool operator==(const ShaderModuleSPIRVDescriptor& rhs) const;\n    };\n\n    struct ShaderModuleWGSLDescriptor : ChainedStruct {\n        ShaderModuleWGSLDescriptor() {\n            sType = wgpu::SType::ShaderModuleWGSLDescriptor;\n        }\n        alignas(wgpu::ShaderModuleWGSLDescriptor::kFirstMemberAlignment) char const * code;\n\n        // Equality operators, mostly for testing. Note that this tests\n        // strict pointer-pointer equality if the struct contains member pointers.\n        bool operator==(const ShaderModuleWGSLDescriptor& rhs) const;\n    };\n\n    struct StencilFaceState {\n        wgpu::CompareFunction compare = wgpu::CompareFunction::Always;\n        wgpu::StencilOperation failOp = wgpu::StencilOperation::Keep;\n        wgpu::StencilOperation depthFailOp = wgpu::StencilOperation::Keep;\n        wgpu::StencilOperation passOp = wgpu::StencilOperation::Keep;\n\n        // Equality operators, mostly for testing. Note that this tests\n        // strict pointer-pointer equality if the struct contains member pointers.\n        bool operator==(const StencilFaceState& rhs) const;\n    };\n\n    struct StorageTextureBindingLayout {\n        ChainedStruct const * nextInChain = nullptr;\n        wgpu::StorageTextureAccess access = wgpu::StorageTextureAccess::Undefined;\n        wgpu::TextureFormat format = wgpu::TextureFormat::Undefined;\n        wgpu::TextureViewDimension viewDimension = wgpu::TextureViewDimension::Undefined;\n\n        // Equality operators, mostly for testing. Note that this tests\n        // strict pointer-pointer equality if the struct contains member pointers.\n        bool operator==(const StorageTextureBindingLayout& rhs) const;\n    };\n\n    struct SurfaceDescriptor {\n        ChainedStruct const * nextInChain = nullptr;\n        char const * label = nullptr;\n\n        // Equality operators, mostly for testing. Note that this tests\n        // strict pointer-pointer equality if the struct contains member pointers.\n        bool operator==(const SurfaceDescriptor& rhs) const;\n    };\n\n    struct SurfaceDescriptorFromAndroidNativeWindow : ChainedStruct {\n        SurfaceDescriptorFromAndroidNativeWindow() {\n            sType = wgpu::SType::SurfaceDescriptorFromAndroidNativeWindow;\n        }\n        alignas(wgpu::SurfaceDescriptorFromAndroidNativeWindow::kFirstMemberAlignment) void * window;\n\n        // Equality operators, mostly for testing. Note that this tests\n        // strict pointer-pointer equality if the struct contains member pointers.\n        bool operator==(const SurfaceDescriptorFromAndroidNativeWindow& rhs) const;\n    };\n\n    struct SurfaceDescriptorFromCanvasHTMLSelector : ChainedStruct {\n        SurfaceDescriptorFromCanvasHTMLSelector() {\n            sType = wgpu::SType::SurfaceDescriptorFromCanvasHTMLSelector;\n        }\n        alignas(wgpu::SurfaceDescriptorFromCanvasHTMLSelector::kFirstMemberAlignment) char const * selector;\n\n        // Equality operators, mostly for testing. Note that this tests\n        // strict pointer-pointer equality if the struct contains member pointers.\n        bool operator==(const SurfaceDescriptorFromCanvasHTMLSelector& rhs) const;\n    };\n\n    struct SurfaceDescriptorFromMetalLayer : ChainedStruct {\n        SurfaceDescriptorFromMetalLayer() {\n            sType = wgpu::SType::SurfaceDescriptorFromMetalLayer;\n        }\n        alignas(wgpu::SurfaceDescriptorFromMetalLayer::kFirstMemberAlignment) void * layer;\n\n        // Equality operators, mostly for testing. Note that this tests\n        // strict pointer-pointer equality if the struct contains member pointers.\n        bool operator==(const SurfaceDescriptorFromMetalLayer& rhs) const;\n    };\n\n    struct SurfaceDescriptorFromWaylandSurface : ChainedStruct {\n        SurfaceDescriptorFromWaylandSurface() {\n            sType = wgpu::SType::SurfaceDescriptorFromWaylandSurface;\n        }\n        alignas(wgpu::SurfaceDescriptorFromWaylandSurface::kFirstMemberAlignment) void * display;\n        void * surface;\n\n        // Equality operators, mostly for testing. Note that this tests\n        // strict pointer-pointer equality if the struct contains member pointers.\n        bool operator==(const SurfaceDescriptorFromWaylandSurface& rhs) const;\n    };\n\n    struct SurfaceDescriptorFromWindowsCoreWindow : ChainedStruct {\n        SurfaceDescriptorFromWindowsCoreWindow() {\n            sType = wgpu::SType::SurfaceDescriptorFromWindowsCoreWindow;\n        }\n        alignas(wgpu::SurfaceDescriptorFromWindowsCoreWindow::kFirstMemberAlignment) void * coreWindow;\n\n        // Equality operators, mostly for testing. Note that this tests\n        // strict pointer-pointer equality if the struct contains member pointers.\n        bool operator==(const SurfaceDescriptorFromWindowsCoreWindow& rhs) const;\n    };\n\n    struct SurfaceDescriptorFromWindowsHWND : ChainedStruct {\n        SurfaceDescriptorFromWindowsHWND() {\n            sType = wgpu::SType::SurfaceDescriptorFromWindowsHWND;\n        }\n        alignas(wgpu::SurfaceDescriptorFromWindowsHWND::kFirstMemberAlignment) void * hinstance;\n        void * hwnd;\n\n        // Equality operators, mostly for testing. Note that this tests\n        // strict pointer-pointer equality if the struct contains member pointers.\n        bool operator==(const SurfaceDescriptorFromWindowsHWND& rhs) const;\n    };\n\n    struct SurfaceDescriptorFromWindowsSwapChainPanel : ChainedStruct {\n        SurfaceDescriptorFromWindowsSwapChainPanel() {\n            sType = wgpu::SType::SurfaceDescriptorFromWindowsSwapChainPanel;\n        }\n        alignas(wgpu::SurfaceDescriptorFromWindowsSwapChainPanel::kFirstMemberAlignment) void * swapChainPanel;\n\n        // Equality operators, mostly for testing. Note that this tests\n        // strict pointer-pointer equality if the struct contains member pointers.\n        bool operator==(const SurfaceDescriptorFromWindowsSwapChainPanel& rhs) const;\n    };\n\n    struct SurfaceDescriptorFromXlibWindow : ChainedStruct {\n        SurfaceDescriptorFromXlibWindow() {\n            sType = wgpu::SType::SurfaceDescriptorFromXlibWindow;\n        }\n        alignas(wgpu::SurfaceDescriptorFromXlibWindow::kFirstMemberAlignment) void * display;\n        uint32_t window;\n\n        // Equality operators, mostly for testing. Note that this tests\n        // strict pointer-pointer equality if the struct contains member pointers.\n        bool operator==(const SurfaceDescriptorFromXlibWindow& rhs) const;\n    };\n\n    struct SwapChainDescriptor {\n        ChainedStruct const * nextInChain = nullptr;\n        char const * label = nullptr;\n        wgpu::TextureUsage usage;\n        wgpu::TextureFormat format;\n        uint32_t width;\n        uint32_t height;\n        wgpu::PresentMode presentMode;\n\n        // Equality operators, mostly for testing. Note that this tests\n        // strict pointer-pointer equality if the struct contains member pointers.\n        bool operator==(const SwapChainDescriptor& rhs) const;\n    };\n\n    struct TextureBindingLayout {\n        ChainedStruct const * nextInChain = nullptr;\n        wgpu::TextureSampleType sampleType = wgpu::TextureSampleType::Undefined;\n        wgpu::TextureViewDimension viewDimension = wgpu::TextureViewDimension::Undefined;\n        bool multisampled = false;\n\n        // Equality operators, mostly for testing. Note that this tests\n        // strict pointer-pointer equality if the struct contains member pointers.\n        bool operator==(const TextureBindingLayout& rhs) const;\n    };\n\n    struct TextureDataLayout {\n        ChainedStruct const * nextInChain = nullptr;\n        uint64_t offset = 0;\n        uint32_t bytesPerRow = WGPU_COPY_STRIDE_UNDEFINED;\n        uint32_t rowsPerImage = WGPU_COPY_STRIDE_UNDEFINED;\n\n        // Equality operators, mostly for testing. Note that this tests\n        // strict pointer-pointer equality if the struct contains member pointers.\n        bool operator==(const TextureDataLayout& rhs) const;\n    };\n\n    struct TextureViewDescriptor {\n        ChainedStruct const * nextInChain = nullptr;\n        char const * label = nullptr;\n        wgpu::TextureFormat format = wgpu::TextureFormat::Undefined;\n        wgpu::TextureViewDimension dimension = wgpu::TextureViewDimension::Undefined;\n        uint32_t baseMipLevel = 0;\n        uint32_t mipLevelCount = WGPU_MIP_LEVEL_COUNT_UNDEFINED;\n        uint32_t baseArrayLayer = 0;\n        uint32_t arrayLayerCount = WGPU_ARRAY_LAYER_COUNT_UNDEFINED;\n        wgpu::TextureAspect aspect = wgpu::TextureAspect::All;\n\n        // Equality operators, mostly for testing. Note that this tests\n        // strict pointer-pointer equality if the struct contains member pointers.\n        bool operator==(const TextureViewDescriptor& rhs) const;\n    };\n\n    struct VertexAttribute {\n        wgpu::VertexFormat format;\n        uint64_t offset;\n        uint32_t shaderLocation;\n\n        // Equality operators, mostly for testing. Note that this tests\n        // strict pointer-pointer equality if the struct contains member pointers.\n        bool operator==(const VertexAttribute& rhs) const;\n    };\n\n    struct BindGroupDescriptor {\n        ChainedStruct const * nextInChain = nullptr;\n        char const * label = nullptr;\n        BindGroupLayoutBase* layout;\n        size_t entryCount;\n        BindGroupEntry const * entries;\n\n        // Equality operators, mostly for testing. Note that this tests\n        // strict pointer-pointer equality if the struct contains member pointers.\n        bool operator==(const BindGroupDescriptor& rhs) const;\n    };\n\n    struct BindGroupLayoutEntry {\n        ChainedStruct const * nextInChain = nullptr;\n        uint32_t binding;\n        wgpu::ShaderStage visibility;\n        BufferBindingLayout buffer;\n        SamplerBindingLayout sampler;\n        TextureBindingLayout texture;\n        StorageTextureBindingLayout storageTexture;\n\n        // Equality operators, mostly for testing. Note that this tests\n        // strict pointer-pointer equality if the struct contains member pointers.\n        bool operator==(const BindGroupLayoutEntry& rhs) const;\n    };\n\n    struct BlendState {\n        BlendComponent color;\n        BlendComponent alpha;\n\n        // Equality operators, mostly for testing. Note that this tests\n        // strict pointer-pointer equality if the struct contains member pointers.\n        bool operator==(const BlendState& rhs) const;\n    };\n\n    struct CompilationInfo {\n        ChainedStruct const * nextInChain = nullptr;\n        size_t messageCount;\n        CompilationMessage const * messages;\n\n        // Equality operators, mostly for testing. Note that this tests\n        // strict pointer-pointer equality if the struct contains member pointers.\n        bool operator==(const CompilationInfo& rhs) const;\n    };\n\n    struct ComputePassDescriptor {\n        ChainedStruct const * nextInChain = nullptr;\n        char const * label = nullptr;\n        size_t timestampWriteCount = 0;\n        ComputePassTimestampWrite const * timestampWrites;\n\n        // Equality operators, mostly for testing. Note that this tests\n        // strict pointer-pointer equality if the struct contains member pointers.\n        bool operator==(const ComputePassDescriptor& rhs) const;\n    };\n\n    struct DepthStencilState {\n        ChainedStruct const * nextInChain = nullptr;\n        wgpu::TextureFormat format;\n        bool depthWriteEnabled;\n        wgpu::CompareFunction depthCompare;\n        StencilFaceState stencilFront;\n        StencilFaceState stencilBack;\n        uint32_t stencilReadMask = 0xFFFFFFFF;\n        uint32_t stencilWriteMask = 0xFFFFFFFF;\n        int32_t depthBias = 0;\n        float depthBiasSlopeScale = 0.0f;\n        float depthBiasClamp = 0.0f;\n\n        // Equality operators, mostly for testing. Note that this tests\n        // strict pointer-pointer equality if the struct contains member pointers.\n        bool operator==(const DepthStencilState& rhs) const;\n    };\n\n    struct ExternalTextureDescriptor {\n        ChainedStruct const * nextInChain = nullptr;\n        char const * label = nullptr;\n        TextureViewBase* plane0;\n        TextureViewBase* plane1 = nullptr;\n        Origin2D visibleOrigin;\n        Extent2D visibleSize;\n        bool doYuvToRgbConversionOnly = false;\n        float const * yuvToRgbConversionMatrix = nullptr;\n        float const * srcTransferFunctionParameters;\n        float const * dstTransferFunctionParameters;\n        float const * gamutConversionMatrix;\n        bool flipY = false;\n        wgpu::ExternalTextureRotation rotation = wgpu::ExternalTextureRotation::Rotate0Degrees;\n\n        // Equality operators, mostly for testing. Note that this tests\n        // strict pointer-pointer equality if the struct contains member pointers.\n        bool operator==(const ExternalTextureDescriptor& rhs) const;\n    };\n\n    struct ImageCopyBuffer {\n        ChainedStruct const * nextInChain = nullptr;\n        TextureDataLayout layout;\n        BufferBase* buffer;\n\n        // Equality operators, mostly for testing. Note that this tests\n        // strict pointer-pointer equality if the struct contains member pointers.\n        bool operator==(const ImageCopyBuffer& rhs) const;\n    };\n\n    struct ImageCopyExternalTexture {\n        ChainedStruct const * nextInChain = nullptr;\n        ExternalTextureBase* externalTexture;\n        Origin3D origin;\n        Extent2D naturalSize;\n\n        // Equality operators, mostly for testing. Note that this tests\n        // strict pointer-pointer equality if the struct contains member pointers.\n        bool operator==(const ImageCopyExternalTexture& rhs) const;\n    };\n\n    struct ImageCopyTexture {\n        ChainedStruct const * nextInChain = nullptr;\n        TextureBase* texture;\n        uint32_t mipLevel = 0;\n        Origin3D origin;\n        wgpu::TextureAspect aspect = wgpu::TextureAspect::All;\n\n        // Equality operators, mostly for testing. Note that this tests\n        // strict pointer-pointer equality if the struct contains member pointers.\n        bool operator==(const ImageCopyTexture& rhs) const;\n    };\n\n    struct ProgrammableStageDescriptor {\n        ChainedStruct const * nextInChain = nullptr;\n        ShaderModuleBase* module;\n        char const * entryPoint;\n        size_t constantCount = 0;\n        ConstantEntry const * constants;\n\n        // Equality operators, mostly for testing. Note that this tests\n        // strict pointer-pointer equality if the struct contains member pointers.\n        bool operator==(const ProgrammableStageDescriptor& rhs) const;\n    };\n\n    struct RenderPassColorAttachment {\n        ChainedStruct const * nextInChain = nullptr;\n        TextureViewBase* view = nullptr;\n        TextureViewBase* resolveTarget = nullptr;\n        wgpu::LoadOp loadOp;\n        wgpu::StoreOp storeOp;\n        Color clearValue;\n\n        // Equality operators, mostly for testing. Note that this tests\n        // strict pointer-pointer equality if the struct contains member pointers.\n        bool operator==(const RenderPassColorAttachment& rhs) const;\n    };\n\n    struct RequiredLimits {\n        ChainedStruct const * nextInChain = nullptr;\n        Limits limits;\n\n        // Equality operators, mostly for testing. Note that this tests\n        // strict pointer-pointer equality if the struct contains member pointers.\n        bool operator==(const RequiredLimits& rhs) const;\n    };\n\n    struct SupportedLimits {\n        ChainedStructOut * nextInChain = nullptr;\n        Limits limits;\n\n        // Equality operators, mostly for testing. Note that this tests\n        // strict pointer-pointer equality if the struct contains member pointers.\n        bool operator==(const SupportedLimits& rhs) const;\n    };\n\n    struct TextureDescriptor {\n        ChainedStruct const * nextInChain = nullptr;\n        char const * label = nullptr;\n        wgpu::TextureUsage usage;\n        wgpu::TextureDimension dimension = wgpu::TextureDimension::e2D;\n        Extent3D size;\n        wgpu::TextureFormat format;\n        uint32_t mipLevelCount = 1;\n        uint32_t sampleCount = 1;\n        size_t viewFormatCount = 0;\n        wgpu::TextureFormat const * viewFormats;\n\n        // Equality operators, mostly for testing. Note that this tests\n        // strict pointer-pointer equality if the struct contains member pointers.\n        bool operator==(const TextureDescriptor& rhs) const;\n    };\n\n    struct VertexBufferLayout {\n        uint64_t arrayStride;\n        wgpu::VertexStepMode stepMode = wgpu::VertexStepMode::Vertex;\n        size_t attributeCount;\n        VertexAttribute const * attributes;\n\n        // Equality operators, mostly for testing. Note that this tests\n        // strict pointer-pointer equality if the struct contains member pointers.\n        bool operator==(const VertexBufferLayout& rhs) const;\n    };\n\n    struct BindGroupLayoutDescriptor {\n        ChainedStruct const * nextInChain = nullptr;\n        char const * label = nullptr;\n        size_t entryCount;\n        BindGroupLayoutEntry const * entries;\n\n        // Equality operators, mostly for testing. Note that this tests\n        // strict pointer-pointer equality if the struct contains member pointers.\n        bool operator==(const BindGroupLayoutDescriptor& rhs) const;\n    };\n\n    struct ColorTargetState {\n        ChainedStruct const * nextInChain = nullptr;\n        wgpu::TextureFormat format;\n        BlendState const * blend = nullptr;\n        wgpu::ColorWriteMask writeMask = wgpu::ColorWriteMask::All;\n\n        // Equality operators, mostly for testing. Note that this tests\n        // strict pointer-pointer equality if the struct contains member pointers.\n        bool operator==(const ColorTargetState& rhs) const;\n    };\n\n    struct ComputePipelineDescriptor {\n        ChainedStruct const * nextInChain = nullptr;\n        char const * label = nullptr;\n        PipelineLayoutBase* layout = nullptr;\n        ProgrammableStageDescriptor compute;\n\n        // Equality operators, mostly for testing. Note that this tests\n        // strict pointer-pointer equality if the struct contains member pointers.\n        bool operator==(const ComputePipelineDescriptor& rhs) const;\n    };\n\n    struct DeviceDescriptor {\n        ChainedStruct const * nextInChain = nullptr;\n        char const * label = nullptr;\n        size_t requiredFeaturesCount = 0;\n        wgpu::FeatureName const * requiredFeatures = nullptr;\n        RequiredLimits const * requiredLimits = nullptr;\n        QueueDescriptor defaultQueue;\n        WGPUDeviceLostCallback deviceLostCallback = nullptr;\n        void * deviceLostUserdata = nullptr;\n\n        // Equality operators, mostly for testing. Note that this tests\n        // strict pointer-pointer equality if the struct contains member pointers.\n        bool operator==(const DeviceDescriptor& rhs) const;\n    };\n\n    struct RenderPassDescriptor {\n        ChainedStruct const * nextInChain = nullptr;\n        char const * label = nullptr;\n        size_t colorAttachmentCount;\n        RenderPassColorAttachment const * colorAttachments;\n        RenderPassDepthStencilAttachment const * depthStencilAttachment = nullptr;\n        QuerySetBase* occlusionQuerySet = nullptr;\n        size_t timestampWriteCount = 0;\n        RenderPassTimestampWrite const * timestampWrites;\n\n        // Equality operators, mostly for testing. Note that this tests\n        // strict pointer-pointer equality if the struct contains member pointers.\n        bool operator==(const RenderPassDescriptor& rhs) const;\n    };\n\n    struct VertexState {\n        ChainedStruct const * nextInChain = nullptr;\n        ShaderModuleBase* module;\n        char const * entryPoint;\n        size_t constantCount = 0;\n        ConstantEntry const * constants;\n        size_t bufferCount = 0;\n        VertexBufferLayout const * buffers;\n\n        // Equality operators, mostly for testing. Note that this tests\n        // strict pointer-pointer equality if the struct contains member pointers.\n        bool operator==(const VertexState& rhs) const;\n    };\n\n    struct FragmentState {\n        ChainedStruct const * nextInChain = nullptr;\n        ShaderModuleBase* module;\n        char const * entryPoint;\n        size_t constantCount = 0;\n        ConstantEntry const * constants;\n        size_t targetCount;\n        ColorTargetState const * targets;\n\n        // Equality operators, mostly for testing. Note that this tests\n        // strict pointer-pointer equality if the struct contains member pointers.\n        bool operator==(const FragmentState& rhs) const;\n    };\n\n    struct RenderPipelineDescriptor {\n        ChainedStruct const * nextInChain = nullptr;\n        char const * label = nullptr;\n        PipelineLayoutBase* layout = nullptr;\n        VertexState vertex;\n        PrimitiveState primitive;\n        DepthStencilState const * depthStencil = nullptr;\n        MultisampleState multisample;\n        FragmentState const * fragment = nullptr;\n\n        // Equality operators, mostly for testing. Note that this tests\n        // strict pointer-pointer equality if the struct contains member pointers.\n        bool operator==(const RenderPipelineDescriptor& rhs) const;\n    };\n\n\n\n} // namespace dawn::native\n\n#endif  // DAWNNATIVE_WGPU_STRUCTS_H_\n", "src/dawn/native/wgpu_structs_autogen.cpp": "\n#include \"dawn/native/wgpu_structs_autogen.h\"\n\n#include <tuple>\n\n#ifdef __GNUC__\n// error: 'offsetof' within non-standard-layout type 'wgpu::XXX' is conditionally-supported\n#pragma GCC diagnostic ignored \"-Winvalid-offsetof\"\n#endif\n\nnamespace dawn::native {\n\n    static_assert(sizeof(ChainedStruct) == sizeof(WGPUChainedStruct),\n            \"sizeof mismatch for ChainedStruct\");\n    static_assert(alignof(ChainedStruct) == alignof(WGPUChainedStruct),\n            \"alignof mismatch for ChainedStruct\");\n    static_assert(offsetof(ChainedStruct, nextInChain) == offsetof(WGPUChainedStruct, next),\n            \"offsetof mismatch for ChainedStruct::nextInChain\");\n    static_assert(offsetof(ChainedStruct, sType) == offsetof(WGPUChainedStruct, sType),\n            \"offsetof mismatch for ChainedStruct::sType\");\n\n\n    static_assert(sizeof(AdapterProperties) == sizeof(WGPUAdapterProperties), \"sizeof mismatch for AdapterProperties\");\n    static_assert(alignof(AdapterProperties) == alignof(WGPUAdapterProperties), \"alignof mismatch for AdapterProperties\");\n\n    static_assert(offsetof(AdapterProperties, nextInChain) == offsetof(WGPUAdapterProperties, nextInChain),\n            \"offsetof mismatch for AdapterProperties::nextInChain\");\n    static_assert(offsetof(AdapterProperties, vendorID) == offsetof(WGPUAdapterProperties, vendorID),\n            \"offsetof mismatch for AdapterProperties::vendorID\");\n    static_assert(offsetof(AdapterProperties, vendorName) == offsetof(WGPUAdapterProperties, vendorName),\n            \"offsetof mismatch for AdapterProperties::vendorName\");\n    static_assert(offsetof(AdapterProperties, architecture) == offsetof(WGPUAdapterProperties, architecture),\n            \"offsetof mismatch for AdapterProperties::architecture\");\n    static_assert(offsetof(AdapterProperties, deviceID) == offsetof(WGPUAdapterProperties, deviceID),\n            \"offsetof mismatch for AdapterProperties::deviceID\");\n    static_assert(offsetof(AdapterProperties, name) == offsetof(WGPUAdapterProperties, name),\n            \"offsetof mismatch for AdapterProperties::name\");\n    static_assert(offsetof(AdapterProperties, driverDescription) == offsetof(WGPUAdapterProperties, driverDescription),\n            \"offsetof mismatch for AdapterProperties::driverDescription\");\n    static_assert(offsetof(AdapterProperties, adapterType) == offsetof(WGPUAdapterProperties, adapterType),\n            \"offsetof mismatch for AdapterProperties::adapterType\");\n    static_assert(offsetof(AdapterProperties, backendType) == offsetof(WGPUAdapterProperties, backendType),\n            \"offsetof mismatch for AdapterProperties::backendType\");\n    static_assert(offsetof(AdapterProperties, compatibilityMode) == offsetof(WGPUAdapterProperties, compatibilityMode),\n            \"offsetof mismatch for AdapterProperties::compatibilityMode\");\n\n    bool AdapterProperties::operator==(const AdapterProperties& rhs) const {\n        return (nextInChain == rhs.nextInChain) && std::tie(\n            vendorID,\n            vendorName,\n            architecture,\n            deviceID,\n            name,\n            driverDescription,\n            adapterType,\n            backendType,\n            compatibilityMode\n        ) == std::tie(\n            rhs.vendorID,\n            rhs.vendorName,\n            rhs.architecture,\n            rhs.deviceID,\n            rhs.name,\n            rhs.driverDescription,\n            rhs.adapterType,\n            rhs.backendType,\n            rhs.compatibilityMode\n        );\n    }\n\n\n    static_assert(sizeof(BindGroupEntry) == sizeof(WGPUBindGroupEntry), \"sizeof mismatch for BindGroupEntry\");\n    static_assert(alignof(BindGroupEntry) == alignof(WGPUBindGroupEntry), \"alignof mismatch for BindGroupEntry\");\n\n    static_assert(offsetof(BindGroupEntry, nextInChain) == offsetof(WGPUBindGroupEntry, nextInChain),\n            \"offsetof mismatch for BindGroupEntry::nextInChain\");\n    static_assert(offsetof(BindGroupEntry, binding) == offsetof(WGPUBindGroupEntry, binding),\n            \"offsetof mismatch for BindGroupEntry::binding\");\n    static_assert(offsetof(BindGroupEntry, buffer) == offsetof(WGPUBindGroupEntry, buffer),\n            \"offsetof mismatch for BindGroupEntry::buffer\");\n    static_assert(offsetof(BindGroupEntry, offset) == offsetof(WGPUBindGroupEntry, offset),\n            \"offsetof mismatch for BindGroupEntry::offset\");\n    static_assert(offsetof(BindGroupEntry, size) == offsetof(WGPUBindGroupEntry, size),\n            \"offsetof mismatch for BindGroupEntry::size\");\n    static_assert(offsetof(BindGroupEntry, sampler) == offsetof(WGPUBindGroupEntry, sampler),\n            \"offsetof mismatch for BindGroupEntry::sampler\");\n    static_assert(offsetof(BindGroupEntry, textureView) == offsetof(WGPUBindGroupEntry, textureView),\n            \"offsetof mismatch for BindGroupEntry::textureView\");\n\n    bool BindGroupEntry::operator==(const BindGroupEntry& rhs) const {\n        return (nextInChain == rhs.nextInChain) && std::tie(\n            binding,\n            buffer,\n            offset,\n            size,\n            sampler,\n            textureView\n        ) == std::tie(\n            rhs.binding,\n            rhs.buffer,\n            rhs.offset,\n            rhs.size,\n            rhs.sampler,\n            rhs.textureView\n        );\n    }\n\n\n    static_assert(sizeof(BlendComponent) == sizeof(WGPUBlendComponent), \"sizeof mismatch for BlendComponent\");\n    static_assert(alignof(BlendComponent) == alignof(WGPUBlendComponent), \"alignof mismatch for BlendComponent\");\n\n    static_assert(offsetof(BlendComponent, operation) == offsetof(WGPUBlendComponent, operation),\n            \"offsetof mismatch for BlendComponent::operation\");\n    static_assert(offsetof(BlendComponent, srcFactor) == offsetof(WGPUBlendComponent, srcFactor),\n            \"offsetof mismatch for BlendComponent::srcFactor\");\n    static_assert(offsetof(BlendComponent, dstFactor) == offsetof(WGPUBlendComponent, dstFactor),\n            \"offsetof mismatch for BlendComponent::dstFactor\");\n\n    bool BlendComponent::operator==(const BlendComponent& rhs) const {\n        return  std::tie(\n            operation,\n            srcFactor,\n            dstFactor\n        ) == std::tie(\n            rhs.operation,\n            rhs.srcFactor,\n            rhs.dstFactor\n        );\n    }\n\n\n    static_assert(sizeof(BufferBindingLayout) == sizeof(WGPUBufferBindingLayout), \"sizeof mismatch for BufferBindingLayout\");\n    static_assert(alignof(BufferBindingLayout) == alignof(WGPUBufferBindingLayout), \"alignof mismatch for BufferBindingLayout\");\n\n    static_assert(offsetof(BufferBindingLayout, nextInChain) == offsetof(WGPUBufferBindingLayout, nextInChain),\n            \"offsetof mismatch for BufferBindingLayout::nextInChain\");\n    static_assert(offsetof(BufferBindingLayout, type) == offsetof(WGPUBufferBindingLayout, type),\n            \"offsetof mismatch for BufferBindingLayout::type\");\n    static_assert(offsetof(BufferBindingLayout, hasDynamicOffset) == offsetof(WGPUBufferBindingLayout, hasDynamicOffset),\n            \"offsetof mismatch for BufferBindingLayout::hasDynamicOffset\");\n    static_assert(offsetof(BufferBindingLayout, minBindingSize) == offsetof(WGPUBufferBindingLayout, minBindingSize),\n            \"offsetof mismatch for BufferBindingLayout::minBindingSize\");\n\n    bool BufferBindingLayout::operator==(const BufferBindingLayout& rhs) const {\n        return (nextInChain == rhs.nextInChain) && std::tie(\n            type,\n            hasDynamicOffset,\n            minBindingSize\n        ) == std::tie(\n            rhs.type,\n            rhs.hasDynamicOffset,\n            rhs.minBindingSize\n        );\n    }\n\n\n    static_assert(sizeof(BufferDescriptor) == sizeof(WGPUBufferDescriptor), \"sizeof mismatch for BufferDescriptor\");\n    static_assert(alignof(BufferDescriptor) == alignof(WGPUBufferDescriptor), \"alignof mismatch for BufferDescriptor\");\n\n    static_assert(offsetof(BufferDescriptor, nextInChain) == offsetof(WGPUBufferDescriptor, nextInChain),\n            \"offsetof mismatch for BufferDescriptor::nextInChain\");\n    static_assert(offsetof(BufferDescriptor, label) == offsetof(WGPUBufferDescriptor, label),\n            \"offsetof mismatch for BufferDescriptor::label\");\n    static_assert(offsetof(BufferDescriptor, usage) == offsetof(WGPUBufferDescriptor, usage),\n            \"offsetof mismatch for BufferDescriptor::usage\");\n    static_assert(offsetof(BufferDescriptor, size) == offsetof(WGPUBufferDescriptor, size),\n            \"offsetof mismatch for BufferDescriptor::size\");\n    static_assert(offsetof(BufferDescriptor, mappedAtCreation) == offsetof(WGPUBufferDescriptor, mappedAtCreation),\n            \"offsetof mismatch for BufferDescriptor::mappedAtCreation\");\n\n    bool BufferDescriptor::operator==(const BufferDescriptor& rhs) const {\n        return (nextInChain == rhs.nextInChain) && std::tie(\n            label,\n            usage,\n            size,\n            mappedAtCreation\n        ) == std::tie(\n            rhs.label,\n            rhs.usage,\n            rhs.size,\n            rhs.mappedAtCreation\n        );\n    }\n\n\n    static_assert(sizeof(Color) == sizeof(WGPUColor), \"sizeof mismatch for Color\");\n    static_assert(alignof(Color) == alignof(WGPUColor), \"alignof mismatch for Color\");\n\n    static_assert(offsetof(Color, r) == offsetof(WGPUColor, r),\n            \"offsetof mismatch for Color::r\");\n    static_assert(offsetof(Color, g) == offsetof(WGPUColor, g),\n            \"offsetof mismatch for Color::g\");\n    static_assert(offsetof(Color, b) == offsetof(WGPUColor, b),\n            \"offsetof mismatch for Color::b\");\n    static_assert(offsetof(Color, a) == offsetof(WGPUColor, a),\n            \"offsetof mismatch for Color::a\");\n\n    bool Color::operator==(const Color& rhs) const {\n        return  std::tie(\n            r,\n            g,\n            b,\n            a\n        ) == std::tie(\n            rhs.r,\n            rhs.g,\n            rhs.b,\n            rhs.a\n        );\n    }\n\n\n    static_assert(sizeof(CommandBufferDescriptor) == sizeof(WGPUCommandBufferDescriptor), \"sizeof mismatch for CommandBufferDescriptor\");\n    static_assert(alignof(CommandBufferDescriptor) == alignof(WGPUCommandBufferDescriptor), \"alignof mismatch for CommandBufferDescriptor\");\n\n    static_assert(offsetof(CommandBufferDescriptor, nextInChain) == offsetof(WGPUCommandBufferDescriptor, nextInChain),\n            \"offsetof mismatch for CommandBufferDescriptor::nextInChain\");\n    static_assert(offsetof(CommandBufferDescriptor, label) == offsetof(WGPUCommandBufferDescriptor, label),\n            \"offsetof mismatch for CommandBufferDescriptor::label\");\n\n    bool CommandBufferDescriptor::operator==(const CommandBufferDescriptor& rhs) const {\n        return (nextInChain == rhs.nextInChain) && std::tie(\n            label\n        ) == std::tie(\n            rhs.label\n        );\n    }\n\n\n    static_assert(sizeof(CommandEncoderDescriptor) == sizeof(WGPUCommandEncoderDescriptor), \"sizeof mismatch for CommandEncoderDescriptor\");\n    static_assert(alignof(CommandEncoderDescriptor) == alignof(WGPUCommandEncoderDescriptor), \"alignof mismatch for CommandEncoderDescriptor\");\n\n    static_assert(offsetof(CommandEncoderDescriptor, nextInChain) == offsetof(WGPUCommandEncoderDescriptor, nextInChain),\n            \"offsetof mismatch for CommandEncoderDescriptor::nextInChain\");\n    static_assert(offsetof(CommandEncoderDescriptor, label) == offsetof(WGPUCommandEncoderDescriptor, label),\n            \"offsetof mismatch for CommandEncoderDescriptor::label\");\n\n    bool CommandEncoderDescriptor::operator==(const CommandEncoderDescriptor& rhs) const {\n        return (nextInChain == rhs.nextInChain) && std::tie(\n            label\n        ) == std::tie(\n            rhs.label\n        );\n    }\n\n\n    static_assert(sizeof(CompilationMessage) == sizeof(WGPUCompilationMessage), \"sizeof mismatch for CompilationMessage\");\n    static_assert(alignof(CompilationMessage) == alignof(WGPUCompilationMessage), \"alignof mismatch for CompilationMessage\");\n\n    static_assert(offsetof(CompilationMessage, nextInChain) == offsetof(WGPUCompilationMessage, nextInChain),\n            \"offsetof mismatch for CompilationMessage::nextInChain\");\n    static_assert(offsetof(CompilationMessage, message) == offsetof(WGPUCompilationMessage, message),\n            \"offsetof mismatch for CompilationMessage::message\");\n    static_assert(offsetof(CompilationMessage, type) == offsetof(WGPUCompilationMessage, type),\n            \"offsetof mismatch for CompilationMessage::type\");\n    static_assert(offsetof(CompilationMessage, lineNum) == offsetof(WGPUCompilationMessage, lineNum),\n            \"offsetof mismatch for CompilationMessage::lineNum\");\n    static_assert(offsetof(CompilationMessage, linePos) == offsetof(WGPUCompilationMessage, linePos),\n            \"offsetof mismatch for CompilationMessage::linePos\");\n    static_assert(offsetof(CompilationMessage, offset) == offsetof(WGPUCompilationMessage, offset),\n            \"offsetof mismatch for CompilationMessage::offset\");\n    static_assert(offsetof(CompilationMessage, length) == offsetof(WGPUCompilationMessage, length),\n            \"offsetof mismatch for CompilationMessage::length\");\n    static_assert(offsetof(CompilationMessage, utf16LinePos) == offsetof(WGPUCompilationMessage, utf16LinePos),\n            \"offsetof mismatch for CompilationMessage::utf16LinePos\");\n    static_assert(offsetof(CompilationMessage, utf16Offset) == offsetof(WGPUCompilationMessage, utf16Offset),\n            \"offsetof mismatch for CompilationMessage::utf16Offset\");\n    static_assert(offsetof(CompilationMessage, utf16Length) == offsetof(WGPUCompilationMessage, utf16Length),\n            \"offsetof mismatch for CompilationMessage::utf16Length\");\n\n    bool CompilationMessage::operator==(const CompilationMessage& rhs) const {\n        return (nextInChain == rhs.nextInChain) && std::tie(\n            message,\n            type,\n            lineNum,\n            linePos,\n            offset,\n            length,\n            utf16LinePos,\n            utf16Offset,\n            utf16Length\n        ) == std::tie(\n            rhs.message,\n            rhs.type,\n            rhs.lineNum,\n            rhs.linePos,\n            rhs.offset,\n            rhs.length,\n            rhs.utf16LinePos,\n            rhs.utf16Offset,\n            rhs.utf16Length\n        );\n    }\n\n\n    static_assert(sizeof(ComputePassTimestampWrite) == sizeof(WGPUComputePassTimestampWrite), \"sizeof mismatch for ComputePassTimestampWrite\");\n    static_assert(alignof(ComputePassTimestampWrite) == alignof(WGPUComputePassTimestampWrite), \"alignof mismatch for ComputePassTimestampWrite\");\n\n    static_assert(offsetof(ComputePassTimestampWrite, querySet) == offsetof(WGPUComputePassTimestampWrite, querySet),\n            \"offsetof mismatch for ComputePassTimestampWrite::querySet\");\n    static_assert(offsetof(ComputePassTimestampWrite, queryIndex) == offsetof(WGPUComputePassTimestampWrite, queryIndex),\n            \"offsetof mismatch for ComputePassTimestampWrite::queryIndex\");\n    static_assert(offsetof(ComputePassTimestampWrite, location) == offsetof(WGPUComputePassTimestampWrite, location),\n            \"offsetof mismatch for ComputePassTimestampWrite::location\");\n\n    bool ComputePassTimestampWrite::operator==(const ComputePassTimestampWrite& rhs) const {\n        return  std::tie(\n            querySet,\n            queryIndex,\n            location\n        ) == std::tie(\n            rhs.querySet,\n            rhs.queryIndex,\n            rhs.location\n        );\n    }\n\n\n    static_assert(sizeof(ConstantEntry) == sizeof(WGPUConstantEntry), \"sizeof mismatch for ConstantEntry\");\n    static_assert(alignof(ConstantEntry) == alignof(WGPUConstantEntry), \"alignof mismatch for ConstantEntry\");\n\n    static_assert(offsetof(ConstantEntry, nextInChain) == offsetof(WGPUConstantEntry, nextInChain),\n            \"offsetof mismatch for ConstantEntry::nextInChain\");\n    static_assert(offsetof(ConstantEntry, key) == offsetof(WGPUConstantEntry, key),\n            \"offsetof mismatch for ConstantEntry::key\");\n    static_assert(offsetof(ConstantEntry, value) == offsetof(WGPUConstantEntry, value),\n            \"offsetof mismatch for ConstantEntry::value\");\n\n    bool ConstantEntry::operator==(const ConstantEntry& rhs) const {\n        return (nextInChain == rhs.nextInChain) && std::tie(\n            key,\n            value\n        ) == std::tie(\n            rhs.key,\n            rhs.value\n        );\n    }\n\n\n    static_assert(sizeof(CopyTextureForBrowserOptions) == sizeof(WGPUCopyTextureForBrowserOptions), \"sizeof mismatch for CopyTextureForBrowserOptions\");\n    static_assert(alignof(CopyTextureForBrowserOptions) == alignof(WGPUCopyTextureForBrowserOptions), \"alignof mismatch for CopyTextureForBrowserOptions\");\n\n    static_assert(offsetof(CopyTextureForBrowserOptions, nextInChain) == offsetof(WGPUCopyTextureForBrowserOptions, nextInChain),\n            \"offsetof mismatch for CopyTextureForBrowserOptions::nextInChain\");\n    static_assert(offsetof(CopyTextureForBrowserOptions, flipY) == offsetof(WGPUCopyTextureForBrowserOptions, flipY),\n            \"offsetof mismatch for CopyTextureForBrowserOptions::flipY\");\n    static_assert(offsetof(CopyTextureForBrowserOptions, needsColorSpaceConversion) == offsetof(WGPUCopyTextureForBrowserOptions, needsColorSpaceConversion),\n            \"offsetof mismatch for CopyTextureForBrowserOptions::needsColorSpaceConversion\");\n    static_assert(offsetof(CopyTextureForBrowserOptions, srcAlphaMode) == offsetof(WGPUCopyTextureForBrowserOptions, srcAlphaMode),\n            \"offsetof mismatch for CopyTextureForBrowserOptions::srcAlphaMode\");\n    static_assert(offsetof(CopyTextureForBrowserOptions, srcTransferFunctionParameters) == offsetof(WGPUCopyTextureForBrowserOptions, srcTransferFunctionParameters),\n            \"offsetof mismatch for CopyTextureForBrowserOptions::srcTransferFunctionParameters\");\n    static_assert(offsetof(CopyTextureForBrowserOptions, conversionMatrix) == offsetof(WGPUCopyTextureForBrowserOptions, conversionMatrix),\n            \"offsetof mismatch for CopyTextureForBrowserOptions::conversionMatrix\");\n    static_assert(offsetof(CopyTextureForBrowserOptions, dstTransferFunctionParameters) == offsetof(WGPUCopyTextureForBrowserOptions, dstTransferFunctionParameters),\n            \"offsetof mismatch for CopyTextureForBrowserOptions::dstTransferFunctionParameters\");\n    static_assert(offsetof(CopyTextureForBrowserOptions, dstAlphaMode) == offsetof(WGPUCopyTextureForBrowserOptions, dstAlphaMode),\n            \"offsetof mismatch for CopyTextureForBrowserOptions::dstAlphaMode\");\n    static_assert(offsetof(CopyTextureForBrowserOptions, internalUsage) == offsetof(WGPUCopyTextureForBrowserOptions, internalUsage),\n            \"offsetof mismatch for CopyTextureForBrowserOptions::internalUsage\");\n\n    bool CopyTextureForBrowserOptions::operator==(const CopyTextureForBrowserOptions& rhs) const {\n        return (nextInChain == rhs.nextInChain) && std::tie(\n            flipY,\n            needsColorSpaceConversion,\n            srcAlphaMode,\n            srcTransferFunctionParameters,\n            conversionMatrix,\n            dstTransferFunctionParameters,\n            dstAlphaMode,\n            internalUsage\n        ) == std::tie(\n            rhs.flipY,\n            rhs.needsColorSpaceConversion,\n            rhs.srcAlphaMode,\n            rhs.srcTransferFunctionParameters,\n            rhs.conversionMatrix,\n            rhs.dstTransferFunctionParameters,\n            rhs.dstAlphaMode,\n            rhs.internalUsage\n        );\n    }\n\n\n    static_assert(sizeof(DawnAdapterPropertiesPowerPreference) == sizeof(WGPUDawnAdapterPropertiesPowerPreference), \"sizeof mismatch for DawnAdapterPropertiesPowerPreference\");\n    static_assert(alignof(DawnAdapterPropertiesPowerPreference) == alignof(WGPUDawnAdapterPropertiesPowerPreference), \"alignof mismatch for DawnAdapterPropertiesPowerPreference\");\n\n    static_assert(offsetof(DawnAdapterPropertiesPowerPreference, powerPreference) == offsetof(WGPUDawnAdapterPropertiesPowerPreference, powerPreference),\n            \"offsetof mismatch for DawnAdapterPropertiesPowerPreference::powerPreference\");\n\n    bool DawnAdapterPropertiesPowerPreference::operator==(const DawnAdapterPropertiesPowerPreference& rhs) const {\n        return (nextInChain == rhs.nextInChain) && std::tie(\n            powerPreference\n        ) == std::tie(\n            rhs.powerPreference\n        );\n    }\n\n\n    static_assert(sizeof(DawnBufferDescriptorErrorInfoFromWireClient) == sizeof(WGPUDawnBufferDescriptorErrorInfoFromWireClient), \"sizeof mismatch for DawnBufferDescriptorErrorInfoFromWireClient\");\n    static_assert(alignof(DawnBufferDescriptorErrorInfoFromWireClient) == alignof(WGPUDawnBufferDescriptorErrorInfoFromWireClient), \"alignof mismatch for DawnBufferDescriptorErrorInfoFromWireClient\");\n\n    static_assert(offsetof(DawnBufferDescriptorErrorInfoFromWireClient, outOfMemory) == offsetof(WGPUDawnBufferDescriptorErrorInfoFromWireClient, outOfMemory),\n            \"offsetof mismatch for DawnBufferDescriptorErrorInfoFromWireClient::outOfMemory\");\n\n    bool DawnBufferDescriptorErrorInfoFromWireClient::operator==(const DawnBufferDescriptorErrorInfoFromWireClient& rhs) const {\n        return (nextInChain == rhs.nextInChain) && std::tie(\n            outOfMemory\n        ) == std::tie(\n            rhs.outOfMemory\n        );\n    }\n\n\n    static_assert(sizeof(DawnCacheDeviceDescriptor) == sizeof(WGPUDawnCacheDeviceDescriptor), \"sizeof mismatch for DawnCacheDeviceDescriptor\");\n    static_assert(alignof(DawnCacheDeviceDescriptor) == alignof(WGPUDawnCacheDeviceDescriptor), \"alignof mismatch for DawnCacheDeviceDescriptor\");\n\n    static_assert(offsetof(DawnCacheDeviceDescriptor, isolationKey) == offsetof(WGPUDawnCacheDeviceDescriptor, isolationKey),\n            \"offsetof mismatch for DawnCacheDeviceDescriptor::isolationKey\");\n\n    bool DawnCacheDeviceDescriptor::operator==(const DawnCacheDeviceDescriptor& rhs) const {\n        return (nextInChain == rhs.nextInChain) && std::tie(\n            isolationKey\n        ) == std::tie(\n            rhs.isolationKey\n        );\n    }\n\n\n    static_assert(sizeof(DawnEncoderInternalUsageDescriptor) == sizeof(WGPUDawnEncoderInternalUsageDescriptor), \"sizeof mismatch for DawnEncoderInternalUsageDescriptor\");\n    static_assert(alignof(DawnEncoderInternalUsageDescriptor) == alignof(WGPUDawnEncoderInternalUsageDescriptor), \"alignof mismatch for DawnEncoderInternalUsageDescriptor\");\n\n    static_assert(offsetof(DawnEncoderInternalUsageDescriptor, useInternalUsages) == offsetof(WGPUDawnEncoderInternalUsageDescriptor, useInternalUsages),\n            \"offsetof mismatch for DawnEncoderInternalUsageDescriptor::useInternalUsages\");\n\n    bool DawnEncoderInternalUsageDescriptor::operator==(const DawnEncoderInternalUsageDescriptor& rhs) const {\n        return (nextInChain == rhs.nextInChain) && std::tie(\n            useInternalUsages\n        ) == std::tie(\n            rhs.useInternalUsages\n        );\n    }\n\n\n    static_assert(sizeof(DawnMultisampleStateRenderToSingleSampled) == sizeof(WGPUDawnMultisampleStateRenderToSingleSampled), \"sizeof mismatch for DawnMultisampleStateRenderToSingleSampled\");\n    static_assert(alignof(DawnMultisampleStateRenderToSingleSampled) == alignof(WGPUDawnMultisampleStateRenderToSingleSampled), \"alignof mismatch for DawnMultisampleStateRenderToSingleSampled\");\n\n    static_assert(offsetof(DawnMultisampleStateRenderToSingleSampled, enabled) == offsetof(WGPUDawnMultisampleStateRenderToSingleSampled, enabled),\n            \"offsetof mismatch for DawnMultisampleStateRenderToSingleSampled::enabled\");\n\n    bool DawnMultisampleStateRenderToSingleSampled::operator==(const DawnMultisampleStateRenderToSingleSampled& rhs) const {\n        return (nextInChain == rhs.nextInChain) && std::tie(\n            enabled\n        ) == std::tie(\n            rhs.enabled\n        );\n    }\n\n\n    static_assert(sizeof(DawnRenderPassColorAttachmentRenderToSingleSampled) == sizeof(WGPUDawnRenderPassColorAttachmentRenderToSingleSampled), \"sizeof mismatch for DawnRenderPassColorAttachmentRenderToSingleSampled\");\n    static_assert(alignof(DawnRenderPassColorAttachmentRenderToSingleSampled) == alignof(WGPUDawnRenderPassColorAttachmentRenderToSingleSampled), \"alignof mismatch for DawnRenderPassColorAttachmentRenderToSingleSampled\");\n\n    static_assert(offsetof(DawnRenderPassColorAttachmentRenderToSingleSampled, implicitSampleCount) == offsetof(WGPUDawnRenderPassColorAttachmentRenderToSingleSampled, implicitSampleCount),\n            \"offsetof mismatch for DawnRenderPassColorAttachmentRenderToSingleSampled::implicitSampleCount\");\n\n    bool DawnRenderPassColorAttachmentRenderToSingleSampled::operator==(const DawnRenderPassColorAttachmentRenderToSingleSampled& rhs) const {\n        return (nextInChain == rhs.nextInChain) && std::tie(\n            implicitSampleCount\n        ) == std::tie(\n            rhs.implicitSampleCount\n        );\n    }\n\n\n    static_assert(sizeof(DawnShaderModuleSPIRVOptionsDescriptor) == sizeof(WGPUDawnShaderModuleSPIRVOptionsDescriptor), \"sizeof mismatch for DawnShaderModuleSPIRVOptionsDescriptor\");\n    static_assert(alignof(DawnShaderModuleSPIRVOptionsDescriptor) == alignof(WGPUDawnShaderModuleSPIRVOptionsDescriptor), \"alignof mismatch for DawnShaderModuleSPIRVOptionsDescriptor\");\n\n    static_assert(offsetof(DawnShaderModuleSPIRVOptionsDescriptor, allowNonUniformDerivatives) == offsetof(WGPUDawnShaderModuleSPIRVOptionsDescriptor, allowNonUniformDerivatives),\n            \"offsetof mismatch for DawnShaderModuleSPIRVOptionsDescriptor::allowNonUniformDerivatives\");\n\n    bool DawnShaderModuleSPIRVOptionsDescriptor::operator==(const DawnShaderModuleSPIRVOptionsDescriptor& rhs) const {\n        return (nextInChain == rhs.nextInChain) && std::tie(\n            allowNonUniformDerivatives\n        ) == std::tie(\n            rhs.allowNonUniformDerivatives\n        );\n    }\n\n\n    static_assert(sizeof(DawnTextureInternalUsageDescriptor) == sizeof(WGPUDawnTextureInternalUsageDescriptor), \"sizeof mismatch for DawnTextureInternalUsageDescriptor\");\n    static_assert(alignof(DawnTextureInternalUsageDescriptor) == alignof(WGPUDawnTextureInternalUsageDescriptor), \"alignof mismatch for DawnTextureInternalUsageDescriptor\");\n\n    static_assert(offsetof(DawnTextureInternalUsageDescriptor, internalUsage) == offsetof(WGPUDawnTextureInternalUsageDescriptor, internalUsage),\n            \"offsetof mismatch for DawnTextureInternalUsageDescriptor::internalUsage\");\n\n    bool DawnTextureInternalUsageDescriptor::operator==(const DawnTextureInternalUsageDescriptor& rhs) const {\n        return (nextInChain == rhs.nextInChain) && std::tie(\n            internalUsage\n        ) == std::tie(\n            rhs.internalUsage\n        );\n    }\n\n\n    static_assert(sizeof(DawnTogglesDescriptor) == sizeof(WGPUDawnTogglesDescriptor), \"sizeof mismatch for DawnTogglesDescriptor\");\n    static_assert(alignof(DawnTogglesDescriptor) == alignof(WGPUDawnTogglesDescriptor), \"alignof mismatch for DawnTogglesDescriptor\");\n\n    static_assert(offsetof(DawnTogglesDescriptor, enabledTogglesCount) == offsetof(WGPUDawnTogglesDescriptor, enabledTogglesCount),\n            \"offsetof mismatch for DawnTogglesDescriptor::enabledTogglesCount\");\n    static_assert(offsetof(DawnTogglesDescriptor, enabledToggles) == offsetof(WGPUDawnTogglesDescriptor, enabledToggles),\n            \"offsetof mismatch for DawnTogglesDescriptor::enabledToggles\");\n    static_assert(offsetof(DawnTogglesDescriptor, disabledTogglesCount) == offsetof(WGPUDawnTogglesDescriptor, disabledTogglesCount),\n            \"offsetof mismatch for DawnTogglesDescriptor::disabledTogglesCount\");\n    static_assert(offsetof(DawnTogglesDescriptor, disabledToggles) == offsetof(WGPUDawnTogglesDescriptor, disabledToggles),\n            \"offsetof mismatch for DawnTogglesDescriptor::disabledToggles\");\n\n    bool DawnTogglesDescriptor::operator==(const DawnTogglesDescriptor& rhs) const {\n        return (nextInChain == rhs.nextInChain) && std::tie(\n            enabledTogglesCount,\n            enabledToggles,\n            disabledTogglesCount,\n            disabledToggles\n        ) == std::tie(\n            rhs.enabledTogglesCount,\n            rhs.enabledToggles,\n            rhs.disabledTogglesCount,\n            rhs.disabledToggles\n        );\n    }\n\n\n    static_assert(sizeof(Extent2D) == sizeof(WGPUExtent2D), \"sizeof mismatch for Extent2D\");\n    static_assert(alignof(Extent2D) == alignof(WGPUExtent2D), \"alignof mismatch for Extent2D\");\n\n    static_assert(offsetof(Extent2D, width) == offsetof(WGPUExtent2D, width),\n            \"offsetof mismatch for Extent2D::width\");\n    static_assert(offsetof(Extent2D, height) == offsetof(WGPUExtent2D, height),\n            \"offsetof mismatch for Extent2D::height\");\n\n    bool Extent2D::operator==(const Extent2D& rhs) const {\n        return  std::tie(\n            width,\n            height\n        ) == std::tie(\n            rhs.width,\n            rhs.height\n        );\n    }\n\n\n    static_assert(sizeof(Extent3D) == sizeof(WGPUExtent3D), \"sizeof mismatch for Extent3D\");\n    static_assert(alignof(Extent3D) == alignof(WGPUExtent3D), \"alignof mismatch for Extent3D\");\n\n    static_assert(offsetof(Extent3D, width) == offsetof(WGPUExtent3D, width),\n            \"offsetof mismatch for Extent3D::width\");\n    static_assert(offsetof(Extent3D, height) == offsetof(WGPUExtent3D, height),\n            \"offsetof mismatch for Extent3D::height\");\n    static_assert(offsetof(Extent3D, depthOrArrayLayers) == offsetof(WGPUExtent3D, depthOrArrayLayers),\n            \"offsetof mismatch for Extent3D::depthOrArrayLayers\");\n\n    bool Extent3D::operator==(const Extent3D& rhs) const {\n        return  std::tie(\n            width,\n            height,\n            depthOrArrayLayers\n        ) == std::tie(\n            rhs.width,\n            rhs.height,\n            rhs.depthOrArrayLayers\n        );\n    }\n\n\n    static_assert(sizeof(ExternalTextureBindingEntry) == sizeof(WGPUExternalTextureBindingEntry), \"sizeof mismatch for ExternalTextureBindingEntry\");\n    static_assert(alignof(ExternalTextureBindingEntry) == alignof(WGPUExternalTextureBindingEntry), \"alignof mismatch for ExternalTextureBindingEntry\");\n\n    static_assert(offsetof(ExternalTextureBindingEntry, externalTexture) == offsetof(WGPUExternalTextureBindingEntry, externalTexture),\n            \"offsetof mismatch for ExternalTextureBindingEntry::externalTexture\");\n\n    bool ExternalTextureBindingEntry::operator==(const ExternalTextureBindingEntry& rhs) const {\n        return (nextInChain == rhs.nextInChain) && std::tie(\n            externalTexture\n        ) == std::tie(\n            rhs.externalTexture\n        );\n    }\n\n\n    static_assert(sizeof(ExternalTextureBindingLayout) == sizeof(WGPUExternalTextureBindingLayout), \"sizeof mismatch for ExternalTextureBindingLayout\");\n    static_assert(alignof(ExternalTextureBindingLayout) == alignof(WGPUExternalTextureBindingLayout), \"alignof mismatch for ExternalTextureBindingLayout\");\n\n\n    bool ExternalTextureBindingLayout::operator==(const ExternalTextureBindingLayout& rhs) const {\n        return (nextInChain == rhs.nextInChain) && std::tie(\n        ) == std::tie(\n        );\n    }\n\n\n    static_assert(sizeof(InstanceDescriptor) == sizeof(WGPUInstanceDescriptor), \"sizeof mismatch for InstanceDescriptor\");\n    static_assert(alignof(InstanceDescriptor) == alignof(WGPUInstanceDescriptor), \"alignof mismatch for InstanceDescriptor\");\n\n    static_assert(offsetof(InstanceDescriptor, nextInChain) == offsetof(WGPUInstanceDescriptor, nextInChain),\n            \"offsetof mismatch for InstanceDescriptor::nextInChain\");\n\n    bool InstanceDescriptor::operator==(const InstanceDescriptor& rhs) const {\n        return (nextInChain == rhs.nextInChain) && std::tie(\n        ) == std::tie(\n        );\n    }\n\n\n    static_assert(sizeof(Limits) == sizeof(WGPULimits), \"sizeof mismatch for Limits\");\n    static_assert(alignof(Limits) == alignof(WGPULimits), \"alignof mismatch for Limits\");\n\n    static_assert(offsetof(Limits, maxTextureDimension1D) == offsetof(WGPULimits, maxTextureDimension1D),\n            \"offsetof mismatch for Limits::maxTextureDimension1D\");\n    static_assert(offsetof(Limits, maxTextureDimension2D) == offsetof(WGPULimits, maxTextureDimension2D),\n            \"offsetof mismatch for Limits::maxTextureDimension2D\");\n    static_assert(offsetof(Limits, maxTextureDimension3D) == offsetof(WGPULimits, maxTextureDimension3D),\n            \"offsetof mismatch for Limits::maxTextureDimension3D\");\n    static_assert(offsetof(Limits, maxTextureArrayLayers) == offsetof(WGPULimits, maxTextureArrayLayers),\n            \"offsetof mismatch for Limits::maxTextureArrayLayers\");\n    static_assert(offsetof(Limits, maxBindGroups) == offsetof(WGPULimits, maxBindGroups),\n            \"offsetof mismatch for Limits::maxBindGroups\");\n    static_assert(offsetof(Limits, maxBindGroupsPlusVertexBuffers) == offsetof(WGPULimits, maxBindGroupsPlusVertexBuffers),\n            \"offsetof mismatch for Limits::maxBindGroupsPlusVertexBuffers\");\n    static_assert(offsetof(Limits, maxBindingsPerBindGroup) == offsetof(WGPULimits, maxBindingsPerBindGroup),\n            \"offsetof mismatch for Limits::maxBindingsPerBindGroup\");\n    static_assert(offsetof(Limits, maxDynamicUniformBuffersPerPipelineLayout) == offsetof(WGPULimits, maxDynamicUniformBuffersPerPipelineLayout),\n            \"offsetof mismatch for Limits::maxDynamicUniformBuffersPerPipelineLayout\");\n    static_assert(offsetof(Limits, maxDynamicStorageBuffersPerPipelineLayout) == offsetof(WGPULimits, maxDynamicStorageBuffersPerPipelineLayout),\n            \"offsetof mismatch for Limits::maxDynamicStorageBuffersPerPipelineLayout\");\n    static_assert(offsetof(Limits, maxSampledTexturesPerShaderStage) == offsetof(WGPULimits, maxSampledTexturesPerShaderStage),\n            \"offsetof mismatch for Limits::maxSampledTexturesPerShaderStage\");\n    static_assert(offsetof(Limits, maxSamplersPerShaderStage) == offsetof(WGPULimits, maxSamplersPerShaderStage),\n            \"offsetof mismatch for Limits::maxSamplersPerShaderStage\");\n    static_assert(offsetof(Limits, maxStorageBuffersPerShaderStage) == offsetof(WGPULimits, maxStorageBuffersPerShaderStage),\n            \"offsetof mismatch for Limits::maxStorageBuffersPerShaderStage\");\n    static_assert(offsetof(Limits, maxStorageTexturesPerShaderStage) == offsetof(WGPULimits, maxStorageTexturesPerShaderStage),\n            \"offsetof mismatch for Limits::maxStorageTexturesPerShaderStage\");\n    static_assert(offsetof(Limits, maxUniformBuffersPerShaderStage) == offsetof(WGPULimits, maxUniformBuffersPerShaderStage),\n            \"offsetof mismatch for Limits::maxUniformBuffersPerShaderStage\");\n    static_assert(offsetof(Limits, maxUniformBufferBindingSize) == offsetof(WGPULimits, maxUniformBufferBindingSize),\n            \"offsetof mismatch for Limits::maxUniformBufferBindingSize\");\n    static_assert(offsetof(Limits, maxStorageBufferBindingSize) == offsetof(WGPULimits, maxStorageBufferBindingSize),\n            \"offsetof mismatch for Limits::maxStorageBufferBindingSize\");\n    static_assert(offsetof(Limits, minUniformBufferOffsetAlignment) == offsetof(WGPULimits, minUniformBufferOffsetAlignment),\n            \"offsetof mismatch for Limits::minUniformBufferOffsetAlignment\");\n    static_assert(offsetof(Limits, minStorageBufferOffsetAlignment) == offsetof(WGPULimits, minStorageBufferOffsetAlignment),\n            \"offsetof mismatch for Limits::minStorageBufferOffsetAlignment\");\n    static_assert(offsetof(Limits, maxVertexBuffers) == offsetof(WGPULimits, maxVertexBuffers),\n            \"offsetof mismatch for Limits::maxVertexBuffers\");\n    static_assert(offsetof(Limits, maxBufferSize) == offsetof(WGPULimits, maxBufferSize),\n            \"offsetof mismatch for Limits::maxBufferSize\");\n    static_assert(offsetof(Limits, maxVertexAttributes) == offsetof(WGPULimits, maxVertexAttributes),\n            \"offsetof mismatch for Limits::maxVertexAttributes\");\n    static_assert(offsetof(Limits, maxVertexBufferArrayStride) == offsetof(WGPULimits, maxVertexBufferArrayStride),\n            \"offsetof mismatch for Limits::maxVertexBufferArrayStride\");\n    static_assert(offsetof(Limits, maxInterStageShaderComponents) == offsetof(WGPULimits, maxInterStageShaderComponents),\n            \"offsetof mismatch for Limits::maxInterStageShaderComponents\");\n    static_assert(offsetof(Limits, maxInterStageShaderVariables) == offsetof(WGPULimits, maxInterStageShaderVariables),\n            \"offsetof mismatch for Limits::maxInterStageShaderVariables\");\n    static_assert(offsetof(Limits, maxColorAttachments) == offsetof(WGPULimits, maxColorAttachments),\n            \"offsetof mismatch for Limits::maxColorAttachments\");\n    static_assert(offsetof(Limits, maxColorAttachmentBytesPerSample) == offsetof(WGPULimits, maxColorAttachmentBytesPerSample),\n            \"offsetof mismatch for Limits::maxColorAttachmentBytesPerSample\");\n    static_assert(offsetof(Limits, maxComputeWorkgroupStorageSize) == offsetof(WGPULimits, maxComputeWorkgroupStorageSize),\n            \"offsetof mismatch for Limits::maxComputeWorkgroupStorageSize\");\n    static_assert(offsetof(Limits, maxComputeInvocationsPerWorkgroup) == offsetof(WGPULimits, maxComputeInvocationsPerWorkgroup),\n            \"offsetof mismatch for Limits::maxComputeInvocationsPerWorkgroup\");\n    static_assert(offsetof(Limits, maxComputeWorkgroupSizeX) == offsetof(WGPULimits, maxComputeWorkgroupSizeX),\n            \"offsetof mismatch for Limits::maxComputeWorkgroupSizeX\");\n    static_assert(offsetof(Limits, maxComputeWorkgroupSizeY) == offsetof(WGPULimits, maxComputeWorkgroupSizeY),\n            \"offsetof mismatch for Limits::maxComputeWorkgroupSizeY\");\n    static_assert(offsetof(Limits, maxComputeWorkgroupSizeZ) == offsetof(WGPULimits, maxComputeWorkgroupSizeZ),\n            \"offsetof mismatch for Limits::maxComputeWorkgroupSizeZ\");\n    static_assert(offsetof(Limits, maxComputeWorkgroupsPerDimension) == offsetof(WGPULimits, maxComputeWorkgroupsPerDimension),\n            \"offsetof mismatch for Limits::maxComputeWorkgroupsPerDimension\");\n\n    bool Limits::operator==(const Limits& rhs) const {\n        return  std::tie(\n            maxTextureDimension1D,\n            maxTextureDimension2D,\n            maxTextureDimension3D,\n            maxTextureArrayLayers,\n            maxBindGroups,\n            maxBindGroupsPlusVertexBuffers,\n            maxBindingsPerBindGroup,\n            maxDynamicUniformBuffersPerPipelineLayout,\n            maxDynamicStorageBuffersPerPipelineLayout,\n            maxSampledTexturesPerShaderStage,\n            maxSamplersPerShaderStage,\n            maxStorageBuffersPerShaderStage,\n            maxStorageTexturesPerShaderStage,\n            maxUniformBuffersPerShaderStage,\n            maxUniformBufferBindingSize,\n            maxStorageBufferBindingSize,\n            minUniformBufferOffsetAlignment,\n            minStorageBufferOffsetAlignment,\n            maxVertexBuffers,\n            maxBufferSize,\n            maxVertexAttributes,\n            maxVertexBufferArrayStride,\n            maxInterStageShaderComponents,\n            maxInterStageShaderVariables,\n            maxColorAttachments,\n            maxColorAttachmentBytesPerSample,\n            maxComputeWorkgroupStorageSize,\n            maxComputeInvocationsPerWorkgroup,\n            maxComputeWorkgroupSizeX,\n            maxComputeWorkgroupSizeY,\n            maxComputeWorkgroupSizeZ,\n            maxComputeWorkgroupsPerDimension\n        ) == std::tie(\n            rhs.maxTextureDimension1D,\n            rhs.maxTextureDimension2D,\n            rhs.maxTextureDimension3D,\n            rhs.maxTextureArrayLayers,\n            rhs.maxBindGroups,\n            rhs.maxBindGroupsPlusVertexBuffers,\n            rhs.maxBindingsPerBindGroup,\n            rhs.maxDynamicUniformBuffersPerPipelineLayout,\n            rhs.maxDynamicStorageBuffersPerPipelineLayout,\n            rhs.maxSampledTexturesPerShaderStage,\n            rhs.maxSamplersPerShaderStage,\n            rhs.maxStorageBuffersPerShaderStage,\n            rhs.maxStorageTexturesPerShaderStage,\n            rhs.maxUniformBuffersPerShaderStage,\n            rhs.maxUniformBufferBindingSize,\n            rhs.maxStorageBufferBindingSize,\n            rhs.minUniformBufferOffsetAlignment,\n            rhs.minStorageBufferOffsetAlignment,\n            rhs.maxVertexBuffers,\n            rhs.maxBufferSize,\n            rhs.maxVertexAttributes,\n            rhs.maxVertexBufferArrayStride,\n            rhs.maxInterStageShaderComponents,\n            rhs.maxInterStageShaderVariables,\n            rhs.maxColorAttachments,\n            rhs.maxColorAttachmentBytesPerSample,\n            rhs.maxComputeWorkgroupStorageSize,\n            rhs.maxComputeInvocationsPerWorkgroup,\n            rhs.maxComputeWorkgroupSizeX,\n            rhs.maxComputeWorkgroupSizeY,\n            rhs.maxComputeWorkgroupSizeZ,\n            rhs.maxComputeWorkgroupsPerDimension\n        );\n    }\n\n\n    static_assert(sizeof(MultisampleState) == sizeof(WGPUMultisampleState), \"sizeof mismatch for MultisampleState\");\n    static_assert(alignof(MultisampleState) == alignof(WGPUMultisampleState), \"alignof mismatch for MultisampleState\");\n\n    static_assert(offsetof(MultisampleState, nextInChain) == offsetof(WGPUMultisampleState, nextInChain),\n            \"offsetof mismatch for MultisampleState::nextInChain\");\n    static_assert(offsetof(MultisampleState, count) == offsetof(WGPUMultisampleState, count),\n            \"offsetof mismatch for MultisampleState::count\");\n    static_assert(offsetof(MultisampleState, mask) == offsetof(WGPUMultisampleState, mask),\n            \"offsetof mismatch for MultisampleState::mask\");\n    static_assert(offsetof(MultisampleState, alphaToCoverageEnabled) == offsetof(WGPUMultisampleState, alphaToCoverageEnabled),\n            \"offsetof mismatch for MultisampleState::alphaToCoverageEnabled\");\n\n    bool MultisampleState::operator==(const MultisampleState& rhs) const {\n        return (nextInChain == rhs.nextInChain) && std::tie(\n            count,\n            mask,\n            alphaToCoverageEnabled\n        ) == std::tie(\n            rhs.count,\n            rhs.mask,\n            rhs.alphaToCoverageEnabled\n        );\n    }\n\n\n    static_assert(sizeof(Origin2D) == sizeof(WGPUOrigin2D), \"sizeof mismatch for Origin2D\");\n    static_assert(alignof(Origin2D) == alignof(WGPUOrigin2D), \"alignof mismatch for Origin2D\");\n\n    static_assert(offsetof(Origin2D, x) == offsetof(WGPUOrigin2D, x),\n            \"offsetof mismatch for Origin2D::x\");\n    static_assert(offsetof(Origin2D, y) == offsetof(WGPUOrigin2D, y),\n            \"offsetof mismatch for Origin2D::y\");\n\n    bool Origin2D::operator==(const Origin2D& rhs) const {\n        return  std::tie(\n            x,\n            y\n        ) == std::tie(\n            rhs.x,\n            rhs.y\n        );\n    }\n\n\n    static_assert(sizeof(Origin3D) == sizeof(WGPUOrigin3D), \"sizeof mismatch for Origin3D\");\n    static_assert(alignof(Origin3D) == alignof(WGPUOrigin3D), \"alignof mismatch for Origin3D\");\n\n    static_assert(offsetof(Origin3D, x) == offsetof(WGPUOrigin3D, x),\n            \"offsetof mismatch for Origin3D::x\");\n    static_assert(offsetof(Origin3D, y) == offsetof(WGPUOrigin3D, y),\n            \"offsetof mismatch for Origin3D::y\");\n    static_assert(offsetof(Origin3D, z) == offsetof(WGPUOrigin3D, z),\n            \"offsetof mismatch for Origin3D::z\");\n\n    bool Origin3D::operator==(const Origin3D& rhs) const {\n        return  std::tie(\n            x,\n            y,\n            z\n        ) == std::tie(\n            rhs.x,\n            rhs.y,\n            rhs.z\n        );\n    }\n\n\n    static_assert(sizeof(PipelineLayoutDescriptor) == sizeof(WGPUPipelineLayoutDescriptor), \"sizeof mismatch for PipelineLayoutDescriptor\");\n    static_assert(alignof(PipelineLayoutDescriptor) == alignof(WGPUPipelineLayoutDescriptor), \"alignof mismatch for PipelineLayoutDescriptor\");\n\n    static_assert(offsetof(PipelineLayoutDescriptor, nextInChain) == offsetof(WGPUPipelineLayoutDescriptor, nextInChain),\n            \"offsetof mismatch for PipelineLayoutDescriptor::nextInChain\");\n    static_assert(offsetof(PipelineLayoutDescriptor, label) == offsetof(WGPUPipelineLayoutDescriptor, label),\n            \"offsetof mismatch for PipelineLayoutDescriptor::label\");\n    static_assert(offsetof(PipelineLayoutDescriptor, bindGroupLayoutCount) == offsetof(WGPUPipelineLayoutDescriptor, bindGroupLayoutCount),\n            \"offsetof mismatch for PipelineLayoutDescriptor::bindGroupLayoutCount\");\n    static_assert(offsetof(PipelineLayoutDescriptor, bindGroupLayouts) == offsetof(WGPUPipelineLayoutDescriptor, bindGroupLayouts),\n            \"offsetof mismatch for PipelineLayoutDescriptor::bindGroupLayouts\");\n\n    bool PipelineLayoutDescriptor::operator==(const PipelineLayoutDescriptor& rhs) const {\n        return (nextInChain == rhs.nextInChain) && std::tie(\n            label,\n            bindGroupLayoutCount,\n            bindGroupLayouts\n        ) == std::tie(\n            rhs.label,\n            rhs.bindGroupLayoutCount,\n            rhs.bindGroupLayouts\n        );\n    }\n\n\n    static_assert(sizeof(PrimitiveDepthClipControl) == sizeof(WGPUPrimitiveDepthClipControl), \"sizeof mismatch for PrimitiveDepthClipControl\");\n    static_assert(alignof(PrimitiveDepthClipControl) == alignof(WGPUPrimitiveDepthClipControl), \"alignof mismatch for PrimitiveDepthClipControl\");\n\n    static_assert(offsetof(PrimitiveDepthClipControl, unclippedDepth) == offsetof(WGPUPrimitiveDepthClipControl, unclippedDepth),\n            \"offsetof mismatch for PrimitiveDepthClipControl::unclippedDepth\");\n\n    bool PrimitiveDepthClipControl::operator==(const PrimitiveDepthClipControl& rhs) const {\n        return (nextInChain == rhs.nextInChain) && std::tie(\n            unclippedDepth\n        ) == std::tie(\n            rhs.unclippedDepth\n        );\n    }\n\n\n    static_assert(sizeof(PrimitiveState) == sizeof(WGPUPrimitiveState), \"sizeof mismatch for PrimitiveState\");\n    static_assert(alignof(PrimitiveState) == alignof(WGPUPrimitiveState), \"alignof mismatch for PrimitiveState\");\n\n    static_assert(offsetof(PrimitiveState, nextInChain) == offsetof(WGPUPrimitiveState, nextInChain),\n            \"offsetof mismatch for PrimitiveState::nextInChain\");\n    static_assert(offsetof(PrimitiveState, topology) == offsetof(WGPUPrimitiveState, topology),\n            \"offsetof mismatch for PrimitiveState::topology\");\n    static_assert(offsetof(PrimitiveState, stripIndexFormat) == offsetof(WGPUPrimitiveState, stripIndexFormat),\n            \"offsetof mismatch for PrimitiveState::stripIndexFormat\");\n    static_assert(offsetof(PrimitiveState, frontFace) == offsetof(WGPUPrimitiveState, frontFace),\n            \"offsetof mismatch for PrimitiveState::frontFace\");\n    static_assert(offsetof(PrimitiveState, cullMode) == offsetof(WGPUPrimitiveState, cullMode),\n            \"offsetof mismatch for PrimitiveState::cullMode\");\n\n    bool PrimitiveState::operator==(const PrimitiveState& rhs) const {\n        return (nextInChain == rhs.nextInChain) && std::tie(\n            topology,\n            stripIndexFormat,\n            frontFace,\n            cullMode\n        ) == std::tie(\n            rhs.topology,\n            rhs.stripIndexFormat,\n            rhs.frontFace,\n            rhs.cullMode\n        );\n    }\n\n\n    static_assert(sizeof(QuerySetDescriptor) == sizeof(WGPUQuerySetDescriptor), \"sizeof mismatch for QuerySetDescriptor\");\n    static_assert(alignof(QuerySetDescriptor) == alignof(WGPUQuerySetDescriptor), \"alignof mismatch for QuerySetDescriptor\");\n\n    static_assert(offsetof(QuerySetDescriptor, nextInChain) == offsetof(WGPUQuerySetDescriptor, nextInChain),\n            \"offsetof mismatch for QuerySetDescriptor::nextInChain\");\n    static_assert(offsetof(QuerySetDescriptor, label) == offsetof(WGPUQuerySetDescriptor, label),\n            \"offsetof mismatch for QuerySetDescriptor::label\");\n    static_assert(offsetof(QuerySetDescriptor, type) == offsetof(WGPUQuerySetDescriptor, type),\n            \"offsetof mismatch for QuerySetDescriptor::type\");\n    static_assert(offsetof(QuerySetDescriptor, count) == offsetof(WGPUQuerySetDescriptor, count),\n            \"offsetof mismatch for QuerySetDescriptor::count\");\n    static_assert(offsetof(QuerySetDescriptor, pipelineStatistics) == offsetof(WGPUQuerySetDescriptor, pipelineStatistics),\n            \"offsetof mismatch for QuerySetDescriptor::pipelineStatistics\");\n    static_assert(offsetof(QuerySetDescriptor, pipelineStatisticsCount) == offsetof(WGPUQuerySetDescriptor, pipelineStatisticsCount),\n            \"offsetof mismatch for QuerySetDescriptor::pipelineStatisticsCount\");\n\n    bool QuerySetDescriptor::operator==(const QuerySetDescriptor& rhs) const {\n        return (nextInChain == rhs.nextInChain) && std::tie(\n            label,\n            type,\n            count,\n            pipelineStatistics,\n            pipelineStatisticsCount\n        ) == std::tie(\n            rhs.label,\n            rhs.type,\n            rhs.count,\n            rhs.pipelineStatistics,\n            rhs.pipelineStatisticsCount\n        );\n    }\n\n\n    static_assert(sizeof(QueueDescriptor) == sizeof(WGPUQueueDescriptor), \"sizeof mismatch for QueueDescriptor\");\n    static_assert(alignof(QueueDescriptor) == alignof(WGPUQueueDescriptor), \"alignof mismatch for QueueDescriptor\");\n\n    static_assert(offsetof(QueueDescriptor, nextInChain) == offsetof(WGPUQueueDescriptor, nextInChain),\n            \"offsetof mismatch for QueueDescriptor::nextInChain\");\n    static_assert(offsetof(QueueDescriptor, label) == offsetof(WGPUQueueDescriptor, label),\n            \"offsetof mismatch for QueueDescriptor::label\");\n\n    bool QueueDescriptor::operator==(const QueueDescriptor& rhs) const {\n        return (nextInChain == rhs.nextInChain) && std::tie(\n            label\n        ) == std::tie(\n            rhs.label\n        );\n    }\n\n\n    static_assert(sizeof(RenderBundleDescriptor) == sizeof(WGPURenderBundleDescriptor), \"sizeof mismatch for RenderBundleDescriptor\");\n    static_assert(alignof(RenderBundleDescriptor) == alignof(WGPURenderBundleDescriptor), \"alignof mismatch for RenderBundleDescriptor\");\n\n    static_assert(offsetof(RenderBundleDescriptor, nextInChain) == offsetof(WGPURenderBundleDescriptor, nextInChain),\n            \"offsetof mismatch for RenderBundleDescriptor::nextInChain\");\n    static_assert(offsetof(RenderBundleDescriptor, label) == offsetof(WGPURenderBundleDescriptor, label),\n            \"offsetof mismatch for RenderBundleDescriptor::label\");\n\n    bool RenderBundleDescriptor::operator==(const RenderBundleDescriptor& rhs) const {\n        return (nextInChain == rhs.nextInChain) && std::tie(\n            label\n        ) == std::tie(\n            rhs.label\n        );\n    }\n\n\n    static_assert(sizeof(RenderBundleEncoderDescriptor) == sizeof(WGPURenderBundleEncoderDescriptor), \"sizeof mismatch for RenderBundleEncoderDescriptor\");\n    static_assert(alignof(RenderBundleEncoderDescriptor) == alignof(WGPURenderBundleEncoderDescriptor), \"alignof mismatch for RenderBundleEncoderDescriptor\");\n\n    static_assert(offsetof(RenderBundleEncoderDescriptor, nextInChain) == offsetof(WGPURenderBundleEncoderDescriptor, nextInChain),\n            \"offsetof mismatch for RenderBundleEncoderDescriptor::nextInChain\");\n    static_assert(offsetof(RenderBundleEncoderDescriptor, label) == offsetof(WGPURenderBundleEncoderDescriptor, label),\n            \"offsetof mismatch for RenderBundleEncoderDescriptor::label\");\n    static_assert(offsetof(RenderBundleEncoderDescriptor, colorFormatsCount) == offsetof(WGPURenderBundleEncoderDescriptor, colorFormatsCount),\n            \"offsetof mismatch for RenderBundleEncoderDescriptor::colorFormatsCount\");\n    static_assert(offsetof(RenderBundleEncoderDescriptor, colorFormats) == offsetof(WGPURenderBundleEncoderDescriptor, colorFormats),\n            \"offsetof mismatch for RenderBundleEncoderDescriptor::colorFormats\");\n    static_assert(offsetof(RenderBundleEncoderDescriptor, depthStencilFormat) == offsetof(WGPURenderBundleEncoderDescriptor, depthStencilFormat),\n            \"offsetof mismatch for RenderBundleEncoderDescriptor::depthStencilFormat\");\n    static_assert(offsetof(RenderBundleEncoderDescriptor, sampleCount) == offsetof(WGPURenderBundleEncoderDescriptor, sampleCount),\n            \"offsetof mismatch for RenderBundleEncoderDescriptor::sampleCount\");\n    static_assert(offsetof(RenderBundleEncoderDescriptor, depthReadOnly) == offsetof(WGPURenderBundleEncoderDescriptor, depthReadOnly),\n            \"offsetof mismatch for RenderBundleEncoderDescriptor::depthReadOnly\");\n    static_assert(offsetof(RenderBundleEncoderDescriptor, stencilReadOnly) == offsetof(WGPURenderBundleEncoderDescriptor, stencilReadOnly),\n            \"offsetof mismatch for RenderBundleEncoderDescriptor::stencilReadOnly\");\n\n    bool RenderBundleEncoderDescriptor::operator==(const RenderBundleEncoderDescriptor& rhs) const {\n        return (nextInChain == rhs.nextInChain) && std::tie(\n            label,\n            colorFormatsCount,\n            colorFormats,\n            depthStencilFormat,\n            sampleCount,\n            depthReadOnly,\n            stencilReadOnly\n        ) == std::tie(\n            rhs.label,\n            rhs.colorFormatsCount,\n            rhs.colorFormats,\n            rhs.depthStencilFormat,\n            rhs.sampleCount,\n            rhs.depthReadOnly,\n            rhs.stencilReadOnly\n        );\n    }\n\n\n    static_assert(sizeof(RenderPassDepthStencilAttachment) == sizeof(WGPURenderPassDepthStencilAttachment), \"sizeof mismatch for RenderPassDepthStencilAttachment\");\n    static_assert(alignof(RenderPassDepthStencilAttachment) == alignof(WGPURenderPassDepthStencilAttachment), \"alignof mismatch for RenderPassDepthStencilAttachment\");\n\n    static_assert(offsetof(RenderPassDepthStencilAttachment, view) == offsetof(WGPURenderPassDepthStencilAttachment, view),\n            \"offsetof mismatch for RenderPassDepthStencilAttachment::view\");\n    static_assert(offsetof(RenderPassDepthStencilAttachment, depthLoadOp) == offsetof(WGPURenderPassDepthStencilAttachment, depthLoadOp),\n            \"offsetof mismatch for RenderPassDepthStencilAttachment::depthLoadOp\");\n    static_assert(offsetof(RenderPassDepthStencilAttachment, depthStoreOp) == offsetof(WGPURenderPassDepthStencilAttachment, depthStoreOp),\n            \"offsetof mismatch for RenderPassDepthStencilAttachment::depthStoreOp\");\n    static_assert(offsetof(RenderPassDepthStencilAttachment, depthClearValue) == offsetof(WGPURenderPassDepthStencilAttachment, depthClearValue),\n            \"offsetof mismatch for RenderPassDepthStencilAttachment::depthClearValue\");\n    static_assert(offsetof(RenderPassDepthStencilAttachment, depthReadOnly) == offsetof(WGPURenderPassDepthStencilAttachment, depthReadOnly),\n            \"offsetof mismatch for RenderPassDepthStencilAttachment::depthReadOnly\");\n    static_assert(offsetof(RenderPassDepthStencilAttachment, stencilLoadOp) == offsetof(WGPURenderPassDepthStencilAttachment, stencilLoadOp),\n            \"offsetof mismatch for RenderPassDepthStencilAttachment::stencilLoadOp\");\n    static_assert(offsetof(RenderPassDepthStencilAttachment, stencilStoreOp) == offsetof(WGPURenderPassDepthStencilAttachment, stencilStoreOp),\n            \"offsetof mismatch for RenderPassDepthStencilAttachment::stencilStoreOp\");\n    static_assert(offsetof(RenderPassDepthStencilAttachment, stencilClearValue) == offsetof(WGPURenderPassDepthStencilAttachment, stencilClearValue),\n            \"offsetof mismatch for RenderPassDepthStencilAttachment::stencilClearValue\");\n    static_assert(offsetof(RenderPassDepthStencilAttachment, stencilReadOnly) == offsetof(WGPURenderPassDepthStencilAttachment, stencilReadOnly),\n            \"offsetof mismatch for RenderPassDepthStencilAttachment::stencilReadOnly\");\n\n    bool RenderPassDepthStencilAttachment::operator==(const RenderPassDepthStencilAttachment& rhs) const {\n        return  std::tie(\n            view,\n            depthLoadOp,\n            depthStoreOp,\n            depthClearValue,\n            depthReadOnly,\n            stencilLoadOp,\n            stencilStoreOp,\n            stencilClearValue,\n            stencilReadOnly\n        ) == std::tie(\n            rhs.view,\n            rhs.depthLoadOp,\n            rhs.depthStoreOp,\n            rhs.depthClearValue,\n            rhs.depthReadOnly,\n            rhs.stencilLoadOp,\n            rhs.stencilStoreOp,\n            rhs.stencilClearValue,\n            rhs.stencilReadOnly\n        );\n    }\n\n\n    static_assert(sizeof(RenderPassDescriptorMaxDrawCount) == sizeof(WGPURenderPassDescriptorMaxDrawCount), \"sizeof mismatch for RenderPassDescriptorMaxDrawCount\");\n    static_assert(alignof(RenderPassDescriptorMaxDrawCount) == alignof(WGPURenderPassDescriptorMaxDrawCount), \"alignof mismatch for RenderPassDescriptorMaxDrawCount\");\n\n    static_assert(offsetof(RenderPassDescriptorMaxDrawCount, maxDrawCount) == offsetof(WGPURenderPassDescriptorMaxDrawCount, maxDrawCount),\n            \"offsetof mismatch for RenderPassDescriptorMaxDrawCount::maxDrawCount\");\n\n    bool RenderPassDescriptorMaxDrawCount::operator==(const RenderPassDescriptorMaxDrawCount& rhs) const {\n        return (nextInChain == rhs.nextInChain) && std::tie(\n            maxDrawCount\n        ) == std::tie(\n            rhs.maxDrawCount\n        );\n    }\n\n\n    static_assert(sizeof(RenderPassTimestampWrite) == sizeof(WGPURenderPassTimestampWrite), \"sizeof mismatch for RenderPassTimestampWrite\");\n    static_assert(alignof(RenderPassTimestampWrite) == alignof(WGPURenderPassTimestampWrite), \"alignof mismatch for RenderPassTimestampWrite\");\n\n    static_assert(offsetof(RenderPassTimestampWrite, querySet) == offsetof(WGPURenderPassTimestampWrite, querySet),\n            \"offsetof mismatch for RenderPassTimestampWrite::querySet\");\n    static_assert(offsetof(RenderPassTimestampWrite, queryIndex) == offsetof(WGPURenderPassTimestampWrite, queryIndex),\n            \"offsetof mismatch for RenderPassTimestampWrite::queryIndex\");\n    static_assert(offsetof(RenderPassTimestampWrite, location) == offsetof(WGPURenderPassTimestampWrite, location),\n            \"offsetof mismatch for RenderPassTimestampWrite::location\");\n\n    bool RenderPassTimestampWrite::operator==(const RenderPassTimestampWrite& rhs) const {\n        return  std::tie(\n            querySet,\n            queryIndex,\n            location\n        ) == std::tie(\n            rhs.querySet,\n            rhs.queryIndex,\n            rhs.location\n        );\n    }\n\n\n    static_assert(sizeof(RequestAdapterOptions) == sizeof(WGPURequestAdapterOptions), \"sizeof mismatch for RequestAdapterOptions\");\n    static_assert(alignof(RequestAdapterOptions) == alignof(WGPURequestAdapterOptions), \"alignof mismatch for RequestAdapterOptions\");\n\n    static_assert(offsetof(RequestAdapterOptions, nextInChain) == offsetof(WGPURequestAdapterOptions, nextInChain),\n            \"offsetof mismatch for RequestAdapterOptions::nextInChain\");\n    static_assert(offsetof(RequestAdapterOptions, compatibleSurface) == offsetof(WGPURequestAdapterOptions, compatibleSurface),\n            \"offsetof mismatch for RequestAdapterOptions::compatibleSurface\");\n    static_assert(offsetof(RequestAdapterOptions, powerPreference) == offsetof(WGPURequestAdapterOptions, powerPreference),\n            \"offsetof mismatch for RequestAdapterOptions::powerPreference\");\n    static_assert(offsetof(RequestAdapterOptions, backendType) == offsetof(WGPURequestAdapterOptions, backendType),\n            \"offsetof mismatch for RequestAdapterOptions::backendType\");\n    static_assert(offsetof(RequestAdapterOptions, forceFallbackAdapter) == offsetof(WGPURequestAdapterOptions, forceFallbackAdapter),\n            \"offsetof mismatch for RequestAdapterOptions::forceFallbackAdapter\");\n    static_assert(offsetof(RequestAdapterOptions, compatibilityMode) == offsetof(WGPURequestAdapterOptions, compatibilityMode),\n            \"offsetof mismatch for RequestAdapterOptions::compatibilityMode\");\n\n    bool RequestAdapterOptions::operator==(const RequestAdapterOptions& rhs) const {\n        return (nextInChain == rhs.nextInChain) && std::tie(\n            compatibleSurface,\n            powerPreference,\n            backendType,\n            forceFallbackAdapter,\n            compatibilityMode\n        ) == std::tie(\n            rhs.compatibleSurface,\n            rhs.powerPreference,\n            rhs.backendType,\n            rhs.forceFallbackAdapter,\n            rhs.compatibilityMode\n        );\n    }\n\n\n    static_assert(sizeof(SamplerBindingLayout) == sizeof(WGPUSamplerBindingLayout), \"sizeof mismatch for SamplerBindingLayout\");\n    static_assert(alignof(SamplerBindingLayout) == alignof(WGPUSamplerBindingLayout), \"alignof mismatch for SamplerBindingLayout\");\n\n    static_assert(offsetof(SamplerBindingLayout, nextInChain) == offsetof(WGPUSamplerBindingLayout, nextInChain),\n            \"offsetof mismatch for SamplerBindingLayout::nextInChain\");\n    static_assert(offsetof(SamplerBindingLayout, type) == offsetof(WGPUSamplerBindingLayout, type),\n            \"offsetof mismatch for SamplerBindingLayout::type\");\n\n    bool SamplerBindingLayout::operator==(const SamplerBindingLayout& rhs) const {\n        return (nextInChain == rhs.nextInChain) && std::tie(\n            type\n        ) == std::tie(\n            rhs.type\n        );\n    }\n\n\n    static_assert(sizeof(SamplerDescriptor) == sizeof(WGPUSamplerDescriptor), \"sizeof mismatch for SamplerDescriptor\");\n    static_assert(alignof(SamplerDescriptor) == alignof(WGPUSamplerDescriptor), \"alignof mismatch for SamplerDescriptor\");\n\n    static_assert(offsetof(SamplerDescriptor, nextInChain) == offsetof(WGPUSamplerDescriptor, nextInChain),\n            \"offsetof mismatch for SamplerDescriptor::nextInChain\");\n    static_assert(offsetof(SamplerDescriptor, label) == offsetof(WGPUSamplerDescriptor, label),\n            \"offsetof mismatch for SamplerDescriptor::label\");\n    static_assert(offsetof(SamplerDescriptor, addressModeU) == offsetof(WGPUSamplerDescriptor, addressModeU),\n            \"offsetof mismatch for SamplerDescriptor::addressModeU\");\n    static_assert(offsetof(SamplerDescriptor, addressModeV) == offsetof(WGPUSamplerDescriptor, addressModeV),\n            \"offsetof mismatch for SamplerDescriptor::addressModeV\");\n    static_assert(offsetof(SamplerDescriptor, addressModeW) == offsetof(WGPUSamplerDescriptor, addressModeW),\n            \"offsetof mismatch for SamplerDescriptor::addressModeW\");\n    static_assert(offsetof(SamplerDescriptor, magFilter) == offsetof(WGPUSamplerDescriptor, magFilter),\n            \"offsetof mismatch for SamplerDescriptor::magFilter\");\n    static_assert(offsetof(SamplerDescriptor, minFilter) == offsetof(WGPUSamplerDescriptor, minFilter),\n            \"offsetof mismatch for SamplerDescriptor::minFilter\");\n    static_assert(offsetof(SamplerDescriptor, mipmapFilter) == offsetof(WGPUSamplerDescriptor, mipmapFilter),\n            \"offsetof mismatch for SamplerDescriptor::mipmapFilter\");\n    static_assert(offsetof(SamplerDescriptor, lodMinClamp) == offsetof(WGPUSamplerDescriptor, lodMinClamp),\n            \"offsetof mismatch for SamplerDescriptor::lodMinClamp\");\n    static_assert(offsetof(SamplerDescriptor, lodMaxClamp) == offsetof(WGPUSamplerDescriptor, lodMaxClamp),\n            \"offsetof mismatch for SamplerDescriptor::lodMaxClamp\");\n    static_assert(offsetof(SamplerDescriptor, compare) == offsetof(WGPUSamplerDescriptor, compare),\n            \"offsetof mismatch for SamplerDescriptor::compare\");\n    static_assert(offsetof(SamplerDescriptor, maxAnisotropy) == offsetof(WGPUSamplerDescriptor, maxAnisotropy),\n            \"offsetof mismatch for SamplerDescriptor::maxAnisotropy\");\n\n    bool SamplerDescriptor::operator==(const SamplerDescriptor& rhs) const {\n        return (nextInChain == rhs.nextInChain) && std::tie(\n            label,\n            addressModeU,\n            addressModeV,\n            addressModeW,\n            magFilter,\n            minFilter,\n            mipmapFilter,\n            lodMinClamp,\n            lodMaxClamp,\n            compare,\n            maxAnisotropy\n        ) == std::tie(\n            rhs.label,\n            rhs.addressModeU,\n            rhs.addressModeV,\n            rhs.addressModeW,\n            rhs.magFilter,\n            rhs.minFilter,\n            rhs.mipmapFilter,\n            rhs.lodMinClamp,\n            rhs.lodMaxClamp,\n            rhs.compare,\n            rhs.maxAnisotropy\n        );\n    }\n\n\n    static_assert(sizeof(ShaderModuleDescriptor) == sizeof(WGPUShaderModuleDescriptor), \"sizeof mismatch for ShaderModuleDescriptor\");\n    static_assert(alignof(ShaderModuleDescriptor) == alignof(WGPUShaderModuleDescriptor), \"alignof mismatch for ShaderModuleDescriptor\");\n\n    static_assert(offsetof(ShaderModuleDescriptor, nextInChain) == offsetof(WGPUShaderModuleDescriptor, nextInChain),\n            \"offsetof mismatch for ShaderModuleDescriptor::nextInChain\");\n    static_assert(offsetof(ShaderModuleDescriptor, label) == offsetof(WGPUShaderModuleDescriptor, label),\n            \"offsetof mismatch for ShaderModuleDescriptor::label\");\n\n    bool ShaderModuleDescriptor::operator==(const ShaderModuleDescriptor& rhs) const {\n        return (nextInChain == rhs.nextInChain) && std::tie(\n            label\n        ) == std::tie(\n            rhs.label\n        );\n    }\n\n\n    static_assert(sizeof(ShaderModuleSPIRVDescriptor) == sizeof(WGPUShaderModuleSPIRVDescriptor), \"sizeof mismatch for ShaderModuleSPIRVDescriptor\");\n    static_assert(alignof(ShaderModuleSPIRVDescriptor) == alignof(WGPUShaderModuleSPIRVDescriptor), \"alignof mismatch for ShaderModuleSPIRVDescriptor\");\n\n    static_assert(offsetof(ShaderModuleSPIRVDescriptor, codeSize) == offsetof(WGPUShaderModuleSPIRVDescriptor, codeSize),\n            \"offsetof mismatch for ShaderModuleSPIRVDescriptor::codeSize\");\n    static_assert(offsetof(ShaderModuleSPIRVDescriptor, code) == offsetof(WGPUShaderModuleSPIRVDescriptor, code),\n            \"offsetof mismatch for ShaderModuleSPIRVDescriptor::code\");\n\n    bool ShaderModuleSPIRVDescriptor::operator==(const ShaderModuleSPIRVDescriptor& rhs) const {\n        return (nextInChain == rhs.nextInChain) && std::tie(\n            codeSize,\n            code\n        ) == std::tie(\n            rhs.codeSize,\n            rhs.code\n        );\n    }\n\n\n    static_assert(sizeof(ShaderModuleWGSLDescriptor) == sizeof(WGPUShaderModuleWGSLDescriptor), \"sizeof mismatch for ShaderModuleWGSLDescriptor\");\n    static_assert(alignof(ShaderModuleWGSLDescriptor) == alignof(WGPUShaderModuleWGSLDescriptor), \"alignof mismatch for ShaderModuleWGSLDescriptor\");\n\n    static_assert(offsetof(ShaderModuleWGSLDescriptor, code) == offsetof(WGPUShaderModuleWGSLDescriptor, code),\n            \"offsetof mismatch for ShaderModuleWGSLDescriptor::code\");\n\n    bool ShaderModuleWGSLDescriptor::operator==(const ShaderModuleWGSLDescriptor& rhs) const {\n        return (nextInChain == rhs.nextInChain) && std::tie(\n            code\n        ) == std::tie(\n            rhs.code\n        );\n    }\n\n\n    static_assert(sizeof(StencilFaceState) == sizeof(WGPUStencilFaceState), \"sizeof mismatch for StencilFaceState\");\n    static_assert(alignof(StencilFaceState) == alignof(WGPUStencilFaceState), \"alignof mismatch for StencilFaceState\");\n\n    static_assert(offsetof(StencilFaceState, compare) == offsetof(WGPUStencilFaceState, compare),\n            \"offsetof mismatch for StencilFaceState::compare\");\n    static_assert(offsetof(StencilFaceState, failOp) == offsetof(WGPUStencilFaceState, failOp),\n            \"offsetof mismatch for StencilFaceState::failOp\");\n    static_assert(offsetof(StencilFaceState, depthFailOp) == offsetof(WGPUStencilFaceState, depthFailOp),\n            \"offsetof mismatch for StencilFaceState::depthFailOp\");\n    static_assert(offsetof(StencilFaceState, passOp) == offsetof(WGPUStencilFaceState, passOp),\n            \"offsetof mismatch for StencilFaceState::passOp\");\n\n    bool StencilFaceState::operator==(const StencilFaceState& rhs) const {\n        return  std::tie(\n            compare,\n            failOp,\n            depthFailOp,\n            passOp\n        ) == std::tie(\n            rhs.compare,\n            rhs.failOp,\n            rhs.depthFailOp,\n            rhs.passOp\n        );\n    }\n\n\n    static_assert(sizeof(StorageTextureBindingLayout) == sizeof(WGPUStorageTextureBindingLayout), \"sizeof mismatch for StorageTextureBindingLayout\");\n    static_assert(alignof(StorageTextureBindingLayout) == alignof(WGPUStorageTextureBindingLayout), \"alignof mismatch for StorageTextureBindingLayout\");\n\n    static_assert(offsetof(StorageTextureBindingLayout, nextInChain) == offsetof(WGPUStorageTextureBindingLayout, nextInChain),\n            \"offsetof mismatch for StorageTextureBindingLayout::nextInChain\");\n    static_assert(offsetof(StorageTextureBindingLayout, access) == offsetof(WGPUStorageTextureBindingLayout, access),\n            \"offsetof mismatch for StorageTextureBindingLayout::access\");\n    static_assert(offsetof(StorageTextureBindingLayout, format) == offsetof(WGPUStorageTextureBindingLayout, format),\n            \"offsetof mismatch for StorageTextureBindingLayout::format\");\n    static_assert(offsetof(StorageTextureBindingLayout, viewDimension) == offsetof(WGPUStorageTextureBindingLayout, viewDimension),\n            \"offsetof mismatch for StorageTextureBindingLayout::viewDimension\");\n\n    bool StorageTextureBindingLayout::operator==(const StorageTextureBindingLayout& rhs) const {\n        return (nextInChain == rhs.nextInChain) && std::tie(\n            access,\n            format,\n            viewDimension\n        ) == std::tie(\n            rhs.access,\n            rhs.format,\n            rhs.viewDimension\n        );\n    }\n\n\n    static_assert(sizeof(SurfaceDescriptor) == sizeof(WGPUSurfaceDescriptor), \"sizeof mismatch for SurfaceDescriptor\");\n    static_assert(alignof(SurfaceDescriptor) == alignof(WGPUSurfaceDescriptor), \"alignof mismatch for SurfaceDescriptor\");\n\n    static_assert(offsetof(SurfaceDescriptor, nextInChain) == offsetof(WGPUSurfaceDescriptor, nextInChain),\n            \"offsetof mismatch for SurfaceDescriptor::nextInChain\");\n    static_assert(offsetof(SurfaceDescriptor, label) == offsetof(WGPUSurfaceDescriptor, label),\n            \"offsetof mismatch for SurfaceDescriptor::label\");\n\n    bool SurfaceDescriptor::operator==(const SurfaceDescriptor& rhs) const {\n        return (nextInChain == rhs.nextInChain) && std::tie(\n            label\n        ) == std::tie(\n            rhs.label\n        );\n    }\n\n\n    static_assert(sizeof(SurfaceDescriptorFromAndroidNativeWindow) == sizeof(WGPUSurfaceDescriptorFromAndroidNativeWindow), \"sizeof mismatch for SurfaceDescriptorFromAndroidNativeWindow\");\n    static_assert(alignof(SurfaceDescriptorFromAndroidNativeWindow) == alignof(WGPUSurfaceDescriptorFromAndroidNativeWindow), \"alignof mismatch for SurfaceDescriptorFromAndroidNativeWindow\");\n\n    static_assert(offsetof(SurfaceDescriptorFromAndroidNativeWindow, window) == offsetof(WGPUSurfaceDescriptorFromAndroidNativeWindow, window),\n            \"offsetof mismatch for SurfaceDescriptorFromAndroidNativeWindow::window\");\n\n    bool SurfaceDescriptorFromAndroidNativeWindow::operator==(const SurfaceDescriptorFromAndroidNativeWindow& rhs) const {\n        return (nextInChain == rhs.nextInChain) && std::tie(\n            window\n        ) == std::tie(\n            rhs.window\n        );\n    }\n\n\n    static_assert(sizeof(SurfaceDescriptorFromCanvasHTMLSelector) == sizeof(WGPUSurfaceDescriptorFromCanvasHTMLSelector), \"sizeof mismatch for SurfaceDescriptorFromCanvasHTMLSelector\");\n    static_assert(alignof(SurfaceDescriptorFromCanvasHTMLSelector) == alignof(WGPUSurfaceDescriptorFromCanvasHTMLSelector), \"alignof mismatch for SurfaceDescriptorFromCanvasHTMLSelector\");\n\n    static_assert(offsetof(SurfaceDescriptorFromCanvasHTMLSelector, selector) == offsetof(WGPUSurfaceDescriptorFromCanvasHTMLSelector, selector),\n            \"offsetof mismatch for SurfaceDescriptorFromCanvasHTMLSelector::selector\");\n\n    bool SurfaceDescriptorFromCanvasHTMLSelector::operator==(const SurfaceDescriptorFromCanvasHTMLSelector& rhs) const {\n        return (nextInChain == rhs.nextInChain) && std::tie(\n            selector\n        ) == std::tie(\n            rhs.selector\n        );\n    }\n\n\n    static_assert(sizeof(SurfaceDescriptorFromMetalLayer) == sizeof(WGPUSurfaceDescriptorFromMetalLayer), \"sizeof mismatch for SurfaceDescriptorFromMetalLayer\");\n    static_assert(alignof(SurfaceDescriptorFromMetalLayer) == alignof(WGPUSurfaceDescriptorFromMetalLayer), \"alignof mismatch for SurfaceDescriptorFromMetalLayer\");\n\n    static_assert(offsetof(SurfaceDescriptorFromMetalLayer, layer) == offsetof(WGPUSurfaceDescriptorFromMetalLayer, layer),\n            \"offsetof mismatch for SurfaceDescriptorFromMetalLayer::layer\");\n\n    bool SurfaceDescriptorFromMetalLayer::operator==(const SurfaceDescriptorFromMetalLayer& rhs) const {\n        return (nextInChain == rhs.nextInChain) && std::tie(\n            layer\n        ) == std::tie(\n            rhs.layer\n        );\n    }\n\n\n    static_assert(sizeof(SurfaceDescriptorFromWaylandSurface) == sizeof(WGPUSurfaceDescriptorFromWaylandSurface), \"sizeof mismatch for SurfaceDescriptorFromWaylandSurface\");\n    static_assert(alignof(SurfaceDescriptorFromWaylandSurface) == alignof(WGPUSurfaceDescriptorFromWaylandSurface), \"alignof mismatch for SurfaceDescriptorFromWaylandSurface\");\n\n    static_assert(offsetof(SurfaceDescriptorFromWaylandSurface, display) == offsetof(WGPUSurfaceDescriptorFromWaylandSurface, display),\n            \"offsetof mismatch for SurfaceDescriptorFromWaylandSurface::display\");\n    static_assert(offsetof(SurfaceDescriptorFromWaylandSurface, surface) == offsetof(WGPUSurfaceDescriptorFromWaylandSurface, surface),\n            \"offsetof mismatch for SurfaceDescriptorFromWaylandSurface::surface\");\n\n    bool SurfaceDescriptorFromWaylandSurface::operator==(const SurfaceDescriptorFromWaylandSurface& rhs) const {\n        return (nextInChain == rhs.nextInChain) && std::tie(\n            display,\n            surface\n        ) == std::tie(\n            rhs.display,\n            rhs.surface\n        );\n    }\n\n\n    static_assert(sizeof(SurfaceDescriptorFromWindowsCoreWindow) == sizeof(WGPUSurfaceDescriptorFromWindowsCoreWindow), \"sizeof mismatch for SurfaceDescriptorFromWindowsCoreWindow\");\n    static_assert(alignof(SurfaceDescriptorFromWindowsCoreWindow) == alignof(WGPUSurfaceDescriptorFromWindowsCoreWindow), \"alignof mismatch for SurfaceDescriptorFromWindowsCoreWindow\");\n\n    static_assert(offsetof(SurfaceDescriptorFromWindowsCoreWindow, coreWindow) == offsetof(WGPUSurfaceDescriptorFromWindowsCoreWindow, coreWindow),\n            \"offsetof mismatch for SurfaceDescriptorFromWindowsCoreWindow::coreWindow\");\n\n    bool SurfaceDescriptorFromWindowsCoreWindow::operator==(const SurfaceDescriptorFromWindowsCoreWindow& rhs) const {\n        return (nextInChain == rhs.nextInChain) && std::tie(\n            coreWindow\n        ) == std::tie(\n            rhs.coreWindow\n        );\n    }\n\n\n    static_assert(sizeof(SurfaceDescriptorFromWindowsHWND) == sizeof(WGPUSurfaceDescriptorFromWindowsHWND), \"sizeof mismatch for SurfaceDescriptorFromWindowsHWND\");\n    static_assert(alignof(SurfaceDescriptorFromWindowsHWND) == alignof(WGPUSurfaceDescriptorFromWindowsHWND), \"alignof mismatch for SurfaceDescriptorFromWindowsHWND\");\n\n    static_assert(offsetof(SurfaceDescriptorFromWindowsHWND, hinstance) == offsetof(WGPUSurfaceDescriptorFromWindowsHWND, hinstance),\n            \"offsetof mismatch for SurfaceDescriptorFromWindowsHWND::hinstance\");\n    static_assert(offsetof(SurfaceDescriptorFromWindowsHWND, hwnd) == offsetof(WGPUSurfaceDescriptorFromWindowsHWND, hwnd),\n            \"offsetof mismatch for SurfaceDescriptorFromWindowsHWND::hwnd\");\n\n    bool SurfaceDescriptorFromWindowsHWND::operator==(const SurfaceDescriptorFromWindowsHWND& rhs) const {\n        return (nextInChain == rhs.nextInChain) && std::tie(\n            hinstance,\n            hwnd\n        ) == std::tie(\n            rhs.hinstance,\n            rhs.hwnd\n        );\n    }\n\n\n    static_assert(sizeof(SurfaceDescriptorFromWindowsSwapChainPanel) == sizeof(WGPUSurfaceDescriptorFromWindowsSwapChainPanel), \"sizeof mismatch for SurfaceDescriptorFromWindowsSwapChainPanel\");\n    static_assert(alignof(SurfaceDescriptorFromWindowsSwapChainPanel) == alignof(WGPUSurfaceDescriptorFromWindowsSwapChainPanel), \"alignof mismatch for SurfaceDescriptorFromWindowsSwapChainPanel\");\n\n    static_assert(offsetof(SurfaceDescriptorFromWindowsSwapChainPanel, swapChainPanel) == offsetof(WGPUSurfaceDescriptorFromWindowsSwapChainPanel, swapChainPanel),\n            \"offsetof mismatch for SurfaceDescriptorFromWindowsSwapChainPanel::swapChainPanel\");\n\n    bool SurfaceDescriptorFromWindowsSwapChainPanel::operator==(const SurfaceDescriptorFromWindowsSwapChainPanel& rhs) const {\n        return (nextInChain == rhs.nextInChain) && std::tie(\n            swapChainPanel\n        ) == std::tie(\n            rhs.swapChainPanel\n        );\n    }\n\n\n    static_assert(sizeof(SurfaceDescriptorFromXlibWindow) == sizeof(WGPUSurfaceDescriptorFromXlibWindow), \"sizeof mismatch for SurfaceDescriptorFromXlibWindow\");\n    static_assert(alignof(SurfaceDescriptorFromXlibWindow) == alignof(WGPUSurfaceDescriptorFromXlibWindow), \"alignof mismatch for SurfaceDescriptorFromXlibWindow\");\n\n    static_assert(offsetof(SurfaceDescriptorFromXlibWindow, display) == offsetof(WGPUSurfaceDescriptorFromXlibWindow, display),\n            \"offsetof mismatch for SurfaceDescriptorFromXlibWindow::display\");\n    static_assert(offsetof(SurfaceDescriptorFromXlibWindow, window) == offsetof(WGPUSurfaceDescriptorFromXlibWindow, window),\n            \"offsetof mismatch for SurfaceDescriptorFromXlibWindow::window\");\n\n    bool SurfaceDescriptorFromXlibWindow::operator==(const SurfaceDescriptorFromXlibWindow& rhs) const {\n        return (nextInChain == rhs.nextInChain) && std::tie(\n            display,\n            window\n        ) == std::tie(\n            rhs.display,\n            rhs.window\n        );\n    }\n\n\n    static_assert(sizeof(SwapChainDescriptor) == sizeof(WGPUSwapChainDescriptor), \"sizeof mismatch for SwapChainDescriptor\");\n    static_assert(alignof(SwapChainDescriptor) == alignof(WGPUSwapChainDescriptor), \"alignof mismatch for SwapChainDescriptor\");\n\n    static_assert(offsetof(SwapChainDescriptor, nextInChain) == offsetof(WGPUSwapChainDescriptor, nextInChain),\n            \"offsetof mismatch for SwapChainDescriptor::nextInChain\");\n    static_assert(offsetof(SwapChainDescriptor, label) == offsetof(WGPUSwapChainDescriptor, label),\n            \"offsetof mismatch for SwapChainDescriptor::label\");\n    static_assert(offsetof(SwapChainDescriptor, usage) == offsetof(WGPUSwapChainDescriptor, usage),\n            \"offsetof mismatch for SwapChainDescriptor::usage\");\n    static_assert(offsetof(SwapChainDescriptor, format) == offsetof(WGPUSwapChainDescriptor, format),\n            \"offsetof mismatch for SwapChainDescriptor::format\");\n    static_assert(offsetof(SwapChainDescriptor, width) == offsetof(WGPUSwapChainDescriptor, width),\n            \"offsetof mismatch for SwapChainDescriptor::width\");\n    static_assert(offsetof(SwapChainDescriptor, height) == offsetof(WGPUSwapChainDescriptor, height),\n            \"offsetof mismatch for SwapChainDescriptor::height\");\n    static_assert(offsetof(SwapChainDescriptor, presentMode) == offsetof(WGPUSwapChainDescriptor, presentMode),\n            \"offsetof mismatch for SwapChainDescriptor::presentMode\");\n\n    bool SwapChainDescriptor::operator==(const SwapChainDescriptor& rhs) const {\n        return (nextInChain == rhs.nextInChain) && std::tie(\n            label,\n            usage,\n            format,\n            width,\n            height,\n            presentMode\n        ) == std::tie(\n            rhs.label,\n            rhs.usage,\n            rhs.format,\n            rhs.width,\n            rhs.height,\n            rhs.presentMode\n        );\n    }\n\n\n    static_assert(sizeof(TextureBindingLayout) == sizeof(WGPUTextureBindingLayout), \"sizeof mismatch for TextureBindingLayout\");\n    static_assert(alignof(TextureBindingLayout) == alignof(WGPUTextureBindingLayout), \"alignof mismatch for TextureBindingLayout\");\n\n    static_assert(offsetof(TextureBindingLayout, nextInChain) == offsetof(WGPUTextureBindingLayout, nextInChain),\n            \"offsetof mismatch for TextureBindingLayout::nextInChain\");\n    static_assert(offsetof(TextureBindingLayout, sampleType) == offsetof(WGPUTextureBindingLayout, sampleType),\n            \"offsetof mismatch for TextureBindingLayout::sampleType\");\n    static_assert(offsetof(TextureBindingLayout, viewDimension) == offsetof(WGPUTextureBindingLayout, viewDimension),\n            \"offsetof mismatch for TextureBindingLayout::viewDimension\");\n    static_assert(offsetof(TextureBindingLayout, multisampled) == offsetof(WGPUTextureBindingLayout, multisampled),\n            \"offsetof mismatch for TextureBindingLayout::multisampled\");\n\n    bool TextureBindingLayout::operator==(const TextureBindingLayout& rhs) const {\n        return (nextInChain == rhs.nextInChain) && std::tie(\n            sampleType,\n            viewDimension,\n            multisampled\n        ) == std::tie(\n            rhs.sampleType,\n            rhs.viewDimension,\n            rhs.multisampled\n        );\n    }\n\n\n    static_assert(sizeof(TextureDataLayout) == sizeof(WGPUTextureDataLayout), \"sizeof mismatch for TextureDataLayout\");\n    static_assert(alignof(TextureDataLayout) == alignof(WGPUTextureDataLayout), \"alignof mismatch for TextureDataLayout\");\n\n    static_assert(offsetof(TextureDataLayout, nextInChain) == offsetof(WGPUTextureDataLayout, nextInChain),\n            \"offsetof mismatch for TextureDataLayout::nextInChain\");\n    static_assert(offsetof(TextureDataLayout, offset) == offsetof(WGPUTextureDataLayout, offset),\n            \"offsetof mismatch for TextureDataLayout::offset\");\n    static_assert(offsetof(TextureDataLayout, bytesPerRow) == offsetof(WGPUTextureDataLayout, bytesPerRow),\n            \"offsetof mismatch for TextureDataLayout::bytesPerRow\");\n    static_assert(offsetof(TextureDataLayout, rowsPerImage) == offsetof(WGPUTextureDataLayout, rowsPerImage),\n            \"offsetof mismatch for TextureDataLayout::rowsPerImage\");\n\n    bool TextureDataLayout::operator==(const TextureDataLayout& rhs) const {\n        return (nextInChain == rhs.nextInChain) && std::tie(\n            offset,\n            bytesPerRow,\n            rowsPerImage\n        ) == std::tie(\n            rhs.offset,\n            rhs.bytesPerRow,\n            rhs.rowsPerImage\n        );\n    }\n\n\n    static_assert(sizeof(TextureViewDescriptor) == sizeof(WGPUTextureViewDescriptor), \"sizeof mismatch for TextureViewDescriptor\");\n    static_assert(alignof(TextureViewDescriptor) == alignof(WGPUTextureViewDescriptor), \"alignof mismatch for TextureViewDescriptor\");\n\n    static_assert(offsetof(TextureViewDescriptor, nextInChain) == offsetof(WGPUTextureViewDescriptor, nextInChain),\n            \"offsetof mismatch for TextureViewDescriptor::nextInChain\");\n    static_assert(offsetof(TextureViewDescriptor, label) == offsetof(WGPUTextureViewDescriptor, label),\n            \"offsetof mismatch for TextureViewDescriptor::label\");\n    static_assert(offsetof(TextureViewDescriptor, format) == offsetof(WGPUTextureViewDescriptor, format),\n            \"offsetof mismatch for TextureViewDescriptor::format\");\n    static_assert(offsetof(TextureViewDescriptor, dimension) == offsetof(WGPUTextureViewDescriptor, dimension),\n            \"offsetof mismatch for TextureViewDescriptor::dimension\");\n    static_assert(offsetof(TextureViewDescriptor, baseMipLevel) == offsetof(WGPUTextureViewDescriptor, baseMipLevel),\n            \"offsetof mismatch for TextureViewDescriptor::baseMipLevel\");\n    static_assert(offsetof(TextureViewDescriptor, mipLevelCount) == offsetof(WGPUTextureViewDescriptor, mipLevelCount),\n            \"offsetof mismatch for TextureViewDescriptor::mipLevelCount\");\n    static_assert(offsetof(TextureViewDescriptor, baseArrayLayer) == offsetof(WGPUTextureViewDescriptor, baseArrayLayer),\n            \"offsetof mismatch for TextureViewDescriptor::baseArrayLayer\");\n    static_assert(offsetof(TextureViewDescriptor, arrayLayerCount) == offsetof(WGPUTextureViewDescriptor, arrayLayerCount),\n            \"offsetof mismatch for TextureViewDescriptor::arrayLayerCount\");\n    static_assert(offsetof(TextureViewDescriptor, aspect) == offsetof(WGPUTextureViewDescriptor, aspect),\n            \"offsetof mismatch for TextureViewDescriptor::aspect\");\n\n    bool TextureViewDescriptor::operator==(const TextureViewDescriptor& rhs) const {\n        return (nextInChain == rhs.nextInChain) && std::tie(\n            label,\n            format,\n            dimension,\n            baseMipLevel,\n            mipLevelCount,\n            baseArrayLayer,\n            arrayLayerCount,\n            aspect\n        ) == std::tie(\n            rhs.label,\n            rhs.format,\n            rhs.dimension,\n            rhs.baseMipLevel,\n            rhs.mipLevelCount,\n            rhs.baseArrayLayer,\n            rhs.arrayLayerCount,\n            rhs.aspect\n        );\n    }\n\n\n    static_assert(sizeof(VertexAttribute) == sizeof(WGPUVertexAttribute), \"sizeof mismatch for VertexAttribute\");\n    static_assert(alignof(VertexAttribute) == alignof(WGPUVertexAttribute), \"alignof mismatch for VertexAttribute\");\n\n    static_assert(offsetof(VertexAttribute, format) == offsetof(WGPUVertexAttribute, format),\n            \"offsetof mismatch for VertexAttribute::format\");\n    static_assert(offsetof(VertexAttribute, offset) == offsetof(WGPUVertexAttribute, offset),\n            \"offsetof mismatch for VertexAttribute::offset\");\n    static_assert(offsetof(VertexAttribute, shaderLocation) == offsetof(WGPUVertexAttribute, shaderLocation),\n            \"offsetof mismatch for VertexAttribute::shaderLocation\");\n\n    bool VertexAttribute::operator==(const VertexAttribute& rhs) const {\n        return  std::tie(\n            format,\n            offset,\n            shaderLocation\n        ) == std::tie(\n            rhs.format,\n            rhs.offset,\n            rhs.shaderLocation\n        );\n    }\n\n\n    static_assert(sizeof(BindGroupDescriptor) == sizeof(WGPUBindGroupDescriptor), \"sizeof mismatch for BindGroupDescriptor\");\n    static_assert(alignof(BindGroupDescriptor) == alignof(WGPUBindGroupDescriptor), \"alignof mismatch for BindGroupDescriptor\");\n\n    static_assert(offsetof(BindGroupDescriptor, nextInChain) == offsetof(WGPUBindGroupDescriptor, nextInChain),\n            \"offsetof mismatch for BindGroupDescriptor::nextInChain\");\n    static_assert(offsetof(BindGroupDescriptor, label) == offsetof(WGPUBindGroupDescriptor, label),\n            \"offsetof mismatch for BindGroupDescriptor::label\");\n    static_assert(offsetof(BindGroupDescriptor, layout) == offsetof(WGPUBindGroupDescriptor, layout),\n            \"offsetof mismatch for BindGroupDescriptor::layout\");\n    static_assert(offsetof(BindGroupDescriptor, entryCount) == offsetof(WGPUBindGroupDescriptor, entryCount),\n            \"offsetof mismatch for BindGroupDescriptor::entryCount\");\n    static_assert(offsetof(BindGroupDescriptor, entries) == offsetof(WGPUBindGroupDescriptor, entries),\n            \"offsetof mismatch for BindGroupDescriptor::entries\");\n\n    bool BindGroupDescriptor::operator==(const BindGroupDescriptor& rhs) const {\n        return (nextInChain == rhs.nextInChain) && std::tie(\n            label,\n            layout,\n            entryCount,\n            entries\n        ) == std::tie(\n            rhs.label,\n            rhs.layout,\n            rhs.entryCount,\n            rhs.entries\n        );\n    }\n\n\n    static_assert(sizeof(BindGroupLayoutEntry) == sizeof(WGPUBindGroupLayoutEntry), \"sizeof mismatch for BindGroupLayoutEntry\");\n    static_assert(alignof(BindGroupLayoutEntry) == alignof(WGPUBindGroupLayoutEntry), \"alignof mismatch for BindGroupLayoutEntry\");\n\n    static_assert(offsetof(BindGroupLayoutEntry, nextInChain) == offsetof(WGPUBindGroupLayoutEntry, nextInChain),\n            \"offsetof mismatch for BindGroupLayoutEntry::nextInChain\");\n    static_assert(offsetof(BindGroupLayoutEntry, binding) == offsetof(WGPUBindGroupLayoutEntry, binding),\n            \"offsetof mismatch for BindGroupLayoutEntry::binding\");\n    static_assert(offsetof(BindGroupLayoutEntry, visibility) == offsetof(WGPUBindGroupLayoutEntry, visibility),\n            \"offsetof mismatch for BindGroupLayoutEntry::visibility\");\n    static_assert(offsetof(BindGroupLayoutEntry, buffer) == offsetof(WGPUBindGroupLayoutEntry, buffer),\n            \"offsetof mismatch for BindGroupLayoutEntry::buffer\");\n    static_assert(offsetof(BindGroupLayoutEntry, sampler) == offsetof(WGPUBindGroupLayoutEntry, sampler),\n            \"offsetof mismatch for BindGroupLayoutEntry::sampler\");\n    static_assert(offsetof(BindGroupLayoutEntry, texture) == offsetof(WGPUBindGroupLayoutEntry, texture),\n            \"offsetof mismatch for BindGroupLayoutEntry::texture\");\n    static_assert(offsetof(BindGroupLayoutEntry, storageTexture) == offsetof(WGPUBindGroupLayoutEntry, storageTexture),\n            \"offsetof mismatch for BindGroupLayoutEntry::storageTexture\");\n\n    bool BindGroupLayoutEntry::operator==(const BindGroupLayoutEntry& rhs) const {\n        return (nextInChain == rhs.nextInChain) && std::tie(\n            binding,\n            visibility,\n            buffer,\n            sampler,\n            texture,\n            storageTexture\n        ) == std::tie(\n            rhs.binding,\n            rhs.visibility,\n            rhs.buffer,\n            rhs.sampler,\n            rhs.texture,\n            rhs.storageTexture\n        );\n    }\n\n\n    static_assert(sizeof(BlendState) == sizeof(WGPUBlendState), \"sizeof mismatch for BlendState\");\n    static_assert(alignof(BlendState) == alignof(WGPUBlendState), \"alignof mismatch for BlendState\");\n\n    static_assert(offsetof(BlendState, color) == offsetof(WGPUBlendState, color),\n            \"offsetof mismatch for BlendState::color\");\n    static_assert(offsetof(BlendState, alpha) == offsetof(WGPUBlendState, alpha),\n            \"offsetof mismatch for BlendState::alpha\");\n\n    bool BlendState::operator==(const BlendState& rhs) const {\n        return  std::tie(\n            color,\n            alpha\n        ) == std::tie(\n            rhs.color,\n            rhs.alpha\n        );\n    }\n\n\n    static_assert(sizeof(CompilationInfo) == sizeof(WGPUCompilationInfo), \"sizeof mismatch for CompilationInfo\");\n    static_assert(alignof(CompilationInfo) == alignof(WGPUCompilationInfo), \"alignof mismatch for CompilationInfo\");\n\n    static_assert(offsetof(CompilationInfo, nextInChain) == offsetof(WGPUCompilationInfo, nextInChain),\n            \"offsetof mismatch for CompilationInfo::nextInChain\");\n    static_assert(offsetof(CompilationInfo, messageCount) == offsetof(WGPUCompilationInfo, messageCount),\n            \"offsetof mismatch for CompilationInfo::messageCount\");\n    static_assert(offsetof(CompilationInfo, messages) == offsetof(WGPUCompilationInfo, messages),\n            \"offsetof mismatch for CompilationInfo::messages\");\n\n    bool CompilationInfo::operator==(const CompilationInfo& rhs) const {\n        return (nextInChain == rhs.nextInChain) && std::tie(\n            messageCount,\n            messages\n        ) == std::tie(\n            rhs.messageCount,\n            rhs.messages\n        );\n    }\n\n\n    static_assert(sizeof(ComputePassDescriptor) == sizeof(WGPUComputePassDescriptor), \"sizeof mismatch for ComputePassDescriptor\");\n    static_assert(alignof(ComputePassDescriptor) == alignof(WGPUComputePassDescriptor), \"alignof mismatch for ComputePassDescriptor\");\n\n    static_assert(offsetof(ComputePassDescriptor, nextInChain) == offsetof(WGPUComputePassDescriptor, nextInChain),\n            \"offsetof mismatch for ComputePassDescriptor::nextInChain\");\n    static_assert(offsetof(ComputePassDescriptor, label) == offsetof(WGPUComputePassDescriptor, label),\n            \"offsetof mismatch for ComputePassDescriptor::label\");\n    static_assert(offsetof(ComputePassDescriptor, timestampWriteCount) == offsetof(WGPUComputePassDescriptor, timestampWriteCount),\n            \"offsetof mismatch for ComputePassDescriptor::timestampWriteCount\");\n    static_assert(offsetof(ComputePassDescriptor, timestampWrites) == offsetof(WGPUComputePassDescriptor, timestampWrites),\n            \"offsetof mismatch for ComputePassDescriptor::timestampWrites\");\n\n    bool ComputePassDescriptor::operator==(const ComputePassDescriptor& rhs) const {\n        return (nextInChain == rhs.nextInChain) && std::tie(\n            label,\n            timestampWriteCount,\n            timestampWrites\n        ) == std::tie(\n            rhs.label,\n            rhs.timestampWriteCount,\n            rhs.timestampWrites\n        );\n    }\n\n\n    static_assert(sizeof(DepthStencilState) == sizeof(WGPUDepthStencilState), \"sizeof mismatch for DepthStencilState\");\n    static_assert(alignof(DepthStencilState) == alignof(WGPUDepthStencilState), \"alignof mismatch for DepthStencilState\");\n\n    static_assert(offsetof(DepthStencilState, nextInChain) == offsetof(WGPUDepthStencilState, nextInChain),\n            \"offsetof mismatch for DepthStencilState::nextInChain\");\n    static_assert(offsetof(DepthStencilState, format) == offsetof(WGPUDepthStencilState, format),\n            \"offsetof mismatch for DepthStencilState::format\");\n    static_assert(offsetof(DepthStencilState, depthWriteEnabled) == offsetof(WGPUDepthStencilState, depthWriteEnabled),\n            \"offsetof mismatch for DepthStencilState::depthWriteEnabled\");\n    static_assert(offsetof(DepthStencilState, depthCompare) == offsetof(WGPUDepthStencilState, depthCompare),\n            \"offsetof mismatch for DepthStencilState::depthCompare\");\n    static_assert(offsetof(DepthStencilState, stencilFront) == offsetof(WGPUDepthStencilState, stencilFront),\n            \"offsetof mismatch for DepthStencilState::stencilFront\");\n    static_assert(offsetof(DepthStencilState, stencilBack) == offsetof(WGPUDepthStencilState, stencilBack),\n            \"offsetof mismatch for DepthStencilState::stencilBack\");\n    static_assert(offsetof(DepthStencilState, stencilReadMask) == offsetof(WGPUDepthStencilState, stencilReadMask),\n            \"offsetof mismatch for DepthStencilState::stencilReadMask\");\n    static_assert(offsetof(DepthStencilState, stencilWriteMask) == offsetof(WGPUDepthStencilState, stencilWriteMask),\n            \"offsetof mismatch for DepthStencilState::stencilWriteMask\");\n    static_assert(offsetof(DepthStencilState, depthBias) == offsetof(WGPUDepthStencilState, depthBias),\n            \"offsetof mismatch for DepthStencilState::depthBias\");\n    static_assert(offsetof(DepthStencilState, depthBiasSlopeScale) == offsetof(WGPUDepthStencilState, depthBiasSlopeScale),\n            \"offsetof mismatch for DepthStencilState::depthBiasSlopeScale\");\n    static_assert(offsetof(DepthStencilState, depthBiasClamp) == offsetof(WGPUDepthStencilState, depthBiasClamp),\n            \"offsetof mismatch for DepthStencilState::depthBiasClamp\");\n\n    bool DepthStencilState::operator==(const DepthStencilState& rhs) const {\n        return (nextInChain == rhs.nextInChain) && std::tie(\n            format,\n            depthWriteEnabled,\n            depthCompare,\n            stencilFront,\n            stencilBack,\n            stencilReadMask,\n            stencilWriteMask,\n            depthBias,\n            depthBiasSlopeScale,\n            depthBiasClamp\n        ) == std::tie(\n            rhs.format,\n            rhs.depthWriteEnabled,\n            rhs.depthCompare,\n            rhs.stencilFront,\n            rhs.stencilBack,\n            rhs.stencilReadMask,\n            rhs.stencilWriteMask,\n            rhs.depthBias,\n            rhs.depthBiasSlopeScale,\n            rhs.depthBiasClamp\n        );\n    }\n\n\n    static_assert(sizeof(ExternalTextureDescriptor) == sizeof(WGPUExternalTextureDescriptor), \"sizeof mismatch for ExternalTextureDescriptor\");\n    static_assert(alignof(ExternalTextureDescriptor) == alignof(WGPUExternalTextureDescriptor), \"alignof mismatch for ExternalTextureDescriptor\");\n\n    static_assert(offsetof(ExternalTextureDescriptor, nextInChain) == offsetof(WGPUExternalTextureDescriptor, nextInChain),\n            \"offsetof mismatch for ExternalTextureDescriptor::nextInChain\");\n    static_assert(offsetof(ExternalTextureDescriptor, label) == offsetof(WGPUExternalTextureDescriptor, label),\n            \"offsetof mismatch for ExternalTextureDescriptor::label\");\n    static_assert(offsetof(ExternalTextureDescriptor, plane0) == offsetof(WGPUExternalTextureDescriptor, plane0),\n            \"offsetof mismatch for ExternalTextureDescriptor::plane0\");\n    static_assert(offsetof(ExternalTextureDescriptor, plane1) == offsetof(WGPUExternalTextureDescriptor, plane1),\n            \"offsetof mismatch for ExternalTextureDescriptor::plane1\");\n    static_assert(offsetof(ExternalTextureDescriptor, visibleOrigin) == offsetof(WGPUExternalTextureDescriptor, visibleOrigin),\n            \"offsetof mismatch for ExternalTextureDescriptor::visibleOrigin\");\n    static_assert(offsetof(ExternalTextureDescriptor, visibleSize) == offsetof(WGPUExternalTextureDescriptor, visibleSize),\n            \"offsetof mismatch for ExternalTextureDescriptor::visibleSize\");\n    static_assert(offsetof(ExternalTextureDescriptor, doYuvToRgbConversionOnly) == offsetof(WGPUExternalTextureDescriptor, doYuvToRgbConversionOnly),\n            \"offsetof mismatch for ExternalTextureDescriptor::doYuvToRgbConversionOnly\");\n    static_assert(offsetof(ExternalTextureDescriptor, yuvToRgbConversionMatrix) == offsetof(WGPUExternalTextureDescriptor, yuvToRgbConversionMatrix),\n            \"offsetof mismatch for ExternalTextureDescriptor::yuvToRgbConversionMatrix\");\n    static_assert(offsetof(ExternalTextureDescriptor, srcTransferFunctionParameters) == offsetof(WGPUExternalTextureDescriptor, srcTransferFunctionParameters),\n            \"offsetof mismatch for ExternalTextureDescriptor::srcTransferFunctionParameters\");\n    static_assert(offsetof(ExternalTextureDescriptor, dstTransferFunctionParameters) == offsetof(WGPUExternalTextureDescriptor, dstTransferFunctionParameters),\n            \"offsetof mismatch for ExternalTextureDescriptor::dstTransferFunctionParameters\");\n    static_assert(offsetof(ExternalTextureDescriptor, gamutConversionMatrix) == offsetof(WGPUExternalTextureDescriptor, gamutConversionMatrix),\n            \"offsetof mismatch for ExternalTextureDescriptor::gamutConversionMatrix\");\n    static_assert(offsetof(ExternalTextureDescriptor, flipY) == offsetof(WGPUExternalTextureDescriptor, flipY),\n            \"offsetof mismatch for ExternalTextureDescriptor::flipY\");\n    static_assert(offsetof(ExternalTextureDescriptor, rotation) == offsetof(WGPUExternalTextureDescriptor, rotation),\n            \"offsetof mismatch for ExternalTextureDescriptor::rotation\");\n\n    bool ExternalTextureDescriptor::operator==(const ExternalTextureDescriptor& rhs) const {\n        return (nextInChain == rhs.nextInChain) && std::tie(\n            label,\n            plane0,\n            plane1,\n            visibleOrigin,\n            visibleSize,\n            doYuvToRgbConversionOnly,\n            yuvToRgbConversionMatrix,\n            srcTransferFunctionParameters,\n            dstTransferFunctionParameters,\n            gamutConversionMatrix,\n            flipY,\n            rotation\n        ) == std::tie(\n            rhs.label,\n            rhs.plane0,\n            rhs.plane1,\n            rhs.visibleOrigin,\n            rhs.visibleSize,\n            rhs.doYuvToRgbConversionOnly,\n            rhs.yuvToRgbConversionMatrix,\n            rhs.srcTransferFunctionParameters,\n            rhs.dstTransferFunctionParameters,\n            rhs.gamutConversionMatrix,\n            rhs.flipY,\n            rhs.rotation\n        );\n    }\n\n\n    static_assert(sizeof(ImageCopyBuffer) == sizeof(WGPUImageCopyBuffer), \"sizeof mismatch for ImageCopyBuffer\");\n    static_assert(alignof(ImageCopyBuffer) == alignof(WGPUImageCopyBuffer), \"alignof mismatch for ImageCopyBuffer\");\n\n    static_assert(offsetof(ImageCopyBuffer, nextInChain) == offsetof(WGPUImageCopyBuffer, nextInChain),\n            \"offsetof mismatch for ImageCopyBuffer::nextInChain\");\n    static_assert(offsetof(ImageCopyBuffer, layout) == offsetof(WGPUImageCopyBuffer, layout),\n            \"offsetof mismatch for ImageCopyBuffer::layout\");\n    static_assert(offsetof(ImageCopyBuffer, buffer) == offsetof(WGPUImageCopyBuffer, buffer),\n            \"offsetof mismatch for ImageCopyBuffer::buffer\");\n\n    bool ImageCopyBuffer::operator==(const ImageCopyBuffer& rhs) const {\n        return (nextInChain == rhs.nextInChain) && std::tie(\n            layout,\n            buffer\n        ) == std::tie(\n            rhs.layout,\n            rhs.buffer\n        );\n    }\n\n\n    static_assert(sizeof(ImageCopyExternalTexture) == sizeof(WGPUImageCopyExternalTexture), \"sizeof mismatch for ImageCopyExternalTexture\");\n    static_assert(alignof(ImageCopyExternalTexture) == alignof(WGPUImageCopyExternalTexture), \"alignof mismatch for ImageCopyExternalTexture\");\n\n    static_assert(offsetof(ImageCopyExternalTexture, nextInChain) == offsetof(WGPUImageCopyExternalTexture, nextInChain),\n            \"offsetof mismatch for ImageCopyExternalTexture::nextInChain\");\n    static_assert(offsetof(ImageCopyExternalTexture, externalTexture) == offsetof(WGPUImageCopyExternalTexture, externalTexture),\n            \"offsetof mismatch for ImageCopyExternalTexture::externalTexture\");\n    static_assert(offsetof(ImageCopyExternalTexture, origin) == offsetof(WGPUImageCopyExternalTexture, origin),\n            \"offsetof mismatch for ImageCopyExternalTexture::origin\");\n    static_assert(offsetof(ImageCopyExternalTexture, naturalSize) == offsetof(WGPUImageCopyExternalTexture, naturalSize),\n            \"offsetof mismatch for ImageCopyExternalTexture::naturalSize\");\n\n    bool ImageCopyExternalTexture::operator==(const ImageCopyExternalTexture& rhs) const {\n        return (nextInChain == rhs.nextInChain) && std::tie(\n            externalTexture,\n            origin,\n            naturalSize\n        ) == std::tie(\n            rhs.externalTexture,\n            rhs.origin,\n            rhs.naturalSize\n        );\n    }\n\n\n    static_assert(sizeof(ImageCopyTexture) == sizeof(WGPUImageCopyTexture), \"sizeof mismatch for ImageCopyTexture\");\n    static_assert(alignof(ImageCopyTexture) == alignof(WGPUImageCopyTexture), \"alignof mismatch for ImageCopyTexture\");\n\n    static_assert(offsetof(ImageCopyTexture, nextInChain) == offsetof(WGPUImageCopyTexture, nextInChain),\n            \"offsetof mismatch for ImageCopyTexture::nextInChain\");\n    static_assert(offsetof(ImageCopyTexture, texture) == offsetof(WGPUImageCopyTexture, texture),\n            \"offsetof mismatch for ImageCopyTexture::texture\");\n    static_assert(offsetof(ImageCopyTexture, mipLevel) == offsetof(WGPUImageCopyTexture, mipLevel),\n            \"offsetof mismatch for ImageCopyTexture::mipLevel\");\n    static_assert(offsetof(ImageCopyTexture, origin) == offsetof(WGPUImageCopyTexture, origin),\n            \"offsetof mismatch for ImageCopyTexture::origin\");\n    static_assert(offsetof(ImageCopyTexture, aspect) == offsetof(WGPUImageCopyTexture, aspect),\n            \"offsetof mismatch for ImageCopyTexture::aspect\");\n\n    bool ImageCopyTexture::operator==(const ImageCopyTexture& rhs) const {\n        return (nextInChain == rhs.nextInChain) && std::tie(\n            texture,\n            mipLevel,\n            origin,\n            aspect\n        ) == std::tie(\n            rhs.texture,\n            rhs.mipLevel,\n            rhs.origin,\n            rhs.aspect\n        );\n    }\n\n\n    static_assert(sizeof(ProgrammableStageDescriptor) == sizeof(WGPUProgrammableStageDescriptor), \"sizeof mismatch for ProgrammableStageDescriptor\");\n    static_assert(alignof(ProgrammableStageDescriptor) == alignof(WGPUProgrammableStageDescriptor), \"alignof mismatch for ProgrammableStageDescriptor\");\n\n    static_assert(offsetof(ProgrammableStageDescriptor, nextInChain) == offsetof(WGPUProgrammableStageDescriptor, nextInChain),\n            \"offsetof mismatch for ProgrammableStageDescriptor::nextInChain\");\n    static_assert(offsetof(ProgrammableStageDescriptor, module) == offsetof(WGPUProgrammableStageDescriptor, module),\n            \"offsetof mismatch for ProgrammableStageDescriptor::module\");\n    static_assert(offsetof(ProgrammableStageDescriptor, entryPoint) == offsetof(WGPUProgrammableStageDescriptor, entryPoint),\n            \"offsetof mismatch for ProgrammableStageDescriptor::entryPoint\");\n    static_assert(offsetof(ProgrammableStageDescriptor, constantCount) == offsetof(WGPUProgrammableStageDescriptor, constantCount),\n            \"offsetof mismatch for ProgrammableStageDescriptor::constantCount\");\n    static_assert(offsetof(ProgrammableStageDescriptor, constants) == offsetof(WGPUProgrammableStageDescriptor, constants),\n            \"offsetof mismatch for ProgrammableStageDescriptor::constants\");\n\n    bool ProgrammableStageDescriptor::operator==(const ProgrammableStageDescriptor& rhs) const {\n        return (nextInChain == rhs.nextInChain) && std::tie(\n            module,\n            entryPoint,\n            constantCount,\n            constants\n        ) == std::tie(\n            rhs.module,\n            rhs.entryPoint,\n            rhs.constantCount,\n            rhs.constants\n        );\n    }\n\n\n    static_assert(sizeof(RenderPassColorAttachment) == sizeof(WGPURenderPassColorAttachment), \"sizeof mismatch for RenderPassColorAttachment\");\n    static_assert(alignof(RenderPassColorAttachment) == alignof(WGPURenderPassColorAttachment), \"alignof mismatch for RenderPassColorAttachment\");\n\n    static_assert(offsetof(RenderPassColorAttachment, nextInChain) == offsetof(WGPURenderPassColorAttachment, nextInChain),\n            \"offsetof mismatch for RenderPassColorAttachment::nextInChain\");\n    static_assert(offsetof(RenderPassColorAttachment, view) == offsetof(WGPURenderPassColorAttachment, view),\n            \"offsetof mismatch for RenderPassColorAttachment::view\");\n    static_assert(offsetof(RenderPassColorAttachment, resolveTarget) == offsetof(WGPURenderPassColorAttachment, resolveTarget),\n            \"offsetof mismatch for RenderPassColorAttachment::resolveTarget\");\n    static_assert(offsetof(RenderPassColorAttachment, loadOp) == offsetof(WGPURenderPassColorAttachment, loadOp),\n            \"offsetof mismatch for RenderPassColorAttachment::loadOp\");\n    static_assert(offsetof(RenderPassColorAttachment, storeOp) == offsetof(WGPURenderPassColorAttachment, storeOp),\n            \"offsetof mismatch for RenderPassColorAttachment::storeOp\");\n    static_assert(offsetof(RenderPassColorAttachment, clearValue) == offsetof(WGPURenderPassColorAttachment, clearValue),\n            \"offsetof mismatch for RenderPassColorAttachment::clearValue\");\n\n    bool RenderPassColorAttachment::operator==(const RenderPassColorAttachment& rhs) const {\n        return (nextInChain == rhs.nextInChain) && std::tie(\n            view,\n            resolveTarget,\n            loadOp,\n            storeOp,\n            clearValue\n        ) == std::tie(\n            rhs.view,\n            rhs.resolveTarget,\n            rhs.loadOp,\n            rhs.storeOp,\n            rhs.clearValue\n        );\n    }\n\n\n    static_assert(sizeof(RequiredLimits) == sizeof(WGPURequiredLimits), \"sizeof mismatch for RequiredLimits\");\n    static_assert(alignof(RequiredLimits) == alignof(WGPURequiredLimits), \"alignof mismatch for RequiredLimits\");\n\n    static_assert(offsetof(RequiredLimits, nextInChain) == offsetof(WGPURequiredLimits, nextInChain),\n            \"offsetof mismatch for RequiredLimits::nextInChain\");\n    static_assert(offsetof(RequiredLimits, limits) == offsetof(WGPURequiredLimits, limits),\n            \"offsetof mismatch for RequiredLimits::limits\");\n\n    bool RequiredLimits::operator==(const RequiredLimits& rhs) const {\n        return (nextInChain == rhs.nextInChain) && std::tie(\n            limits\n        ) == std::tie(\n            rhs.limits\n        );\n    }\n\n\n    static_assert(sizeof(SupportedLimits) == sizeof(WGPUSupportedLimits), \"sizeof mismatch for SupportedLimits\");\n    static_assert(alignof(SupportedLimits) == alignof(WGPUSupportedLimits), \"alignof mismatch for SupportedLimits\");\n\n    static_assert(offsetof(SupportedLimits, nextInChain) == offsetof(WGPUSupportedLimits, nextInChain),\n            \"offsetof mismatch for SupportedLimits::nextInChain\");\n    static_assert(offsetof(SupportedLimits, limits) == offsetof(WGPUSupportedLimits, limits),\n            \"offsetof mismatch for SupportedLimits::limits\");\n\n    bool SupportedLimits::operator==(const SupportedLimits& rhs) const {\n        return (nextInChain == rhs.nextInChain) && std::tie(\n            limits\n        ) == std::tie(\n            rhs.limits\n        );\n    }\n\n\n    static_assert(sizeof(TextureDescriptor) == sizeof(WGPUTextureDescriptor), \"sizeof mismatch for TextureDescriptor\");\n    static_assert(alignof(TextureDescriptor) == alignof(WGPUTextureDescriptor), \"alignof mismatch for TextureDescriptor\");\n\n    static_assert(offsetof(TextureDescriptor, nextInChain) == offsetof(WGPUTextureDescriptor, nextInChain),\n            \"offsetof mismatch for TextureDescriptor::nextInChain\");\n    static_assert(offsetof(TextureDescriptor, label) == offsetof(WGPUTextureDescriptor, label),\n            \"offsetof mismatch for TextureDescriptor::label\");\n    static_assert(offsetof(TextureDescriptor, usage) == offsetof(WGPUTextureDescriptor, usage),\n            \"offsetof mismatch for TextureDescriptor::usage\");\n    static_assert(offsetof(TextureDescriptor, dimension) == offsetof(WGPUTextureDescriptor, dimension),\n            \"offsetof mismatch for TextureDescriptor::dimension\");\n    static_assert(offsetof(TextureDescriptor, size) == offsetof(WGPUTextureDescriptor, size),\n            \"offsetof mismatch for TextureDescriptor::size\");\n    static_assert(offsetof(TextureDescriptor, format) == offsetof(WGPUTextureDescriptor, format),\n            \"offsetof mismatch for TextureDescriptor::format\");\n    static_assert(offsetof(TextureDescriptor, mipLevelCount) == offsetof(WGPUTextureDescriptor, mipLevelCount),\n            \"offsetof mismatch for TextureDescriptor::mipLevelCount\");\n    static_assert(offsetof(TextureDescriptor, sampleCount) == offsetof(WGPUTextureDescriptor, sampleCount),\n            \"offsetof mismatch for TextureDescriptor::sampleCount\");\n    static_assert(offsetof(TextureDescriptor, viewFormatCount) == offsetof(WGPUTextureDescriptor, viewFormatCount),\n            \"offsetof mismatch for TextureDescriptor::viewFormatCount\");\n    static_assert(offsetof(TextureDescriptor, viewFormats) == offsetof(WGPUTextureDescriptor, viewFormats),\n            \"offsetof mismatch for TextureDescriptor::viewFormats\");\n\n    bool TextureDescriptor::operator==(const TextureDescriptor& rhs) const {\n        return (nextInChain == rhs.nextInChain) && std::tie(\n            label,\n            usage,\n            dimension,\n            size,\n            format,\n            mipLevelCount,\n            sampleCount,\n            viewFormatCount,\n            viewFormats\n        ) == std::tie(\n            rhs.label,\n            rhs.usage,\n            rhs.dimension,\n            rhs.size,\n            rhs.format,\n            rhs.mipLevelCount,\n            rhs.sampleCount,\n            rhs.viewFormatCount,\n            rhs.viewFormats\n        );\n    }\n\n\n    static_assert(sizeof(VertexBufferLayout) == sizeof(WGPUVertexBufferLayout), \"sizeof mismatch for VertexBufferLayout\");\n    static_assert(alignof(VertexBufferLayout) == alignof(WGPUVertexBufferLayout), \"alignof mismatch for VertexBufferLayout\");\n\n    static_assert(offsetof(VertexBufferLayout, arrayStride) == offsetof(WGPUVertexBufferLayout, arrayStride),\n            \"offsetof mismatch for VertexBufferLayout::arrayStride\");\n    static_assert(offsetof(VertexBufferLayout, stepMode) == offsetof(WGPUVertexBufferLayout, stepMode),\n            \"offsetof mismatch for VertexBufferLayout::stepMode\");\n    static_assert(offsetof(VertexBufferLayout, attributeCount) == offsetof(WGPUVertexBufferLayout, attributeCount),\n            \"offsetof mismatch for VertexBufferLayout::attributeCount\");\n    static_assert(offsetof(VertexBufferLayout, attributes) == offsetof(WGPUVertexBufferLayout, attributes),\n            \"offsetof mismatch for VertexBufferLayout::attributes\");\n\n    bool VertexBufferLayout::operator==(const VertexBufferLayout& rhs) const {\n        return  std::tie(\n            arrayStride,\n            stepMode,\n            attributeCount,\n            attributes\n        ) == std::tie(\n            rhs.arrayStride,\n            rhs.stepMode,\n            rhs.attributeCount,\n            rhs.attributes\n        );\n    }\n\n\n    static_assert(sizeof(BindGroupLayoutDescriptor) == sizeof(WGPUBindGroupLayoutDescriptor), \"sizeof mismatch for BindGroupLayoutDescriptor\");\n    static_assert(alignof(BindGroupLayoutDescriptor) == alignof(WGPUBindGroupLayoutDescriptor), \"alignof mismatch for BindGroupLayoutDescriptor\");\n\n    static_assert(offsetof(BindGroupLayoutDescriptor, nextInChain) == offsetof(WGPUBindGroupLayoutDescriptor, nextInChain),\n            \"offsetof mismatch for BindGroupLayoutDescriptor::nextInChain\");\n    static_assert(offsetof(BindGroupLayoutDescriptor, label) == offsetof(WGPUBindGroupLayoutDescriptor, label),\n            \"offsetof mismatch for BindGroupLayoutDescriptor::label\");\n    static_assert(offsetof(BindGroupLayoutDescriptor, entryCount) == offsetof(WGPUBindGroupLayoutDescriptor, entryCount),\n            \"offsetof mismatch for BindGroupLayoutDescriptor::entryCount\");\n    static_assert(offsetof(BindGroupLayoutDescriptor, entries) == offsetof(WGPUBindGroupLayoutDescriptor, entries),\n            \"offsetof mismatch for BindGroupLayoutDescriptor::entries\");\n\n    bool BindGroupLayoutDescriptor::operator==(const BindGroupLayoutDescriptor& rhs) const {\n        return (nextInChain == rhs.nextInChain) && std::tie(\n            label,\n            entryCount,\n            entries\n        ) == std::tie(\n            rhs.label,\n            rhs.entryCount,\n            rhs.entries\n        );\n    }\n\n\n    static_assert(sizeof(ColorTargetState) == sizeof(WGPUColorTargetState), \"sizeof mismatch for ColorTargetState\");\n    static_assert(alignof(ColorTargetState) == alignof(WGPUColorTargetState), \"alignof mismatch for ColorTargetState\");\n\n    static_assert(offsetof(ColorTargetState, nextInChain) == offsetof(WGPUColorTargetState, nextInChain),\n            \"offsetof mismatch for ColorTargetState::nextInChain\");\n    static_assert(offsetof(ColorTargetState, format) == offsetof(WGPUColorTargetState, format),\n            \"offsetof mismatch for ColorTargetState::format\");\n    static_assert(offsetof(ColorTargetState, blend) == offsetof(WGPUColorTargetState, blend),\n            \"offsetof mismatch for ColorTargetState::blend\");\n    static_assert(offsetof(ColorTargetState, writeMask) == offsetof(WGPUColorTargetState, writeMask),\n            \"offsetof mismatch for ColorTargetState::writeMask\");\n\n    bool ColorTargetState::operator==(const ColorTargetState& rhs) const {\n        return (nextInChain == rhs.nextInChain) && std::tie(\n            format,\n            blend,\n            writeMask\n        ) == std::tie(\n            rhs.format,\n            rhs.blend,\n            rhs.writeMask\n        );\n    }\n\n\n    static_assert(sizeof(ComputePipelineDescriptor) == sizeof(WGPUComputePipelineDescriptor), \"sizeof mismatch for ComputePipelineDescriptor\");\n    static_assert(alignof(ComputePipelineDescriptor) == alignof(WGPUComputePipelineDescriptor), \"alignof mismatch for ComputePipelineDescriptor\");\n\n    static_assert(offsetof(ComputePipelineDescriptor, nextInChain) == offsetof(WGPUComputePipelineDescriptor, nextInChain),\n            \"offsetof mismatch for ComputePipelineDescriptor::nextInChain\");\n    static_assert(offsetof(ComputePipelineDescriptor, label) == offsetof(WGPUComputePipelineDescriptor, label),\n            \"offsetof mismatch for ComputePipelineDescriptor::label\");\n    static_assert(offsetof(ComputePipelineDescriptor, layout) == offsetof(WGPUComputePipelineDescriptor, layout),\n            \"offsetof mismatch for ComputePipelineDescriptor::layout\");\n    static_assert(offsetof(ComputePipelineDescriptor, compute) == offsetof(WGPUComputePipelineDescriptor, compute),\n            \"offsetof mismatch for ComputePipelineDescriptor::compute\");\n\n    bool ComputePipelineDescriptor::operator==(const ComputePipelineDescriptor& rhs) const {\n        return (nextInChain == rhs.nextInChain) && std::tie(\n            label,\n            layout,\n            compute\n        ) == std::tie(\n            rhs.label,\n            rhs.layout,\n            rhs.compute\n        );\n    }\n\n\n    static_assert(sizeof(DeviceDescriptor) == sizeof(WGPUDeviceDescriptor), \"sizeof mismatch for DeviceDescriptor\");\n    static_assert(alignof(DeviceDescriptor) == alignof(WGPUDeviceDescriptor), \"alignof mismatch for DeviceDescriptor\");\n\n    static_assert(offsetof(DeviceDescriptor, nextInChain) == offsetof(WGPUDeviceDescriptor, nextInChain),\n            \"offsetof mismatch for DeviceDescriptor::nextInChain\");\n    static_assert(offsetof(DeviceDescriptor, label) == offsetof(WGPUDeviceDescriptor, label),\n            \"offsetof mismatch for DeviceDescriptor::label\");\n    static_assert(offsetof(DeviceDescriptor, requiredFeaturesCount) == offsetof(WGPUDeviceDescriptor, requiredFeaturesCount),\n            \"offsetof mismatch for DeviceDescriptor::requiredFeaturesCount\");\n    static_assert(offsetof(DeviceDescriptor, requiredFeatures) == offsetof(WGPUDeviceDescriptor, requiredFeatures),\n            \"offsetof mismatch for DeviceDescriptor::requiredFeatures\");\n    static_assert(offsetof(DeviceDescriptor, requiredLimits) == offsetof(WGPUDeviceDescriptor, requiredLimits),\n            \"offsetof mismatch for DeviceDescriptor::requiredLimits\");\n    static_assert(offsetof(DeviceDescriptor, defaultQueue) == offsetof(WGPUDeviceDescriptor, defaultQueue),\n            \"offsetof mismatch for DeviceDescriptor::defaultQueue\");\n    static_assert(offsetof(DeviceDescriptor, deviceLostCallback) == offsetof(WGPUDeviceDescriptor, deviceLostCallback),\n            \"offsetof mismatch for DeviceDescriptor::deviceLostCallback\");\n    static_assert(offsetof(DeviceDescriptor, deviceLostUserdata) == offsetof(WGPUDeviceDescriptor, deviceLostUserdata),\n            \"offsetof mismatch for DeviceDescriptor::deviceLostUserdata\");\n\n    bool DeviceDescriptor::operator==(const DeviceDescriptor& rhs) const {\n        return (nextInChain == rhs.nextInChain) && std::tie(\n            label,\n            requiredFeaturesCount,\n            requiredFeatures,\n            requiredLimits,\n            defaultQueue,\n            deviceLostCallback,\n            deviceLostUserdata\n        ) == std::tie(\n            rhs.label,\n            rhs.requiredFeaturesCount,\n            rhs.requiredFeatures,\n            rhs.requiredLimits,\n            rhs.defaultQueue,\n            rhs.deviceLostCallback,\n            rhs.deviceLostUserdata\n        );\n    }\n\n\n    static_assert(sizeof(RenderPassDescriptor) == sizeof(WGPURenderPassDescriptor), \"sizeof mismatch for RenderPassDescriptor\");\n    static_assert(alignof(RenderPassDescriptor) == alignof(WGPURenderPassDescriptor), \"alignof mismatch for RenderPassDescriptor\");\n\n    static_assert(offsetof(RenderPassDescriptor, nextInChain) == offsetof(WGPURenderPassDescriptor, nextInChain),\n            \"offsetof mismatch for RenderPassDescriptor::nextInChain\");\n    static_assert(offsetof(RenderPassDescriptor, label) == offsetof(WGPURenderPassDescriptor, label),\n            \"offsetof mismatch for RenderPassDescriptor::label\");\n    static_assert(offsetof(RenderPassDescriptor, colorAttachmentCount) == offsetof(WGPURenderPassDescriptor, colorAttachmentCount),\n            \"offsetof mismatch for RenderPassDescriptor::colorAttachmentCount\");\n    static_assert(offsetof(RenderPassDescriptor, colorAttachments) == offsetof(WGPURenderPassDescriptor, colorAttachments),\n            \"offsetof mismatch for RenderPassDescriptor::colorAttachments\");\n    static_assert(offsetof(RenderPassDescriptor, depthStencilAttachment) == offsetof(WGPURenderPassDescriptor, depthStencilAttachment),\n            \"offsetof mismatch for RenderPassDescriptor::depthStencilAttachment\");\n    static_assert(offsetof(RenderPassDescriptor, occlusionQuerySet) == offsetof(WGPURenderPassDescriptor, occlusionQuerySet),\n            \"offsetof mismatch for RenderPassDescriptor::occlusionQuerySet\");\n    static_assert(offsetof(RenderPassDescriptor, timestampWriteCount) == offsetof(WGPURenderPassDescriptor, timestampWriteCount),\n            \"offsetof mismatch for RenderPassDescriptor::timestampWriteCount\");\n    static_assert(offsetof(RenderPassDescriptor, timestampWrites) == offsetof(WGPURenderPassDescriptor, timestampWrites),\n            \"offsetof mismatch for RenderPassDescriptor::timestampWrites\");\n\n    bool RenderPassDescriptor::operator==(const RenderPassDescriptor& rhs) const {\n        return (nextInChain == rhs.nextInChain) && std::tie(\n            label,\n            colorAttachmentCount,\n            colorAttachments,\n            depthStencilAttachment,\n            occlusionQuerySet,\n            timestampWriteCount,\n            timestampWrites\n        ) == std::tie(\n            rhs.label,\n            rhs.colorAttachmentCount,\n            rhs.colorAttachments,\n            rhs.depthStencilAttachment,\n            rhs.occlusionQuerySet,\n            rhs.timestampWriteCount,\n            rhs.timestampWrites\n        );\n    }\n\n\n    static_assert(sizeof(VertexState) == sizeof(WGPUVertexState), \"sizeof mismatch for VertexState\");\n    static_assert(alignof(VertexState) == alignof(WGPUVertexState), \"alignof mismatch for VertexState\");\n\n    static_assert(offsetof(VertexState, nextInChain) == offsetof(WGPUVertexState, nextInChain),\n            \"offsetof mismatch for VertexState::nextInChain\");\n    static_assert(offsetof(VertexState, module) == offsetof(WGPUVertexState, module),\n            \"offsetof mismatch for VertexState::module\");\n    static_assert(offsetof(VertexState, entryPoint) == offsetof(WGPUVertexState, entryPoint),\n            \"offsetof mismatch for VertexState::entryPoint\");\n    static_assert(offsetof(VertexState, constantCount) == offsetof(WGPUVertexState, constantCount),\n            \"offsetof mismatch for VertexState::constantCount\");\n    static_assert(offsetof(VertexState, constants) == offsetof(WGPUVertexState, constants),\n            \"offsetof mismatch for VertexState::constants\");\n    static_assert(offsetof(VertexState, bufferCount) == offsetof(WGPUVertexState, bufferCount),\n            \"offsetof mismatch for VertexState::bufferCount\");\n    static_assert(offsetof(VertexState, buffers) == offsetof(WGPUVertexState, buffers),\n            \"offsetof mismatch for VertexState::buffers\");\n\n    bool VertexState::operator==(const VertexState& rhs) const {\n        return (nextInChain == rhs.nextInChain) && std::tie(\n            module,\n            entryPoint,\n            constantCount,\n            constants,\n            bufferCount,\n            buffers\n        ) == std::tie(\n            rhs.module,\n            rhs.entryPoint,\n            rhs.constantCount,\n            rhs.constants,\n            rhs.bufferCount,\n            rhs.buffers\n        );\n    }\n\n\n    static_assert(sizeof(FragmentState) == sizeof(WGPUFragmentState), \"sizeof mismatch for FragmentState\");\n    static_assert(alignof(FragmentState) == alignof(WGPUFragmentState), \"alignof mismatch for FragmentState\");\n\n    static_assert(offsetof(FragmentState, nextInChain) == offsetof(WGPUFragmentState, nextInChain),\n            \"offsetof mismatch for FragmentState::nextInChain\");\n    static_assert(offsetof(FragmentState, module) == offsetof(WGPUFragmentState, module),\n            \"offsetof mismatch for FragmentState::module\");\n    static_assert(offsetof(FragmentState, entryPoint) == offsetof(WGPUFragmentState, entryPoint),\n            \"offsetof mismatch for FragmentState::entryPoint\");\n    static_assert(offsetof(FragmentState, constantCount) == offsetof(WGPUFragmentState, constantCount),\n            \"offsetof mismatch for FragmentState::constantCount\");\n    static_assert(offsetof(FragmentState, constants) == offsetof(WGPUFragmentState, constants),\n            \"offsetof mismatch for FragmentState::constants\");\n    static_assert(offsetof(FragmentState, targetCount) == offsetof(WGPUFragmentState, targetCount),\n            \"offsetof mismatch for FragmentState::targetCount\");\n    static_assert(offsetof(FragmentState, targets) == offsetof(WGPUFragmentState, targets),\n            \"offsetof mismatch for FragmentState::targets\");\n\n    bool FragmentState::operator==(const FragmentState& rhs) const {\n        return (nextInChain == rhs.nextInChain) && std::tie(\n            module,\n            entryPoint,\n            constantCount,\n            constants,\n            targetCount,\n            targets\n        ) == std::tie(\n            rhs.module,\n            rhs.entryPoint,\n            rhs.constantCount,\n            rhs.constants,\n            rhs.targetCount,\n            rhs.targets\n        );\n    }\n\n\n    static_assert(sizeof(RenderPipelineDescriptor) == sizeof(WGPURenderPipelineDescriptor), \"sizeof mismatch for RenderPipelineDescriptor\");\n    static_assert(alignof(RenderPipelineDescriptor) == alignof(WGPURenderPipelineDescriptor), \"alignof mismatch for RenderPipelineDescriptor\");\n\n    static_assert(offsetof(RenderPipelineDescriptor, nextInChain) == offsetof(WGPURenderPipelineDescriptor, nextInChain),\n            \"offsetof mismatch for RenderPipelineDescriptor::nextInChain\");\n    static_assert(offsetof(RenderPipelineDescriptor, label) == offsetof(WGPURenderPipelineDescriptor, label),\n            \"offsetof mismatch for RenderPipelineDescriptor::label\");\n    static_assert(offsetof(RenderPipelineDescriptor, layout) == offsetof(WGPURenderPipelineDescriptor, layout),\n            \"offsetof mismatch for RenderPipelineDescriptor::layout\");\n    static_assert(offsetof(RenderPipelineDescriptor, vertex) == offsetof(WGPURenderPipelineDescriptor, vertex),\n            \"offsetof mismatch for RenderPipelineDescriptor::vertex\");\n    static_assert(offsetof(RenderPipelineDescriptor, primitive) == offsetof(WGPURenderPipelineDescriptor, primitive),\n            \"offsetof mismatch for RenderPipelineDescriptor::primitive\");\n    static_assert(offsetof(RenderPipelineDescriptor, depthStencil) == offsetof(WGPURenderPipelineDescriptor, depthStencil),\n            \"offsetof mismatch for RenderPipelineDescriptor::depthStencil\");\n    static_assert(offsetof(RenderPipelineDescriptor, multisample) == offsetof(WGPURenderPipelineDescriptor, multisample),\n            \"offsetof mismatch for RenderPipelineDescriptor::multisample\");\n    static_assert(offsetof(RenderPipelineDescriptor, fragment) == offsetof(WGPURenderPipelineDescriptor, fragment),\n            \"offsetof mismatch for RenderPipelineDescriptor::fragment\");\n\n    bool RenderPipelineDescriptor::operator==(const RenderPipelineDescriptor& rhs) const {\n        return (nextInChain == rhs.nextInChain) && std::tie(\n            label,\n            layout,\n            vertex,\n            primitive,\n            depthStencil,\n            multisample,\n            fragment\n        ) == std::tie(\n            rhs.label,\n            rhs.layout,\n            rhs.vertex,\n            rhs.primitive,\n            rhs.depthStencil,\n            rhs.multisample,\n            rhs.fragment\n        );\n    }\n\n} // namespace dawn::native\n", "src/dawn/native/ProcTable.cpp": "\n#include \"dawn/native/dawn_platform.h\"\n#include \"dawn/native/DawnNative.h\"\n\n#include <algorithm>\n#include <vector>\n\n#include \"dawn/native/Adapter.h\"\n#include \"dawn/native/BindGroup.h\"\n#include \"dawn/native/BindGroupLayout.h\"\n#include \"dawn/native/Buffer.h\"\n#include \"dawn/native/CommandBuffer.h\"\n#include \"dawn/native/CommandEncoder.h\"\n#include \"dawn/native/ComputePassEncoder.h\"\n#include \"dawn/native/ComputePipeline.h\"\n#include \"dawn/native/Device.h\"\n#include \"dawn/native/ExternalTexture.h\"\n#include \"dawn/native/Instance.h\"\n#include \"dawn/native/PipelineLayout.h\"\n#include \"dawn/native/QuerySet.h\"\n#include \"dawn/native/Queue.h\"\n#include \"dawn/native/RenderBundle.h\"\n#include \"dawn/native/RenderBundleEncoder.h\"\n#include \"dawn/native/RenderPassEncoder.h\"\n#include \"dawn/native/RenderPipeline.h\"\n#include \"dawn/native/Sampler.h\"\n#include \"dawn/native/ShaderModule.h\"\n#include \"dawn/native/Surface.h\"\n#include \"dawn/native/SwapChain.h\"\n#include \"dawn/native/Texture.h\"\n\nnamespace dawn::native {\n\n\n    WGPUDevice NativeAdapterCreateDevice(WGPUAdapter cSelf, WGPUDeviceDescriptor const * descriptor) {\n        auto self = FromAPI(cSelf);\n\n        auto descriptor_ = reinterpret_cast<DeviceDescriptor const * >(descriptor);\n        // This method is specified to not use AutoLock in json script.\n\n        auto result =        self->APICreateDevice(descriptor_);\n        return ToAPI(result);\n    }\n\n    size_t NativeAdapterEnumerateFeatures(WGPUAdapter cSelf, WGPUFeatureName * features) {\n        auto self = FromAPI(cSelf);\n\n        auto features_ = reinterpret_cast<wgpu::FeatureName * >(features);\n        // This method is specified to not use AutoLock in json script.\n\n        auto result =        self->APIEnumerateFeatures(features_);\n        return result;\n    }\n\n    WGPUInstance NativeAdapterGetInstance(WGPUAdapter cSelf) {\n        auto self = FromAPI(cSelf);\n\n        // This method is specified to not use AutoLock in json script.\n\n        auto result =        self->APIGetInstance();\n        return ToAPI(result);\n    }\n\n    bool NativeAdapterGetLimits(WGPUAdapter cSelf, WGPUSupportedLimits * limits) {\n        auto self = FromAPI(cSelf);\n\n        auto limits_ = reinterpret_cast<SupportedLimits * >(limits);\n        // This method is specified to not use AutoLock in json script.\n\n        auto result =        self->APIGetLimits(limits_);\n        return result;\n    }\n\n    void NativeAdapterGetProperties(WGPUAdapter cSelf, WGPUAdapterProperties * properties) {\n        auto self = FromAPI(cSelf);\n\n        auto properties_ = reinterpret_cast<AdapterProperties * >(properties);\n        // This method is specified to not use AutoLock in json script.\n\n        self->APIGetProperties(properties_);\n    }\n\n    bool NativeAdapterHasFeature(WGPUAdapter cSelf, WGPUFeatureName feature) {\n        auto self = FromAPI(cSelf);\n\n        auto feature_ = static_cast<wgpu::FeatureName>(feature);\n        // This method is specified to not use AutoLock in json script.\n\n        auto result =        self->APIHasFeature(feature_);\n        return result;\n    }\n\n    void NativeAdapterRequestDevice(WGPUAdapter cSelf, WGPUDeviceDescriptor const * descriptor, WGPURequestDeviceCallback callback, void * userdata) {\n        auto self = FromAPI(cSelf);\n\n        auto descriptor_ = reinterpret_cast<DeviceDescriptor const * >(descriptor);\n        auto callback_ = callback;\n        auto userdata_ = userdata;\n        // This method is specified to not use AutoLock in json script.\n\n        self->APIRequestDevice(descriptor_, callback_, userdata_);\n    }\n\n    void NativeAdapterReference(WGPUAdapter cSelf) {\n        auto self = FromAPI(cSelf);\n\n        // This method is specified to not use AutoLock in json script.\n\n        self->APIReference();\n    }\n\n    void NativeAdapterRelease(WGPUAdapter cSelf) {\n        auto self = FromAPI(cSelf);\n\n        // This method is specified to not use AutoLock in json script.\n\n        self->APIRelease();\n    }\n\n    void NativeBindGroupSetLabel(WGPUBindGroup cSelf, char const * label) {\n        auto self = FromAPI(cSelf);\n\n        auto label_ = reinterpret_cast<char const * >(label);\n        auto device = self->GetDevice();\n        auto deviceLock(device->GetScopedLock());\n\n        self->APISetLabel(label_);\n    }\n\n    void NativeBindGroupReference(WGPUBindGroup cSelf) {\n        auto self = FromAPI(cSelf);\n\n        // This method is specified to not use AutoLock in json script.\n\n        self->APIReference();\n    }\n\n    void NativeBindGroupRelease(WGPUBindGroup cSelf) {\n        auto self = FromAPI(cSelf);\n\n        // This method is specified to not use AutoLock in json script.\n\n        self->APIRelease();\n    }\n\n    void NativeBindGroupLayoutSetLabel(WGPUBindGroupLayout cSelf, char const * label) {\n        auto self = FromAPI(cSelf);\n\n        auto label_ = reinterpret_cast<char const * >(label);\n        auto device = self->GetDevice();\n        auto deviceLock(device->GetScopedLock());\n\n        self->APISetLabel(label_);\n    }\n\n    void NativeBindGroupLayoutReference(WGPUBindGroupLayout cSelf) {\n        auto self = FromAPI(cSelf);\n\n        // This method is specified to not use AutoLock in json script.\n\n        self->APIReference();\n    }\n\n    void NativeBindGroupLayoutRelease(WGPUBindGroupLayout cSelf) {\n        auto self = FromAPI(cSelf);\n\n        // This method is specified to not use AutoLock in json script.\n\n        self->APIRelease();\n    }\n\n    void NativeBufferDestroy(WGPUBuffer cSelf) {\n        auto self = FromAPI(cSelf);\n\n        auto device = self->GetDevice();\n        auto deviceLock(device->GetScopedLock());\n\n        self->APIDestroy();\n    }\n\n    void const * NativeBufferGetConstMappedRange(WGPUBuffer cSelf, size_t offset, size_t size) {\n        auto self = FromAPI(cSelf);\n\n        auto offset_ = offset;\n        auto size_ = size;\n        auto device = self->GetDevice();\n        auto deviceLock(device->GetScopedLock());\n\n        auto result =        self->APIGetConstMappedRange(offset_, size_);\n        return result;\n    }\n\n    WGPUBufferMapState NativeBufferGetMapState(WGPUBuffer cSelf) {\n        auto self = FromAPI(cSelf);\n\n        auto device = self->GetDevice();\n        auto deviceLock(device->GetScopedLock());\n\n        auto result =        self->APIGetMapState();\n        return ToAPI(result);\n    }\n\n    void * NativeBufferGetMappedRange(WGPUBuffer cSelf, size_t offset, size_t size) {\n        auto self = FromAPI(cSelf);\n\n        auto offset_ = offset;\n        auto size_ = size;\n        auto device = self->GetDevice();\n        auto deviceLock(device->GetScopedLock());\n\n        auto result =        self->APIGetMappedRange(offset_, size_);\n        return result;\n    }\n\n    uint64_t NativeBufferGetSize(WGPUBuffer cSelf) {\n        auto self = FromAPI(cSelf);\n\n        auto device = self->GetDevice();\n        auto deviceLock(device->GetScopedLock());\n\n        auto result =        self->APIGetSize();\n        return result;\n    }\n\n    WGPUBufferUsageFlags NativeBufferGetUsage(WGPUBuffer cSelf) {\n        auto self = FromAPI(cSelf);\n\n        auto device = self->GetDevice();\n        auto deviceLock(device->GetScopedLock());\n\n        auto result =        self->APIGetUsage();\n        return ToAPI(result);\n    }\n\n    void NativeBufferMapAsync(WGPUBuffer cSelf, WGPUMapModeFlags mode, size_t offset, size_t size, WGPUBufferMapCallback callback, void * userdata) {\n        auto self = FromAPI(cSelf);\n\n        auto mode_ = static_cast<wgpu::MapMode>(mode);\n        auto offset_ = offset;\n        auto size_ = size;\n        auto callback_ = callback;\n        auto userdata_ = userdata;\n        auto device = self->GetDevice();\n        auto deviceLock(device->GetScopedLock());\n\n        self->APIMapAsync(mode_, offset_, size_, callback_, userdata_);\n    }\n\n    void NativeBufferSetLabel(WGPUBuffer cSelf, char const * label) {\n        auto self = FromAPI(cSelf);\n\n        auto label_ = reinterpret_cast<char const * >(label);\n        auto device = self->GetDevice();\n        auto deviceLock(device->GetScopedLock());\n\n        self->APISetLabel(label_);\n    }\n\n    void NativeBufferUnmap(WGPUBuffer cSelf) {\n        auto self = FromAPI(cSelf);\n\n        auto device = self->GetDevice();\n        auto deviceLock(device->GetScopedLock());\n\n        self->APIUnmap();\n    }\n\n    void NativeBufferReference(WGPUBuffer cSelf) {\n        auto self = FromAPI(cSelf);\n\n        // This method is specified to not use AutoLock in json script.\n\n        self->APIReference();\n    }\n\n    void NativeBufferRelease(WGPUBuffer cSelf) {\n        auto self = FromAPI(cSelf);\n\n        // This method is specified to not use AutoLock in json script.\n\n        self->APIRelease();\n    }\n\n    void NativeCommandBufferSetLabel(WGPUCommandBuffer cSelf, char const * label) {\n        auto self = FromAPI(cSelf);\n\n        auto label_ = reinterpret_cast<char const * >(label);\n        auto device = self->GetDevice();\n        auto deviceLock(device->GetScopedLock());\n\n        self->APISetLabel(label_);\n    }\n\n    void NativeCommandBufferReference(WGPUCommandBuffer cSelf) {\n        auto self = FromAPI(cSelf);\n\n        // This method is specified to not use AutoLock in json script.\n\n        self->APIReference();\n    }\n\n    void NativeCommandBufferRelease(WGPUCommandBuffer cSelf) {\n        auto self = FromAPI(cSelf);\n\n        // This method is specified to not use AutoLock in json script.\n\n        self->APIRelease();\n    }\n\n    WGPUComputePassEncoder NativeCommandEncoderBeginComputePass(WGPUCommandEncoder cSelf, WGPUComputePassDescriptor const * descriptor) {\n        auto self = FromAPI(cSelf);\n\n        auto descriptor_ = reinterpret_cast<ComputePassDescriptor const * >(descriptor);\n        // This method is specified to not use AutoLock in json script.\n\n        auto result =        self->APIBeginComputePass(descriptor_);\n        return ToAPI(result);\n    }\n\n    WGPURenderPassEncoder NativeCommandEncoderBeginRenderPass(WGPUCommandEncoder cSelf, WGPURenderPassDescriptor const * descriptor) {\n        auto self = FromAPI(cSelf);\n\n        auto descriptor_ = reinterpret_cast<RenderPassDescriptor const * >(descriptor);\n        // This method is specified to not use AutoLock in json script.\n\n        auto result =        self->APIBeginRenderPass(descriptor_);\n        return ToAPI(result);\n    }\n\n    void NativeCommandEncoderClearBuffer(WGPUCommandEncoder cSelf, WGPUBuffer buffer, uint64_t offset, uint64_t size) {\n        auto self = FromAPI(cSelf);\n\n        auto buffer_ = reinterpret_cast<BufferBase* >(buffer);\n        auto offset_ = offset;\n        auto size_ = size;\n        // This method is specified to not use AutoLock in json script.\n\n        self->APIClearBuffer(buffer_, offset_, size_);\n    }\n\n    void NativeCommandEncoderCopyBufferToBuffer(WGPUCommandEncoder cSelf, WGPUBuffer source, uint64_t sourceOffset, WGPUBuffer destination, uint64_t destinationOffset, uint64_t size) {\n        auto self = FromAPI(cSelf);\n\n        auto source_ = reinterpret_cast<BufferBase* >(source);\n        auto sourceOffset_ = sourceOffset;\n        auto destination_ = reinterpret_cast<BufferBase* >(destination);\n        auto destinationOffset_ = destinationOffset;\n        auto size_ = size;\n        // This method is specified to not use AutoLock in json script.\n\n        self->APICopyBufferToBuffer(source_, sourceOffset_, destination_, destinationOffset_, size_);\n    }\n\n    void NativeCommandEncoderCopyBufferToTexture(WGPUCommandEncoder cSelf, WGPUImageCopyBuffer const * source, WGPUImageCopyTexture const * destination, WGPUExtent3D const * copySize) {\n        auto self = FromAPI(cSelf);\n\n        auto source_ = reinterpret_cast<ImageCopyBuffer const * >(source);\n        auto destination_ = reinterpret_cast<ImageCopyTexture const * >(destination);\n        auto copySize_ = reinterpret_cast<Extent3D const * >(copySize);\n        // This method is specified to not use AutoLock in json script.\n\n        self->APICopyBufferToTexture(source_, destination_, copySize_);\n    }\n\n    void NativeCommandEncoderCopyTextureToBuffer(WGPUCommandEncoder cSelf, WGPUImageCopyTexture const * source, WGPUImageCopyBuffer const * destination, WGPUExtent3D const * copySize) {\n        auto self = FromAPI(cSelf);\n\n        auto source_ = reinterpret_cast<ImageCopyTexture const * >(source);\n        auto destination_ = reinterpret_cast<ImageCopyBuffer const * >(destination);\n        auto copySize_ = reinterpret_cast<Extent3D const * >(copySize);\n        // This method is specified to not use AutoLock in json script.\n\n        self->APICopyTextureToBuffer(source_, destination_, copySize_);\n    }\n\n    void NativeCommandEncoderCopyTextureToTexture(WGPUCommandEncoder cSelf, WGPUImageCopyTexture const * source, WGPUImageCopyTexture const * destination, WGPUExtent3D const * copySize) {\n        auto self = FromAPI(cSelf);\n\n        auto source_ = reinterpret_cast<ImageCopyTexture const * >(source);\n        auto destination_ = reinterpret_cast<ImageCopyTexture const * >(destination);\n        auto copySize_ = reinterpret_cast<Extent3D const * >(copySize);\n        // This method is specified to not use AutoLock in json script.\n\n        self->APICopyTextureToTexture(source_, destination_, copySize_);\n    }\n\n    void NativeCommandEncoderCopyTextureToTextureInternal(WGPUCommandEncoder cSelf, WGPUImageCopyTexture const * source, WGPUImageCopyTexture const * destination, WGPUExtent3D const * copySize) {\n        auto self = FromAPI(cSelf);\n\n        auto source_ = reinterpret_cast<ImageCopyTexture const * >(source);\n        auto destination_ = reinterpret_cast<ImageCopyTexture const * >(destination);\n        auto copySize_ = reinterpret_cast<Extent3D const * >(copySize);\n        // This method is specified to not use AutoLock in json script.\n\n        self->APICopyTextureToTextureInternal(source_, destination_, copySize_);\n    }\n\n    WGPUCommandBuffer NativeCommandEncoderFinish(WGPUCommandEncoder cSelf, WGPUCommandBufferDescriptor const * descriptor) {\n        auto self = FromAPI(cSelf);\n\n        auto descriptor_ = reinterpret_cast<CommandBufferDescriptor const * >(descriptor);\n        // This method is specified to not use AutoLock in json script.\n\n        auto result =        self->APIFinish(descriptor_);\n        return ToAPI(result);\n    }\n\n    void NativeCommandEncoderInjectValidationError(WGPUCommandEncoder cSelf, char const * message) {\n        auto self = FromAPI(cSelf);\n\n        auto message_ = reinterpret_cast<char const * >(message);\n        // This method is specified to not use AutoLock in json script.\n\n        self->APIInjectValidationError(message_);\n    }\n\n    void NativeCommandEncoderInsertDebugMarker(WGPUCommandEncoder cSelf, char const * markerLabel) {\n        auto self = FromAPI(cSelf);\n\n        auto markerLabel_ = reinterpret_cast<char const * >(markerLabel);\n        // This method is specified to not use AutoLock in json script.\n\n        self->APIInsertDebugMarker(markerLabel_);\n    }\n\n    void NativeCommandEncoderPopDebugGroup(WGPUCommandEncoder cSelf) {\n        auto self = FromAPI(cSelf);\n\n        // This method is specified to not use AutoLock in json script.\n\n        self->APIPopDebugGroup();\n    }\n\n    void NativeCommandEncoderPushDebugGroup(WGPUCommandEncoder cSelf, char const * groupLabel) {\n        auto self = FromAPI(cSelf);\n\n        auto groupLabel_ = reinterpret_cast<char const * >(groupLabel);\n        // This method is specified to not use AutoLock in json script.\n\n        self->APIPushDebugGroup(groupLabel_);\n    }\n\n    void NativeCommandEncoderResolveQuerySet(WGPUCommandEncoder cSelf, WGPUQuerySet querySet, uint32_t firstQuery, uint32_t queryCount, WGPUBuffer destination, uint64_t destinationOffset) {\n        auto self = FromAPI(cSelf);\n\n        auto querySet_ = reinterpret_cast<QuerySetBase* >(querySet);\n        auto firstQuery_ = firstQuery;\n        auto queryCount_ = queryCount;\n        auto destination_ = reinterpret_cast<BufferBase* >(destination);\n        auto destinationOffset_ = destinationOffset;\n        // This method is specified to not use AutoLock in json script.\n\n        self->APIResolveQuerySet(querySet_, firstQuery_, queryCount_, destination_, destinationOffset_);\n    }\n\n    void NativeCommandEncoderSetLabel(WGPUCommandEncoder cSelf, char const * label) {\n        auto self = FromAPI(cSelf);\n\n        auto label_ = reinterpret_cast<char const * >(label);\n        // This method is specified to not use AutoLock in json script.\n\n        self->APISetLabel(label_);\n    }\n\n    void NativeCommandEncoderWriteBuffer(WGPUCommandEncoder cSelf, WGPUBuffer buffer, uint64_t bufferOffset, uint8_t const * data, uint64_t size) {\n        auto self = FromAPI(cSelf);\n\n        auto buffer_ = reinterpret_cast<BufferBase* >(buffer);\n        auto bufferOffset_ = bufferOffset;\n        auto data_ = reinterpret_cast<uint8_t const * >(data);\n        auto size_ = size;\n        // This method is specified to not use AutoLock in json script.\n\n        self->APIWriteBuffer(buffer_, bufferOffset_, data_, size_);\n    }\n\n    void NativeCommandEncoderWriteTimestamp(WGPUCommandEncoder cSelf, WGPUQuerySet querySet, uint32_t queryIndex) {\n        auto self = FromAPI(cSelf);\n\n        auto querySet_ = reinterpret_cast<QuerySetBase* >(querySet);\n        auto queryIndex_ = queryIndex;\n        // This method is specified to not use AutoLock in json script.\n\n        self->APIWriteTimestamp(querySet_, queryIndex_);\n    }\n\n    void NativeCommandEncoderReference(WGPUCommandEncoder cSelf) {\n        auto self = FromAPI(cSelf);\n\n        // This method is specified to not use AutoLock in json script.\n\n        self->APIReference();\n    }\n\n    void NativeCommandEncoderRelease(WGPUCommandEncoder cSelf) {\n        auto self = FromAPI(cSelf);\n\n        // This method is specified to not use AutoLock in json script.\n\n        self->APIRelease();\n    }\n\n    void NativeComputePassEncoderDispatchWorkgroups(WGPUComputePassEncoder cSelf, uint32_t workgroupCountX, uint32_t workgroupCountY, uint32_t workgroupCountZ) {\n        auto self = FromAPI(cSelf);\n\n        auto workgroupCountX_ = workgroupCountX;\n        auto workgroupCountY_ = workgroupCountY;\n        auto workgroupCountZ_ = workgroupCountZ;\n        // This method is specified to not use AutoLock in json script.\n\n        self->APIDispatchWorkgroups(workgroupCountX_, workgroupCountY_, workgroupCountZ_);\n    }\n\n    void NativeComputePassEncoderDispatchWorkgroupsIndirect(WGPUComputePassEncoder cSelf, WGPUBuffer indirectBuffer, uint64_t indirectOffset) {\n        auto self = FromAPI(cSelf);\n\n        auto indirectBuffer_ = reinterpret_cast<BufferBase* >(indirectBuffer);\n        auto indirectOffset_ = indirectOffset;\n        // This method is specified to not use AutoLock in json script.\n\n        self->APIDispatchWorkgroupsIndirect(indirectBuffer_, indirectOffset_);\n    }\n\n    void NativeComputePassEncoderEnd(WGPUComputePassEncoder cSelf) {\n        auto self = FromAPI(cSelf);\n\n        // This method is specified to not use AutoLock in json script.\n\n        self->APIEnd();\n    }\n\n    void NativeComputePassEncoderInsertDebugMarker(WGPUComputePassEncoder cSelf, char const * markerLabel) {\n        auto self = FromAPI(cSelf);\n\n        auto markerLabel_ = reinterpret_cast<char const * >(markerLabel);\n        // This method is specified to not use AutoLock in json script.\n\n        self->APIInsertDebugMarker(markerLabel_);\n    }\n\n    void NativeComputePassEncoderPopDebugGroup(WGPUComputePassEncoder cSelf) {\n        auto self = FromAPI(cSelf);\n\n        // This method is specified to not use AutoLock in json script.\n\n        self->APIPopDebugGroup();\n    }\n\n    void NativeComputePassEncoderPushDebugGroup(WGPUComputePassEncoder cSelf, char const * groupLabel) {\n        auto self = FromAPI(cSelf);\n\n        auto groupLabel_ = reinterpret_cast<char const * >(groupLabel);\n        // This method is specified to not use AutoLock in json script.\n\n        self->APIPushDebugGroup(groupLabel_);\n    }\n\n    void NativeComputePassEncoderSetBindGroup(WGPUComputePassEncoder cSelf, uint32_t groupIndex, WGPUBindGroup group, size_t dynamicOffsetCount, uint32_t const * dynamicOffsets) {\n        auto self = FromAPI(cSelf);\n\n        auto groupIndex_ = groupIndex;\n        auto group_ = reinterpret_cast<BindGroupBase* >(group);\n        auto dynamicOffsetCount_ = dynamicOffsetCount;\n        auto dynamicOffsets_ = reinterpret_cast<uint32_t const * >(dynamicOffsets);\n        // This method is specified to not use AutoLock in json script.\n\n        self->APISetBindGroup(groupIndex_, group_, dynamicOffsetCount_, dynamicOffsets_);\n    }\n\n    void NativeComputePassEncoderSetLabel(WGPUComputePassEncoder cSelf, char const * label) {\n        auto self = FromAPI(cSelf);\n\n        auto label_ = reinterpret_cast<char const * >(label);\n        // This method is specified to not use AutoLock in json script.\n\n        self->APISetLabel(label_);\n    }\n\n    void NativeComputePassEncoderSetPipeline(WGPUComputePassEncoder cSelf, WGPUComputePipeline pipeline) {\n        auto self = FromAPI(cSelf);\n\n        auto pipeline_ = reinterpret_cast<ComputePipelineBase* >(pipeline);\n        // This method is specified to not use AutoLock in json script.\n\n        self->APISetPipeline(pipeline_);\n    }\n\n    void NativeComputePassEncoderWriteTimestamp(WGPUComputePassEncoder cSelf, WGPUQuerySet querySet, uint32_t queryIndex) {\n        auto self = FromAPI(cSelf);\n\n        auto querySet_ = reinterpret_cast<QuerySetBase* >(querySet);\n        auto queryIndex_ = queryIndex;\n        // This method is specified to not use AutoLock in json script.\n\n        self->APIWriteTimestamp(querySet_, queryIndex_);\n    }\n\n    void NativeComputePassEncoderReference(WGPUComputePassEncoder cSelf) {\n        auto self = FromAPI(cSelf);\n\n        // This method is specified to not use AutoLock in json script.\n\n        self->APIReference();\n    }\n\n    void NativeComputePassEncoderRelease(WGPUComputePassEncoder cSelf) {\n        auto self = FromAPI(cSelf);\n\n        // This method is specified to not use AutoLock in json script.\n\n        self->APIRelease();\n    }\n\n    WGPUBindGroupLayout NativeComputePipelineGetBindGroupLayout(WGPUComputePipeline cSelf, uint32_t groupIndex) {\n        auto self = FromAPI(cSelf);\n\n        auto groupIndex_ = groupIndex;\n        auto device = self->GetDevice();\n        auto deviceLock(device->GetScopedLock());\n\n        auto result =        self->APIGetBindGroupLayout(groupIndex_);\n        return ToAPI(result);\n    }\n\n    void NativeComputePipelineSetLabel(WGPUComputePipeline cSelf, char const * label) {\n        auto self = FromAPI(cSelf);\n\n        auto label_ = reinterpret_cast<char const * >(label);\n        auto device = self->GetDevice();\n        auto deviceLock(device->GetScopedLock());\n\n        self->APISetLabel(label_);\n    }\n\n    void NativeComputePipelineReference(WGPUComputePipeline cSelf) {\n        auto self = FromAPI(cSelf);\n\n        // This method is specified to not use AutoLock in json script.\n\n        self->APIReference();\n    }\n\n    void NativeComputePipelineRelease(WGPUComputePipeline cSelf) {\n        auto self = FromAPI(cSelf);\n\n        // This method is specified to not use AutoLock in json script.\n\n        self->APIRelease();\n    }\n\n    WGPUBindGroup NativeDeviceCreateBindGroup(WGPUDevice cSelf, WGPUBindGroupDescriptor const * descriptor) {\n        auto self = FromAPI(cSelf);\n\n        auto descriptor_ = reinterpret_cast<BindGroupDescriptor const * >(descriptor);\n        auto device = self;\n        auto deviceLock(device->GetScopedLock());\n\n        auto result =        self->APICreateBindGroup(descriptor_);\n        return ToAPI(result);\n    }\n\n    WGPUBindGroupLayout NativeDeviceCreateBindGroupLayout(WGPUDevice cSelf, WGPUBindGroupLayoutDescriptor const * descriptor) {\n        auto self = FromAPI(cSelf);\n\n        auto descriptor_ = reinterpret_cast<BindGroupLayoutDescriptor const * >(descriptor);\n        auto device = self;\n        auto deviceLock(device->GetScopedLock());\n\n        auto result =        self->APICreateBindGroupLayout(descriptor_);\n        return ToAPI(result);\n    }\n\n    WGPUBuffer NativeDeviceCreateBuffer(WGPUDevice cSelf, WGPUBufferDescriptor const * descriptor) {\n        auto self = FromAPI(cSelf);\n\n        auto descriptor_ = reinterpret_cast<BufferDescriptor const * >(descriptor);\n        auto device = self;\n        auto deviceLock(device->GetScopedLock());\n\n        auto result =        self->APICreateBuffer(descriptor_);\n        return ToAPI(result);\n    }\n\n    WGPUCommandEncoder NativeDeviceCreateCommandEncoder(WGPUDevice cSelf, WGPUCommandEncoderDescriptor const * descriptor) {\n        auto self = FromAPI(cSelf);\n\n        auto descriptor_ = reinterpret_cast<CommandEncoderDescriptor const * >(descriptor);\n        auto device = self;\n        auto deviceLock(device->GetScopedLock());\n\n        auto result =        self->APICreateCommandEncoder(descriptor_);\n        return ToAPI(result);\n    }\n\n    WGPUComputePipeline NativeDeviceCreateComputePipeline(WGPUDevice cSelf, WGPUComputePipelineDescriptor const * descriptor) {\n        auto self = FromAPI(cSelf);\n\n        auto descriptor_ = reinterpret_cast<ComputePipelineDescriptor const * >(descriptor);\n        auto device = self;\n        auto deviceLock(device->GetScopedLock());\n\n        auto result =        self->APICreateComputePipeline(descriptor_);\n        return ToAPI(result);\n    }\n\n    void NativeDeviceCreateComputePipelineAsync(WGPUDevice cSelf, WGPUComputePipelineDescriptor const * descriptor, WGPUCreateComputePipelineAsyncCallback callback, void * userdata) {\n        auto self = FromAPI(cSelf);\n\n        auto descriptor_ = reinterpret_cast<ComputePipelineDescriptor const * >(descriptor);\n        auto callback_ = callback;\n        auto userdata_ = userdata;\n        auto device = self;\n        auto deviceLock(device->GetScopedLock());\n\n        self->APICreateComputePipelineAsync(descriptor_, callback_, userdata_);\n    }\n\n    WGPUBuffer NativeDeviceCreateErrorBuffer(WGPUDevice cSelf, WGPUBufferDescriptor const * descriptor) {\n        auto self = FromAPI(cSelf);\n\n        auto descriptor_ = reinterpret_cast<BufferDescriptor const * >(descriptor);\n        auto device = self;\n        auto deviceLock(device->GetScopedLock());\n\n        auto result =        self->APICreateErrorBuffer(descriptor_);\n        return ToAPI(result);\n    }\n\n    WGPUExternalTexture NativeDeviceCreateErrorExternalTexture(WGPUDevice cSelf) {\n        auto self = FromAPI(cSelf);\n\n        auto device = self;\n        auto deviceLock(device->GetScopedLock());\n\n        auto result =        self->APICreateErrorExternalTexture();\n        return ToAPI(result);\n    }\n\n    WGPUShaderModule NativeDeviceCreateErrorShaderModule(WGPUDevice cSelf, WGPUShaderModuleDescriptor const * descriptor, char const * errorMessage) {\n        auto self = FromAPI(cSelf);\n\n        auto descriptor_ = reinterpret_cast<ShaderModuleDescriptor const * >(descriptor);\n        auto errorMessage_ = reinterpret_cast<char const * >(errorMessage);\n        auto device = self;\n        auto deviceLock(device->GetScopedLock());\n\n        auto result =        self->APICreateErrorShaderModule(descriptor_, errorMessage_);\n        return ToAPI(result);\n    }\n\n    WGPUTexture NativeDeviceCreateErrorTexture(WGPUDevice cSelf, WGPUTextureDescriptor const * descriptor) {\n        auto self = FromAPI(cSelf);\n\n        auto descriptor_ = reinterpret_cast<TextureDescriptor const * >(descriptor);\n        auto device = self;\n        auto deviceLock(device->GetScopedLock());\n\n        auto result =        self->APICreateErrorTexture(descriptor_);\n        return ToAPI(result);\n    }\n\n    WGPUExternalTexture NativeDeviceCreateExternalTexture(WGPUDevice cSelf, WGPUExternalTextureDescriptor const * externalTextureDescriptor) {\n        auto self = FromAPI(cSelf);\n\n        auto externalTextureDescriptor_ = reinterpret_cast<ExternalTextureDescriptor const * >(externalTextureDescriptor);\n        auto device = self;\n        auto deviceLock(device->GetScopedLock());\n\n        auto result =        self->APICreateExternalTexture(externalTextureDescriptor_);\n        return ToAPI(result);\n    }\n\n    WGPUPipelineLayout NativeDeviceCreatePipelineLayout(WGPUDevice cSelf, WGPUPipelineLayoutDescriptor const * descriptor) {\n        auto self = FromAPI(cSelf);\n\n        auto descriptor_ = reinterpret_cast<PipelineLayoutDescriptor const * >(descriptor);\n        auto device = self;\n        auto deviceLock(device->GetScopedLock());\n\n        auto result =        self->APICreatePipelineLayout(descriptor_);\n        return ToAPI(result);\n    }\n\n    WGPUQuerySet NativeDeviceCreateQuerySet(WGPUDevice cSelf, WGPUQuerySetDescriptor const * descriptor) {\n        auto self = FromAPI(cSelf);\n\n        auto descriptor_ = reinterpret_cast<QuerySetDescriptor const * >(descriptor);\n        auto device = self;\n        auto deviceLock(device->GetScopedLock());\n\n        auto result =        self->APICreateQuerySet(descriptor_);\n        return ToAPI(result);\n    }\n\n    WGPURenderBundleEncoder NativeDeviceCreateRenderBundleEncoder(WGPUDevice cSelf, WGPURenderBundleEncoderDescriptor const * descriptor) {\n        auto self = FromAPI(cSelf);\n\n        auto descriptor_ = reinterpret_cast<RenderBundleEncoderDescriptor const * >(descriptor);\n        auto device = self;\n        auto deviceLock(device->GetScopedLock());\n\n        auto result =        self->APICreateRenderBundleEncoder(descriptor_);\n        return ToAPI(result);\n    }\n\n    WGPURenderPipeline NativeDeviceCreateRenderPipeline(WGPUDevice cSelf, WGPURenderPipelineDescriptor const * descriptor) {\n        auto self = FromAPI(cSelf);\n\n        auto descriptor_ = reinterpret_cast<RenderPipelineDescriptor const * >(descriptor);\n        auto device = self;\n        auto deviceLock(device->GetScopedLock());\n\n        auto result =        self->APICreateRenderPipeline(descriptor_);\n        return ToAPI(result);\n    }\n\n    void NativeDeviceCreateRenderPipelineAsync(WGPUDevice cSelf, WGPURenderPipelineDescriptor const * descriptor, WGPUCreateRenderPipelineAsyncCallback callback, void * userdata) {\n        auto self = FromAPI(cSelf);\n\n        auto descriptor_ = reinterpret_cast<RenderPipelineDescriptor const * >(descriptor);\n        auto callback_ = callback;\n        auto userdata_ = userdata;\n        auto device = self;\n        auto deviceLock(device->GetScopedLock());\n\n        self->APICreateRenderPipelineAsync(descriptor_, callback_, userdata_);\n    }\n\n    WGPUSampler NativeDeviceCreateSampler(WGPUDevice cSelf, WGPUSamplerDescriptor const * descriptor) {\n        auto self = FromAPI(cSelf);\n\n        auto descriptor_ = reinterpret_cast<SamplerDescriptor const * >(descriptor);\n        auto device = self;\n        auto deviceLock(device->GetScopedLock());\n\n        auto result =        self->APICreateSampler(descriptor_);\n        return ToAPI(result);\n    }\n\n    WGPUShaderModule NativeDeviceCreateShaderModule(WGPUDevice cSelf, WGPUShaderModuleDescriptor const * descriptor) {\n        auto self = FromAPI(cSelf);\n\n        auto descriptor_ = reinterpret_cast<ShaderModuleDescriptor const * >(descriptor);\n        auto device = self;\n        auto deviceLock(device->GetScopedLock());\n\n        auto result =        self->APICreateShaderModule(descriptor_);\n        return ToAPI(result);\n    }\n\n    WGPUSwapChain NativeDeviceCreateSwapChain(WGPUDevice cSelf, WGPUSurface surface, WGPUSwapChainDescriptor const * descriptor) {\n        auto self = FromAPI(cSelf);\n\n        auto surface_ = reinterpret_cast<SurfaceBase* >(surface);\n        auto descriptor_ = reinterpret_cast<SwapChainDescriptor const * >(descriptor);\n        auto device = self;\n        auto deviceLock(device->GetScopedLock());\n\n        auto result =        self->APICreateSwapChain(surface_, descriptor_);\n        return ToAPI(result);\n    }\n\n    WGPUTexture NativeDeviceCreateTexture(WGPUDevice cSelf, WGPUTextureDescriptor const * descriptor) {\n        auto self = FromAPI(cSelf);\n\n        auto descriptor_ = reinterpret_cast<TextureDescriptor const * >(descriptor);\n        auto device = self;\n        auto deviceLock(device->GetScopedLock());\n\n        auto result =        self->APICreateTexture(descriptor_);\n        return ToAPI(result);\n    }\n\n    void NativeDeviceDestroy(WGPUDevice cSelf) {\n        auto self = FromAPI(cSelf);\n\n        auto device = self;\n        auto deviceLock(device->GetScopedLock());\n\n        self->APIDestroy();\n    }\n\n    size_t NativeDeviceEnumerateFeatures(WGPUDevice cSelf, WGPUFeatureName * features) {\n        auto self = FromAPI(cSelf);\n\n        auto features_ = reinterpret_cast<wgpu::FeatureName * >(features);\n        auto device = self;\n        auto deviceLock(device->GetScopedLock());\n\n        auto result =        self->APIEnumerateFeatures(features_);\n        return result;\n    }\n\n    void NativeDeviceForceLoss(WGPUDevice cSelf, WGPUDeviceLostReason type, char const * message) {\n        auto self = FromAPI(cSelf);\n\n        auto type_ = static_cast<wgpu::DeviceLostReason>(type);\n        auto message_ = reinterpret_cast<char const * >(message);\n        auto device = self;\n        auto deviceLock(device->GetScopedLock());\n\n        self->APIForceLoss(type_, message_);\n    }\n\n    WGPUAdapter NativeDeviceGetAdapter(WGPUDevice cSelf) {\n        auto self = FromAPI(cSelf);\n\n        auto device = self;\n        auto deviceLock(device->GetScopedLock());\n\n        auto result =        self->APIGetAdapter();\n        return ToAPI(result);\n    }\n\n    bool NativeDeviceGetLimits(WGPUDevice cSelf, WGPUSupportedLimits * limits) {\n        auto self = FromAPI(cSelf);\n\n        auto limits_ = reinterpret_cast<SupportedLimits * >(limits);\n        auto device = self;\n        auto deviceLock(device->GetScopedLock());\n\n        auto result =        self->APIGetLimits(limits_);\n        return result;\n    }\n\n    WGPUQueue NativeDeviceGetQueue(WGPUDevice cSelf) {\n        auto self = FromAPI(cSelf);\n\n        auto device = self;\n        auto deviceLock(device->GetScopedLock());\n\n        auto result =        self->APIGetQueue();\n        return ToAPI(result);\n    }\n\n    WGPUTextureUsageFlags NativeDeviceGetSupportedSurfaceUsage(WGPUDevice cSelf, WGPUSurface surface) {\n        auto self = FromAPI(cSelf);\n\n        auto surface_ = reinterpret_cast<SurfaceBase* >(surface);\n        auto device = self;\n        auto deviceLock(device->GetScopedLock());\n\n        auto result =        self->APIGetSupportedSurfaceUsage(surface_);\n        return ToAPI(result);\n    }\n\n    bool NativeDeviceHasFeature(WGPUDevice cSelf, WGPUFeatureName feature) {\n        auto self = FromAPI(cSelf);\n\n        auto feature_ = static_cast<wgpu::FeatureName>(feature);\n        auto device = self;\n        auto deviceLock(device->GetScopedLock());\n\n        auto result =        self->APIHasFeature(feature_);\n        return result;\n    }\n\n    void NativeDeviceInjectError(WGPUDevice cSelf, WGPUErrorType type, char const * message) {\n        auto self = FromAPI(cSelf);\n\n        auto type_ = static_cast<wgpu::ErrorType>(type);\n        auto message_ = reinterpret_cast<char const * >(message);\n        auto device = self;\n        auto deviceLock(device->GetScopedLock());\n\n        self->APIInjectError(type_, message_);\n    }\n\n    void NativeDevicePopErrorScope(WGPUDevice cSelf, WGPUErrorCallback callback, void * userdata) {\n        auto self = FromAPI(cSelf);\n\n        auto callback_ = callback;\n        auto userdata_ = userdata;\n        auto device = self;\n        auto deviceLock(device->GetScopedLock());\n\n        self->APIPopErrorScope(callback_, userdata_);\n    }\n\n    void NativeDevicePushErrorScope(WGPUDevice cSelf, WGPUErrorFilter filter) {\n        auto self = FromAPI(cSelf);\n\n        auto filter_ = static_cast<wgpu::ErrorFilter>(filter);\n        auto device = self;\n        auto deviceLock(device->GetScopedLock());\n\n        self->APIPushErrorScope(filter_);\n    }\n\n    void NativeDeviceSetDeviceLostCallback(WGPUDevice cSelf, WGPUDeviceLostCallback callback, void * userdata) {\n        auto self = FromAPI(cSelf);\n\n        auto callback_ = callback;\n        auto userdata_ = userdata;\n        // This method is specified to not use AutoLock in json script.\n\n        self->APISetDeviceLostCallback(callback_, userdata_);\n    }\n\n    void NativeDeviceSetLabel(WGPUDevice cSelf, char const * label) {\n        auto self = FromAPI(cSelf);\n\n        auto label_ = reinterpret_cast<char const * >(label);\n        auto device = self;\n        auto deviceLock(device->GetScopedLock());\n\n        self->APISetLabel(label_);\n    }\n\n    void NativeDeviceSetLoggingCallback(WGPUDevice cSelf, WGPULoggingCallback callback, void * userdata) {\n        auto self = FromAPI(cSelf);\n\n        auto callback_ = callback;\n        auto userdata_ = userdata;\n        // This method is specified to not use AutoLock in json script.\n\n        self->APISetLoggingCallback(callback_, userdata_);\n    }\n\n    void NativeDeviceSetUncapturedErrorCallback(WGPUDevice cSelf, WGPUErrorCallback callback, void * userdata) {\n        auto self = FromAPI(cSelf);\n\n        auto callback_ = callback;\n        auto userdata_ = userdata;\n        // This method is specified to not use AutoLock in json script.\n\n        self->APISetUncapturedErrorCallback(callback_, userdata_);\n    }\n\n    void NativeDeviceTick(WGPUDevice cSelf) {\n        auto self = FromAPI(cSelf);\n\n        // This method is specified to not use AutoLock in json script.\n\n        self->APITick();\n    }\n\n    void NativeDeviceValidateTextureDescriptor(WGPUDevice cSelf, WGPUTextureDescriptor const * descriptor) {\n        auto self = FromAPI(cSelf);\n\n        auto descriptor_ = reinterpret_cast<TextureDescriptor const * >(descriptor);\n        auto device = self;\n        auto deviceLock(device->GetScopedLock());\n\n        self->APIValidateTextureDescriptor(descriptor_);\n    }\n\n    void NativeDeviceReference(WGPUDevice cSelf) {\n        auto self = FromAPI(cSelf);\n\n        // This method is specified to not use AutoLock in json script.\n\n        self->APIReference();\n    }\n\n    void NativeDeviceRelease(WGPUDevice cSelf) {\n        auto self = FromAPI(cSelf);\n\n        // This method is specified to not use AutoLock in json script.\n\n        self->APIRelease();\n    }\n\n    void NativeExternalTextureDestroy(WGPUExternalTexture cSelf) {\n        auto self = FromAPI(cSelf);\n\n        auto device = self->GetDevice();\n        auto deviceLock(device->GetScopedLock());\n\n        self->APIDestroy();\n    }\n\n    void NativeExternalTextureExpire(WGPUExternalTexture cSelf) {\n        auto self = FromAPI(cSelf);\n\n        auto device = self->GetDevice();\n        auto deviceLock(device->GetScopedLock());\n\n        self->APIExpire();\n    }\n\n    void NativeExternalTextureRefresh(WGPUExternalTexture cSelf) {\n        auto self = FromAPI(cSelf);\n\n        auto device = self->GetDevice();\n        auto deviceLock(device->GetScopedLock());\n\n        self->APIRefresh();\n    }\n\n    void NativeExternalTextureSetLabel(WGPUExternalTexture cSelf, char const * label) {\n        auto self = FromAPI(cSelf);\n\n        auto label_ = reinterpret_cast<char const * >(label);\n        auto device = self->GetDevice();\n        auto deviceLock(device->GetScopedLock());\n\n        self->APISetLabel(label_);\n    }\n\n    void NativeExternalTextureReference(WGPUExternalTexture cSelf) {\n        auto self = FromAPI(cSelf);\n\n        // This method is specified to not use AutoLock in json script.\n\n        self->APIReference();\n    }\n\n    void NativeExternalTextureRelease(WGPUExternalTexture cSelf) {\n        auto self = FromAPI(cSelf);\n\n        // This method is specified to not use AutoLock in json script.\n\n        self->APIRelease();\n    }\n\n    WGPUSurface NativeInstanceCreateSurface(WGPUInstance cSelf, WGPUSurfaceDescriptor const * descriptor) {\n        auto self = FromAPI(cSelf);\n\n        auto descriptor_ = reinterpret_cast<SurfaceDescriptor const * >(descriptor);\n        // This method is specified to not use AutoLock in json script.\n\n        auto result =        self->APICreateSurface(descriptor_);\n        return ToAPI(result);\n    }\n\n    void NativeInstanceProcessEvents(WGPUInstance cSelf) {\n        auto self = FromAPI(cSelf);\n\n        // This method is specified to not use AutoLock in json script.\n\n        self->APIProcessEvents();\n    }\n\n    void NativeInstanceRequestAdapter(WGPUInstance cSelf, WGPURequestAdapterOptions const * options, WGPURequestAdapterCallback callback, void * userdata) {\n        auto self = FromAPI(cSelf);\n\n        auto options_ = reinterpret_cast<RequestAdapterOptions const * >(options);\n        auto callback_ = callback;\n        auto userdata_ = userdata;\n        // This method is specified to not use AutoLock in json script.\n\n        self->APIRequestAdapter(options_, callback_, userdata_);\n    }\n\n    void NativeInstanceReference(WGPUInstance cSelf) {\n        auto self = FromAPI(cSelf);\n\n        // This method is specified to not use AutoLock in json script.\n\n        self->APIReference();\n    }\n\n    void NativeInstanceRelease(WGPUInstance cSelf) {\n        auto self = FromAPI(cSelf);\n\n        // This method is specified to not use AutoLock in json script.\n\n        self->APIRelease();\n    }\n\n    void NativePipelineLayoutSetLabel(WGPUPipelineLayout cSelf, char const * label) {\n        auto self = FromAPI(cSelf);\n\n        auto label_ = reinterpret_cast<char const * >(label);\n        auto device = self->GetDevice();\n        auto deviceLock(device->GetScopedLock());\n\n        self->APISetLabel(label_);\n    }\n\n    void NativePipelineLayoutReference(WGPUPipelineLayout cSelf) {\n        auto self = FromAPI(cSelf);\n\n        // This method is specified to not use AutoLock in json script.\n\n        self->APIReference();\n    }\n\n    void NativePipelineLayoutRelease(WGPUPipelineLayout cSelf) {\n        auto self = FromAPI(cSelf);\n\n        // This method is specified to not use AutoLock in json script.\n\n        self->APIRelease();\n    }\n\n    void NativeQuerySetDestroy(WGPUQuerySet cSelf) {\n        auto self = FromAPI(cSelf);\n\n        auto device = self->GetDevice();\n        auto deviceLock(device->GetScopedLock());\n\n        self->APIDestroy();\n    }\n\n    uint32_t NativeQuerySetGetCount(WGPUQuerySet cSelf) {\n        auto self = FromAPI(cSelf);\n\n        auto device = self->GetDevice();\n        auto deviceLock(device->GetScopedLock());\n\n        auto result =        self->APIGetCount();\n        return result;\n    }\n\n    WGPUQueryType NativeQuerySetGetType(WGPUQuerySet cSelf) {\n        auto self = FromAPI(cSelf);\n\n        auto device = self->GetDevice();\n        auto deviceLock(device->GetScopedLock());\n\n        auto result =        self->APIGetType();\n        return ToAPI(result);\n    }\n\n    void NativeQuerySetSetLabel(WGPUQuerySet cSelf, char const * label) {\n        auto self = FromAPI(cSelf);\n\n        auto label_ = reinterpret_cast<char const * >(label);\n        auto device = self->GetDevice();\n        auto deviceLock(device->GetScopedLock());\n\n        self->APISetLabel(label_);\n    }\n\n    void NativeQuerySetReference(WGPUQuerySet cSelf) {\n        auto self = FromAPI(cSelf);\n\n        // This method is specified to not use AutoLock in json script.\n\n        self->APIReference();\n    }\n\n    void NativeQuerySetRelease(WGPUQuerySet cSelf) {\n        auto self = FromAPI(cSelf);\n\n        // This method is specified to not use AutoLock in json script.\n\n        self->APIRelease();\n    }\n\n    void NativeQueueCopyExternalTextureForBrowser(WGPUQueue cSelf, WGPUImageCopyExternalTexture const * source, WGPUImageCopyTexture const * destination, WGPUExtent3D const * copySize, WGPUCopyTextureForBrowserOptions const * options) {\n        auto self = FromAPI(cSelf);\n\n        auto source_ = reinterpret_cast<ImageCopyExternalTexture const * >(source);\n        auto destination_ = reinterpret_cast<ImageCopyTexture const * >(destination);\n        auto copySize_ = reinterpret_cast<Extent3D const * >(copySize);\n        auto options_ = reinterpret_cast<CopyTextureForBrowserOptions const * >(options);\n        auto device = self->GetDevice();\n        auto deviceLock(device->GetScopedLock());\n\n        self->APICopyExternalTextureForBrowser(source_, destination_, copySize_, options_);\n    }\n\n    void NativeQueueCopyTextureForBrowser(WGPUQueue cSelf, WGPUImageCopyTexture const * source, WGPUImageCopyTexture const * destination, WGPUExtent3D const * copySize, WGPUCopyTextureForBrowserOptions const * options) {\n        auto self = FromAPI(cSelf);\n\n        auto source_ = reinterpret_cast<ImageCopyTexture const * >(source);\n        auto destination_ = reinterpret_cast<ImageCopyTexture const * >(destination);\n        auto copySize_ = reinterpret_cast<Extent3D const * >(copySize);\n        auto options_ = reinterpret_cast<CopyTextureForBrowserOptions const * >(options);\n        auto device = self->GetDevice();\n        auto deviceLock(device->GetScopedLock());\n\n        self->APICopyTextureForBrowser(source_, destination_, copySize_, options_);\n    }\n\n    void NativeQueueOnSubmittedWorkDone(WGPUQueue cSelf, uint64_t signalValue, WGPUQueueWorkDoneCallback callback, void * userdata) {\n        auto self = FromAPI(cSelf);\n\n        auto signalValue_ = signalValue;\n        auto callback_ = callback;\n        auto userdata_ = userdata;\n        auto device = self->GetDevice();\n        auto deviceLock(device->GetScopedLock());\n\n        self->APIOnSubmittedWorkDone(signalValue_, callback_, userdata_);\n    }\n\n    void NativeQueueSetLabel(WGPUQueue cSelf, char const * label) {\n        auto self = FromAPI(cSelf);\n\n        auto label_ = reinterpret_cast<char const * >(label);\n        auto device = self->GetDevice();\n        auto deviceLock(device->GetScopedLock());\n\n        self->APISetLabel(label_);\n    }\n\n    void NativeQueueSubmit(WGPUQueue cSelf, size_t commandCount, WGPUCommandBuffer const * commands) {\n        auto self = FromAPI(cSelf);\n\n        auto commandCount_ = commandCount;\n        auto commands_ = reinterpret_cast<CommandBufferBase* const * >(commands);\n        auto device = self->GetDevice();\n        auto deviceLock(device->GetScopedLock());\n\n        self->APISubmit(commandCount_, commands_);\n    }\n\n    void NativeQueueWriteBuffer(WGPUQueue cSelf, WGPUBuffer buffer, uint64_t bufferOffset, void const * data, size_t size) {\n        auto self = FromAPI(cSelf);\n\n        auto buffer_ = reinterpret_cast<BufferBase* >(buffer);\n        auto bufferOffset_ = bufferOffset;\n        auto data_ = reinterpret_cast<void const * >(data);\n        auto size_ = size;\n        auto device = self->GetDevice();\n        auto deviceLock(device->GetScopedLock());\n\n        self->APIWriteBuffer(buffer_, bufferOffset_, data_, size_);\n    }\n\n    void NativeQueueWriteTexture(WGPUQueue cSelf, WGPUImageCopyTexture const * destination, void const * data, size_t dataSize, WGPUTextureDataLayout const * dataLayout, WGPUExtent3D const * writeSize) {\n        auto self = FromAPI(cSelf);\n\n        auto destination_ = reinterpret_cast<ImageCopyTexture const * >(destination);\n        auto data_ = reinterpret_cast<void const * >(data);\n        auto dataSize_ = dataSize;\n        auto dataLayout_ = reinterpret_cast<TextureDataLayout const * >(dataLayout);\n        auto writeSize_ = reinterpret_cast<Extent3D const * >(writeSize);\n        auto device = self->GetDevice();\n        auto deviceLock(device->GetScopedLock());\n\n        self->APIWriteTexture(destination_, data_, dataSize_, dataLayout_, writeSize_);\n    }\n\n    void NativeQueueReference(WGPUQueue cSelf) {\n        auto self = FromAPI(cSelf);\n\n        // This method is specified to not use AutoLock in json script.\n\n        self->APIReference();\n    }\n\n    void NativeQueueRelease(WGPUQueue cSelf) {\n        auto self = FromAPI(cSelf);\n\n        // This method is specified to not use AutoLock in json script.\n\n        self->APIRelease();\n    }\n\n    void NativeRenderBundleSetLabel(WGPURenderBundle cSelf, char const * label) {\n        auto self = FromAPI(cSelf);\n\n        auto label_ = reinterpret_cast<char const * >(label);\n        auto device = self->GetDevice();\n        auto deviceLock(device->GetScopedLock());\n\n        self->APISetLabel(label_);\n    }\n\n    void NativeRenderBundleReference(WGPURenderBundle cSelf) {\n        auto self = FromAPI(cSelf);\n\n        // This method is specified to not use AutoLock in json script.\n\n        self->APIReference();\n    }\n\n    void NativeRenderBundleRelease(WGPURenderBundle cSelf) {\n        auto self = FromAPI(cSelf);\n\n        // This method is specified to not use AutoLock in json script.\n\n        self->APIRelease();\n    }\n\n    void NativeRenderBundleEncoderDraw(WGPURenderBundleEncoder cSelf, uint32_t vertexCount, uint32_t instanceCount, uint32_t firstVertex, uint32_t firstInstance) {\n        auto self = FromAPI(cSelf);\n\n        auto vertexCount_ = vertexCount;\n        auto instanceCount_ = instanceCount;\n        auto firstVertex_ = firstVertex;\n        auto firstInstance_ = firstInstance;\n        // This method is specified to not use AutoLock in json script.\n\n        self->APIDraw(vertexCount_, instanceCount_, firstVertex_, firstInstance_);\n    }\n\n    void NativeRenderBundleEncoderDrawIndexed(WGPURenderBundleEncoder cSelf, uint32_t indexCount, uint32_t instanceCount, uint32_t firstIndex, int32_t baseVertex, uint32_t firstInstance) {\n        auto self = FromAPI(cSelf);\n\n        auto indexCount_ = indexCount;\n        auto instanceCount_ = instanceCount;\n        auto firstIndex_ = firstIndex;\n        auto baseVertex_ = baseVertex;\n        auto firstInstance_ = firstInstance;\n        // This method is specified to not use AutoLock in json script.\n\n        self->APIDrawIndexed(indexCount_, instanceCount_, firstIndex_, baseVertex_, firstInstance_);\n    }\n\n    void NativeRenderBundleEncoderDrawIndexedIndirect(WGPURenderBundleEncoder cSelf, WGPUBuffer indirectBuffer, uint64_t indirectOffset) {\n        auto self = FromAPI(cSelf);\n\n        auto indirectBuffer_ = reinterpret_cast<BufferBase* >(indirectBuffer);\n        auto indirectOffset_ = indirectOffset;\n        // This method is specified to not use AutoLock in json script.\n\n        self->APIDrawIndexedIndirect(indirectBuffer_, indirectOffset_);\n    }\n\n    void NativeRenderBundleEncoderDrawIndirect(WGPURenderBundleEncoder cSelf, WGPUBuffer indirectBuffer, uint64_t indirectOffset) {\n        auto self = FromAPI(cSelf);\n\n        auto indirectBuffer_ = reinterpret_cast<BufferBase* >(indirectBuffer);\n        auto indirectOffset_ = indirectOffset;\n        // This method is specified to not use AutoLock in json script.\n\n        self->APIDrawIndirect(indirectBuffer_, indirectOffset_);\n    }\n\n    WGPURenderBundle NativeRenderBundleEncoderFinish(WGPURenderBundleEncoder cSelf, WGPURenderBundleDescriptor const * descriptor) {\n        auto self = FromAPI(cSelf);\n\n        auto descriptor_ = reinterpret_cast<RenderBundleDescriptor const * >(descriptor);\n        // This method is specified to not use AutoLock in json script.\n\n        auto result =        self->APIFinish(descriptor_);\n        return ToAPI(result);\n    }\n\n    void NativeRenderBundleEncoderInsertDebugMarker(WGPURenderBundleEncoder cSelf, char const * markerLabel) {\n        auto self = FromAPI(cSelf);\n\n        auto markerLabel_ = reinterpret_cast<char const * >(markerLabel);\n        // This method is specified to not use AutoLock in json script.\n\n        self->APIInsertDebugMarker(markerLabel_);\n    }\n\n    void NativeRenderBundleEncoderPopDebugGroup(WGPURenderBundleEncoder cSelf) {\n        auto self = FromAPI(cSelf);\n\n        // This method is specified to not use AutoLock in json script.\n\n        self->APIPopDebugGroup();\n    }\n\n    void NativeRenderBundleEncoderPushDebugGroup(WGPURenderBundleEncoder cSelf, char const * groupLabel) {\n        auto self = FromAPI(cSelf);\n\n        auto groupLabel_ = reinterpret_cast<char const * >(groupLabel);\n        // This method is specified to not use AutoLock in json script.\n\n        self->APIPushDebugGroup(groupLabel_);\n    }\n\n    void NativeRenderBundleEncoderSetBindGroup(WGPURenderBundleEncoder cSelf, uint32_t groupIndex, WGPUBindGroup group, size_t dynamicOffsetCount, uint32_t const * dynamicOffsets) {\n        auto self = FromAPI(cSelf);\n\n        auto groupIndex_ = groupIndex;\n        auto group_ = reinterpret_cast<BindGroupBase* >(group);\n        auto dynamicOffsetCount_ = dynamicOffsetCount;\n        auto dynamicOffsets_ = reinterpret_cast<uint32_t const * >(dynamicOffsets);\n        // This method is specified to not use AutoLock in json script.\n\n        self->APISetBindGroup(groupIndex_, group_, dynamicOffsetCount_, dynamicOffsets_);\n    }\n\n    void NativeRenderBundleEncoderSetIndexBuffer(WGPURenderBundleEncoder cSelf, WGPUBuffer buffer, WGPUIndexFormat format, uint64_t offset, uint64_t size) {\n        auto self = FromAPI(cSelf);\n\n        auto buffer_ = reinterpret_cast<BufferBase* >(buffer);\n        auto format_ = static_cast<wgpu::IndexFormat>(format);\n        auto offset_ = offset;\n        auto size_ = size;\n        // This method is specified to not use AutoLock in json script.\n\n        self->APISetIndexBuffer(buffer_, format_, offset_, size_);\n    }\n\n    void NativeRenderBundleEncoderSetLabel(WGPURenderBundleEncoder cSelf, char const * label) {\n        auto self = FromAPI(cSelf);\n\n        auto label_ = reinterpret_cast<char const * >(label);\n        // This method is specified to not use AutoLock in json script.\n\n        self->APISetLabel(label_);\n    }\n\n    void NativeRenderBundleEncoderSetPipeline(WGPURenderBundleEncoder cSelf, WGPURenderPipeline pipeline) {\n        auto self = FromAPI(cSelf);\n\n        auto pipeline_ = reinterpret_cast<RenderPipelineBase* >(pipeline);\n        // This method is specified to not use AutoLock in json script.\n\n        self->APISetPipeline(pipeline_);\n    }\n\n    void NativeRenderBundleEncoderSetVertexBuffer(WGPURenderBundleEncoder cSelf, uint32_t slot, WGPUBuffer buffer, uint64_t offset, uint64_t size) {\n        auto self = FromAPI(cSelf);\n\n        auto slot_ = slot;\n        auto buffer_ = reinterpret_cast<BufferBase* >(buffer);\n        auto offset_ = offset;\n        auto size_ = size;\n        // This method is specified to not use AutoLock in json script.\n\n        self->APISetVertexBuffer(slot_, buffer_, offset_, size_);\n    }\n\n    void NativeRenderBundleEncoderReference(WGPURenderBundleEncoder cSelf) {\n        auto self = FromAPI(cSelf);\n\n        // This method is specified to not use AutoLock in json script.\n\n        self->APIReference();\n    }\n\n    void NativeRenderBundleEncoderRelease(WGPURenderBundleEncoder cSelf) {\n        auto self = FromAPI(cSelf);\n\n        // This method is specified to not use AutoLock in json script.\n\n        self->APIRelease();\n    }\n\n    void NativeRenderPassEncoderBeginOcclusionQuery(WGPURenderPassEncoder cSelf, uint32_t queryIndex) {\n        auto self = FromAPI(cSelf);\n\n        auto queryIndex_ = queryIndex;\n        // This method is specified to not use AutoLock in json script.\n\n        self->APIBeginOcclusionQuery(queryIndex_);\n    }\n\n    void NativeRenderPassEncoderDraw(WGPURenderPassEncoder cSelf, uint32_t vertexCount, uint32_t instanceCount, uint32_t firstVertex, uint32_t firstInstance) {\n        auto self = FromAPI(cSelf);\n\n        auto vertexCount_ = vertexCount;\n        auto instanceCount_ = instanceCount;\n        auto firstVertex_ = firstVertex;\n        auto firstInstance_ = firstInstance;\n        // This method is specified to not use AutoLock in json script.\n\n        self->APIDraw(vertexCount_, instanceCount_, firstVertex_, firstInstance_);\n    }\n\n    void NativeRenderPassEncoderDrawIndexed(WGPURenderPassEncoder cSelf, uint32_t indexCount, uint32_t instanceCount, uint32_t firstIndex, int32_t baseVertex, uint32_t firstInstance) {\n        auto self = FromAPI(cSelf);\n\n        auto indexCount_ = indexCount;\n        auto instanceCount_ = instanceCount;\n        auto firstIndex_ = firstIndex;\n        auto baseVertex_ = baseVertex;\n        auto firstInstance_ = firstInstance;\n        // This method is specified to not use AutoLock in json script.\n\n        self->APIDrawIndexed(indexCount_, instanceCount_, firstIndex_, baseVertex_, firstInstance_);\n    }\n\n    void NativeRenderPassEncoderDrawIndexedIndirect(WGPURenderPassEncoder cSelf, WGPUBuffer indirectBuffer, uint64_t indirectOffset) {\n        auto self = FromAPI(cSelf);\n\n        auto indirectBuffer_ = reinterpret_cast<BufferBase* >(indirectBuffer);\n        auto indirectOffset_ = indirectOffset;\n        // This method is specified to not use AutoLock in json script.\n\n        self->APIDrawIndexedIndirect(indirectBuffer_, indirectOffset_);\n    }\n\n    void NativeRenderPassEncoderDrawIndirect(WGPURenderPassEncoder cSelf, WGPUBuffer indirectBuffer, uint64_t indirectOffset) {\n        auto self = FromAPI(cSelf);\n\n        auto indirectBuffer_ = reinterpret_cast<BufferBase* >(indirectBuffer);\n        auto indirectOffset_ = indirectOffset;\n        // This method is specified to not use AutoLock in json script.\n\n        self->APIDrawIndirect(indirectBuffer_, indirectOffset_);\n    }\n\n    void NativeRenderPassEncoderEnd(WGPURenderPassEncoder cSelf) {\n        auto self = FromAPI(cSelf);\n\n        // This method is specified to not use AutoLock in json script.\n\n        self->APIEnd();\n    }\n\n    void NativeRenderPassEncoderEndOcclusionQuery(WGPURenderPassEncoder cSelf) {\n        auto self = FromAPI(cSelf);\n\n        // This method is specified to not use AutoLock in json script.\n\n        self->APIEndOcclusionQuery();\n    }\n\n    void NativeRenderPassEncoderExecuteBundles(WGPURenderPassEncoder cSelf, size_t bundleCount, WGPURenderBundle const * bundles) {\n        auto self = FromAPI(cSelf);\n\n        auto bundleCount_ = bundleCount;\n        auto bundles_ = reinterpret_cast<RenderBundleBase* const * >(bundles);\n        // This method is specified to not use AutoLock in json script.\n\n        self->APIExecuteBundles(bundleCount_, bundles_);\n    }\n\n    void NativeRenderPassEncoderInsertDebugMarker(WGPURenderPassEncoder cSelf, char const * markerLabel) {\n        auto self = FromAPI(cSelf);\n\n        auto markerLabel_ = reinterpret_cast<char const * >(markerLabel);\n        // This method is specified to not use AutoLock in json script.\n\n        self->APIInsertDebugMarker(markerLabel_);\n    }\n\n    void NativeRenderPassEncoderPopDebugGroup(WGPURenderPassEncoder cSelf) {\n        auto self = FromAPI(cSelf);\n\n        // This method is specified to not use AutoLock in json script.\n\n        self->APIPopDebugGroup();\n    }\n\n    void NativeRenderPassEncoderPushDebugGroup(WGPURenderPassEncoder cSelf, char const * groupLabel) {\n        auto self = FromAPI(cSelf);\n\n        auto groupLabel_ = reinterpret_cast<char const * >(groupLabel);\n        // This method is specified to not use AutoLock in json script.\n\n        self->APIPushDebugGroup(groupLabel_);\n    }\n\n    void NativeRenderPassEncoderSetBindGroup(WGPURenderPassEncoder cSelf, uint32_t groupIndex, WGPUBindGroup group, size_t dynamicOffsetCount, uint32_t const * dynamicOffsets) {\n        auto self = FromAPI(cSelf);\n\n        auto groupIndex_ = groupIndex;\n        auto group_ = reinterpret_cast<BindGroupBase* >(group);\n        auto dynamicOffsetCount_ = dynamicOffsetCount;\n        auto dynamicOffsets_ = reinterpret_cast<uint32_t const * >(dynamicOffsets);\n        // This method is specified to not use AutoLock in json script.\n\n        self->APISetBindGroup(groupIndex_, group_, dynamicOffsetCount_, dynamicOffsets_);\n    }\n\n    void NativeRenderPassEncoderSetBlendConstant(WGPURenderPassEncoder cSelf, WGPUColor const * color) {\n        auto self = FromAPI(cSelf);\n\n        auto color_ = reinterpret_cast<Color const * >(color);\n        // This method is specified to not use AutoLock in json script.\n\n        self->APISetBlendConstant(color_);\n    }\n\n    void NativeRenderPassEncoderSetIndexBuffer(WGPURenderPassEncoder cSelf, WGPUBuffer buffer, WGPUIndexFormat format, uint64_t offset, uint64_t size) {\n        auto self = FromAPI(cSelf);\n\n        auto buffer_ = reinterpret_cast<BufferBase* >(buffer);\n        auto format_ = static_cast<wgpu::IndexFormat>(format);\n        auto offset_ = offset;\n        auto size_ = size;\n        // This method is specified to not use AutoLock in json script.\n\n        self->APISetIndexBuffer(buffer_, format_, offset_, size_);\n    }\n\n    void NativeRenderPassEncoderSetLabel(WGPURenderPassEncoder cSelf, char const * label) {\n        auto self = FromAPI(cSelf);\n\n        auto label_ = reinterpret_cast<char const * >(label);\n        // This method is specified to not use AutoLock in json script.\n\n        self->APISetLabel(label_);\n    }\n\n    void NativeRenderPassEncoderSetPipeline(WGPURenderPassEncoder cSelf, WGPURenderPipeline pipeline) {\n        auto self = FromAPI(cSelf);\n\n        auto pipeline_ = reinterpret_cast<RenderPipelineBase* >(pipeline);\n        // This method is specified to not use AutoLock in json script.\n\n        self->APISetPipeline(pipeline_);\n    }\n\n    void NativeRenderPassEncoderSetScissorRect(WGPURenderPassEncoder cSelf, uint32_t x, uint32_t y, uint32_t width, uint32_t height) {\n        auto self = FromAPI(cSelf);\n\n        auto x_ = x;\n        auto y_ = y;\n        auto width_ = width;\n        auto height_ = height;\n        // This method is specified to not use AutoLock in json script.\n\n        self->APISetScissorRect(x_, y_, width_, height_);\n    }\n\n    void NativeRenderPassEncoderSetStencilReference(WGPURenderPassEncoder cSelf, uint32_t reference) {\n        auto self = FromAPI(cSelf);\n\n        auto reference_ = reference;\n        // This method is specified to not use AutoLock in json script.\n\n        self->APISetStencilReference(reference_);\n    }\n\n    void NativeRenderPassEncoderSetVertexBuffer(WGPURenderPassEncoder cSelf, uint32_t slot, WGPUBuffer buffer, uint64_t offset, uint64_t size) {\n        auto self = FromAPI(cSelf);\n\n        auto slot_ = slot;\n        auto buffer_ = reinterpret_cast<BufferBase* >(buffer);\n        auto offset_ = offset;\n        auto size_ = size;\n        // This method is specified to not use AutoLock in json script.\n\n        self->APISetVertexBuffer(slot_, buffer_, offset_, size_);\n    }\n\n    void NativeRenderPassEncoderSetViewport(WGPURenderPassEncoder cSelf, float x, float y, float width, float height, float minDepth, float maxDepth) {\n        auto self = FromAPI(cSelf);\n\n        auto x_ = x;\n        auto y_ = y;\n        auto width_ = width;\n        auto height_ = height;\n        auto minDepth_ = minDepth;\n        auto maxDepth_ = maxDepth;\n        // This method is specified to not use AutoLock in json script.\n\n        self->APISetViewport(x_, y_, width_, height_, minDepth_, maxDepth_);\n    }\n\n    void NativeRenderPassEncoderWriteTimestamp(WGPURenderPassEncoder cSelf, WGPUQuerySet querySet, uint32_t queryIndex) {\n        auto self = FromAPI(cSelf);\n\n        auto querySet_ = reinterpret_cast<QuerySetBase* >(querySet);\n        auto queryIndex_ = queryIndex;\n        // This method is specified to not use AutoLock in json script.\n\n        self->APIWriteTimestamp(querySet_, queryIndex_);\n    }\n\n    void NativeRenderPassEncoderReference(WGPURenderPassEncoder cSelf) {\n        auto self = FromAPI(cSelf);\n\n        // This method is specified to not use AutoLock in json script.\n\n        self->APIReference();\n    }\n\n    void NativeRenderPassEncoderRelease(WGPURenderPassEncoder cSelf) {\n        auto self = FromAPI(cSelf);\n\n        // This method is specified to not use AutoLock in json script.\n\n        self->APIRelease();\n    }\n\n    WGPUBindGroupLayout NativeRenderPipelineGetBindGroupLayout(WGPURenderPipeline cSelf, uint32_t groupIndex) {\n        auto self = FromAPI(cSelf);\n\n        auto groupIndex_ = groupIndex;\n        auto device = self->GetDevice();\n        auto deviceLock(device->GetScopedLock());\n\n        auto result =        self->APIGetBindGroupLayout(groupIndex_);\n        return ToAPI(result);\n    }\n\n    void NativeRenderPipelineSetLabel(WGPURenderPipeline cSelf, char const * label) {\n        auto self = FromAPI(cSelf);\n\n        auto label_ = reinterpret_cast<char const * >(label);\n        auto device = self->GetDevice();\n        auto deviceLock(device->GetScopedLock());\n\n        self->APISetLabel(label_);\n    }\n\n    void NativeRenderPipelineReference(WGPURenderPipeline cSelf) {\n        auto self = FromAPI(cSelf);\n\n        // This method is specified to not use AutoLock in json script.\n\n        self->APIReference();\n    }\n\n    void NativeRenderPipelineRelease(WGPURenderPipeline cSelf) {\n        auto self = FromAPI(cSelf);\n\n        // This method is specified to not use AutoLock in json script.\n\n        self->APIRelease();\n    }\n\n    void NativeSamplerSetLabel(WGPUSampler cSelf, char const * label) {\n        auto self = FromAPI(cSelf);\n\n        auto label_ = reinterpret_cast<char const * >(label);\n        auto device = self->GetDevice();\n        auto deviceLock(device->GetScopedLock());\n\n        self->APISetLabel(label_);\n    }\n\n    void NativeSamplerReference(WGPUSampler cSelf) {\n        auto self = FromAPI(cSelf);\n\n        // This method is specified to not use AutoLock in json script.\n\n        self->APIReference();\n    }\n\n    void NativeSamplerRelease(WGPUSampler cSelf) {\n        auto self = FromAPI(cSelf);\n\n        // This method is specified to not use AutoLock in json script.\n\n        self->APIRelease();\n    }\n\n    void NativeShaderModuleGetCompilationInfo(WGPUShaderModule cSelf, WGPUCompilationInfoCallback callback, void * userdata) {\n        auto self = FromAPI(cSelf);\n\n        auto callback_ = callback;\n        auto userdata_ = userdata;\n        auto device = self->GetDevice();\n        auto deviceLock(device->GetScopedLock());\n\n        self->APIGetCompilationInfo(callback_, userdata_);\n    }\n\n    void NativeShaderModuleSetLabel(WGPUShaderModule cSelf, char const * label) {\n        auto self = FromAPI(cSelf);\n\n        auto label_ = reinterpret_cast<char const * >(label);\n        auto device = self->GetDevice();\n        auto deviceLock(device->GetScopedLock());\n\n        self->APISetLabel(label_);\n    }\n\n    void NativeShaderModuleReference(WGPUShaderModule cSelf) {\n        auto self = FromAPI(cSelf);\n\n        // This method is specified to not use AutoLock in json script.\n\n        self->APIReference();\n    }\n\n    void NativeShaderModuleRelease(WGPUShaderModule cSelf) {\n        auto self = FromAPI(cSelf);\n\n        // This method is specified to not use AutoLock in json script.\n\n        self->APIRelease();\n    }\n\n    void NativeSurfaceReference(WGPUSurface cSelf) {\n        auto self = FromAPI(cSelf);\n\n        // This method is specified to not use AutoLock in json script.\n\n        self->APIReference();\n    }\n\n    void NativeSurfaceRelease(WGPUSurface cSelf) {\n        auto self = FromAPI(cSelf);\n\n        // This method is specified to not use AutoLock in json script.\n\n        self->APIRelease();\n    }\n\n    WGPUTexture NativeSwapChainGetCurrentTexture(WGPUSwapChain cSelf) {\n        auto self = FromAPI(cSelf);\n\n        auto device = self->GetDevice();\n        auto deviceLock(device->GetScopedLock());\n\n        auto result =        self->APIGetCurrentTexture();\n        return ToAPI(result);\n    }\n\n    WGPUTextureView NativeSwapChainGetCurrentTextureView(WGPUSwapChain cSelf) {\n        auto self = FromAPI(cSelf);\n\n        auto device = self->GetDevice();\n        auto deviceLock(device->GetScopedLock());\n\n        auto result =        self->APIGetCurrentTextureView();\n        return ToAPI(result);\n    }\n\n    void NativeSwapChainPresent(WGPUSwapChain cSelf) {\n        auto self = FromAPI(cSelf);\n\n        auto device = self->GetDevice();\n        auto deviceLock(device->GetScopedLock());\n\n        self->APIPresent();\n    }\n\n    void NativeSwapChainReference(WGPUSwapChain cSelf) {\n        auto self = FromAPI(cSelf);\n\n        // This method is specified to not use AutoLock in json script.\n\n        self->APIReference();\n    }\n\n    void NativeSwapChainRelease(WGPUSwapChain cSelf) {\n        auto self = FromAPI(cSelf);\n\n        // This method is specified to not use AutoLock in json script.\n\n        self->APIRelease();\n    }\n\n    WGPUTextureView NativeTextureCreateView(WGPUTexture cSelf, WGPUTextureViewDescriptor const * descriptor) {\n        auto self = FromAPI(cSelf);\n\n        auto descriptor_ = reinterpret_cast<TextureViewDescriptor const * >(descriptor);\n        auto device = self->GetDevice();\n        auto deviceLock(device->GetScopedLock());\n\n        auto result =        self->APICreateView(descriptor_);\n        return ToAPI(result);\n    }\n\n    void NativeTextureDestroy(WGPUTexture cSelf) {\n        auto self = FromAPI(cSelf);\n\n        auto device = self->GetDevice();\n        auto deviceLock(device->GetScopedLock());\n\n        self->APIDestroy();\n    }\n\n    uint32_t NativeTextureGetDepthOrArrayLayers(WGPUTexture cSelf) {\n        auto self = FromAPI(cSelf);\n\n        auto device = self->GetDevice();\n        auto deviceLock(device->GetScopedLock());\n\n        auto result =        self->APIGetDepthOrArrayLayers();\n        return result;\n    }\n\n    WGPUTextureDimension NativeTextureGetDimension(WGPUTexture cSelf) {\n        auto self = FromAPI(cSelf);\n\n        auto device = self->GetDevice();\n        auto deviceLock(device->GetScopedLock());\n\n        auto result =        self->APIGetDimension();\n        return ToAPI(result);\n    }\n\n    WGPUTextureFormat NativeTextureGetFormat(WGPUTexture cSelf) {\n        auto self = FromAPI(cSelf);\n\n        auto device = self->GetDevice();\n        auto deviceLock(device->GetScopedLock());\n\n        auto result =        self->APIGetFormat();\n        return ToAPI(result);\n    }\n\n    uint32_t NativeTextureGetHeight(WGPUTexture cSelf) {\n        auto self = FromAPI(cSelf);\n\n        auto device = self->GetDevice();\n        auto deviceLock(device->GetScopedLock());\n\n        auto result =        self->APIGetHeight();\n        return result;\n    }\n\n    uint32_t NativeTextureGetMipLevelCount(WGPUTexture cSelf) {\n        auto self = FromAPI(cSelf);\n\n        auto device = self->GetDevice();\n        auto deviceLock(device->GetScopedLock());\n\n        auto result =        self->APIGetMipLevelCount();\n        return result;\n    }\n\n    uint32_t NativeTextureGetSampleCount(WGPUTexture cSelf) {\n        auto self = FromAPI(cSelf);\n\n        auto device = self->GetDevice();\n        auto deviceLock(device->GetScopedLock());\n\n        auto result =        self->APIGetSampleCount();\n        return result;\n    }\n\n    WGPUTextureUsageFlags NativeTextureGetUsage(WGPUTexture cSelf) {\n        auto self = FromAPI(cSelf);\n\n        auto device = self->GetDevice();\n        auto deviceLock(device->GetScopedLock());\n\n        auto result =        self->APIGetUsage();\n        return ToAPI(result);\n    }\n\n    uint32_t NativeTextureGetWidth(WGPUTexture cSelf) {\n        auto self = FromAPI(cSelf);\n\n        auto device = self->GetDevice();\n        auto deviceLock(device->GetScopedLock());\n\n        auto result =        self->APIGetWidth();\n        return result;\n    }\n\n    void NativeTextureSetLabel(WGPUTexture cSelf, char const * label) {\n        auto self = FromAPI(cSelf);\n\n        auto label_ = reinterpret_cast<char const * >(label);\n        auto device = self->GetDevice();\n        auto deviceLock(device->GetScopedLock());\n\n        self->APISetLabel(label_);\n    }\n\n    void NativeTextureReference(WGPUTexture cSelf) {\n        auto self = FromAPI(cSelf);\n\n        // This method is specified to not use AutoLock in json script.\n\n        self->APIReference();\n    }\n\n    void NativeTextureRelease(WGPUTexture cSelf) {\n        auto self = FromAPI(cSelf);\n\n        // This method is specified to not use AutoLock in json script.\n\n        self->APIRelease();\n    }\n\n    void NativeTextureViewSetLabel(WGPUTextureView cSelf, char const * label) {\n        auto self = FromAPI(cSelf);\n\n        auto label_ = reinterpret_cast<char const * >(label);\n        auto device = self->GetDevice();\n        auto deviceLock(device->GetScopedLock());\n\n        self->APISetLabel(label_);\n    }\n\n    void NativeTextureViewReference(WGPUTextureView cSelf) {\n        auto self = FromAPI(cSelf);\n\n        // This method is specified to not use AutoLock in json script.\n\n        self->APIReference();\n    }\n\n    void NativeTextureViewRelease(WGPUTextureView cSelf) {\n        auto self = FromAPI(cSelf);\n\n        // This method is specified to not use AutoLock in json script.\n\n        self->APIRelease();\n    }\n\n    WGPUInstance NativeCreateInstance(WGPUInstanceDescriptor const * descriptor) {\n        auto descriptor_ = reinterpret_cast<InstanceDescriptor const * >(descriptor);\n        auto result =        APICreateInstance(descriptor_);\n        return ToAPI(result);\n    }\n\n    namespace {\n\n        struct ProcEntry {\n            WGPUProc proc;\n            const char* name;\n        };\n        static const ProcEntry sProcMap[] = {\n            { reinterpret_cast<WGPUProc>(NativeAdapterCreateDevice), \"wgpuAdapterCreateDevice\" },\n            { reinterpret_cast<WGPUProc>(NativeAdapterEnumerateFeatures), \"wgpuAdapterEnumerateFeatures\" },\n            { reinterpret_cast<WGPUProc>(NativeAdapterGetInstance), \"wgpuAdapterGetInstance\" },\n            { reinterpret_cast<WGPUProc>(NativeAdapterGetLimits), \"wgpuAdapterGetLimits\" },\n            { reinterpret_cast<WGPUProc>(NativeAdapterGetProperties), \"wgpuAdapterGetProperties\" },\n            { reinterpret_cast<WGPUProc>(NativeAdapterHasFeature), \"wgpuAdapterHasFeature\" },\n            { reinterpret_cast<WGPUProc>(NativeAdapterReference), \"wgpuAdapterReference\" },\n            { reinterpret_cast<WGPUProc>(NativeAdapterRelease), \"wgpuAdapterRelease\" },\n            { reinterpret_cast<WGPUProc>(NativeAdapterRequestDevice), \"wgpuAdapterRequestDevice\" },\n            { reinterpret_cast<WGPUProc>(NativeBindGroupLayoutReference), \"wgpuBindGroupLayoutReference\" },\n            { reinterpret_cast<WGPUProc>(NativeBindGroupLayoutRelease), \"wgpuBindGroupLayoutRelease\" },\n            { reinterpret_cast<WGPUProc>(NativeBindGroupLayoutSetLabel), \"wgpuBindGroupLayoutSetLabel\" },\n            { reinterpret_cast<WGPUProc>(NativeBindGroupReference), \"wgpuBindGroupReference\" },\n            { reinterpret_cast<WGPUProc>(NativeBindGroupRelease), \"wgpuBindGroupRelease\" },\n            { reinterpret_cast<WGPUProc>(NativeBindGroupSetLabel), \"wgpuBindGroupSetLabel\" },\n            { reinterpret_cast<WGPUProc>(NativeBufferDestroy), \"wgpuBufferDestroy\" },\n            { reinterpret_cast<WGPUProc>(NativeBufferGetConstMappedRange), \"wgpuBufferGetConstMappedRange\" },\n            { reinterpret_cast<WGPUProc>(NativeBufferGetMapState), \"wgpuBufferGetMapState\" },\n            { reinterpret_cast<WGPUProc>(NativeBufferGetMappedRange), \"wgpuBufferGetMappedRange\" },\n            { reinterpret_cast<WGPUProc>(NativeBufferGetSize), \"wgpuBufferGetSize\" },\n            { reinterpret_cast<WGPUProc>(NativeBufferGetUsage), \"wgpuBufferGetUsage\" },\n            { reinterpret_cast<WGPUProc>(NativeBufferMapAsync), \"wgpuBufferMapAsync\" },\n            { reinterpret_cast<WGPUProc>(NativeBufferReference), \"wgpuBufferReference\" },\n            { reinterpret_cast<WGPUProc>(NativeBufferRelease), \"wgpuBufferRelease\" },\n            { reinterpret_cast<WGPUProc>(NativeBufferSetLabel), \"wgpuBufferSetLabel\" },\n            { reinterpret_cast<WGPUProc>(NativeBufferUnmap), \"wgpuBufferUnmap\" },\n            { reinterpret_cast<WGPUProc>(NativeCommandBufferReference), \"wgpuCommandBufferReference\" },\n            { reinterpret_cast<WGPUProc>(NativeCommandBufferRelease), \"wgpuCommandBufferRelease\" },\n            { reinterpret_cast<WGPUProc>(NativeCommandBufferSetLabel), \"wgpuCommandBufferSetLabel\" },\n            { reinterpret_cast<WGPUProc>(NativeCommandEncoderBeginComputePass), \"wgpuCommandEncoderBeginComputePass\" },\n            { reinterpret_cast<WGPUProc>(NativeCommandEncoderBeginRenderPass), \"wgpuCommandEncoderBeginRenderPass\" },\n            { reinterpret_cast<WGPUProc>(NativeCommandEncoderClearBuffer), \"wgpuCommandEncoderClearBuffer\" },\n            { reinterpret_cast<WGPUProc>(NativeCommandEncoderCopyBufferToBuffer), \"wgpuCommandEncoderCopyBufferToBuffer\" },\n            { reinterpret_cast<WGPUProc>(NativeCommandEncoderCopyBufferToTexture), \"wgpuCommandEncoderCopyBufferToTexture\" },\n            { reinterpret_cast<WGPUProc>(NativeCommandEncoderCopyTextureToBuffer), \"wgpuCommandEncoderCopyTextureToBuffer\" },\n            { reinterpret_cast<WGPUProc>(NativeCommandEncoderCopyTextureToTexture), \"wgpuCommandEncoderCopyTextureToTexture\" },\n            { reinterpret_cast<WGPUProc>(NativeCommandEncoderCopyTextureToTextureInternal), \"wgpuCommandEncoderCopyTextureToTextureInternal\" },\n            { reinterpret_cast<WGPUProc>(NativeCommandEncoderFinish), \"wgpuCommandEncoderFinish\" },\n            { reinterpret_cast<WGPUProc>(NativeCommandEncoderInjectValidationError), \"wgpuCommandEncoderInjectValidationError\" },\n            { reinterpret_cast<WGPUProc>(NativeCommandEncoderInsertDebugMarker), \"wgpuCommandEncoderInsertDebugMarker\" },\n            { reinterpret_cast<WGPUProc>(NativeCommandEncoderPopDebugGroup), \"wgpuCommandEncoderPopDebugGroup\" },\n            { reinterpret_cast<WGPUProc>(NativeCommandEncoderPushDebugGroup), \"wgpuCommandEncoderPushDebugGroup\" },\n            { reinterpret_cast<WGPUProc>(NativeCommandEncoderReference), \"wgpuCommandEncoderReference\" },\n            { reinterpret_cast<WGPUProc>(NativeCommandEncoderRelease), \"wgpuCommandEncoderRelease\" },\n            { reinterpret_cast<WGPUProc>(NativeCommandEncoderResolveQuerySet), \"wgpuCommandEncoderResolveQuerySet\" },\n            { reinterpret_cast<WGPUProc>(NativeCommandEncoderSetLabel), \"wgpuCommandEncoderSetLabel\" },\n            { reinterpret_cast<WGPUProc>(NativeCommandEncoderWriteBuffer), \"wgpuCommandEncoderWriteBuffer\" },\n            { reinterpret_cast<WGPUProc>(NativeCommandEncoderWriteTimestamp), \"wgpuCommandEncoderWriteTimestamp\" },\n            { reinterpret_cast<WGPUProc>(NativeComputePassEncoderDispatchWorkgroups), \"wgpuComputePassEncoderDispatchWorkgroups\" },\n            { reinterpret_cast<WGPUProc>(NativeComputePassEncoderDispatchWorkgroupsIndirect), \"wgpuComputePassEncoderDispatchWorkgroupsIndirect\" },\n            { reinterpret_cast<WGPUProc>(NativeComputePassEncoderEnd), \"wgpuComputePassEncoderEnd\" },\n            { reinterpret_cast<WGPUProc>(NativeComputePassEncoderInsertDebugMarker), \"wgpuComputePassEncoderInsertDebugMarker\" },\n            { reinterpret_cast<WGPUProc>(NativeComputePassEncoderPopDebugGroup), \"wgpuComputePassEncoderPopDebugGroup\" },\n            { reinterpret_cast<WGPUProc>(NativeComputePassEncoderPushDebugGroup), \"wgpuComputePassEncoderPushDebugGroup\" },\n            { reinterpret_cast<WGPUProc>(NativeComputePassEncoderReference), \"wgpuComputePassEncoderReference\" },\n            { reinterpret_cast<WGPUProc>(NativeComputePassEncoderRelease), \"wgpuComputePassEncoderRelease\" },\n            { reinterpret_cast<WGPUProc>(NativeComputePassEncoderSetBindGroup), \"wgpuComputePassEncoderSetBindGroup\" },\n            { reinterpret_cast<WGPUProc>(NativeComputePassEncoderSetLabel), \"wgpuComputePassEncoderSetLabel\" },\n            { reinterpret_cast<WGPUProc>(NativeComputePassEncoderSetPipeline), \"wgpuComputePassEncoderSetPipeline\" },\n            { reinterpret_cast<WGPUProc>(NativeComputePassEncoderWriteTimestamp), \"wgpuComputePassEncoderWriteTimestamp\" },\n            { reinterpret_cast<WGPUProc>(NativeComputePipelineGetBindGroupLayout), \"wgpuComputePipelineGetBindGroupLayout\" },\n            { reinterpret_cast<WGPUProc>(NativeComputePipelineReference), \"wgpuComputePipelineReference\" },\n            { reinterpret_cast<WGPUProc>(NativeComputePipelineRelease), \"wgpuComputePipelineRelease\" },\n            { reinterpret_cast<WGPUProc>(NativeComputePipelineSetLabel), \"wgpuComputePipelineSetLabel\" },\n            { reinterpret_cast<WGPUProc>(NativeDeviceCreateBindGroup), \"wgpuDeviceCreateBindGroup\" },\n            { reinterpret_cast<WGPUProc>(NativeDeviceCreateBindGroupLayout), \"wgpuDeviceCreateBindGroupLayout\" },\n            { reinterpret_cast<WGPUProc>(NativeDeviceCreateBuffer), \"wgpuDeviceCreateBuffer\" },\n            { reinterpret_cast<WGPUProc>(NativeDeviceCreateCommandEncoder), \"wgpuDeviceCreateCommandEncoder\" },\n            { reinterpret_cast<WGPUProc>(NativeDeviceCreateComputePipeline), \"wgpuDeviceCreateComputePipeline\" },\n            { reinterpret_cast<WGPUProc>(NativeDeviceCreateComputePipelineAsync), \"wgpuDeviceCreateComputePipelineAsync\" },\n            { reinterpret_cast<WGPUProc>(NativeDeviceCreateErrorBuffer), \"wgpuDeviceCreateErrorBuffer\" },\n            { reinterpret_cast<WGPUProc>(NativeDeviceCreateErrorExternalTexture), \"wgpuDeviceCreateErrorExternalTexture\" },\n            { reinterpret_cast<WGPUProc>(NativeDeviceCreateErrorShaderModule), \"wgpuDeviceCreateErrorShaderModule\" },\n            { reinterpret_cast<WGPUProc>(NativeDeviceCreateErrorTexture), \"wgpuDeviceCreateErrorTexture\" },\n            { reinterpret_cast<WGPUProc>(NativeDeviceCreateExternalTexture), \"wgpuDeviceCreateExternalTexture\" },\n            { reinterpret_cast<WGPUProc>(NativeDeviceCreatePipelineLayout), \"wgpuDeviceCreatePipelineLayout\" },\n            { reinterpret_cast<WGPUProc>(NativeDeviceCreateQuerySet), \"wgpuDeviceCreateQuerySet\" },\n            { reinterpret_cast<WGPUProc>(NativeDeviceCreateRenderBundleEncoder), \"wgpuDeviceCreateRenderBundleEncoder\" },\n            { reinterpret_cast<WGPUProc>(NativeDeviceCreateRenderPipeline), \"wgpuDeviceCreateRenderPipeline\" },\n            { reinterpret_cast<WGPUProc>(NativeDeviceCreateRenderPipelineAsync), \"wgpuDeviceCreateRenderPipelineAsync\" },\n            { reinterpret_cast<WGPUProc>(NativeDeviceCreateSampler), \"wgpuDeviceCreateSampler\" },\n            { reinterpret_cast<WGPUProc>(NativeDeviceCreateShaderModule), \"wgpuDeviceCreateShaderModule\" },\n            { reinterpret_cast<WGPUProc>(NativeDeviceCreateSwapChain), \"wgpuDeviceCreateSwapChain\" },\n            { reinterpret_cast<WGPUProc>(NativeDeviceCreateTexture), \"wgpuDeviceCreateTexture\" },\n            { reinterpret_cast<WGPUProc>(NativeDeviceDestroy), \"wgpuDeviceDestroy\" },\n            { reinterpret_cast<WGPUProc>(NativeDeviceEnumerateFeatures), \"wgpuDeviceEnumerateFeatures\" },\n            { reinterpret_cast<WGPUProc>(NativeDeviceForceLoss), \"wgpuDeviceForceLoss\" },\n            { reinterpret_cast<WGPUProc>(NativeDeviceGetAdapter), \"wgpuDeviceGetAdapter\" },\n            { reinterpret_cast<WGPUProc>(NativeDeviceGetLimits), \"wgpuDeviceGetLimits\" },\n            { reinterpret_cast<WGPUProc>(NativeDeviceGetQueue), \"wgpuDeviceGetQueue\" },\n            { reinterpret_cast<WGPUProc>(NativeDeviceGetSupportedSurfaceUsage), \"wgpuDeviceGetSupportedSurfaceUsage\" },\n            { reinterpret_cast<WGPUProc>(NativeDeviceHasFeature), \"wgpuDeviceHasFeature\" },\n            { reinterpret_cast<WGPUProc>(NativeDeviceInjectError), \"wgpuDeviceInjectError\" },\n            { reinterpret_cast<WGPUProc>(NativeDevicePopErrorScope), \"wgpuDevicePopErrorScope\" },\n            { reinterpret_cast<WGPUProc>(NativeDevicePushErrorScope), \"wgpuDevicePushErrorScope\" },\n            { reinterpret_cast<WGPUProc>(NativeDeviceReference), \"wgpuDeviceReference\" },\n            { reinterpret_cast<WGPUProc>(NativeDeviceRelease), \"wgpuDeviceRelease\" },\n            { reinterpret_cast<WGPUProc>(NativeDeviceSetDeviceLostCallback), \"wgpuDeviceSetDeviceLostCallback\" },\n            { reinterpret_cast<WGPUProc>(NativeDeviceSetLabel), \"wgpuDeviceSetLabel\" },\n            { reinterpret_cast<WGPUProc>(NativeDeviceSetLoggingCallback), \"wgpuDeviceSetLoggingCallback\" },\n            { reinterpret_cast<WGPUProc>(NativeDeviceSetUncapturedErrorCallback), \"wgpuDeviceSetUncapturedErrorCallback\" },\n            { reinterpret_cast<WGPUProc>(NativeDeviceTick), \"wgpuDeviceTick\" },\n            { reinterpret_cast<WGPUProc>(NativeDeviceValidateTextureDescriptor), \"wgpuDeviceValidateTextureDescriptor\" },\n            { reinterpret_cast<WGPUProc>(NativeExternalTextureDestroy), \"wgpuExternalTextureDestroy\" },\n            { reinterpret_cast<WGPUProc>(NativeExternalTextureExpire), \"wgpuExternalTextureExpire\" },\n            { reinterpret_cast<WGPUProc>(NativeExternalTextureReference), \"wgpuExternalTextureReference\" },\n            { reinterpret_cast<WGPUProc>(NativeExternalTextureRefresh), \"wgpuExternalTextureRefresh\" },\n            { reinterpret_cast<WGPUProc>(NativeExternalTextureRelease), \"wgpuExternalTextureRelease\" },\n            { reinterpret_cast<WGPUProc>(NativeExternalTextureSetLabel), \"wgpuExternalTextureSetLabel\" },\n            { reinterpret_cast<WGPUProc>(NativeInstanceCreateSurface), \"wgpuInstanceCreateSurface\" },\n            { reinterpret_cast<WGPUProc>(NativeInstanceProcessEvents), \"wgpuInstanceProcessEvents\" },\n            { reinterpret_cast<WGPUProc>(NativeInstanceReference), \"wgpuInstanceReference\" },\n            { reinterpret_cast<WGPUProc>(NativeInstanceRelease), \"wgpuInstanceRelease\" },\n            { reinterpret_cast<WGPUProc>(NativeInstanceRequestAdapter), \"wgpuInstanceRequestAdapter\" },\n            { reinterpret_cast<WGPUProc>(NativePipelineLayoutReference), \"wgpuPipelineLayoutReference\" },\n            { reinterpret_cast<WGPUProc>(NativePipelineLayoutRelease), \"wgpuPipelineLayoutRelease\" },\n            { reinterpret_cast<WGPUProc>(NativePipelineLayoutSetLabel), \"wgpuPipelineLayoutSetLabel\" },\n            { reinterpret_cast<WGPUProc>(NativeQuerySetDestroy), \"wgpuQuerySetDestroy\" },\n            { reinterpret_cast<WGPUProc>(NativeQuerySetGetCount), \"wgpuQuerySetGetCount\" },\n            { reinterpret_cast<WGPUProc>(NativeQuerySetGetType), \"wgpuQuerySetGetType\" },\n            { reinterpret_cast<WGPUProc>(NativeQuerySetReference), \"wgpuQuerySetReference\" },\n            { reinterpret_cast<WGPUProc>(NativeQuerySetRelease), \"wgpuQuerySetRelease\" },\n            { reinterpret_cast<WGPUProc>(NativeQuerySetSetLabel), \"wgpuQuerySetSetLabel\" },\n            { reinterpret_cast<WGPUProc>(NativeQueueCopyExternalTextureForBrowser), \"wgpuQueueCopyExternalTextureForBrowser\" },\n            { reinterpret_cast<WGPUProc>(NativeQueueCopyTextureForBrowser), \"wgpuQueueCopyTextureForBrowser\" },\n            { reinterpret_cast<WGPUProc>(NativeQueueOnSubmittedWorkDone), \"wgpuQueueOnSubmittedWorkDone\" },\n            { reinterpret_cast<WGPUProc>(NativeQueueReference), \"wgpuQueueReference\" },\n            { reinterpret_cast<WGPUProc>(NativeQueueRelease), \"wgpuQueueRelease\" },\n            { reinterpret_cast<WGPUProc>(NativeQueueSetLabel), \"wgpuQueueSetLabel\" },\n            { reinterpret_cast<WGPUProc>(NativeQueueSubmit), \"wgpuQueueSubmit\" },\n            { reinterpret_cast<WGPUProc>(NativeQueueWriteBuffer), \"wgpuQueueWriteBuffer\" },\n            { reinterpret_cast<WGPUProc>(NativeQueueWriteTexture), \"wgpuQueueWriteTexture\" },\n            { reinterpret_cast<WGPUProc>(NativeRenderBundleEncoderDraw), \"wgpuRenderBundleEncoderDraw\" },\n            { reinterpret_cast<WGPUProc>(NativeRenderBundleEncoderDrawIndexed), \"wgpuRenderBundleEncoderDrawIndexed\" },\n            { reinterpret_cast<WGPUProc>(NativeRenderBundleEncoderDrawIndexedIndirect), \"wgpuRenderBundleEncoderDrawIndexedIndirect\" },\n            { reinterpret_cast<WGPUProc>(NativeRenderBundleEncoderDrawIndirect), \"wgpuRenderBundleEncoderDrawIndirect\" },\n            { reinterpret_cast<WGPUProc>(NativeRenderBundleEncoderFinish), \"wgpuRenderBundleEncoderFinish\" },\n            { reinterpret_cast<WGPUProc>(NativeRenderBundleEncoderInsertDebugMarker), \"wgpuRenderBundleEncoderInsertDebugMarker\" },\n            { reinterpret_cast<WGPUProc>(NativeRenderBundleEncoderPopDebugGroup), \"wgpuRenderBundleEncoderPopDebugGroup\" },\n            { reinterpret_cast<WGPUProc>(NativeRenderBundleEncoderPushDebugGroup), \"wgpuRenderBundleEncoderPushDebugGroup\" },\n            { reinterpret_cast<WGPUProc>(NativeRenderBundleEncoderReference), \"wgpuRenderBundleEncoderReference\" },\n            { reinterpret_cast<WGPUProc>(NativeRenderBundleEncoderRelease), \"wgpuRenderBundleEncoderRelease\" },\n            { reinterpret_cast<WGPUProc>(NativeRenderBundleEncoderSetBindGroup), \"wgpuRenderBundleEncoderSetBindGroup\" },\n            { reinterpret_cast<WGPUProc>(NativeRenderBundleEncoderSetIndexBuffer), \"wgpuRenderBundleEncoderSetIndexBuffer\" },\n            { reinterpret_cast<WGPUProc>(NativeRenderBundleEncoderSetLabel), \"wgpuRenderBundleEncoderSetLabel\" },\n            { reinterpret_cast<WGPUProc>(NativeRenderBundleEncoderSetPipeline), \"wgpuRenderBundleEncoderSetPipeline\" },\n            { reinterpret_cast<WGPUProc>(NativeRenderBundleEncoderSetVertexBuffer), \"wgpuRenderBundleEncoderSetVertexBuffer\" },\n            { reinterpret_cast<WGPUProc>(NativeRenderBundleReference), \"wgpuRenderBundleReference\" },\n            { reinterpret_cast<WGPUProc>(NativeRenderBundleRelease), \"wgpuRenderBundleRelease\" },\n            { reinterpret_cast<WGPUProc>(NativeRenderBundleSetLabel), \"wgpuRenderBundleSetLabel\" },\n            { reinterpret_cast<WGPUProc>(NativeRenderPassEncoderBeginOcclusionQuery), \"wgpuRenderPassEncoderBeginOcclusionQuery\" },\n            { reinterpret_cast<WGPUProc>(NativeRenderPassEncoderDraw), \"wgpuRenderPassEncoderDraw\" },\n            { reinterpret_cast<WGPUProc>(NativeRenderPassEncoderDrawIndexed), \"wgpuRenderPassEncoderDrawIndexed\" },\n            { reinterpret_cast<WGPUProc>(NativeRenderPassEncoderDrawIndexedIndirect), \"wgpuRenderPassEncoderDrawIndexedIndirect\" },\n            { reinterpret_cast<WGPUProc>(NativeRenderPassEncoderDrawIndirect), \"wgpuRenderPassEncoderDrawIndirect\" },\n            { reinterpret_cast<WGPUProc>(NativeRenderPassEncoderEnd), \"wgpuRenderPassEncoderEnd\" },\n            { reinterpret_cast<WGPUProc>(NativeRenderPassEncoderEndOcclusionQuery), \"wgpuRenderPassEncoderEndOcclusionQuery\" },\n            { reinterpret_cast<WGPUProc>(NativeRenderPassEncoderExecuteBundles), \"wgpuRenderPassEncoderExecuteBundles\" },\n            { reinterpret_cast<WGPUProc>(NativeRenderPassEncoderInsertDebugMarker), \"wgpuRenderPassEncoderInsertDebugMarker\" },\n            { reinterpret_cast<WGPUProc>(NativeRenderPassEncoderPopDebugGroup), \"wgpuRenderPassEncoderPopDebugGroup\" },\n            { reinterpret_cast<WGPUProc>(NativeRenderPassEncoderPushDebugGroup), \"wgpuRenderPassEncoderPushDebugGroup\" },\n            { reinterpret_cast<WGPUProc>(NativeRenderPassEncoderReference), \"wgpuRenderPassEncoderReference\" },\n            { reinterpret_cast<WGPUProc>(NativeRenderPassEncoderRelease), \"wgpuRenderPassEncoderRelease\" },\n            { reinterpret_cast<WGPUProc>(NativeRenderPassEncoderSetBindGroup), \"wgpuRenderPassEncoderSetBindGroup\" },\n            { reinterpret_cast<WGPUProc>(NativeRenderPassEncoderSetBlendConstant), \"wgpuRenderPassEncoderSetBlendConstant\" },\n            { reinterpret_cast<WGPUProc>(NativeRenderPassEncoderSetIndexBuffer), \"wgpuRenderPassEncoderSetIndexBuffer\" },\n            { reinterpret_cast<WGPUProc>(NativeRenderPassEncoderSetLabel), \"wgpuRenderPassEncoderSetLabel\" },\n            { reinterpret_cast<WGPUProc>(NativeRenderPassEncoderSetPipeline), \"wgpuRenderPassEncoderSetPipeline\" },\n            { reinterpret_cast<WGPUProc>(NativeRenderPassEncoderSetScissorRect), \"wgpuRenderPassEncoderSetScissorRect\" },\n            { reinterpret_cast<WGPUProc>(NativeRenderPassEncoderSetStencilReference), \"wgpuRenderPassEncoderSetStencilReference\" },\n            { reinterpret_cast<WGPUProc>(NativeRenderPassEncoderSetVertexBuffer), \"wgpuRenderPassEncoderSetVertexBuffer\" },\n            { reinterpret_cast<WGPUProc>(NativeRenderPassEncoderSetViewport), \"wgpuRenderPassEncoderSetViewport\" },\n            { reinterpret_cast<WGPUProc>(NativeRenderPassEncoderWriteTimestamp), \"wgpuRenderPassEncoderWriteTimestamp\" },\n            { reinterpret_cast<WGPUProc>(NativeRenderPipelineGetBindGroupLayout), \"wgpuRenderPipelineGetBindGroupLayout\" },\n            { reinterpret_cast<WGPUProc>(NativeRenderPipelineReference), \"wgpuRenderPipelineReference\" },\n            { reinterpret_cast<WGPUProc>(NativeRenderPipelineRelease), \"wgpuRenderPipelineRelease\" },\n            { reinterpret_cast<WGPUProc>(NativeRenderPipelineSetLabel), \"wgpuRenderPipelineSetLabel\" },\n            { reinterpret_cast<WGPUProc>(NativeSamplerReference), \"wgpuSamplerReference\" },\n            { reinterpret_cast<WGPUProc>(NativeSamplerRelease), \"wgpuSamplerRelease\" },\n            { reinterpret_cast<WGPUProc>(NativeSamplerSetLabel), \"wgpuSamplerSetLabel\" },\n            { reinterpret_cast<WGPUProc>(NativeShaderModuleGetCompilationInfo), \"wgpuShaderModuleGetCompilationInfo\" },\n            { reinterpret_cast<WGPUProc>(NativeShaderModuleReference), \"wgpuShaderModuleReference\" },\n            { reinterpret_cast<WGPUProc>(NativeShaderModuleRelease), \"wgpuShaderModuleRelease\" },\n            { reinterpret_cast<WGPUProc>(NativeShaderModuleSetLabel), \"wgpuShaderModuleSetLabel\" },\n            { reinterpret_cast<WGPUProc>(NativeSurfaceReference), \"wgpuSurfaceReference\" },\n            { reinterpret_cast<WGPUProc>(NativeSurfaceRelease), \"wgpuSurfaceRelease\" },\n            { reinterpret_cast<WGPUProc>(NativeSwapChainGetCurrentTexture), \"wgpuSwapChainGetCurrentTexture\" },\n            { reinterpret_cast<WGPUProc>(NativeSwapChainGetCurrentTextureView), \"wgpuSwapChainGetCurrentTextureView\" },\n            { reinterpret_cast<WGPUProc>(NativeSwapChainPresent), \"wgpuSwapChainPresent\" },\n            { reinterpret_cast<WGPUProc>(NativeSwapChainReference), \"wgpuSwapChainReference\" },\n            { reinterpret_cast<WGPUProc>(NativeSwapChainRelease), \"wgpuSwapChainRelease\" },\n            { reinterpret_cast<WGPUProc>(NativeTextureCreateView), \"wgpuTextureCreateView\" },\n            { reinterpret_cast<WGPUProc>(NativeTextureDestroy), \"wgpuTextureDestroy\" },\n            { reinterpret_cast<WGPUProc>(NativeTextureGetDepthOrArrayLayers), \"wgpuTextureGetDepthOrArrayLayers\" },\n            { reinterpret_cast<WGPUProc>(NativeTextureGetDimension), \"wgpuTextureGetDimension\" },\n            { reinterpret_cast<WGPUProc>(NativeTextureGetFormat), \"wgpuTextureGetFormat\" },\n            { reinterpret_cast<WGPUProc>(NativeTextureGetHeight), \"wgpuTextureGetHeight\" },\n            { reinterpret_cast<WGPUProc>(NativeTextureGetMipLevelCount), \"wgpuTextureGetMipLevelCount\" },\n            { reinterpret_cast<WGPUProc>(NativeTextureGetSampleCount), \"wgpuTextureGetSampleCount\" },\n            { reinterpret_cast<WGPUProc>(NativeTextureGetUsage), \"wgpuTextureGetUsage\" },\n            { reinterpret_cast<WGPUProc>(NativeTextureGetWidth), \"wgpuTextureGetWidth\" },\n            { reinterpret_cast<WGPUProc>(NativeTextureReference), \"wgpuTextureReference\" },\n            { reinterpret_cast<WGPUProc>(NativeTextureRelease), \"wgpuTextureRelease\" },\n            { reinterpret_cast<WGPUProc>(NativeTextureSetLabel), \"wgpuTextureSetLabel\" },\n            { reinterpret_cast<WGPUProc>(NativeTextureViewReference), \"wgpuTextureViewReference\" },\n            { reinterpret_cast<WGPUProc>(NativeTextureViewRelease), \"wgpuTextureViewRelease\" },\n            { reinterpret_cast<WGPUProc>(NativeTextureViewSetLabel), \"wgpuTextureViewSetLabel\" },\n        };\n        static constexpr size_t sProcMapSize = sizeof(sProcMap) / sizeof(sProcMap[0]);\n\n    }  // anonymous namespace\n\n    WGPUProc NativeGetProcAddress(WGPUDevice, const char* procName) {\n        if (procName == nullptr) {\n            return nullptr;\n        }\n\n        const ProcEntry* entry = std::lower_bound(&sProcMap[0], &sProcMap[sProcMapSize], procName,\n            [](const ProcEntry &a, const char *b) -> bool {\n                return strcmp(a.name, b) < 0;\n            }\n        );\n\n        if (entry != &sProcMap[sProcMapSize] && strcmp(entry->name, procName) == 0) {\n            return entry->proc;\n        }\n\n        // Special case the free-standing functions of the API.\n        // TODO(dawn:1238) Checking string one by one is slow, it needs to be optimized.\n        if (strcmp(procName, \"wgpuCreateInstance\") == 0) {\n            return reinterpret_cast<WGPUProc>(NativeCreateInstance);\n        }\n\n        if (strcmp(procName, \"wgpuGetProcAddress\") == 0) {\n            return reinterpret_cast<WGPUProc>(NativeGetProcAddress);\n        }\n\n        return nullptr;\n    }\n\n    std::vector<const char*> GetProcMapNamesForTestingInternal() {\n        std::vector<const char*> result;\n        result.reserve(sProcMapSize);\n        for (const ProcEntry& entry : sProcMap) {\n            result.push_back(entry.name);\n        }\n        return result;\n    }\n\n    static DawnProcTable gProcTable = {\n        NativeCreateInstance,\n        NativeGetProcAddress,\n        NativeAdapterCreateDevice,\n        NativeAdapterEnumerateFeatures,\n        NativeAdapterGetInstance,\n        NativeAdapterGetLimits,\n        NativeAdapterGetProperties,\n        NativeAdapterHasFeature,\n        NativeAdapterRequestDevice,\n        NativeAdapterReference,\n        NativeAdapterRelease,\n        NativeBindGroupSetLabel,\n        NativeBindGroupReference,\n        NativeBindGroupRelease,\n        NativeBindGroupLayoutSetLabel,\n        NativeBindGroupLayoutReference,\n        NativeBindGroupLayoutRelease,\n        NativeBufferDestroy,\n        NativeBufferGetConstMappedRange,\n        NativeBufferGetMapState,\n        NativeBufferGetMappedRange,\n        NativeBufferGetSize,\n        NativeBufferGetUsage,\n        NativeBufferMapAsync,\n        NativeBufferSetLabel,\n        NativeBufferUnmap,\n        NativeBufferReference,\n        NativeBufferRelease,\n        NativeCommandBufferSetLabel,\n        NativeCommandBufferReference,\n        NativeCommandBufferRelease,\n        NativeCommandEncoderBeginComputePass,\n        NativeCommandEncoderBeginRenderPass,\n        NativeCommandEncoderClearBuffer,\n        NativeCommandEncoderCopyBufferToBuffer,\n        NativeCommandEncoderCopyBufferToTexture,\n        NativeCommandEncoderCopyTextureToBuffer,\n        NativeCommandEncoderCopyTextureToTexture,\n        NativeCommandEncoderCopyTextureToTextureInternal,\n        NativeCommandEncoderFinish,\n        NativeCommandEncoderInjectValidationError,\n        NativeCommandEncoderInsertDebugMarker,\n        NativeCommandEncoderPopDebugGroup,\n        NativeCommandEncoderPushDebugGroup,\n        NativeCommandEncoderResolveQuerySet,\n        NativeCommandEncoderSetLabel,\n        NativeCommandEncoderWriteBuffer,\n        NativeCommandEncoderWriteTimestamp,\n        NativeCommandEncoderReference,\n        NativeCommandEncoderRelease,\n        NativeComputePassEncoderDispatchWorkgroups,\n        NativeComputePassEncoderDispatchWorkgroupsIndirect,\n        NativeComputePassEncoderEnd,\n        NativeComputePassEncoderInsertDebugMarker,\n        NativeComputePassEncoderPopDebugGroup,\n        NativeComputePassEncoderPushDebugGroup,\n        NativeComputePassEncoderSetBindGroup,\n        NativeComputePassEncoderSetLabel,\n        NativeComputePassEncoderSetPipeline,\n        NativeComputePassEncoderWriteTimestamp,\n        NativeComputePassEncoderReference,\n        NativeComputePassEncoderRelease,\n        NativeComputePipelineGetBindGroupLayout,\n        NativeComputePipelineSetLabel,\n        NativeComputePipelineReference,\n        NativeComputePipelineRelease,\n        NativeDeviceCreateBindGroup,\n        NativeDeviceCreateBindGroupLayout,\n        NativeDeviceCreateBuffer,\n        NativeDeviceCreateCommandEncoder,\n        NativeDeviceCreateComputePipeline,\n        NativeDeviceCreateComputePipelineAsync,\n        NativeDeviceCreateErrorBuffer,\n        NativeDeviceCreateErrorExternalTexture,\n        NativeDeviceCreateErrorShaderModule,\n        NativeDeviceCreateErrorTexture,\n        NativeDeviceCreateExternalTexture,\n        NativeDeviceCreatePipelineLayout,\n        NativeDeviceCreateQuerySet,\n        NativeDeviceCreateRenderBundleEncoder,\n        NativeDeviceCreateRenderPipeline,\n        NativeDeviceCreateRenderPipelineAsync,\n        NativeDeviceCreateSampler,\n        NativeDeviceCreateShaderModule,\n        NativeDeviceCreateSwapChain,\n        NativeDeviceCreateTexture,\n        NativeDeviceDestroy,\n        NativeDeviceEnumerateFeatures,\n        NativeDeviceForceLoss,\n        NativeDeviceGetAdapter,\n        NativeDeviceGetLimits,\n        NativeDeviceGetQueue,\n        NativeDeviceGetSupportedSurfaceUsage,\n        NativeDeviceHasFeature,\n        NativeDeviceInjectError,\n        NativeDevicePopErrorScope,\n        NativeDevicePushErrorScope,\n        NativeDeviceSetDeviceLostCallback,\n        NativeDeviceSetLabel,\n        NativeDeviceSetLoggingCallback,\n        NativeDeviceSetUncapturedErrorCallback,\n        NativeDeviceTick,\n        NativeDeviceValidateTextureDescriptor,\n        NativeDeviceReference,\n        NativeDeviceRelease,\n        NativeExternalTextureDestroy,\n        NativeExternalTextureExpire,\n        NativeExternalTextureRefresh,\n        NativeExternalTextureSetLabel,\n        NativeExternalTextureReference,\n        NativeExternalTextureRelease,\n        NativeInstanceCreateSurface,\n        NativeInstanceProcessEvents,\n        NativeInstanceRequestAdapter,\n        NativeInstanceReference,\n        NativeInstanceRelease,\n        NativePipelineLayoutSetLabel,\n        NativePipelineLayoutReference,\n        NativePipelineLayoutRelease,\n        NativeQuerySetDestroy,\n        NativeQuerySetGetCount,\n        NativeQuerySetGetType,\n        NativeQuerySetSetLabel,\n        NativeQuerySetReference,\n        NativeQuerySetRelease,\n        NativeQueueCopyExternalTextureForBrowser,\n        NativeQueueCopyTextureForBrowser,\n        NativeQueueOnSubmittedWorkDone,\n        NativeQueueSetLabel,\n        NativeQueueSubmit,\n        NativeQueueWriteBuffer,\n        NativeQueueWriteTexture,\n        NativeQueueReference,\n        NativeQueueRelease,\n        NativeRenderBundleSetLabel,\n        NativeRenderBundleReference,\n        NativeRenderBundleRelease,\n        NativeRenderBundleEncoderDraw,\n        NativeRenderBundleEncoderDrawIndexed,\n        NativeRenderBundleEncoderDrawIndexedIndirect,\n        NativeRenderBundleEncoderDrawIndirect,\n        NativeRenderBundleEncoderFinish,\n        NativeRenderBundleEncoderInsertDebugMarker,\n        NativeRenderBundleEncoderPopDebugGroup,\n        NativeRenderBundleEncoderPushDebugGroup,\n        NativeRenderBundleEncoderSetBindGroup,\n        NativeRenderBundleEncoderSetIndexBuffer,\n        NativeRenderBundleEncoderSetLabel,\n        NativeRenderBundleEncoderSetPipeline,\n        NativeRenderBundleEncoderSetVertexBuffer,\n        NativeRenderBundleEncoderReference,\n        NativeRenderBundleEncoderRelease,\n        NativeRenderPassEncoderBeginOcclusionQuery,\n        NativeRenderPassEncoderDraw,\n        NativeRenderPassEncoderDrawIndexed,\n        NativeRenderPassEncoderDrawIndexedIndirect,\n        NativeRenderPassEncoderDrawIndirect,\n        NativeRenderPassEncoderEnd,\n        NativeRenderPassEncoderEndOcclusionQuery,\n        NativeRenderPassEncoderExecuteBundles,\n        NativeRenderPassEncoderInsertDebugMarker,\n        NativeRenderPassEncoderPopDebugGroup,\n        NativeRenderPassEncoderPushDebugGroup,\n        NativeRenderPassEncoderSetBindGroup,\n        NativeRenderPassEncoderSetBlendConstant,\n        NativeRenderPassEncoderSetIndexBuffer,\n        NativeRenderPassEncoderSetLabel,\n        NativeRenderPassEncoderSetPipeline,\n        NativeRenderPassEncoderSetScissorRect,\n        NativeRenderPassEncoderSetStencilReference,\n        NativeRenderPassEncoderSetVertexBuffer,\n        NativeRenderPassEncoderSetViewport,\n        NativeRenderPassEncoderWriteTimestamp,\n        NativeRenderPassEncoderReference,\n        NativeRenderPassEncoderRelease,\n        NativeRenderPipelineGetBindGroupLayout,\n        NativeRenderPipelineSetLabel,\n        NativeRenderPipelineReference,\n        NativeRenderPipelineRelease,\n        NativeSamplerSetLabel,\n        NativeSamplerReference,\n        NativeSamplerRelease,\n        NativeShaderModuleGetCompilationInfo,\n        NativeShaderModuleSetLabel,\n        NativeShaderModuleReference,\n        NativeShaderModuleRelease,\n        NativeSurfaceReference,\n        NativeSurfaceRelease,\n        NativeSwapChainGetCurrentTexture,\n        NativeSwapChainGetCurrentTextureView,\n        NativeSwapChainPresent,\n        NativeSwapChainReference,\n        NativeSwapChainRelease,\n        NativeTextureCreateView,\n        NativeTextureDestroy,\n        NativeTextureGetDepthOrArrayLayers,\n        NativeTextureGetDimension,\n        NativeTextureGetFormat,\n        NativeTextureGetHeight,\n        NativeTextureGetMipLevelCount,\n        NativeTextureGetSampleCount,\n        NativeTextureGetUsage,\n        NativeTextureGetWidth,\n        NativeTextureSetLabel,\n        NativeTextureReference,\n        NativeTextureRelease,\n        NativeTextureViewSetLabel,\n        NativeTextureViewReference,\n        NativeTextureViewRelease,\n    };\n\n    const DawnProcTable& GetProcsAutogen() {\n        return gProcTable;\n    }\n}\n", "src/dawn/native/ChainUtils_autogen.h": "// Copyright 2021 The Dawn Authors\n//\n// Licensed under the Apache License, Version 2.0 (the \"License\");\n// you may not use this file except in compliance with the License.\n// You may obtain a copy of the License at\n//\n//     http://www.apache.org/licenses/LICENSE-2.0\n//\n// Unless required by applicable law or agreed to in writing, software\n// distributed under the License is distributed on an \"AS IS\" BASIS,\n// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n// See the License for the specific language governing permissions and\n// limitations under the License.\n\n#ifndef DAWNNATIVE_CHAIN_UTILS_H_\n#define DAWNNATIVE_CHAIN_UTILS_H_\n\n#include \"dawn/native/dawn_platform.h\"\n#include \"dawn/native/Error.h\"\n\nnamespace dawn::native {\n\n    template <typename T>\n    inline wgpu::SType STypeFor;\n\n    // Specialize STypeFor to map from native struct types to their SType.\n    template <>\n    inline wgpu::SType STypeFor<SurfaceDescriptorFromMetalLayer> = wgpu::SType::SurfaceDescriptorFromMetalLayer;\n    template <>\n    inline wgpu::SType STypeFor<SurfaceDescriptorFromWindowsHWND> = wgpu::SType::SurfaceDescriptorFromWindowsHWND;\n    template <>\n    inline wgpu::SType STypeFor<SurfaceDescriptorFromXlibWindow> = wgpu::SType::SurfaceDescriptorFromXlibWindow;\n    template <>\n    inline wgpu::SType STypeFor<SurfaceDescriptorFromCanvasHTMLSelector> = wgpu::SType::SurfaceDescriptorFromCanvasHTMLSelector;\n    template <>\n    inline wgpu::SType STypeFor<ShaderModuleSPIRVDescriptor> = wgpu::SType::ShaderModuleSPIRVDescriptor;\n    template <>\n    inline wgpu::SType STypeFor<ShaderModuleWGSLDescriptor> = wgpu::SType::ShaderModuleWGSLDescriptor;\n    template <>\n    inline wgpu::SType STypeFor<PrimitiveDepthClipControl> = wgpu::SType::PrimitiveDepthClipControl;\n    template <>\n    inline wgpu::SType STypeFor<SurfaceDescriptorFromWaylandSurface> = wgpu::SType::SurfaceDescriptorFromWaylandSurface;\n    template <>\n    inline wgpu::SType STypeFor<SurfaceDescriptorFromAndroidNativeWindow> = wgpu::SType::SurfaceDescriptorFromAndroidNativeWindow;\n    template <>\n    inline wgpu::SType STypeFor<SurfaceDescriptorFromWindowsCoreWindow> = wgpu::SType::SurfaceDescriptorFromWindowsCoreWindow;\n    template <>\n    inline wgpu::SType STypeFor<ExternalTextureBindingEntry> = wgpu::SType::ExternalTextureBindingEntry;\n    template <>\n    inline wgpu::SType STypeFor<ExternalTextureBindingLayout> = wgpu::SType::ExternalTextureBindingLayout;\n    template <>\n    inline wgpu::SType STypeFor<SurfaceDescriptorFromWindowsSwapChainPanel> = wgpu::SType::SurfaceDescriptorFromWindowsSwapChainPanel;\n    template <>\n    inline wgpu::SType STypeFor<RenderPassDescriptorMaxDrawCount> = wgpu::SType::RenderPassDescriptorMaxDrawCount;\n    template <>\n    inline wgpu::SType STypeFor<DawnTextureInternalUsageDescriptor> = wgpu::SType::DawnTextureInternalUsageDescriptor;\n    template <>\n    inline wgpu::SType STypeFor<DawnEncoderInternalUsageDescriptor> = wgpu::SType::DawnEncoderInternalUsageDescriptor;\n    template <>\n    inline wgpu::SType STypeFor<DawnCacheDeviceDescriptor> = wgpu::SType::DawnCacheDeviceDescriptor;\n    template <>\n    inline wgpu::SType STypeFor<DawnAdapterPropertiesPowerPreference> = wgpu::SType::DawnAdapterPropertiesPowerPreference;\n    template <>\n    inline wgpu::SType STypeFor<DawnBufferDescriptorErrorInfoFromWireClient> = wgpu::SType::DawnBufferDescriptorErrorInfoFromWireClient;\n    template <>\n    inline wgpu::SType STypeFor<DawnTogglesDescriptor> = wgpu::SType::DawnTogglesDescriptor;\n    template <>\n    inline wgpu::SType STypeFor<DawnShaderModuleSPIRVOptionsDescriptor> = wgpu::SType::DawnShaderModuleSPIRVOptionsDescriptor;\n    template <>\n    inline wgpu::SType STypeFor<DawnMultisampleStateRenderToSingleSampled> = wgpu::SType::DawnMultisampleStateRenderToSingleSampled;\n    template <>\n    inline wgpu::SType STypeFor<DawnRenderPassColorAttachmentRenderToSingleSampled> = wgpu::SType::DawnRenderPassColorAttachmentRenderToSingleSampled;\n\n    template <typename T>\n    void FindInChain(const ChainedStruct* chain, const T** out) {\n        for (; chain; chain = chain->nextInChain) {\n            if (chain->sType == STypeFor<T>) {\n                *out = static_cast<const T*>(chain);\n                break;\n            }\n        }\n    }\n    template <typename T>\n    void FindInChain(ChainedStructOut* chain, T** out) {\n        for (; chain; chain = chain->nextInChain) {\n            if (chain->sType == STypeFor<T>) {\n                *out = static_cast<T*>(chain);\n                break;\n            }\n        }\n    }\n\n    // Verifies that |chain| only contains ChainedStructs of types enumerated in\n    // |oneOfConstraints| and contains no duplicate sTypes. Each vector in\n    // |oneOfConstraints| defines a set of sTypes that cannot coexist in the same chain.\n    // For example:\n    //   ValidateSTypes(chain, { { ShaderModuleSPIRVDescriptor, ShaderModuleWGSLDescriptor } }))\n    //   ValidateSTypes(chain, { { Extension1 }, { Extension2 } })\n    MaybeError ValidateSTypes(const ChainedStruct* chain,\n                              std::vector<std::vector<wgpu::SType>> oneOfConstraints);\n    MaybeError ValidateSTypes(const ChainedStructOut* chain,\n                              std::vector<std::vector<wgpu::SType>> oneOfConstraints);\n\n    template <typename T>\n    MaybeError ValidateSingleSTypeInner(const ChainedStruct* chain, T sType) {\n        DAWN_INVALID_IF(chain->sType != sType,\n            \"Unsupported sType (%s). Expected (%s)\", chain->sType, sType);\n        return {};\n    }\n    template <typename T>\n    MaybeError ValidateSingleSTypeInner(const ChainedStructOut* chain, T sType) {\n        DAWN_INVALID_IF(chain->sType != sType,\n            \"Unsupported sType (%s). Expected (%s)\", chain->sType, sType);\n        return {};\n    }\n\n    template <typename T, typename... Args>\n    MaybeError ValidateSingleSTypeInner(const ChainedStruct* chain, T sType, Args... sTypes) {\n        if (chain->sType == sType) {\n            return {};\n        }\n        return ValidateSingleSTypeInner(chain, sTypes...);\n    }\n    template <typename T, typename... Args>\n    MaybeError ValidateSingleSTypeInner(const ChainedStructOut* chain, T sType, Args... sTypes) {\n        if (chain->sType == sType) {\n            return {};\n        }\n        return ValidateSingleSTypeInner(chain, sTypes...);\n    }\n\n    // Verifies that |chain| contains a single ChainedStruct of type |sType| or no ChainedStructs\n    // at all.\n    template <typename T>\n    MaybeError ValidateSingleSType(const ChainedStruct* chain, T sType) {\n        if (chain == nullptr) {\n            return {};\n        }\n        DAWN_INVALID_IF(chain->nextInChain != nullptr,\n            \"Chain can only contain a single chained struct.\");\n        return ValidateSingleSTypeInner(chain, sType);\n    }\n    template <typename T>\n    MaybeError ValidateSingleSType(const ChainedStructOut* chain, T sType) {\n        if (chain == nullptr) {\n            return {};\n        }\n        DAWN_INVALID_IF(chain->nextInChain != nullptr,\n            \"Chain can only contain a single chained struct.\");\n        return ValidateSingleSTypeInner(chain, sType);\n    }\n\n    // Verifies that |chain| contains a single ChainedStruct with a type enumerated in the\n    // parameter pack or no ChainedStructs at all.\n    template <typename T, typename... Args>\n    MaybeError ValidateSingleSType(const ChainedStruct* chain, T sType, Args... sTypes) {\n        if (chain == nullptr) {\n            return {};\n        }\n        DAWN_INVALID_IF(chain->nextInChain != nullptr,\n            \"Chain can only contain a single chained struct.\");\n        return ValidateSingleSTypeInner(chain, sType, sTypes...);\n    }\n    template <typename T, typename... Args>\n    MaybeError ValidateSingleSType(const ChainedStructOut* chain, T sType, Args... sTypes) {\n        if (chain == nullptr) {\n            return {};\n        }\n        DAWN_INVALID_IF(chain->nextInChain != nullptr,\n            \"Chain can only contain a single chained struct.\");\n        return ValidateSingleSTypeInner(chain, sType, sTypes...);\n    }\n\n}  // namespace dawn::native\n\n#endif  // DAWNNATIVE_CHAIN_UTILS_H_\n", "src/dawn/native/ChainUtils_autogen.cpp": "// Copyright 2021 The Dawn Authors\n//\n// Licensed under the Apache License, Version 2.0 (the \"License\");\n// you may not use this file except in compliance with the License.\n// You may obtain a copy of the License at\n//\n//     http://www.apache.org/licenses/LICENSE-2.0\n//\n// Unless required by applicable law or agreed to in writing, software\n// distributed under the License is distributed on an \"AS IS\" BASIS,\n// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n// See the License for the specific language governing permissions and\n// limitations under the License.\n\n#include \"dawn/native/ChainUtils_autogen.h\"\n\n#include <unordered_set>\n\nnamespace dawn::native {\n\nMaybeError ValidateSTypes(const ChainedStruct* chain,\n                          std::vector<std::vector<wgpu::SType>> oneOfConstraints) {\n    std::unordered_set<wgpu::SType> allSTypes;\n    for (; chain; chain = chain->nextInChain) {\n        DAWN_INVALID_IF(allSTypes.find(chain->sType) != allSTypes.end(),\n            \"Extension chain has duplicate sType %s.\", chain->sType);\n        allSTypes.insert(chain->sType);\n    }\n\n    for (const auto& oneOfConstraint : oneOfConstraints) {\n        bool satisfied = false;\n        for (wgpu::SType oneOfSType : oneOfConstraint) {\n            if (allSTypes.find(oneOfSType) != allSTypes.end()) {\n                DAWN_INVALID_IF(satisfied,\n                    \"sType %s is part of a group of exclusive sTypes that is already present.\",\n                    oneOfSType);\n                satisfied = true;\n                allSTypes.erase(oneOfSType);\n            }\n        }\n    }\n\n    DAWN_INVALID_IF(!allSTypes.empty(), \"Unsupported sType %s.\", *allSTypes.begin());\n    return {};\n}\n\nMaybeError ValidateSTypes(const ChainedStructOut* chain,\n                          std::vector<std::vector<wgpu::SType>> oneOfConstraints) {\n    std::unordered_set<wgpu::SType> allSTypes;\n    for (; chain; chain = chain->nextInChain) {\n        DAWN_INVALID_IF(allSTypes.find(chain->sType) != allSTypes.end(),\n            \"Extension chain has duplicate sType %s.\", chain->sType);\n        allSTypes.insert(chain->sType);\n    }\n\n    for (const auto& oneOfConstraint : oneOfConstraints) {\n        bool satisfied = false;\n        for (wgpu::SType oneOfSType : oneOfConstraint) {\n            if (allSTypes.find(oneOfSType) != allSTypes.end()) {\n                DAWN_INVALID_IF(satisfied,\n                    \"sType %s is part of a group of exclusive sTypes that is already present.\",\n                    oneOfSType);\n                satisfied = true;\n                allSTypes.erase(oneOfSType);\n            }\n        }\n    }\n\n    DAWN_INVALID_IF(!allSTypes.empty(), \"Unsupported sType %s.\", *allSTypes.begin());\n    return {};\n}\n\n}  // namespace dawn::native\n", "src/dawn/native/webgpu_absl_format_autogen.h": "\n#ifndef WEBGPU_ABSL_FORMAT_H_\n#define WEBGPU_ABSL_FORMAT_H_\n\n#include \"dawn/native/dawn_platform.h\"\n\n#include \"absl/strings/str_format.h\"\n\nnamespace dawn::native {\n\n    //\n    // Descriptors\n    //\n\n    // Only includes structures that have a 'label' member.\n    absl::FormatConvertResult<absl::FormatConversionCharSet::kString>\n        AbslFormatConvert(const BufferDescriptor* value,\n                          const absl::FormatConversionSpec& spec,\n                          absl::FormatSink* s);\n    absl::FormatConvertResult<absl::FormatConversionCharSet::kString>\n        AbslFormatConvert(const CommandBufferDescriptor* value,\n                          const absl::FormatConversionSpec& spec,\n                          absl::FormatSink* s);\n    absl::FormatConvertResult<absl::FormatConversionCharSet::kString>\n        AbslFormatConvert(const CommandEncoderDescriptor* value,\n                          const absl::FormatConversionSpec& spec,\n                          absl::FormatSink* s);\n    absl::FormatConvertResult<absl::FormatConversionCharSet::kString>\n        AbslFormatConvert(const PipelineLayoutDescriptor* value,\n                          const absl::FormatConversionSpec& spec,\n                          absl::FormatSink* s);\n    absl::FormatConvertResult<absl::FormatConversionCharSet::kString>\n        AbslFormatConvert(const QuerySetDescriptor* value,\n                          const absl::FormatConversionSpec& spec,\n                          absl::FormatSink* s);\n    absl::FormatConvertResult<absl::FormatConversionCharSet::kString>\n        AbslFormatConvert(const QueueDescriptor* value,\n                          const absl::FormatConversionSpec& spec,\n                          absl::FormatSink* s);\n    absl::FormatConvertResult<absl::FormatConversionCharSet::kString>\n        AbslFormatConvert(const RenderBundleDescriptor* value,\n                          const absl::FormatConversionSpec& spec,\n                          absl::FormatSink* s);\n    absl::FormatConvertResult<absl::FormatConversionCharSet::kString>\n        AbslFormatConvert(const RenderBundleEncoderDescriptor* value,\n                          const absl::FormatConversionSpec& spec,\n                          absl::FormatSink* s);\n    absl::FormatConvertResult<absl::FormatConversionCharSet::kString>\n        AbslFormatConvert(const SamplerDescriptor* value,\n                          const absl::FormatConversionSpec& spec,\n                          absl::FormatSink* s);\n    absl::FormatConvertResult<absl::FormatConversionCharSet::kString>\n        AbslFormatConvert(const ShaderModuleDescriptor* value,\n                          const absl::FormatConversionSpec& spec,\n                          absl::FormatSink* s);\n    absl::FormatConvertResult<absl::FormatConversionCharSet::kString>\n        AbslFormatConvert(const SurfaceDescriptor* value,\n                          const absl::FormatConversionSpec& spec,\n                          absl::FormatSink* s);\n    absl::FormatConvertResult<absl::FormatConversionCharSet::kString>\n        AbslFormatConvert(const SwapChainDescriptor* value,\n                          const absl::FormatConversionSpec& spec,\n                          absl::FormatSink* s);\n    absl::FormatConvertResult<absl::FormatConversionCharSet::kString>\n        AbslFormatConvert(const TextureViewDescriptor* value,\n                          const absl::FormatConversionSpec& spec,\n                          absl::FormatSink* s);\n    absl::FormatConvertResult<absl::FormatConversionCharSet::kString>\n        AbslFormatConvert(const BindGroupDescriptor* value,\n                          const absl::FormatConversionSpec& spec,\n                          absl::FormatSink* s);\n    absl::FormatConvertResult<absl::FormatConversionCharSet::kString>\n        AbslFormatConvert(const ComputePassDescriptor* value,\n                          const absl::FormatConversionSpec& spec,\n                          absl::FormatSink* s);\n    absl::FormatConvertResult<absl::FormatConversionCharSet::kString>\n        AbslFormatConvert(const ExternalTextureDescriptor* value,\n                          const absl::FormatConversionSpec& spec,\n                          absl::FormatSink* s);\n    absl::FormatConvertResult<absl::FormatConversionCharSet::kString>\n        AbslFormatConvert(const TextureDescriptor* value,\n                          const absl::FormatConversionSpec& spec,\n                          absl::FormatSink* s);\n    absl::FormatConvertResult<absl::FormatConversionCharSet::kString>\n        AbslFormatConvert(const BindGroupLayoutDescriptor* value,\n                          const absl::FormatConversionSpec& spec,\n                          absl::FormatSink* s);\n    absl::FormatConvertResult<absl::FormatConversionCharSet::kString>\n        AbslFormatConvert(const ComputePipelineDescriptor* value,\n                          const absl::FormatConversionSpec& spec,\n                          absl::FormatSink* s);\n    absl::FormatConvertResult<absl::FormatConversionCharSet::kString>\n        AbslFormatConvert(const DeviceDescriptor* value,\n                          const absl::FormatConversionSpec& spec,\n                          absl::FormatSink* s);\n    absl::FormatConvertResult<absl::FormatConversionCharSet::kString>\n        AbslFormatConvert(const RenderPassDescriptor* value,\n                          const absl::FormatConversionSpec& spec,\n                          absl::FormatSink* s);\n    absl::FormatConvertResult<absl::FormatConversionCharSet::kString>\n        AbslFormatConvert(const RenderPipelineDescriptor* value,\n                          const absl::FormatConversionSpec& spec,\n                          absl::FormatSink* s);\n\n    //\n    // Compatible with absl::StrFormat (Needs to be disjoint from having a 'label' for now.)\n    // Currently uses a hard-coded list to determine which structures are actually supported. If\n    // additional structures are added, be sure to update the cpp file's list as well.\n    //\n    absl::FormatConvertResult<absl::FormatConversionCharSet::kString>\n        AbslFormatConvert(const BufferBindingLayout& value,\n                          const absl::FormatConversionSpec& spec,\n                          absl::FormatSink* s);\n    absl::FormatConvertResult<absl::FormatConversionCharSet::kString>\n        AbslFormatConvert(const SamplerBindingLayout& value,\n                          const absl::FormatConversionSpec& spec,\n                          absl::FormatSink* s);\n    absl::FormatConvertResult<absl::FormatConversionCharSet::kString>\n        AbslFormatConvert(const StorageTextureBindingLayout& value,\n                          const absl::FormatConversionSpec& spec,\n                          absl::FormatSink* s);\n    absl::FormatConvertResult<absl::FormatConversionCharSet::kString>\n        AbslFormatConvert(const TextureBindingLayout& value,\n                          const absl::FormatConversionSpec& spec,\n                          absl::FormatSink* s);\n\n} // namespace dawn::native\n\nnamespace wgpu {\n\n    //\n    // Enums\n    //\n\n        absl::FormatConvertResult<absl::FormatConversionCharSet::kString|absl::FormatConversionCharSet::kIntegral>\n        AbslFormatConvert(AdapterType value,\n                          const absl::FormatConversionSpec& spec,\n                          absl::FormatSink* s);\n        absl::FormatConvertResult<absl::FormatConversionCharSet::kString|absl::FormatConversionCharSet::kIntegral>\n        AbslFormatConvert(AddressMode value,\n                          const absl::FormatConversionSpec& spec,\n                          absl::FormatSink* s);\n        absl::FormatConvertResult<absl::FormatConversionCharSet::kString|absl::FormatConversionCharSet::kIntegral>\n        AbslFormatConvert(AlphaMode value,\n                          const absl::FormatConversionSpec& spec,\n                          absl::FormatSink* s);\n        absl::FormatConvertResult<absl::FormatConversionCharSet::kString|absl::FormatConversionCharSet::kIntegral>\n        AbslFormatConvert(BackendType value,\n                          const absl::FormatConversionSpec& spec,\n                          absl::FormatSink* s);\n        absl::FormatConvertResult<absl::FormatConversionCharSet::kString|absl::FormatConversionCharSet::kIntegral>\n        AbslFormatConvert(BlendFactor value,\n                          const absl::FormatConversionSpec& spec,\n                          absl::FormatSink* s);\n        absl::FormatConvertResult<absl::FormatConversionCharSet::kString|absl::FormatConversionCharSet::kIntegral>\n        AbslFormatConvert(BlendOperation value,\n                          const absl::FormatConversionSpec& spec,\n                          absl::FormatSink* s);\n        absl::FormatConvertResult<absl::FormatConversionCharSet::kString|absl::FormatConversionCharSet::kIntegral>\n        AbslFormatConvert(BufferBindingType value,\n                          const absl::FormatConversionSpec& spec,\n                          absl::FormatSink* s);\n        absl::FormatConvertResult<absl::FormatConversionCharSet::kString|absl::FormatConversionCharSet::kIntegral>\n        AbslFormatConvert(BufferMapAsyncStatus value,\n                          const absl::FormatConversionSpec& spec,\n                          absl::FormatSink* s);\n        absl::FormatConvertResult<absl::FormatConversionCharSet::kString|absl::FormatConversionCharSet::kIntegral>\n        AbslFormatConvert(BufferMapState value,\n                          const absl::FormatConversionSpec& spec,\n                          absl::FormatSink* s);\n        absl::FormatConvertResult<absl::FormatConversionCharSet::kString|absl::FormatConversionCharSet::kIntegral>\n        AbslFormatConvert(CompareFunction value,\n                          const absl::FormatConversionSpec& spec,\n                          absl::FormatSink* s);\n        absl::FormatConvertResult<absl::FormatConversionCharSet::kString|absl::FormatConversionCharSet::kIntegral>\n        AbslFormatConvert(CompilationInfoRequestStatus value,\n                          const absl::FormatConversionSpec& spec,\n                          absl::FormatSink* s);\n        absl::FormatConvertResult<absl::FormatConversionCharSet::kString|absl::FormatConversionCharSet::kIntegral>\n        AbslFormatConvert(CompilationMessageType value,\n                          const absl::FormatConversionSpec& spec,\n                          absl::FormatSink* s);\n        absl::FormatConvertResult<absl::FormatConversionCharSet::kString|absl::FormatConversionCharSet::kIntegral>\n        AbslFormatConvert(ComputePassTimestampLocation value,\n                          const absl::FormatConversionSpec& spec,\n                          absl::FormatSink* s);\n        absl::FormatConvertResult<absl::FormatConversionCharSet::kString|absl::FormatConversionCharSet::kIntegral>\n        AbslFormatConvert(CreatePipelineAsyncStatus value,\n                          const absl::FormatConversionSpec& spec,\n                          absl::FormatSink* s);\n        absl::FormatConvertResult<absl::FormatConversionCharSet::kString|absl::FormatConversionCharSet::kIntegral>\n        AbslFormatConvert(CullMode value,\n                          const absl::FormatConversionSpec& spec,\n                          absl::FormatSink* s);\n        absl::FormatConvertResult<absl::FormatConversionCharSet::kString|absl::FormatConversionCharSet::kIntegral>\n        AbslFormatConvert(DeviceLostReason value,\n                          const absl::FormatConversionSpec& spec,\n                          absl::FormatSink* s);\n        absl::FormatConvertResult<absl::FormatConversionCharSet::kString|absl::FormatConversionCharSet::kIntegral>\n        AbslFormatConvert(ErrorFilter value,\n                          const absl::FormatConversionSpec& spec,\n                          absl::FormatSink* s);\n        absl::FormatConvertResult<absl::FormatConversionCharSet::kString|absl::FormatConversionCharSet::kIntegral>\n        AbslFormatConvert(ErrorType value,\n                          const absl::FormatConversionSpec& spec,\n                          absl::FormatSink* s);\n        absl::FormatConvertResult<absl::FormatConversionCharSet::kString|absl::FormatConversionCharSet::kIntegral>\n        AbslFormatConvert(ExternalTextureRotation value,\n                          const absl::FormatConversionSpec& spec,\n                          absl::FormatSink* s);\n        absl::FormatConvertResult<absl::FormatConversionCharSet::kString|absl::FormatConversionCharSet::kIntegral>\n        AbslFormatConvert(FeatureName value,\n                          const absl::FormatConversionSpec& spec,\n                          absl::FormatSink* s);\n        absl::FormatConvertResult<absl::FormatConversionCharSet::kString|absl::FormatConversionCharSet::kIntegral>\n        AbslFormatConvert(FilterMode value,\n                          const absl::FormatConversionSpec& spec,\n                          absl::FormatSink* s);\n        absl::FormatConvertResult<absl::FormatConversionCharSet::kString|absl::FormatConversionCharSet::kIntegral>\n        AbslFormatConvert(FrontFace value,\n                          const absl::FormatConversionSpec& spec,\n                          absl::FormatSink* s);\n        absl::FormatConvertResult<absl::FormatConversionCharSet::kString|absl::FormatConversionCharSet::kIntegral>\n        AbslFormatConvert(IndexFormat value,\n                          const absl::FormatConversionSpec& spec,\n                          absl::FormatSink* s);\n        absl::FormatConvertResult<absl::FormatConversionCharSet::kString|absl::FormatConversionCharSet::kIntegral>\n        AbslFormatConvert(LoadOp value,\n                          const absl::FormatConversionSpec& spec,\n                          absl::FormatSink* s);\n        absl::FormatConvertResult<absl::FormatConversionCharSet::kString|absl::FormatConversionCharSet::kIntegral>\n        AbslFormatConvert(LoggingType value,\n                          const absl::FormatConversionSpec& spec,\n                          absl::FormatSink* s);\n        absl::FormatConvertResult<absl::FormatConversionCharSet::kString|absl::FormatConversionCharSet::kIntegral>\n        AbslFormatConvert(MipmapFilterMode value,\n                          const absl::FormatConversionSpec& spec,\n                          absl::FormatSink* s);\n        absl::FormatConvertResult<absl::FormatConversionCharSet::kString|absl::FormatConversionCharSet::kIntegral>\n        AbslFormatConvert(PipelineStatisticName value,\n                          const absl::FormatConversionSpec& spec,\n                          absl::FormatSink* s);\n        absl::FormatConvertResult<absl::FormatConversionCharSet::kString|absl::FormatConversionCharSet::kIntegral>\n        AbslFormatConvert(PowerPreference value,\n                          const absl::FormatConversionSpec& spec,\n                          absl::FormatSink* s);\n        absl::FormatConvertResult<absl::FormatConversionCharSet::kString|absl::FormatConversionCharSet::kIntegral>\n        AbslFormatConvert(PresentMode value,\n                          const absl::FormatConversionSpec& spec,\n                          absl::FormatSink* s);\n        absl::FormatConvertResult<absl::FormatConversionCharSet::kString|absl::FormatConversionCharSet::kIntegral>\n        AbslFormatConvert(PrimitiveTopology value,\n                          const absl::FormatConversionSpec& spec,\n                          absl::FormatSink* s);\n        absl::FormatConvertResult<absl::FormatConversionCharSet::kString|absl::FormatConversionCharSet::kIntegral>\n        AbslFormatConvert(QueryType value,\n                          const absl::FormatConversionSpec& spec,\n                          absl::FormatSink* s);\n        absl::FormatConvertResult<absl::FormatConversionCharSet::kString|absl::FormatConversionCharSet::kIntegral>\n        AbslFormatConvert(QueueWorkDoneStatus value,\n                          const absl::FormatConversionSpec& spec,\n                          absl::FormatSink* s);\n        absl::FormatConvertResult<absl::FormatConversionCharSet::kString|absl::FormatConversionCharSet::kIntegral>\n        AbslFormatConvert(RenderPassTimestampLocation value,\n                          const absl::FormatConversionSpec& spec,\n                          absl::FormatSink* s);\n        absl::FormatConvertResult<absl::FormatConversionCharSet::kString|absl::FormatConversionCharSet::kIntegral>\n        AbslFormatConvert(RequestAdapterStatus value,\n                          const absl::FormatConversionSpec& spec,\n                          absl::FormatSink* s);\n        absl::FormatConvertResult<absl::FormatConversionCharSet::kString|absl::FormatConversionCharSet::kIntegral>\n        AbslFormatConvert(RequestDeviceStatus value,\n                          const absl::FormatConversionSpec& spec,\n                          absl::FormatSink* s);\n        absl::FormatConvertResult<absl::FormatConversionCharSet::kString|absl::FormatConversionCharSet::kIntegral>\n        AbslFormatConvert(SType value,\n                          const absl::FormatConversionSpec& spec,\n                          absl::FormatSink* s);\n        absl::FormatConvertResult<absl::FormatConversionCharSet::kString|absl::FormatConversionCharSet::kIntegral>\n        AbslFormatConvert(SamplerBindingType value,\n                          const absl::FormatConversionSpec& spec,\n                          absl::FormatSink* s);\n        absl::FormatConvertResult<absl::FormatConversionCharSet::kString|absl::FormatConversionCharSet::kIntegral>\n        AbslFormatConvert(StencilOperation value,\n                          const absl::FormatConversionSpec& spec,\n                          absl::FormatSink* s);\n        absl::FormatConvertResult<absl::FormatConversionCharSet::kString|absl::FormatConversionCharSet::kIntegral>\n        AbslFormatConvert(StorageTextureAccess value,\n                          const absl::FormatConversionSpec& spec,\n                          absl::FormatSink* s);\n        absl::FormatConvertResult<absl::FormatConversionCharSet::kString|absl::FormatConversionCharSet::kIntegral>\n        AbslFormatConvert(StoreOp value,\n                          const absl::FormatConversionSpec& spec,\n                          absl::FormatSink* s);\n        absl::FormatConvertResult<absl::FormatConversionCharSet::kString|absl::FormatConversionCharSet::kIntegral>\n        AbslFormatConvert(TextureAspect value,\n                          const absl::FormatConversionSpec& spec,\n                          absl::FormatSink* s);\n        absl::FormatConvertResult<absl::FormatConversionCharSet::kString|absl::FormatConversionCharSet::kIntegral>\n        AbslFormatConvert(TextureDimension value,\n                          const absl::FormatConversionSpec& spec,\n                          absl::FormatSink* s);\n        absl::FormatConvertResult<absl::FormatConversionCharSet::kString|absl::FormatConversionCharSet::kIntegral>\n        AbslFormatConvert(TextureFormat value,\n                          const absl::FormatConversionSpec& spec,\n                          absl::FormatSink* s);\n        absl::FormatConvertResult<absl::FormatConversionCharSet::kString|absl::FormatConversionCharSet::kIntegral>\n        AbslFormatConvert(TextureSampleType value,\n                          const absl::FormatConversionSpec& spec,\n                          absl::FormatSink* s);\n        absl::FormatConvertResult<absl::FormatConversionCharSet::kString|absl::FormatConversionCharSet::kIntegral>\n        AbslFormatConvert(TextureViewDimension value,\n                          const absl::FormatConversionSpec& spec,\n                          absl::FormatSink* s);\n        absl::FormatConvertResult<absl::FormatConversionCharSet::kString|absl::FormatConversionCharSet::kIntegral>\n        AbslFormatConvert(VertexFormat value,\n                          const absl::FormatConversionSpec& spec,\n                          absl::FormatSink* s);\n        absl::FormatConvertResult<absl::FormatConversionCharSet::kString|absl::FormatConversionCharSet::kIntegral>\n        AbslFormatConvert(VertexStepMode value,\n                          const absl::FormatConversionSpec& spec,\n                          absl::FormatSink* s);\n\n    //\n    // Bitmasks\n    //\n\n        absl::FormatConvertResult<absl::FormatConversionCharSet::kString|absl::FormatConversionCharSet::kIntegral>\n        AbslFormatConvert(BufferUsage value,\n                          const absl::FormatConversionSpec& spec,\n                          absl::FormatSink* s);\n        absl::FormatConvertResult<absl::FormatConversionCharSet::kString|absl::FormatConversionCharSet::kIntegral>\n        AbslFormatConvert(ColorWriteMask value,\n                          const absl::FormatConversionSpec& spec,\n                          absl::FormatSink* s);\n        absl::FormatConvertResult<absl::FormatConversionCharSet::kString|absl::FormatConversionCharSet::kIntegral>\n        AbslFormatConvert(MapMode value,\n                          const absl::FormatConversionSpec& spec,\n                          absl::FormatSink* s);\n        absl::FormatConvertResult<absl::FormatConversionCharSet::kString|absl::FormatConversionCharSet::kIntegral>\n        AbslFormatConvert(ShaderStage value,\n                          const absl::FormatConversionSpec& spec,\n                          absl::FormatSink* s);\n        absl::FormatConvertResult<absl::FormatConversionCharSet::kString|absl::FormatConversionCharSet::kIntegral>\n        AbslFormatConvert(TextureUsage value,\n                          const absl::FormatConversionSpec& spec,\n                          absl::FormatSink* s);\n\n}  // namespace wgpu\n\n#endif // WEBGPU_ABSL_FORMAT_H_\n", "src/dawn/native/webgpu_absl_format_autogen.cpp": "\n#include \"dawn/native/webgpu_absl_format_autogen.h\"\n\n#include \"dawn/native/ObjectType_autogen.h\"\n\nnamespace dawn::native {\n\n    //\n    // Descriptors\n    //\n\n    absl::FormatConvertResult<absl::FormatConversionCharSet::kString>\n    AbslFormatConvert(const BufferDescriptor* value,\n                        const absl::FormatConversionSpec& spec,\n                        absl::FormatSink* s) {\n        if (value == nullptr) {\n            s->Append(\"[null]\");\n            return {true};\n        }\n        s->Append(\"[BufferDescriptor\");\n        if (value->label != nullptr) {\n            s->Append(absl::StrFormat(\" \\\"%s\\\"\", value->label));\n        }\n        s->Append(\"]\");\n        return {true};\n    }\n    absl::FormatConvertResult<absl::FormatConversionCharSet::kString>\n    AbslFormatConvert(const CommandBufferDescriptor* value,\n                        const absl::FormatConversionSpec& spec,\n                        absl::FormatSink* s) {\n        if (value == nullptr) {\n            s->Append(\"[null]\");\n            return {true};\n        }\n        s->Append(\"[CommandBufferDescriptor\");\n        if (value->label != nullptr) {\n            s->Append(absl::StrFormat(\" \\\"%s\\\"\", value->label));\n        }\n        s->Append(\"]\");\n        return {true};\n    }\n    absl::FormatConvertResult<absl::FormatConversionCharSet::kString>\n    AbslFormatConvert(const CommandEncoderDescriptor* value,\n                        const absl::FormatConversionSpec& spec,\n                        absl::FormatSink* s) {\n        if (value == nullptr) {\n            s->Append(\"[null]\");\n            return {true};\n        }\n        s->Append(\"[CommandEncoderDescriptor\");\n        if (value->label != nullptr) {\n            s->Append(absl::StrFormat(\" \\\"%s\\\"\", value->label));\n        }\n        s->Append(\"]\");\n        return {true};\n    }\n    absl::FormatConvertResult<absl::FormatConversionCharSet::kString>\n    AbslFormatConvert(const PipelineLayoutDescriptor* value,\n                        const absl::FormatConversionSpec& spec,\n                        absl::FormatSink* s) {\n        if (value == nullptr) {\n            s->Append(\"[null]\");\n            return {true};\n        }\n        s->Append(\"[PipelineLayoutDescriptor\");\n        if (value->label != nullptr) {\n            s->Append(absl::StrFormat(\" \\\"%s\\\"\", value->label));\n        }\n        s->Append(\"]\");\n        return {true};\n    }\n    absl::FormatConvertResult<absl::FormatConversionCharSet::kString>\n    AbslFormatConvert(const QuerySetDescriptor* value,\n                        const absl::FormatConversionSpec& spec,\n                        absl::FormatSink* s) {\n        if (value == nullptr) {\n            s->Append(\"[null]\");\n            return {true};\n        }\n        s->Append(\"[QuerySetDescriptor\");\n        if (value->label != nullptr) {\n            s->Append(absl::StrFormat(\" \\\"%s\\\"\", value->label));\n        }\n        s->Append(\"]\");\n        return {true};\n    }\n    absl::FormatConvertResult<absl::FormatConversionCharSet::kString>\n    AbslFormatConvert(const QueueDescriptor* value,\n                        const absl::FormatConversionSpec& spec,\n                        absl::FormatSink* s) {\n        if (value == nullptr) {\n            s->Append(\"[null]\");\n            return {true};\n        }\n        s->Append(\"[QueueDescriptor\");\n        if (value->label != nullptr) {\n            s->Append(absl::StrFormat(\" \\\"%s\\\"\", value->label));\n        }\n        s->Append(\"]\");\n        return {true};\n    }\n    absl::FormatConvertResult<absl::FormatConversionCharSet::kString>\n    AbslFormatConvert(const RenderBundleDescriptor* value,\n                        const absl::FormatConversionSpec& spec,\n                        absl::FormatSink* s) {\n        if (value == nullptr) {\n            s->Append(\"[null]\");\n            return {true};\n        }\n        s->Append(\"[RenderBundleDescriptor\");\n        if (value->label != nullptr) {\n            s->Append(absl::StrFormat(\" \\\"%s\\\"\", value->label));\n        }\n        s->Append(\"]\");\n        return {true};\n    }\n    absl::FormatConvertResult<absl::FormatConversionCharSet::kString>\n    AbslFormatConvert(const RenderBundleEncoderDescriptor* value,\n                        const absl::FormatConversionSpec& spec,\n                        absl::FormatSink* s) {\n        if (value == nullptr) {\n            s->Append(\"[null]\");\n            return {true};\n        }\n        s->Append(\"[RenderBundleEncoderDescriptor\");\n        if (value->label != nullptr) {\n            s->Append(absl::StrFormat(\" \\\"%s\\\"\", value->label));\n        }\n        s->Append(\"]\");\n        return {true};\n    }\n    absl::FormatConvertResult<absl::FormatConversionCharSet::kString>\n    AbslFormatConvert(const SamplerDescriptor* value,\n                        const absl::FormatConversionSpec& spec,\n                        absl::FormatSink* s) {\n        if (value == nullptr) {\n            s->Append(\"[null]\");\n            return {true};\n        }\n        s->Append(\"[SamplerDescriptor\");\n        if (value->label != nullptr) {\n            s->Append(absl::StrFormat(\" \\\"%s\\\"\", value->label));\n        }\n        s->Append(\"]\");\n        return {true};\n    }\n    absl::FormatConvertResult<absl::FormatConversionCharSet::kString>\n    AbslFormatConvert(const ShaderModuleDescriptor* value,\n                        const absl::FormatConversionSpec& spec,\n                        absl::FormatSink* s) {\n        if (value == nullptr) {\n            s->Append(\"[null]\");\n            return {true};\n        }\n        s->Append(\"[ShaderModuleDescriptor\");\n        if (value->label != nullptr) {\n            s->Append(absl::StrFormat(\" \\\"%s\\\"\", value->label));\n        }\n        s->Append(\"]\");\n        return {true};\n    }\n    absl::FormatConvertResult<absl::FormatConversionCharSet::kString>\n    AbslFormatConvert(const SurfaceDescriptor* value,\n                        const absl::FormatConversionSpec& spec,\n                        absl::FormatSink* s) {\n        if (value == nullptr) {\n            s->Append(\"[null]\");\n            return {true};\n        }\n        s->Append(\"[SurfaceDescriptor\");\n        if (value->label != nullptr) {\n            s->Append(absl::StrFormat(\" \\\"%s\\\"\", value->label));\n        }\n        s->Append(\"]\");\n        return {true};\n    }\n    absl::FormatConvertResult<absl::FormatConversionCharSet::kString>\n    AbslFormatConvert(const SwapChainDescriptor* value,\n                        const absl::FormatConversionSpec& spec,\n                        absl::FormatSink* s) {\n        if (value == nullptr) {\n            s->Append(\"[null]\");\n            return {true};\n        }\n        s->Append(\"[SwapChainDescriptor\");\n        if (value->label != nullptr) {\n            s->Append(absl::StrFormat(\" \\\"%s\\\"\", value->label));\n        }\n        s->Append(\"]\");\n        return {true};\n    }\n    absl::FormatConvertResult<absl::FormatConversionCharSet::kString>\n    AbslFormatConvert(const TextureViewDescriptor* value,\n                        const absl::FormatConversionSpec& spec,\n                        absl::FormatSink* s) {\n        if (value == nullptr) {\n            s->Append(\"[null]\");\n            return {true};\n        }\n        s->Append(\"[TextureViewDescriptor\");\n        if (value->label != nullptr) {\n            s->Append(absl::StrFormat(\" \\\"%s\\\"\", value->label));\n        }\n        s->Append(\"]\");\n        return {true};\n    }\n    absl::FormatConvertResult<absl::FormatConversionCharSet::kString>\n    AbslFormatConvert(const BindGroupDescriptor* value,\n                        const absl::FormatConversionSpec& spec,\n                        absl::FormatSink* s) {\n        if (value == nullptr) {\n            s->Append(\"[null]\");\n            return {true};\n        }\n        s->Append(\"[BindGroupDescriptor\");\n        if (value->label != nullptr) {\n            s->Append(absl::StrFormat(\" \\\"%s\\\"\", value->label));\n        }\n        s->Append(\"]\");\n        return {true};\n    }\n    absl::FormatConvertResult<absl::FormatConversionCharSet::kString>\n    AbslFormatConvert(const ComputePassDescriptor* value,\n                        const absl::FormatConversionSpec& spec,\n                        absl::FormatSink* s) {\n        if (value == nullptr) {\n            s->Append(\"[null]\");\n            return {true};\n        }\n        s->Append(\"[ComputePassDescriptor\");\n        if (value->label != nullptr) {\n            s->Append(absl::StrFormat(\" \\\"%s\\\"\", value->label));\n        }\n        s->Append(\"]\");\n        return {true};\n    }\n    absl::FormatConvertResult<absl::FormatConversionCharSet::kString>\n    AbslFormatConvert(const ExternalTextureDescriptor* value,\n                        const absl::FormatConversionSpec& spec,\n                        absl::FormatSink* s) {\n        if (value == nullptr) {\n            s->Append(\"[null]\");\n            return {true};\n        }\n        s->Append(\"[ExternalTextureDescriptor\");\n        if (value->label != nullptr) {\n            s->Append(absl::StrFormat(\" \\\"%s\\\"\", value->label));\n        }\n        s->Append(\"]\");\n        return {true};\n    }\n    absl::FormatConvertResult<absl::FormatConversionCharSet::kString>\n    AbslFormatConvert(const TextureDescriptor* value,\n                        const absl::FormatConversionSpec& spec,\n                        absl::FormatSink* s) {\n        if (value == nullptr) {\n            s->Append(\"[null]\");\n            return {true};\n        }\n        s->Append(\"[TextureDescriptor\");\n        if (value->label != nullptr) {\n            s->Append(absl::StrFormat(\" \\\"%s\\\"\", value->label));\n        }\n        s->Append(\"]\");\n        return {true};\n    }\n    absl::FormatConvertResult<absl::FormatConversionCharSet::kString>\n    AbslFormatConvert(const BindGroupLayoutDescriptor* value,\n                        const absl::FormatConversionSpec& spec,\n                        absl::FormatSink* s) {\n        if (value == nullptr) {\n            s->Append(\"[null]\");\n            return {true};\n        }\n        s->Append(\"[BindGroupLayoutDescriptor\");\n        if (value->label != nullptr) {\n            s->Append(absl::StrFormat(\" \\\"%s\\\"\", value->label));\n        }\n        s->Append(\"]\");\n        return {true};\n    }\n    absl::FormatConvertResult<absl::FormatConversionCharSet::kString>\n    AbslFormatConvert(const ComputePipelineDescriptor* value,\n                        const absl::FormatConversionSpec& spec,\n                        absl::FormatSink* s) {\n        if (value == nullptr) {\n            s->Append(\"[null]\");\n            return {true};\n        }\n        s->Append(\"[ComputePipelineDescriptor\");\n        if (value->label != nullptr) {\n            s->Append(absl::StrFormat(\" \\\"%s\\\"\", value->label));\n        }\n        s->Append(\"]\");\n        return {true};\n    }\n    absl::FormatConvertResult<absl::FormatConversionCharSet::kString>\n    AbslFormatConvert(const DeviceDescriptor* value,\n                        const absl::FormatConversionSpec& spec,\n                        absl::FormatSink* s) {\n        if (value == nullptr) {\n            s->Append(\"[null]\");\n            return {true};\n        }\n        s->Append(\"[DeviceDescriptor\");\n        if (value->label != nullptr) {\n            s->Append(absl::StrFormat(\" \\\"%s\\\"\", value->label));\n        }\n        s->Append(\"]\");\n        return {true};\n    }\n    absl::FormatConvertResult<absl::FormatConversionCharSet::kString>\n    AbslFormatConvert(const RenderPassDescriptor* value,\n                        const absl::FormatConversionSpec& spec,\n                        absl::FormatSink* s) {\n        if (value == nullptr) {\n            s->Append(\"[null]\");\n            return {true};\n        }\n        s->Append(\"[RenderPassDescriptor\");\n        if (value->label != nullptr) {\n            s->Append(absl::StrFormat(\" \\\"%s\\\"\", value->label));\n        }\n        s->Append(\"]\");\n        return {true};\n    }\n    absl::FormatConvertResult<absl::FormatConversionCharSet::kString>\n    AbslFormatConvert(const RenderPipelineDescriptor* value,\n                        const absl::FormatConversionSpec& spec,\n                        absl::FormatSink* s) {\n        if (value == nullptr) {\n            s->Append(\"[null]\");\n            return {true};\n        }\n        s->Append(\"[RenderPipelineDescriptor\");\n        if (value->label != nullptr) {\n            s->Append(absl::StrFormat(\" \\\"%s\\\"\", value->label));\n        }\n        s->Append(\"]\");\n        return {true};\n    }\n\n    //\n    // Compatible with absl::StrFormat (Needs to be disjoint from having a 'label' for now.)\n    // Currently uses a hard-coded list to determine which structures are actually supported. If\n    // additional structures are added, be sure to update the header file's list as well.\n    //\n    using absl::ParsedFormat;\n\n    absl::FormatConvertResult<absl::FormatConversionCharSet::kString>\n        AbslFormatConvert(const BufferBindingLayout& value,\n                          const absl::FormatConversionSpec& spec,\n                          absl::FormatSink* s) {\n        static const auto* const fmt =\n            new ParsedFormat<'s','u','u'>(\"{ type: %s, hasDynamicOffset: %u, minBindingSize: %u }\");\n        s->Append(absl::StrFormat(*fmt, value.type, value.hasDynamicOffset, value.minBindingSize));\n        return {true};\n    }\n    absl::FormatConvertResult<absl::FormatConversionCharSet::kString>\n        AbslFormatConvert(const SamplerBindingLayout& value,\n                          const absl::FormatConversionSpec& spec,\n                          absl::FormatSink* s) {\n        static const auto* const fmt =\n            new ParsedFormat<'s'>(\"{ type: %s }\");\n        s->Append(absl::StrFormat(*fmt, value.type));\n        return {true};\n    }\n    absl::FormatConvertResult<absl::FormatConversionCharSet::kString>\n        AbslFormatConvert(const StorageTextureBindingLayout& value,\n                          const absl::FormatConversionSpec& spec,\n                          absl::FormatSink* s) {\n        static const auto* const fmt =\n            new ParsedFormat<'s','s','s'>(\"{ access: %s, format: %s, viewDimension: %s }\");\n        s->Append(absl::StrFormat(*fmt, value.access, value.format, value.viewDimension));\n        return {true};\n    }\n    absl::FormatConvertResult<absl::FormatConversionCharSet::kString>\n        AbslFormatConvert(const TextureBindingLayout& value,\n                          const absl::FormatConversionSpec& spec,\n                          absl::FormatSink* s) {\n        static const auto* const fmt =\n            new ParsedFormat<'s','s','u'>(\"{ sampleType: %s, viewDimension: %s, multisampled: %u }\");\n        s->Append(absl::StrFormat(*fmt, value.sampleType, value.viewDimension, value.multisampled));\n        return {true};\n    }\n\n}  // namespace dawn::native\n\nnamespace wgpu {\n\n    //\n    // Enums\n    //\n\n    absl::FormatConvertResult<absl::FormatConversionCharSet::kString|absl::FormatConversionCharSet::kIntegral>\n    AbslFormatConvert(AdapterType value,\n                      const absl::FormatConversionSpec& spec,\n                      absl::FormatSink* s) {\n        if (spec.conversion_char() == absl::FormatConversionChar::s) {\n            s->Append(\"AdapterType::\");\n            switch (value) {\n            case AdapterType::DiscreteGPU:\n                s->Append(\"DiscreteGPU\");\n                break;\n            case AdapterType::IntegratedGPU:\n                s->Append(\"IntegratedGPU\");\n                break;\n            case AdapterType::CPU:\n                s->Append(\"CPU\");\n                break;\n            case AdapterType::Unknown:\n                s->Append(\"Unknown\");\n                break;\n            }\n        } else {\n            s->Append(absl::StrFormat(\"%u\", static_cast<typename std::underlying_type<AdapterType>::type>(value)));\n        }\n        return {true};\n    }\n    absl::FormatConvertResult<absl::FormatConversionCharSet::kString|absl::FormatConversionCharSet::kIntegral>\n    AbslFormatConvert(AddressMode value,\n                      const absl::FormatConversionSpec& spec,\n                      absl::FormatSink* s) {\n        if (spec.conversion_char() == absl::FormatConversionChar::s) {\n            s->Append(\"AddressMode::\");\n            switch (value) {\n            case AddressMode::Repeat:\n                s->Append(\"Repeat\");\n                break;\n            case AddressMode::MirrorRepeat:\n                s->Append(\"MirrorRepeat\");\n                break;\n            case AddressMode::ClampToEdge:\n                s->Append(\"ClampToEdge\");\n                break;\n            }\n        } else {\n            s->Append(absl::StrFormat(\"%u\", static_cast<typename std::underlying_type<AddressMode>::type>(value)));\n        }\n        return {true};\n    }\n    absl::FormatConvertResult<absl::FormatConversionCharSet::kString|absl::FormatConversionCharSet::kIntegral>\n    AbslFormatConvert(AlphaMode value,\n                      const absl::FormatConversionSpec& spec,\n                      absl::FormatSink* s) {\n        if (spec.conversion_char() == absl::FormatConversionChar::s) {\n            s->Append(\"AlphaMode::\");\n            switch (value) {\n            case AlphaMode::Premultiplied:\n                s->Append(\"Premultiplied\");\n                break;\n            case AlphaMode::Unpremultiplied:\n                s->Append(\"Unpremultiplied\");\n                break;\n            case AlphaMode::Opaque:\n                s->Append(\"Opaque\");\n                break;\n            }\n        } else {\n            s->Append(absl::StrFormat(\"%u\", static_cast<typename std::underlying_type<AlphaMode>::type>(value)));\n        }\n        return {true};\n    }\n    absl::FormatConvertResult<absl::FormatConversionCharSet::kString|absl::FormatConversionCharSet::kIntegral>\n    AbslFormatConvert(BackendType value,\n                      const absl::FormatConversionSpec& spec,\n                      absl::FormatSink* s) {\n        if (spec.conversion_char() == absl::FormatConversionChar::s) {\n            s->Append(\"BackendType::\");\n            switch (value) {\n            case BackendType::Undefined:\n                s->Append(\"Undefined\");\n                break;\n            case BackendType::Null:\n                s->Append(\"Null\");\n                break;\n            case BackendType::WebGPU:\n                s->Append(\"WebGPU\");\n                break;\n            case BackendType::D3D11:\n                s->Append(\"D3D11\");\n                break;\n            case BackendType::D3D12:\n                s->Append(\"D3D12\");\n                break;\n            case BackendType::Metal:\n                s->Append(\"Metal\");\n                break;\n            case BackendType::Vulkan:\n                s->Append(\"Vulkan\");\n                break;\n            case BackendType::OpenGL:\n                s->Append(\"OpenGL\");\n                break;\n            case BackendType::OpenGLES:\n                s->Append(\"OpenGLES\");\n                break;\n            }\n        } else {\n            s->Append(absl::StrFormat(\"%u\", static_cast<typename std::underlying_type<BackendType>::type>(value)));\n        }\n        return {true};\n    }\n    absl::FormatConvertResult<absl::FormatConversionCharSet::kString|absl::FormatConversionCharSet::kIntegral>\n    AbslFormatConvert(BlendFactor value,\n                      const absl::FormatConversionSpec& spec,\n                      absl::FormatSink* s) {\n        if (spec.conversion_char() == absl::FormatConversionChar::s) {\n            s->Append(\"BlendFactor::\");\n            switch (value) {\n            case BlendFactor::Zero:\n                s->Append(\"Zero\");\n                break;\n            case BlendFactor::One:\n                s->Append(\"One\");\n                break;\n            case BlendFactor::Src:\n                s->Append(\"Src\");\n                break;\n            case BlendFactor::OneMinusSrc:\n                s->Append(\"OneMinusSrc\");\n                break;\n            case BlendFactor::SrcAlpha:\n                s->Append(\"SrcAlpha\");\n                break;\n            case BlendFactor::OneMinusSrcAlpha:\n                s->Append(\"OneMinusSrcAlpha\");\n                break;\n            case BlendFactor::Dst:\n                s->Append(\"Dst\");\n                break;\n            case BlendFactor::OneMinusDst:\n                s->Append(\"OneMinusDst\");\n                break;\n            case BlendFactor::DstAlpha:\n                s->Append(\"DstAlpha\");\n                break;\n            case BlendFactor::OneMinusDstAlpha:\n                s->Append(\"OneMinusDstAlpha\");\n                break;\n            case BlendFactor::SrcAlphaSaturated:\n                s->Append(\"SrcAlphaSaturated\");\n                break;\n            case BlendFactor::Constant:\n                s->Append(\"Constant\");\n                break;\n            case BlendFactor::OneMinusConstant:\n                s->Append(\"OneMinusConstant\");\n                break;\n            }\n        } else {\n            s->Append(absl::StrFormat(\"%u\", static_cast<typename std::underlying_type<BlendFactor>::type>(value)));\n        }\n        return {true};\n    }\n    absl::FormatConvertResult<absl::FormatConversionCharSet::kString|absl::FormatConversionCharSet::kIntegral>\n    AbslFormatConvert(BlendOperation value,\n                      const absl::FormatConversionSpec& spec,\n                      absl::FormatSink* s) {\n        if (spec.conversion_char() == absl::FormatConversionChar::s) {\n            s->Append(\"BlendOperation::\");\n            switch (value) {\n            case BlendOperation::Add:\n                s->Append(\"Add\");\n                break;\n            case BlendOperation::Subtract:\n                s->Append(\"Subtract\");\n                break;\n            case BlendOperation::ReverseSubtract:\n                s->Append(\"ReverseSubtract\");\n                break;\n            case BlendOperation::Min:\n                s->Append(\"Min\");\n                break;\n            case BlendOperation::Max:\n                s->Append(\"Max\");\n                break;\n            }\n        } else {\n            s->Append(absl::StrFormat(\"%u\", static_cast<typename std::underlying_type<BlendOperation>::type>(value)));\n        }\n        return {true};\n    }\n    absl::FormatConvertResult<absl::FormatConversionCharSet::kString|absl::FormatConversionCharSet::kIntegral>\n    AbslFormatConvert(BufferBindingType value,\n                      const absl::FormatConversionSpec& spec,\n                      absl::FormatSink* s) {\n        if (spec.conversion_char() == absl::FormatConversionChar::s) {\n            s->Append(\"BufferBindingType::\");\n            switch (value) {\n            case BufferBindingType::Undefined:\n                s->Append(\"Undefined\");\n                break;\n            case BufferBindingType::Uniform:\n                s->Append(\"Uniform\");\n                break;\n            case BufferBindingType::Storage:\n                s->Append(\"Storage\");\n                break;\n            case BufferBindingType::ReadOnlyStorage:\n                s->Append(\"ReadOnlyStorage\");\n                break;\n            }\n        } else {\n            s->Append(absl::StrFormat(\"%u\", static_cast<typename std::underlying_type<BufferBindingType>::type>(value)));\n        }\n        return {true};\n    }\n    absl::FormatConvertResult<absl::FormatConversionCharSet::kString|absl::FormatConversionCharSet::kIntegral>\n    AbslFormatConvert(BufferMapAsyncStatus value,\n                      const absl::FormatConversionSpec& spec,\n                      absl::FormatSink* s) {\n        if (spec.conversion_char() == absl::FormatConversionChar::s) {\n            s->Append(\"BufferMapAsyncStatus::\");\n            switch (value) {\n            case BufferMapAsyncStatus::Success:\n                s->Append(\"Success\");\n                break;\n            case BufferMapAsyncStatus::ValidationError:\n                s->Append(\"ValidationError\");\n                break;\n            case BufferMapAsyncStatus::Unknown:\n                s->Append(\"Unknown\");\n                break;\n            case BufferMapAsyncStatus::DeviceLost:\n                s->Append(\"DeviceLost\");\n                break;\n            case BufferMapAsyncStatus::DestroyedBeforeCallback:\n                s->Append(\"DestroyedBeforeCallback\");\n                break;\n            case BufferMapAsyncStatus::UnmappedBeforeCallback:\n                s->Append(\"UnmappedBeforeCallback\");\n                break;\n            case BufferMapAsyncStatus::MappingAlreadyPending:\n                s->Append(\"MappingAlreadyPending\");\n                break;\n            case BufferMapAsyncStatus::OffsetOutOfRange:\n                s->Append(\"OffsetOutOfRange\");\n                break;\n            case BufferMapAsyncStatus::SizeOutOfRange:\n                s->Append(\"SizeOutOfRange\");\n                break;\n            }\n        } else {\n            s->Append(absl::StrFormat(\"%u\", static_cast<typename std::underlying_type<BufferMapAsyncStatus>::type>(value)));\n        }\n        return {true};\n    }\n    absl::FormatConvertResult<absl::FormatConversionCharSet::kString|absl::FormatConversionCharSet::kIntegral>\n    AbslFormatConvert(BufferMapState value,\n                      const absl::FormatConversionSpec& spec,\n                      absl::FormatSink* s) {\n        if (spec.conversion_char() == absl::FormatConversionChar::s) {\n            s->Append(\"BufferMapState::\");\n            switch (value) {\n            case BufferMapState::Unmapped:\n                s->Append(\"Unmapped\");\n                break;\n            case BufferMapState::Pending:\n                s->Append(\"Pending\");\n                break;\n            case BufferMapState::Mapped:\n                s->Append(\"Mapped\");\n                break;\n            }\n        } else {\n            s->Append(absl::StrFormat(\"%u\", static_cast<typename std::underlying_type<BufferMapState>::type>(value)));\n        }\n        return {true};\n    }\n    absl::FormatConvertResult<absl::FormatConversionCharSet::kString|absl::FormatConversionCharSet::kIntegral>\n    AbslFormatConvert(CompareFunction value,\n                      const absl::FormatConversionSpec& spec,\n                      absl::FormatSink* s) {\n        if (spec.conversion_char() == absl::FormatConversionChar::s) {\n            s->Append(\"CompareFunction::\");\n            switch (value) {\n            case CompareFunction::Undefined:\n                s->Append(\"Undefined\");\n                break;\n            case CompareFunction::Never:\n                s->Append(\"Never\");\n                break;\n            case CompareFunction::Less:\n                s->Append(\"Less\");\n                break;\n            case CompareFunction::LessEqual:\n                s->Append(\"LessEqual\");\n                break;\n            case CompareFunction::Greater:\n                s->Append(\"Greater\");\n                break;\n            case CompareFunction::GreaterEqual:\n                s->Append(\"GreaterEqual\");\n                break;\n            case CompareFunction::Equal:\n                s->Append(\"Equal\");\n                break;\n            case CompareFunction::NotEqual:\n                s->Append(\"NotEqual\");\n                break;\n            case CompareFunction::Always:\n                s->Append(\"Always\");\n                break;\n            }\n        } else {\n            s->Append(absl::StrFormat(\"%u\", static_cast<typename std::underlying_type<CompareFunction>::type>(value)));\n        }\n        return {true};\n    }\n    absl::FormatConvertResult<absl::FormatConversionCharSet::kString|absl::FormatConversionCharSet::kIntegral>\n    AbslFormatConvert(CompilationInfoRequestStatus value,\n                      const absl::FormatConversionSpec& spec,\n                      absl::FormatSink* s) {\n        if (spec.conversion_char() == absl::FormatConversionChar::s) {\n            s->Append(\"CompilationInfoRequestStatus::\");\n            switch (value) {\n            case CompilationInfoRequestStatus::Success:\n                s->Append(\"Success\");\n                break;\n            case CompilationInfoRequestStatus::Error:\n                s->Append(\"Error\");\n                break;\n            case CompilationInfoRequestStatus::DeviceLost:\n                s->Append(\"DeviceLost\");\n                break;\n            case CompilationInfoRequestStatus::Unknown:\n                s->Append(\"Unknown\");\n                break;\n            }\n        } else {\n            s->Append(absl::StrFormat(\"%u\", static_cast<typename std::underlying_type<CompilationInfoRequestStatus>::type>(value)));\n        }\n        return {true};\n    }\n    absl::FormatConvertResult<absl::FormatConversionCharSet::kString|absl::FormatConversionCharSet::kIntegral>\n    AbslFormatConvert(CompilationMessageType value,\n                      const absl::FormatConversionSpec& spec,\n                      absl::FormatSink* s) {\n        if (spec.conversion_char() == absl::FormatConversionChar::s) {\n            s->Append(\"CompilationMessageType::\");\n            switch (value) {\n            case CompilationMessageType::Error:\n                s->Append(\"Error\");\n                break;\n            case CompilationMessageType::Warning:\n                s->Append(\"Warning\");\n                break;\n            case CompilationMessageType::Info:\n                s->Append(\"Info\");\n                break;\n            }\n        } else {\n            s->Append(absl::StrFormat(\"%u\", static_cast<typename std::underlying_type<CompilationMessageType>::type>(value)));\n        }\n        return {true};\n    }\n    absl::FormatConvertResult<absl::FormatConversionCharSet::kString|absl::FormatConversionCharSet::kIntegral>\n    AbslFormatConvert(ComputePassTimestampLocation value,\n                      const absl::FormatConversionSpec& spec,\n                      absl::FormatSink* s) {\n        if (spec.conversion_char() == absl::FormatConversionChar::s) {\n            s->Append(\"ComputePassTimestampLocation::\");\n            switch (value) {\n            case ComputePassTimestampLocation::Beginning:\n                s->Append(\"Beginning\");\n                break;\n            case ComputePassTimestampLocation::End:\n                s->Append(\"End\");\n                break;\n            }\n        } else {\n            s->Append(absl::StrFormat(\"%u\", static_cast<typename std::underlying_type<ComputePassTimestampLocation>::type>(value)));\n        }\n        return {true};\n    }\n    absl::FormatConvertResult<absl::FormatConversionCharSet::kString|absl::FormatConversionCharSet::kIntegral>\n    AbslFormatConvert(CreatePipelineAsyncStatus value,\n                      const absl::FormatConversionSpec& spec,\n                      absl::FormatSink* s) {\n        if (spec.conversion_char() == absl::FormatConversionChar::s) {\n            s->Append(\"CreatePipelineAsyncStatus::\");\n            switch (value) {\n            case CreatePipelineAsyncStatus::Success:\n                s->Append(\"Success\");\n                break;\n            case CreatePipelineAsyncStatus::ValidationError:\n                s->Append(\"ValidationError\");\n                break;\n            case CreatePipelineAsyncStatus::InternalError:\n                s->Append(\"InternalError\");\n                break;\n            case CreatePipelineAsyncStatus::DeviceLost:\n                s->Append(\"DeviceLost\");\n                break;\n            case CreatePipelineAsyncStatus::DeviceDestroyed:\n                s->Append(\"DeviceDestroyed\");\n                break;\n            case CreatePipelineAsyncStatus::Unknown:\n                s->Append(\"Unknown\");\n                break;\n            }\n        } else {\n            s->Append(absl::StrFormat(\"%u\", static_cast<typename std::underlying_type<CreatePipelineAsyncStatus>::type>(value)));\n        }\n        return {true};\n    }\n    absl::FormatConvertResult<absl::FormatConversionCharSet::kString|absl::FormatConversionCharSet::kIntegral>\n    AbslFormatConvert(CullMode value,\n                      const absl::FormatConversionSpec& spec,\n                      absl::FormatSink* s) {\n        if (spec.conversion_char() == absl::FormatConversionChar::s) {\n            s->Append(\"CullMode::\");\n            switch (value) {\n            case CullMode::None:\n                s->Append(\"None\");\n                break;\n            case CullMode::Front:\n                s->Append(\"Front\");\n                break;\n            case CullMode::Back:\n                s->Append(\"Back\");\n                break;\n            }\n        } else {\n            s->Append(absl::StrFormat(\"%u\", static_cast<typename std::underlying_type<CullMode>::type>(value)));\n        }\n        return {true};\n    }\n    absl::FormatConvertResult<absl::FormatConversionCharSet::kString|absl::FormatConversionCharSet::kIntegral>\n    AbslFormatConvert(DeviceLostReason value,\n                      const absl::FormatConversionSpec& spec,\n                      absl::FormatSink* s) {\n        if (spec.conversion_char() == absl::FormatConversionChar::s) {\n            s->Append(\"DeviceLostReason::\");\n            switch (value) {\n            case DeviceLostReason::Undefined:\n                s->Append(\"Undefined\");\n                break;\n            case DeviceLostReason::Destroyed:\n                s->Append(\"Destroyed\");\n                break;\n            }\n        } else {\n            s->Append(absl::StrFormat(\"%u\", static_cast<typename std::underlying_type<DeviceLostReason>::type>(value)));\n        }\n        return {true};\n    }\n    absl::FormatConvertResult<absl::FormatConversionCharSet::kString|absl::FormatConversionCharSet::kIntegral>\n    AbslFormatConvert(ErrorFilter value,\n                      const absl::FormatConversionSpec& spec,\n                      absl::FormatSink* s) {\n        if (spec.conversion_char() == absl::FormatConversionChar::s) {\n            s->Append(\"ErrorFilter::\");\n            switch (value) {\n            case ErrorFilter::Validation:\n                s->Append(\"Validation\");\n                break;\n            case ErrorFilter::OutOfMemory:\n                s->Append(\"OutOfMemory\");\n                break;\n            case ErrorFilter::Internal:\n                s->Append(\"Internal\");\n                break;\n            }\n        } else {\n            s->Append(absl::StrFormat(\"%u\", static_cast<typename std::underlying_type<ErrorFilter>::type>(value)));\n        }\n        return {true};\n    }\n    absl::FormatConvertResult<absl::FormatConversionCharSet::kString|absl::FormatConversionCharSet::kIntegral>\n    AbslFormatConvert(ErrorType value,\n                      const absl::FormatConversionSpec& spec,\n                      absl::FormatSink* s) {\n        if (spec.conversion_char() == absl::FormatConversionChar::s) {\n            s->Append(\"ErrorType::\");\n            switch (value) {\n            case ErrorType::NoError:\n                s->Append(\"NoError\");\n                break;\n            case ErrorType::Validation:\n                s->Append(\"Validation\");\n                break;\n            case ErrorType::OutOfMemory:\n                s->Append(\"OutOfMemory\");\n                break;\n            case ErrorType::Internal:\n                s->Append(\"Internal\");\n                break;\n            case ErrorType::Unknown:\n                s->Append(\"Unknown\");\n                break;\n            case ErrorType::DeviceLost:\n                s->Append(\"DeviceLost\");\n                break;\n            }\n        } else {\n            s->Append(absl::StrFormat(\"%u\", static_cast<typename std::underlying_type<ErrorType>::type>(value)));\n        }\n        return {true};\n    }\n    absl::FormatConvertResult<absl::FormatConversionCharSet::kString|absl::FormatConversionCharSet::kIntegral>\n    AbslFormatConvert(ExternalTextureRotation value,\n                      const absl::FormatConversionSpec& spec,\n                      absl::FormatSink* s) {\n        if (spec.conversion_char() == absl::FormatConversionChar::s) {\n            s->Append(\"ExternalTextureRotation::\");\n            switch (value) {\n            case ExternalTextureRotation::Rotate0Degrees:\n                s->Append(\"Rotate0Degrees\");\n                break;\n            case ExternalTextureRotation::Rotate90Degrees:\n                s->Append(\"Rotate90Degrees\");\n                break;\n            case ExternalTextureRotation::Rotate180Degrees:\n                s->Append(\"Rotate180Degrees\");\n                break;\n            case ExternalTextureRotation::Rotate270Degrees:\n                s->Append(\"Rotate270Degrees\");\n                break;\n            }\n        } else {\n            s->Append(absl::StrFormat(\"%u\", static_cast<typename std::underlying_type<ExternalTextureRotation>::type>(value)));\n        }\n        return {true};\n    }\n    absl::FormatConvertResult<absl::FormatConversionCharSet::kString|absl::FormatConversionCharSet::kIntegral>\n    AbslFormatConvert(FeatureName value,\n                      const absl::FormatConversionSpec& spec,\n                      absl::FormatSink* s) {\n        if (spec.conversion_char() == absl::FormatConversionChar::s) {\n            s->Append(\"FeatureName::\");\n            switch (value) {\n            case FeatureName::Undefined:\n                s->Append(\"Undefined\");\n                break;\n            case FeatureName::DepthClipControl:\n                s->Append(\"DepthClipControl\");\n                break;\n            case FeatureName::Depth32FloatStencil8:\n                s->Append(\"Depth32FloatStencil8\");\n                break;\n            case FeatureName::TimestampQuery:\n                s->Append(\"TimestampQuery\");\n                break;\n            case FeatureName::PipelineStatisticsQuery:\n                s->Append(\"PipelineStatisticsQuery\");\n                break;\n            case FeatureName::TextureCompressionBC:\n                s->Append(\"TextureCompressionBC\");\n                break;\n            case FeatureName::TextureCompressionETC2:\n                s->Append(\"TextureCompressionETC2\");\n                break;\n            case FeatureName::TextureCompressionASTC:\n                s->Append(\"TextureCompressionASTC\");\n                break;\n            case FeatureName::IndirectFirstInstance:\n                s->Append(\"IndirectFirstInstance\");\n                break;\n            case FeatureName::ShaderF16:\n                s->Append(\"ShaderF16\");\n                break;\n            case FeatureName::RG11B10UfloatRenderable:\n                s->Append(\"RG11B10UfloatRenderable\");\n                break;\n            case FeatureName::BGRA8UnormStorage:\n                s->Append(\"BGRA8UnormStorage\");\n                break;\n            case FeatureName::Float32Filterable:\n                s->Append(\"Float32Filterable\");\n                break;\n            case FeatureName::DawnShaderFloat16:\n                s->Append(\"DawnShaderFloat16\");\n                break;\n            case FeatureName::DawnInternalUsages:\n                s->Append(\"DawnInternalUsages\");\n                break;\n            case FeatureName::DawnMultiPlanarFormats:\n                s->Append(\"DawnMultiPlanarFormats\");\n                break;\n            case FeatureName::DawnNative:\n                s->Append(\"DawnNative\");\n                break;\n            case FeatureName::ChromiumExperimentalDp4a:\n                s->Append(\"ChromiumExperimentalDp4a\");\n                break;\n            case FeatureName::TimestampQueryInsidePasses:\n                s->Append(\"TimestampQueryInsidePasses\");\n                break;\n            case FeatureName::ImplicitDeviceSynchronization:\n                s->Append(\"ImplicitDeviceSynchronization\");\n                break;\n            case FeatureName::SurfaceCapabilities:\n                s->Append(\"SurfaceCapabilities\");\n                break;\n            case FeatureName::TransientAttachments:\n                s->Append(\"TransientAttachments\");\n                break;\n            case FeatureName::MSAARenderToSingleSampled:\n                s->Append(\"MSAARenderToSingleSampled\");\n                break;\n            }\n        } else {\n            s->Append(absl::StrFormat(\"%u\", static_cast<typename std::underlying_type<FeatureName>::type>(value)));\n        }\n        return {true};\n    }\n    absl::FormatConvertResult<absl::FormatConversionCharSet::kString|absl::FormatConversionCharSet::kIntegral>\n    AbslFormatConvert(FilterMode value,\n                      const absl::FormatConversionSpec& spec,\n                      absl::FormatSink* s) {\n        if (spec.conversion_char() == absl::FormatConversionChar::s) {\n            s->Append(\"FilterMode::\");\n            switch (value) {\n            case FilterMode::Nearest:\n                s->Append(\"Nearest\");\n                break;\n            case FilterMode::Linear:\n                s->Append(\"Linear\");\n                break;\n            }\n        } else {\n            s->Append(absl::StrFormat(\"%u\", static_cast<typename std::underlying_type<FilterMode>::type>(value)));\n        }\n        return {true};\n    }\n    absl::FormatConvertResult<absl::FormatConversionCharSet::kString|absl::FormatConversionCharSet::kIntegral>\n    AbslFormatConvert(FrontFace value,\n                      const absl::FormatConversionSpec& spec,\n                      absl::FormatSink* s) {\n        if (spec.conversion_char() == absl::FormatConversionChar::s) {\n            s->Append(\"FrontFace::\");\n            switch (value) {\n            case FrontFace::CCW:\n                s->Append(\"CCW\");\n                break;\n            case FrontFace::CW:\n                s->Append(\"CW\");\n                break;\n            }\n        } else {\n            s->Append(absl::StrFormat(\"%u\", static_cast<typename std::underlying_type<FrontFace>::type>(value)));\n        }\n        return {true};\n    }\n    absl::FormatConvertResult<absl::FormatConversionCharSet::kString|absl::FormatConversionCharSet::kIntegral>\n    AbslFormatConvert(IndexFormat value,\n                      const absl::FormatConversionSpec& spec,\n                      absl::FormatSink* s) {\n        if (spec.conversion_char() == absl::FormatConversionChar::s) {\n            s->Append(\"IndexFormat::\");\n            switch (value) {\n            case IndexFormat::Undefined:\n                s->Append(\"Undefined\");\n                break;\n            case IndexFormat::Uint16:\n                s->Append(\"Uint16\");\n                break;\n            case IndexFormat::Uint32:\n                s->Append(\"Uint32\");\n                break;\n            }\n        } else {\n            s->Append(absl::StrFormat(\"%u\", static_cast<typename std::underlying_type<IndexFormat>::type>(value)));\n        }\n        return {true};\n    }\n    absl::FormatConvertResult<absl::FormatConversionCharSet::kString|absl::FormatConversionCharSet::kIntegral>\n    AbslFormatConvert(LoadOp value,\n                      const absl::FormatConversionSpec& spec,\n                      absl::FormatSink* s) {\n        if (spec.conversion_char() == absl::FormatConversionChar::s) {\n            s->Append(\"LoadOp::\");\n            switch (value) {\n            case LoadOp::Undefined:\n                s->Append(\"Undefined\");\n                break;\n            case LoadOp::Clear:\n                s->Append(\"Clear\");\n                break;\n            case LoadOp::Load:\n                s->Append(\"Load\");\n                break;\n            }\n        } else {\n            s->Append(absl::StrFormat(\"%u\", static_cast<typename std::underlying_type<LoadOp>::type>(value)));\n        }\n        return {true};\n    }\n    absl::FormatConvertResult<absl::FormatConversionCharSet::kString|absl::FormatConversionCharSet::kIntegral>\n    AbslFormatConvert(LoggingType value,\n                      const absl::FormatConversionSpec& spec,\n                      absl::FormatSink* s) {\n        if (spec.conversion_char() == absl::FormatConversionChar::s) {\n            s->Append(\"LoggingType::\");\n            switch (value) {\n            case LoggingType::Verbose:\n                s->Append(\"Verbose\");\n                break;\n            case LoggingType::Info:\n                s->Append(\"Info\");\n                break;\n            case LoggingType::Warning:\n                s->Append(\"Warning\");\n                break;\n            case LoggingType::Error:\n                s->Append(\"Error\");\n                break;\n            }\n        } else {\n            s->Append(absl::StrFormat(\"%u\", static_cast<typename std::underlying_type<LoggingType>::type>(value)));\n        }\n        return {true};\n    }\n    absl::FormatConvertResult<absl::FormatConversionCharSet::kString|absl::FormatConversionCharSet::kIntegral>\n    AbslFormatConvert(MipmapFilterMode value,\n                      const absl::FormatConversionSpec& spec,\n                      absl::FormatSink* s) {\n        if (spec.conversion_char() == absl::FormatConversionChar::s) {\n            s->Append(\"MipmapFilterMode::\");\n            switch (value) {\n            case MipmapFilterMode::Nearest:\n                s->Append(\"Nearest\");\n                break;\n            case MipmapFilterMode::Linear:\n                s->Append(\"Linear\");\n                break;\n            }\n        } else {\n            s->Append(absl::StrFormat(\"%u\", static_cast<typename std::underlying_type<MipmapFilterMode>::type>(value)));\n        }\n        return {true};\n    }\n    absl::FormatConvertResult<absl::FormatConversionCharSet::kString|absl::FormatConversionCharSet::kIntegral>\n    AbslFormatConvert(PipelineStatisticName value,\n                      const absl::FormatConversionSpec& spec,\n                      absl::FormatSink* s) {\n        if (spec.conversion_char() == absl::FormatConversionChar::s) {\n            s->Append(\"PipelineStatisticName::\");\n            switch (value) {\n            case PipelineStatisticName::VertexShaderInvocations:\n                s->Append(\"VertexShaderInvocations\");\n                break;\n            case PipelineStatisticName::ClipperInvocations:\n                s->Append(\"ClipperInvocations\");\n                break;\n            case PipelineStatisticName::ClipperPrimitivesOut:\n                s->Append(\"ClipperPrimitivesOut\");\n                break;\n            case PipelineStatisticName::FragmentShaderInvocations:\n                s->Append(\"FragmentShaderInvocations\");\n                break;\n            case PipelineStatisticName::ComputeShaderInvocations:\n                s->Append(\"ComputeShaderInvocations\");\n                break;\n            }\n        } else {\n            s->Append(absl::StrFormat(\"%u\", static_cast<typename std::underlying_type<PipelineStatisticName>::type>(value)));\n        }\n        return {true};\n    }\n    absl::FormatConvertResult<absl::FormatConversionCharSet::kString|absl::FormatConversionCharSet::kIntegral>\n    AbslFormatConvert(PowerPreference value,\n                      const absl::FormatConversionSpec& spec,\n                      absl::FormatSink* s) {\n        if (spec.conversion_char() == absl::FormatConversionChar::s) {\n            s->Append(\"PowerPreference::\");\n            switch (value) {\n            case PowerPreference::Undefined:\n                s->Append(\"Undefined\");\n                break;\n            case PowerPreference::LowPower:\n                s->Append(\"LowPower\");\n                break;\n            case PowerPreference::HighPerformance:\n                s->Append(\"HighPerformance\");\n                break;\n            }\n        } else {\n            s->Append(absl::StrFormat(\"%u\", static_cast<typename std::underlying_type<PowerPreference>::type>(value)));\n        }\n        return {true};\n    }\n    absl::FormatConvertResult<absl::FormatConversionCharSet::kString|absl::FormatConversionCharSet::kIntegral>\n    AbslFormatConvert(PresentMode value,\n                      const absl::FormatConversionSpec& spec,\n                      absl::FormatSink* s) {\n        if (spec.conversion_char() == absl::FormatConversionChar::s) {\n            s->Append(\"PresentMode::\");\n            switch (value) {\n            case PresentMode::Immediate:\n                s->Append(\"Immediate\");\n                break;\n            case PresentMode::Mailbox:\n                s->Append(\"Mailbox\");\n                break;\n            case PresentMode::Fifo:\n                s->Append(\"Fifo\");\n                break;\n            }\n        } else {\n            s->Append(absl::StrFormat(\"%u\", static_cast<typename std::underlying_type<PresentMode>::type>(value)));\n        }\n        return {true};\n    }\n    absl::FormatConvertResult<absl::FormatConversionCharSet::kString|absl::FormatConversionCharSet::kIntegral>\n    AbslFormatConvert(PrimitiveTopology value,\n                      const absl::FormatConversionSpec& spec,\n                      absl::FormatSink* s) {\n        if (spec.conversion_char() == absl::FormatConversionChar::s) {\n            s->Append(\"PrimitiveTopology::\");\n            switch (value) {\n            case PrimitiveTopology::PointList:\n                s->Append(\"PointList\");\n                break;\n            case PrimitiveTopology::LineList:\n                s->Append(\"LineList\");\n                break;\n            case PrimitiveTopology::LineStrip:\n                s->Append(\"LineStrip\");\n                break;\n            case PrimitiveTopology::TriangleList:\n                s->Append(\"TriangleList\");\n                break;\n            case PrimitiveTopology::TriangleStrip:\n                s->Append(\"TriangleStrip\");\n                break;\n            }\n        } else {\n            s->Append(absl::StrFormat(\"%u\", static_cast<typename std::underlying_type<PrimitiveTopology>::type>(value)));\n        }\n        return {true};\n    }\n    absl::FormatConvertResult<absl::FormatConversionCharSet::kString|absl::FormatConversionCharSet::kIntegral>\n    AbslFormatConvert(QueryType value,\n                      const absl::FormatConversionSpec& spec,\n                      absl::FormatSink* s) {\n        if (spec.conversion_char() == absl::FormatConversionChar::s) {\n            s->Append(\"QueryType::\");\n            switch (value) {\n            case QueryType::Occlusion:\n                s->Append(\"Occlusion\");\n                break;\n            case QueryType::PipelineStatistics:\n                s->Append(\"PipelineStatistics\");\n                break;\n            case QueryType::Timestamp:\n                s->Append(\"Timestamp\");\n                break;\n            }\n        } else {\n            s->Append(absl::StrFormat(\"%u\", static_cast<typename std::underlying_type<QueryType>::type>(value)));\n        }\n        return {true};\n    }\n    absl::FormatConvertResult<absl::FormatConversionCharSet::kString|absl::FormatConversionCharSet::kIntegral>\n    AbslFormatConvert(QueueWorkDoneStatus value,\n                      const absl::FormatConversionSpec& spec,\n                      absl::FormatSink* s) {\n        if (spec.conversion_char() == absl::FormatConversionChar::s) {\n            s->Append(\"QueueWorkDoneStatus::\");\n            switch (value) {\n            case QueueWorkDoneStatus::Success:\n                s->Append(\"Success\");\n                break;\n            case QueueWorkDoneStatus::Error:\n                s->Append(\"Error\");\n                break;\n            case QueueWorkDoneStatus::Unknown:\n                s->Append(\"Unknown\");\n                break;\n            case QueueWorkDoneStatus::DeviceLost:\n                s->Append(\"DeviceLost\");\n                break;\n            }\n        } else {\n            s->Append(absl::StrFormat(\"%u\", static_cast<typename std::underlying_type<QueueWorkDoneStatus>::type>(value)));\n        }\n        return {true};\n    }\n    absl::FormatConvertResult<absl::FormatConversionCharSet::kString|absl::FormatConversionCharSet::kIntegral>\n    AbslFormatConvert(RenderPassTimestampLocation value,\n                      const absl::FormatConversionSpec& spec,\n                      absl::FormatSink* s) {\n        if (spec.conversion_char() == absl::FormatConversionChar::s) {\n            s->Append(\"RenderPassTimestampLocation::\");\n            switch (value) {\n            case RenderPassTimestampLocation::Beginning:\n                s->Append(\"Beginning\");\n                break;\n            case RenderPassTimestampLocation::End:\n                s->Append(\"End\");\n                break;\n            }\n        } else {\n            s->Append(absl::StrFormat(\"%u\", static_cast<typename std::underlying_type<RenderPassTimestampLocation>::type>(value)));\n        }\n        return {true};\n    }\n    absl::FormatConvertResult<absl::FormatConversionCharSet::kString|absl::FormatConversionCharSet::kIntegral>\n    AbslFormatConvert(RequestAdapterStatus value,\n                      const absl::FormatConversionSpec& spec,\n                      absl::FormatSink* s) {\n        if (spec.conversion_char() == absl::FormatConversionChar::s) {\n            s->Append(\"RequestAdapterStatus::\");\n            switch (value) {\n            case RequestAdapterStatus::Success:\n                s->Append(\"Success\");\n                break;\n            case RequestAdapterStatus::Unavailable:\n                s->Append(\"Unavailable\");\n                break;\n            case RequestAdapterStatus::Error:\n                s->Append(\"Error\");\n                break;\n            case RequestAdapterStatus::Unknown:\n                s->Append(\"Unknown\");\n                break;\n            }\n        } else {\n            s->Append(absl::StrFormat(\"%u\", static_cast<typename std::underlying_type<RequestAdapterStatus>::type>(value)));\n        }\n        return {true};\n    }\n    absl::FormatConvertResult<absl::FormatConversionCharSet::kString|absl::FormatConversionCharSet::kIntegral>\n    AbslFormatConvert(RequestDeviceStatus value,\n                      const absl::FormatConversionSpec& spec,\n                      absl::FormatSink* s) {\n        if (spec.conversion_char() == absl::FormatConversionChar::s) {\n            s->Append(\"RequestDeviceStatus::\");\n            switch (value) {\n            case RequestDeviceStatus::Success:\n                s->Append(\"Success\");\n                break;\n            case RequestDeviceStatus::Error:\n                s->Append(\"Error\");\n                break;\n            case RequestDeviceStatus::Unknown:\n                s->Append(\"Unknown\");\n                break;\n            }\n        } else {\n            s->Append(absl::StrFormat(\"%u\", static_cast<typename std::underlying_type<RequestDeviceStatus>::type>(value)));\n        }\n        return {true};\n    }\n    absl::FormatConvertResult<absl::FormatConversionCharSet::kString|absl::FormatConversionCharSet::kIntegral>\n    AbslFormatConvert(SType value,\n                      const absl::FormatConversionSpec& spec,\n                      absl::FormatSink* s) {\n        if (spec.conversion_char() == absl::FormatConversionChar::s) {\n            s->Append(\"SType::\");\n            switch (value) {\n            case SType::Invalid:\n                s->Append(\"Invalid\");\n                break;\n            case SType::SurfaceDescriptorFromMetalLayer:\n                s->Append(\"SurfaceDescriptorFromMetalLayer\");\n                break;\n            case SType::SurfaceDescriptorFromWindowsHWND:\n                s->Append(\"SurfaceDescriptorFromWindowsHWND\");\n                break;\n            case SType::SurfaceDescriptorFromXlibWindow:\n                s->Append(\"SurfaceDescriptorFromXlibWindow\");\n                break;\n            case SType::SurfaceDescriptorFromCanvasHTMLSelector:\n                s->Append(\"SurfaceDescriptorFromCanvasHTMLSelector\");\n                break;\n            case SType::ShaderModuleSPIRVDescriptor:\n                s->Append(\"ShaderModuleSPIRVDescriptor\");\n                break;\n            case SType::ShaderModuleWGSLDescriptor:\n                s->Append(\"ShaderModuleWGSLDescriptor\");\n                break;\n            case SType::PrimitiveDepthClipControl:\n                s->Append(\"PrimitiveDepthClipControl\");\n                break;\n            case SType::SurfaceDescriptorFromWaylandSurface:\n                s->Append(\"SurfaceDescriptorFromWaylandSurface\");\n                break;\n            case SType::SurfaceDescriptorFromAndroidNativeWindow:\n                s->Append(\"SurfaceDescriptorFromAndroidNativeWindow\");\n                break;\n            case SType::SurfaceDescriptorFromWindowsCoreWindow:\n                s->Append(\"SurfaceDescriptorFromWindowsCoreWindow\");\n                break;\n            case SType::ExternalTextureBindingEntry:\n                s->Append(\"ExternalTextureBindingEntry\");\n                break;\n            case SType::ExternalTextureBindingLayout:\n                s->Append(\"ExternalTextureBindingLayout\");\n                break;\n            case SType::SurfaceDescriptorFromWindowsSwapChainPanel:\n                s->Append(\"SurfaceDescriptorFromWindowsSwapChainPanel\");\n                break;\n            case SType::RenderPassDescriptorMaxDrawCount:\n                s->Append(\"RenderPassDescriptorMaxDrawCount\");\n                break;\n            case SType::DawnTextureInternalUsageDescriptor:\n                s->Append(\"DawnTextureInternalUsageDescriptor\");\n                break;\n            case SType::DawnEncoderInternalUsageDescriptor:\n                s->Append(\"DawnEncoderInternalUsageDescriptor\");\n                break;\n            case SType::DawnInstanceDescriptor:\n                s->Append(\"DawnInstanceDescriptor\");\n                break;\n            case SType::DawnCacheDeviceDescriptor:\n                s->Append(\"DawnCacheDeviceDescriptor\");\n                break;\n            case SType::DawnAdapterPropertiesPowerPreference:\n                s->Append(\"DawnAdapterPropertiesPowerPreference\");\n                break;\n            case SType::DawnBufferDescriptorErrorInfoFromWireClient:\n                s->Append(\"DawnBufferDescriptorErrorInfoFromWireClient\");\n                break;\n            case SType::DawnTogglesDescriptor:\n                s->Append(\"DawnTogglesDescriptor\");\n                break;\n            case SType::DawnShaderModuleSPIRVOptionsDescriptor:\n                s->Append(\"DawnShaderModuleSPIRVOptionsDescriptor\");\n                break;\n            case SType::RequestAdapterOptionsLUID:\n                s->Append(\"RequestAdapterOptionsLUID\");\n                break;\n            case SType::RequestAdapterOptionsGetGLProc:\n                s->Append(\"RequestAdapterOptionsGetGLProc\");\n                break;\n            case SType::DawnMultisampleStateRenderToSingleSampled:\n                s->Append(\"DawnMultisampleStateRenderToSingleSampled\");\n                break;\n            case SType::DawnRenderPassColorAttachmentRenderToSingleSampled:\n                s->Append(\"DawnRenderPassColorAttachmentRenderToSingleSampled\");\n                break;\n            }\n        } else {\n            s->Append(absl::StrFormat(\"%u\", static_cast<typename std::underlying_type<SType>::type>(value)));\n        }\n        return {true};\n    }\n    absl::FormatConvertResult<absl::FormatConversionCharSet::kString|absl::FormatConversionCharSet::kIntegral>\n    AbslFormatConvert(SamplerBindingType value,\n                      const absl::FormatConversionSpec& spec,\n                      absl::FormatSink* s) {\n        if (spec.conversion_char() == absl::FormatConversionChar::s) {\n            s->Append(\"SamplerBindingType::\");\n            switch (value) {\n            case SamplerBindingType::Undefined:\n                s->Append(\"Undefined\");\n                break;\n            case SamplerBindingType::Filtering:\n                s->Append(\"Filtering\");\n                break;\n            case SamplerBindingType::NonFiltering:\n                s->Append(\"NonFiltering\");\n                break;\n            case SamplerBindingType::Comparison:\n                s->Append(\"Comparison\");\n                break;\n            }\n        } else {\n            s->Append(absl::StrFormat(\"%u\", static_cast<typename std::underlying_type<SamplerBindingType>::type>(value)));\n        }\n        return {true};\n    }\n    absl::FormatConvertResult<absl::FormatConversionCharSet::kString|absl::FormatConversionCharSet::kIntegral>\n    AbslFormatConvert(StencilOperation value,\n                      const absl::FormatConversionSpec& spec,\n                      absl::FormatSink* s) {\n        if (spec.conversion_char() == absl::FormatConversionChar::s) {\n            s->Append(\"StencilOperation::\");\n            switch (value) {\n            case StencilOperation::Keep:\n                s->Append(\"Keep\");\n                break;\n            case StencilOperation::Zero:\n                s->Append(\"Zero\");\n                break;\n            case StencilOperation::Replace:\n                s->Append(\"Replace\");\n                break;\n            case StencilOperation::Invert:\n                s->Append(\"Invert\");\n                break;\n            case StencilOperation::IncrementClamp:\n                s->Append(\"IncrementClamp\");\n                break;\n            case StencilOperation::DecrementClamp:\n                s->Append(\"DecrementClamp\");\n                break;\n            case StencilOperation::IncrementWrap:\n                s->Append(\"IncrementWrap\");\n                break;\n            case StencilOperation::DecrementWrap:\n                s->Append(\"DecrementWrap\");\n                break;\n            }\n        } else {\n            s->Append(absl::StrFormat(\"%u\", static_cast<typename std::underlying_type<StencilOperation>::type>(value)));\n        }\n        return {true};\n    }\n    absl::FormatConvertResult<absl::FormatConversionCharSet::kString|absl::FormatConversionCharSet::kIntegral>\n    AbslFormatConvert(StorageTextureAccess value,\n                      const absl::FormatConversionSpec& spec,\n                      absl::FormatSink* s) {\n        if (spec.conversion_char() == absl::FormatConversionChar::s) {\n            s->Append(\"StorageTextureAccess::\");\n            switch (value) {\n            case StorageTextureAccess::Undefined:\n                s->Append(\"Undefined\");\n                break;\n            case StorageTextureAccess::WriteOnly:\n                s->Append(\"WriteOnly\");\n                break;\n            }\n        } else {\n            s->Append(absl::StrFormat(\"%u\", static_cast<typename std::underlying_type<StorageTextureAccess>::type>(value)));\n        }\n        return {true};\n    }\n    absl::FormatConvertResult<absl::FormatConversionCharSet::kString|absl::FormatConversionCharSet::kIntegral>\n    AbslFormatConvert(StoreOp value,\n                      const absl::FormatConversionSpec& spec,\n                      absl::FormatSink* s) {\n        if (spec.conversion_char() == absl::FormatConversionChar::s) {\n            s->Append(\"StoreOp::\");\n            switch (value) {\n            case StoreOp::Undefined:\n                s->Append(\"Undefined\");\n                break;\n            case StoreOp::Store:\n                s->Append(\"Store\");\n                break;\n            case StoreOp::Discard:\n                s->Append(\"Discard\");\n                break;\n            }\n        } else {\n            s->Append(absl::StrFormat(\"%u\", static_cast<typename std::underlying_type<StoreOp>::type>(value)));\n        }\n        return {true};\n    }\n    absl::FormatConvertResult<absl::FormatConversionCharSet::kString|absl::FormatConversionCharSet::kIntegral>\n    AbslFormatConvert(TextureAspect value,\n                      const absl::FormatConversionSpec& spec,\n                      absl::FormatSink* s) {\n        if (spec.conversion_char() == absl::FormatConversionChar::s) {\n            s->Append(\"TextureAspect::\");\n            switch (value) {\n            case TextureAspect::All:\n                s->Append(\"All\");\n                break;\n            case TextureAspect::StencilOnly:\n                s->Append(\"StencilOnly\");\n                break;\n            case TextureAspect::DepthOnly:\n                s->Append(\"DepthOnly\");\n                break;\n            case TextureAspect::Plane0Only:\n                s->Append(\"Plane0Only\");\n                break;\n            case TextureAspect::Plane1Only:\n                s->Append(\"Plane1Only\");\n                break;\n            }\n        } else {\n            s->Append(absl::StrFormat(\"%u\", static_cast<typename std::underlying_type<TextureAspect>::type>(value)));\n        }\n        return {true};\n    }\n    absl::FormatConvertResult<absl::FormatConversionCharSet::kString|absl::FormatConversionCharSet::kIntegral>\n    AbslFormatConvert(TextureDimension value,\n                      const absl::FormatConversionSpec& spec,\n                      absl::FormatSink* s) {\n        if (spec.conversion_char() == absl::FormatConversionChar::s) {\n            s->Append(\"TextureDimension::\");\n            switch (value) {\n            case TextureDimension::e1D:\n                s->Append(\"e1D\");\n                break;\n            case TextureDimension::e2D:\n                s->Append(\"e2D\");\n                break;\n            case TextureDimension::e3D:\n                s->Append(\"e3D\");\n                break;\n            }\n        } else {\n            s->Append(absl::StrFormat(\"%u\", static_cast<typename std::underlying_type<TextureDimension>::type>(value)));\n        }\n        return {true};\n    }\n    absl::FormatConvertResult<absl::FormatConversionCharSet::kString|absl::FormatConversionCharSet::kIntegral>\n    AbslFormatConvert(TextureFormat value,\n                      const absl::FormatConversionSpec& spec,\n                      absl::FormatSink* s) {\n        if (spec.conversion_char() == absl::FormatConversionChar::s) {\n            s->Append(\"TextureFormat::\");\n            switch (value) {\n            case TextureFormat::Undefined:\n                s->Append(\"Undefined\");\n                break;\n            case TextureFormat::R8Unorm:\n                s->Append(\"R8Unorm\");\n                break;\n            case TextureFormat::R8Snorm:\n                s->Append(\"R8Snorm\");\n                break;\n            case TextureFormat::R8Uint:\n                s->Append(\"R8Uint\");\n                break;\n            case TextureFormat::R8Sint:\n                s->Append(\"R8Sint\");\n                break;\n            case TextureFormat::R16Uint:\n                s->Append(\"R16Uint\");\n                break;\n            case TextureFormat::R16Sint:\n                s->Append(\"R16Sint\");\n                break;\n            case TextureFormat::R16Float:\n                s->Append(\"R16Float\");\n                break;\n            case TextureFormat::RG8Unorm:\n                s->Append(\"RG8Unorm\");\n                break;\n            case TextureFormat::RG8Snorm:\n                s->Append(\"RG8Snorm\");\n                break;\n            case TextureFormat::RG8Uint:\n                s->Append(\"RG8Uint\");\n                break;\n            case TextureFormat::RG8Sint:\n                s->Append(\"RG8Sint\");\n                break;\n            case TextureFormat::R32Float:\n                s->Append(\"R32Float\");\n                break;\n            case TextureFormat::R32Uint:\n                s->Append(\"R32Uint\");\n                break;\n            case TextureFormat::R32Sint:\n                s->Append(\"R32Sint\");\n                break;\n            case TextureFormat::RG16Uint:\n                s->Append(\"RG16Uint\");\n                break;\n            case TextureFormat::RG16Sint:\n                s->Append(\"RG16Sint\");\n                break;\n            case TextureFormat::RG16Float:\n                s->Append(\"RG16Float\");\n                break;\n            case TextureFormat::RGBA8Unorm:\n                s->Append(\"RGBA8Unorm\");\n                break;\n            case TextureFormat::RGBA8UnormSrgb:\n                s->Append(\"RGBA8UnormSrgb\");\n                break;\n            case TextureFormat::RGBA8Snorm:\n                s->Append(\"RGBA8Snorm\");\n                break;\n            case TextureFormat::RGBA8Uint:\n                s->Append(\"RGBA8Uint\");\n                break;\n            case TextureFormat::RGBA8Sint:\n                s->Append(\"RGBA8Sint\");\n                break;\n            case TextureFormat::BGRA8Unorm:\n                s->Append(\"BGRA8Unorm\");\n                break;\n            case TextureFormat::BGRA8UnormSrgb:\n                s->Append(\"BGRA8UnormSrgb\");\n                break;\n            case TextureFormat::RGB10A2Unorm:\n                s->Append(\"RGB10A2Unorm\");\n                break;\n            case TextureFormat::RG11B10Ufloat:\n                s->Append(\"RG11B10Ufloat\");\n                break;\n            case TextureFormat::RGB9E5Ufloat:\n                s->Append(\"RGB9E5Ufloat\");\n                break;\n            case TextureFormat::RG32Float:\n                s->Append(\"RG32Float\");\n                break;\n            case TextureFormat::RG32Uint:\n                s->Append(\"RG32Uint\");\n                break;\n            case TextureFormat::RG32Sint:\n                s->Append(\"RG32Sint\");\n                break;\n            case TextureFormat::RGBA16Uint:\n                s->Append(\"RGBA16Uint\");\n                break;\n            case TextureFormat::RGBA16Sint:\n                s->Append(\"RGBA16Sint\");\n                break;\n            case TextureFormat::RGBA16Float:\n                s->Append(\"RGBA16Float\");\n                break;\n            case TextureFormat::RGBA32Float:\n                s->Append(\"RGBA32Float\");\n                break;\n            case TextureFormat::RGBA32Uint:\n                s->Append(\"RGBA32Uint\");\n                break;\n            case TextureFormat::RGBA32Sint:\n                s->Append(\"RGBA32Sint\");\n                break;\n            case TextureFormat::Stencil8:\n                s->Append(\"Stencil8\");\n                break;\n            case TextureFormat::Depth16Unorm:\n                s->Append(\"Depth16Unorm\");\n                break;\n            case TextureFormat::Depth24Plus:\n                s->Append(\"Depth24Plus\");\n                break;\n            case TextureFormat::Depth24PlusStencil8:\n                s->Append(\"Depth24PlusStencil8\");\n                break;\n            case TextureFormat::Depth32Float:\n                s->Append(\"Depth32Float\");\n                break;\n            case TextureFormat::Depth32FloatStencil8:\n                s->Append(\"Depth32FloatStencil8\");\n                break;\n            case TextureFormat::BC1RGBAUnorm:\n                s->Append(\"BC1RGBAUnorm\");\n                break;\n            case TextureFormat::BC1RGBAUnormSrgb:\n                s->Append(\"BC1RGBAUnormSrgb\");\n                break;\n            case TextureFormat::BC2RGBAUnorm:\n                s->Append(\"BC2RGBAUnorm\");\n                break;\n            case TextureFormat::BC2RGBAUnormSrgb:\n                s->Append(\"BC2RGBAUnormSrgb\");\n                break;\n            case TextureFormat::BC3RGBAUnorm:\n                s->Append(\"BC3RGBAUnorm\");\n                break;\n            case TextureFormat::BC3RGBAUnormSrgb:\n                s->Append(\"BC3RGBAUnormSrgb\");\n                break;\n            case TextureFormat::BC4RUnorm:\n                s->Append(\"BC4RUnorm\");\n                break;\n            case TextureFormat::BC4RSnorm:\n                s->Append(\"BC4RSnorm\");\n                break;\n            case TextureFormat::BC5RGUnorm:\n                s->Append(\"BC5RGUnorm\");\n                break;\n            case TextureFormat::BC5RGSnorm:\n                s->Append(\"BC5RGSnorm\");\n                break;\n            case TextureFormat::BC6HRGBUfloat:\n                s->Append(\"BC6HRGBUfloat\");\n                break;\n            case TextureFormat::BC6HRGBFloat:\n                s->Append(\"BC6HRGBFloat\");\n                break;\n            case TextureFormat::BC7RGBAUnorm:\n                s->Append(\"BC7RGBAUnorm\");\n                break;\n            case TextureFormat::BC7RGBAUnormSrgb:\n                s->Append(\"BC7RGBAUnormSrgb\");\n                break;\n            case TextureFormat::ETC2RGB8Unorm:\n                s->Append(\"ETC2RGB8Unorm\");\n                break;\n            case TextureFormat::ETC2RGB8UnormSrgb:\n                s->Append(\"ETC2RGB8UnormSrgb\");\n                break;\n            case TextureFormat::ETC2RGB8A1Unorm:\n                s->Append(\"ETC2RGB8A1Unorm\");\n                break;\n            case TextureFormat::ETC2RGB8A1UnormSrgb:\n                s->Append(\"ETC2RGB8A1UnormSrgb\");\n                break;\n            case TextureFormat::ETC2RGBA8Unorm:\n                s->Append(\"ETC2RGBA8Unorm\");\n                break;\n            case TextureFormat::ETC2RGBA8UnormSrgb:\n                s->Append(\"ETC2RGBA8UnormSrgb\");\n                break;\n            case TextureFormat::EACR11Unorm:\n                s->Append(\"EACR11Unorm\");\n                break;\n            case TextureFormat::EACR11Snorm:\n                s->Append(\"EACR11Snorm\");\n                break;\n            case TextureFormat::EACRG11Unorm:\n                s->Append(\"EACRG11Unorm\");\n                break;\n            case TextureFormat::EACRG11Snorm:\n                s->Append(\"EACRG11Snorm\");\n                break;\n            case TextureFormat::ASTC4x4Unorm:\n                s->Append(\"ASTC4x4Unorm\");\n                break;\n            case TextureFormat::ASTC4x4UnormSrgb:\n                s->Append(\"ASTC4x4UnormSrgb\");\n                break;\n            case TextureFormat::ASTC5x4Unorm:\n                s->Append(\"ASTC5x4Unorm\");\n                break;\n            case TextureFormat::ASTC5x4UnormSrgb:\n                s->Append(\"ASTC5x4UnormSrgb\");\n                break;\n            case TextureFormat::ASTC5x5Unorm:\n                s->Append(\"ASTC5x5Unorm\");\n                break;\n            case TextureFormat::ASTC5x5UnormSrgb:\n                s->Append(\"ASTC5x5UnormSrgb\");\n                break;\n            case TextureFormat::ASTC6x5Unorm:\n                s->Append(\"ASTC6x5Unorm\");\n                break;\n            case TextureFormat::ASTC6x5UnormSrgb:\n                s->Append(\"ASTC6x5UnormSrgb\");\n                break;\n            case TextureFormat::ASTC6x6Unorm:\n                s->Append(\"ASTC6x6Unorm\");\n                break;\n            case TextureFormat::ASTC6x6UnormSrgb:\n                s->Append(\"ASTC6x6UnormSrgb\");\n                break;\n            case TextureFormat::ASTC8x5Unorm:\n                s->Append(\"ASTC8x5Unorm\");\n                break;\n            case TextureFormat::ASTC8x5UnormSrgb:\n                s->Append(\"ASTC8x5UnormSrgb\");\n                break;\n            case TextureFormat::ASTC8x6Unorm:\n                s->Append(\"ASTC8x6Unorm\");\n                break;\n            case TextureFormat::ASTC8x6UnormSrgb:\n                s->Append(\"ASTC8x6UnormSrgb\");\n                break;\n            case TextureFormat::ASTC8x8Unorm:\n                s->Append(\"ASTC8x8Unorm\");\n                break;\n            case TextureFormat::ASTC8x8UnormSrgb:\n                s->Append(\"ASTC8x8UnormSrgb\");\n                break;\n            case TextureFormat::ASTC10x5Unorm:\n                s->Append(\"ASTC10x5Unorm\");\n                break;\n            case TextureFormat::ASTC10x5UnormSrgb:\n                s->Append(\"ASTC10x5UnormSrgb\");\n                break;\n            case TextureFormat::ASTC10x6Unorm:\n                s->Append(\"ASTC10x6Unorm\");\n                break;\n            case TextureFormat::ASTC10x6UnormSrgb:\n                s->Append(\"ASTC10x6UnormSrgb\");\n                break;\n            case TextureFormat::ASTC10x8Unorm:\n                s->Append(\"ASTC10x8Unorm\");\n                break;\n            case TextureFormat::ASTC10x8UnormSrgb:\n                s->Append(\"ASTC10x8UnormSrgb\");\n                break;\n            case TextureFormat::ASTC10x10Unorm:\n                s->Append(\"ASTC10x10Unorm\");\n                break;\n            case TextureFormat::ASTC10x10UnormSrgb:\n                s->Append(\"ASTC10x10UnormSrgb\");\n                break;\n            case TextureFormat::ASTC12x10Unorm:\n                s->Append(\"ASTC12x10Unorm\");\n                break;\n            case TextureFormat::ASTC12x10UnormSrgb:\n                s->Append(\"ASTC12x10UnormSrgb\");\n                break;\n            case TextureFormat::ASTC12x12Unorm:\n                s->Append(\"ASTC12x12Unorm\");\n                break;\n            case TextureFormat::ASTC12x12UnormSrgb:\n                s->Append(\"ASTC12x12UnormSrgb\");\n                break;\n            case TextureFormat::R8BG8Biplanar420Unorm:\n                s->Append(\"R8BG8Biplanar420Unorm\");\n                break;\n            }\n        } else {\n            s->Append(absl::StrFormat(\"%u\", static_cast<typename std::underlying_type<TextureFormat>::type>(value)));\n        }\n        return {true};\n    }\n    absl::FormatConvertResult<absl::FormatConversionCharSet::kString|absl::FormatConversionCharSet::kIntegral>\n    AbslFormatConvert(TextureSampleType value,\n                      const absl::FormatConversionSpec& spec,\n                      absl::FormatSink* s) {\n        if (spec.conversion_char() == absl::FormatConversionChar::s) {\n            s->Append(\"TextureSampleType::\");\n            switch (value) {\n            case TextureSampleType::Undefined:\n                s->Append(\"Undefined\");\n                break;\n            case TextureSampleType::Float:\n                s->Append(\"Float\");\n                break;\n            case TextureSampleType::UnfilterableFloat:\n                s->Append(\"UnfilterableFloat\");\n                break;\n            case TextureSampleType::Depth:\n                s->Append(\"Depth\");\n                break;\n            case TextureSampleType::Sint:\n                s->Append(\"Sint\");\n                break;\n            case TextureSampleType::Uint:\n                s->Append(\"Uint\");\n                break;\n            }\n        } else {\n            s->Append(absl::StrFormat(\"%u\", static_cast<typename std::underlying_type<TextureSampleType>::type>(value)));\n        }\n        return {true};\n    }\n    absl::FormatConvertResult<absl::FormatConversionCharSet::kString|absl::FormatConversionCharSet::kIntegral>\n    AbslFormatConvert(TextureViewDimension value,\n                      const absl::FormatConversionSpec& spec,\n                      absl::FormatSink* s) {\n        if (spec.conversion_char() == absl::FormatConversionChar::s) {\n            s->Append(\"TextureViewDimension::\");\n            switch (value) {\n            case TextureViewDimension::Undefined:\n                s->Append(\"Undefined\");\n                break;\n            case TextureViewDimension::e1D:\n                s->Append(\"e1D\");\n                break;\n            case TextureViewDimension::e2D:\n                s->Append(\"e2D\");\n                break;\n            case TextureViewDimension::e2DArray:\n                s->Append(\"e2DArray\");\n                break;\n            case TextureViewDimension::Cube:\n                s->Append(\"Cube\");\n                break;\n            case TextureViewDimension::CubeArray:\n                s->Append(\"CubeArray\");\n                break;\n            case TextureViewDimension::e3D:\n                s->Append(\"e3D\");\n                break;\n            }\n        } else {\n            s->Append(absl::StrFormat(\"%u\", static_cast<typename std::underlying_type<TextureViewDimension>::type>(value)));\n        }\n        return {true};\n    }\n    absl::FormatConvertResult<absl::FormatConversionCharSet::kString|absl::FormatConversionCharSet::kIntegral>\n    AbslFormatConvert(VertexFormat value,\n                      const absl::FormatConversionSpec& spec,\n                      absl::FormatSink* s) {\n        if (spec.conversion_char() == absl::FormatConversionChar::s) {\n            s->Append(\"VertexFormat::\");\n            switch (value) {\n            case VertexFormat::Undefined:\n                s->Append(\"Undefined\");\n                break;\n            case VertexFormat::Uint8x2:\n                s->Append(\"Uint8x2\");\n                break;\n            case VertexFormat::Uint8x4:\n                s->Append(\"Uint8x4\");\n                break;\n            case VertexFormat::Sint8x2:\n                s->Append(\"Sint8x2\");\n                break;\n            case VertexFormat::Sint8x4:\n                s->Append(\"Sint8x4\");\n                break;\n            case VertexFormat::Unorm8x2:\n                s->Append(\"Unorm8x2\");\n                break;\n            case VertexFormat::Unorm8x4:\n                s->Append(\"Unorm8x4\");\n                break;\n            case VertexFormat::Snorm8x2:\n                s->Append(\"Snorm8x2\");\n                break;\n            case VertexFormat::Snorm8x4:\n                s->Append(\"Snorm8x4\");\n                break;\n            case VertexFormat::Uint16x2:\n                s->Append(\"Uint16x2\");\n                break;\n            case VertexFormat::Uint16x4:\n                s->Append(\"Uint16x4\");\n                break;\n            case VertexFormat::Sint16x2:\n                s->Append(\"Sint16x2\");\n                break;\n            case VertexFormat::Sint16x4:\n                s->Append(\"Sint16x4\");\n                break;\n            case VertexFormat::Unorm16x2:\n                s->Append(\"Unorm16x2\");\n                break;\n            case VertexFormat::Unorm16x4:\n                s->Append(\"Unorm16x4\");\n                break;\n            case VertexFormat::Snorm16x2:\n                s->Append(\"Snorm16x2\");\n                break;\n            case VertexFormat::Snorm16x4:\n                s->Append(\"Snorm16x4\");\n                break;\n            case VertexFormat::Float16x2:\n                s->Append(\"Float16x2\");\n                break;\n            case VertexFormat::Float16x4:\n                s->Append(\"Float16x4\");\n                break;\n            case VertexFormat::Float32:\n                s->Append(\"Float32\");\n                break;\n            case VertexFormat::Float32x2:\n                s->Append(\"Float32x2\");\n                break;\n            case VertexFormat::Float32x3:\n                s->Append(\"Float32x3\");\n                break;\n            case VertexFormat::Float32x4:\n                s->Append(\"Float32x4\");\n                break;\n            case VertexFormat::Uint32:\n                s->Append(\"Uint32\");\n                break;\n            case VertexFormat::Uint32x2:\n                s->Append(\"Uint32x2\");\n                break;\n            case VertexFormat::Uint32x3:\n                s->Append(\"Uint32x3\");\n                break;\n            case VertexFormat::Uint32x4:\n                s->Append(\"Uint32x4\");\n                break;\n            case VertexFormat::Sint32:\n                s->Append(\"Sint32\");\n                break;\n            case VertexFormat::Sint32x2:\n                s->Append(\"Sint32x2\");\n                break;\n            case VertexFormat::Sint32x3:\n                s->Append(\"Sint32x3\");\n                break;\n            case VertexFormat::Sint32x4:\n                s->Append(\"Sint32x4\");\n                break;\n            }\n        } else {\n            s->Append(absl::StrFormat(\"%u\", static_cast<typename std::underlying_type<VertexFormat>::type>(value)));\n        }\n        return {true};\n    }\n    absl::FormatConvertResult<absl::FormatConversionCharSet::kString|absl::FormatConversionCharSet::kIntegral>\n    AbslFormatConvert(VertexStepMode value,\n                      const absl::FormatConversionSpec& spec,\n                      absl::FormatSink* s) {\n        if (spec.conversion_char() == absl::FormatConversionChar::s) {\n            s->Append(\"VertexStepMode::\");\n            switch (value) {\n            case VertexStepMode::Vertex:\n                s->Append(\"Vertex\");\n                break;\n            case VertexStepMode::Instance:\n                s->Append(\"Instance\");\n                break;\n            case VertexStepMode::VertexBufferNotUsed:\n                s->Append(\"VertexBufferNotUsed\");\n                break;\n            }\n        } else {\n            s->Append(absl::StrFormat(\"%u\", static_cast<typename std::underlying_type<VertexStepMode>::type>(value)));\n        }\n        return {true};\n    }\n\n    //\n    // Bitmasks\n    //\n\n    absl::FormatConvertResult<absl::FormatConversionCharSet::kString|absl::FormatConversionCharSet::kIntegral>\n    AbslFormatConvert(BufferUsage value,\n                      const absl::FormatConversionSpec& spec,\n                      absl::FormatSink* s) {\n        if (spec.conversion_char() == absl::FormatConversionChar::s) {\n            s->Append(\"BufferUsage::\");\n            if (!static_cast<bool>(value)) {\n                // 0 is often explicitly declared as None.\n                s->Append(\"None\");\n                return {true};\n            }\n\n            bool moreThanOneBit = !HasZeroOrOneBits(value);\n            if (moreThanOneBit) {\n                s->Append(\"(\");\n            }\n\n            bool first = true;\n            if (value & BufferUsage::MapRead) {\n                if (!first) {\n                    s->Append(\"|\");\n                }\n                first = false;\n                s->Append(\"MapRead\");\n                value &= ~BufferUsage::MapRead;\n            }\n            if (value & BufferUsage::MapWrite) {\n                if (!first) {\n                    s->Append(\"|\");\n                }\n                first = false;\n                s->Append(\"MapWrite\");\n                value &= ~BufferUsage::MapWrite;\n            }\n            if (value & BufferUsage::CopySrc) {\n                if (!first) {\n                    s->Append(\"|\");\n                }\n                first = false;\n                s->Append(\"CopySrc\");\n                value &= ~BufferUsage::CopySrc;\n            }\n            if (value & BufferUsage::CopyDst) {\n                if (!first) {\n                    s->Append(\"|\");\n                }\n                first = false;\n                s->Append(\"CopyDst\");\n                value &= ~BufferUsage::CopyDst;\n            }\n            if (value & BufferUsage::Index) {\n                if (!first) {\n                    s->Append(\"|\");\n                }\n                first = false;\n                s->Append(\"Index\");\n                value &= ~BufferUsage::Index;\n            }\n            if (value & BufferUsage::Vertex) {\n                if (!first) {\n                    s->Append(\"|\");\n                }\n                first = false;\n                s->Append(\"Vertex\");\n                value &= ~BufferUsage::Vertex;\n            }\n            if (value & BufferUsage::Uniform) {\n                if (!first) {\n                    s->Append(\"|\");\n                }\n                first = false;\n                s->Append(\"Uniform\");\n                value &= ~BufferUsage::Uniform;\n            }\n            if (value & BufferUsage::Storage) {\n                if (!first) {\n                    s->Append(\"|\");\n                }\n                first = false;\n                s->Append(\"Storage\");\n                value &= ~BufferUsage::Storage;\n            }\n            if (value & BufferUsage::Indirect) {\n                if (!first) {\n                    s->Append(\"|\");\n                }\n                first = false;\n                s->Append(\"Indirect\");\n                value &= ~BufferUsage::Indirect;\n            }\n            if (value & BufferUsage::QueryResolve) {\n                if (!first) {\n                    s->Append(\"|\");\n                }\n                first = false;\n                s->Append(\"QueryResolve\");\n                value &= ~BufferUsage::QueryResolve;\n            }\n\n            if (static_cast<bool>(value)) {\n                if (!first) {\n                    s->Append(\"|\");\n                }\n                s->Append(absl::StrFormat(\"BufferUsage::%x\", static_cast<typename std::underlying_type<BufferUsage>::type>(value)));\n            }\n\n            if (moreThanOneBit) {\n                s->Append(\")\");\n            }\n        } else {\n            s->Append(absl::StrFormat(\"%u\", static_cast<typename std::underlying_type<BufferUsage>::type>(value)));\n        }\n        return {true};\n    }\n    absl::FormatConvertResult<absl::FormatConversionCharSet::kString|absl::FormatConversionCharSet::kIntegral>\n    AbslFormatConvert(ColorWriteMask value,\n                      const absl::FormatConversionSpec& spec,\n                      absl::FormatSink* s) {\n        if (spec.conversion_char() == absl::FormatConversionChar::s) {\n            s->Append(\"ColorWriteMask::\");\n            if (!static_cast<bool>(value)) {\n                // 0 is often explicitly declared as None.\n                s->Append(\"None\");\n                return {true};\n            }\n\n            bool moreThanOneBit = !HasZeroOrOneBits(value);\n            if (moreThanOneBit) {\n                s->Append(\"(\");\n            }\n\n            bool first = true;\n            if (value & ColorWriteMask::Red) {\n                if (!first) {\n                    s->Append(\"|\");\n                }\n                first = false;\n                s->Append(\"Red\");\n                value &= ~ColorWriteMask::Red;\n            }\n            if (value & ColorWriteMask::Green) {\n                if (!first) {\n                    s->Append(\"|\");\n                }\n                first = false;\n                s->Append(\"Green\");\n                value &= ~ColorWriteMask::Green;\n            }\n            if (value & ColorWriteMask::Blue) {\n                if (!first) {\n                    s->Append(\"|\");\n                }\n                first = false;\n                s->Append(\"Blue\");\n                value &= ~ColorWriteMask::Blue;\n            }\n            if (value & ColorWriteMask::Alpha) {\n                if (!first) {\n                    s->Append(\"|\");\n                }\n                first = false;\n                s->Append(\"Alpha\");\n                value &= ~ColorWriteMask::Alpha;\n            }\n            if (value & ColorWriteMask::All) {\n                if (!first) {\n                    s->Append(\"|\");\n                }\n                first = false;\n                s->Append(\"All\");\n                value &= ~ColorWriteMask::All;\n            }\n\n            if (static_cast<bool>(value)) {\n                if (!first) {\n                    s->Append(\"|\");\n                }\n                s->Append(absl::StrFormat(\"ColorWriteMask::%x\", static_cast<typename std::underlying_type<ColorWriteMask>::type>(value)));\n            }\n\n            if (moreThanOneBit) {\n                s->Append(\")\");\n            }\n        } else {\n            s->Append(absl::StrFormat(\"%u\", static_cast<typename std::underlying_type<ColorWriteMask>::type>(value)));\n        }\n        return {true};\n    }\n    absl::FormatConvertResult<absl::FormatConversionCharSet::kString|absl::FormatConversionCharSet::kIntegral>\n    AbslFormatConvert(MapMode value,\n                      const absl::FormatConversionSpec& spec,\n                      absl::FormatSink* s) {\n        if (spec.conversion_char() == absl::FormatConversionChar::s) {\n            s->Append(\"MapMode::\");\n            if (!static_cast<bool>(value)) {\n                // 0 is often explicitly declared as None.\n                s->Append(\"None\");\n                return {true};\n            }\n\n            bool moreThanOneBit = !HasZeroOrOneBits(value);\n            if (moreThanOneBit) {\n                s->Append(\"(\");\n            }\n\n            bool first = true;\n            if (value & MapMode::Read) {\n                if (!first) {\n                    s->Append(\"|\");\n                }\n                first = false;\n                s->Append(\"Read\");\n                value &= ~MapMode::Read;\n            }\n            if (value & MapMode::Write) {\n                if (!first) {\n                    s->Append(\"|\");\n                }\n                first = false;\n                s->Append(\"Write\");\n                value &= ~MapMode::Write;\n            }\n\n            if (static_cast<bool>(value)) {\n                if (!first) {\n                    s->Append(\"|\");\n                }\n                s->Append(absl::StrFormat(\"MapMode::%x\", static_cast<typename std::underlying_type<MapMode>::type>(value)));\n            }\n\n            if (moreThanOneBit) {\n                s->Append(\")\");\n            }\n        } else {\n            s->Append(absl::StrFormat(\"%u\", static_cast<typename std::underlying_type<MapMode>::type>(value)));\n        }\n        return {true};\n    }\n    absl::FormatConvertResult<absl::FormatConversionCharSet::kString|absl::FormatConversionCharSet::kIntegral>\n    AbslFormatConvert(ShaderStage value,\n                      const absl::FormatConversionSpec& spec,\n                      absl::FormatSink* s) {\n        if (spec.conversion_char() == absl::FormatConversionChar::s) {\n            s->Append(\"ShaderStage::\");\n            if (!static_cast<bool>(value)) {\n                // 0 is often explicitly declared as None.\n                s->Append(\"None\");\n                return {true};\n            }\n\n            bool moreThanOneBit = !HasZeroOrOneBits(value);\n            if (moreThanOneBit) {\n                s->Append(\"(\");\n            }\n\n            bool first = true;\n            if (value & ShaderStage::Vertex) {\n                if (!first) {\n                    s->Append(\"|\");\n                }\n                first = false;\n                s->Append(\"Vertex\");\n                value &= ~ShaderStage::Vertex;\n            }\n            if (value & ShaderStage::Fragment) {\n                if (!first) {\n                    s->Append(\"|\");\n                }\n                first = false;\n                s->Append(\"Fragment\");\n                value &= ~ShaderStage::Fragment;\n            }\n            if (value & ShaderStage::Compute) {\n                if (!first) {\n                    s->Append(\"|\");\n                }\n                first = false;\n                s->Append(\"Compute\");\n                value &= ~ShaderStage::Compute;\n            }\n\n            if (static_cast<bool>(value)) {\n                if (!first) {\n                    s->Append(\"|\");\n                }\n                s->Append(absl::StrFormat(\"ShaderStage::%x\", static_cast<typename std::underlying_type<ShaderStage>::type>(value)));\n            }\n\n            if (moreThanOneBit) {\n                s->Append(\")\");\n            }\n        } else {\n            s->Append(absl::StrFormat(\"%u\", static_cast<typename std::underlying_type<ShaderStage>::type>(value)));\n        }\n        return {true};\n    }\n    absl::FormatConvertResult<absl::FormatConversionCharSet::kString|absl::FormatConversionCharSet::kIntegral>\n    AbslFormatConvert(TextureUsage value,\n                      const absl::FormatConversionSpec& spec,\n                      absl::FormatSink* s) {\n        if (spec.conversion_char() == absl::FormatConversionChar::s) {\n            s->Append(\"TextureUsage::\");\n            if (!static_cast<bool>(value)) {\n                // 0 is often explicitly declared as None.\n                s->Append(\"None\");\n                return {true};\n            }\n\n            bool moreThanOneBit = !HasZeroOrOneBits(value);\n            if (moreThanOneBit) {\n                s->Append(\"(\");\n            }\n\n            bool first = true;\n            if (value & TextureUsage::CopySrc) {\n                if (!first) {\n                    s->Append(\"|\");\n                }\n                first = false;\n                s->Append(\"CopySrc\");\n                value &= ~TextureUsage::CopySrc;\n            }\n            if (value & TextureUsage::CopyDst) {\n                if (!first) {\n                    s->Append(\"|\");\n                }\n                first = false;\n                s->Append(\"CopyDst\");\n                value &= ~TextureUsage::CopyDst;\n            }\n            if (value & TextureUsage::TextureBinding) {\n                if (!first) {\n                    s->Append(\"|\");\n                }\n                first = false;\n                s->Append(\"TextureBinding\");\n                value &= ~TextureUsage::TextureBinding;\n            }\n            if (value & TextureUsage::StorageBinding) {\n                if (!first) {\n                    s->Append(\"|\");\n                }\n                first = false;\n                s->Append(\"StorageBinding\");\n                value &= ~TextureUsage::StorageBinding;\n            }\n            if (value & TextureUsage::RenderAttachment) {\n                if (!first) {\n                    s->Append(\"|\");\n                }\n                first = false;\n                s->Append(\"RenderAttachment\");\n                value &= ~TextureUsage::RenderAttachment;\n            }\n            if (value & TextureUsage::TransientAttachment) {\n                if (!first) {\n                    s->Append(\"|\");\n                }\n                first = false;\n                s->Append(\"TransientAttachment\");\n                value &= ~TextureUsage::TransientAttachment;\n            }\n\n            if (static_cast<bool>(value)) {\n                if (!first) {\n                    s->Append(\"|\");\n                }\n                s->Append(absl::StrFormat(\"TextureUsage::%x\", static_cast<typename std::underlying_type<TextureUsage>::type>(value)));\n            }\n\n            if (moreThanOneBit) {\n                s->Append(\")\");\n            }\n        } else {\n            s->Append(absl::StrFormat(\"%u\", static_cast<typename std::underlying_type<TextureUsage>::type>(value)));\n        }\n        return {true};\n    }\n\n}  // namespace wgpu\n", "src/dawn/native/webgpu_StreamImpl_autogen.cpp": "\n#include \"dawn/native/CacheKey.h\"\n#include \"dawn/native/dawn_platform.h\"\n\n#include <cstring>\n\nnamespace dawn::native {\n\n//\n// Streaming readers for wgpu structures.\n//\n\n//\n// Streaming writers for wgpu structures.\n//\n\n\ntemplate <>\nvoid stream::Stream<AdapterProperties>::Write(stream::Sink* sink, const AdapterProperties& t) {\n\n    StreamIn(sink, t.vendorID);\n\n    StreamIn(sink, Iterable(t.vendorName, strlen(t.vendorName)));\n\n    StreamIn(sink, Iterable(t.architecture, strlen(t.architecture)));\n\n    StreamIn(sink, t.deviceID);\n\n    StreamIn(sink, Iterable(t.name, strlen(t.name)));\n\n    StreamIn(sink, Iterable(t.driverDescription, strlen(t.driverDescription)));\n\n    StreamIn(sink, t.adapterType);\n\n    StreamIn(sink, t.backendType);\n\n    StreamIn(sink, t.compatibilityMode);\n\n}\n\ntemplate <>\nvoid stream::Stream<DawnCacheDeviceDescriptor>::Write(stream::Sink* sink, const DawnCacheDeviceDescriptor& t) {\n\n    StreamIn(sink, Iterable(t.isolationKey, strlen(t.isolationKey)));\n\n}\n\ntemplate <>\nMaybeError stream::Stream<Extent3D>::Read(stream::Source* source, Extent3D* t) {\n\n    DAWN_TRY(StreamOut(source, &t->width));\n\n    DAWN_TRY(StreamOut(source, &t->height));\n\n    DAWN_TRY(StreamOut(source, &t->depthOrArrayLayers));\n\n    return {};\n}\ntemplate <>\nvoid stream::Stream<Extent3D>::Write(stream::Sink* sink, const Extent3D& t) {\n\n    StreamIn(sink, t.width);\n\n    StreamIn(sink, t.height);\n\n    StreamIn(sink, t.depthOrArrayLayers);\n\n}\n\n} // namespace dawn::native\n", "src/dawn/native/ObjectType_autogen.h": "\n#ifndef DAWNNATIVE_OBJECTTPYE_AUTOGEN_H_\n#define DAWNNATIVE_OBJECTTPYE_AUTOGEN_H_\n\n#include \"dawn/common/ityp_array.h\"\n\n#include <cstdint>\n\nnamespace dawn::native {\n\n    enum class ObjectType : uint32_t {\n        Adapter,\n        BindGroup,\n        BindGroupLayout,\n        Buffer,\n        CommandBuffer,\n        CommandEncoder,\n        ComputePassEncoder,\n        ComputePipeline,\n        Device,\n        ExternalTexture,\n        Instance,\n        PipelineLayout,\n        QuerySet,\n        Queue,\n        RenderBundle,\n        RenderBundleEncoder,\n        RenderPassEncoder,\n        RenderPipeline,\n        Sampler,\n        ShaderModule,\n        Surface,\n        SwapChain,\n        Texture,\n        TextureView,\n    };\n\n    template <typename T>\n    using PerObjectType = ityp::array<ObjectType, T, 24>;\n\n    const char* ObjectTypeAsString(ObjectType type);\n\n} // namespace dawn::native\n\n\n#endif  // DAWNNATIVE_OBJECTTPYE_AUTOGEN_H_\n", "src/dawn/native/ObjectType_autogen.cpp": "\n#include \"dawn/native/ObjectType_autogen.h\"\n\nnamespace dawn::native {\n\n    const char* ObjectTypeAsString(ObjectType type) {\n        switch (type) {\n            case ObjectType::Adapter:\n                return \"Adapter\";\n            case ObjectType::BindGroup:\n                return \"BindGroup\";\n            case ObjectType::BindGroupLayout:\n                return \"BindGroupLayout\";\n            case ObjectType::Buffer:\n                return \"Buffer\";\n            case ObjectType::CommandBuffer:\n                return \"CommandBuffer\";\n            case ObjectType::CommandEncoder:\n                return \"CommandEncoder\";\n            case ObjectType::ComputePassEncoder:\n                return \"ComputePassEncoder\";\n            case ObjectType::ComputePipeline:\n                return \"ComputePipeline\";\n            case ObjectType::Device:\n                return \"Device\";\n            case ObjectType::ExternalTexture:\n                return \"ExternalTexture\";\n            case ObjectType::Instance:\n                return \"Instance\";\n            case ObjectType::PipelineLayout:\n                return \"PipelineLayout\";\n            case ObjectType::QuerySet:\n                return \"QuerySet\";\n            case ObjectType::Queue:\n                return \"Queue\";\n            case ObjectType::RenderBundle:\n                return \"RenderBundle\";\n            case ObjectType::RenderBundleEncoder:\n                return \"RenderBundleEncoder\";\n            case ObjectType::RenderPassEncoder:\n                return \"RenderPassEncoder\";\n            case ObjectType::RenderPipeline:\n                return \"RenderPipeline\";\n            case ObjectType::Sampler:\n                return \"Sampler\";\n            case ObjectType::ShaderModule:\n                return \"ShaderModule\";\n            case ObjectType::Surface:\n                return \"Surface\";\n            case ObjectType::SwapChain:\n                return \"SwapChain\";\n            case ObjectType::Texture:\n                return \"Texture\";\n            case ObjectType::TextureView:\n                return \"TextureView\";\n            default:\n                UNREACHABLE();\n        }\n    }\n\n} // namespace dawn::native\n"}