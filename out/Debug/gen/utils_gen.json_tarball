{"src/dawn/native/ValidationUtils_autogen.h": "\n#ifndef BACKEND_VALIDATIONUTILS_H_\n#define BACKEND_VALIDATIONUTILS_H_\n\n#include \"dawn/webgpu_cpp.h\"\n\n#include \"dawn/native/Error.h\"\n\nnamespace dawn::native {\n\n    // Helper functions to check the value of enums and bitmasks\n    MaybeError ValidateAdapterType(wgpu::AdapterType value);\n    MaybeError ValidateAddressMode(wgpu::AddressMode value);\n    MaybeError ValidateAlphaMode(wgpu::AlphaMode value);\n    MaybeError ValidateBackendType(wgpu::BackendType value);\n    MaybeError ValidateBlendFactor(wgpu::BlendFactor value);\n    MaybeError ValidateBlendOperation(wgpu::BlendOperation value);\n    MaybeError ValidateBufferBindingType(wgpu::BufferBindingType value);\n    MaybeError ValidateBufferMapAsyncStatus(wgpu::BufferMapAsyncStatus value);\n    MaybeError ValidateCompareFunction(wgpu::CompareFunction value);\n    MaybeError ValidateCompilationInfoRequestStatus(wgpu::CompilationInfoRequestStatus value);\n    MaybeError ValidateCompilationMessageType(wgpu::CompilationMessageType value);\n    MaybeError ValidateCreatePipelineAsyncStatus(wgpu::CreatePipelineAsyncStatus value);\n    MaybeError ValidateCullMode(wgpu::CullMode value);\n    MaybeError ValidateDeviceLostReason(wgpu::DeviceLostReason value);\n    MaybeError ValidateErrorFilter(wgpu::ErrorFilter value);\n    MaybeError ValidateErrorType(wgpu::ErrorType value);\n    MaybeError ValidateFeatureName(wgpu::FeatureName value);\n    MaybeError ValidateFilterMode(wgpu::FilterMode value);\n    MaybeError ValidateFrontFace(wgpu::FrontFace value);\n    MaybeError ValidateIndexFormat(wgpu::IndexFormat value);\n    MaybeError ValidateLoadOp(wgpu::LoadOp value);\n    MaybeError ValidateLoggingType(wgpu::LoggingType value);\n    MaybeError ValidatePipelineStatisticName(wgpu::PipelineStatisticName value);\n    MaybeError ValidatePowerPreference(wgpu::PowerPreference value);\n    MaybeError ValidatePredefinedColorSpace(wgpu::PredefinedColorSpace value);\n    MaybeError ValidatePresentMode(wgpu::PresentMode value);\n    MaybeError ValidatePrimitiveTopology(wgpu::PrimitiveTopology value);\n    MaybeError ValidateQueryType(wgpu::QueryType value);\n    MaybeError ValidateQueueWorkDoneStatus(wgpu::QueueWorkDoneStatus value);\n    MaybeError ValidateRequestAdapterStatus(wgpu::RequestAdapterStatus value);\n    MaybeError ValidateRequestDeviceStatus(wgpu::RequestDeviceStatus value);\n    MaybeError ValidateSType(wgpu::SType value);\n    MaybeError ValidateSamplerBindingType(wgpu::SamplerBindingType value);\n    MaybeError ValidateStencilOperation(wgpu::StencilOperation value);\n    MaybeError ValidateStorageTextureAccess(wgpu::StorageTextureAccess value);\n    MaybeError ValidateStoreOp(wgpu::StoreOp value);\n    MaybeError ValidateTextureAspect(wgpu::TextureAspect value);\n    MaybeError ValidateTextureComponentType(wgpu::TextureComponentType value);\n    MaybeError ValidateTextureDimension(wgpu::TextureDimension value);\n    MaybeError ValidateTextureFormat(wgpu::TextureFormat value);\n    MaybeError ValidateTextureSampleType(wgpu::TextureSampleType value);\n    MaybeError ValidateTextureViewDimension(wgpu::TextureViewDimension value);\n    MaybeError ValidateVertexFormat(wgpu::VertexFormat value);\n    MaybeError ValidateVertexStepMode(wgpu::VertexStepMode value);\n    MaybeError ValidateBufferUsage(wgpu::BufferUsage value);\n    MaybeError ValidateColorWriteMask(wgpu::ColorWriteMask value);\n    MaybeError ValidateMapMode(wgpu::MapMode value);\n    MaybeError ValidateShaderStage(wgpu::ShaderStage value);\n    MaybeError ValidateTextureUsage(wgpu::TextureUsage value);\n\n} // namespace dawn::native\n\n#endif  // BACKEND_VALIDATIONUTILS_H_\n", "src/dawn/native/ValidationUtils_autogen.cpp": "\n#include \"dawn/native/ValidationUtils_autogen.h\"\n\nnamespace dawn::native {\n\n    MaybeError ValidateAdapterType(wgpu::AdapterType value) {\n        switch (value) {\n            case wgpu::AdapterType::DiscreteGPU:\n                return {};\n            case wgpu::AdapterType::IntegratedGPU:\n                return {};\n            case wgpu::AdapterType::CPU:\n                return {};\n            case wgpu::AdapterType::Unknown:\n                return {};\n            default:\n                return DAWN_VALIDATION_ERROR(\"Invalid value for WGPUAdapterType\");\n        }\n    }\n\n    MaybeError ValidateAddressMode(wgpu::AddressMode value) {\n        switch (value) {\n            case wgpu::AddressMode::Repeat:\n                return {};\n            case wgpu::AddressMode::MirrorRepeat:\n                return {};\n            case wgpu::AddressMode::ClampToEdge:\n                return {};\n            default:\n                return DAWN_VALIDATION_ERROR(\"Invalid value for WGPUAddressMode\");\n        }\n    }\n\n    MaybeError ValidateAlphaMode(wgpu::AlphaMode value) {\n        switch (value) {\n            case wgpu::AlphaMode::Premultiplied:\n                return {};\n            case wgpu::AlphaMode::Unpremultiplied:\n                return {};\n            default:\n                return DAWN_VALIDATION_ERROR(\"Invalid value for WGPUAlphaMode\");\n        }\n    }\n\n    MaybeError ValidateBackendType(wgpu::BackendType value) {\n        switch (value) {\n            case wgpu::BackendType::Null:\n                return {};\n            case wgpu::BackendType::WebGPU:\n                return {};\n            case wgpu::BackendType::D3D11:\n                return {};\n            case wgpu::BackendType::D3D12:\n                return {};\n            case wgpu::BackendType::Metal:\n                return {};\n            case wgpu::BackendType::Vulkan:\n                return {};\n            case wgpu::BackendType::OpenGL:\n                return {};\n            case wgpu::BackendType::OpenGLES:\n                return {};\n            default:\n                return DAWN_VALIDATION_ERROR(\"Invalid value for WGPUBackendType\");\n        }\n    }\n\n    MaybeError ValidateBlendFactor(wgpu::BlendFactor value) {\n        switch (value) {\n            case wgpu::BlendFactor::Zero:\n                return {};\n            case wgpu::BlendFactor::One:\n                return {};\n            case wgpu::BlendFactor::Src:\n                return {};\n            case wgpu::BlendFactor::OneMinusSrc:\n                return {};\n            case wgpu::BlendFactor::SrcAlpha:\n                return {};\n            case wgpu::BlendFactor::OneMinusSrcAlpha:\n                return {};\n            case wgpu::BlendFactor::Dst:\n                return {};\n            case wgpu::BlendFactor::OneMinusDst:\n                return {};\n            case wgpu::BlendFactor::DstAlpha:\n                return {};\n            case wgpu::BlendFactor::OneMinusDstAlpha:\n                return {};\n            case wgpu::BlendFactor::SrcAlphaSaturated:\n                return {};\n            case wgpu::BlendFactor::Constant:\n                return {};\n            case wgpu::BlendFactor::OneMinusConstant:\n                return {};\n            default:\n                return DAWN_VALIDATION_ERROR(\"Invalid value for WGPUBlendFactor\");\n        }\n    }\n\n    MaybeError ValidateBlendOperation(wgpu::BlendOperation value) {\n        switch (value) {\n            case wgpu::BlendOperation::Add:\n                return {};\n            case wgpu::BlendOperation::Subtract:\n                return {};\n            case wgpu::BlendOperation::ReverseSubtract:\n                return {};\n            case wgpu::BlendOperation::Min:\n                return {};\n            case wgpu::BlendOperation::Max:\n                return {};\n            default:\n                return DAWN_VALIDATION_ERROR(\"Invalid value for WGPUBlendOperation\");\n        }\n    }\n\n    MaybeError ValidateBufferBindingType(wgpu::BufferBindingType value) {\n        switch (value) {\n            case wgpu::BufferBindingType::Uniform:\n                return {};\n            case wgpu::BufferBindingType::Storage:\n                return {};\n            case wgpu::BufferBindingType::ReadOnlyStorage:\n                return {};\n            default:\n                return DAWN_VALIDATION_ERROR(\"Invalid value for WGPUBufferBindingType\");\n        }\n    }\n\n    MaybeError ValidateBufferMapAsyncStatus(wgpu::BufferMapAsyncStatus value) {\n        switch (value) {\n            case wgpu::BufferMapAsyncStatus::Success:\n                return {};\n            case wgpu::BufferMapAsyncStatus::Error:\n                return {};\n            case wgpu::BufferMapAsyncStatus::Unknown:\n                return {};\n            case wgpu::BufferMapAsyncStatus::DeviceLost:\n                return {};\n            case wgpu::BufferMapAsyncStatus::DestroyedBeforeCallback:\n                return {};\n            case wgpu::BufferMapAsyncStatus::UnmappedBeforeCallback:\n                return {};\n            default:\n                return DAWN_VALIDATION_ERROR(\"Invalid value for WGPUBufferMapAsyncStatus\");\n        }\n    }\n\n    MaybeError ValidateCompareFunction(wgpu::CompareFunction value) {\n        switch (value) {\n            case wgpu::CompareFunction::Never:\n                return {};\n            case wgpu::CompareFunction::Less:\n                return {};\n            case wgpu::CompareFunction::LessEqual:\n                return {};\n            case wgpu::CompareFunction::Greater:\n                return {};\n            case wgpu::CompareFunction::GreaterEqual:\n                return {};\n            case wgpu::CompareFunction::Equal:\n                return {};\n            case wgpu::CompareFunction::NotEqual:\n                return {};\n            case wgpu::CompareFunction::Always:\n                return {};\n            default:\n                return DAWN_VALIDATION_ERROR(\"Invalid value for WGPUCompareFunction\");\n        }\n    }\n\n    MaybeError ValidateCompilationInfoRequestStatus(wgpu::CompilationInfoRequestStatus value) {\n        switch (value) {\n            case wgpu::CompilationInfoRequestStatus::Success:\n                return {};\n            case wgpu::CompilationInfoRequestStatus::Error:\n                return {};\n            case wgpu::CompilationInfoRequestStatus::DeviceLost:\n                return {};\n            case wgpu::CompilationInfoRequestStatus::Unknown:\n                return {};\n            default:\n                return DAWN_VALIDATION_ERROR(\"Invalid value for WGPUCompilationInfoRequestStatus\");\n        }\n    }\n\n    MaybeError ValidateCompilationMessageType(wgpu::CompilationMessageType value) {\n        switch (value) {\n            case wgpu::CompilationMessageType::Error:\n                return {};\n            case wgpu::CompilationMessageType::Warning:\n                return {};\n            case wgpu::CompilationMessageType::Info:\n                return {};\n            default:\n                return DAWN_VALIDATION_ERROR(\"Invalid value for WGPUCompilationMessageType\");\n        }\n    }\n\n    MaybeError ValidateCreatePipelineAsyncStatus(wgpu::CreatePipelineAsyncStatus value) {\n        switch (value) {\n            case wgpu::CreatePipelineAsyncStatus::Success:\n                return {};\n            case wgpu::CreatePipelineAsyncStatus::Error:\n                return {};\n            case wgpu::CreatePipelineAsyncStatus::DeviceLost:\n                return {};\n            case wgpu::CreatePipelineAsyncStatus::DeviceDestroyed:\n                return {};\n            case wgpu::CreatePipelineAsyncStatus::Unknown:\n                return {};\n            default:\n                return DAWN_VALIDATION_ERROR(\"Invalid value for WGPUCreatePipelineAsyncStatus\");\n        }\n    }\n\n    MaybeError ValidateCullMode(wgpu::CullMode value) {\n        switch (value) {\n            case wgpu::CullMode::None:\n                return {};\n            case wgpu::CullMode::Front:\n                return {};\n            case wgpu::CullMode::Back:\n                return {};\n            default:\n                return DAWN_VALIDATION_ERROR(\"Invalid value for WGPUCullMode\");\n        }\n    }\n\n    MaybeError ValidateDeviceLostReason(wgpu::DeviceLostReason value) {\n        switch (value) {\n            case wgpu::DeviceLostReason::Undefined:\n                return {};\n            case wgpu::DeviceLostReason::Destroyed:\n                return {};\n            default:\n                return DAWN_VALIDATION_ERROR(\"Invalid value for WGPUDeviceLostReason\");\n        }\n    }\n\n    MaybeError ValidateErrorFilter(wgpu::ErrorFilter value) {\n        switch (value) {\n            case wgpu::ErrorFilter::Validation:\n                return {};\n            case wgpu::ErrorFilter::OutOfMemory:\n                return {};\n            default:\n                return DAWN_VALIDATION_ERROR(\"Invalid value for WGPUErrorFilter\");\n        }\n    }\n\n    MaybeError ValidateErrorType(wgpu::ErrorType value) {\n        switch (value) {\n            case wgpu::ErrorType::NoError:\n                return {};\n            case wgpu::ErrorType::Validation:\n                return {};\n            case wgpu::ErrorType::OutOfMemory:\n                return {};\n            case wgpu::ErrorType::Unknown:\n                return {};\n            case wgpu::ErrorType::DeviceLost:\n                return {};\n            default:\n                return DAWN_VALIDATION_ERROR(\"Invalid value for WGPUErrorType\");\n        }\n    }\n\n    MaybeError ValidateFeatureName(wgpu::FeatureName value) {\n        switch (value) {\n            case wgpu::FeatureName::Undefined:\n                return {};\n            case wgpu::FeatureName::Depth24UnormStencil8:\n                return {};\n            case wgpu::FeatureName::Depth32FloatStencil8:\n                return {};\n            case wgpu::FeatureName::TimestampQuery:\n                return {};\n            case wgpu::FeatureName::PipelineStatisticsQuery:\n                return {};\n            case wgpu::FeatureName::TextureCompressionBC:\n                return {};\n            case wgpu::FeatureName::TextureCompressionETC2:\n                return {};\n            case wgpu::FeatureName::TextureCompressionASTC:\n                return {};\n            case wgpu::FeatureName::IndirectFirstInstance:\n                return {};\n            case wgpu::FeatureName::DepthClamping:\n                return {};\n            case wgpu::FeatureName::DawnShaderFloat16:\n                return {};\n            case wgpu::FeatureName::DawnInternalUsages:\n                return {};\n            case wgpu::FeatureName::DawnMultiPlanarFormats:\n                return {};\n            case wgpu::FeatureName::DawnNative:\n                return {};\n            default:\n                return DAWN_VALIDATION_ERROR(\"Invalid value for WGPUFeatureName\");\n        }\n    }\n\n    MaybeError ValidateFilterMode(wgpu::FilterMode value) {\n        switch (value) {\n            case wgpu::FilterMode::Nearest:\n                return {};\n            case wgpu::FilterMode::Linear:\n                return {};\n            default:\n                return DAWN_VALIDATION_ERROR(\"Invalid value for WGPUFilterMode\");\n        }\n    }\n\n    MaybeError ValidateFrontFace(wgpu::FrontFace value) {\n        switch (value) {\n            case wgpu::FrontFace::CCW:\n                return {};\n            case wgpu::FrontFace::CW:\n                return {};\n            default:\n                return DAWN_VALIDATION_ERROR(\"Invalid value for WGPUFrontFace\");\n        }\n    }\n\n    MaybeError ValidateIndexFormat(wgpu::IndexFormat value) {\n        switch (value) {\n            case wgpu::IndexFormat::Undefined:\n                return {};\n            case wgpu::IndexFormat::Uint16:\n                return {};\n            case wgpu::IndexFormat::Uint32:\n                return {};\n            default:\n                return DAWN_VALIDATION_ERROR(\"Invalid value for WGPUIndexFormat\");\n        }\n    }\n\n    MaybeError ValidateLoadOp(wgpu::LoadOp value) {\n        switch (value) {\n            case wgpu::LoadOp::Clear:\n                return {};\n            case wgpu::LoadOp::Load:\n                return {};\n            default:\n                return DAWN_VALIDATION_ERROR(\"Invalid value for WGPULoadOp\");\n        }\n    }\n\n    MaybeError ValidateLoggingType(wgpu::LoggingType value) {\n        switch (value) {\n            case wgpu::LoggingType::Verbose:\n                return {};\n            case wgpu::LoggingType::Info:\n                return {};\n            case wgpu::LoggingType::Warning:\n                return {};\n            case wgpu::LoggingType::Error:\n                return {};\n            default:\n                return DAWN_VALIDATION_ERROR(\"Invalid value for WGPULoggingType\");\n        }\n    }\n\n    MaybeError ValidatePipelineStatisticName(wgpu::PipelineStatisticName value) {\n        switch (value) {\n            case wgpu::PipelineStatisticName::VertexShaderInvocations:\n                return {};\n            case wgpu::PipelineStatisticName::ClipperInvocations:\n                return {};\n            case wgpu::PipelineStatisticName::ClipperPrimitivesOut:\n                return {};\n            case wgpu::PipelineStatisticName::FragmentShaderInvocations:\n                return {};\n            case wgpu::PipelineStatisticName::ComputeShaderInvocations:\n                return {};\n            default:\n                return DAWN_VALIDATION_ERROR(\"Invalid value for WGPUPipelineStatisticName\");\n        }\n    }\n\n    MaybeError ValidatePowerPreference(wgpu::PowerPreference value) {\n        switch (value) {\n            case wgpu::PowerPreference::Undefined:\n                return {};\n            case wgpu::PowerPreference::LowPower:\n                return {};\n            case wgpu::PowerPreference::HighPerformance:\n                return {};\n            default:\n                return DAWN_VALIDATION_ERROR(\"Invalid value for WGPUPowerPreference\");\n        }\n    }\n\n    MaybeError ValidatePredefinedColorSpace(wgpu::PredefinedColorSpace value) {\n        switch (value) {\n            case wgpu::PredefinedColorSpace::Undefined:\n                return {};\n            case wgpu::PredefinedColorSpace::Srgb:\n                return {};\n            default:\n                return DAWN_VALIDATION_ERROR(\"Invalid value for WGPUPredefinedColorSpace\");\n        }\n    }\n\n    MaybeError ValidatePresentMode(wgpu::PresentMode value) {\n        switch (value) {\n            case wgpu::PresentMode::Immediate:\n                return {};\n            case wgpu::PresentMode::Mailbox:\n                return {};\n            case wgpu::PresentMode::Fifo:\n                return {};\n            default:\n                return DAWN_VALIDATION_ERROR(\"Invalid value for WGPUPresentMode\");\n        }\n    }\n\n    MaybeError ValidatePrimitiveTopology(wgpu::PrimitiveTopology value) {\n        switch (value) {\n            case wgpu::PrimitiveTopology::PointList:\n                return {};\n            case wgpu::PrimitiveTopology::LineList:\n                return {};\n            case wgpu::PrimitiveTopology::LineStrip:\n                return {};\n            case wgpu::PrimitiveTopology::TriangleList:\n                return {};\n            case wgpu::PrimitiveTopology::TriangleStrip:\n                return {};\n            default:\n                return DAWN_VALIDATION_ERROR(\"Invalid value for WGPUPrimitiveTopology\");\n        }\n    }\n\n    MaybeError ValidateQueryType(wgpu::QueryType value) {\n        switch (value) {\n            case wgpu::QueryType::Occlusion:\n                return {};\n            case wgpu::QueryType::PipelineStatistics:\n                return {};\n            case wgpu::QueryType::Timestamp:\n                return {};\n            default:\n                return DAWN_VALIDATION_ERROR(\"Invalid value for WGPUQueryType\");\n        }\n    }\n\n    MaybeError ValidateQueueWorkDoneStatus(wgpu::QueueWorkDoneStatus value) {\n        switch (value) {\n            case wgpu::QueueWorkDoneStatus::Success:\n                return {};\n            case wgpu::QueueWorkDoneStatus::Error:\n                return {};\n            case wgpu::QueueWorkDoneStatus::Unknown:\n                return {};\n            case wgpu::QueueWorkDoneStatus::DeviceLost:\n                return {};\n            default:\n                return DAWN_VALIDATION_ERROR(\"Invalid value for WGPUQueueWorkDoneStatus\");\n        }\n    }\n\n    MaybeError ValidateRequestAdapterStatus(wgpu::RequestAdapterStatus value) {\n        switch (value) {\n            case wgpu::RequestAdapterStatus::Success:\n                return {};\n            case wgpu::RequestAdapterStatus::Unavailable:\n                return {};\n            case wgpu::RequestAdapterStatus::Error:\n                return {};\n            case wgpu::RequestAdapterStatus::Unknown:\n                return {};\n            default:\n                return DAWN_VALIDATION_ERROR(\"Invalid value for WGPURequestAdapterStatus\");\n        }\n    }\n\n    MaybeError ValidateRequestDeviceStatus(wgpu::RequestDeviceStatus value) {\n        switch (value) {\n            case wgpu::RequestDeviceStatus::Success:\n                return {};\n            case wgpu::RequestDeviceStatus::Error:\n                return {};\n            case wgpu::RequestDeviceStatus::Unknown:\n                return {};\n            default:\n                return DAWN_VALIDATION_ERROR(\"Invalid value for WGPURequestDeviceStatus\");\n        }\n    }\n\n    MaybeError ValidateSType(wgpu::SType value) {\n        switch (value) {\n            case wgpu::SType::SurfaceDescriptorFromMetalLayer:\n                return {};\n            case wgpu::SType::SurfaceDescriptorFromWindowsHWND:\n                return {};\n            case wgpu::SType::SurfaceDescriptorFromXlibWindow:\n                return {};\n            case wgpu::SType::SurfaceDescriptorFromCanvasHTMLSelector:\n                return {};\n            case wgpu::SType::ShaderModuleSPIRVDescriptor:\n                return {};\n            case wgpu::SType::ShaderModuleWGSLDescriptor:\n                return {};\n            case wgpu::SType::SurfaceDescriptorFromWindowsCoreWindow:\n                return {};\n            case wgpu::SType::ExternalTextureBindingEntry:\n                return {};\n            case wgpu::SType::ExternalTextureBindingLayout:\n                return {};\n            case wgpu::SType::SurfaceDescriptorFromWindowsSwapChainPanel:\n                return {};\n            case wgpu::SType::DawnTextureInternalUsageDescriptor:\n                return {};\n            case wgpu::SType::PrimitiveDepthClampingState:\n                return {};\n            case wgpu::SType::DawnTogglesDeviceDescriptor:\n                return {};\n            case wgpu::SType::DawnEncoderInternalUsageDescriptor:\n                return {};\n            case wgpu::SType::DawnInstanceDescriptor:\n                return {};\n            default:\n                return DAWN_VALIDATION_ERROR(\"Invalid value for WGPUSType\");\n        }\n    }\n\n    MaybeError ValidateSamplerBindingType(wgpu::SamplerBindingType value) {\n        switch (value) {\n            case wgpu::SamplerBindingType::Filtering:\n                return {};\n            case wgpu::SamplerBindingType::NonFiltering:\n                return {};\n            case wgpu::SamplerBindingType::Comparison:\n                return {};\n            default:\n                return DAWN_VALIDATION_ERROR(\"Invalid value for WGPUSamplerBindingType\");\n        }\n    }\n\n    MaybeError ValidateStencilOperation(wgpu::StencilOperation value) {\n        switch (value) {\n            case wgpu::StencilOperation::Keep:\n                return {};\n            case wgpu::StencilOperation::Zero:\n                return {};\n            case wgpu::StencilOperation::Replace:\n                return {};\n            case wgpu::StencilOperation::Invert:\n                return {};\n            case wgpu::StencilOperation::IncrementClamp:\n                return {};\n            case wgpu::StencilOperation::DecrementClamp:\n                return {};\n            case wgpu::StencilOperation::IncrementWrap:\n                return {};\n            case wgpu::StencilOperation::DecrementWrap:\n                return {};\n            default:\n                return DAWN_VALIDATION_ERROR(\"Invalid value for WGPUStencilOperation\");\n        }\n    }\n\n    MaybeError ValidateStorageTextureAccess(wgpu::StorageTextureAccess value) {\n        switch (value) {\n            case wgpu::StorageTextureAccess::WriteOnly:\n                return {};\n            default:\n                return DAWN_VALIDATION_ERROR(\"Invalid value for WGPUStorageTextureAccess\");\n        }\n    }\n\n    MaybeError ValidateStoreOp(wgpu::StoreOp value) {\n        switch (value) {\n            case wgpu::StoreOp::Store:\n                return {};\n            case wgpu::StoreOp::Discard:\n                return {};\n            default:\n                return DAWN_VALIDATION_ERROR(\"Invalid value for WGPUStoreOp\");\n        }\n    }\n\n    MaybeError ValidateTextureAspect(wgpu::TextureAspect value) {\n        switch (value) {\n            case wgpu::TextureAspect::All:\n                return {};\n            case wgpu::TextureAspect::StencilOnly:\n                return {};\n            case wgpu::TextureAspect::DepthOnly:\n                return {};\n            case wgpu::TextureAspect::Plane0Only:\n                return {};\n            case wgpu::TextureAspect::Plane1Only:\n                return {};\n            default:\n                return DAWN_VALIDATION_ERROR(\"Invalid value for WGPUTextureAspect\");\n        }\n    }\n\n    MaybeError ValidateTextureComponentType(wgpu::TextureComponentType value) {\n        switch (value) {\n            case wgpu::TextureComponentType::Float:\n                return {};\n            case wgpu::TextureComponentType::Sint:\n                return {};\n            case wgpu::TextureComponentType::Uint:\n                return {};\n            case wgpu::TextureComponentType::DepthComparison:\n                return {};\n            default:\n                return DAWN_VALIDATION_ERROR(\"Invalid value for WGPUTextureComponentType\");\n        }\n    }\n\n    MaybeError ValidateTextureDimension(wgpu::TextureDimension value) {\n        switch (value) {\n            case wgpu::TextureDimension::e1D:\n                return {};\n            case wgpu::TextureDimension::e2D:\n                return {};\n            case wgpu::TextureDimension::e3D:\n                return {};\n            default:\n                return DAWN_VALIDATION_ERROR(\"Invalid value for WGPUTextureDimension\");\n        }\n    }\n\n    MaybeError ValidateTextureFormat(wgpu::TextureFormat value) {\n        switch (value) {\n            case wgpu::TextureFormat::R8Unorm:\n                return {};\n            case wgpu::TextureFormat::R8Snorm:\n                return {};\n            case wgpu::TextureFormat::R8Uint:\n                return {};\n            case wgpu::TextureFormat::R8Sint:\n                return {};\n            case wgpu::TextureFormat::R16Uint:\n                return {};\n            case wgpu::TextureFormat::R16Sint:\n                return {};\n            case wgpu::TextureFormat::R16Float:\n                return {};\n            case wgpu::TextureFormat::RG8Unorm:\n                return {};\n            case wgpu::TextureFormat::RG8Snorm:\n                return {};\n            case wgpu::TextureFormat::RG8Uint:\n                return {};\n            case wgpu::TextureFormat::RG8Sint:\n                return {};\n            case wgpu::TextureFormat::R32Float:\n                return {};\n            case wgpu::TextureFormat::R32Uint:\n                return {};\n            case wgpu::TextureFormat::R32Sint:\n                return {};\n            case wgpu::TextureFormat::RG16Uint:\n                return {};\n            case wgpu::TextureFormat::RG16Sint:\n                return {};\n            case wgpu::TextureFormat::RG16Float:\n                return {};\n            case wgpu::TextureFormat::RGBA8Unorm:\n                return {};\n            case wgpu::TextureFormat::RGBA8UnormSrgb:\n                return {};\n            case wgpu::TextureFormat::RGBA8Snorm:\n                return {};\n            case wgpu::TextureFormat::RGBA8Uint:\n                return {};\n            case wgpu::TextureFormat::RGBA8Sint:\n                return {};\n            case wgpu::TextureFormat::BGRA8Unorm:\n                return {};\n            case wgpu::TextureFormat::BGRA8UnormSrgb:\n                return {};\n            case wgpu::TextureFormat::RGB10A2Unorm:\n                return {};\n            case wgpu::TextureFormat::RG11B10Ufloat:\n                return {};\n            case wgpu::TextureFormat::RGB9E5Ufloat:\n                return {};\n            case wgpu::TextureFormat::RG32Float:\n                return {};\n            case wgpu::TextureFormat::RG32Uint:\n                return {};\n            case wgpu::TextureFormat::RG32Sint:\n                return {};\n            case wgpu::TextureFormat::RGBA16Uint:\n                return {};\n            case wgpu::TextureFormat::RGBA16Sint:\n                return {};\n            case wgpu::TextureFormat::RGBA16Float:\n                return {};\n            case wgpu::TextureFormat::RGBA32Float:\n                return {};\n            case wgpu::TextureFormat::RGBA32Uint:\n                return {};\n            case wgpu::TextureFormat::RGBA32Sint:\n                return {};\n            case wgpu::TextureFormat::Stencil8:\n                return {};\n            case wgpu::TextureFormat::Depth16Unorm:\n                return {};\n            case wgpu::TextureFormat::Depth24Plus:\n                return {};\n            case wgpu::TextureFormat::Depth24PlusStencil8:\n                return {};\n            case wgpu::TextureFormat::Depth24UnormStencil8:\n                return {};\n            case wgpu::TextureFormat::Depth32Float:\n                return {};\n            case wgpu::TextureFormat::Depth32FloatStencil8:\n                return {};\n            case wgpu::TextureFormat::BC1RGBAUnorm:\n                return {};\n            case wgpu::TextureFormat::BC1RGBAUnormSrgb:\n                return {};\n            case wgpu::TextureFormat::BC2RGBAUnorm:\n                return {};\n            case wgpu::TextureFormat::BC2RGBAUnormSrgb:\n                return {};\n            case wgpu::TextureFormat::BC3RGBAUnorm:\n                return {};\n            case wgpu::TextureFormat::BC3RGBAUnormSrgb:\n                return {};\n            case wgpu::TextureFormat::BC4RUnorm:\n                return {};\n            case wgpu::TextureFormat::BC4RSnorm:\n                return {};\n            case wgpu::TextureFormat::BC5RGUnorm:\n                return {};\n            case wgpu::TextureFormat::BC5RGSnorm:\n                return {};\n            case wgpu::TextureFormat::BC6HRGBUfloat:\n                return {};\n            case wgpu::TextureFormat::BC6HRGBFloat:\n                return {};\n            case wgpu::TextureFormat::BC7RGBAUnorm:\n                return {};\n            case wgpu::TextureFormat::BC7RGBAUnormSrgb:\n                return {};\n            case wgpu::TextureFormat::ETC2RGB8Unorm:\n                return {};\n            case wgpu::TextureFormat::ETC2RGB8UnormSrgb:\n                return {};\n            case wgpu::TextureFormat::ETC2RGB8A1Unorm:\n                return {};\n            case wgpu::TextureFormat::ETC2RGB8A1UnormSrgb:\n                return {};\n            case wgpu::TextureFormat::ETC2RGBA8Unorm:\n                return {};\n            case wgpu::TextureFormat::ETC2RGBA8UnormSrgb:\n                return {};\n            case wgpu::TextureFormat::EACR11Unorm:\n                return {};\n            case wgpu::TextureFormat::EACR11Snorm:\n                return {};\n            case wgpu::TextureFormat::EACRG11Unorm:\n                return {};\n            case wgpu::TextureFormat::EACRG11Snorm:\n                return {};\n            case wgpu::TextureFormat::ASTC4x4Unorm:\n                return {};\n            case wgpu::TextureFormat::ASTC4x4UnormSrgb:\n                return {};\n            case wgpu::TextureFormat::ASTC5x4Unorm:\n                return {};\n            case wgpu::TextureFormat::ASTC5x4UnormSrgb:\n                return {};\n            case wgpu::TextureFormat::ASTC5x5Unorm:\n                return {};\n            case wgpu::TextureFormat::ASTC5x5UnormSrgb:\n                return {};\n            case wgpu::TextureFormat::ASTC6x5Unorm:\n                return {};\n            case wgpu::TextureFormat::ASTC6x5UnormSrgb:\n                return {};\n            case wgpu::TextureFormat::ASTC6x6Unorm:\n                return {};\n            case wgpu::TextureFormat::ASTC6x6UnormSrgb:\n                return {};\n            case wgpu::TextureFormat::ASTC8x5Unorm:\n                return {};\n            case wgpu::TextureFormat::ASTC8x5UnormSrgb:\n                return {};\n            case wgpu::TextureFormat::ASTC8x6Unorm:\n                return {};\n            case wgpu::TextureFormat::ASTC8x6UnormSrgb:\n                return {};\n            case wgpu::TextureFormat::ASTC8x8Unorm:\n                return {};\n            case wgpu::TextureFormat::ASTC8x8UnormSrgb:\n                return {};\n            case wgpu::TextureFormat::ASTC10x5Unorm:\n                return {};\n            case wgpu::TextureFormat::ASTC10x5UnormSrgb:\n                return {};\n            case wgpu::TextureFormat::ASTC10x6Unorm:\n                return {};\n            case wgpu::TextureFormat::ASTC10x6UnormSrgb:\n                return {};\n            case wgpu::TextureFormat::ASTC10x8Unorm:\n                return {};\n            case wgpu::TextureFormat::ASTC10x8UnormSrgb:\n                return {};\n            case wgpu::TextureFormat::ASTC10x10Unorm:\n                return {};\n            case wgpu::TextureFormat::ASTC10x10UnormSrgb:\n                return {};\n            case wgpu::TextureFormat::ASTC12x10Unorm:\n                return {};\n            case wgpu::TextureFormat::ASTC12x10UnormSrgb:\n                return {};\n            case wgpu::TextureFormat::ASTC12x12Unorm:\n                return {};\n            case wgpu::TextureFormat::ASTC12x12UnormSrgb:\n                return {};\n            case wgpu::TextureFormat::R8BG8Biplanar420Unorm:\n                return {};\n            default:\n                return DAWN_VALIDATION_ERROR(\"Invalid value for WGPUTextureFormat\");\n        }\n    }\n\n    MaybeError ValidateTextureSampleType(wgpu::TextureSampleType value) {\n        switch (value) {\n            case wgpu::TextureSampleType::Float:\n                return {};\n            case wgpu::TextureSampleType::UnfilterableFloat:\n                return {};\n            case wgpu::TextureSampleType::Depth:\n                return {};\n            case wgpu::TextureSampleType::Sint:\n                return {};\n            case wgpu::TextureSampleType::Uint:\n                return {};\n            default:\n                return DAWN_VALIDATION_ERROR(\"Invalid value for WGPUTextureSampleType\");\n        }\n    }\n\n    MaybeError ValidateTextureViewDimension(wgpu::TextureViewDimension value) {\n        switch (value) {\n            case wgpu::TextureViewDimension::e1D:\n                return {};\n            case wgpu::TextureViewDimension::e2D:\n                return {};\n            case wgpu::TextureViewDimension::e2DArray:\n                return {};\n            case wgpu::TextureViewDimension::Cube:\n                return {};\n            case wgpu::TextureViewDimension::CubeArray:\n                return {};\n            case wgpu::TextureViewDimension::e3D:\n                return {};\n            default:\n                return DAWN_VALIDATION_ERROR(\"Invalid value for WGPUTextureViewDimension\");\n        }\n    }\n\n    MaybeError ValidateVertexFormat(wgpu::VertexFormat value) {\n        switch (value) {\n            case wgpu::VertexFormat::Uint8x2:\n                return {};\n            case wgpu::VertexFormat::Uint8x4:\n                return {};\n            case wgpu::VertexFormat::Sint8x2:\n                return {};\n            case wgpu::VertexFormat::Sint8x4:\n                return {};\n            case wgpu::VertexFormat::Unorm8x2:\n                return {};\n            case wgpu::VertexFormat::Unorm8x4:\n                return {};\n            case wgpu::VertexFormat::Snorm8x2:\n                return {};\n            case wgpu::VertexFormat::Snorm8x4:\n                return {};\n            case wgpu::VertexFormat::Uint16x2:\n                return {};\n            case wgpu::VertexFormat::Uint16x4:\n                return {};\n            case wgpu::VertexFormat::Sint16x2:\n                return {};\n            case wgpu::VertexFormat::Sint16x4:\n                return {};\n            case wgpu::VertexFormat::Unorm16x2:\n                return {};\n            case wgpu::VertexFormat::Unorm16x4:\n                return {};\n            case wgpu::VertexFormat::Snorm16x2:\n                return {};\n            case wgpu::VertexFormat::Snorm16x4:\n                return {};\n            case wgpu::VertexFormat::Float16x2:\n                return {};\n            case wgpu::VertexFormat::Float16x4:\n                return {};\n            case wgpu::VertexFormat::Float32:\n                return {};\n            case wgpu::VertexFormat::Float32x2:\n                return {};\n            case wgpu::VertexFormat::Float32x3:\n                return {};\n            case wgpu::VertexFormat::Float32x4:\n                return {};\n            case wgpu::VertexFormat::Uint32:\n                return {};\n            case wgpu::VertexFormat::Uint32x2:\n                return {};\n            case wgpu::VertexFormat::Uint32x3:\n                return {};\n            case wgpu::VertexFormat::Uint32x4:\n                return {};\n            case wgpu::VertexFormat::Sint32:\n                return {};\n            case wgpu::VertexFormat::Sint32x2:\n                return {};\n            case wgpu::VertexFormat::Sint32x3:\n                return {};\n            case wgpu::VertexFormat::Sint32x4:\n                return {};\n            default:\n                return DAWN_VALIDATION_ERROR(\"Invalid value for WGPUVertexFormat\");\n        }\n    }\n\n    MaybeError ValidateVertexStepMode(wgpu::VertexStepMode value) {\n        switch (value) {\n            case wgpu::VertexStepMode::Vertex:\n                return {};\n            case wgpu::VertexStepMode::Instance:\n                return {};\n            default:\n                return DAWN_VALIDATION_ERROR(\"Invalid value for WGPUVertexStepMode\");\n        }\n    }\n\n\n    MaybeError ValidateBufferUsage(wgpu::BufferUsage value) {\n        if ((value & static_cast<wgpu::BufferUsage>(~1023)) == 0) {\n            return {};\n        }\n        return DAWN_VALIDATION_ERROR(\"Invalid value for WGPUBufferUsage\");\n    }\n\n    MaybeError ValidateColorWriteMask(wgpu::ColorWriteMask value) {\n        if ((value & static_cast<wgpu::ColorWriteMask>(~15)) == 0) {\n            return {};\n        }\n        return DAWN_VALIDATION_ERROR(\"Invalid value for WGPUColorWriteMask\");\n    }\n\n    MaybeError ValidateMapMode(wgpu::MapMode value) {\n        if ((value & static_cast<wgpu::MapMode>(~3)) == 0) {\n            return {};\n        }\n        return DAWN_VALIDATION_ERROR(\"Invalid value for WGPUMapMode\");\n    }\n\n    MaybeError ValidateShaderStage(wgpu::ShaderStage value) {\n        if ((value & static_cast<wgpu::ShaderStage>(~7)) == 0) {\n            return {};\n        }\n        return DAWN_VALIDATION_ERROR(\"Invalid value for WGPUShaderStage\");\n    }\n\n    MaybeError ValidateTextureUsage(wgpu::TextureUsage value) {\n        if ((value & static_cast<wgpu::TextureUsage>(~63)) == 0) {\n            return {};\n        }\n        return DAWN_VALIDATION_ERROR(\"Invalid value for WGPUTextureUsage\");\n    }\n\n\n} // namespace dawn::native\n", "src/dawn/native/dawn_platform_autogen.h": "\n#ifndef DAWNNATIVE_DAWN_PLATFORM_AUTOGEN_H_\n#define DAWNNATIVE_DAWN_PLATFORM_AUTOGEN_H_\n\n#include \"dawn/webgpu_cpp.h\"\n#include \"dawn/native/Forward.h\"\n\n// Use our autogenerated version of the wgpu structures that point to dawn::native object types\n// (wgpu::Buffer is dawn::native::BufferBase*)\n#include <dawn/native/wgpu_structs_autogen.h>\n\nnamespace dawn::native {\n\n    inline const WGPUAdapterProperties* ToAPI(const AdapterProperties* rhs) {\n        return reinterpret_cast<const WGPUAdapterProperties*>(rhs);\n    }\n\n    inline WGPUAdapterProperties* ToAPI(AdapterProperties* rhs) {\n        return reinterpret_cast<WGPUAdapterProperties*>(rhs);\n    }\n\n    inline const AdapterProperties* FromAPI(const WGPUAdapterProperties* rhs) {\n        return reinterpret_cast<const AdapterProperties*>(rhs);\n    }\n\n    inline AdapterProperties* FromAPI(WGPUAdapterProperties* rhs) {\n        return reinterpret_cast<AdapterProperties*>(rhs);\n    }\n    inline const WGPUBindGroupEntry* ToAPI(const BindGroupEntry* rhs) {\n        return reinterpret_cast<const WGPUBindGroupEntry*>(rhs);\n    }\n\n    inline WGPUBindGroupEntry* ToAPI(BindGroupEntry* rhs) {\n        return reinterpret_cast<WGPUBindGroupEntry*>(rhs);\n    }\n\n    inline const BindGroupEntry* FromAPI(const WGPUBindGroupEntry* rhs) {\n        return reinterpret_cast<const BindGroupEntry*>(rhs);\n    }\n\n    inline BindGroupEntry* FromAPI(WGPUBindGroupEntry* rhs) {\n        return reinterpret_cast<BindGroupEntry*>(rhs);\n    }\n    inline const WGPUBlendComponent* ToAPI(const BlendComponent* rhs) {\n        return reinterpret_cast<const WGPUBlendComponent*>(rhs);\n    }\n\n    inline WGPUBlendComponent* ToAPI(BlendComponent* rhs) {\n        return reinterpret_cast<WGPUBlendComponent*>(rhs);\n    }\n\n    inline const BlendComponent* FromAPI(const WGPUBlendComponent* rhs) {\n        return reinterpret_cast<const BlendComponent*>(rhs);\n    }\n\n    inline BlendComponent* FromAPI(WGPUBlendComponent* rhs) {\n        return reinterpret_cast<BlendComponent*>(rhs);\n    }\n    inline const WGPUBufferBindingLayout* ToAPI(const BufferBindingLayout* rhs) {\n        return reinterpret_cast<const WGPUBufferBindingLayout*>(rhs);\n    }\n\n    inline WGPUBufferBindingLayout* ToAPI(BufferBindingLayout* rhs) {\n        return reinterpret_cast<WGPUBufferBindingLayout*>(rhs);\n    }\n\n    inline const BufferBindingLayout* FromAPI(const WGPUBufferBindingLayout* rhs) {\n        return reinterpret_cast<const BufferBindingLayout*>(rhs);\n    }\n\n    inline BufferBindingLayout* FromAPI(WGPUBufferBindingLayout* rhs) {\n        return reinterpret_cast<BufferBindingLayout*>(rhs);\n    }\n    inline const WGPUBufferDescriptor* ToAPI(const BufferDescriptor* rhs) {\n        return reinterpret_cast<const WGPUBufferDescriptor*>(rhs);\n    }\n\n    inline WGPUBufferDescriptor* ToAPI(BufferDescriptor* rhs) {\n        return reinterpret_cast<WGPUBufferDescriptor*>(rhs);\n    }\n\n    inline const BufferDescriptor* FromAPI(const WGPUBufferDescriptor* rhs) {\n        return reinterpret_cast<const BufferDescriptor*>(rhs);\n    }\n\n    inline BufferDescriptor* FromAPI(WGPUBufferDescriptor* rhs) {\n        return reinterpret_cast<BufferDescriptor*>(rhs);\n    }\n    inline const WGPUColor* ToAPI(const Color* rhs) {\n        return reinterpret_cast<const WGPUColor*>(rhs);\n    }\n\n    inline WGPUColor* ToAPI(Color* rhs) {\n        return reinterpret_cast<WGPUColor*>(rhs);\n    }\n\n    inline const Color* FromAPI(const WGPUColor* rhs) {\n        return reinterpret_cast<const Color*>(rhs);\n    }\n\n    inline Color* FromAPI(WGPUColor* rhs) {\n        return reinterpret_cast<Color*>(rhs);\n    }\n    inline const WGPUCommandBufferDescriptor* ToAPI(const CommandBufferDescriptor* rhs) {\n        return reinterpret_cast<const WGPUCommandBufferDescriptor*>(rhs);\n    }\n\n    inline WGPUCommandBufferDescriptor* ToAPI(CommandBufferDescriptor* rhs) {\n        return reinterpret_cast<WGPUCommandBufferDescriptor*>(rhs);\n    }\n\n    inline const CommandBufferDescriptor* FromAPI(const WGPUCommandBufferDescriptor* rhs) {\n        return reinterpret_cast<const CommandBufferDescriptor*>(rhs);\n    }\n\n    inline CommandBufferDescriptor* FromAPI(WGPUCommandBufferDescriptor* rhs) {\n        return reinterpret_cast<CommandBufferDescriptor*>(rhs);\n    }\n    inline const WGPUCommandEncoderDescriptor* ToAPI(const CommandEncoderDescriptor* rhs) {\n        return reinterpret_cast<const WGPUCommandEncoderDescriptor*>(rhs);\n    }\n\n    inline WGPUCommandEncoderDescriptor* ToAPI(CommandEncoderDescriptor* rhs) {\n        return reinterpret_cast<WGPUCommandEncoderDescriptor*>(rhs);\n    }\n\n    inline const CommandEncoderDescriptor* FromAPI(const WGPUCommandEncoderDescriptor* rhs) {\n        return reinterpret_cast<const CommandEncoderDescriptor*>(rhs);\n    }\n\n    inline CommandEncoderDescriptor* FromAPI(WGPUCommandEncoderDescriptor* rhs) {\n        return reinterpret_cast<CommandEncoderDescriptor*>(rhs);\n    }\n    inline const WGPUCompilationMessage* ToAPI(const CompilationMessage* rhs) {\n        return reinterpret_cast<const WGPUCompilationMessage*>(rhs);\n    }\n\n    inline WGPUCompilationMessage* ToAPI(CompilationMessage* rhs) {\n        return reinterpret_cast<WGPUCompilationMessage*>(rhs);\n    }\n\n    inline const CompilationMessage* FromAPI(const WGPUCompilationMessage* rhs) {\n        return reinterpret_cast<const CompilationMessage*>(rhs);\n    }\n\n    inline CompilationMessage* FromAPI(WGPUCompilationMessage* rhs) {\n        return reinterpret_cast<CompilationMessage*>(rhs);\n    }\n    inline const WGPUComputePassDescriptor* ToAPI(const ComputePassDescriptor* rhs) {\n        return reinterpret_cast<const WGPUComputePassDescriptor*>(rhs);\n    }\n\n    inline WGPUComputePassDescriptor* ToAPI(ComputePassDescriptor* rhs) {\n        return reinterpret_cast<WGPUComputePassDescriptor*>(rhs);\n    }\n\n    inline const ComputePassDescriptor* FromAPI(const WGPUComputePassDescriptor* rhs) {\n        return reinterpret_cast<const ComputePassDescriptor*>(rhs);\n    }\n\n    inline ComputePassDescriptor* FromAPI(WGPUComputePassDescriptor* rhs) {\n        return reinterpret_cast<ComputePassDescriptor*>(rhs);\n    }\n    inline const WGPUConstantEntry* ToAPI(const ConstantEntry* rhs) {\n        return reinterpret_cast<const WGPUConstantEntry*>(rhs);\n    }\n\n    inline WGPUConstantEntry* ToAPI(ConstantEntry* rhs) {\n        return reinterpret_cast<WGPUConstantEntry*>(rhs);\n    }\n\n    inline const ConstantEntry* FromAPI(const WGPUConstantEntry* rhs) {\n        return reinterpret_cast<const ConstantEntry*>(rhs);\n    }\n\n    inline ConstantEntry* FromAPI(WGPUConstantEntry* rhs) {\n        return reinterpret_cast<ConstantEntry*>(rhs);\n    }\n    inline const WGPUCopyTextureForBrowserOptions* ToAPI(const CopyTextureForBrowserOptions* rhs) {\n        return reinterpret_cast<const WGPUCopyTextureForBrowserOptions*>(rhs);\n    }\n\n    inline WGPUCopyTextureForBrowserOptions* ToAPI(CopyTextureForBrowserOptions* rhs) {\n        return reinterpret_cast<WGPUCopyTextureForBrowserOptions*>(rhs);\n    }\n\n    inline const CopyTextureForBrowserOptions* FromAPI(const WGPUCopyTextureForBrowserOptions* rhs) {\n        return reinterpret_cast<const CopyTextureForBrowserOptions*>(rhs);\n    }\n\n    inline CopyTextureForBrowserOptions* FromAPI(WGPUCopyTextureForBrowserOptions* rhs) {\n        return reinterpret_cast<CopyTextureForBrowserOptions*>(rhs);\n    }\n    inline const WGPUDawnEncoderInternalUsageDescriptor* ToAPI(const DawnEncoderInternalUsageDescriptor* rhs) {\n        return reinterpret_cast<const WGPUDawnEncoderInternalUsageDescriptor*>(rhs);\n    }\n\n    inline WGPUDawnEncoderInternalUsageDescriptor* ToAPI(DawnEncoderInternalUsageDescriptor* rhs) {\n        return reinterpret_cast<WGPUDawnEncoderInternalUsageDescriptor*>(rhs);\n    }\n\n    inline const DawnEncoderInternalUsageDescriptor* FromAPI(const WGPUDawnEncoderInternalUsageDescriptor* rhs) {\n        return reinterpret_cast<const DawnEncoderInternalUsageDescriptor*>(rhs);\n    }\n\n    inline DawnEncoderInternalUsageDescriptor* FromAPI(WGPUDawnEncoderInternalUsageDescriptor* rhs) {\n        return reinterpret_cast<DawnEncoderInternalUsageDescriptor*>(rhs);\n    }\n    inline const WGPUDawnInstanceDescriptor* ToAPI(const DawnInstanceDescriptor* rhs) {\n        return reinterpret_cast<const WGPUDawnInstanceDescriptor*>(rhs);\n    }\n\n    inline WGPUDawnInstanceDescriptor* ToAPI(DawnInstanceDescriptor* rhs) {\n        return reinterpret_cast<WGPUDawnInstanceDescriptor*>(rhs);\n    }\n\n    inline const DawnInstanceDescriptor* FromAPI(const WGPUDawnInstanceDescriptor* rhs) {\n        return reinterpret_cast<const DawnInstanceDescriptor*>(rhs);\n    }\n\n    inline DawnInstanceDescriptor* FromAPI(WGPUDawnInstanceDescriptor* rhs) {\n        return reinterpret_cast<DawnInstanceDescriptor*>(rhs);\n    }\n    inline const WGPUDawnTextureInternalUsageDescriptor* ToAPI(const DawnTextureInternalUsageDescriptor* rhs) {\n        return reinterpret_cast<const WGPUDawnTextureInternalUsageDescriptor*>(rhs);\n    }\n\n    inline WGPUDawnTextureInternalUsageDescriptor* ToAPI(DawnTextureInternalUsageDescriptor* rhs) {\n        return reinterpret_cast<WGPUDawnTextureInternalUsageDescriptor*>(rhs);\n    }\n\n    inline const DawnTextureInternalUsageDescriptor* FromAPI(const WGPUDawnTextureInternalUsageDescriptor* rhs) {\n        return reinterpret_cast<const DawnTextureInternalUsageDescriptor*>(rhs);\n    }\n\n    inline DawnTextureInternalUsageDescriptor* FromAPI(WGPUDawnTextureInternalUsageDescriptor* rhs) {\n        return reinterpret_cast<DawnTextureInternalUsageDescriptor*>(rhs);\n    }\n    inline const WGPUDawnTogglesDeviceDescriptor* ToAPI(const DawnTogglesDeviceDescriptor* rhs) {\n        return reinterpret_cast<const WGPUDawnTogglesDeviceDescriptor*>(rhs);\n    }\n\n    inline WGPUDawnTogglesDeviceDescriptor* ToAPI(DawnTogglesDeviceDescriptor* rhs) {\n        return reinterpret_cast<WGPUDawnTogglesDeviceDescriptor*>(rhs);\n    }\n\n    inline const DawnTogglesDeviceDescriptor* FromAPI(const WGPUDawnTogglesDeviceDescriptor* rhs) {\n        return reinterpret_cast<const DawnTogglesDeviceDescriptor*>(rhs);\n    }\n\n    inline DawnTogglesDeviceDescriptor* FromAPI(WGPUDawnTogglesDeviceDescriptor* rhs) {\n        return reinterpret_cast<DawnTogglesDeviceDescriptor*>(rhs);\n    }\n    inline const WGPUExtent3D* ToAPI(const Extent3D* rhs) {\n        return reinterpret_cast<const WGPUExtent3D*>(rhs);\n    }\n\n    inline WGPUExtent3D* ToAPI(Extent3D* rhs) {\n        return reinterpret_cast<WGPUExtent3D*>(rhs);\n    }\n\n    inline const Extent3D* FromAPI(const WGPUExtent3D* rhs) {\n        return reinterpret_cast<const Extent3D*>(rhs);\n    }\n\n    inline Extent3D* FromAPI(WGPUExtent3D* rhs) {\n        return reinterpret_cast<Extent3D*>(rhs);\n    }\n    inline const WGPUExternalTextureBindingEntry* ToAPI(const ExternalTextureBindingEntry* rhs) {\n        return reinterpret_cast<const WGPUExternalTextureBindingEntry*>(rhs);\n    }\n\n    inline WGPUExternalTextureBindingEntry* ToAPI(ExternalTextureBindingEntry* rhs) {\n        return reinterpret_cast<WGPUExternalTextureBindingEntry*>(rhs);\n    }\n\n    inline const ExternalTextureBindingEntry* FromAPI(const WGPUExternalTextureBindingEntry* rhs) {\n        return reinterpret_cast<const ExternalTextureBindingEntry*>(rhs);\n    }\n\n    inline ExternalTextureBindingEntry* FromAPI(WGPUExternalTextureBindingEntry* rhs) {\n        return reinterpret_cast<ExternalTextureBindingEntry*>(rhs);\n    }\n    inline const WGPUExternalTextureBindingLayout* ToAPI(const ExternalTextureBindingLayout* rhs) {\n        return reinterpret_cast<const WGPUExternalTextureBindingLayout*>(rhs);\n    }\n\n    inline WGPUExternalTextureBindingLayout* ToAPI(ExternalTextureBindingLayout* rhs) {\n        return reinterpret_cast<WGPUExternalTextureBindingLayout*>(rhs);\n    }\n\n    inline const ExternalTextureBindingLayout* FromAPI(const WGPUExternalTextureBindingLayout* rhs) {\n        return reinterpret_cast<const ExternalTextureBindingLayout*>(rhs);\n    }\n\n    inline ExternalTextureBindingLayout* FromAPI(WGPUExternalTextureBindingLayout* rhs) {\n        return reinterpret_cast<ExternalTextureBindingLayout*>(rhs);\n    }\n    inline const WGPUExternalTextureDescriptor* ToAPI(const ExternalTextureDescriptor* rhs) {\n        return reinterpret_cast<const WGPUExternalTextureDescriptor*>(rhs);\n    }\n\n    inline WGPUExternalTextureDescriptor* ToAPI(ExternalTextureDescriptor* rhs) {\n        return reinterpret_cast<WGPUExternalTextureDescriptor*>(rhs);\n    }\n\n    inline const ExternalTextureDescriptor* FromAPI(const WGPUExternalTextureDescriptor* rhs) {\n        return reinterpret_cast<const ExternalTextureDescriptor*>(rhs);\n    }\n\n    inline ExternalTextureDescriptor* FromAPI(WGPUExternalTextureDescriptor* rhs) {\n        return reinterpret_cast<ExternalTextureDescriptor*>(rhs);\n    }\n    inline const WGPUInstanceDescriptor* ToAPI(const InstanceDescriptor* rhs) {\n        return reinterpret_cast<const WGPUInstanceDescriptor*>(rhs);\n    }\n\n    inline WGPUInstanceDescriptor* ToAPI(InstanceDescriptor* rhs) {\n        return reinterpret_cast<WGPUInstanceDescriptor*>(rhs);\n    }\n\n    inline const InstanceDescriptor* FromAPI(const WGPUInstanceDescriptor* rhs) {\n        return reinterpret_cast<const InstanceDescriptor*>(rhs);\n    }\n\n    inline InstanceDescriptor* FromAPI(WGPUInstanceDescriptor* rhs) {\n        return reinterpret_cast<InstanceDescriptor*>(rhs);\n    }\n    inline const WGPULimits* ToAPI(const Limits* rhs) {\n        return reinterpret_cast<const WGPULimits*>(rhs);\n    }\n\n    inline WGPULimits* ToAPI(Limits* rhs) {\n        return reinterpret_cast<WGPULimits*>(rhs);\n    }\n\n    inline const Limits* FromAPI(const WGPULimits* rhs) {\n        return reinterpret_cast<const Limits*>(rhs);\n    }\n\n    inline Limits* FromAPI(WGPULimits* rhs) {\n        return reinterpret_cast<Limits*>(rhs);\n    }\n    inline const WGPUMultisampleState* ToAPI(const MultisampleState* rhs) {\n        return reinterpret_cast<const WGPUMultisampleState*>(rhs);\n    }\n\n    inline WGPUMultisampleState* ToAPI(MultisampleState* rhs) {\n        return reinterpret_cast<WGPUMultisampleState*>(rhs);\n    }\n\n    inline const MultisampleState* FromAPI(const WGPUMultisampleState* rhs) {\n        return reinterpret_cast<const MultisampleState*>(rhs);\n    }\n\n    inline MultisampleState* FromAPI(WGPUMultisampleState* rhs) {\n        return reinterpret_cast<MultisampleState*>(rhs);\n    }\n    inline const WGPUOrigin3D* ToAPI(const Origin3D* rhs) {\n        return reinterpret_cast<const WGPUOrigin3D*>(rhs);\n    }\n\n    inline WGPUOrigin3D* ToAPI(Origin3D* rhs) {\n        return reinterpret_cast<WGPUOrigin3D*>(rhs);\n    }\n\n    inline const Origin3D* FromAPI(const WGPUOrigin3D* rhs) {\n        return reinterpret_cast<const Origin3D*>(rhs);\n    }\n\n    inline Origin3D* FromAPI(WGPUOrigin3D* rhs) {\n        return reinterpret_cast<Origin3D*>(rhs);\n    }\n    inline const WGPUPipelineLayoutDescriptor* ToAPI(const PipelineLayoutDescriptor* rhs) {\n        return reinterpret_cast<const WGPUPipelineLayoutDescriptor*>(rhs);\n    }\n\n    inline WGPUPipelineLayoutDescriptor* ToAPI(PipelineLayoutDescriptor* rhs) {\n        return reinterpret_cast<WGPUPipelineLayoutDescriptor*>(rhs);\n    }\n\n    inline const PipelineLayoutDescriptor* FromAPI(const WGPUPipelineLayoutDescriptor* rhs) {\n        return reinterpret_cast<const PipelineLayoutDescriptor*>(rhs);\n    }\n\n    inline PipelineLayoutDescriptor* FromAPI(WGPUPipelineLayoutDescriptor* rhs) {\n        return reinterpret_cast<PipelineLayoutDescriptor*>(rhs);\n    }\n    inline const WGPUPrimitiveDepthClampingState* ToAPI(const PrimitiveDepthClampingState* rhs) {\n        return reinterpret_cast<const WGPUPrimitiveDepthClampingState*>(rhs);\n    }\n\n    inline WGPUPrimitiveDepthClampingState* ToAPI(PrimitiveDepthClampingState* rhs) {\n        return reinterpret_cast<WGPUPrimitiveDepthClampingState*>(rhs);\n    }\n\n    inline const PrimitiveDepthClampingState* FromAPI(const WGPUPrimitiveDepthClampingState* rhs) {\n        return reinterpret_cast<const PrimitiveDepthClampingState*>(rhs);\n    }\n\n    inline PrimitiveDepthClampingState* FromAPI(WGPUPrimitiveDepthClampingState* rhs) {\n        return reinterpret_cast<PrimitiveDepthClampingState*>(rhs);\n    }\n    inline const WGPUPrimitiveState* ToAPI(const PrimitiveState* rhs) {\n        return reinterpret_cast<const WGPUPrimitiveState*>(rhs);\n    }\n\n    inline WGPUPrimitiveState* ToAPI(PrimitiveState* rhs) {\n        return reinterpret_cast<WGPUPrimitiveState*>(rhs);\n    }\n\n    inline const PrimitiveState* FromAPI(const WGPUPrimitiveState* rhs) {\n        return reinterpret_cast<const PrimitiveState*>(rhs);\n    }\n\n    inline PrimitiveState* FromAPI(WGPUPrimitiveState* rhs) {\n        return reinterpret_cast<PrimitiveState*>(rhs);\n    }\n    inline const WGPUQuerySetDescriptor* ToAPI(const QuerySetDescriptor* rhs) {\n        return reinterpret_cast<const WGPUQuerySetDescriptor*>(rhs);\n    }\n\n    inline WGPUQuerySetDescriptor* ToAPI(QuerySetDescriptor* rhs) {\n        return reinterpret_cast<WGPUQuerySetDescriptor*>(rhs);\n    }\n\n    inline const QuerySetDescriptor* FromAPI(const WGPUQuerySetDescriptor* rhs) {\n        return reinterpret_cast<const QuerySetDescriptor*>(rhs);\n    }\n\n    inline QuerySetDescriptor* FromAPI(WGPUQuerySetDescriptor* rhs) {\n        return reinterpret_cast<QuerySetDescriptor*>(rhs);\n    }\n    inline const WGPURenderBundleDescriptor* ToAPI(const RenderBundleDescriptor* rhs) {\n        return reinterpret_cast<const WGPURenderBundleDescriptor*>(rhs);\n    }\n\n    inline WGPURenderBundleDescriptor* ToAPI(RenderBundleDescriptor* rhs) {\n        return reinterpret_cast<WGPURenderBundleDescriptor*>(rhs);\n    }\n\n    inline const RenderBundleDescriptor* FromAPI(const WGPURenderBundleDescriptor* rhs) {\n        return reinterpret_cast<const RenderBundleDescriptor*>(rhs);\n    }\n\n    inline RenderBundleDescriptor* FromAPI(WGPURenderBundleDescriptor* rhs) {\n        return reinterpret_cast<RenderBundleDescriptor*>(rhs);\n    }\n    inline const WGPURenderBundleEncoderDescriptor* ToAPI(const RenderBundleEncoderDescriptor* rhs) {\n        return reinterpret_cast<const WGPURenderBundleEncoderDescriptor*>(rhs);\n    }\n\n    inline WGPURenderBundleEncoderDescriptor* ToAPI(RenderBundleEncoderDescriptor* rhs) {\n        return reinterpret_cast<WGPURenderBundleEncoderDescriptor*>(rhs);\n    }\n\n    inline const RenderBundleEncoderDescriptor* FromAPI(const WGPURenderBundleEncoderDescriptor* rhs) {\n        return reinterpret_cast<const RenderBundleEncoderDescriptor*>(rhs);\n    }\n\n    inline RenderBundleEncoderDescriptor* FromAPI(WGPURenderBundleEncoderDescriptor* rhs) {\n        return reinterpret_cast<RenderBundleEncoderDescriptor*>(rhs);\n    }\n    inline const WGPURenderPassDepthStencilAttachment* ToAPI(const RenderPassDepthStencilAttachment* rhs) {\n        return reinterpret_cast<const WGPURenderPassDepthStencilAttachment*>(rhs);\n    }\n\n    inline WGPURenderPassDepthStencilAttachment* ToAPI(RenderPassDepthStencilAttachment* rhs) {\n        return reinterpret_cast<WGPURenderPassDepthStencilAttachment*>(rhs);\n    }\n\n    inline const RenderPassDepthStencilAttachment* FromAPI(const WGPURenderPassDepthStencilAttachment* rhs) {\n        return reinterpret_cast<const RenderPassDepthStencilAttachment*>(rhs);\n    }\n\n    inline RenderPassDepthStencilAttachment* FromAPI(WGPURenderPassDepthStencilAttachment* rhs) {\n        return reinterpret_cast<RenderPassDepthStencilAttachment*>(rhs);\n    }\n    inline const WGPURequestAdapterOptions* ToAPI(const RequestAdapterOptions* rhs) {\n        return reinterpret_cast<const WGPURequestAdapterOptions*>(rhs);\n    }\n\n    inline WGPURequestAdapterOptions* ToAPI(RequestAdapterOptions* rhs) {\n        return reinterpret_cast<WGPURequestAdapterOptions*>(rhs);\n    }\n\n    inline const RequestAdapterOptions* FromAPI(const WGPURequestAdapterOptions* rhs) {\n        return reinterpret_cast<const RequestAdapterOptions*>(rhs);\n    }\n\n    inline RequestAdapterOptions* FromAPI(WGPURequestAdapterOptions* rhs) {\n        return reinterpret_cast<RequestAdapterOptions*>(rhs);\n    }\n    inline const WGPUSamplerBindingLayout* ToAPI(const SamplerBindingLayout* rhs) {\n        return reinterpret_cast<const WGPUSamplerBindingLayout*>(rhs);\n    }\n\n    inline WGPUSamplerBindingLayout* ToAPI(SamplerBindingLayout* rhs) {\n        return reinterpret_cast<WGPUSamplerBindingLayout*>(rhs);\n    }\n\n    inline const SamplerBindingLayout* FromAPI(const WGPUSamplerBindingLayout* rhs) {\n        return reinterpret_cast<const SamplerBindingLayout*>(rhs);\n    }\n\n    inline SamplerBindingLayout* FromAPI(WGPUSamplerBindingLayout* rhs) {\n        return reinterpret_cast<SamplerBindingLayout*>(rhs);\n    }\n    inline const WGPUSamplerDescriptor* ToAPI(const SamplerDescriptor* rhs) {\n        return reinterpret_cast<const WGPUSamplerDescriptor*>(rhs);\n    }\n\n    inline WGPUSamplerDescriptor* ToAPI(SamplerDescriptor* rhs) {\n        return reinterpret_cast<WGPUSamplerDescriptor*>(rhs);\n    }\n\n    inline const SamplerDescriptor* FromAPI(const WGPUSamplerDescriptor* rhs) {\n        return reinterpret_cast<const SamplerDescriptor*>(rhs);\n    }\n\n    inline SamplerDescriptor* FromAPI(WGPUSamplerDescriptor* rhs) {\n        return reinterpret_cast<SamplerDescriptor*>(rhs);\n    }\n    inline const WGPUShaderModuleDescriptor* ToAPI(const ShaderModuleDescriptor* rhs) {\n        return reinterpret_cast<const WGPUShaderModuleDescriptor*>(rhs);\n    }\n\n    inline WGPUShaderModuleDescriptor* ToAPI(ShaderModuleDescriptor* rhs) {\n        return reinterpret_cast<WGPUShaderModuleDescriptor*>(rhs);\n    }\n\n    inline const ShaderModuleDescriptor* FromAPI(const WGPUShaderModuleDescriptor* rhs) {\n        return reinterpret_cast<const ShaderModuleDescriptor*>(rhs);\n    }\n\n    inline ShaderModuleDescriptor* FromAPI(WGPUShaderModuleDescriptor* rhs) {\n        return reinterpret_cast<ShaderModuleDescriptor*>(rhs);\n    }\n    inline const WGPUShaderModuleSPIRVDescriptor* ToAPI(const ShaderModuleSPIRVDescriptor* rhs) {\n        return reinterpret_cast<const WGPUShaderModuleSPIRVDescriptor*>(rhs);\n    }\n\n    inline WGPUShaderModuleSPIRVDescriptor* ToAPI(ShaderModuleSPIRVDescriptor* rhs) {\n        return reinterpret_cast<WGPUShaderModuleSPIRVDescriptor*>(rhs);\n    }\n\n    inline const ShaderModuleSPIRVDescriptor* FromAPI(const WGPUShaderModuleSPIRVDescriptor* rhs) {\n        return reinterpret_cast<const ShaderModuleSPIRVDescriptor*>(rhs);\n    }\n\n    inline ShaderModuleSPIRVDescriptor* FromAPI(WGPUShaderModuleSPIRVDescriptor* rhs) {\n        return reinterpret_cast<ShaderModuleSPIRVDescriptor*>(rhs);\n    }\n    inline const WGPUShaderModuleWGSLDescriptor* ToAPI(const ShaderModuleWGSLDescriptor* rhs) {\n        return reinterpret_cast<const WGPUShaderModuleWGSLDescriptor*>(rhs);\n    }\n\n    inline WGPUShaderModuleWGSLDescriptor* ToAPI(ShaderModuleWGSLDescriptor* rhs) {\n        return reinterpret_cast<WGPUShaderModuleWGSLDescriptor*>(rhs);\n    }\n\n    inline const ShaderModuleWGSLDescriptor* FromAPI(const WGPUShaderModuleWGSLDescriptor* rhs) {\n        return reinterpret_cast<const ShaderModuleWGSLDescriptor*>(rhs);\n    }\n\n    inline ShaderModuleWGSLDescriptor* FromAPI(WGPUShaderModuleWGSLDescriptor* rhs) {\n        return reinterpret_cast<ShaderModuleWGSLDescriptor*>(rhs);\n    }\n    inline const WGPUStencilFaceState* ToAPI(const StencilFaceState* rhs) {\n        return reinterpret_cast<const WGPUStencilFaceState*>(rhs);\n    }\n\n    inline WGPUStencilFaceState* ToAPI(StencilFaceState* rhs) {\n        return reinterpret_cast<WGPUStencilFaceState*>(rhs);\n    }\n\n    inline const StencilFaceState* FromAPI(const WGPUStencilFaceState* rhs) {\n        return reinterpret_cast<const StencilFaceState*>(rhs);\n    }\n\n    inline StencilFaceState* FromAPI(WGPUStencilFaceState* rhs) {\n        return reinterpret_cast<StencilFaceState*>(rhs);\n    }\n    inline const WGPUStorageTextureBindingLayout* ToAPI(const StorageTextureBindingLayout* rhs) {\n        return reinterpret_cast<const WGPUStorageTextureBindingLayout*>(rhs);\n    }\n\n    inline WGPUStorageTextureBindingLayout* ToAPI(StorageTextureBindingLayout* rhs) {\n        return reinterpret_cast<WGPUStorageTextureBindingLayout*>(rhs);\n    }\n\n    inline const StorageTextureBindingLayout* FromAPI(const WGPUStorageTextureBindingLayout* rhs) {\n        return reinterpret_cast<const StorageTextureBindingLayout*>(rhs);\n    }\n\n    inline StorageTextureBindingLayout* FromAPI(WGPUStorageTextureBindingLayout* rhs) {\n        return reinterpret_cast<StorageTextureBindingLayout*>(rhs);\n    }\n    inline const WGPUSurfaceDescriptor* ToAPI(const SurfaceDescriptor* rhs) {\n        return reinterpret_cast<const WGPUSurfaceDescriptor*>(rhs);\n    }\n\n    inline WGPUSurfaceDescriptor* ToAPI(SurfaceDescriptor* rhs) {\n        return reinterpret_cast<WGPUSurfaceDescriptor*>(rhs);\n    }\n\n    inline const SurfaceDescriptor* FromAPI(const WGPUSurfaceDescriptor* rhs) {\n        return reinterpret_cast<const SurfaceDescriptor*>(rhs);\n    }\n\n    inline SurfaceDescriptor* FromAPI(WGPUSurfaceDescriptor* rhs) {\n        return reinterpret_cast<SurfaceDescriptor*>(rhs);\n    }\n    inline const WGPUSurfaceDescriptorFromCanvasHTMLSelector* ToAPI(const SurfaceDescriptorFromCanvasHTMLSelector* rhs) {\n        return reinterpret_cast<const WGPUSurfaceDescriptorFromCanvasHTMLSelector*>(rhs);\n    }\n\n    inline WGPUSurfaceDescriptorFromCanvasHTMLSelector* ToAPI(SurfaceDescriptorFromCanvasHTMLSelector* rhs) {\n        return reinterpret_cast<WGPUSurfaceDescriptorFromCanvasHTMLSelector*>(rhs);\n    }\n\n    inline const SurfaceDescriptorFromCanvasHTMLSelector* FromAPI(const WGPUSurfaceDescriptorFromCanvasHTMLSelector* rhs) {\n        return reinterpret_cast<const SurfaceDescriptorFromCanvasHTMLSelector*>(rhs);\n    }\n\n    inline SurfaceDescriptorFromCanvasHTMLSelector* FromAPI(WGPUSurfaceDescriptorFromCanvasHTMLSelector* rhs) {\n        return reinterpret_cast<SurfaceDescriptorFromCanvasHTMLSelector*>(rhs);\n    }\n    inline const WGPUSurfaceDescriptorFromMetalLayer* ToAPI(const SurfaceDescriptorFromMetalLayer* rhs) {\n        return reinterpret_cast<const WGPUSurfaceDescriptorFromMetalLayer*>(rhs);\n    }\n\n    inline WGPUSurfaceDescriptorFromMetalLayer* ToAPI(SurfaceDescriptorFromMetalLayer* rhs) {\n        return reinterpret_cast<WGPUSurfaceDescriptorFromMetalLayer*>(rhs);\n    }\n\n    inline const SurfaceDescriptorFromMetalLayer* FromAPI(const WGPUSurfaceDescriptorFromMetalLayer* rhs) {\n        return reinterpret_cast<const SurfaceDescriptorFromMetalLayer*>(rhs);\n    }\n\n    inline SurfaceDescriptorFromMetalLayer* FromAPI(WGPUSurfaceDescriptorFromMetalLayer* rhs) {\n        return reinterpret_cast<SurfaceDescriptorFromMetalLayer*>(rhs);\n    }\n    inline const WGPUSurfaceDescriptorFromWindowsCoreWindow* ToAPI(const SurfaceDescriptorFromWindowsCoreWindow* rhs) {\n        return reinterpret_cast<const WGPUSurfaceDescriptorFromWindowsCoreWindow*>(rhs);\n    }\n\n    inline WGPUSurfaceDescriptorFromWindowsCoreWindow* ToAPI(SurfaceDescriptorFromWindowsCoreWindow* rhs) {\n        return reinterpret_cast<WGPUSurfaceDescriptorFromWindowsCoreWindow*>(rhs);\n    }\n\n    inline const SurfaceDescriptorFromWindowsCoreWindow* FromAPI(const WGPUSurfaceDescriptorFromWindowsCoreWindow* rhs) {\n        return reinterpret_cast<const SurfaceDescriptorFromWindowsCoreWindow*>(rhs);\n    }\n\n    inline SurfaceDescriptorFromWindowsCoreWindow* FromAPI(WGPUSurfaceDescriptorFromWindowsCoreWindow* rhs) {\n        return reinterpret_cast<SurfaceDescriptorFromWindowsCoreWindow*>(rhs);\n    }\n    inline const WGPUSurfaceDescriptorFromWindowsHWND* ToAPI(const SurfaceDescriptorFromWindowsHWND* rhs) {\n        return reinterpret_cast<const WGPUSurfaceDescriptorFromWindowsHWND*>(rhs);\n    }\n\n    inline WGPUSurfaceDescriptorFromWindowsHWND* ToAPI(SurfaceDescriptorFromWindowsHWND* rhs) {\n        return reinterpret_cast<WGPUSurfaceDescriptorFromWindowsHWND*>(rhs);\n    }\n\n    inline const SurfaceDescriptorFromWindowsHWND* FromAPI(const WGPUSurfaceDescriptorFromWindowsHWND* rhs) {\n        return reinterpret_cast<const SurfaceDescriptorFromWindowsHWND*>(rhs);\n    }\n\n    inline SurfaceDescriptorFromWindowsHWND* FromAPI(WGPUSurfaceDescriptorFromWindowsHWND* rhs) {\n        return reinterpret_cast<SurfaceDescriptorFromWindowsHWND*>(rhs);\n    }\n    inline const WGPUSurfaceDescriptorFromWindowsSwapChainPanel* ToAPI(const SurfaceDescriptorFromWindowsSwapChainPanel* rhs) {\n        return reinterpret_cast<const WGPUSurfaceDescriptorFromWindowsSwapChainPanel*>(rhs);\n    }\n\n    inline WGPUSurfaceDescriptorFromWindowsSwapChainPanel* ToAPI(SurfaceDescriptorFromWindowsSwapChainPanel* rhs) {\n        return reinterpret_cast<WGPUSurfaceDescriptorFromWindowsSwapChainPanel*>(rhs);\n    }\n\n    inline const SurfaceDescriptorFromWindowsSwapChainPanel* FromAPI(const WGPUSurfaceDescriptorFromWindowsSwapChainPanel* rhs) {\n        return reinterpret_cast<const SurfaceDescriptorFromWindowsSwapChainPanel*>(rhs);\n    }\n\n    inline SurfaceDescriptorFromWindowsSwapChainPanel* FromAPI(WGPUSurfaceDescriptorFromWindowsSwapChainPanel* rhs) {\n        return reinterpret_cast<SurfaceDescriptorFromWindowsSwapChainPanel*>(rhs);\n    }\n    inline const WGPUSurfaceDescriptorFromXlibWindow* ToAPI(const SurfaceDescriptorFromXlibWindow* rhs) {\n        return reinterpret_cast<const WGPUSurfaceDescriptorFromXlibWindow*>(rhs);\n    }\n\n    inline WGPUSurfaceDescriptorFromXlibWindow* ToAPI(SurfaceDescriptorFromXlibWindow* rhs) {\n        return reinterpret_cast<WGPUSurfaceDescriptorFromXlibWindow*>(rhs);\n    }\n\n    inline const SurfaceDescriptorFromXlibWindow* FromAPI(const WGPUSurfaceDescriptorFromXlibWindow* rhs) {\n        return reinterpret_cast<const SurfaceDescriptorFromXlibWindow*>(rhs);\n    }\n\n    inline SurfaceDescriptorFromXlibWindow* FromAPI(WGPUSurfaceDescriptorFromXlibWindow* rhs) {\n        return reinterpret_cast<SurfaceDescriptorFromXlibWindow*>(rhs);\n    }\n    inline const WGPUSwapChainDescriptor* ToAPI(const SwapChainDescriptor* rhs) {\n        return reinterpret_cast<const WGPUSwapChainDescriptor*>(rhs);\n    }\n\n    inline WGPUSwapChainDescriptor* ToAPI(SwapChainDescriptor* rhs) {\n        return reinterpret_cast<WGPUSwapChainDescriptor*>(rhs);\n    }\n\n    inline const SwapChainDescriptor* FromAPI(const WGPUSwapChainDescriptor* rhs) {\n        return reinterpret_cast<const SwapChainDescriptor*>(rhs);\n    }\n\n    inline SwapChainDescriptor* FromAPI(WGPUSwapChainDescriptor* rhs) {\n        return reinterpret_cast<SwapChainDescriptor*>(rhs);\n    }\n    inline const WGPUTextureBindingLayout* ToAPI(const TextureBindingLayout* rhs) {\n        return reinterpret_cast<const WGPUTextureBindingLayout*>(rhs);\n    }\n\n    inline WGPUTextureBindingLayout* ToAPI(TextureBindingLayout* rhs) {\n        return reinterpret_cast<WGPUTextureBindingLayout*>(rhs);\n    }\n\n    inline const TextureBindingLayout* FromAPI(const WGPUTextureBindingLayout* rhs) {\n        return reinterpret_cast<const TextureBindingLayout*>(rhs);\n    }\n\n    inline TextureBindingLayout* FromAPI(WGPUTextureBindingLayout* rhs) {\n        return reinterpret_cast<TextureBindingLayout*>(rhs);\n    }\n    inline const WGPUTextureDataLayout* ToAPI(const TextureDataLayout* rhs) {\n        return reinterpret_cast<const WGPUTextureDataLayout*>(rhs);\n    }\n\n    inline WGPUTextureDataLayout* ToAPI(TextureDataLayout* rhs) {\n        return reinterpret_cast<WGPUTextureDataLayout*>(rhs);\n    }\n\n    inline const TextureDataLayout* FromAPI(const WGPUTextureDataLayout* rhs) {\n        return reinterpret_cast<const TextureDataLayout*>(rhs);\n    }\n\n    inline TextureDataLayout* FromAPI(WGPUTextureDataLayout* rhs) {\n        return reinterpret_cast<TextureDataLayout*>(rhs);\n    }\n    inline const WGPUTextureViewDescriptor* ToAPI(const TextureViewDescriptor* rhs) {\n        return reinterpret_cast<const WGPUTextureViewDescriptor*>(rhs);\n    }\n\n    inline WGPUTextureViewDescriptor* ToAPI(TextureViewDescriptor* rhs) {\n        return reinterpret_cast<WGPUTextureViewDescriptor*>(rhs);\n    }\n\n    inline const TextureViewDescriptor* FromAPI(const WGPUTextureViewDescriptor* rhs) {\n        return reinterpret_cast<const TextureViewDescriptor*>(rhs);\n    }\n\n    inline TextureViewDescriptor* FromAPI(WGPUTextureViewDescriptor* rhs) {\n        return reinterpret_cast<TextureViewDescriptor*>(rhs);\n    }\n    inline const WGPUVertexAttribute* ToAPI(const VertexAttribute* rhs) {\n        return reinterpret_cast<const WGPUVertexAttribute*>(rhs);\n    }\n\n    inline WGPUVertexAttribute* ToAPI(VertexAttribute* rhs) {\n        return reinterpret_cast<WGPUVertexAttribute*>(rhs);\n    }\n\n    inline const VertexAttribute* FromAPI(const WGPUVertexAttribute* rhs) {\n        return reinterpret_cast<const VertexAttribute*>(rhs);\n    }\n\n    inline VertexAttribute* FromAPI(WGPUVertexAttribute* rhs) {\n        return reinterpret_cast<VertexAttribute*>(rhs);\n    }\n    inline const WGPUBindGroupDescriptor* ToAPI(const BindGroupDescriptor* rhs) {\n        return reinterpret_cast<const WGPUBindGroupDescriptor*>(rhs);\n    }\n\n    inline WGPUBindGroupDescriptor* ToAPI(BindGroupDescriptor* rhs) {\n        return reinterpret_cast<WGPUBindGroupDescriptor*>(rhs);\n    }\n\n    inline const BindGroupDescriptor* FromAPI(const WGPUBindGroupDescriptor* rhs) {\n        return reinterpret_cast<const BindGroupDescriptor*>(rhs);\n    }\n\n    inline BindGroupDescriptor* FromAPI(WGPUBindGroupDescriptor* rhs) {\n        return reinterpret_cast<BindGroupDescriptor*>(rhs);\n    }\n    inline const WGPUBindGroupLayoutEntry* ToAPI(const BindGroupLayoutEntry* rhs) {\n        return reinterpret_cast<const WGPUBindGroupLayoutEntry*>(rhs);\n    }\n\n    inline WGPUBindGroupLayoutEntry* ToAPI(BindGroupLayoutEntry* rhs) {\n        return reinterpret_cast<WGPUBindGroupLayoutEntry*>(rhs);\n    }\n\n    inline const BindGroupLayoutEntry* FromAPI(const WGPUBindGroupLayoutEntry* rhs) {\n        return reinterpret_cast<const BindGroupLayoutEntry*>(rhs);\n    }\n\n    inline BindGroupLayoutEntry* FromAPI(WGPUBindGroupLayoutEntry* rhs) {\n        return reinterpret_cast<BindGroupLayoutEntry*>(rhs);\n    }\n    inline const WGPUBlendState* ToAPI(const BlendState* rhs) {\n        return reinterpret_cast<const WGPUBlendState*>(rhs);\n    }\n\n    inline WGPUBlendState* ToAPI(BlendState* rhs) {\n        return reinterpret_cast<WGPUBlendState*>(rhs);\n    }\n\n    inline const BlendState* FromAPI(const WGPUBlendState* rhs) {\n        return reinterpret_cast<const BlendState*>(rhs);\n    }\n\n    inline BlendState* FromAPI(WGPUBlendState* rhs) {\n        return reinterpret_cast<BlendState*>(rhs);\n    }\n    inline const WGPUCompilationInfo* ToAPI(const CompilationInfo* rhs) {\n        return reinterpret_cast<const WGPUCompilationInfo*>(rhs);\n    }\n\n    inline WGPUCompilationInfo* ToAPI(CompilationInfo* rhs) {\n        return reinterpret_cast<WGPUCompilationInfo*>(rhs);\n    }\n\n    inline const CompilationInfo* FromAPI(const WGPUCompilationInfo* rhs) {\n        return reinterpret_cast<const CompilationInfo*>(rhs);\n    }\n\n    inline CompilationInfo* FromAPI(WGPUCompilationInfo* rhs) {\n        return reinterpret_cast<CompilationInfo*>(rhs);\n    }\n    inline const WGPUDepthStencilState* ToAPI(const DepthStencilState* rhs) {\n        return reinterpret_cast<const WGPUDepthStencilState*>(rhs);\n    }\n\n    inline WGPUDepthStencilState* ToAPI(DepthStencilState* rhs) {\n        return reinterpret_cast<WGPUDepthStencilState*>(rhs);\n    }\n\n    inline const DepthStencilState* FromAPI(const WGPUDepthStencilState* rhs) {\n        return reinterpret_cast<const DepthStencilState*>(rhs);\n    }\n\n    inline DepthStencilState* FromAPI(WGPUDepthStencilState* rhs) {\n        return reinterpret_cast<DepthStencilState*>(rhs);\n    }\n    inline const WGPUImageCopyBuffer* ToAPI(const ImageCopyBuffer* rhs) {\n        return reinterpret_cast<const WGPUImageCopyBuffer*>(rhs);\n    }\n\n    inline WGPUImageCopyBuffer* ToAPI(ImageCopyBuffer* rhs) {\n        return reinterpret_cast<WGPUImageCopyBuffer*>(rhs);\n    }\n\n    inline const ImageCopyBuffer* FromAPI(const WGPUImageCopyBuffer* rhs) {\n        return reinterpret_cast<const ImageCopyBuffer*>(rhs);\n    }\n\n    inline ImageCopyBuffer* FromAPI(WGPUImageCopyBuffer* rhs) {\n        return reinterpret_cast<ImageCopyBuffer*>(rhs);\n    }\n    inline const WGPUImageCopyTexture* ToAPI(const ImageCopyTexture* rhs) {\n        return reinterpret_cast<const WGPUImageCopyTexture*>(rhs);\n    }\n\n    inline WGPUImageCopyTexture* ToAPI(ImageCopyTexture* rhs) {\n        return reinterpret_cast<WGPUImageCopyTexture*>(rhs);\n    }\n\n    inline const ImageCopyTexture* FromAPI(const WGPUImageCopyTexture* rhs) {\n        return reinterpret_cast<const ImageCopyTexture*>(rhs);\n    }\n\n    inline ImageCopyTexture* FromAPI(WGPUImageCopyTexture* rhs) {\n        return reinterpret_cast<ImageCopyTexture*>(rhs);\n    }\n    inline const WGPUProgrammableStageDescriptor* ToAPI(const ProgrammableStageDescriptor* rhs) {\n        return reinterpret_cast<const WGPUProgrammableStageDescriptor*>(rhs);\n    }\n\n    inline WGPUProgrammableStageDescriptor* ToAPI(ProgrammableStageDescriptor* rhs) {\n        return reinterpret_cast<WGPUProgrammableStageDescriptor*>(rhs);\n    }\n\n    inline const ProgrammableStageDescriptor* FromAPI(const WGPUProgrammableStageDescriptor* rhs) {\n        return reinterpret_cast<const ProgrammableStageDescriptor*>(rhs);\n    }\n\n    inline ProgrammableStageDescriptor* FromAPI(WGPUProgrammableStageDescriptor* rhs) {\n        return reinterpret_cast<ProgrammableStageDescriptor*>(rhs);\n    }\n    inline const WGPURenderPassColorAttachment* ToAPI(const RenderPassColorAttachment* rhs) {\n        return reinterpret_cast<const WGPURenderPassColorAttachment*>(rhs);\n    }\n\n    inline WGPURenderPassColorAttachment* ToAPI(RenderPassColorAttachment* rhs) {\n        return reinterpret_cast<WGPURenderPassColorAttachment*>(rhs);\n    }\n\n    inline const RenderPassColorAttachment* FromAPI(const WGPURenderPassColorAttachment* rhs) {\n        return reinterpret_cast<const RenderPassColorAttachment*>(rhs);\n    }\n\n    inline RenderPassColorAttachment* FromAPI(WGPURenderPassColorAttachment* rhs) {\n        return reinterpret_cast<RenderPassColorAttachment*>(rhs);\n    }\n    inline const WGPURequiredLimits* ToAPI(const RequiredLimits* rhs) {\n        return reinterpret_cast<const WGPURequiredLimits*>(rhs);\n    }\n\n    inline WGPURequiredLimits* ToAPI(RequiredLimits* rhs) {\n        return reinterpret_cast<WGPURequiredLimits*>(rhs);\n    }\n\n    inline const RequiredLimits* FromAPI(const WGPURequiredLimits* rhs) {\n        return reinterpret_cast<const RequiredLimits*>(rhs);\n    }\n\n    inline RequiredLimits* FromAPI(WGPURequiredLimits* rhs) {\n        return reinterpret_cast<RequiredLimits*>(rhs);\n    }\n    inline const WGPUSupportedLimits* ToAPI(const SupportedLimits* rhs) {\n        return reinterpret_cast<const WGPUSupportedLimits*>(rhs);\n    }\n\n    inline WGPUSupportedLimits* ToAPI(SupportedLimits* rhs) {\n        return reinterpret_cast<WGPUSupportedLimits*>(rhs);\n    }\n\n    inline const SupportedLimits* FromAPI(const WGPUSupportedLimits* rhs) {\n        return reinterpret_cast<const SupportedLimits*>(rhs);\n    }\n\n    inline SupportedLimits* FromAPI(WGPUSupportedLimits* rhs) {\n        return reinterpret_cast<SupportedLimits*>(rhs);\n    }\n    inline const WGPUTextureDescriptor* ToAPI(const TextureDescriptor* rhs) {\n        return reinterpret_cast<const WGPUTextureDescriptor*>(rhs);\n    }\n\n    inline WGPUTextureDescriptor* ToAPI(TextureDescriptor* rhs) {\n        return reinterpret_cast<WGPUTextureDescriptor*>(rhs);\n    }\n\n    inline const TextureDescriptor* FromAPI(const WGPUTextureDescriptor* rhs) {\n        return reinterpret_cast<const TextureDescriptor*>(rhs);\n    }\n\n    inline TextureDescriptor* FromAPI(WGPUTextureDescriptor* rhs) {\n        return reinterpret_cast<TextureDescriptor*>(rhs);\n    }\n    inline const WGPUVertexBufferLayout* ToAPI(const VertexBufferLayout* rhs) {\n        return reinterpret_cast<const WGPUVertexBufferLayout*>(rhs);\n    }\n\n    inline WGPUVertexBufferLayout* ToAPI(VertexBufferLayout* rhs) {\n        return reinterpret_cast<WGPUVertexBufferLayout*>(rhs);\n    }\n\n    inline const VertexBufferLayout* FromAPI(const WGPUVertexBufferLayout* rhs) {\n        return reinterpret_cast<const VertexBufferLayout*>(rhs);\n    }\n\n    inline VertexBufferLayout* FromAPI(WGPUVertexBufferLayout* rhs) {\n        return reinterpret_cast<VertexBufferLayout*>(rhs);\n    }\n    inline const WGPUBindGroupLayoutDescriptor* ToAPI(const BindGroupLayoutDescriptor* rhs) {\n        return reinterpret_cast<const WGPUBindGroupLayoutDescriptor*>(rhs);\n    }\n\n    inline WGPUBindGroupLayoutDescriptor* ToAPI(BindGroupLayoutDescriptor* rhs) {\n        return reinterpret_cast<WGPUBindGroupLayoutDescriptor*>(rhs);\n    }\n\n    inline const BindGroupLayoutDescriptor* FromAPI(const WGPUBindGroupLayoutDescriptor* rhs) {\n        return reinterpret_cast<const BindGroupLayoutDescriptor*>(rhs);\n    }\n\n    inline BindGroupLayoutDescriptor* FromAPI(WGPUBindGroupLayoutDescriptor* rhs) {\n        return reinterpret_cast<BindGroupLayoutDescriptor*>(rhs);\n    }\n    inline const WGPUColorTargetState* ToAPI(const ColorTargetState* rhs) {\n        return reinterpret_cast<const WGPUColorTargetState*>(rhs);\n    }\n\n    inline WGPUColorTargetState* ToAPI(ColorTargetState* rhs) {\n        return reinterpret_cast<WGPUColorTargetState*>(rhs);\n    }\n\n    inline const ColorTargetState* FromAPI(const WGPUColorTargetState* rhs) {\n        return reinterpret_cast<const ColorTargetState*>(rhs);\n    }\n\n    inline ColorTargetState* FromAPI(WGPUColorTargetState* rhs) {\n        return reinterpret_cast<ColorTargetState*>(rhs);\n    }\n    inline const WGPUComputePipelineDescriptor* ToAPI(const ComputePipelineDescriptor* rhs) {\n        return reinterpret_cast<const WGPUComputePipelineDescriptor*>(rhs);\n    }\n\n    inline WGPUComputePipelineDescriptor* ToAPI(ComputePipelineDescriptor* rhs) {\n        return reinterpret_cast<WGPUComputePipelineDescriptor*>(rhs);\n    }\n\n    inline const ComputePipelineDescriptor* FromAPI(const WGPUComputePipelineDescriptor* rhs) {\n        return reinterpret_cast<const ComputePipelineDescriptor*>(rhs);\n    }\n\n    inline ComputePipelineDescriptor* FromAPI(WGPUComputePipelineDescriptor* rhs) {\n        return reinterpret_cast<ComputePipelineDescriptor*>(rhs);\n    }\n    inline const WGPUDeviceDescriptor* ToAPI(const DeviceDescriptor* rhs) {\n        return reinterpret_cast<const WGPUDeviceDescriptor*>(rhs);\n    }\n\n    inline WGPUDeviceDescriptor* ToAPI(DeviceDescriptor* rhs) {\n        return reinterpret_cast<WGPUDeviceDescriptor*>(rhs);\n    }\n\n    inline const DeviceDescriptor* FromAPI(const WGPUDeviceDescriptor* rhs) {\n        return reinterpret_cast<const DeviceDescriptor*>(rhs);\n    }\n\n    inline DeviceDescriptor* FromAPI(WGPUDeviceDescriptor* rhs) {\n        return reinterpret_cast<DeviceDescriptor*>(rhs);\n    }\n    inline const WGPUDeviceProperties* ToAPI(const DeviceProperties* rhs) {\n        return reinterpret_cast<const WGPUDeviceProperties*>(rhs);\n    }\n\n    inline WGPUDeviceProperties* ToAPI(DeviceProperties* rhs) {\n        return reinterpret_cast<WGPUDeviceProperties*>(rhs);\n    }\n\n    inline const DeviceProperties* FromAPI(const WGPUDeviceProperties* rhs) {\n        return reinterpret_cast<const DeviceProperties*>(rhs);\n    }\n\n    inline DeviceProperties* FromAPI(WGPUDeviceProperties* rhs) {\n        return reinterpret_cast<DeviceProperties*>(rhs);\n    }\n    inline const WGPURenderPassDescriptor* ToAPI(const RenderPassDescriptor* rhs) {\n        return reinterpret_cast<const WGPURenderPassDescriptor*>(rhs);\n    }\n\n    inline WGPURenderPassDescriptor* ToAPI(RenderPassDescriptor* rhs) {\n        return reinterpret_cast<WGPURenderPassDescriptor*>(rhs);\n    }\n\n    inline const RenderPassDescriptor* FromAPI(const WGPURenderPassDescriptor* rhs) {\n        return reinterpret_cast<const RenderPassDescriptor*>(rhs);\n    }\n\n    inline RenderPassDescriptor* FromAPI(WGPURenderPassDescriptor* rhs) {\n        return reinterpret_cast<RenderPassDescriptor*>(rhs);\n    }\n    inline const WGPUVertexState* ToAPI(const VertexState* rhs) {\n        return reinterpret_cast<const WGPUVertexState*>(rhs);\n    }\n\n    inline WGPUVertexState* ToAPI(VertexState* rhs) {\n        return reinterpret_cast<WGPUVertexState*>(rhs);\n    }\n\n    inline const VertexState* FromAPI(const WGPUVertexState* rhs) {\n        return reinterpret_cast<const VertexState*>(rhs);\n    }\n\n    inline VertexState* FromAPI(WGPUVertexState* rhs) {\n        return reinterpret_cast<VertexState*>(rhs);\n    }\n    inline const WGPUFragmentState* ToAPI(const FragmentState* rhs) {\n        return reinterpret_cast<const WGPUFragmentState*>(rhs);\n    }\n\n    inline WGPUFragmentState* ToAPI(FragmentState* rhs) {\n        return reinterpret_cast<WGPUFragmentState*>(rhs);\n    }\n\n    inline const FragmentState* FromAPI(const WGPUFragmentState* rhs) {\n        return reinterpret_cast<const FragmentState*>(rhs);\n    }\n\n    inline FragmentState* FromAPI(WGPUFragmentState* rhs) {\n        return reinterpret_cast<FragmentState*>(rhs);\n    }\n    inline const WGPURenderPipelineDescriptor* ToAPI(const RenderPipelineDescriptor* rhs) {\n        return reinterpret_cast<const WGPURenderPipelineDescriptor*>(rhs);\n    }\n\n    inline WGPURenderPipelineDescriptor* ToAPI(RenderPipelineDescriptor* rhs) {\n        return reinterpret_cast<WGPURenderPipelineDescriptor*>(rhs);\n    }\n\n    inline const RenderPipelineDescriptor* FromAPI(const WGPURenderPipelineDescriptor* rhs) {\n        return reinterpret_cast<const RenderPipelineDescriptor*>(rhs);\n    }\n\n    inline RenderPipelineDescriptor* FromAPI(WGPURenderPipelineDescriptor* rhs) {\n        return reinterpret_cast<RenderPipelineDescriptor*>(rhs);\n    }\n\n    inline const WGPUAdapterImpl* ToAPI(const AdapterBase* rhs) {\n        return reinterpret_cast<const WGPUAdapterImpl*>(rhs);\n    }\n\n    inline WGPUAdapterImpl* ToAPI(AdapterBase* rhs) {\n        return reinterpret_cast<WGPUAdapterImpl*>(rhs);\n    }\n\n    inline const AdapterBase* FromAPI(const WGPUAdapterImpl* rhs) {\n        return reinterpret_cast<const AdapterBase*>(rhs);\n    }\n\n    inline AdapterBase* FromAPI(WGPUAdapterImpl* rhs) {\n        return reinterpret_cast<AdapterBase*>(rhs);\n    }\n    inline const WGPUBindGroupImpl* ToAPI(const BindGroupBase* rhs) {\n        return reinterpret_cast<const WGPUBindGroupImpl*>(rhs);\n    }\n\n    inline WGPUBindGroupImpl* ToAPI(BindGroupBase* rhs) {\n        return reinterpret_cast<WGPUBindGroupImpl*>(rhs);\n    }\n\n    inline const BindGroupBase* FromAPI(const WGPUBindGroupImpl* rhs) {\n        return reinterpret_cast<const BindGroupBase*>(rhs);\n    }\n\n    inline BindGroupBase* FromAPI(WGPUBindGroupImpl* rhs) {\n        return reinterpret_cast<BindGroupBase*>(rhs);\n    }\n    inline const WGPUBindGroupLayoutImpl* ToAPI(const BindGroupLayoutBase* rhs) {\n        return reinterpret_cast<const WGPUBindGroupLayoutImpl*>(rhs);\n    }\n\n    inline WGPUBindGroupLayoutImpl* ToAPI(BindGroupLayoutBase* rhs) {\n        return reinterpret_cast<WGPUBindGroupLayoutImpl*>(rhs);\n    }\n\n    inline const BindGroupLayoutBase* FromAPI(const WGPUBindGroupLayoutImpl* rhs) {\n        return reinterpret_cast<const BindGroupLayoutBase*>(rhs);\n    }\n\n    inline BindGroupLayoutBase* FromAPI(WGPUBindGroupLayoutImpl* rhs) {\n        return reinterpret_cast<BindGroupLayoutBase*>(rhs);\n    }\n    inline const WGPUBufferImpl* ToAPI(const BufferBase* rhs) {\n        return reinterpret_cast<const WGPUBufferImpl*>(rhs);\n    }\n\n    inline WGPUBufferImpl* ToAPI(BufferBase* rhs) {\n        return reinterpret_cast<WGPUBufferImpl*>(rhs);\n    }\n\n    inline const BufferBase* FromAPI(const WGPUBufferImpl* rhs) {\n        return reinterpret_cast<const BufferBase*>(rhs);\n    }\n\n    inline BufferBase* FromAPI(WGPUBufferImpl* rhs) {\n        return reinterpret_cast<BufferBase*>(rhs);\n    }\n    inline const WGPUCommandBufferImpl* ToAPI(const CommandBufferBase* rhs) {\n        return reinterpret_cast<const WGPUCommandBufferImpl*>(rhs);\n    }\n\n    inline WGPUCommandBufferImpl* ToAPI(CommandBufferBase* rhs) {\n        return reinterpret_cast<WGPUCommandBufferImpl*>(rhs);\n    }\n\n    inline const CommandBufferBase* FromAPI(const WGPUCommandBufferImpl* rhs) {\n        return reinterpret_cast<const CommandBufferBase*>(rhs);\n    }\n\n    inline CommandBufferBase* FromAPI(WGPUCommandBufferImpl* rhs) {\n        return reinterpret_cast<CommandBufferBase*>(rhs);\n    }\n    inline const WGPUCommandEncoderImpl* ToAPI(const CommandEncoderBase* rhs) {\n        return reinterpret_cast<const WGPUCommandEncoderImpl*>(rhs);\n    }\n\n    inline WGPUCommandEncoderImpl* ToAPI(CommandEncoderBase* rhs) {\n        return reinterpret_cast<WGPUCommandEncoderImpl*>(rhs);\n    }\n\n    inline const CommandEncoderBase* FromAPI(const WGPUCommandEncoderImpl* rhs) {\n        return reinterpret_cast<const CommandEncoderBase*>(rhs);\n    }\n\n    inline CommandEncoderBase* FromAPI(WGPUCommandEncoderImpl* rhs) {\n        return reinterpret_cast<CommandEncoderBase*>(rhs);\n    }\n    inline const WGPUComputePassEncoderImpl* ToAPI(const ComputePassEncoderBase* rhs) {\n        return reinterpret_cast<const WGPUComputePassEncoderImpl*>(rhs);\n    }\n\n    inline WGPUComputePassEncoderImpl* ToAPI(ComputePassEncoderBase* rhs) {\n        return reinterpret_cast<WGPUComputePassEncoderImpl*>(rhs);\n    }\n\n    inline const ComputePassEncoderBase* FromAPI(const WGPUComputePassEncoderImpl* rhs) {\n        return reinterpret_cast<const ComputePassEncoderBase*>(rhs);\n    }\n\n    inline ComputePassEncoderBase* FromAPI(WGPUComputePassEncoderImpl* rhs) {\n        return reinterpret_cast<ComputePassEncoderBase*>(rhs);\n    }\n    inline const WGPUComputePipelineImpl* ToAPI(const ComputePipelineBase* rhs) {\n        return reinterpret_cast<const WGPUComputePipelineImpl*>(rhs);\n    }\n\n    inline WGPUComputePipelineImpl* ToAPI(ComputePipelineBase* rhs) {\n        return reinterpret_cast<WGPUComputePipelineImpl*>(rhs);\n    }\n\n    inline const ComputePipelineBase* FromAPI(const WGPUComputePipelineImpl* rhs) {\n        return reinterpret_cast<const ComputePipelineBase*>(rhs);\n    }\n\n    inline ComputePipelineBase* FromAPI(WGPUComputePipelineImpl* rhs) {\n        return reinterpret_cast<ComputePipelineBase*>(rhs);\n    }\n    inline const WGPUDeviceImpl* ToAPI(const DeviceBase* rhs) {\n        return reinterpret_cast<const WGPUDeviceImpl*>(rhs);\n    }\n\n    inline WGPUDeviceImpl* ToAPI(DeviceBase* rhs) {\n        return reinterpret_cast<WGPUDeviceImpl*>(rhs);\n    }\n\n    inline const DeviceBase* FromAPI(const WGPUDeviceImpl* rhs) {\n        return reinterpret_cast<const DeviceBase*>(rhs);\n    }\n\n    inline DeviceBase* FromAPI(WGPUDeviceImpl* rhs) {\n        return reinterpret_cast<DeviceBase*>(rhs);\n    }\n    inline const WGPUExternalTextureImpl* ToAPI(const ExternalTextureBase* rhs) {\n        return reinterpret_cast<const WGPUExternalTextureImpl*>(rhs);\n    }\n\n    inline WGPUExternalTextureImpl* ToAPI(ExternalTextureBase* rhs) {\n        return reinterpret_cast<WGPUExternalTextureImpl*>(rhs);\n    }\n\n    inline const ExternalTextureBase* FromAPI(const WGPUExternalTextureImpl* rhs) {\n        return reinterpret_cast<const ExternalTextureBase*>(rhs);\n    }\n\n    inline ExternalTextureBase* FromAPI(WGPUExternalTextureImpl* rhs) {\n        return reinterpret_cast<ExternalTextureBase*>(rhs);\n    }\n    inline const WGPUInstanceImpl* ToAPI(const InstanceBase* rhs) {\n        return reinterpret_cast<const WGPUInstanceImpl*>(rhs);\n    }\n\n    inline WGPUInstanceImpl* ToAPI(InstanceBase* rhs) {\n        return reinterpret_cast<WGPUInstanceImpl*>(rhs);\n    }\n\n    inline const InstanceBase* FromAPI(const WGPUInstanceImpl* rhs) {\n        return reinterpret_cast<const InstanceBase*>(rhs);\n    }\n\n    inline InstanceBase* FromAPI(WGPUInstanceImpl* rhs) {\n        return reinterpret_cast<InstanceBase*>(rhs);\n    }\n    inline const WGPUPipelineLayoutImpl* ToAPI(const PipelineLayoutBase* rhs) {\n        return reinterpret_cast<const WGPUPipelineLayoutImpl*>(rhs);\n    }\n\n    inline WGPUPipelineLayoutImpl* ToAPI(PipelineLayoutBase* rhs) {\n        return reinterpret_cast<WGPUPipelineLayoutImpl*>(rhs);\n    }\n\n    inline const PipelineLayoutBase* FromAPI(const WGPUPipelineLayoutImpl* rhs) {\n        return reinterpret_cast<const PipelineLayoutBase*>(rhs);\n    }\n\n    inline PipelineLayoutBase* FromAPI(WGPUPipelineLayoutImpl* rhs) {\n        return reinterpret_cast<PipelineLayoutBase*>(rhs);\n    }\n    inline const WGPUQuerySetImpl* ToAPI(const QuerySetBase* rhs) {\n        return reinterpret_cast<const WGPUQuerySetImpl*>(rhs);\n    }\n\n    inline WGPUQuerySetImpl* ToAPI(QuerySetBase* rhs) {\n        return reinterpret_cast<WGPUQuerySetImpl*>(rhs);\n    }\n\n    inline const QuerySetBase* FromAPI(const WGPUQuerySetImpl* rhs) {\n        return reinterpret_cast<const QuerySetBase*>(rhs);\n    }\n\n    inline QuerySetBase* FromAPI(WGPUQuerySetImpl* rhs) {\n        return reinterpret_cast<QuerySetBase*>(rhs);\n    }\n    inline const WGPUQueueImpl* ToAPI(const QueueBase* rhs) {\n        return reinterpret_cast<const WGPUQueueImpl*>(rhs);\n    }\n\n    inline WGPUQueueImpl* ToAPI(QueueBase* rhs) {\n        return reinterpret_cast<WGPUQueueImpl*>(rhs);\n    }\n\n    inline const QueueBase* FromAPI(const WGPUQueueImpl* rhs) {\n        return reinterpret_cast<const QueueBase*>(rhs);\n    }\n\n    inline QueueBase* FromAPI(WGPUQueueImpl* rhs) {\n        return reinterpret_cast<QueueBase*>(rhs);\n    }\n    inline const WGPURenderBundleImpl* ToAPI(const RenderBundleBase* rhs) {\n        return reinterpret_cast<const WGPURenderBundleImpl*>(rhs);\n    }\n\n    inline WGPURenderBundleImpl* ToAPI(RenderBundleBase* rhs) {\n        return reinterpret_cast<WGPURenderBundleImpl*>(rhs);\n    }\n\n    inline const RenderBundleBase* FromAPI(const WGPURenderBundleImpl* rhs) {\n        return reinterpret_cast<const RenderBundleBase*>(rhs);\n    }\n\n    inline RenderBundleBase* FromAPI(WGPURenderBundleImpl* rhs) {\n        return reinterpret_cast<RenderBundleBase*>(rhs);\n    }\n    inline const WGPURenderBundleEncoderImpl* ToAPI(const RenderBundleEncoderBase* rhs) {\n        return reinterpret_cast<const WGPURenderBundleEncoderImpl*>(rhs);\n    }\n\n    inline WGPURenderBundleEncoderImpl* ToAPI(RenderBundleEncoderBase* rhs) {\n        return reinterpret_cast<WGPURenderBundleEncoderImpl*>(rhs);\n    }\n\n    inline const RenderBundleEncoderBase* FromAPI(const WGPURenderBundleEncoderImpl* rhs) {\n        return reinterpret_cast<const RenderBundleEncoderBase*>(rhs);\n    }\n\n    inline RenderBundleEncoderBase* FromAPI(WGPURenderBundleEncoderImpl* rhs) {\n        return reinterpret_cast<RenderBundleEncoderBase*>(rhs);\n    }\n    inline const WGPURenderPassEncoderImpl* ToAPI(const RenderPassEncoderBase* rhs) {\n        return reinterpret_cast<const WGPURenderPassEncoderImpl*>(rhs);\n    }\n\n    inline WGPURenderPassEncoderImpl* ToAPI(RenderPassEncoderBase* rhs) {\n        return reinterpret_cast<WGPURenderPassEncoderImpl*>(rhs);\n    }\n\n    inline const RenderPassEncoderBase* FromAPI(const WGPURenderPassEncoderImpl* rhs) {\n        return reinterpret_cast<const RenderPassEncoderBase*>(rhs);\n    }\n\n    inline RenderPassEncoderBase* FromAPI(WGPURenderPassEncoderImpl* rhs) {\n        return reinterpret_cast<RenderPassEncoderBase*>(rhs);\n    }\n    inline const WGPURenderPipelineImpl* ToAPI(const RenderPipelineBase* rhs) {\n        return reinterpret_cast<const WGPURenderPipelineImpl*>(rhs);\n    }\n\n    inline WGPURenderPipelineImpl* ToAPI(RenderPipelineBase* rhs) {\n        return reinterpret_cast<WGPURenderPipelineImpl*>(rhs);\n    }\n\n    inline const RenderPipelineBase* FromAPI(const WGPURenderPipelineImpl* rhs) {\n        return reinterpret_cast<const RenderPipelineBase*>(rhs);\n    }\n\n    inline RenderPipelineBase* FromAPI(WGPURenderPipelineImpl* rhs) {\n        return reinterpret_cast<RenderPipelineBase*>(rhs);\n    }\n    inline const WGPUSamplerImpl* ToAPI(const SamplerBase* rhs) {\n        return reinterpret_cast<const WGPUSamplerImpl*>(rhs);\n    }\n\n    inline WGPUSamplerImpl* ToAPI(SamplerBase* rhs) {\n        return reinterpret_cast<WGPUSamplerImpl*>(rhs);\n    }\n\n    inline const SamplerBase* FromAPI(const WGPUSamplerImpl* rhs) {\n        return reinterpret_cast<const SamplerBase*>(rhs);\n    }\n\n    inline SamplerBase* FromAPI(WGPUSamplerImpl* rhs) {\n        return reinterpret_cast<SamplerBase*>(rhs);\n    }\n    inline const WGPUShaderModuleImpl* ToAPI(const ShaderModuleBase* rhs) {\n        return reinterpret_cast<const WGPUShaderModuleImpl*>(rhs);\n    }\n\n    inline WGPUShaderModuleImpl* ToAPI(ShaderModuleBase* rhs) {\n        return reinterpret_cast<WGPUShaderModuleImpl*>(rhs);\n    }\n\n    inline const ShaderModuleBase* FromAPI(const WGPUShaderModuleImpl* rhs) {\n        return reinterpret_cast<const ShaderModuleBase*>(rhs);\n    }\n\n    inline ShaderModuleBase* FromAPI(WGPUShaderModuleImpl* rhs) {\n        return reinterpret_cast<ShaderModuleBase*>(rhs);\n    }\n    inline const WGPUSurfaceImpl* ToAPI(const SurfaceBase* rhs) {\n        return reinterpret_cast<const WGPUSurfaceImpl*>(rhs);\n    }\n\n    inline WGPUSurfaceImpl* ToAPI(SurfaceBase* rhs) {\n        return reinterpret_cast<WGPUSurfaceImpl*>(rhs);\n    }\n\n    inline const SurfaceBase* FromAPI(const WGPUSurfaceImpl* rhs) {\n        return reinterpret_cast<const SurfaceBase*>(rhs);\n    }\n\n    inline SurfaceBase* FromAPI(WGPUSurfaceImpl* rhs) {\n        return reinterpret_cast<SurfaceBase*>(rhs);\n    }\n    inline const WGPUSwapChainImpl* ToAPI(const SwapChainBase* rhs) {\n        return reinterpret_cast<const WGPUSwapChainImpl*>(rhs);\n    }\n\n    inline WGPUSwapChainImpl* ToAPI(SwapChainBase* rhs) {\n        return reinterpret_cast<WGPUSwapChainImpl*>(rhs);\n    }\n\n    inline const SwapChainBase* FromAPI(const WGPUSwapChainImpl* rhs) {\n        return reinterpret_cast<const SwapChainBase*>(rhs);\n    }\n\n    inline SwapChainBase* FromAPI(WGPUSwapChainImpl* rhs) {\n        return reinterpret_cast<SwapChainBase*>(rhs);\n    }\n    inline const WGPUTextureImpl* ToAPI(const TextureBase* rhs) {\n        return reinterpret_cast<const WGPUTextureImpl*>(rhs);\n    }\n\n    inline WGPUTextureImpl* ToAPI(TextureBase* rhs) {\n        return reinterpret_cast<WGPUTextureImpl*>(rhs);\n    }\n\n    inline const TextureBase* FromAPI(const WGPUTextureImpl* rhs) {\n        return reinterpret_cast<const TextureBase*>(rhs);\n    }\n\n    inline TextureBase* FromAPI(WGPUTextureImpl* rhs) {\n        return reinterpret_cast<TextureBase*>(rhs);\n    }\n    inline const WGPUTextureViewImpl* ToAPI(const TextureViewBase* rhs) {\n        return reinterpret_cast<const WGPUTextureViewImpl*>(rhs);\n    }\n\n    inline WGPUTextureViewImpl* ToAPI(TextureViewBase* rhs) {\n        return reinterpret_cast<WGPUTextureViewImpl*>(rhs);\n    }\n\n    inline const TextureViewBase* FromAPI(const WGPUTextureViewImpl* rhs) {\n        return reinterpret_cast<const TextureViewBase*>(rhs);\n    }\n\n    inline TextureViewBase* FromAPI(WGPUTextureViewImpl* rhs) {\n        return reinterpret_cast<TextureViewBase*>(rhs);\n    }\n\n    template <typename T>\n    struct EnumCount;\n\n    template<>\n    struct EnumCount<wgpu::AdapterType> {\n        static constexpr uint32_t value = 4;\n    };\n    template<>\n    struct EnumCount<wgpu::AddressMode> {\n        static constexpr uint32_t value = 3;\n    };\n    template<>\n    struct EnumCount<wgpu::AlphaMode> {\n        static constexpr uint32_t value = 2;\n    };\n    template<>\n    struct EnumCount<wgpu::BackendType> {\n        static constexpr uint32_t value = 8;\n    };\n    template<>\n    struct EnumCount<wgpu::BlendFactor> {\n        static constexpr uint32_t value = 13;\n    };\n    template<>\n    struct EnumCount<wgpu::BlendOperation> {\n        static constexpr uint32_t value = 5;\n    };\n    template<>\n    struct EnumCount<wgpu::BufferBindingType> {\n        static constexpr uint32_t value = 4;\n    };\n    template<>\n    struct EnumCount<wgpu::BufferMapAsyncStatus> {\n        static constexpr uint32_t value = 6;\n    };\n    template<>\n    struct EnumCount<wgpu::CompareFunction> {\n        static constexpr uint32_t value = 9;\n    };\n    template<>\n    struct EnumCount<wgpu::CompilationInfoRequestStatus> {\n        static constexpr uint32_t value = 4;\n    };\n    template<>\n    struct EnumCount<wgpu::CompilationMessageType> {\n        static constexpr uint32_t value = 3;\n    };\n    template<>\n    struct EnumCount<wgpu::CreatePipelineAsyncStatus> {\n        static constexpr uint32_t value = 5;\n    };\n    template<>\n    struct EnumCount<wgpu::CullMode> {\n        static constexpr uint32_t value = 3;\n    };\n    template<>\n    struct EnumCount<wgpu::DeviceLostReason> {\n        static constexpr uint32_t value = 2;\n    };\n    template<>\n    struct EnumCount<wgpu::ErrorFilter> {\n        static constexpr uint32_t value = 2;\n    };\n    template<>\n    struct EnumCount<wgpu::ErrorType> {\n        static constexpr uint32_t value = 5;\n    };\n    template<>\n    struct EnumCount<wgpu::FilterMode> {\n        static constexpr uint32_t value = 2;\n    };\n    template<>\n    struct EnumCount<wgpu::FrontFace> {\n        static constexpr uint32_t value = 2;\n    };\n    template<>\n    struct EnumCount<wgpu::IndexFormat> {\n        static constexpr uint32_t value = 3;\n    };\n    template<>\n    struct EnumCount<wgpu::LoadOp> {\n        static constexpr uint32_t value = 3;\n    };\n    template<>\n    struct EnumCount<wgpu::LoggingType> {\n        static constexpr uint32_t value = 4;\n    };\n    template<>\n    struct EnumCount<wgpu::PipelineStatisticName> {\n        static constexpr uint32_t value = 5;\n    };\n    template<>\n    struct EnumCount<wgpu::PowerPreference> {\n        static constexpr uint32_t value = 3;\n    };\n    template<>\n    struct EnumCount<wgpu::PredefinedColorSpace> {\n        static constexpr uint32_t value = 2;\n    };\n    template<>\n    struct EnumCount<wgpu::PresentMode> {\n        static constexpr uint32_t value = 3;\n    };\n    template<>\n    struct EnumCount<wgpu::PrimitiveTopology> {\n        static constexpr uint32_t value = 5;\n    };\n    template<>\n    struct EnumCount<wgpu::QueryType> {\n        static constexpr uint32_t value = 3;\n    };\n    template<>\n    struct EnumCount<wgpu::QueueWorkDoneStatus> {\n        static constexpr uint32_t value = 4;\n    };\n    template<>\n    struct EnumCount<wgpu::RequestAdapterStatus> {\n        static constexpr uint32_t value = 4;\n    };\n    template<>\n    struct EnumCount<wgpu::RequestDeviceStatus> {\n        static constexpr uint32_t value = 3;\n    };\n    template<>\n    struct EnumCount<wgpu::SamplerBindingType> {\n        static constexpr uint32_t value = 4;\n    };\n    template<>\n    struct EnumCount<wgpu::StencilOperation> {\n        static constexpr uint32_t value = 8;\n    };\n    template<>\n    struct EnumCount<wgpu::StorageTextureAccess> {\n        static constexpr uint32_t value = 2;\n    };\n    template<>\n    struct EnumCount<wgpu::StoreOp> {\n        static constexpr uint32_t value = 3;\n    };\n    template<>\n    struct EnumCount<wgpu::TextureAspect> {\n        static constexpr uint32_t value = 5;\n    };\n    template<>\n    struct EnumCount<wgpu::TextureComponentType> {\n        static constexpr uint32_t value = 4;\n    };\n    template<>\n    struct EnumCount<wgpu::TextureDimension> {\n        static constexpr uint32_t value = 3;\n    };\n    template<>\n    struct EnumCount<wgpu::TextureFormat> {\n        static constexpr uint32_t value = 97;\n    };\n    template<>\n    struct EnumCount<wgpu::TextureSampleType> {\n        static constexpr uint32_t value = 6;\n    };\n    template<>\n    struct EnumCount<wgpu::TextureViewDimension> {\n        static constexpr uint32_t value = 7;\n    };\n    template<>\n    struct EnumCount<wgpu::VertexFormat> {\n        static constexpr uint32_t value = 31;\n    };\n    template<>\n    struct EnumCount<wgpu::VertexStepMode> {\n        static constexpr uint32_t value = 2;\n    };\n}\n\n#endif  // DAWNNATIVE_DAWN_PLATFORM_AUTOGEN_H_\n", "src/dawn/native/wgpu_structs_autogen.h": "\n#ifndef DAWNNATIVE_WGPU_STRUCTS_H_\n#define DAWNNATIVE_WGPU_STRUCTS_H_\n\n#include \"dawn/webgpu_cpp.h\"\n#include \"dawn/native/Forward.h\"\n\nnamespace dawn::native {\n\n\n    struct ChainedStruct {\n        ChainedStruct const * nextInChain = nullptr;\n        wgpu::SType sType = wgpu::SType::Invalid;\n    };\n\n    struct AdapterProperties {\n        ChainedStruct const * nextInChain = nullptr;\n        uint32_t vendorID;\n        uint32_t deviceID;\n        char const * name;\n        char const * driverDescription;\n        wgpu::AdapterType adapterType;\n        wgpu::BackendType backendType;\n\n        // Equality operators, mostly for testing. Note that this tests\n        // strict pointer-pointer equality if the struct contains member pointers.\n        bool operator==(const AdapterProperties& rhs) const;\n    };\n\n    struct BindGroupEntry {\n        ChainedStruct const * nextInChain = nullptr;\n        uint32_t binding;\n        BufferBase* buffer = nullptr;\n        uint64_t offset = 0;\n        uint64_t size;\n        SamplerBase* sampler = nullptr;\n        TextureViewBase* textureView = nullptr;\n\n        // Equality operators, mostly for testing. Note that this tests\n        // strict pointer-pointer equality if the struct contains member pointers.\n        bool operator==(const BindGroupEntry& rhs) const;\n    };\n\n    struct BlendComponent {\n        wgpu::BlendOperation operation = wgpu::BlendOperation::Add;\n        wgpu::BlendFactor srcFactor = wgpu::BlendFactor::One;\n        wgpu::BlendFactor dstFactor = wgpu::BlendFactor::Zero;\n\n        // Equality operators, mostly for testing. Note that this tests\n        // strict pointer-pointer equality if the struct contains member pointers.\n        bool operator==(const BlendComponent& rhs) const;\n    };\n\n    struct BufferBindingLayout {\n        ChainedStruct const * nextInChain = nullptr;\n        wgpu::BufferBindingType type = wgpu::BufferBindingType::Undefined;\n        bool hasDynamicOffset = false;\n        uint64_t minBindingSize = 0;\n\n        // Equality operators, mostly for testing. Note that this tests\n        // strict pointer-pointer equality if the struct contains member pointers.\n        bool operator==(const BufferBindingLayout& rhs) const;\n    };\n\n    struct BufferDescriptor {\n        ChainedStruct const * nextInChain = nullptr;\n        char const * label = nullptr;\n        wgpu::BufferUsage usage;\n        uint64_t size;\n        bool mappedAtCreation = false;\n\n        // Equality operators, mostly for testing. Note that this tests\n        // strict pointer-pointer equality if the struct contains member pointers.\n        bool operator==(const BufferDescriptor& rhs) const;\n    };\n\n    struct Color {\n        double r;\n        double g;\n        double b;\n        double a;\n\n        // Equality operators, mostly for testing. Note that this tests\n        // strict pointer-pointer equality if the struct contains member pointers.\n        bool operator==(const Color& rhs) const;\n    };\n\n    struct CommandBufferDescriptor {\n        ChainedStruct const * nextInChain = nullptr;\n        char const * label = nullptr;\n\n        // Equality operators, mostly for testing. Note that this tests\n        // strict pointer-pointer equality if the struct contains member pointers.\n        bool operator==(const CommandBufferDescriptor& rhs) const;\n    };\n\n    struct CommandEncoderDescriptor {\n        ChainedStruct const * nextInChain = nullptr;\n        char const * label = nullptr;\n\n        // Equality operators, mostly for testing. Note that this tests\n        // strict pointer-pointer equality if the struct contains member pointers.\n        bool operator==(const CommandEncoderDescriptor& rhs) const;\n    };\n\n    struct CompilationMessage {\n        ChainedStruct const * nextInChain = nullptr;\n        char const * message = nullptr;\n        wgpu::CompilationMessageType type;\n        uint64_t lineNum;\n        uint64_t linePos;\n        uint64_t offset;\n        uint64_t length;\n\n        // Equality operators, mostly for testing. Note that this tests\n        // strict pointer-pointer equality if the struct contains member pointers.\n        bool operator==(const CompilationMessage& rhs) const;\n    };\n\n    struct ComputePassDescriptor {\n        ChainedStruct const * nextInChain = nullptr;\n        char const * label = nullptr;\n\n        // Equality operators, mostly for testing. Note that this tests\n        // strict pointer-pointer equality if the struct contains member pointers.\n        bool operator==(const ComputePassDescriptor& rhs) const;\n    };\n\n    struct ConstantEntry {\n        ChainedStruct const * nextInChain = nullptr;\n        char const * key;\n        double value;\n\n        // Equality operators, mostly for testing. Note that this tests\n        // strict pointer-pointer equality if the struct contains member pointers.\n        bool operator==(const ConstantEntry& rhs) const;\n    };\n\n    struct CopyTextureForBrowserOptions {\n        ChainedStruct const * nextInChain = nullptr;\n        bool flipY = false;\n        bool needsColorSpaceConversion = false;\n        wgpu::AlphaMode srcAlphaMode = wgpu::AlphaMode::Unpremultiplied;\n        float const * srcTransferFunctionParameters = nullptr;\n        float const * conversionMatrix = nullptr;\n        float const * dstTransferFunctionParameters = nullptr;\n        wgpu::AlphaMode dstAlphaMode = wgpu::AlphaMode::Unpremultiplied;\n\n        // Equality operators, mostly for testing. Note that this tests\n        // strict pointer-pointer equality if the struct contains member pointers.\n        bool operator==(const CopyTextureForBrowserOptions& rhs) const;\n    };\n\n    struct DawnEncoderInternalUsageDescriptor : ChainedStruct {\n        DawnEncoderInternalUsageDescriptor() {\n            sType = wgpu::SType::DawnEncoderInternalUsageDescriptor;\n        }\n        alignas(ChainedStruct) bool useInternalUsages = false;\n\n        // Equality operators, mostly for testing. Note that this tests\n        // strict pointer-pointer equality if the struct contains member pointers.\n        bool operator==(const DawnEncoderInternalUsageDescriptor& rhs) const;\n    };\n\n    struct DawnInstanceDescriptor : ChainedStruct {\n        DawnInstanceDescriptor() {\n            sType = wgpu::SType::DawnInstanceDescriptor;\n        }\n        alignas(ChainedStruct) uint32_t additionalRuntimeSearchPathsCount = 0;\n        const char* const * additionalRuntimeSearchPaths;\n\n        // Equality operators, mostly for testing. Note that this tests\n        // strict pointer-pointer equality if the struct contains member pointers.\n        bool operator==(const DawnInstanceDescriptor& rhs) const;\n    };\n\n    struct DawnTextureInternalUsageDescriptor : ChainedStruct {\n        DawnTextureInternalUsageDescriptor() {\n            sType = wgpu::SType::DawnTextureInternalUsageDescriptor;\n        }\n        alignas(ChainedStruct) wgpu::TextureUsage internalUsage = wgpu::TextureUsage::None;\n\n        // Equality operators, mostly for testing. Note that this tests\n        // strict pointer-pointer equality if the struct contains member pointers.\n        bool operator==(const DawnTextureInternalUsageDescriptor& rhs) const;\n    };\n\n    struct DawnTogglesDeviceDescriptor : ChainedStruct {\n        DawnTogglesDeviceDescriptor() {\n            sType = wgpu::SType::DawnTogglesDeviceDescriptor;\n        }\n        alignas(ChainedStruct) uint32_t forceEnabledTogglesCount = 0;\n        const char* const * forceEnabledToggles;\n        uint32_t forceDisabledTogglesCount = 0;\n        const char* const * forceDisabledToggles;\n\n        // Equality operators, mostly for testing. Note that this tests\n        // strict pointer-pointer equality if the struct contains member pointers.\n        bool operator==(const DawnTogglesDeviceDescriptor& rhs) const;\n    };\n\n    struct Extent3D {\n        uint32_t width;\n        uint32_t height = 1;\n        uint32_t depthOrArrayLayers = 1;\n\n        // Equality operators, mostly for testing. Note that this tests\n        // strict pointer-pointer equality if the struct contains member pointers.\n        bool operator==(const Extent3D& rhs) const;\n    };\n\n    struct ExternalTextureBindingEntry : ChainedStruct {\n        ExternalTextureBindingEntry() {\n            sType = wgpu::SType::ExternalTextureBindingEntry;\n        }\n        alignas(ChainedStruct) ExternalTextureBase* externalTexture;\n\n        // Equality operators, mostly for testing. Note that this tests\n        // strict pointer-pointer equality if the struct contains member pointers.\n        bool operator==(const ExternalTextureBindingEntry& rhs) const;\n    };\n\n    struct ExternalTextureBindingLayout : ChainedStruct {\n        ExternalTextureBindingLayout() {\n            sType = wgpu::SType::ExternalTextureBindingLayout;\n        }\n\n        // Equality operators, mostly for testing. Note that this tests\n        // strict pointer-pointer equality if the struct contains member pointers.\n        bool operator==(const ExternalTextureBindingLayout& rhs) const;\n    };\n\n    struct ExternalTextureDescriptor {\n        ChainedStruct const * nextInChain = nullptr;\n        char const * label = nullptr;\n        TextureViewBase* plane0;\n        TextureViewBase* plane1 = nullptr;\n        wgpu::PredefinedColorSpace colorSpace = wgpu::PredefinedColorSpace::Srgb;\n\n        // Equality operators, mostly for testing. Note that this tests\n        // strict pointer-pointer equality if the struct contains member pointers.\n        bool operator==(const ExternalTextureDescriptor& rhs) const;\n    };\n\n    struct InstanceDescriptor {\n        ChainedStruct const * nextInChain = nullptr;\n\n        // Equality operators, mostly for testing. Note that this tests\n        // strict pointer-pointer equality if the struct contains member pointers.\n        bool operator==(const InstanceDescriptor& rhs) const;\n    };\n\n    struct Limits {\n        uint32_t maxTextureDimension1D = WGPU_LIMIT_U32_UNDEFINED;\n        uint32_t maxTextureDimension2D = WGPU_LIMIT_U32_UNDEFINED;\n        uint32_t maxTextureDimension3D = WGPU_LIMIT_U32_UNDEFINED;\n        uint32_t maxTextureArrayLayers = WGPU_LIMIT_U32_UNDEFINED;\n        uint32_t maxBindGroups = WGPU_LIMIT_U32_UNDEFINED;\n        uint32_t maxDynamicUniformBuffersPerPipelineLayout = WGPU_LIMIT_U32_UNDEFINED;\n        uint32_t maxDynamicStorageBuffersPerPipelineLayout = WGPU_LIMIT_U32_UNDEFINED;\n        uint32_t maxSampledTexturesPerShaderStage = WGPU_LIMIT_U32_UNDEFINED;\n        uint32_t maxSamplersPerShaderStage = WGPU_LIMIT_U32_UNDEFINED;\n        uint32_t maxStorageBuffersPerShaderStage = WGPU_LIMIT_U32_UNDEFINED;\n        uint32_t maxStorageTexturesPerShaderStage = WGPU_LIMIT_U32_UNDEFINED;\n        uint32_t maxUniformBuffersPerShaderStage = WGPU_LIMIT_U32_UNDEFINED;\n        uint64_t maxUniformBufferBindingSize = WGPU_LIMIT_U64_UNDEFINED;\n        uint64_t maxStorageBufferBindingSize = WGPU_LIMIT_U64_UNDEFINED;\n        uint32_t minUniformBufferOffsetAlignment = WGPU_LIMIT_U32_UNDEFINED;\n        uint32_t minStorageBufferOffsetAlignment = WGPU_LIMIT_U32_UNDEFINED;\n        uint32_t maxVertexBuffers = WGPU_LIMIT_U32_UNDEFINED;\n        uint32_t maxVertexAttributes = WGPU_LIMIT_U32_UNDEFINED;\n        uint32_t maxVertexBufferArrayStride = WGPU_LIMIT_U32_UNDEFINED;\n        uint32_t maxInterStageShaderComponents = WGPU_LIMIT_U32_UNDEFINED;\n        uint32_t maxComputeWorkgroupStorageSize = WGPU_LIMIT_U32_UNDEFINED;\n        uint32_t maxComputeInvocationsPerWorkgroup = WGPU_LIMIT_U32_UNDEFINED;\n        uint32_t maxComputeWorkgroupSizeX = WGPU_LIMIT_U32_UNDEFINED;\n        uint32_t maxComputeWorkgroupSizeY = WGPU_LIMIT_U32_UNDEFINED;\n        uint32_t maxComputeWorkgroupSizeZ = WGPU_LIMIT_U32_UNDEFINED;\n        uint32_t maxComputeWorkgroupsPerDimension = WGPU_LIMIT_U32_UNDEFINED;\n\n        // Equality operators, mostly for testing. Note that this tests\n        // strict pointer-pointer equality if the struct contains member pointers.\n        bool operator==(const Limits& rhs) const;\n    };\n\n    struct MultisampleState {\n        ChainedStruct const * nextInChain = nullptr;\n        uint32_t count = 1;\n        uint32_t mask = 0xFFFFFFFF;\n        bool alphaToCoverageEnabled = false;\n\n        // Equality operators, mostly for testing. Note that this tests\n        // strict pointer-pointer equality if the struct contains member pointers.\n        bool operator==(const MultisampleState& rhs) const;\n    };\n\n    struct Origin3D {\n        uint32_t x = 0;\n        uint32_t y = 0;\n        uint32_t z = 0;\n\n        // Equality operators, mostly for testing. Note that this tests\n        // strict pointer-pointer equality if the struct contains member pointers.\n        bool operator==(const Origin3D& rhs) const;\n    };\n\n    struct PipelineLayoutDescriptor {\n        ChainedStruct const * nextInChain = nullptr;\n        char const * label = nullptr;\n        uint32_t bindGroupLayoutCount;\n        BindGroupLayoutBase* const * bindGroupLayouts;\n\n        // Equality operators, mostly for testing. Note that this tests\n        // strict pointer-pointer equality if the struct contains member pointers.\n        bool operator==(const PipelineLayoutDescriptor& rhs) const;\n    };\n\n    struct PrimitiveDepthClampingState : ChainedStruct {\n        PrimitiveDepthClampingState() {\n            sType = wgpu::SType::PrimitiveDepthClampingState;\n        }\n        alignas(ChainedStruct) bool clampDepth = false;\n\n        // Equality operators, mostly for testing. Note that this tests\n        // strict pointer-pointer equality if the struct contains member pointers.\n        bool operator==(const PrimitiveDepthClampingState& rhs) const;\n    };\n\n    struct PrimitiveState {\n        ChainedStruct const * nextInChain = nullptr;\n        wgpu::PrimitiveTopology topology = wgpu::PrimitiveTopology::TriangleList;\n        wgpu::IndexFormat stripIndexFormat = wgpu::IndexFormat::Undefined;\n        wgpu::FrontFace frontFace = wgpu::FrontFace::CCW;\n        wgpu::CullMode cullMode = wgpu::CullMode::None;\n\n        // Equality operators, mostly for testing. Note that this tests\n        // strict pointer-pointer equality if the struct contains member pointers.\n        bool operator==(const PrimitiveState& rhs) const;\n    };\n\n    struct QuerySetDescriptor {\n        ChainedStruct const * nextInChain = nullptr;\n        char const * label = nullptr;\n        wgpu::QueryType type;\n        uint32_t count;\n        wgpu::PipelineStatisticName const * pipelineStatistics;\n        uint32_t pipelineStatisticsCount = 0;\n\n        // Equality operators, mostly for testing. Note that this tests\n        // strict pointer-pointer equality if the struct contains member pointers.\n        bool operator==(const QuerySetDescriptor& rhs) const;\n    };\n\n    struct RenderBundleDescriptor {\n        ChainedStruct const * nextInChain = nullptr;\n        char const * label = nullptr;\n\n        // Equality operators, mostly for testing. Note that this tests\n        // strict pointer-pointer equality if the struct contains member pointers.\n        bool operator==(const RenderBundleDescriptor& rhs) const;\n    };\n\n    struct RenderBundleEncoderDescriptor {\n        ChainedStruct const * nextInChain = nullptr;\n        char const * label = nullptr;\n        uint32_t colorFormatsCount;\n        wgpu::TextureFormat const * colorFormats;\n        wgpu::TextureFormat depthStencilFormat = wgpu::TextureFormat::Undefined;\n        uint32_t sampleCount = 1;\n        bool depthReadOnly = false;\n        bool stencilReadOnly = false;\n\n        // Equality operators, mostly for testing. Note that this tests\n        // strict pointer-pointer equality if the struct contains member pointers.\n        bool operator==(const RenderBundleEncoderDescriptor& rhs) const;\n    };\n\n    struct RenderPassDepthStencilAttachment {\n        TextureViewBase* view;\n        wgpu::LoadOp depthLoadOp = wgpu::LoadOp::Undefined;\n        wgpu::StoreOp depthStoreOp = wgpu::StoreOp::Undefined;\n        float clearDepth = 0;\n        bool depthReadOnly = false;\n        wgpu::LoadOp stencilLoadOp = wgpu::LoadOp::Undefined;\n        wgpu::StoreOp stencilStoreOp = wgpu::StoreOp::Undefined;\n        uint32_t clearStencil = 0;\n        bool stencilReadOnly = false;\n\n        // Equality operators, mostly for testing. Note that this tests\n        // strict pointer-pointer equality if the struct contains member pointers.\n        bool operator==(const RenderPassDepthStencilAttachment& rhs) const;\n    };\n\n    struct RequestAdapterOptions {\n        ChainedStruct const * nextInChain = nullptr;\n        SurfaceBase* compatibleSurface = nullptr;\n        wgpu::PowerPreference powerPreference = wgpu::PowerPreference::Undefined;\n        bool forceFallbackAdapter = false;\n\n        // Equality operators, mostly for testing. Note that this tests\n        // strict pointer-pointer equality if the struct contains member pointers.\n        bool operator==(const RequestAdapterOptions& rhs) const;\n    };\n\n    struct SamplerBindingLayout {\n        ChainedStruct const * nextInChain = nullptr;\n        wgpu::SamplerBindingType type = wgpu::SamplerBindingType::Undefined;\n\n        // Equality operators, mostly for testing. Note that this tests\n        // strict pointer-pointer equality if the struct contains member pointers.\n        bool operator==(const SamplerBindingLayout& rhs) const;\n    };\n\n    struct SamplerDescriptor {\n        ChainedStruct const * nextInChain = nullptr;\n        char const * label = nullptr;\n        wgpu::AddressMode addressModeU = wgpu::AddressMode::ClampToEdge;\n        wgpu::AddressMode addressModeV = wgpu::AddressMode::ClampToEdge;\n        wgpu::AddressMode addressModeW = wgpu::AddressMode::ClampToEdge;\n        wgpu::FilterMode magFilter = wgpu::FilterMode::Nearest;\n        wgpu::FilterMode minFilter = wgpu::FilterMode::Nearest;\n        wgpu::FilterMode mipmapFilter = wgpu::FilterMode::Nearest;\n        float lodMinClamp = 0.0f;\n        float lodMaxClamp = 1000.0f;\n        wgpu::CompareFunction compare = wgpu::CompareFunction::Undefined;\n        uint16_t maxAnisotropy = 1;\n\n        // Equality operators, mostly for testing. Note that this tests\n        // strict pointer-pointer equality if the struct contains member pointers.\n        bool operator==(const SamplerDescriptor& rhs) const;\n    };\n\n    struct ShaderModuleDescriptor {\n        ChainedStruct const * nextInChain = nullptr;\n        char const * label = nullptr;\n\n        // Equality operators, mostly for testing. Note that this tests\n        // strict pointer-pointer equality if the struct contains member pointers.\n        bool operator==(const ShaderModuleDescriptor& rhs) const;\n    };\n\n    struct ShaderModuleSPIRVDescriptor : ChainedStruct {\n        ShaderModuleSPIRVDescriptor() {\n            sType = wgpu::SType::ShaderModuleSPIRVDescriptor;\n        }\n        alignas(ChainedStruct) uint32_t codeSize;\n        uint32_t const * code;\n\n        // Equality operators, mostly for testing. Note that this tests\n        // strict pointer-pointer equality if the struct contains member pointers.\n        bool operator==(const ShaderModuleSPIRVDescriptor& rhs) const;\n    };\n\n    struct ShaderModuleWGSLDescriptor : ChainedStruct {\n        ShaderModuleWGSLDescriptor() {\n            sType = wgpu::SType::ShaderModuleWGSLDescriptor;\n        }\n        alignas(ChainedStruct) char const * source;\n\n        // Equality operators, mostly for testing. Note that this tests\n        // strict pointer-pointer equality if the struct contains member pointers.\n        bool operator==(const ShaderModuleWGSLDescriptor& rhs) const;\n    };\n\n    struct StencilFaceState {\n        wgpu::CompareFunction compare = wgpu::CompareFunction::Always;\n        wgpu::StencilOperation failOp = wgpu::StencilOperation::Keep;\n        wgpu::StencilOperation depthFailOp = wgpu::StencilOperation::Keep;\n        wgpu::StencilOperation passOp = wgpu::StencilOperation::Keep;\n\n        // Equality operators, mostly for testing. Note that this tests\n        // strict pointer-pointer equality if the struct contains member pointers.\n        bool operator==(const StencilFaceState& rhs) const;\n    };\n\n    struct StorageTextureBindingLayout {\n        ChainedStruct const * nextInChain = nullptr;\n        wgpu::StorageTextureAccess access = wgpu::StorageTextureAccess::Undefined;\n        wgpu::TextureFormat format = wgpu::TextureFormat::Undefined;\n        wgpu::TextureViewDimension viewDimension = wgpu::TextureViewDimension::Undefined;\n\n        // Equality operators, mostly for testing. Note that this tests\n        // strict pointer-pointer equality if the struct contains member pointers.\n        bool operator==(const StorageTextureBindingLayout& rhs) const;\n    };\n\n    struct SurfaceDescriptor {\n        ChainedStruct const * nextInChain = nullptr;\n        char const * label = nullptr;\n\n        // Equality operators, mostly for testing. Note that this tests\n        // strict pointer-pointer equality if the struct contains member pointers.\n        bool operator==(const SurfaceDescriptor& rhs) const;\n    };\n\n    struct SurfaceDescriptorFromCanvasHTMLSelector : ChainedStruct {\n        SurfaceDescriptorFromCanvasHTMLSelector() {\n            sType = wgpu::SType::SurfaceDescriptorFromCanvasHTMLSelector;\n        }\n        alignas(ChainedStruct) char const * selector;\n\n        // Equality operators, mostly for testing. Note that this tests\n        // strict pointer-pointer equality if the struct contains member pointers.\n        bool operator==(const SurfaceDescriptorFromCanvasHTMLSelector& rhs) const;\n    };\n\n    struct SurfaceDescriptorFromMetalLayer : ChainedStruct {\n        SurfaceDescriptorFromMetalLayer() {\n            sType = wgpu::SType::SurfaceDescriptorFromMetalLayer;\n        }\n        alignas(ChainedStruct) void * layer;\n\n        // Equality operators, mostly for testing. Note that this tests\n        // strict pointer-pointer equality if the struct contains member pointers.\n        bool operator==(const SurfaceDescriptorFromMetalLayer& rhs) const;\n    };\n\n    struct SurfaceDescriptorFromWindowsCoreWindow : ChainedStruct {\n        SurfaceDescriptorFromWindowsCoreWindow() {\n            sType = wgpu::SType::SurfaceDescriptorFromWindowsCoreWindow;\n        }\n        alignas(ChainedStruct) void * coreWindow;\n\n        // Equality operators, mostly for testing. Note that this tests\n        // strict pointer-pointer equality if the struct contains member pointers.\n        bool operator==(const SurfaceDescriptorFromWindowsCoreWindow& rhs) const;\n    };\n\n    struct SurfaceDescriptorFromWindowsHWND : ChainedStruct {\n        SurfaceDescriptorFromWindowsHWND() {\n            sType = wgpu::SType::SurfaceDescriptorFromWindowsHWND;\n        }\n        alignas(ChainedStruct) void * hinstance;\n        void * hwnd;\n\n        // Equality operators, mostly for testing. Note that this tests\n        // strict pointer-pointer equality if the struct contains member pointers.\n        bool operator==(const SurfaceDescriptorFromWindowsHWND& rhs) const;\n    };\n\n    struct SurfaceDescriptorFromWindowsSwapChainPanel : ChainedStruct {\n        SurfaceDescriptorFromWindowsSwapChainPanel() {\n            sType = wgpu::SType::SurfaceDescriptorFromWindowsSwapChainPanel;\n        }\n        alignas(ChainedStruct) void * swapChainPanel;\n\n        // Equality operators, mostly for testing. Note that this tests\n        // strict pointer-pointer equality if the struct contains member pointers.\n        bool operator==(const SurfaceDescriptorFromWindowsSwapChainPanel& rhs) const;\n    };\n\n    struct SurfaceDescriptorFromXlibWindow : ChainedStruct {\n        SurfaceDescriptorFromXlibWindow() {\n            sType = wgpu::SType::SurfaceDescriptorFromXlibWindow;\n        }\n        alignas(ChainedStruct) void * display;\n        uint32_t window;\n\n        // Equality operators, mostly for testing. Note that this tests\n        // strict pointer-pointer equality if the struct contains member pointers.\n        bool operator==(const SurfaceDescriptorFromXlibWindow& rhs) const;\n    };\n\n    struct SwapChainDescriptor {\n        ChainedStruct const * nextInChain = nullptr;\n        char const * label = nullptr;\n        wgpu::TextureUsage usage;\n        wgpu::TextureFormat format;\n        uint32_t width;\n        uint32_t height;\n        wgpu::PresentMode presentMode;\n        uint64_t implementation = 0;\n\n        // Equality operators, mostly for testing. Note that this tests\n        // strict pointer-pointer equality if the struct contains member pointers.\n        bool operator==(const SwapChainDescriptor& rhs) const;\n    };\n\n    struct TextureBindingLayout {\n        ChainedStruct const * nextInChain = nullptr;\n        wgpu::TextureSampleType sampleType = wgpu::TextureSampleType::Undefined;\n        wgpu::TextureViewDimension viewDimension = wgpu::TextureViewDimension::Undefined;\n        bool multisampled = false;\n\n        // Equality operators, mostly for testing. Note that this tests\n        // strict pointer-pointer equality if the struct contains member pointers.\n        bool operator==(const TextureBindingLayout& rhs) const;\n    };\n\n    struct TextureDataLayout {\n        ChainedStruct const * nextInChain = nullptr;\n        uint64_t offset = 0;\n        uint32_t bytesPerRow = WGPU_COPY_STRIDE_UNDEFINED;\n        uint32_t rowsPerImage = WGPU_COPY_STRIDE_UNDEFINED;\n\n        // Equality operators, mostly for testing. Note that this tests\n        // strict pointer-pointer equality if the struct contains member pointers.\n        bool operator==(const TextureDataLayout& rhs) const;\n    };\n\n    struct TextureViewDescriptor {\n        ChainedStruct const * nextInChain = nullptr;\n        char const * label = nullptr;\n        wgpu::TextureFormat format = wgpu::TextureFormat::Undefined;\n        wgpu::TextureViewDimension dimension = wgpu::TextureViewDimension::Undefined;\n        uint32_t baseMipLevel = 0;\n        uint32_t mipLevelCount = WGPU_MIP_LEVEL_COUNT_UNDEFINED;\n        uint32_t baseArrayLayer = 0;\n        uint32_t arrayLayerCount = WGPU_ARRAY_LAYER_COUNT_UNDEFINED;\n        wgpu::TextureAspect aspect = wgpu::TextureAspect::All;\n\n        // Equality operators, mostly for testing. Note that this tests\n        // strict pointer-pointer equality if the struct contains member pointers.\n        bool operator==(const TextureViewDescriptor& rhs) const;\n    };\n\n    struct VertexAttribute {\n        wgpu::VertexFormat format;\n        uint64_t offset;\n        uint32_t shaderLocation;\n\n        // Equality operators, mostly for testing. Note that this tests\n        // strict pointer-pointer equality if the struct contains member pointers.\n        bool operator==(const VertexAttribute& rhs) const;\n    };\n\n    struct BindGroupDescriptor {\n        ChainedStruct const * nextInChain = nullptr;\n        char const * label = nullptr;\n        BindGroupLayoutBase* layout;\n        uint32_t entryCount;\n        BindGroupEntry const * entries;\n\n        // Equality operators, mostly for testing. Note that this tests\n        // strict pointer-pointer equality if the struct contains member pointers.\n        bool operator==(const BindGroupDescriptor& rhs) const;\n    };\n\n    struct BindGroupLayoutEntry {\n        ChainedStruct const * nextInChain = nullptr;\n        uint32_t binding;\n        wgpu::ShaderStage visibility;\n        BufferBindingLayout buffer;\n        SamplerBindingLayout sampler;\n        TextureBindingLayout texture;\n        StorageTextureBindingLayout storageTexture;\n\n        // Equality operators, mostly for testing. Note that this tests\n        // strict pointer-pointer equality if the struct contains member pointers.\n        bool operator==(const BindGroupLayoutEntry& rhs) const;\n    };\n\n    struct BlendState {\n        BlendComponent color;\n        BlendComponent alpha;\n\n        // Equality operators, mostly for testing. Note that this tests\n        // strict pointer-pointer equality if the struct contains member pointers.\n        bool operator==(const BlendState& rhs) const;\n    };\n\n    struct CompilationInfo {\n        ChainedStruct const * nextInChain = nullptr;\n        uint32_t messageCount;\n        CompilationMessage const * messages;\n\n        // Equality operators, mostly for testing. Note that this tests\n        // strict pointer-pointer equality if the struct contains member pointers.\n        bool operator==(const CompilationInfo& rhs) const;\n    };\n\n    struct DepthStencilState {\n        ChainedStruct const * nextInChain = nullptr;\n        wgpu::TextureFormat format;\n        bool depthWriteEnabled = false;\n        wgpu::CompareFunction depthCompare = wgpu::CompareFunction::Always;\n        StencilFaceState stencilFront;\n        StencilFaceState stencilBack;\n        uint32_t stencilReadMask = 0xFFFFFFFF;\n        uint32_t stencilWriteMask = 0xFFFFFFFF;\n        int32_t depthBias = 0;\n        float depthBiasSlopeScale = 0.0f;\n        float depthBiasClamp = 0.0f;\n\n        // Equality operators, mostly for testing. Note that this tests\n        // strict pointer-pointer equality if the struct contains member pointers.\n        bool operator==(const DepthStencilState& rhs) const;\n    };\n\n    struct ImageCopyBuffer {\n        ChainedStruct const * nextInChain = nullptr;\n        TextureDataLayout layout;\n        BufferBase* buffer;\n\n        // Equality operators, mostly for testing. Note that this tests\n        // strict pointer-pointer equality if the struct contains member pointers.\n        bool operator==(const ImageCopyBuffer& rhs) const;\n    };\n\n    struct ImageCopyTexture {\n        ChainedStruct const * nextInChain = nullptr;\n        TextureBase* texture;\n        uint32_t mipLevel = 0;\n        Origin3D origin;\n        wgpu::TextureAspect aspect = wgpu::TextureAspect::All;\n\n        // Equality operators, mostly for testing. Note that this tests\n        // strict pointer-pointer equality if the struct contains member pointers.\n        bool operator==(const ImageCopyTexture& rhs) const;\n    };\n\n    struct ProgrammableStageDescriptor {\n        ChainedStruct const * nextInChain = nullptr;\n        ShaderModuleBase* module;\n        char const * entryPoint;\n        uint32_t constantCount = 0;\n        ConstantEntry const * constants;\n\n        // Equality operators, mostly for testing. Note that this tests\n        // strict pointer-pointer equality if the struct contains member pointers.\n        bool operator==(const ProgrammableStageDescriptor& rhs) const;\n    };\n\n    struct RenderPassColorAttachment {\n        TextureViewBase* view;\n        TextureViewBase* resolveTarget = nullptr;\n        wgpu::LoadOp loadOp;\n        wgpu::StoreOp storeOp;\n        Color clearColor;\n\n        // Equality operators, mostly for testing. Note that this tests\n        // strict pointer-pointer equality if the struct contains member pointers.\n        bool operator==(const RenderPassColorAttachment& rhs) const;\n    };\n\n    struct RequiredLimits {\n        ChainedStruct const * nextInChain = nullptr;\n        Limits limits;\n\n        // Equality operators, mostly for testing. Note that this tests\n        // strict pointer-pointer equality if the struct contains member pointers.\n        bool operator==(const RequiredLimits& rhs) const;\n    };\n\n    struct SupportedLimits {\n        ChainedStruct const * nextInChain = nullptr;\n        Limits limits;\n\n        // Equality operators, mostly for testing. Note that this tests\n        // strict pointer-pointer equality if the struct contains member pointers.\n        bool operator==(const SupportedLimits& rhs) const;\n    };\n\n    struct TextureDescriptor {\n        ChainedStruct const * nextInChain = nullptr;\n        char const * label = nullptr;\n        wgpu::TextureUsage usage;\n        wgpu::TextureDimension dimension = wgpu::TextureDimension::e2D;\n        Extent3D size;\n        wgpu::TextureFormat format;\n        uint32_t mipLevelCount = 1;\n        uint32_t sampleCount = 1;\n\n        // Equality operators, mostly for testing. Note that this tests\n        // strict pointer-pointer equality if the struct contains member pointers.\n        bool operator==(const TextureDescriptor& rhs) const;\n    };\n\n    struct VertexBufferLayout {\n        uint64_t arrayStride;\n        wgpu::VertexStepMode stepMode = wgpu::VertexStepMode::Vertex;\n        uint32_t attributeCount;\n        VertexAttribute const * attributes;\n\n        // Equality operators, mostly for testing. Note that this tests\n        // strict pointer-pointer equality if the struct contains member pointers.\n        bool operator==(const VertexBufferLayout& rhs) const;\n    };\n\n    struct BindGroupLayoutDescriptor {\n        ChainedStruct const * nextInChain = nullptr;\n        char const * label = nullptr;\n        uint32_t entryCount;\n        BindGroupLayoutEntry const * entries;\n\n        // Equality operators, mostly for testing. Note that this tests\n        // strict pointer-pointer equality if the struct contains member pointers.\n        bool operator==(const BindGroupLayoutDescriptor& rhs) const;\n    };\n\n    struct ColorTargetState {\n        ChainedStruct const * nextInChain = nullptr;\n        wgpu::TextureFormat format;\n        BlendState const * blend = nullptr;\n        wgpu::ColorWriteMask writeMask = wgpu::ColorWriteMask::All;\n\n        // Equality operators, mostly for testing. Note that this tests\n        // strict pointer-pointer equality if the struct contains member pointers.\n        bool operator==(const ColorTargetState& rhs) const;\n    };\n\n    struct ComputePipelineDescriptor {\n        ChainedStruct const * nextInChain = nullptr;\n        char const * label = nullptr;\n        PipelineLayoutBase* layout = nullptr;\n        ProgrammableStageDescriptor compute;\n\n        // Equality operators, mostly for testing. Note that this tests\n        // strict pointer-pointer equality if the struct contains member pointers.\n        bool operator==(const ComputePipelineDescriptor& rhs) const;\n    };\n\n    struct DeviceDescriptor {\n        ChainedStruct const * nextInChain = nullptr;\n        char const * label = nullptr;\n        uint32_t requiredFeaturesCount = 0;\n        wgpu::FeatureName const * requiredFeatures = nullptr;\n        RequiredLimits const * requiredLimits = nullptr;\n\n        // Equality operators, mostly for testing. Note that this tests\n        // strict pointer-pointer equality if the struct contains member pointers.\n        bool operator==(const DeviceDescriptor& rhs) const;\n    };\n\n    struct DeviceProperties {\n        uint32_t deviceID;\n        uint32_t vendorID;\n        wgpu::AdapterType adapterType;\n        bool textureCompressionBC = false;\n        bool textureCompressionETC2 = false;\n        bool textureCompressionASTC = false;\n        bool shaderFloat16 = false;\n        bool pipelineStatisticsQuery = false;\n        bool timestampQuery = false;\n        bool multiPlanarFormats = false;\n        bool depthClamping = false;\n        bool depth24UnormStencil8 = false;\n        bool depth32FloatStencil8 = false;\n        bool invalidFeature = false;\n        bool dawnInternalUsages = false;\n        bool dawnNative = false;\n        SupportedLimits limits;\n\n        // Equality operators, mostly for testing. Note that this tests\n        // strict pointer-pointer equality if the struct contains member pointers.\n        bool operator==(const DeviceProperties& rhs) const;\n    };\n\n    struct RenderPassDescriptor {\n        ChainedStruct const * nextInChain = nullptr;\n        char const * label = nullptr;\n        uint32_t colorAttachmentCount;\n        RenderPassColorAttachment const * colorAttachments;\n        RenderPassDepthStencilAttachment const * depthStencilAttachment = nullptr;\n        QuerySetBase* occlusionQuerySet = nullptr;\n\n        // Equality operators, mostly for testing. Note that this tests\n        // strict pointer-pointer equality if the struct contains member pointers.\n        bool operator==(const RenderPassDescriptor& rhs) const;\n    };\n\n    struct VertexState {\n        ChainedStruct const * nextInChain = nullptr;\n        ShaderModuleBase* module;\n        char const * entryPoint;\n        uint32_t constantCount = 0;\n        ConstantEntry const * constants;\n        uint32_t bufferCount = 0;\n        VertexBufferLayout const * buffers;\n\n        // Equality operators, mostly for testing. Note that this tests\n        // strict pointer-pointer equality if the struct contains member pointers.\n        bool operator==(const VertexState& rhs) const;\n    };\n\n    struct FragmentState {\n        ChainedStruct const * nextInChain = nullptr;\n        ShaderModuleBase* module;\n        char const * entryPoint;\n        uint32_t constantCount = 0;\n        ConstantEntry const * constants;\n        uint32_t targetCount;\n        ColorTargetState const * targets;\n\n        // Equality operators, mostly for testing. Note that this tests\n        // strict pointer-pointer equality if the struct contains member pointers.\n        bool operator==(const FragmentState& rhs) const;\n    };\n\n    struct RenderPipelineDescriptor {\n        ChainedStruct const * nextInChain = nullptr;\n        char const * label = nullptr;\n        PipelineLayoutBase* layout = nullptr;\n        VertexState vertex;\n        PrimitiveState primitive;\n        DepthStencilState const * depthStencil = nullptr;\n        MultisampleState multisample;\n        FragmentState const * fragment = nullptr;\n\n        // Equality operators, mostly for testing. Note that this tests\n        // strict pointer-pointer equality if the struct contains member pointers.\n        bool operator==(const RenderPipelineDescriptor& rhs) const;\n    };\n\n\n\n} // namespace dawn::native\n\n#endif  // DAWNNATIVE_WGPU_STRUCTS_H_\n", "src/dawn/native/wgpu_structs_autogen.cpp": "\n#include \"dawn/native/wgpu_structs_autogen.h\"\n\n#include <tuple>\n\n#ifdef __GNUC__\n// error: 'offsetof' within non-standard-layout type 'wgpu::XXX' is conditionally-supported\n#pragma GCC diagnostic ignored \"-Winvalid-offsetof\"\n#endif\n\nnamespace dawn::native {\n\n    static_assert(sizeof(ChainedStruct) == sizeof(WGPUChainedStruct),\n            \"sizeof mismatch for ChainedStruct\");\n    static_assert(alignof(ChainedStruct) == alignof(WGPUChainedStruct),\n            \"alignof mismatch for ChainedStruct\");\n    static_assert(offsetof(ChainedStruct, nextInChain) == offsetof(WGPUChainedStruct, next),\n            \"offsetof mismatch for ChainedStruct::nextInChain\");\n    static_assert(offsetof(ChainedStruct, sType) == offsetof(WGPUChainedStruct, sType),\n            \"offsetof mismatch for ChainedStruct::sType\");\n\n\n    static_assert(sizeof(AdapterProperties) == sizeof(WGPUAdapterProperties), \"sizeof mismatch for AdapterProperties\");\n    static_assert(alignof(AdapterProperties) == alignof(WGPUAdapterProperties), \"alignof mismatch for AdapterProperties\");\n\n    static_assert(offsetof(AdapterProperties, nextInChain) == offsetof(WGPUAdapterProperties, nextInChain),\n            \"offsetof mismatch for AdapterProperties::nextInChain\");\n    static_assert(offsetof(AdapterProperties, vendorID) == offsetof(WGPUAdapterProperties, vendorID),\n            \"offsetof mismatch for AdapterProperties::vendorID\");\n    static_assert(offsetof(AdapterProperties, deviceID) == offsetof(WGPUAdapterProperties, deviceID),\n            \"offsetof mismatch for AdapterProperties::deviceID\");\n    static_assert(offsetof(AdapterProperties, name) == offsetof(WGPUAdapterProperties, name),\n            \"offsetof mismatch for AdapterProperties::name\");\n    static_assert(offsetof(AdapterProperties, driverDescription) == offsetof(WGPUAdapterProperties, driverDescription),\n            \"offsetof mismatch for AdapterProperties::driverDescription\");\n    static_assert(offsetof(AdapterProperties, adapterType) == offsetof(WGPUAdapterProperties, adapterType),\n            \"offsetof mismatch for AdapterProperties::adapterType\");\n    static_assert(offsetof(AdapterProperties, backendType) == offsetof(WGPUAdapterProperties, backendType),\n            \"offsetof mismatch for AdapterProperties::backendType\");\n\n    bool AdapterProperties::operator==(const AdapterProperties& rhs) const {\n        return (nextInChain == rhs.nextInChain) && std::tie(\n            vendorID,\n            deviceID,\n            name,\n            driverDescription,\n            adapterType,\n            backendType\n        ) == std::tie(\n            rhs.vendorID,\n            rhs.deviceID,\n            rhs.name,\n            rhs.driverDescription,\n            rhs.adapterType,\n            rhs.backendType\n        );\n    }\n\n\n    static_assert(sizeof(BindGroupEntry) == sizeof(WGPUBindGroupEntry), \"sizeof mismatch for BindGroupEntry\");\n    static_assert(alignof(BindGroupEntry) == alignof(WGPUBindGroupEntry), \"alignof mismatch for BindGroupEntry\");\n\n    static_assert(offsetof(BindGroupEntry, nextInChain) == offsetof(WGPUBindGroupEntry, nextInChain),\n            \"offsetof mismatch for BindGroupEntry::nextInChain\");\n    static_assert(offsetof(BindGroupEntry, binding) == offsetof(WGPUBindGroupEntry, binding),\n            \"offsetof mismatch for BindGroupEntry::binding\");\n    static_assert(offsetof(BindGroupEntry, buffer) == offsetof(WGPUBindGroupEntry, buffer),\n            \"offsetof mismatch for BindGroupEntry::buffer\");\n    static_assert(offsetof(BindGroupEntry, offset) == offsetof(WGPUBindGroupEntry, offset),\n            \"offsetof mismatch for BindGroupEntry::offset\");\n    static_assert(offsetof(BindGroupEntry, size) == offsetof(WGPUBindGroupEntry, size),\n            \"offsetof mismatch for BindGroupEntry::size\");\n    static_assert(offsetof(BindGroupEntry, sampler) == offsetof(WGPUBindGroupEntry, sampler),\n            \"offsetof mismatch for BindGroupEntry::sampler\");\n    static_assert(offsetof(BindGroupEntry, textureView) == offsetof(WGPUBindGroupEntry, textureView),\n            \"offsetof mismatch for BindGroupEntry::textureView\");\n\n    bool BindGroupEntry::operator==(const BindGroupEntry& rhs) const {\n        return (nextInChain == rhs.nextInChain) && std::tie(\n            binding,\n            buffer,\n            offset,\n            size,\n            sampler,\n            textureView\n        ) == std::tie(\n            rhs.binding,\n            rhs.buffer,\n            rhs.offset,\n            rhs.size,\n            rhs.sampler,\n            rhs.textureView\n        );\n    }\n\n\n    static_assert(sizeof(BlendComponent) == sizeof(WGPUBlendComponent), \"sizeof mismatch for BlendComponent\");\n    static_assert(alignof(BlendComponent) == alignof(WGPUBlendComponent), \"alignof mismatch for BlendComponent\");\n\n    static_assert(offsetof(BlendComponent, operation) == offsetof(WGPUBlendComponent, operation),\n            \"offsetof mismatch for BlendComponent::operation\");\n    static_assert(offsetof(BlendComponent, srcFactor) == offsetof(WGPUBlendComponent, srcFactor),\n            \"offsetof mismatch for BlendComponent::srcFactor\");\n    static_assert(offsetof(BlendComponent, dstFactor) == offsetof(WGPUBlendComponent, dstFactor),\n            \"offsetof mismatch for BlendComponent::dstFactor\");\n\n    bool BlendComponent::operator==(const BlendComponent& rhs) const {\n        return  std::tie(\n            operation,\n            srcFactor,\n            dstFactor\n        ) == std::tie(\n            rhs.operation,\n            rhs.srcFactor,\n            rhs.dstFactor\n        );\n    }\n\n\n    static_assert(sizeof(BufferBindingLayout) == sizeof(WGPUBufferBindingLayout), \"sizeof mismatch for BufferBindingLayout\");\n    static_assert(alignof(BufferBindingLayout) == alignof(WGPUBufferBindingLayout), \"alignof mismatch for BufferBindingLayout\");\n\n    static_assert(offsetof(BufferBindingLayout, nextInChain) == offsetof(WGPUBufferBindingLayout, nextInChain),\n            \"offsetof mismatch for BufferBindingLayout::nextInChain\");\n    static_assert(offsetof(BufferBindingLayout, type) == offsetof(WGPUBufferBindingLayout, type),\n            \"offsetof mismatch for BufferBindingLayout::type\");\n    static_assert(offsetof(BufferBindingLayout, hasDynamicOffset) == offsetof(WGPUBufferBindingLayout, hasDynamicOffset),\n            \"offsetof mismatch for BufferBindingLayout::hasDynamicOffset\");\n    static_assert(offsetof(BufferBindingLayout, minBindingSize) == offsetof(WGPUBufferBindingLayout, minBindingSize),\n            \"offsetof mismatch for BufferBindingLayout::minBindingSize\");\n\n    bool BufferBindingLayout::operator==(const BufferBindingLayout& rhs) const {\n        return (nextInChain == rhs.nextInChain) && std::tie(\n            type,\n            hasDynamicOffset,\n            minBindingSize\n        ) == std::tie(\n            rhs.type,\n            rhs.hasDynamicOffset,\n            rhs.minBindingSize\n        );\n    }\n\n\n    static_assert(sizeof(BufferDescriptor) == sizeof(WGPUBufferDescriptor), \"sizeof mismatch for BufferDescriptor\");\n    static_assert(alignof(BufferDescriptor) == alignof(WGPUBufferDescriptor), \"alignof mismatch for BufferDescriptor\");\n\n    static_assert(offsetof(BufferDescriptor, nextInChain) == offsetof(WGPUBufferDescriptor, nextInChain),\n            \"offsetof mismatch for BufferDescriptor::nextInChain\");\n    static_assert(offsetof(BufferDescriptor, label) == offsetof(WGPUBufferDescriptor, label),\n            \"offsetof mismatch for BufferDescriptor::label\");\n    static_assert(offsetof(BufferDescriptor, usage) == offsetof(WGPUBufferDescriptor, usage),\n            \"offsetof mismatch for BufferDescriptor::usage\");\n    static_assert(offsetof(BufferDescriptor, size) == offsetof(WGPUBufferDescriptor, size),\n            \"offsetof mismatch for BufferDescriptor::size\");\n    static_assert(offsetof(BufferDescriptor, mappedAtCreation) == offsetof(WGPUBufferDescriptor, mappedAtCreation),\n            \"offsetof mismatch for BufferDescriptor::mappedAtCreation\");\n\n    bool BufferDescriptor::operator==(const BufferDescriptor& rhs) const {\n        return (nextInChain == rhs.nextInChain) && std::tie(\n            label,\n            usage,\n            size,\n            mappedAtCreation\n        ) == std::tie(\n            rhs.label,\n            rhs.usage,\n            rhs.size,\n            rhs.mappedAtCreation\n        );\n    }\n\n\n    static_assert(sizeof(Color) == sizeof(WGPUColor), \"sizeof mismatch for Color\");\n    static_assert(alignof(Color) == alignof(WGPUColor), \"alignof mismatch for Color\");\n\n    static_assert(offsetof(Color, r) == offsetof(WGPUColor, r),\n            \"offsetof mismatch for Color::r\");\n    static_assert(offsetof(Color, g) == offsetof(WGPUColor, g),\n            \"offsetof mismatch for Color::g\");\n    static_assert(offsetof(Color, b) == offsetof(WGPUColor, b),\n            \"offsetof mismatch for Color::b\");\n    static_assert(offsetof(Color, a) == offsetof(WGPUColor, a),\n            \"offsetof mismatch for Color::a\");\n\n    bool Color::operator==(const Color& rhs) const {\n        return  std::tie(\n            r,\n            g,\n            b,\n            a\n        ) == std::tie(\n            rhs.r,\n            rhs.g,\n            rhs.b,\n            rhs.a\n        );\n    }\n\n\n    static_assert(sizeof(CommandBufferDescriptor) == sizeof(WGPUCommandBufferDescriptor), \"sizeof mismatch for CommandBufferDescriptor\");\n    static_assert(alignof(CommandBufferDescriptor) == alignof(WGPUCommandBufferDescriptor), \"alignof mismatch for CommandBufferDescriptor\");\n\n    static_assert(offsetof(CommandBufferDescriptor, nextInChain) == offsetof(WGPUCommandBufferDescriptor, nextInChain),\n            \"offsetof mismatch for CommandBufferDescriptor::nextInChain\");\n    static_assert(offsetof(CommandBufferDescriptor, label) == offsetof(WGPUCommandBufferDescriptor, label),\n            \"offsetof mismatch for CommandBufferDescriptor::label\");\n\n    bool CommandBufferDescriptor::operator==(const CommandBufferDescriptor& rhs) const {\n        return (nextInChain == rhs.nextInChain) && std::tie(\n            label\n        ) == std::tie(\n            rhs.label\n        );\n    }\n\n\n    static_assert(sizeof(CommandEncoderDescriptor) == sizeof(WGPUCommandEncoderDescriptor), \"sizeof mismatch for CommandEncoderDescriptor\");\n    static_assert(alignof(CommandEncoderDescriptor) == alignof(WGPUCommandEncoderDescriptor), \"alignof mismatch for CommandEncoderDescriptor\");\n\n    static_assert(offsetof(CommandEncoderDescriptor, nextInChain) == offsetof(WGPUCommandEncoderDescriptor, nextInChain),\n            \"offsetof mismatch for CommandEncoderDescriptor::nextInChain\");\n    static_assert(offsetof(CommandEncoderDescriptor, label) == offsetof(WGPUCommandEncoderDescriptor, label),\n            \"offsetof mismatch for CommandEncoderDescriptor::label\");\n\n    bool CommandEncoderDescriptor::operator==(const CommandEncoderDescriptor& rhs) const {\n        return (nextInChain == rhs.nextInChain) && std::tie(\n            label\n        ) == std::tie(\n            rhs.label\n        );\n    }\n\n\n    static_assert(sizeof(CompilationMessage) == sizeof(WGPUCompilationMessage), \"sizeof mismatch for CompilationMessage\");\n    static_assert(alignof(CompilationMessage) == alignof(WGPUCompilationMessage), \"alignof mismatch for CompilationMessage\");\n\n    static_assert(offsetof(CompilationMessage, nextInChain) == offsetof(WGPUCompilationMessage, nextInChain),\n            \"offsetof mismatch for CompilationMessage::nextInChain\");\n    static_assert(offsetof(CompilationMessage, message) == offsetof(WGPUCompilationMessage, message),\n            \"offsetof mismatch for CompilationMessage::message\");\n    static_assert(offsetof(CompilationMessage, type) == offsetof(WGPUCompilationMessage, type),\n            \"offsetof mismatch for CompilationMessage::type\");\n    static_assert(offsetof(CompilationMessage, lineNum) == offsetof(WGPUCompilationMessage, lineNum),\n            \"offsetof mismatch for CompilationMessage::lineNum\");\n    static_assert(offsetof(CompilationMessage, linePos) == offsetof(WGPUCompilationMessage, linePos),\n            \"offsetof mismatch for CompilationMessage::linePos\");\n    static_assert(offsetof(CompilationMessage, offset) == offsetof(WGPUCompilationMessage, offset),\n            \"offsetof mismatch for CompilationMessage::offset\");\n    static_assert(offsetof(CompilationMessage, length) == offsetof(WGPUCompilationMessage, length),\n            \"offsetof mismatch for CompilationMessage::length\");\n\n    bool CompilationMessage::operator==(const CompilationMessage& rhs) const {\n        return (nextInChain == rhs.nextInChain) && std::tie(\n            message,\n            type,\n            lineNum,\n            linePos,\n            offset,\n            length\n        ) == std::tie(\n            rhs.message,\n            rhs.type,\n            rhs.lineNum,\n            rhs.linePos,\n            rhs.offset,\n            rhs.length\n        );\n    }\n\n\n    static_assert(sizeof(ComputePassDescriptor) == sizeof(WGPUComputePassDescriptor), \"sizeof mismatch for ComputePassDescriptor\");\n    static_assert(alignof(ComputePassDescriptor) == alignof(WGPUComputePassDescriptor), \"alignof mismatch for ComputePassDescriptor\");\n\n    static_assert(offsetof(ComputePassDescriptor, nextInChain) == offsetof(WGPUComputePassDescriptor, nextInChain),\n            \"offsetof mismatch for ComputePassDescriptor::nextInChain\");\n    static_assert(offsetof(ComputePassDescriptor, label) == offsetof(WGPUComputePassDescriptor, label),\n            \"offsetof mismatch for ComputePassDescriptor::label\");\n\n    bool ComputePassDescriptor::operator==(const ComputePassDescriptor& rhs) const {\n        return (nextInChain == rhs.nextInChain) && std::tie(\n            label\n        ) == std::tie(\n            rhs.label\n        );\n    }\n\n\n    static_assert(sizeof(ConstantEntry) == sizeof(WGPUConstantEntry), \"sizeof mismatch for ConstantEntry\");\n    static_assert(alignof(ConstantEntry) == alignof(WGPUConstantEntry), \"alignof mismatch for ConstantEntry\");\n\n    static_assert(offsetof(ConstantEntry, nextInChain) == offsetof(WGPUConstantEntry, nextInChain),\n            \"offsetof mismatch for ConstantEntry::nextInChain\");\n    static_assert(offsetof(ConstantEntry, key) == offsetof(WGPUConstantEntry, key),\n            \"offsetof mismatch for ConstantEntry::key\");\n    static_assert(offsetof(ConstantEntry, value) == offsetof(WGPUConstantEntry, value),\n            \"offsetof mismatch for ConstantEntry::value\");\n\n    bool ConstantEntry::operator==(const ConstantEntry& rhs) const {\n        return (nextInChain == rhs.nextInChain) && std::tie(\n            key,\n            value\n        ) == std::tie(\n            rhs.key,\n            rhs.value\n        );\n    }\n\n\n    static_assert(sizeof(CopyTextureForBrowserOptions) == sizeof(WGPUCopyTextureForBrowserOptions), \"sizeof mismatch for CopyTextureForBrowserOptions\");\n    static_assert(alignof(CopyTextureForBrowserOptions) == alignof(WGPUCopyTextureForBrowserOptions), \"alignof mismatch for CopyTextureForBrowserOptions\");\n\n    static_assert(offsetof(CopyTextureForBrowserOptions, nextInChain) == offsetof(WGPUCopyTextureForBrowserOptions, nextInChain),\n            \"offsetof mismatch for CopyTextureForBrowserOptions::nextInChain\");\n    static_assert(offsetof(CopyTextureForBrowserOptions, flipY) == offsetof(WGPUCopyTextureForBrowserOptions, flipY),\n            \"offsetof mismatch for CopyTextureForBrowserOptions::flipY\");\n    static_assert(offsetof(CopyTextureForBrowserOptions, needsColorSpaceConversion) == offsetof(WGPUCopyTextureForBrowserOptions, needsColorSpaceConversion),\n            \"offsetof mismatch for CopyTextureForBrowserOptions::needsColorSpaceConversion\");\n    static_assert(offsetof(CopyTextureForBrowserOptions, srcAlphaMode) == offsetof(WGPUCopyTextureForBrowserOptions, srcAlphaMode),\n            \"offsetof mismatch for CopyTextureForBrowserOptions::srcAlphaMode\");\n    static_assert(offsetof(CopyTextureForBrowserOptions, srcTransferFunctionParameters) == offsetof(WGPUCopyTextureForBrowserOptions, srcTransferFunctionParameters),\n            \"offsetof mismatch for CopyTextureForBrowserOptions::srcTransferFunctionParameters\");\n    static_assert(offsetof(CopyTextureForBrowserOptions, conversionMatrix) == offsetof(WGPUCopyTextureForBrowserOptions, conversionMatrix),\n            \"offsetof mismatch for CopyTextureForBrowserOptions::conversionMatrix\");\n    static_assert(offsetof(CopyTextureForBrowserOptions, dstTransferFunctionParameters) == offsetof(WGPUCopyTextureForBrowserOptions, dstTransferFunctionParameters),\n            \"offsetof mismatch for CopyTextureForBrowserOptions::dstTransferFunctionParameters\");\n    static_assert(offsetof(CopyTextureForBrowserOptions, dstAlphaMode) == offsetof(WGPUCopyTextureForBrowserOptions, dstAlphaMode),\n            \"offsetof mismatch for CopyTextureForBrowserOptions::dstAlphaMode\");\n\n    bool CopyTextureForBrowserOptions::operator==(const CopyTextureForBrowserOptions& rhs) const {\n        return (nextInChain == rhs.nextInChain) && std::tie(\n            flipY,\n            needsColorSpaceConversion,\n            srcAlphaMode,\n            srcTransferFunctionParameters,\n            conversionMatrix,\n            dstTransferFunctionParameters,\n            dstAlphaMode\n        ) == std::tie(\n            rhs.flipY,\n            rhs.needsColorSpaceConversion,\n            rhs.srcAlphaMode,\n            rhs.srcTransferFunctionParameters,\n            rhs.conversionMatrix,\n            rhs.dstTransferFunctionParameters,\n            rhs.dstAlphaMode\n        );\n    }\n\n\n    static_assert(sizeof(DawnEncoderInternalUsageDescriptor) == sizeof(WGPUDawnEncoderInternalUsageDescriptor), \"sizeof mismatch for DawnEncoderInternalUsageDescriptor\");\n    static_assert(alignof(DawnEncoderInternalUsageDescriptor) == alignof(WGPUDawnEncoderInternalUsageDescriptor), \"alignof mismatch for DawnEncoderInternalUsageDescriptor\");\n\n    static_assert(offsetof(DawnEncoderInternalUsageDescriptor, useInternalUsages) == offsetof(WGPUDawnEncoderInternalUsageDescriptor, useInternalUsages),\n            \"offsetof mismatch for DawnEncoderInternalUsageDescriptor::useInternalUsages\");\n\n    bool DawnEncoderInternalUsageDescriptor::operator==(const DawnEncoderInternalUsageDescriptor& rhs) const {\n        return (nextInChain == rhs.nextInChain) && std::tie(\n            useInternalUsages\n        ) == std::tie(\n            rhs.useInternalUsages\n        );\n    }\n\n\n    static_assert(sizeof(DawnInstanceDescriptor) == sizeof(WGPUDawnInstanceDescriptor), \"sizeof mismatch for DawnInstanceDescriptor\");\n    static_assert(alignof(DawnInstanceDescriptor) == alignof(WGPUDawnInstanceDescriptor), \"alignof mismatch for DawnInstanceDescriptor\");\n\n    static_assert(offsetof(DawnInstanceDescriptor, additionalRuntimeSearchPathsCount) == offsetof(WGPUDawnInstanceDescriptor, additionalRuntimeSearchPathsCount),\n            \"offsetof mismatch for DawnInstanceDescriptor::additionalRuntimeSearchPathsCount\");\n    static_assert(offsetof(DawnInstanceDescriptor, additionalRuntimeSearchPaths) == offsetof(WGPUDawnInstanceDescriptor, additionalRuntimeSearchPaths),\n            \"offsetof mismatch for DawnInstanceDescriptor::additionalRuntimeSearchPaths\");\n\n    bool DawnInstanceDescriptor::operator==(const DawnInstanceDescriptor& rhs) const {\n        return (nextInChain == rhs.nextInChain) && std::tie(\n            additionalRuntimeSearchPathsCount,\n            additionalRuntimeSearchPaths\n        ) == std::tie(\n            rhs.additionalRuntimeSearchPathsCount,\n            rhs.additionalRuntimeSearchPaths\n        );\n    }\n\n\n    static_assert(sizeof(DawnTextureInternalUsageDescriptor) == sizeof(WGPUDawnTextureInternalUsageDescriptor), \"sizeof mismatch for DawnTextureInternalUsageDescriptor\");\n    static_assert(alignof(DawnTextureInternalUsageDescriptor) == alignof(WGPUDawnTextureInternalUsageDescriptor), \"alignof mismatch for DawnTextureInternalUsageDescriptor\");\n\n    static_assert(offsetof(DawnTextureInternalUsageDescriptor, internalUsage) == offsetof(WGPUDawnTextureInternalUsageDescriptor, internalUsage),\n            \"offsetof mismatch for DawnTextureInternalUsageDescriptor::internalUsage\");\n\n    bool DawnTextureInternalUsageDescriptor::operator==(const DawnTextureInternalUsageDescriptor& rhs) const {\n        return (nextInChain == rhs.nextInChain) && std::tie(\n            internalUsage\n        ) == std::tie(\n            rhs.internalUsage\n        );\n    }\n\n\n    static_assert(sizeof(DawnTogglesDeviceDescriptor) == sizeof(WGPUDawnTogglesDeviceDescriptor), \"sizeof mismatch for DawnTogglesDeviceDescriptor\");\n    static_assert(alignof(DawnTogglesDeviceDescriptor) == alignof(WGPUDawnTogglesDeviceDescriptor), \"alignof mismatch for DawnTogglesDeviceDescriptor\");\n\n    static_assert(offsetof(DawnTogglesDeviceDescriptor, forceEnabledTogglesCount) == offsetof(WGPUDawnTogglesDeviceDescriptor, forceEnabledTogglesCount),\n            \"offsetof mismatch for DawnTogglesDeviceDescriptor::forceEnabledTogglesCount\");\n    static_assert(offsetof(DawnTogglesDeviceDescriptor, forceEnabledToggles) == offsetof(WGPUDawnTogglesDeviceDescriptor, forceEnabledToggles),\n            \"offsetof mismatch for DawnTogglesDeviceDescriptor::forceEnabledToggles\");\n    static_assert(offsetof(DawnTogglesDeviceDescriptor, forceDisabledTogglesCount) == offsetof(WGPUDawnTogglesDeviceDescriptor, forceDisabledTogglesCount),\n            \"offsetof mismatch for DawnTogglesDeviceDescriptor::forceDisabledTogglesCount\");\n    static_assert(offsetof(DawnTogglesDeviceDescriptor, forceDisabledToggles) == offsetof(WGPUDawnTogglesDeviceDescriptor, forceDisabledToggles),\n            \"offsetof mismatch for DawnTogglesDeviceDescriptor::forceDisabledToggles\");\n\n    bool DawnTogglesDeviceDescriptor::operator==(const DawnTogglesDeviceDescriptor& rhs) const {\n        return (nextInChain == rhs.nextInChain) && std::tie(\n            forceEnabledTogglesCount,\n            forceEnabledToggles,\n            forceDisabledTogglesCount,\n            forceDisabledToggles\n        ) == std::tie(\n            rhs.forceEnabledTogglesCount,\n            rhs.forceEnabledToggles,\n            rhs.forceDisabledTogglesCount,\n            rhs.forceDisabledToggles\n        );\n    }\n\n\n    static_assert(sizeof(Extent3D) == sizeof(WGPUExtent3D), \"sizeof mismatch for Extent3D\");\n    static_assert(alignof(Extent3D) == alignof(WGPUExtent3D), \"alignof mismatch for Extent3D\");\n\n    static_assert(offsetof(Extent3D, width) == offsetof(WGPUExtent3D, width),\n            \"offsetof mismatch for Extent3D::width\");\n    static_assert(offsetof(Extent3D, height) == offsetof(WGPUExtent3D, height),\n            \"offsetof mismatch for Extent3D::height\");\n    static_assert(offsetof(Extent3D, depthOrArrayLayers) == offsetof(WGPUExtent3D, depthOrArrayLayers),\n            \"offsetof mismatch for Extent3D::depthOrArrayLayers\");\n\n    bool Extent3D::operator==(const Extent3D& rhs) const {\n        return  std::tie(\n            width,\n            height,\n            depthOrArrayLayers\n        ) == std::tie(\n            rhs.width,\n            rhs.height,\n            rhs.depthOrArrayLayers\n        );\n    }\n\n\n    static_assert(sizeof(ExternalTextureBindingEntry) == sizeof(WGPUExternalTextureBindingEntry), \"sizeof mismatch for ExternalTextureBindingEntry\");\n    static_assert(alignof(ExternalTextureBindingEntry) == alignof(WGPUExternalTextureBindingEntry), \"alignof mismatch for ExternalTextureBindingEntry\");\n\n    static_assert(offsetof(ExternalTextureBindingEntry, externalTexture) == offsetof(WGPUExternalTextureBindingEntry, externalTexture),\n            \"offsetof mismatch for ExternalTextureBindingEntry::externalTexture\");\n\n    bool ExternalTextureBindingEntry::operator==(const ExternalTextureBindingEntry& rhs) const {\n        return (nextInChain == rhs.nextInChain) && std::tie(\n            externalTexture\n        ) == std::tie(\n            rhs.externalTexture\n        );\n    }\n\n\n    static_assert(sizeof(ExternalTextureBindingLayout) == sizeof(WGPUExternalTextureBindingLayout), \"sizeof mismatch for ExternalTextureBindingLayout\");\n    static_assert(alignof(ExternalTextureBindingLayout) == alignof(WGPUExternalTextureBindingLayout), \"alignof mismatch for ExternalTextureBindingLayout\");\n\n\n    bool ExternalTextureBindingLayout::operator==(const ExternalTextureBindingLayout& rhs) const {\n        return (nextInChain == rhs.nextInChain) && std::tie(\n        ) == std::tie(\n        );\n    }\n\n\n    static_assert(sizeof(ExternalTextureDescriptor) == sizeof(WGPUExternalTextureDescriptor), \"sizeof mismatch for ExternalTextureDescriptor\");\n    static_assert(alignof(ExternalTextureDescriptor) == alignof(WGPUExternalTextureDescriptor), \"alignof mismatch for ExternalTextureDescriptor\");\n\n    static_assert(offsetof(ExternalTextureDescriptor, nextInChain) == offsetof(WGPUExternalTextureDescriptor, nextInChain),\n            \"offsetof mismatch for ExternalTextureDescriptor::nextInChain\");\n    static_assert(offsetof(ExternalTextureDescriptor, label) == offsetof(WGPUExternalTextureDescriptor, label),\n            \"offsetof mismatch for ExternalTextureDescriptor::label\");\n    static_assert(offsetof(ExternalTextureDescriptor, plane0) == offsetof(WGPUExternalTextureDescriptor, plane0),\n            \"offsetof mismatch for ExternalTextureDescriptor::plane0\");\n    static_assert(offsetof(ExternalTextureDescriptor, plane1) == offsetof(WGPUExternalTextureDescriptor, plane1),\n            \"offsetof mismatch for ExternalTextureDescriptor::plane1\");\n    static_assert(offsetof(ExternalTextureDescriptor, colorSpace) == offsetof(WGPUExternalTextureDescriptor, colorSpace),\n            \"offsetof mismatch for ExternalTextureDescriptor::colorSpace\");\n\n    bool ExternalTextureDescriptor::operator==(const ExternalTextureDescriptor& rhs) const {\n        return (nextInChain == rhs.nextInChain) && std::tie(\n            label,\n            plane0,\n            plane1,\n            colorSpace\n        ) == std::tie(\n            rhs.label,\n            rhs.plane0,\n            rhs.plane1,\n            rhs.colorSpace\n        );\n    }\n\n\n    static_assert(sizeof(InstanceDescriptor) == sizeof(WGPUInstanceDescriptor), \"sizeof mismatch for InstanceDescriptor\");\n    static_assert(alignof(InstanceDescriptor) == alignof(WGPUInstanceDescriptor), \"alignof mismatch for InstanceDescriptor\");\n\n    static_assert(offsetof(InstanceDescriptor, nextInChain) == offsetof(WGPUInstanceDescriptor, nextInChain),\n            \"offsetof mismatch for InstanceDescriptor::nextInChain\");\n\n    bool InstanceDescriptor::operator==(const InstanceDescriptor& rhs) const {\n        return (nextInChain == rhs.nextInChain) && std::tie(\n        ) == std::tie(\n        );\n    }\n\n\n    static_assert(sizeof(Limits) == sizeof(WGPULimits), \"sizeof mismatch for Limits\");\n    static_assert(alignof(Limits) == alignof(WGPULimits), \"alignof mismatch for Limits\");\n\n    static_assert(offsetof(Limits, maxTextureDimension1D) == offsetof(WGPULimits, maxTextureDimension1D),\n            \"offsetof mismatch for Limits::maxTextureDimension1D\");\n    static_assert(offsetof(Limits, maxTextureDimension2D) == offsetof(WGPULimits, maxTextureDimension2D),\n            \"offsetof mismatch for Limits::maxTextureDimension2D\");\n    static_assert(offsetof(Limits, maxTextureDimension3D) == offsetof(WGPULimits, maxTextureDimension3D),\n            \"offsetof mismatch for Limits::maxTextureDimension3D\");\n    static_assert(offsetof(Limits, maxTextureArrayLayers) == offsetof(WGPULimits, maxTextureArrayLayers),\n            \"offsetof mismatch for Limits::maxTextureArrayLayers\");\n    static_assert(offsetof(Limits, maxBindGroups) == offsetof(WGPULimits, maxBindGroups),\n            \"offsetof mismatch for Limits::maxBindGroups\");\n    static_assert(offsetof(Limits, maxDynamicUniformBuffersPerPipelineLayout) == offsetof(WGPULimits, maxDynamicUniformBuffersPerPipelineLayout),\n            \"offsetof mismatch for Limits::maxDynamicUniformBuffersPerPipelineLayout\");\n    static_assert(offsetof(Limits, maxDynamicStorageBuffersPerPipelineLayout) == offsetof(WGPULimits, maxDynamicStorageBuffersPerPipelineLayout),\n            \"offsetof mismatch for Limits::maxDynamicStorageBuffersPerPipelineLayout\");\n    static_assert(offsetof(Limits, maxSampledTexturesPerShaderStage) == offsetof(WGPULimits, maxSampledTexturesPerShaderStage),\n            \"offsetof mismatch for Limits::maxSampledTexturesPerShaderStage\");\n    static_assert(offsetof(Limits, maxSamplersPerShaderStage) == offsetof(WGPULimits, maxSamplersPerShaderStage),\n            \"offsetof mismatch for Limits::maxSamplersPerShaderStage\");\n    static_assert(offsetof(Limits, maxStorageBuffersPerShaderStage) == offsetof(WGPULimits, maxStorageBuffersPerShaderStage),\n            \"offsetof mismatch for Limits::maxStorageBuffersPerShaderStage\");\n    static_assert(offsetof(Limits, maxStorageTexturesPerShaderStage) == offsetof(WGPULimits, maxStorageTexturesPerShaderStage),\n            \"offsetof mismatch for Limits::maxStorageTexturesPerShaderStage\");\n    static_assert(offsetof(Limits, maxUniformBuffersPerShaderStage) == offsetof(WGPULimits, maxUniformBuffersPerShaderStage),\n            \"offsetof mismatch for Limits::maxUniformBuffersPerShaderStage\");\n    static_assert(offsetof(Limits, maxUniformBufferBindingSize) == offsetof(WGPULimits, maxUniformBufferBindingSize),\n            \"offsetof mismatch for Limits::maxUniformBufferBindingSize\");\n    static_assert(offsetof(Limits, maxStorageBufferBindingSize) == offsetof(WGPULimits, maxStorageBufferBindingSize),\n            \"offsetof mismatch for Limits::maxStorageBufferBindingSize\");\n    static_assert(offsetof(Limits, minUniformBufferOffsetAlignment) == offsetof(WGPULimits, minUniformBufferOffsetAlignment),\n            \"offsetof mismatch for Limits::minUniformBufferOffsetAlignment\");\n    static_assert(offsetof(Limits, minStorageBufferOffsetAlignment) == offsetof(WGPULimits, minStorageBufferOffsetAlignment),\n            \"offsetof mismatch for Limits::minStorageBufferOffsetAlignment\");\n    static_assert(offsetof(Limits, maxVertexBuffers) == offsetof(WGPULimits, maxVertexBuffers),\n            \"offsetof mismatch for Limits::maxVertexBuffers\");\n    static_assert(offsetof(Limits, maxVertexAttributes) == offsetof(WGPULimits, maxVertexAttributes),\n            \"offsetof mismatch for Limits::maxVertexAttributes\");\n    static_assert(offsetof(Limits, maxVertexBufferArrayStride) == offsetof(WGPULimits, maxVertexBufferArrayStride),\n            \"offsetof mismatch for Limits::maxVertexBufferArrayStride\");\n    static_assert(offsetof(Limits, maxInterStageShaderComponents) == offsetof(WGPULimits, maxInterStageShaderComponents),\n            \"offsetof mismatch for Limits::maxInterStageShaderComponents\");\n    static_assert(offsetof(Limits, maxComputeWorkgroupStorageSize) == offsetof(WGPULimits, maxComputeWorkgroupStorageSize),\n            \"offsetof mismatch for Limits::maxComputeWorkgroupStorageSize\");\n    static_assert(offsetof(Limits, maxComputeInvocationsPerWorkgroup) == offsetof(WGPULimits, maxComputeInvocationsPerWorkgroup),\n            \"offsetof mismatch for Limits::maxComputeInvocationsPerWorkgroup\");\n    static_assert(offsetof(Limits, maxComputeWorkgroupSizeX) == offsetof(WGPULimits, maxComputeWorkgroupSizeX),\n            \"offsetof mismatch for Limits::maxComputeWorkgroupSizeX\");\n    static_assert(offsetof(Limits, maxComputeWorkgroupSizeY) == offsetof(WGPULimits, maxComputeWorkgroupSizeY),\n            \"offsetof mismatch for Limits::maxComputeWorkgroupSizeY\");\n    static_assert(offsetof(Limits, maxComputeWorkgroupSizeZ) == offsetof(WGPULimits, maxComputeWorkgroupSizeZ),\n            \"offsetof mismatch for Limits::maxComputeWorkgroupSizeZ\");\n    static_assert(offsetof(Limits, maxComputeWorkgroupsPerDimension) == offsetof(WGPULimits, maxComputeWorkgroupsPerDimension),\n            \"offsetof mismatch for Limits::maxComputeWorkgroupsPerDimension\");\n\n    bool Limits::operator==(const Limits& rhs) const {\n        return  std::tie(\n            maxTextureDimension1D,\n            maxTextureDimension2D,\n            maxTextureDimension3D,\n            maxTextureArrayLayers,\n            maxBindGroups,\n            maxDynamicUniformBuffersPerPipelineLayout,\n            maxDynamicStorageBuffersPerPipelineLayout,\n            maxSampledTexturesPerShaderStage,\n            maxSamplersPerShaderStage,\n            maxStorageBuffersPerShaderStage,\n            maxStorageTexturesPerShaderStage,\n            maxUniformBuffersPerShaderStage,\n            maxUniformBufferBindingSize,\n            maxStorageBufferBindingSize,\n            minUniformBufferOffsetAlignment,\n            minStorageBufferOffsetAlignment,\n            maxVertexBuffers,\n            maxVertexAttributes,\n            maxVertexBufferArrayStride,\n            maxInterStageShaderComponents,\n            maxComputeWorkgroupStorageSize,\n            maxComputeInvocationsPerWorkgroup,\n            maxComputeWorkgroupSizeX,\n            maxComputeWorkgroupSizeY,\n            maxComputeWorkgroupSizeZ,\n            maxComputeWorkgroupsPerDimension\n        ) == std::tie(\n            rhs.maxTextureDimension1D,\n            rhs.maxTextureDimension2D,\n            rhs.maxTextureDimension3D,\n            rhs.maxTextureArrayLayers,\n            rhs.maxBindGroups,\n            rhs.maxDynamicUniformBuffersPerPipelineLayout,\n            rhs.maxDynamicStorageBuffersPerPipelineLayout,\n            rhs.maxSampledTexturesPerShaderStage,\n            rhs.maxSamplersPerShaderStage,\n            rhs.maxStorageBuffersPerShaderStage,\n            rhs.maxStorageTexturesPerShaderStage,\n            rhs.maxUniformBuffersPerShaderStage,\n            rhs.maxUniformBufferBindingSize,\n            rhs.maxStorageBufferBindingSize,\n            rhs.minUniformBufferOffsetAlignment,\n            rhs.minStorageBufferOffsetAlignment,\n            rhs.maxVertexBuffers,\n            rhs.maxVertexAttributes,\n            rhs.maxVertexBufferArrayStride,\n            rhs.maxInterStageShaderComponents,\n            rhs.maxComputeWorkgroupStorageSize,\n            rhs.maxComputeInvocationsPerWorkgroup,\n            rhs.maxComputeWorkgroupSizeX,\n            rhs.maxComputeWorkgroupSizeY,\n            rhs.maxComputeWorkgroupSizeZ,\n            rhs.maxComputeWorkgroupsPerDimension\n        );\n    }\n\n\n    static_assert(sizeof(MultisampleState) == sizeof(WGPUMultisampleState), \"sizeof mismatch for MultisampleState\");\n    static_assert(alignof(MultisampleState) == alignof(WGPUMultisampleState), \"alignof mismatch for MultisampleState\");\n\n    static_assert(offsetof(MultisampleState, nextInChain) == offsetof(WGPUMultisampleState, nextInChain),\n            \"offsetof mismatch for MultisampleState::nextInChain\");\n    static_assert(offsetof(MultisampleState, count) == offsetof(WGPUMultisampleState, count),\n            \"offsetof mismatch for MultisampleState::count\");\n    static_assert(offsetof(MultisampleState, mask) == offsetof(WGPUMultisampleState, mask),\n            \"offsetof mismatch for MultisampleState::mask\");\n    static_assert(offsetof(MultisampleState, alphaToCoverageEnabled) == offsetof(WGPUMultisampleState, alphaToCoverageEnabled),\n            \"offsetof mismatch for MultisampleState::alphaToCoverageEnabled\");\n\n    bool MultisampleState::operator==(const MultisampleState& rhs) const {\n        return (nextInChain == rhs.nextInChain) && std::tie(\n            count,\n            mask,\n            alphaToCoverageEnabled\n        ) == std::tie(\n            rhs.count,\n            rhs.mask,\n            rhs.alphaToCoverageEnabled\n        );\n    }\n\n\n    static_assert(sizeof(Origin3D) == sizeof(WGPUOrigin3D), \"sizeof mismatch for Origin3D\");\n    static_assert(alignof(Origin3D) == alignof(WGPUOrigin3D), \"alignof mismatch for Origin3D\");\n\n    static_assert(offsetof(Origin3D, x) == offsetof(WGPUOrigin3D, x),\n            \"offsetof mismatch for Origin3D::x\");\n    static_assert(offsetof(Origin3D, y) == offsetof(WGPUOrigin3D, y),\n            \"offsetof mismatch for Origin3D::y\");\n    static_assert(offsetof(Origin3D, z) == offsetof(WGPUOrigin3D, z),\n            \"offsetof mismatch for Origin3D::z\");\n\n    bool Origin3D::operator==(const Origin3D& rhs) const {\n        return  std::tie(\n            x,\n            y,\n            z\n        ) == std::tie(\n            rhs.x,\n            rhs.y,\n            rhs.z\n        );\n    }\n\n\n    static_assert(sizeof(PipelineLayoutDescriptor) == sizeof(WGPUPipelineLayoutDescriptor), \"sizeof mismatch for PipelineLayoutDescriptor\");\n    static_assert(alignof(PipelineLayoutDescriptor) == alignof(WGPUPipelineLayoutDescriptor), \"alignof mismatch for PipelineLayoutDescriptor\");\n\n    static_assert(offsetof(PipelineLayoutDescriptor, nextInChain) == offsetof(WGPUPipelineLayoutDescriptor, nextInChain),\n            \"offsetof mismatch for PipelineLayoutDescriptor::nextInChain\");\n    static_assert(offsetof(PipelineLayoutDescriptor, label) == offsetof(WGPUPipelineLayoutDescriptor, label),\n            \"offsetof mismatch for PipelineLayoutDescriptor::label\");\n    static_assert(offsetof(PipelineLayoutDescriptor, bindGroupLayoutCount) == offsetof(WGPUPipelineLayoutDescriptor, bindGroupLayoutCount),\n            \"offsetof mismatch for PipelineLayoutDescriptor::bindGroupLayoutCount\");\n    static_assert(offsetof(PipelineLayoutDescriptor, bindGroupLayouts) == offsetof(WGPUPipelineLayoutDescriptor, bindGroupLayouts),\n            \"offsetof mismatch for PipelineLayoutDescriptor::bindGroupLayouts\");\n\n    bool PipelineLayoutDescriptor::operator==(const PipelineLayoutDescriptor& rhs) const {\n        return (nextInChain == rhs.nextInChain) && std::tie(\n            label,\n            bindGroupLayoutCount,\n            bindGroupLayouts\n        ) == std::tie(\n            rhs.label,\n            rhs.bindGroupLayoutCount,\n            rhs.bindGroupLayouts\n        );\n    }\n\n\n    static_assert(sizeof(PrimitiveDepthClampingState) == sizeof(WGPUPrimitiveDepthClampingState), \"sizeof mismatch for PrimitiveDepthClampingState\");\n    static_assert(alignof(PrimitiveDepthClampingState) == alignof(WGPUPrimitiveDepthClampingState), \"alignof mismatch for PrimitiveDepthClampingState\");\n\n    static_assert(offsetof(PrimitiveDepthClampingState, clampDepth) == offsetof(WGPUPrimitiveDepthClampingState, clampDepth),\n            \"offsetof mismatch for PrimitiveDepthClampingState::clampDepth\");\n\n    bool PrimitiveDepthClampingState::operator==(const PrimitiveDepthClampingState& rhs) const {\n        return (nextInChain == rhs.nextInChain) && std::tie(\n            clampDepth\n        ) == std::tie(\n            rhs.clampDepth\n        );\n    }\n\n\n    static_assert(sizeof(PrimitiveState) == sizeof(WGPUPrimitiveState), \"sizeof mismatch for PrimitiveState\");\n    static_assert(alignof(PrimitiveState) == alignof(WGPUPrimitiveState), \"alignof mismatch for PrimitiveState\");\n\n    static_assert(offsetof(PrimitiveState, nextInChain) == offsetof(WGPUPrimitiveState, nextInChain),\n            \"offsetof mismatch for PrimitiveState::nextInChain\");\n    static_assert(offsetof(PrimitiveState, topology) == offsetof(WGPUPrimitiveState, topology),\n            \"offsetof mismatch for PrimitiveState::topology\");\n    static_assert(offsetof(PrimitiveState, stripIndexFormat) == offsetof(WGPUPrimitiveState, stripIndexFormat),\n            \"offsetof mismatch for PrimitiveState::stripIndexFormat\");\n    static_assert(offsetof(PrimitiveState, frontFace) == offsetof(WGPUPrimitiveState, frontFace),\n            \"offsetof mismatch for PrimitiveState::frontFace\");\n    static_assert(offsetof(PrimitiveState, cullMode) == offsetof(WGPUPrimitiveState, cullMode),\n            \"offsetof mismatch for PrimitiveState::cullMode\");\n\n    bool PrimitiveState::operator==(const PrimitiveState& rhs) const {\n        return (nextInChain == rhs.nextInChain) && std::tie(\n            topology,\n            stripIndexFormat,\n            frontFace,\n            cullMode\n        ) == std::tie(\n            rhs.topology,\n            rhs.stripIndexFormat,\n            rhs.frontFace,\n            rhs.cullMode\n        );\n    }\n\n\n    static_assert(sizeof(QuerySetDescriptor) == sizeof(WGPUQuerySetDescriptor), \"sizeof mismatch for QuerySetDescriptor\");\n    static_assert(alignof(QuerySetDescriptor) == alignof(WGPUQuerySetDescriptor), \"alignof mismatch for QuerySetDescriptor\");\n\n    static_assert(offsetof(QuerySetDescriptor, nextInChain) == offsetof(WGPUQuerySetDescriptor, nextInChain),\n            \"offsetof mismatch for QuerySetDescriptor::nextInChain\");\n    static_assert(offsetof(QuerySetDescriptor, label) == offsetof(WGPUQuerySetDescriptor, label),\n            \"offsetof mismatch for QuerySetDescriptor::label\");\n    static_assert(offsetof(QuerySetDescriptor, type) == offsetof(WGPUQuerySetDescriptor, type),\n            \"offsetof mismatch for QuerySetDescriptor::type\");\n    static_assert(offsetof(QuerySetDescriptor, count) == offsetof(WGPUQuerySetDescriptor, count),\n            \"offsetof mismatch for QuerySetDescriptor::count\");\n    static_assert(offsetof(QuerySetDescriptor, pipelineStatistics) == offsetof(WGPUQuerySetDescriptor, pipelineStatistics),\n            \"offsetof mismatch for QuerySetDescriptor::pipelineStatistics\");\n    static_assert(offsetof(QuerySetDescriptor, pipelineStatisticsCount) == offsetof(WGPUQuerySetDescriptor, pipelineStatisticsCount),\n            \"offsetof mismatch for QuerySetDescriptor::pipelineStatisticsCount\");\n\n    bool QuerySetDescriptor::operator==(const QuerySetDescriptor& rhs) const {\n        return (nextInChain == rhs.nextInChain) && std::tie(\n            label,\n            type,\n            count,\n            pipelineStatistics,\n            pipelineStatisticsCount\n        ) == std::tie(\n            rhs.label,\n            rhs.type,\n            rhs.count,\n            rhs.pipelineStatistics,\n            rhs.pipelineStatisticsCount\n        );\n    }\n\n\n    static_assert(sizeof(RenderBundleDescriptor) == sizeof(WGPURenderBundleDescriptor), \"sizeof mismatch for RenderBundleDescriptor\");\n    static_assert(alignof(RenderBundleDescriptor) == alignof(WGPURenderBundleDescriptor), \"alignof mismatch for RenderBundleDescriptor\");\n\n    static_assert(offsetof(RenderBundleDescriptor, nextInChain) == offsetof(WGPURenderBundleDescriptor, nextInChain),\n            \"offsetof mismatch for RenderBundleDescriptor::nextInChain\");\n    static_assert(offsetof(RenderBundleDescriptor, label) == offsetof(WGPURenderBundleDescriptor, label),\n            \"offsetof mismatch for RenderBundleDescriptor::label\");\n\n    bool RenderBundleDescriptor::operator==(const RenderBundleDescriptor& rhs) const {\n        return (nextInChain == rhs.nextInChain) && std::tie(\n            label\n        ) == std::tie(\n            rhs.label\n        );\n    }\n\n\n    static_assert(sizeof(RenderBundleEncoderDescriptor) == sizeof(WGPURenderBundleEncoderDescriptor), \"sizeof mismatch for RenderBundleEncoderDescriptor\");\n    static_assert(alignof(RenderBundleEncoderDescriptor) == alignof(WGPURenderBundleEncoderDescriptor), \"alignof mismatch for RenderBundleEncoderDescriptor\");\n\n    static_assert(offsetof(RenderBundleEncoderDescriptor, nextInChain) == offsetof(WGPURenderBundleEncoderDescriptor, nextInChain),\n            \"offsetof mismatch for RenderBundleEncoderDescriptor::nextInChain\");\n    static_assert(offsetof(RenderBundleEncoderDescriptor, label) == offsetof(WGPURenderBundleEncoderDescriptor, label),\n            \"offsetof mismatch for RenderBundleEncoderDescriptor::label\");\n    static_assert(offsetof(RenderBundleEncoderDescriptor, colorFormatsCount) == offsetof(WGPURenderBundleEncoderDescriptor, colorFormatsCount),\n            \"offsetof mismatch for RenderBundleEncoderDescriptor::colorFormatsCount\");\n    static_assert(offsetof(RenderBundleEncoderDescriptor, colorFormats) == offsetof(WGPURenderBundleEncoderDescriptor, colorFormats),\n            \"offsetof mismatch for RenderBundleEncoderDescriptor::colorFormats\");\n    static_assert(offsetof(RenderBundleEncoderDescriptor, depthStencilFormat) == offsetof(WGPURenderBundleEncoderDescriptor, depthStencilFormat),\n            \"offsetof mismatch for RenderBundleEncoderDescriptor::depthStencilFormat\");\n    static_assert(offsetof(RenderBundleEncoderDescriptor, sampleCount) == offsetof(WGPURenderBundleEncoderDescriptor, sampleCount),\n            \"offsetof mismatch for RenderBundleEncoderDescriptor::sampleCount\");\n    static_assert(offsetof(RenderBundleEncoderDescriptor, depthReadOnly) == offsetof(WGPURenderBundleEncoderDescriptor, depthReadOnly),\n            \"offsetof mismatch for RenderBundleEncoderDescriptor::depthReadOnly\");\n    static_assert(offsetof(RenderBundleEncoderDescriptor, stencilReadOnly) == offsetof(WGPURenderBundleEncoderDescriptor, stencilReadOnly),\n            \"offsetof mismatch for RenderBundleEncoderDescriptor::stencilReadOnly\");\n\n    bool RenderBundleEncoderDescriptor::operator==(const RenderBundleEncoderDescriptor& rhs) const {\n        return (nextInChain == rhs.nextInChain) && std::tie(\n            label,\n            colorFormatsCount,\n            colorFormats,\n            depthStencilFormat,\n            sampleCount,\n            depthReadOnly,\n            stencilReadOnly\n        ) == std::tie(\n            rhs.label,\n            rhs.colorFormatsCount,\n            rhs.colorFormats,\n            rhs.depthStencilFormat,\n            rhs.sampleCount,\n            rhs.depthReadOnly,\n            rhs.stencilReadOnly\n        );\n    }\n\n\n    static_assert(sizeof(RenderPassDepthStencilAttachment) == sizeof(WGPURenderPassDepthStencilAttachment), \"sizeof mismatch for RenderPassDepthStencilAttachment\");\n    static_assert(alignof(RenderPassDepthStencilAttachment) == alignof(WGPURenderPassDepthStencilAttachment), \"alignof mismatch for RenderPassDepthStencilAttachment\");\n\n    static_assert(offsetof(RenderPassDepthStencilAttachment, view) == offsetof(WGPURenderPassDepthStencilAttachment, view),\n            \"offsetof mismatch for RenderPassDepthStencilAttachment::view\");\n    static_assert(offsetof(RenderPassDepthStencilAttachment, depthLoadOp) == offsetof(WGPURenderPassDepthStencilAttachment, depthLoadOp),\n            \"offsetof mismatch for RenderPassDepthStencilAttachment::depthLoadOp\");\n    static_assert(offsetof(RenderPassDepthStencilAttachment, depthStoreOp) == offsetof(WGPURenderPassDepthStencilAttachment, depthStoreOp),\n            \"offsetof mismatch for RenderPassDepthStencilAttachment::depthStoreOp\");\n    static_assert(offsetof(RenderPassDepthStencilAttachment, clearDepth) == offsetof(WGPURenderPassDepthStencilAttachment, clearDepth),\n            \"offsetof mismatch for RenderPassDepthStencilAttachment::clearDepth\");\n    static_assert(offsetof(RenderPassDepthStencilAttachment, depthReadOnly) == offsetof(WGPURenderPassDepthStencilAttachment, depthReadOnly),\n            \"offsetof mismatch for RenderPassDepthStencilAttachment::depthReadOnly\");\n    static_assert(offsetof(RenderPassDepthStencilAttachment, stencilLoadOp) == offsetof(WGPURenderPassDepthStencilAttachment, stencilLoadOp),\n            \"offsetof mismatch for RenderPassDepthStencilAttachment::stencilLoadOp\");\n    static_assert(offsetof(RenderPassDepthStencilAttachment, stencilStoreOp) == offsetof(WGPURenderPassDepthStencilAttachment, stencilStoreOp),\n            \"offsetof mismatch for RenderPassDepthStencilAttachment::stencilStoreOp\");\n    static_assert(offsetof(RenderPassDepthStencilAttachment, clearStencil) == offsetof(WGPURenderPassDepthStencilAttachment, clearStencil),\n            \"offsetof mismatch for RenderPassDepthStencilAttachment::clearStencil\");\n    static_assert(offsetof(RenderPassDepthStencilAttachment, stencilReadOnly) == offsetof(WGPURenderPassDepthStencilAttachment, stencilReadOnly),\n            \"offsetof mismatch for RenderPassDepthStencilAttachment::stencilReadOnly\");\n\n    bool RenderPassDepthStencilAttachment::operator==(const RenderPassDepthStencilAttachment& rhs) const {\n        return  std::tie(\n            view,\n            depthLoadOp,\n            depthStoreOp,\n            clearDepth,\n            depthReadOnly,\n            stencilLoadOp,\n            stencilStoreOp,\n            clearStencil,\n            stencilReadOnly\n        ) == std::tie(\n            rhs.view,\n            rhs.depthLoadOp,\n            rhs.depthStoreOp,\n            rhs.clearDepth,\n            rhs.depthReadOnly,\n            rhs.stencilLoadOp,\n            rhs.stencilStoreOp,\n            rhs.clearStencil,\n            rhs.stencilReadOnly\n        );\n    }\n\n\n    static_assert(sizeof(RequestAdapterOptions) == sizeof(WGPURequestAdapterOptions), \"sizeof mismatch for RequestAdapterOptions\");\n    static_assert(alignof(RequestAdapterOptions) == alignof(WGPURequestAdapterOptions), \"alignof mismatch for RequestAdapterOptions\");\n\n    static_assert(offsetof(RequestAdapterOptions, nextInChain) == offsetof(WGPURequestAdapterOptions, nextInChain),\n            \"offsetof mismatch for RequestAdapterOptions::nextInChain\");\n    static_assert(offsetof(RequestAdapterOptions, compatibleSurface) == offsetof(WGPURequestAdapterOptions, compatibleSurface),\n            \"offsetof mismatch for RequestAdapterOptions::compatibleSurface\");\n    static_assert(offsetof(RequestAdapterOptions, powerPreference) == offsetof(WGPURequestAdapterOptions, powerPreference),\n            \"offsetof mismatch for RequestAdapterOptions::powerPreference\");\n    static_assert(offsetof(RequestAdapterOptions, forceFallbackAdapter) == offsetof(WGPURequestAdapterOptions, forceFallbackAdapter),\n            \"offsetof mismatch for RequestAdapterOptions::forceFallbackAdapter\");\n\n    bool RequestAdapterOptions::operator==(const RequestAdapterOptions& rhs) const {\n        return (nextInChain == rhs.nextInChain) && std::tie(\n            compatibleSurface,\n            powerPreference,\n            forceFallbackAdapter\n        ) == std::tie(\n            rhs.compatibleSurface,\n            rhs.powerPreference,\n            rhs.forceFallbackAdapter\n        );\n    }\n\n\n    static_assert(sizeof(SamplerBindingLayout) == sizeof(WGPUSamplerBindingLayout), \"sizeof mismatch for SamplerBindingLayout\");\n    static_assert(alignof(SamplerBindingLayout) == alignof(WGPUSamplerBindingLayout), \"alignof mismatch for SamplerBindingLayout\");\n\n    static_assert(offsetof(SamplerBindingLayout, nextInChain) == offsetof(WGPUSamplerBindingLayout, nextInChain),\n            \"offsetof mismatch for SamplerBindingLayout::nextInChain\");\n    static_assert(offsetof(SamplerBindingLayout, type) == offsetof(WGPUSamplerBindingLayout, type),\n            \"offsetof mismatch for SamplerBindingLayout::type\");\n\n    bool SamplerBindingLayout::operator==(const SamplerBindingLayout& rhs) const {\n        return (nextInChain == rhs.nextInChain) && std::tie(\n            type\n        ) == std::tie(\n            rhs.type\n        );\n    }\n\n\n    static_assert(sizeof(SamplerDescriptor) == sizeof(WGPUSamplerDescriptor), \"sizeof mismatch for SamplerDescriptor\");\n    static_assert(alignof(SamplerDescriptor) == alignof(WGPUSamplerDescriptor), \"alignof mismatch for SamplerDescriptor\");\n\n    static_assert(offsetof(SamplerDescriptor, nextInChain) == offsetof(WGPUSamplerDescriptor, nextInChain),\n            \"offsetof mismatch for SamplerDescriptor::nextInChain\");\n    static_assert(offsetof(SamplerDescriptor, label) == offsetof(WGPUSamplerDescriptor, label),\n            \"offsetof mismatch for SamplerDescriptor::label\");\n    static_assert(offsetof(SamplerDescriptor, addressModeU) == offsetof(WGPUSamplerDescriptor, addressModeU),\n            \"offsetof mismatch for SamplerDescriptor::addressModeU\");\n    static_assert(offsetof(SamplerDescriptor, addressModeV) == offsetof(WGPUSamplerDescriptor, addressModeV),\n            \"offsetof mismatch for SamplerDescriptor::addressModeV\");\n    static_assert(offsetof(SamplerDescriptor, addressModeW) == offsetof(WGPUSamplerDescriptor, addressModeW),\n            \"offsetof mismatch for SamplerDescriptor::addressModeW\");\n    static_assert(offsetof(SamplerDescriptor, magFilter) == offsetof(WGPUSamplerDescriptor, magFilter),\n            \"offsetof mismatch for SamplerDescriptor::magFilter\");\n    static_assert(offsetof(SamplerDescriptor, minFilter) == offsetof(WGPUSamplerDescriptor, minFilter),\n            \"offsetof mismatch for SamplerDescriptor::minFilter\");\n    static_assert(offsetof(SamplerDescriptor, mipmapFilter) == offsetof(WGPUSamplerDescriptor, mipmapFilter),\n            \"offsetof mismatch for SamplerDescriptor::mipmapFilter\");\n    static_assert(offsetof(SamplerDescriptor, lodMinClamp) == offsetof(WGPUSamplerDescriptor, lodMinClamp),\n            \"offsetof mismatch for SamplerDescriptor::lodMinClamp\");\n    static_assert(offsetof(SamplerDescriptor, lodMaxClamp) == offsetof(WGPUSamplerDescriptor, lodMaxClamp),\n            \"offsetof mismatch for SamplerDescriptor::lodMaxClamp\");\n    static_assert(offsetof(SamplerDescriptor, compare) == offsetof(WGPUSamplerDescriptor, compare),\n            \"offsetof mismatch for SamplerDescriptor::compare\");\n    static_assert(offsetof(SamplerDescriptor, maxAnisotropy) == offsetof(WGPUSamplerDescriptor, maxAnisotropy),\n            \"offsetof mismatch for SamplerDescriptor::maxAnisotropy\");\n\n    bool SamplerDescriptor::operator==(const SamplerDescriptor& rhs) const {\n        return (nextInChain == rhs.nextInChain) && std::tie(\n            label,\n            addressModeU,\n            addressModeV,\n            addressModeW,\n            magFilter,\n            minFilter,\n            mipmapFilter,\n            lodMinClamp,\n            lodMaxClamp,\n            compare,\n            maxAnisotropy\n        ) == std::tie(\n            rhs.label,\n            rhs.addressModeU,\n            rhs.addressModeV,\n            rhs.addressModeW,\n            rhs.magFilter,\n            rhs.minFilter,\n            rhs.mipmapFilter,\n            rhs.lodMinClamp,\n            rhs.lodMaxClamp,\n            rhs.compare,\n            rhs.maxAnisotropy\n        );\n    }\n\n\n    static_assert(sizeof(ShaderModuleDescriptor) == sizeof(WGPUShaderModuleDescriptor), \"sizeof mismatch for ShaderModuleDescriptor\");\n    static_assert(alignof(ShaderModuleDescriptor) == alignof(WGPUShaderModuleDescriptor), \"alignof mismatch for ShaderModuleDescriptor\");\n\n    static_assert(offsetof(ShaderModuleDescriptor, nextInChain) == offsetof(WGPUShaderModuleDescriptor, nextInChain),\n            \"offsetof mismatch for ShaderModuleDescriptor::nextInChain\");\n    static_assert(offsetof(ShaderModuleDescriptor, label) == offsetof(WGPUShaderModuleDescriptor, label),\n            \"offsetof mismatch for ShaderModuleDescriptor::label\");\n\n    bool ShaderModuleDescriptor::operator==(const ShaderModuleDescriptor& rhs) const {\n        return (nextInChain == rhs.nextInChain) && std::tie(\n            label\n        ) == std::tie(\n            rhs.label\n        );\n    }\n\n\n    static_assert(sizeof(ShaderModuleSPIRVDescriptor) == sizeof(WGPUShaderModuleSPIRVDescriptor), \"sizeof mismatch for ShaderModuleSPIRVDescriptor\");\n    static_assert(alignof(ShaderModuleSPIRVDescriptor) == alignof(WGPUShaderModuleSPIRVDescriptor), \"alignof mismatch for ShaderModuleSPIRVDescriptor\");\n\n    static_assert(offsetof(ShaderModuleSPIRVDescriptor, codeSize) == offsetof(WGPUShaderModuleSPIRVDescriptor, codeSize),\n            \"offsetof mismatch for ShaderModuleSPIRVDescriptor::codeSize\");\n    static_assert(offsetof(ShaderModuleSPIRVDescriptor, code) == offsetof(WGPUShaderModuleSPIRVDescriptor, code),\n            \"offsetof mismatch for ShaderModuleSPIRVDescriptor::code\");\n\n    bool ShaderModuleSPIRVDescriptor::operator==(const ShaderModuleSPIRVDescriptor& rhs) const {\n        return (nextInChain == rhs.nextInChain) && std::tie(\n            codeSize,\n            code\n        ) == std::tie(\n            rhs.codeSize,\n            rhs.code\n        );\n    }\n\n\n    static_assert(sizeof(ShaderModuleWGSLDescriptor) == sizeof(WGPUShaderModuleWGSLDescriptor), \"sizeof mismatch for ShaderModuleWGSLDescriptor\");\n    static_assert(alignof(ShaderModuleWGSLDescriptor) == alignof(WGPUShaderModuleWGSLDescriptor), \"alignof mismatch for ShaderModuleWGSLDescriptor\");\n\n    static_assert(offsetof(ShaderModuleWGSLDescriptor, source) == offsetof(WGPUShaderModuleWGSLDescriptor, source),\n            \"offsetof mismatch for ShaderModuleWGSLDescriptor::source\");\n\n    bool ShaderModuleWGSLDescriptor::operator==(const ShaderModuleWGSLDescriptor& rhs) const {\n        return (nextInChain == rhs.nextInChain) && std::tie(\n            source\n        ) == std::tie(\n            rhs.source\n        );\n    }\n\n\n    static_assert(sizeof(StencilFaceState) == sizeof(WGPUStencilFaceState), \"sizeof mismatch for StencilFaceState\");\n    static_assert(alignof(StencilFaceState) == alignof(WGPUStencilFaceState), \"alignof mismatch for StencilFaceState\");\n\n    static_assert(offsetof(StencilFaceState, compare) == offsetof(WGPUStencilFaceState, compare),\n            \"offsetof mismatch for StencilFaceState::compare\");\n    static_assert(offsetof(StencilFaceState, failOp) == offsetof(WGPUStencilFaceState, failOp),\n            \"offsetof mismatch for StencilFaceState::failOp\");\n    static_assert(offsetof(StencilFaceState, depthFailOp) == offsetof(WGPUStencilFaceState, depthFailOp),\n            \"offsetof mismatch for StencilFaceState::depthFailOp\");\n    static_assert(offsetof(StencilFaceState, passOp) == offsetof(WGPUStencilFaceState, passOp),\n            \"offsetof mismatch for StencilFaceState::passOp\");\n\n    bool StencilFaceState::operator==(const StencilFaceState& rhs) const {\n        return  std::tie(\n            compare,\n            failOp,\n            depthFailOp,\n            passOp\n        ) == std::tie(\n            rhs.compare,\n            rhs.failOp,\n            rhs.depthFailOp,\n            rhs.passOp\n        );\n    }\n\n\n    static_assert(sizeof(StorageTextureBindingLayout) == sizeof(WGPUStorageTextureBindingLayout), \"sizeof mismatch for StorageTextureBindingLayout\");\n    static_assert(alignof(StorageTextureBindingLayout) == alignof(WGPUStorageTextureBindingLayout), \"alignof mismatch for StorageTextureBindingLayout\");\n\n    static_assert(offsetof(StorageTextureBindingLayout, nextInChain) == offsetof(WGPUStorageTextureBindingLayout, nextInChain),\n            \"offsetof mismatch for StorageTextureBindingLayout::nextInChain\");\n    static_assert(offsetof(StorageTextureBindingLayout, access) == offsetof(WGPUStorageTextureBindingLayout, access),\n            \"offsetof mismatch for StorageTextureBindingLayout::access\");\n    static_assert(offsetof(StorageTextureBindingLayout, format) == offsetof(WGPUStorageTextureBindingLayout, format),\n            \"offsetof mismatch for StorageTextureBindingLayout::format\");\n    static_assert(offsetof(StorageTextureBindingLayout, viewDimension) == offsetof(WGPUStorageTextureBindingLayout, viewDimension),\n            \"offsetof mismatch for StorageTextureBindingLayout::viewDimension\");\n\n    bool StorageTextureBindingLayout::operator==(const StorageTextureBindingLayout& rhs) const {\n        return (nextInChain == rhs.nextInChain) && std::tie(\n            access,\n            format,\n            viewDimension\n        ) == std::tie(\n            rhs.access,\n            rhs.format,\n            rhs.viewDimension\n        );\n    }\n\n\n    static_assert(sizeof(SurfaceDescriptor) == sizeof(WGPUSurfaceDescriptor), \"sizeof mismatch for SurfaceDescriptor\");\n    static_assert(alignof(SurfaceDescriptor) == alignof(WGPUSurfaceDescriptor), \"alignof mismatch for SurfaceDescriptor\");\n\n    static_assert(offsetof(SurfaceDescriptor, nextInChain) == offsetof(WGPUSurfaceDescriptor, nextInChain),\n            \"offsetof mismatch for SurfaceDescriptor::nextInChain\");\n    static_assert(offsetof(SurfaceDescriptor, label) == offsetof(WGPUSurfaceDescriptor, label),\n            \"offsetof mismatch for SurfaceDescriptor::label\");\n\n    bool SurfaceDescriptor::operator==(const SurfaceDescriptor& rhs) const {\n        return (nextInChain == rhs.nextInChain) && std::tie(\n            label\n        ) == std::tie(\n            rhs.label\n        );\n    }\n\n\n    static_assert(sizeof(SurfaceDescriptorFromCanvasHTMLSelector) == sizeof(WGPUSurfaceDescriptorFromCanvasHTMLSelector), \"sizeof mismatch for SurfaceDescriptorFromCanvasHTMLSelector\");\n    static_assert(alignof(SurfaceDescriptorFromCanvasHTMLSelector) == alignof(WGPUSurfaceDescriptorFromCanvasHTMLSelector), \"alignof mismatch for SurfaceDescriptorFromCanvasHTMLSelector\");\n\n    static_assert(offsetof(SurfaceDescriptorFromCanvasHTMLSelector, selector) == offsetof(WGPUSurfaceDescriptorFromCanvasHTMLSelector, selector),\n            \"offsetof mismatch for SurfaceDescriptorFromCanvasHTMLSelector::selector\");\n\n    bool SurfaceDescriptorFromCanvasHTMLSelector::operator==(const SurfaceDescriptorFromCanvasHTMLSelector& rhs) const {\n        return (nextInChain == rhs.nextInChain) && std::tie(\n            selector\n        ) == std::tie(\n            rhs.selector\n        );\n    }\n\n\n    static_assert(sizeof(SurfaceDescriptorFromMetalLayer) == sizeof(WGPUSurfaceDescriptorFromMetalLayer), \"sizeof mismatch for SurfaceDescriptorFromMetalLayer\");\n    static_assert(alignof(SurfaceDescriptorFromMetalLayer) == alignof(WGPUSurfaceDescriptorFromMetalLayer), \"alignof mismatch for SurfaceDescriptorFromMetalLayer\");\n\n    static_assert(offsetof(SurfaceDescriptorFromMetalLayer, layer) == offsetof(WGPUSurfaceDescriptorFromMetalLayer, layer),\n            \"offsetof mismatch for SurfaceDescriptorFromMetalLayer::layer\");\n\n    bool SurfaceDescriptorFromMetalLayer::operator==(const SurfaceDescriptorFromMetalLayer& rhs) const {\n        return (nextInChain == rhs.nextInChain) && std::tie(\n            layer\n        ) == std::tie(\n            rhs.layer\n        );\n    }\n\n\n    static_assert(sizeof(SurfaceDescriptorFromWindowsCoreWindow) == sizeof(WGPUSurfaceDescriptorFromWindowsCoreWindow), \"sizeof mismatch for SurfaceDescriptorFromWindowsCoreWindow\");\n    static_assert(alignof(SurfaceDescriptorFromWindowsCoreWindow) == alignof(WGPUSurfaceDescriptorFromWindowsCoreWindow), \"alignof mismatch for SurfaceDescriptorFromWindowsCoreWindow\");\n\n    static_assert(offsetof(SurfaceDescriptorFromWindowsCoreWindow, coreWindow) == offsetof(WGPUSurfaceDescriptorFromWindowsCoreWindow, coreWindow),\n            \"offsetof mismatch for SurfaceDescriptorFromWindowsCoreWindow::coreWindow\");\n\n    bool SurfaceDescriptorFromWindowsCoreWindow::operator==(const SurfaceDescriptorFromWindowsCoreWindow& rhs) const {\n        return (nextInChain == rhs.nextInChain) && std::tie(\n            coreWindow\n        ) == std::tie(\n            rhs.coreWindow\n        );\n    }\n\n\n    static_assert(sizeof(SurfaceDescriptorFromWindowsHWND) == sizeof(WGPUSurfaceDescriptorFromWindowsHWND), \"sizeof mismatch for SurfaceDescriptorFromWindowsHWND\");\n    static_assert(alignof(SurfaceDescriptorFromWindowsHWND) == alignof(WGPUSurfaceDescriptorFromWindowsHWND), \"alignof mismatch for SurfaceDescriptorFromWindowsHWND\");\n\n    static_assert(offsetof(SurfaceDescriptorFromWindowsHWND, hinstance) == offsetof(WGPUSurfaceDescriptorFromWindowsHWND, hinstance),\n            \"offsetof mismatch for SurfaceDescriptorFromWindowsHWND::hinstance\");\n    static_assert(offsetof(SurfaceDescriptorFromWindowsHWND, hwnd) == offsetof(WGPUSurfaceDescriptorFromWindowsHWND, hwnd),\n            \"offsetof mismatch for SurfaceDescriptorFromWindowsHWND::hwnd\");\n\n    bool SurfaceDescriptorFromWindowsHWND::operator==(const SurfaceDescriptorFromWindowsHWND& rhs) const {\n        return (nextInChain == rhs.nextInChain) && std::tie(\n            hinstance,\n            hwnd\n        ) == std::tie(\n            rhs.hinstance,\n            rhs.hwnd\n        );\n    }\n\n\n    static_assert(sizeof(SurfaceDescriptorFromWindowsSwapChainPanel) == sizeof(WGPUSurfaceDescriptorFromWindowsSwapChainPanel), \"sizeof mismatch for SurfaceDescriptorFromWindowsSwapChainPanel\");\n    static_assert(alignof(SurfaceDescriptorFromWindowsSwapChainPanel) == alignof(WGPUSurfaceDescriptorFromWindowsSwapChainPanel), \"alignof mismatch for SurfaceDescriptorFromWindowsSwapChainPanel\");\n\n    static_assert(offsetof(SurfaceDescriptorFromWindowsSwapChainPanel, swapChainPanel) == offsetof(WGPUSurfaceDescriptorFromWindowsSwapChainPanel, swapChainPanel),\n            \"offsetof mismatch for SurfaceDescriptorFromWindowsSwapChainPanel::swapChainPanel\");\n\n    bool SurfaceDescriptorFromWindowsSwapChainPanel::operator==(const SurfaceDescriptorFromWindowsSwapChainPanel& rhs) const {\n        return (nextInChain == rhs.nextInChain) && std::tie(\n            swapChainPanel\n        ) == std::tie(\n            rhs.swapChainPanel\n        );\n    }\n\n\n    static_assert(sizeof(SurfaceDescriptorFromXlibWindow) == sizeof(WGPUSurfaceDescriptorFromXlibWindow), \"sizeof mismatch for SurfaceDescriptorFromXlibWindow\");\n    static_assert(alignof(SurfaceDescriptorFromXlibWindow) == alignof(WGPUSurfaceDescriptorFromXlibWindow), \"alignof mismatch for SurfaceDescriptorFromXlibWindow\");\n\n    static_assert(offsetof(SurfaceDescriptorFromXlibWindow, display) == offsetof(WGPUSurfaceDescriptorFromXlibWindow, display),\n            \"offsetof mismatch for SurfaceDescriptorFromXlibWindow::display\");\n    static_assert(offsetof(SurfaceDescriptorFromXlibWindow, window) == offsetof(WGPUSurfaceDescriptorFromXlibWindow, window),\n            \"offsetof mismatch for SurfaceDescriptorFromXlibWindow::window\");\n\n    bool SurfaceDescriptorFromXlibWindow::operator==(const SurfaceDescriptorFromXlibWindow& rhs) const {\n        return (nextInChain == rhs.nextInChain) && std::tie(\n            display,\n            window\n        ) == std::tie(\n            rhs.display,\n            rhs.window\n        );\n    }\n\n\n    static_assert(sizeof(SwapChainDescriptor) == sizeof(WGPUSwapChainDescriptor), \"sizeof mismatch for SwapChainDescriptor\");\n    static_assert(alignof(SwapChainDescriptor) == alignof(WGPUSwapChainDescriptor), \"alignof mismatch for SwapChainDescriptor\");\n\n    static_assert(offsetof(SwapChainDescriptor, nextInChain) == offsetof(WGPUSwapChainDescriptor, nextInChain),\n            \"offsetof mismatch for SwapChainDescriptor::nextInChain\");\n    static_assert(offsetof(SwapChainDescriptor, label) == offsetof(WGPUSwapChainDescriptor, label),\n            \"offsetof mismatch for SwapChainDescriptor::label\");\n    static_assert(offsetof(SwapChainDescriptor, usage) == offsetof(WGPUSwapChainDescriptor, usage),\n            \"offsetof mismatch for SwapChainDescriptor::usage\");\n    static_assert(offsetof(SwapChainDescriptor, format) == offsetof(WGPUSwapChainDescriptor, format),\n            \"offsetof mismatch for SwapChainDescriptor::format\");\n    static_assert(offsetof(SwapChainDescriptor, width) == offsetof(WGPUSwapChainDescriptor, width),\n            \"offsetof mismatch for SwapChainDescriptor::width\");\n    static_assert(offsetof(SwapChainDescriptor, height) == offsetof(WGPUSwapChainDescriptor, height),\n            \"offsetof mismatch for SwapChainDescriptor::height\");\n    static_assert(offsetof(SwapChainDescriptor, presentMode) == offsetof(WGPUSwapChainDescriptor, presentMode),\n            \"offsetof mismatch for SwapChainDescriptor::presentMode\");\n    static_assert(offsetof(SwapChainDescriptor, implementation) == offsetof(WGPUSwapChainDescriptor, implementation),\n            \"offsetof mismatch for SwapChainDescriptor::implementation\");\n\n    bool SwapChainDescriptor::operator==(const SwapChainDescriptor& rhs) const {\n        return (nextInChain == rhs.nextInChain) && std::tie(\n            label,\n            usage,\n            format,\n            width,\n            height,\n            presentMode,\n            implementation\n        ) == std::tie(\n            rhs.label,\n            rhs.usage,\n            rhs.format,\n            rhs.width,\n            rhs.height,\n            rhs.presentMode,\n            rhs.implementation\n        );\n    }\n\n\n    static_assert(sizeof(TextureBindingLayout) == sizeof(WGPUTextureBindingLayout), \"sizeof mismatch for TextureBindingLayout\");\n    static_assert(alignof(TextureBindingLayout) == alignof(WGPUTextureBindingLayout), \"alignof mismatch for TextureBindingLayout\");\n\n    static_assert(offsetof(TextureBindingLayout, nextInChain) == offsetof(WGPUTextureBindingLayout, nextInChain),\n            \"offsetof mismatch for TextureBindingLayout::nextInChain\");\n    static_assert(offsetof(TextureBindingLayout, sampleType) == offsetof(WGPUTextureBindingLayout, sampleType),\n            \"offsetof mismatch for TextureBindingLayout::sampleType\");\n    static_assert(offsetof(TextureBindingLayout, viewDimension) == offsetof(WGPUTextureBindingLayout, viewDimension),\n            \"offsetof mismatch for TextureBindingLayout::viewDimension\");\n    static_assert(offsetof(TextureBindingLayout, multisampled) == offsetof(WGPUTextureBindingLayout, multisampled),\n            \"offsetof mismatch for TextureBindingLayout::multisampled\");\n\n    bool TextureBindingLayout::operator==(const TextureBindingLayout& rhs) const {\n        return (nextInChain == rhs.nextInChain) && std::tie(\n            sampleType,\n            viewDimension,\n            multisampled\n        ) == std::tie(\n            rhs.sampleType,\n            rhs.viewDimension,\n            rhs.multisampled\n        );\n    }\n\n\n    static_assert(sizeof(TextureDataLayout) == sizeof(WGPUTextureDataLayout), \"sizeof mismatch for TextureDataLayout\");\n    static_assert(alignof(TextureDataLayout) == alignof(WGPUTextureDataLayout), \"alignof mismatch for TextureDataLayout\");\n\n    static_assert(offsetof(TextureDataLayout, nextInChain) == offsetof(WGPUTextureDataLayout, nextInChain),\n            \"offsetof mismatch for TextureDataLayout::nextInChain\");\n    static_assert(offsetof(TextureDataLayout, offset) == offsetof(WGPUTextureDataLayout, offset),\n            \"offsetof mismatch for TextureDataLayout::offset\");\n    static_assert(offsetof(TextureDataLayout, bytesPerRow) == offsetof(WGPUTextureDataLayout, bytesPerRow),\n            \"offsetof mismatch for TextureDataLayout::bytesPerRow\");\n    static_assert(offsetof(TextureDataLayout, rowsPerImage) == offsetof(WGPUTextureDataLayout, rowsPerImage),\n            \"offsetof mismatch for TextureDataLayout::rowsPerImage\");\n\n    bool TextureDataLayout::operator==(const TextureDataLayout& rhs) const {\n        return (nextInChain == rhs.nextInChain) && std::tie(\n            offset,\n            bytesPerRow,\n            rowsPerImage\n        ) == std::tie(\n            rhs.offset,\n            rhs.bytesPerRow,\n            rhs.rowsPerImage\n        );\n    }\n\n\n    static_assert(sizeof(TextureViewDescriptor) == sizeof(WGPUTextureViewDescriptor), \"sizeof mismatch for TextureViewDescriptor\");\n    static_assert(alignof(TextureViewDescriptor) == alignof(WGPUTextureViewDescriptor), \"alignof mismatch for TextureViewDescriptor\");\n\n    static_assert(offsetof(TextureViewDescriptor, nextInChain) == offsetof(WGPUTextureViewDescriptor, nextInChain),\n            \"offsetof mismatch for TextureViewDescriptor::nextInChain\");\n    static_assert(offsetof(TextureViewDescriptor, label) == offsetof(WGPUTextureViewDescriptor, label),\n            \"offsetof mismatch for TextureViewDescriptor::label\");\n    static_assert(offsetof(TextureViewDescriptor, format) == offsetof(WGPUTextureViewDescriptor, format),\n            \"offsetof mismatch for TextureViewDescriptor::format\");\n    static_assert(offsetof(TextureViewDescriptor, dimension) == offsetof(WGPUTextureViewDescriptor, dimension),\n            \"offsetof mismatch for TextureViewDescriptor::dimension\");\n    static_assert(offsetof(TextureViewDescriptor, baseMipLevel) == offsetof(WGPUTextureViewDescriptor, baseMipLevel),\n            \"offsetof mismatch for TextureViewDescriptor::baseMipLevel\");\n    static_assert(offsetof(TextureViewDescriptor, mipLevelCount) == offsetof(WGPUTextureViewDescriptor, mipLevelCount),\n            \"offsetof mismatch for TextureViewDescriptor::mipLevelCount\");\n    static_assert(offsetof(TextureViewDescriptor, baseArrayLayer) == offsetof(WGPUTextureViewDescriptor, baseArrayLayer),\n            \"offsetof mismatch for TextureViewDescriptor::baseArrayLayer\");\n    static_assert(offsetof(TextureViewDescriptor, arrayLayerCount) == offsetof(WGPUTextureViewDescriptor, arrayLayerCount),\n            \"offsetof mismatch for TextureViewDescriptor::arrayLayerCount\");\n    static_assert(offsetof(TextureViewDescriptor, aspect) == offsetof(WGPUTextureViewDescriptor, aspect),\n            \"offsetof mismatch for TextureViewDescriptor::aspect\");\n\n    bool TextureViewDescriptor::operator==(const TextureViewDescriptor& rhs) const {\n        return (nextInChain == rhs.nextInChain) && std::tie(\n            label,\n            format,\n            dimension,\n            baseMipLevel,\n            mipLevelCount,\n            baseArrayLayer,\n            arrayLayerCount,\n            aspect\n        ) == std::tie(\n            rhs.label,\n            rhs.format,\n            rhs.dimension,\n            rhs.baseMipLevel,\n            rhs.mipLevelCount,\n            rhs.baseArrayLayer,\n            rhs.arrayLayerCount,\n            rhs.aspect\n        );\n    }\n\n\n    static_assert(sizeof(VertexAttribute) == sizeof(WGPUVertexAttribute), \"sizeof mismatch for VertexAttribute\");\n    static_assert(alignof(VertexAttribute) == alignof(WGPUVertexAttribute), \"alignof mismatch for VertexAttribute\");\n\n    static_assert(offsetof(VertexAttribute, format) == offsetof(WGPUVertexAttribute, format),\n            \"offsetof mismatch for VertexAttribute::format\");\n    static_assert(offsetof(VertexAttribute, offset) == offsetof(WGPUVertexAttribute, offset),\n            \"offsetof mismatch for VertexAttribute::offset\");\n    static_assert(offsetof(VertexAttribute, shaderLocation) == offsetof(WGPUVertexAttribute, shaderLocation),\n            \"offsetof mismatch for VertexAttribute::shaderLocation\");\n\n    bool VertexAttribute::operator==(const VertexAttribute& rhs) const {\n        return  std::tie(\n            format,\n            offset,\n            shaderLocation\n        ) == std::tie(\n            rhs.format,\n            rhs.offset,\n            rhs.shaderLocation\n        );\n    }\n\n\n    static_assert(sizeof(BindGroupDescriptor) == sizeof(WGPUBindGroupDescriptor), \"sizeof mismatch for BindGroupDescriptor\");\n    static_assert(alignof(BindGroupDescriptor) == alignof(WGPUBindGroupDescriptor), \"alignof mismatch for BindGroupDescriptor\");\n\n    static_assert(offsetof(BindGroupDescriptor, nextInChain) == offsetof(WGPUBindGroupDescriptor, nextInChain),\n            \"offsetof mismatch for BindGroupDescriptor::nextInChain\");\n    static_assert(offsetof(BindGroupDescriptor, label) == offsetof(WGPUBindGroupDescriptor, label),\n            \"offsetof mismatch for BindGroupDescriptor::label\");\n    static_assert(offsetof(BindGroupDescriptor, layout) == offsetof(WGPUBindGroupDescriptor, layout),\n            \"offsetof mismatch for BindGroupDescriptor::layout\");\n    static_assert(offsetof(BindGroupDescriptor, entryCount) == offsetof(WGPUBindGroupDescriptor, entryCount),\n            \"offsetof mismatch for BindGroupDescriptor::entryCount\");\n    static_assert(offsetof(BindGroupDescriptor, entries) == offsetof(WGPUBindGroupDescriptor, entries),\n            \"offsetof mismatch for BindGroupDescriptor::entries\");\n\n    bool BindGroupDescriptor::operator==(const BindGroupDescriptor& rhs) const {\n        return (nextInChain == rhs.nextInChain) && std::tie(\n            label,\n            layout,\n            entryCount,\n            entries\n        ) == std::tie(\n            rhs.label,\n            rhs.layout,\n            rhs.entryCount,\n            rhs.entries\n        );\n    }\n\n\n    static_assert(sizeof(BindGroupLayoutEntry) == sizeof(WGPUBindGroupLayoutEntry), \"sizeof mismatch for BindGroupLayoutEntry\");\n    static_assert(alignof(BindGroupLayoutEntry) == alignof(WGPUBindGroupLayoutEntry), \"alignof mismatch for BindGroupLayoutEntry\");\n\n    static_assert(offsetof(BindGroupLayoutEntry, nextInChain) == offsetof(WGPUBindGroupLayoutEntry, nextInChain),\n            \"offsetof mismatch for BindGroupLayoutEntry::nextInChain\");\n    static_assert(offsetof(BindGroupLayoutEntry, binding) == offsetof(WGPUBindGroupLayoutEntry, binding),\n            \"offsetof mismatch for BindGroupLayoutEntry::binding\");\n    static_assert(offsetof(BindGroupLayoutEntry, visibility) == offsetof(WGPUBindGroupLayoutEntry, visibility),\n            \"offsetof mismatch for BindGroupLayoutEntry::visibility\");\n    static_assert(offsetof(BindGroupLayoutEntry, buffer) == offsetof(WGPUBindGroupLayoutEntry, buffer),\n            \"offsetof mismatch for BindGroupLayoutEntry::buffer\");\n    static_assert(offsetof(BindGroupLayoutEntry, sampler) == offsetof(WGPUBindGroupLayoutEntry, sampler),\n            \"offsetof mismatch for BindGroupLayoutEntry::sampler\");\n    static_assert(offsetof(BindGroupLayoutEntry, texture) == offsetof(WGPUBindGroupLayoutEntry, texture),\n            \"offsetof mismatch for BindGroupLayoutEntry::texture\");\n    static_assert(offsetof(BindGroupLayoutEntry, storageTexture) == offsetof(WGPUBindGroupLayoutEntry, storageTexture),\n            \"offsetof mismatch for BindGroupLayoutEntry::storageTexture\");\n\n    bool BindGroupLayoutEntry::operator==(const BindGroupLayoutEntry& rhs) const {\n        return (nextInChain == rhs.nextInChain) && std::tie(\n            binding,\n            visibility,\n            buffer,\n            sampler,\n            texture,\n            storageTexture\n        ) == std::tie(\n            rhs.binding,\n            rhs.visibility,\n            rhs.buffer,\n            rhs.sampler,\n            rhs.texture,\n            rhs.storageTexture\n        );\n    }\n\n\n    static_assert(sizeof(BlendState) == sizeof(WGPUBlendState), \"sizeof mismatch for BlendState\");\n    static_assert(alignof(BlendState) == alignof(WGPUBlendState), \"alignof mismatch for BlendState\");\n\n    static_assert(offsetof(BlendState, color) == offsetof(WGPUBlendState, color),\n            \"offsetof mismatch for BlendState::color\");\n    static_assert(offsetof(BlendState, alpha) == offsetof(WGPUBlendState, alpha),\n            \"offsetof mismatch for BlendState::alpha\");\n\n    bool BlendState::operator==(const BlendState& rhs) const {\n        return  std::tie(\n            color,\n            alpha\n        ) == std::tie(\n            rhs.color,\n            rhs.alpha\n        );\n    }\n\n\n    static_assert(sizeof(CompilationInfo) == sizeof(WGPUCompilationInfo), \"sizeof mismatch for CompilationInfo\");\n    static_assert(alignof(CompilationInfo) == alignof(WGPUCompilationInfo), \"alignof mismatch for CompilationInfo\");\n\n    static_assert(offsetof(CompilationInfo, nextInChain) == offsetof(WGPUCompilationInfo, nextInChain),\n            \"offsetof mismatch for CompilationInfo::nextInChain\");\n    static_assert(offsetof(CompilationInfo, messageCount) == offsetof(WGPUCompilationInfo, messageCount),\n            \"offsetof mismatch for CompilationInfo::messageCount\");\n    static_assert(offsetof(CompilationInfo, messages) == offsetof(WGPUCompilationInfo, messages),\n            \"offsetof mismatch for CompilationInfo::messages\");\n\n    bool CompilationInfo::operator==(const CompilationInfo& rhs) const {\n        return (nextInChain == rhs.nextInChain) && std::tie(\n            messageCount,\n            messages\n        ) == std::tie(\n            rhs.messageCount,\n            rhs.messages\n        );\n    }\n\n\n    static_assert(sizeof(DepthStencilState) == sizeof(WGPUDepthStencilState), \"sizeof mismatch for DepthStencilState\");\n    static_assert(alignof(DepthStencilState) == alignof(WGPUDepthStencilState), \"alignof mismatch for DepthStencilState\");\n\n    static_assert(offsetof(DepthStencilState, nextInChain) == offsetof(WGPUDepthStencilState, nextInChain),\n            \"offsetof mismatch for DepthStencilState::nextInChain\");\n    static_assert(offsetof(DepthStencilState, format) == offsetof(WGPUDepthStencilState, format),\n            \"offsetof mismatch for DepthStencilState::format\");\n    static_assert(offsetof(DepthStencilState, depthWriteEnabled) == offsetof(WGPUDepthStencilState, depthWriteEnabled),\n            \"offsetof mismatch for DepthStencilState::depthWriteEnabled\");\n    static_assert(offsetof(DepthStencilState, depthCompare) == offsetof(WGPUDepthStencilState, depthCompare),\n            \"offsetof mismatch for DepthStencilState::depthCompare\");\n    static_assert(offsetof(DepthStencilState, stencilFront) == offsetof(WGPUDepthStencilState, stencilFront),\n            \"offsetof mismatch for DepthStencilState::stencilFront\");\n    static_assert(offsetof(DepthStencilState, stencilBack) == offsetof(WGPUDepthStencilState, stencilBack),\n            \"offsetof mismatch for DepthStencilState::stencilBack\");\n    static_assert(offsetof(DepthStencilState, stencilReadMask) == offsetof(WGPUDepthStencilState, stencilReadMask),\n            \"offsetof mismatch for DepthStencilState::stencilReadMask\");\n    static_assert(offsetof(DepthStencilState, stencilWriteMask) == offsetof(WGPUDepthStencilState, stencilWriteMask),\n            \"offsetof mismatch for DepthStencilState::stencilWriteMask\");\n    static_assert(offsetof(DepthStencilState, depthBias) == offsetof(WGPUDepthStencilState, depthBias),\n            \"offsetof mismatch for DepthStencilState::depthBias\");\n    static_assert(offsetof(DepthStencilState, depthBiasSlopeScale) == offsetof(WGPUDepthStencilState, depthBiasSlopeScale),\n            \"offsetof mismatch for DepthStencilState::depthBiasSlopeScale\");\n    static_assert(offsetof(DepthStencilState, depthBiasClamp) == offsetof(WGPUDepthStencilState, depthBiasClamp),\n            \"offsetof mismatch for DepthStencilState::depthBiasClamp\");\n\n    bool DepthStencilState::operator==(const DepthStencilState& rhs) const {\n        return (nextInChain == rhs.nextInChain) && std::tie(\n            format,\n            depthWriteEnabled,\n            depthCompare,\n            stencilFront,\n            stencilBack,\n            stencilReadMask,\n            stencilWriteMask,\n            depthBias,\n            depthBiasSlopeScale,\n            depthBiasClamp\n        ) == std::tie(\n            rhs.format,\n            rhs.depthWriteEnabled,\n            rhs.depthCompare,\n            rhs.stencilFront,\n            rhs.stencilBack,\n            rhs.stencilReadMask,\n            rhs.stencilWriteMask,\n            rhs.depthBias,\n            rhs.depthBiasSlopeScale,\n            rhs.depthBiasClamp\n        );\n    }\n\n\n    static_assert(sizeof(ImageCopyBuffer) == sizeof(WGPUImageCopyBuffer), \"sizeof mismatch for ImageCopyBuffer\");\n    static_assert(alignof(ImageCopyBuffer) == alignof(WGPUImageCopyBuffer), \"alignof mismatch for ImageCopyBuffer\");\n\n    static_assert(offsetof(ImageCopyBuffer, nextInChain) == offsetof(WGPUImageCopyBuffer, nextInChain),\n            \"offsetof mismatch for ImageCopyBuffer::nextInChain\");\n    static_assert(offsetof(ImageCopyBuffer, layout) == offsetof(WGPUImageCopyBuffer, layout),\n            \"offsetof mismatch for ImageCopyBuffer::layout\");\n    static_assert(offsetof(ImageCopyBuffer, buffer) == offsetof(WGPUImageCopyBuffer, buffer),\n            \"offsetof mismatch for ImageCopyBuffer::buffer\");\n\n    bool ImageCopyBuffer::operator==(const ImageCopyBuffer& rhs) const {\n        return (nextInChain == rhs.nextInChain) && std::tie(\n            layout,\n            buffer\n        ) == std::tie(\n            rhs.layout,\n            rhs.buffer\n        );\n    }\n\n\n    static_assert(sizeof(ImageCopyTexture) == sizeof(WGPUImageCopyTexture), \"sizeof mismatch for ImageCopyTexture\");\n    static_assert(alignof(ImageCopyTexture) == alignof(WGPUImageCopyTexture), \"alignof mismatch for ImageCopyTexture\");\n\n    static_assert(offsetof(ImageCopyTexture, nextInChain) == offsetof(WGPUImageCopyTexture, nextInChain),\n            \"offsetof mismatch for ImageCopyTexture::nextInChain\");\n    static_assert(offsetof(ImageCopyTexture, texture) == offsetof(WGPUImageCopyTexture, texture),\n            \"offsetof mismatch for ImageCopyTexture::texture\");\n    static_assert(offsetof(ImageCopyTexture, mipLevel) == offsetof(WGPUImageCopyTexture, mipLevel),\n            \"offsetof mismatch for ImageCopyTexture::mipLevel\");\n    static_assert(offsetof(ImageCopyTexture, origin) == offsetof(WGPUImageCopyTexture, origin),\n            \"offsetof mismatch for ImageCopyTexture::origin\");\n    static_assert(offsetof(ImageCopyTexture, aspect) == offsetof(WGPUImageCopyTexture, aspect),\n            \"offsetof mismatch for ImageCopyTexture::aspect\");\n\n    bool ImageCopyTexture::operator==(const ImageCopyTexture& rhs) const {\n        return (nextInChain == rhs.nextInChain) && std::tie(\n            texture,\n            mipLevel,\n            origin,\n            aspect\n        ) == std::tie(\n            rhs.texture,\n            rhs.mipLevel,\n            rhs.origin,\n            rhs.aspect\n        );\n    }\n\n\n    static_assert(sizeof(ProgrammableStageDescriptor) == sizeof(WGPUProgrammableStageDescriptor), \"sizeof mismatch for ProgrammableStageDescriptor\");\n    static_assert(alignof(ProgrammableStageDescriptor) == alignof(WGPUProgrammableStageDescriptor), \"alignof mismatch for ProgrammableStageDescriptor\");\n\n    static_assert(offsetof(ProgrammableStageDescriptor, nextInChain) == offsetof(WGPUProgrammableStageDescriptor, nextInChain),\n            \"offsetof mismatch for ProgrammableStageDescriptor::nextInChain\");\n    static_assert(offsetof(ProgrammableStageDescriptor, module) == offsetof(WGPUProgrammableStageDescriptor, module),\n            \"offsetof mismatch for ProgrammableStageDescriptor::module\");\n    static_assert(offsetof(ProgrammableStageDescriptor, entryPoint) == offsetof(WGPUProgrammableStageDescriptor, entryPoint),\n            \"offsetof mismatch for ProgrammableStageDescriptor::entryPoint\");\n    static_assert(offsetof(ProgrammableStageDescriptor, constantCount) == offsetof(WGPUProgrammableStageDescriptor, constantCount),\n            \"offsetof mismatch for ProgrammableStageDescriptor::constantCount\");\n    static_assert(offsetof(ProgrammableStageDescriptor, constants) == offsetof(WGPUProgrammableStageDescriptor, constants),\n            \"offsetof mismatch for ProgrammableStageDescriptor::constants\");\n\n    bool ProgrammableStageDescriptor::operator==(const ProgrammableStageDescriptor& rhs) const {\n        return (nextInChain == rhs.nextInChain) && std::tie(\n            module,\n            entryPoint,\n            constantCount,\n            constants\n        ) == std::tie(\n            rhs.module,\n            rhs.entryPoint,\n            rhs.constantCount,\n            rhs.constants\n        );\n    }\n\n\n    static_assert(sizeof(RenderPassColorAttachment) == sizeof(WGPURenderPassColorAttachment), \"sizeof mismatch for RenderPassColorAttachment\");\n    static_assert(alignof(RenderPassColorAttachment) == alignof(WGPURenderPassColorAttachment), \"alignof mismatch for RenderPassColorAttachment\");\n\n    static_assert(offsetof(RenderPassColorAttachment, view) == offsetof(WGPURenderPassColorAttachment, view),\n            \"offsetof mismatch for RenderPassColorAttachment::view\");\n    static_assert(offsetof(RenderPassColorAttachment, resolveTarget) == offsetof(WGPURenderPassColorAttachment, resolveTarget),\n            \"offsetof mismatch for RenderPassColorAttachment::resolveTarget\");\n    static_assert(offsetof(RenderPassColorAttachment, loadOp) == offsetof(WGPURenderPassColorAttachment, loadOp),\n            \"offsetof mismatch for RenderPassColorAttachment::loadOp\");\n    static_assert(offsetof(RenderPassColorAttachment, storeOp) == offsetof(WGPURenderPassColorAttachment, storeOp),\n            \"offsetof mismatch for RenderPassColorAttachment::storeOp\");\n    static_assert(offsetof(RenderPassColorAttachment, clearColor) == offsetof(WGPURenderPassColorAttachment, clearColor),\n            \"offsetof mismatch for RenderPassColorAttachment::clearColor\");\n\n    bool RenderPassColorAttachment::operator==(const RenderPassColorAttachment& rhs) const {\n        return  std::tie(\n            view,\n            resolveTarget,\n            loadOp,\n            storeOp,\n            clearColor\n        ) == std::tie(\n            rhs.view,\n            rhs.resolveTarget,\n            rhs.loadOp,\n            rhs.storeOp,\n            rhs.clearColor\n        );\n    }\n\n\n    static_assert(sizeof(RequiredLimits) == sizeof(WGPURequiredLimits), \"sizeof mismatch for RequiredLimits\");\n    static_assert(alignof(RequiredLimits) == alignof(WGPURequiredLimits), \"alignof mismatch for RequiredLimits\");\n\n    static_assert(offsetof(RequiredLimits, nextInChain) == offsetof(WGPURequiredLimits, nextInChain),\n            \"offsetof mismatch for RequiredLimits::nextInChain\");\n    static_assert(offsetof(RequiredLimits, limits) == offsetof(WGPURequiredLimits, limits),\n            \"offsetof mismatch for RequiredLimits::limits\");\n\n    bool RequiredLimits::operator==(const RequiredLimits& rhs) const {\n        return (nextInChain == rhs.nextInChain) && std::tie(\n            limits\n        ) == std::tie(\n            rhs.limits\n        );\n    }\n\n\n    static_assert(sizeof(SupportedLimits) == sizeof(WGPUSupportedLimits), \"sizeof mismatch for SupportedLimits\");\n    static_assert(alignof(SupportedLimits) == alignof(WGPUSupportedLimits), \"alignof mismatch for SupportedLimits\");\n\n    static_assert(offsetof(SupportedLimits, nextInChain) == offsetof(WGPUSupportedLimits, nextInChain),\n            \"offsetof mismatch for SupportedLimits::nextInChain\");\n    static_assert(offsetof(SupportedLimits, limits) == offsetof(WGPUSupportedLimits, limits),\n            \"offsetof mismatch for SupportedLimits::limits\");\n\n    bool SupportedLimits::operator==(const SupportedLimits& rhs) const {\n        return (nextInChain == rhs.nextInChain) && std::tie(\n            limits\n        ) == std::tie(\n            rhs.limits\n        );\n    }\n\n\n    static_assert(sizeof(TextureDescriptor) == sizeof(WGPUTextureDescriptor), \"sizeof mismatch for TextureDescriptor\");\n    static_assert(alignof(TextureDescriptor) == alignof(WGPUTextureDescriptor), \"alignof mismatch for TextureDescriptor\");\n\n    static_assert(offsetof(TextureDescriptor, nextInChain) == offsetof(WGPUTextureDescriptor, nextInChain),\n            \"offsetof mismatch for TextureDescriptor::nextInChain\");\n    static_assert(offsetof(TextureDescriptor, label) == offsetof(WGPUTextureDescriptor, label),\n            \"offsetof mismatch for TextureDescriptor::label\");\n    static_assert(offsetof(TextureDescriptor, usage) == offsetof(WGPUTextureDescriptor, usage),\n            \"offsetof mismatch for TextureDescriptor::usage\");\n    static_assert(offsetof(TextureDescriptor, dimension) == offsetof(WGPUTextureDescriptor, dimension),\n            \"offsetof mismatch for TextureDescriptor::dimension\");\n    static_assert(offsetof(TextureDescriptor, size) == offsetof(WGPUTextureDescriptor, size),\n            \"offsetof mismatch for TextureDescriptor::size\");\n    static_assert(offsetof(TextureDescriptor, format) == offsetof(WGPUTextureDescriptor, format),\n            \"offsetof mismatch for TextureDescriptor::format\");\n    static_assert(offsetof(TextureDescriptor, mipLevelCount) == offsetof(WGPUTextureDescriptor, mipLevelCount),\n            \"offsetof mismatch for TextureDescriptor::mipLevelCount\");\n    static_assert(offsetof(TextureDescriptor, sampleCount) == offsetof(WGPUTextureDescriptor, sampleCount),\n            \"offsetof mismatch for TextureDescriptor::sampleCount\");\n\n    bool TextureDescriptor::operator==(const TextureDescriptor& rhs) const {\n        return (nextInChain == rhs.nextInChain) && std::tie(\n            label,\n            usage,\n            dimension,\n            size,\n            format,\n            mipLevelCount,\n            sampleCount\n        ) == std::tie(\n            rhs.label,\n            rhs.usage,\n            rhs.dimension,\n            rhs.size,\n            rhs.format,\n            rhs.mipLevelCount,\n            rhs.sampleCount\n        );\n    }\n\n\n    static_assert(sizeof(VertexBufferLayout) == sizeof(WGPUVertexBufferLayout), \"sizeof mismatch for VertexBufferLayout\");\n    static_assert(alignof(VertexBufferLayout) == alignof(WGPUVertexBufferLayout), \"alignof mismatch for VertexBufferLayout\");\n\n    static_assert(offsetof(VertexBufferLayout, arrayStride) == offsetof(WGPUVertexBufferLayout, arrayStride),\n            \"offsetof mismatch for VertexBufferLayout::arrayStride\");\n    static_assert(offsetof(VertexBufferLayout, stepMode) == offsetof(WGPUVertexBufferLayout, stepMode),\n            \"offsetof mismatch for VertexBufferLayout::stepMode\");\n    static_assert(offsetof(VertexBufferLayout, attributeCount) == offsetof(WGPUVertexBufferLayout, attributeCount),\n            \"offsetof mismatch for VertexBufferLayout::attributeCount\");\n    static_assert(offsetof(VertexBufferLayout, attributes) == offsetof(WGPUVertexBufferLayout, attributes),\n            \"offsetof mismatch for VertexBufferLayout::attributes\");\n\n    bool VertexBufferLayout::operator==(const VertexBufferLayout& rhs) const {\n        return  std::tie(\n            arrayStride,\n            stepMode,\n            attributeCount,\n            attributes\n        ) == std::tie(\n            rhs.arrayStride,\n            rhs.stepMode,\n            rhs.attributeCount,\n            rhs.attributes\n        );\n    }\n\n\n    static_assert(sizeof(BindGroupLayoutDescriptor) == sizeof(WGPUBindGroupLayoutDescriptor), \"sizeof mismatch for BindGroupLayoutDescriptor\");\n    static_assert(alignof(BindGroupLayoutDescriptor) == alignof(WGPUBindGroupLayoutDescriptor), \"alignof mismatch for BindGroupLayoutDescriptor\");\n\n    static_assert(offsetof(BindGroupLayoutDescriptor, nextInChain) == offsetof(WGPUBindGroupLayoutDescriptor, nextInChain),\n            \"offsetof mismatch for BindGroupLayoutDescriptor::nextInChain\");\n    static_assert(offsetof(BindGroupLayoutDescriptor, label) == offsetof(WGPUBindGroupLayoutDescriptor, label),\n            \"offsetof mismatch for BindGroupLayoutDescriptor::label\");\n    static_assert(offsetof(BindGroupLayoutDescriptor, entryCount) == offsetof(WGPUBindGroupLayoutDescriptor, entryCount),\n            \"offsetof mismatch for BindGroupLayoutDescriptor::entryCount\");\n    static_assert(offsetof(BindGroupLayoutDescriptor, entries) == offsetof(WGPUBindGroupLayoutDescriptor, entries),\n            \"offsetof mismatch for BindGroupLayoutDescriptor::entries\");\n\n    bool BindGroupLayoutDescriptor::operator==(const BindGroupLayoutDescriptor& rhs) const {\n        return (nextInChain == rhs.nextInChain) && std::tie(\n            label,\n            entryCount,\n            entries\n        ) == std::tie(\n            rhs.label,\n            rhs.entryCount,\n            rhs.entries\n        );\n    }\n\n\n    static_assert(sizeof(ColorTargetState) == sizeof(WGPUColorTargetState), \"sizeof mismatch for ColorTargetState\");\n    static_assert(alignof(ColorTargetState) == alignof(WGPUColorTargetState), \"alignof mismatch for ColorTargetState\");\n\n    static_assert(offsetof(ColorTargetState, nextInChain) == offsetof(WGPUColorTargetState, nextInChain),\n            \"offsetof mismatch for ColorTargetState::nextInChain\");\n    static_assert(offsetof(ColorTargetState, format) == offsetof(WGPUColorTargetState, format),\n            \"offsetof mismatch for ColorTargetState::format\");\n    static_assert(offsetof(ColorTargetState, blend) == offsetof(WGPUColorTargetState, blend),\n            \"offsetof mismatch for ColorTargetState::blend\");\n    static_assert(offsetof(ColorTargetState, writeMask) == offsetof(WGPUColorTargetState, writeMask),\n            \"offsetof mismatch for ColorTargetState::writeMask\");\n\n    bool ColorTargetState::operator==(const ColorTargetState& rhs) const {\n        return (nextInChain == rhs.nextInChain) && std::tie(\n            format,\n            blend,\n            writeMask\n        ) == std::tie(\n            rhs.format,\n            rhs.blend,\n            rhs.writeMask\n        );\n    }\n\n\n    static_assert(sizeof(ComputePipelineDescriptor) == sizeof(WGPUComputePipelineDescriptor), \"sizeof mismatch for ComputePipelineDescriptor\");\n    static_assert(alignof(ComputePipelineDescriptor) == alignof(WGPUComputePipelineDescriptor), \"alignof mismatch for ComputePipelineDescriptor\");\n\n    static_assert(offsetof(ComputePipelineDescriptor, nextInChain) == offsetof(WGPUComputePipelineDescriptor, nextInChain),\n            \"offsetof mismatch for ComputePipelineDescriptor::nextInChain\");\n    static_assert(offsetof(ComputePipelineDescriptor, label) == offsetof(WGPUComputePipelineDescriptor, label),\n            \"offsetof mismatch for ComputePipelineDescriptor::label\");\n    static_assert(offsetof(ComputePipelineDescriptor, layout) == offsetof(WGPUComputePipelineDescriptor, layout),\n            \"offsetof mismatch for ComputePipelineDescriptor::layout\");\n    static_assert(offsetof(ComputePipelineDescriptor, compute) == offsetof(WGPUComputePipelineDescriptor, compute),\n            \"offsetof mismatch for ComputePipelineDescriptor::compute\");\n\n    bool ComputePipelineDescriptor::operator==(const ComputePipelineDescriptor& rhs) const {\n        return (nextInChain == rhs.nextInChain) && std::tie(\n            label,\n            layout,\n            compute\n        ) == std::tie(\n            rhs.label,\n            rhs.layout,\n            rhs.compute\n        );\n    }\n\n\n    static_assert(sizeof(DeviceDescriptor) == sizeof(WGPUDeviceDescriptor), \"sizeof mismatch for DeviceDescriptor\");\n    static_assert(alignof(DeviceDescriptor) == alignof(WGPUDeviceDescriptor), \"alignof mismatch for DeviceDescriptor\");\n\n    static_assert(offsetof(DeviceDescriptor, nextInChain) == offsetof(WGPUDeviceDescriptor, nextInChain),\n            \"offsetof mismatch for DeviceDescriptor::nextInChain\");\n    static_assert(offsetof(DeviceDescriptor, label) == offsetof(WGPUDeviceDescriptor, label),\n            \"offsetof mismatch for DeviceDescriptor::label\");\n    static_assert(offsetof(DeviceDescriptor, requiredFeaturesCount) == offsetof(WGPUDeviceDescriptor, requiredFeaturesCount),\n            \"offsetof mismatch for DeviceDescriptor::requiredFeaturesCount\");\n    static_assert(offsetof(DeviceDescriptor, requiredFeatures) == offsetof(WGPUDeviceDescriptor, requiredFeatures),\n            \"offsetof mismatch for DeviceDescriptor::requiredFeatures\");\n    static_assert(offsetof(DeviceDescriptor, requiredLimits) == offsetof(WGPUDeviceDescriptor, requiredLimits),\n            \"offsetof mismatch for DeviceDescriptor::requiredLimits\");\n\n    bool DeviceDescriptor::operator==(const DeviceDescriptor& rhs) const {\n        return (nextInChain == rhs.nextInChain) && std::tie(\n            label,\n            requiredFeaturesCount,\n            requiredFeatures,\n            requiredLimits\n        ) == std::tie(\n            rhs.label,\n            rhs.requiredFeaturesCount,\n            rhs.requiredFeatures,\n            rhs.requiredLimits\n        );\n    }\n\n\n    static_assert(sizeof(DeviceProperties) == sizeof(WGPUDeviceProperties), \"sizeof mismatch for DeviceProperties\");\n    static_assert(alignof(DeviceProperties) == alignof(WGPUDeviceProperties), \"alignof mismatch for DeviceProperties\");\n\n    static_assert(offsetof(DeviceProperties, deviceID) == offsetof(WGPUDeviceProperties, deviceID),\n            \"offsetof mismatch for DeviceProperties::deviceID\");\n    static_assert(offsetof(DeviceProperties, vendorID) == offsetof(WGPUDeviceProperties, vendorID),\n            \"offsetof mismatch for DeviceProperties::vendorID\");\n    static_assert(offsetof(DeviceProperties, adapterType) == offsetof(WGPUDeviceProperties, adapterType),\n            \"offsetof mismatch for DeviceProperties::adapterType\");\n    static_assert(offsetof(DeviceProperties, textureCompressionBC) == offsetof(WGPUDeviceProperties, textureCompressionBC),\n            \"offsetof mismatch for DeviceProperties::textureCompressionBC\");\n    static_assert(offsetof(DeviceProperties, textureCompressionETC2) == offsetof(WGPUDeviceProperties, textureCompressionETC2),\n            \"offsetof mismatch for DeviceProperties::textureCompressionETC2\");\n    static_assert(offsetof(DeviceProperties, textureCompressionASTC) == offsetof(WGPUDeviceProperties, textureCompressionASTC),\n            \"offsetof mismatch for DeviceProperties::textureCompressionASTC\");\n    static_assert(offsetof(DeviceProperties, shaderFloat16) == offsetof(WGPUDeviceProperties, shaderFloat16),\n            \"offsetof mismatch for DeviceProperties::shaderFloat16\");\n    static_assert(offsetof(DeviceProperties, pipelineStatisticsQuery) == offsetof(WGPUDeviceProperties, pipelineStatisticsQuery),\n            \"offsetof mismatch for DeviceProperties::pipelineStatisticsQuery\");\n    static_assert(offsetof(DeviceProperties, timestampQuery) == offsetof(WGPUDeviceProperties, timestampQuery),\n            \"offsetof mismatch for DeviceProperties::timestampQuery\");\n    static_assert(offsetof(DeviceProperties, multiPlanarFormats) == offsetof(WGPUDeviceProperties, multiPlanarFormats),\n            \"offsetof mismatch for DeviceProperties::multiPlanarFormats\");\n    static_assert(offsetof(DeviceProperties, depthClamping) == offsetof(WGPUDeviceProperties, depthClamping),\n            \"offsetof mismatch for DeviceProperties::depthClamping\");\n    static_assert(offsetof(DeviceProperties, depth24UnormStencil8) == offsetof(WGPUDeviceProperties, depth24UnormStencil8),\n            \"offsetof mismatch for DeviceProperties::depth24UnormStencil8\");\n    static_assert(offsetof(DeviceProperties, depth32FloatStencil8) == offsetof(WGPUDeviceProperties, depth32FloatStencil8),\n            \"offsetof mismatch for DeviceProperties::depth32FloatStencil8\");\n    static_assert(offsetof(DeviceProperties, invalidFeature) == offsetof(WGPUDeviceProperties, invalidFeature),\n            \"offsetof mismatch for DeviceProperties::invalidFeature\");\n    static_assert(offsetof(DeviceProperties, dawnInternalUsages) == offsetof(WGPUDeviceProperties, dawnInternalUsages),\n            \"offsetof mismatch for DeviceProperties::dawnInternalUsages\");\n    static_assert(offsetof(DeviceProperties, dawnNative) == offsetof(WGPUDeviceProperties, dawnNative),\n            \"offsetof mismatch for DeviceProperties::dawnNative\");\n    static_assert(offsetof(DeviceProperties, limits) == offsetof(WGPUDeviceProperties, limits),\n            \"offsetof mismatch for DeviceProperties::limits\");\n\n    bool DeviceProperties::operator==(const DeviceProperties& rhs) const {\n        return  std::tie(\n            deviceID,\n            vendorID,\n            adapterType,\n            textureCompressionBC,\n            textureCompressionETC2,\n            textureCompressionASTC,\n            shaderFloat16,\n            pipelineStatisticsQuery,\n            timestampQuery,\n            multiPlanarFormats,\n            depthClamping,\n            depth24UnormStencil8,\n            depth32FloatStencil8,\n            invalidFeature,\n            dawnInternalUsages,\n            dawnNative,\n            limits\n        ) == std::tie(\n            rhs.deviceID,\n            rhs.vendorID,\n            rhs.adapterType,\n            rhs.textureCompressionBC,\n            rhs.textureCompressionETC2,\n            rhs.textureCompressionASTC,\n            rhs.shaderFloat16,\n            rhs.pipelineStatisticsQuery,\n            rhs.timestampQuery,\n            rhs.multiPlanarFormats,\n            rhs.depthClamping,\n            rhs.depth24UnormStencil8,\n            rhs.depth32FloatStencil8,\n            rhs.invalidFeature,\n            rhs.dawnInternalUsages,\n            rhs.dawnNative,\n            rhs.limits\n        );\n    }\n\n\n    static_assert(sizeof(RenderPassDescriptor) == sizeof(WGPURenderPassDescriptor), \"sizeof mismatch for RenderPassDescriptor\");\n    static_assert(alignof(RenderPassDescriptor) == alignof(WGPURenderPassDescriptor), \"alignof mismatch for RenderPassDescriptor\");\n\n    static_assert(offsetof(RenderPassDescriptor, nextInChain) == offsetof(WGPURenderPassDescriptor, nextInChain),\n            \"offsetof mismatch for RenderPassDescriptor::nextInChain\");\n    static_assert(offsetof(RenderPassDescriptor, label) == offsetof(WGPURenderPassDescriptor, label),\n            \"offsetof mismatch for RenderPassDescriptor::label\");\n    static_assert(offsetof(RenderPassDescriptor, colorAttachmentCount) == offsetof(WGPURenderPassDescriptor, colorAttachmentCount),\n            \"offsetof mismatch for RenderPassDescriptor::colorAttachmentCount\");\n    static_assert(offsetof(RenderPassDescriptor, colorAttachments) == offsetof(WGPURenderPassDescriptor, colorAttachments),\n            \"offsetof mismatch for RenderPassDescriptor::colorAttachments\");\n    static_assert(offsetof(RenderPassDescriptor, depthStencilAttachment) == offsetof(WGPURenderPassDescriptor, depthStencilAttachment),\n            \"offsetof mismatch for RenderPassDescriptor::depthStencilAttachment\");\n    static_assert(offsetof(RenderPassDescriptor, occlusionQuerySet) == offsetof(WGPURenderPassDescriptor, occlusionQuerySet),\n            \"offsetof mismatch for RenderPassDescriptor::occlusionQuerySet\");\n\n    bool RenderPassDescriptor::operator==(const RenderPassDescriptor& rhs) const {\n        return (nextInChain == rhs.nextInChain) && std::tie(\n            label,\n            colorAttachmentCount,\n            colorAttachments,\n            depthStencilAttachment,\n            occlusionQuerySet\n        ) == std::tie(\n            rhs.label,\n            rhs.colorAttachmentCount,\n            rhs.colorAttachments,\n            rhs.depthStencilAttachment,\n            rhs.occlusionQuerySet\n        );\n    }\n\n\n    static_assert(sizeof(VertexState) == sizeof(WGPUVertexState), \"sizeof mismatch for VertexState\");\n    static_assert(alignof(VertexState) == alignof(WGPUVertexState), \"alignof mismatch for VertexState\");\n\n    static_assert(offsetof(VertexState, nextInChain) == offsetof(WGPUVertexState, nextInChain),\n            \"offsetof mismatch for VertexState::nextInChain\");\n    static_assert(offsetof(VertexState, module) == offsetof(WGPUVertexState, module),\n            \"offsetof mismatch for VertexState::module\");\n    static_assert(offsetof(VertexState, entryPoint) == offsetof(WGPUVertexState, entryPoint),\n            \"offsetof mismatch for VertexState::entryPoint\");\n    static_assert(offsetof(VertexState, constantCount) == offsetof(WGPUVertexState, constantCount),\n            \"offsetof mismatch for VertexState::constantCount\");\n    static_assert(offsetof(VertexState, constants) == offsetof(WGPUVertexState, constants),\n            \"offsetof mismatch for VertexState::constants\");\n    static_assert(offsetof(VertexState, bufferCount) == offsetof(WGPUVertexState, bufferCount),\n            \"offsetof mismatch for VertexState::bufferCount\");\n    static_assert(offsetof(VertexState, buffers) == offsetof(WGPUVertexState, buffers),\n            \"offsetof mismatch for VertexState::buffers\");\n\n    bool VertexState::operator==(const VertexState& rhs) const {\n        return (nextInChain == rhs.nextInChain) && std::tie(\n            module,\n            entryPoint,\n            constantCount,\n            constants,\n            bufferCount,\n            buffers\n        ) == std::tie(\n            rhs.module,\n            rhs.entryPoint,\n            rhs.constantCount,\n            rhs.constants,\n            rhs.bufferCount,\n            rhs.buffers\n        );\n    }\n\n\n    static_assert(sizeof(FragmentState) == sizeof(WGPUFragmentState), \"sizeof mismatch for FragmentState\");\n    static_assert(alignof(FragmentState) == alignof(WGPUFragmentState), \"alignof mismatch for FragmentState\");\n\n    static_assert(offsetof(FragmentState, nextInChain) == offsetof(WGPUFragmentState, nextInChain),\n            \"offsetof mismatch for FragmentState::nextInChain\");\n    static_assert(offsetof(FragmentState, module) == offsetof(WGPUFragmentState, module),\n            \"offsetof mismatch for FragmentState::module\");\n    static_assert(offsetof(FragmentState, entryPoint) == offsetof(WGPUFragmentState, entryPoint),\n            \"offsetof mismatch for FragmentState::entryPoint\");\n    static_assert(offsetof(FragmentState, constantCount) == offsetof(WGPUFragmentState, constantCount),\n            \"offsetof mismatch for FragmentState::constantCount\");\n    static_assert(offsetof(FragmentState, constants) == offsetof(WGPUFragmentState, constants),\n            \"offsetof mismatch for FragmentState::constants\");\n    static_assert(offsetof(FragmentState, targetCount) == offsetof(WGPUFragmentState, targetCount),\n            \"offsetof mismatch for FragmentState::targetCount\");\n    static_assert(offsetof(FragmentState, targets) == offsetof(WGPUFragmentState, targets),\n            \"offsetof mismatch for FragmentState::targets\");\n\n    bool FragmentState::operator==(const FragmentState& rhs) const {\n        return (nextInChain == rhs.nextInChain) && std::tie(\n            module,\n            entryPoint,\n            constantCount,\n            constants,\n            targetCount,\n            targets\n        ) == std::tie(\n            rhs.module,\n            rhs.entryPoint,\n            rhs.constantCount,\n            rhs.constants,\n            rhs.targetCount,\n            rhs.targets\n        );\n    }\n\n\n    static_assert(sizeof(RenderPipelineDescriptor) == sizeof(WGPURenderPipelineDescriptor), \"sizeof mismatch for RenderPipelineDescriptor\");\n    static_assert(alignof(RenderPipelineDescriptor) == alignof(WGPURenderPipelineDescriptor), \"alignof mismatch for RenderPipelineDescriptor\");\n\n    static_assert(offsetof(RenderPipelineDescriptor, nextInChain) == offsetof(WGPURenderPipelineDescriptor, nextInChain),\n            \"offsetof mismatch for RenderPipelineDescriptor::nextInChain\");\n    static_assert(offsetof(RenderPipelineDescriptor, label) == offsetof(WGPURenderPipelineDescriptor, label),\n            \"offsetof mismatch for RenderPipelineDescriptor::label\");\n    static_assert(offsetof(RenderPipelineDescriptor, layout) == offsetof(WGPURenderPipelineDescriptor, layout),\n            \"offsetof mismatch for RenderPipelineDescriptor::layout\");\n    static_assert(offsetof(RenderPipelineDescriptor, vertex) == offsetof(WGPURenderPipelineDescriptor, vertex),\n            \"offsetof mismatch for RenderPipelineDescriptor::vertex\");\n    static_assert(offsetof(RenderPipelineDescriptor, primitive) == offsetof(WGPURenderPipelineDescriptor, primitive),\n            \"offsetof mismatch for RenderPipelineDescriptor::primitive\");\n    static_assert(offsetof(RenderPipelineDescriptor, depthStencil) == offsetof(WGPURenderPipelineDescriptor, depthStencil),\n            \"offsetof mismatch for RenderPipelineDescriptor::depthStencil\");\n    static_assert(offsetof(RenderPipelineDescriptor, multisample) == offsetof(WGPURenderPipelineDescriptor, multisample),\n            \"offsetof mismatch for RenderPipelineDescriptor::multisample\");\n    static_assert(offsetof(RenderPipelineDescriptor, fragment) == offsetof(WGPURenderPipelineDescriptor, fragment),\n            \"offsetof mismatch for RenderPipelineDescriptor::fragment\");\n\n    bool RenderPipelineDescriptor::operator==(const RenderPipelineDescriptor& rhs) const {\n        return (nextInChain == rhs.nextInChain) && std::tie(\n            label,\n            layout,\n            vertex,\n            primitive,\n            depthStencil,\n            multisample,\n            fragment\n        ) == std::tie(\n            rhs.label,\n            rhs.layout,\n            rhs.vertex,\n            rhs.primitive,\n            rhs.depthStencil,\n            rhs.multisample,\n            rhs.fragment\n        );\n    }\n\n} // namespace dawn::native\n", "src/dawn/native/ProcTable.cpp": "\n#include \"dawn/native/dawn_platform.h\"\n#include \"dawn/native/DawnNative.h\"\n\n#include <algorithm>\n#include <vector>\n\n#include \"dawn/native/Adapter.h\"\n#include \"dawn/native/BindGroup.h\"\n#include \"dawn/native/BindGroupLayout.h\"\n#include \"dawn/native/Buffer.h\"\n#include \"dawn/native/CommandBuffer.h\"\n#include \"dawn/native/CommandEncoder.h\"\n#include \"dawn/native/ComputePassEncoder.h\"\n#include \"dawn/native/ComputePipeline.h\"\n#include \"dawn/native/Device.h\"\n#include \"dawn/native/ExternalTexture.h\"\n#include \"dawn/native/Instance.h\"\n#include \"dawn/native/PipelineLayout.h\"\n#include \"dawn/native/QuerySet.h\"\n#include \"dawn/native/Queue.h\"\n#include \"dawn/native/RenderBundle.h\"\n#include \"dawn/native/RenderBundleEncoder.h\"\n#include \"dawn/native/RenderPassEncoder.h\"\n#include \"dawn/native/RenderPipeline.h\"\n#include \"dawn/native/Sampler.h\"\n#include \"dawn/native/ShaderModule.h\"\n#include \"dawn/native/Surface.h\"\n#include \"dawn/native/SwapChain.h\"\n#include \"dawn/native/Texture.h\"\n\nnamespace dawn::native {\n\n\n    WGPUDevice NativeAdapterCreateDevice(WGPUAdapter cSelf, WGPUDeviceDescriptor const * descriptor) {\n        auto self = FromAPI(cSelf);\n\n        auto descriptor_ = reinterpret_cast<DeviceDescriptor const * >(descriptor);\n        auto result =        self->APICreateDevice(descriptor_);\n        return ToAPI(result);\n    }\n\n    size_t NativeAdapterEnumerateFeatures(WGPUAdapter cSelf, WGPUFeatureName * features) {\n        auto self = FromAPI(cSelf);\n\n        auto features_ = reinterpret_cast<wgpu::FeatureName * >(features);\n        auto result =        self->APIEnumerateFeatures(features_);\n        return result;\n    }\n\n    bool NativeAdapterGetLimits(WGPUAdapter cSelf, WGPUSupportedLimits * limits) {\n        auto self = FromAPI(cSelf);\n\n        auto limits_ = reinterpret_cast<SupportedLimits * >(limits);\n        auto result =        self->APIGetLimits(limits_);\n        return result;\n    }\n\n    void NativeAdapterGetProperties(WGPUAdapter cSelf, WGPUAdapterProperties * properties) {\n        auto self = FromAPI(cSelf);\n\n        auto properties_ = reinterpret_cast<AdapterProperties * >(properties);\n        self->APIGetProperties(properties_);\n    }\n\n    bool NativeAdapterHasFeature(WGPUAdapter cSelf, WGPUFeatureName feature) {\n        auto self = FromAPI(cSelf);\n\n        auto feature_ = static_cast<wgpu::FeatureName>(feature);\n        auto result =        self->APIHasFeature(feature_);\n        return result;\n    }\n\n    void NativeAdapterRequestDevice(WGPUAdapter cSelf, WGPUDeviceDescriptor const * descriptor, WGPURequestDeviceCallback callback, void * userdata) {\n        auto self = FromAPI(cSelf);\n\n        auto descriptor_ = reinterpret_cast<DeviceDescriptor const * >(descriptor);\n        auto callback_ = callback;\n        auto userdata_ = reinterpret_cast<void * >(userdata);\n        self->APIRequestDevice(descriptor_, callback_, userdata_);\n    }\n\n    void NativeAdapterReference(WGPUAdapter cSelf) {\n        auto self = FromAPI(cSelf);\n\n        self->APIReference();\n    }\n\n    void NativeAdapterRelease(WGPUAdapter cSelf) {\n        auto self = FromAPI(cSelf);\n\n        self->APIRelease();\n    }\n\n    void NativeBindGroupSetLabel(WGPUBindGroup cSelf, char const * label) {\n        auto self = FromAPI(cSelf);\n\n        auto label_ = reinterpret_cast<char const * >(label);\n        self->APISetLabel(label_);\n    }\n\n    void NativeBindGroupReference(WGPUBindGroup cSelf) {\n        auto self = FromAPI(cSelf);\n\n        self->APIReference();\n    }\n\n    void NativeBindGroupRelease(WGPUBindGroup cSelf) {\n        auto self = FromAPI(cSelf);\n\n        self->APIRelease();\n    }\n\n    void NativeBindGroupLayoutSetLabel(WGPUBindGroupLayout cSelf, char const * label) {\n        auto self = FromAPI(cSelf);\n\n        auto label_ = reinterpret_cast<char const * >(label);\n        self->APISetLabel(label_);\n    }\n\n    void NativeBindGroupLayoutReference(WGPUBindGroupLayout cSelf) {\n        auto self = FromAPI(cSelf);\n\n        self->APIReference();\n    }\n\n    void NativeBindGroupLayoutRelease(WGPUBindGroupLayout cSelf) {\n        auto self = FromAPI(cSelf);\n\n        self->APIRelease();\n    }\n\n    void NativeBufferDestroy(WGPUBuffer cSelf) {\n        auto self = FromAPI(cSelf);\n\n        self->APIDestroy();\n    }\n\n    void const * NativeBufferGetConstMappedRange(WGPUBuffer cSelf, size_t offset, size_t size) {\n        auto self = FromAPI(cSelf);\n\n        auto offset_ = offset;\n        auto size_ = size;\n        auto result =        self->APIGetConstMappedRange(offset_, size_);\n        return result;\n    }\n\n    void * NativeBufferGetMappedRange(WGPUBuffer cSelf, size_t offset, size_t size) {\n        auto self = FromAPI(cSelf);\n\n        auto offset_ = offset;\n        auto size_ = size;\n        auto result =        self->APIGetMappedRange(offset_, size_);\n        return result;\n    }\n\n    void NativeBufferMapAsync(WGPUBuffer cSelf, WGPUMapModeFlags mode, size_t offset, size_t size, WGPUBufferMapCallback callback, void * userdata) {\n        auto self = FromAPI(cSelf);\n\n        auto mode_ = static_cast<wgpu::MapMode>(mode);\n        auto offset_ = offset;\n        auto size_ = size;\n        auto callback_ = callback;\n        auto userdata_ = reinterpret_cast<void * >(userdata);\n        self->APIMapAsync(mode_, offset_, size_, callback_, userdata_);\n    }\n\n    void NativeBufferSetLabel(WGPUBuffer cSelf, char const * label) {\n        auto self = FromAPI(cSelf);\n\n        auto label_ = reinterpret_cast<char const * >(label);\n        self->APISetLabel(label_);\n    }\n\n    void NativeBufferUnmap(WGPUBuffer cSelf) {\n        auto self = FromAPI(cSelf);\n\n        self->APIUnmap();\n    }\n\n    void NativeBufferReference(WGPUBuffer cSelf) {\n        auto self = FromAPI(cSelf);\n\n        self->APIReference();\n    }\n\n    void NativeBufferRelease(WGPUBuffer cSelf) {\n        auto self = FromAPI(cSelf);\n\n        self->APIRelease();\n    }\n\n    void NativeCommandBufferSetLabel(WGPUCommandBuffer cSelf, char const * label) {\n        auto self = FromAPI(cSelf);\n\n        auto label_ = reinterpret_cast<char const * >(label);\n        self->APISetLabel(label_);\n    }\n\n    void NativeCommandBufferReference(WGPUCommandBuffer cSelf) {\n        auto self = FromAPI(cSelf);\n\n        self->APIReference();\n    }\n\n    void NativeCommandBufferRelease(WGPUCommandBuffer cSelf) {\n        auto self = FromAPI(cSelf);\n\n        self->APIRelease();\n    }\n\n    WGPUComputePassEncoder NativeCommandEncoderBeginComputePass(WGPUCommandEncoder cSelf, WGPUComputePassDescriptor const * descriptor) {\n        auto self = FromAPI(cSelf);\n\n        auto descriptor_ = reinterpret_cast<ComputePassDescriptor const * >(descriptor);\n        auto result =        self->APIBeginComputePass(descriptor_);\n        return ToAPI(result);\n    }\n\n    WGPURenderPassEncoder NativeCommandEncoderBeginRenderPass(WGPUCommandEncoder cSelf, WGPURenderPassDescriptor const * descriptor) {\n        auto self = FromAPI(cSelf);\n\n        auto descriptor_ = reinterpret_cast<RenderPassDescriptor const * >(descriptor);\n        auto result =        self->APIBeginRenderPass(descriptor_);\n        return ToAPI(result);\n    }\n\n    void NativeCommandEncoderClearBuffer(WGPUCommandEncoder cSelf, WGPUBuffer buffer, uint64_t offset, uint64_t size) {\n        auto self = FromAPI(cSelf);\n\n        auto buffer_ = reinterpret_cast<BufferBase* >(buffer);\n        auto offset_ = offset;\n        auto size_ = size;\n        self->APIClearBuffer(buffer_, offset_, size_);\n    }\n\n    void NativeCommandEncoderCopyBufferToBuffer(WGPUCommandEncoder cSelf, WGPUBuffer source, uint64_t sourceOffset, WGPUBuffer destination, uint64_t destinationOffset, uint64_t size) {\n        auto self = FromAPI(cSelf);\n\n        auto source_ = reinterpret_cast<BufferBase* >(source);\n        auto sourceOffset_ = sourceOffset;\n        auto destination_ = reinterpret_cast<BufferBase* >(destination);\n        auto destinationOffset_ = destinationOffset;\n        auto size_ = size;\n        self->APICopyBufferToBuffer(source_, sourceOffset_, destination_, destinationOffset_, size_);\n    }\n\n    void NativeCommandEncoderCopyBufferToTexture(WGPUCommandEncoder cSelf, WGPUImageCopyBuffer const * source, WGPUImageCopyTexture const * destination, WGPUExtent3D const * copySize) {\n        auto self = FromAPI(cSelf);\n\n        auto source_ = reinterpret_cast<ImageCopyBuffer const * >(source);\n        auto destination_ = reinterpret_cast<ImageCopyTexture const * >(destination);\n        auto copySize_ = reinterpret_cast<Extent3D const * >(copySize);\n        self->APICopyBufferToTexture(source_, destination_, copySize_);\n    }\n\n    void NativeCommandEncoderCopyTextureToBuffer(WGPUCommandEncoder cSelf, WGPUImageCopyTexture const * source, WGPUImageCopyBuffer const * destination, WGPUExtent3D const * copySize) {\n        auto self = FromAPI(cSelf);\n\n        auto source_ = reinterpret_cast<ImageCopyTexture const * >(source);\n        auto destination_ = reinterpret_cast<ImageCopyBuffer const * >(destination);\n        auto copySize_ = reinterpret_cast<Extent3D const * >(copySize);\n        self->APICopyTextureToBuffer(source_, destination_, copySize_);\n    }\n\n    void NativeCommandEncoderCopyTextureToTexture(WGPUCommandEncoder cSelf, WGPUImageCopyTexture const * source, WGPUImageCopyTexture const * destination, WGPUExtent3D const * copySize) {\n        auto self = FromAPI(cSelf);\n\n        auto source_ = reinterpret_cast<ImageCopyTexture const * >(source);\n        auto destination_ = reinterpret_cast<ImageCopyTexture const * >(destination);\n        auto copySize_ = reinterpret_cast<Extent3D const * >(copySize);\n        self->APICopyTextureToTexture(source_, destination_, copySize_);\n    }\n\n    void NativeCommandEncoderCopyTextureToTextureInternal(WGPUCommandEncoder cSelf, WGPUImageCopyTexture const * source, WGPUImageCopyTexture const * destination, WGPUExtent3D const * copySize) {\n        auto self = FromAPI(cSelf);\n\n        auto source_ = reinterpret_cast<ImageCopyTexture const * >(source);\n        auto destination_ = reinterpret_cast<ImageCopyTexture const * >(destination);\n        auto copySize_ = reinterpret_cast<Extent3D const * >(copySize);\n        self->APICopyTextureToTextureInternal(source_, destination_, copySize_);\n    }\n\n    WGPUCommandBuffer NativeCommandEncoderFinish(WGPUCommandEncoder cSelf, WGPUCommandBufferDescriptor const * descriptor) {\n        auto self = FromAPI(cSelf);\n\n        auto descriptor_ = reinterpret_cast<CommandBufferDescriptor const * >(descriptor);\n        auto result =        self->APIFinish(descriptor_);\n        return ToAPI(result);\n    }\n\n    void NativeCommandEncoderInjectValidationError(WGPUCommandEncoder cSelf, char const * message) {\n        auto self = FromAPI(cSelf);\n\n        auto message_ = reinterpret_cast<char const * >(message);\n        self->APIInjectValidationError(message_);\n    }\n\n    void NativeCommandEncoderInsertDebugMarker(WGPUCommandEncoder cSelf, char const * markerLabel) {\n        auto self = FromAPI(cSelf);\n\n        auto markerLabel_ = reinterpret_cast<char const * >(markerLabel);\n        self->APIInsertDebugMarker(markerLabel_);\n    }\n\n    void NativeCommandEncoderPopDebugGroup(WGPUCommandEncoder cSelf) {\n        auto self = FromAPI(cSelf);\n\n        self->APIPopDebugGroup();\n    }\n\n    void NativeCommandEncoderPushDebugGroup(WGPUCommandEncoder cSelf, char const * groupLabel) {\n        auto self = FromAPI(cSelf);\n\n        auto groupLabel_ = reinterpret_cast<char const * >(groupLabel);\n        self->APIPushDebugGroup(groupLabel_);\n    }\n\n    void NativeCommandEncoderResolveQuerySet(WGPUCommandEncoder cSelf, WGPUQuerySet querySet, uint32_t firstQuery, uint32_t queryCount, WGPUBuffer destination, uint64_t destinationOffset) {\n        auto self = FromAPI(cSelf);\n\n        auto querySet_ = reinterpret_cast<QuerySetBase* >(querySet);\n        auto firstQuery_ = firstQuery;\n        auto queryCount_ = queryCount;\n        auto destination_ = reinterpret_cast<BufferBase* >(destination);\n        auto destinationOffset_ = destinationOffset;\n        self->APIResolveQuerySet(querySet_, firstQuery_, queryCount_, destination_, destinationOffset_);\n    }\n\n    void NativeCommandEncoderSetLabel(WGPUCommandEncoder cSelf, char const * label) {\n        auto self = FromAPI(cSelf);\n\n        auto label_ = reinterpret_cast<char const * >(label);\n        self->APISetLabel(label_);\n    }\n\n    void NativeCommandEncoderWriteBuffer(WGPUCommandEncoder cSelf, WGPUBuffer buffer, uint64_t bufferOffset, uint8_t const * data, uint64_t size) {\n        auto self = FromAPI(cSelf);\n\n        auto buffer_ = reinterpret_cast<BufferBase* >(buffer);\n        auto bufferOffset_ = bufferOffset;\n        auto data_ = reinterpret_cast<uint8_t const * >(data);\n        auto size_ = size;\n        self->APIWriteBuffer(buffer_, bufferOffset_, data_, size_);\n    }\n\n    void NativeCommandEncoderWriteTimestamp(WGPUCommandEncoder cSelf, WGPUQuerySet querySet, uint32_t queryIndex) {\n        auto self = FromAPI(cSelf);\n\n        auto querySet_ = reinterpret_cast<QuerySetBase* >(querySet);\n        auto queryIndex_ = queryIndex;\n        self->APIWriteTimestamp(querySet_, queryIndex_);\n    }\n\n    void NativeCommandEncoderReference(WGPUCommandEncoder cSelf) {\n        auto self = FromAPI(cSelf);\n\n        self->APIReference();\n    }\n\n    void NativeCommandEncoderRelease(WGPUCommandEncoder cSelf) {\n        auto self = FromAPI(cSelf);\n\n        self->APIRelease();\n    }\n\n    void NativeComputePassEncoderDispatch(WGPUComputePassEncoder cSelf, uint32_t workgroupCountX, uint32_t workgroupCountY, uint32_t workgroupCountZ) {\n        auto self = FromAPI(cSelf);\n\n        auto workgroupCountX_ = workgroupCountX;\n        auto workgroupCountY_ = workgroupCountY;\n        auto workgroupCountZ_ = workgroupCountZ;\n        self->APIDispatch(workgroupCountX_, workgroupCountY_, workgroupCountZ_);\n    }\n\n    void NativeComputePassEncoderDispatchIndirect(WGPUComputePassEncoder cSelf, WGPUBuffer indirectBuffer, uint64_t indirectOffset) {\n        auto self = FromAPI(cSelf);\n\n        auto indirectBuffer_ = reinterpret_cast<BufferBase* >(indirectBuffer);\n        auto indirectOffset_ = indirectOffset;\n        self->APIDispatchIndirect(indirectBuffer_, indirectOffset_);\n    }\n\n    void NativeComputePassEncoderEnd(WGPUComputePassEncoder cSelf) {\n        auto self = FromAPI(cSelf);\n\n        self->APIEnd();\n    }\n\n    void NativeComputePassEncoderEndPass(WGPUComputePassEncoder cSelf) {\n        auto self = FromAPI(cSelf);\n\n        self->APIEndPass();\n    }\n\n    void NativeComputePassEncoderInsertDebugMarker(WGPUComputePassEncoder cSelf, char const * markerLabel) {\n        auto self = FromAPI(cSelf);\n\n        auto markerLabel_ = reinterpret_cast<char const * >(markerLabel);\n        self->APIInsertDebugMarker(markerLabel_);\n    }\n\n    void NativeComputePassEncoderPopDebugGroup(WGPUComputePassEncoder cSelf) {\n        auto self = FromAPI(cSelf);\n\n        self->APIPopDebugGroup();\n    }\n\n    void NativeComputePassEncoderPushDebugGroup(WGPUComputePassEncoder cSelf, char const * groupLabel) {\n        auto self = FromAPI(cSelf);\n\n        auto groupLabel_ = reinterpret_cast<char const * >(groupLabel);\n        self->APIPushDebugGroup(groupLabel_);\n    }\n\n    void NativeComputePassEncoderSetBindGroup(WGPUComputePassEncoder cSelf, uint32_t groupIndex, WGPUBindGroup group, uint32_t dynamicOffsetCount, uint32_t const * dynamicOffsets) {\n        auto self = FromAPI(cSelf);\n\n        auto groupIndex_ = groupIndex;\n        auto group_ = reinterpret_cast<BindGroupBase* >(group);\n        auto dynamicOffsetCount_ = dynamicOffsetCount;\n        auto dynamicOffsets_ = reinterpret_cast<uint32_t const * >(dynamicOffsets);\n        self->APISetBindGroup(groupIndex_, group_, dynamicOffsetCount_, dynamicOffsets_);\n    }\n\n    void NativeComputePassEncoderSetLabel(WGPUComputePassEncoder cSelf, char const * label) {\n        auto self = FromAPI(cSelf);\n\n        auto label_ = reinterpret_cast<char const * >(label);\n        self->APISetLabel(label_);\n    }\n\n    void NativeComputePassEncoderSetPipeline(WGPUComputePassEncoder cSelf, WGPUComputePipeline pipeline) {\n        auto self = FromAPI(cSelf);\n\n        auto pipeline_ = reinterpret_cast<ComputePipelineBase* >(pipeline);\n        self->APISetPipeline(pipeline_);\n    }\n\n    void NativeComputePassEncoderWriteTimestamp(WGPUComputePassEncoder cSelf, WGPUQuerySet querySet, uint32_t queryIndex) {\n        auto self = FromAPI(cSelf);\n\n        auto querySet_ = reinterpret_cast<QuerySetBase* >(querySet);\n        auto queryIndex_ = queryIndex;\n        self->APIWriteTimestamp(querySet_, queryIndex_);\n    }\n\n    void NativeComputePassEncoderReference(WGPUComputePassEncoder cSelf) {\n        auto self = FromAPI(cSelf);\n\n        self->APIReference();\n    }\n\n    void NativeComputePassEncoderRelease(WGPUComputePassEncoder cSelf) {\n        auto self = FromAPI(cSelf);\n\n        self->APIRelease();\n    }\n\n    WGPUBindGroupLayout NativeComputePipelineGetBindGroupLayout(WGPUComputePipeline cSelf, uint32_t groupIndex) {\n        auto self = FromAPI(cSelf);\n\n        auto groupIndex_ = groupIndex;\n        auto result =        self->APIGetBindGroupLayout(groupIndex_);\n        return ToAPI(result);\n    }\n\n    void NativeComputePipelineSetLabel(WGPUComputePipeline cSelf, char const * label) {\n        auto self = FromAPI(cSelf);\n\n        auto label_ = reinterpret_cast<char const * >(label);\n        self->APISetLabel(label_);\n    }\n\n    void NativeComputePipelineReference(WGPUComputePipeline cSelf) {\n        auto self = FromAPI(cSelf);\n\n        self->APIReference();\n    }\n\n    void NativeComputePipelineRelease(WGPUComputePipeline cSelf) {\n        auto self = FromAPI(cSelf);\n\n        self->APIRelease();\n    }\n\n    WGPUBindGroup NativeDeviceCreateBindGroup(WGPUDevice cSelf, WGPUBindGroupDescriptor const * descriptor) {\n        auto self = FromAPI(cSelf);\n\n        auto descriptor_ = reinterpret_cast<BindGroupDescriptor const * >(descriptor);\n        auto result =        self->APICreateBindGroup(descriptor_);\n        return ToAPI(result);\n    }\n\n    WGPUBindGroupLayout NativeDeviceCreateBindGroupLayout(WGPUDevice cSelf, WGPUBindGroupLayoutDescriptor const * descriptor) {\n        auto self = FromAPI(cSelf);\n\n        auto descriptor_ = reinterpret_cast<BindGroupLayoutDescriptor const * >(descriptor);\n        auto result =        self->APICreateBindGroupLayout(descriptor_);\n        return ToAPI(result);\n    }\n\n    WGPUBuffer NativeDeviceCreateBuffer(WGPUDevice cSelf, WGPUBufferDescriptor const * descriptor) {\n        auto self = FromAPI(cSelf);\n\n        auto descriptor_ = reinterpret_cast<BufferDescriptor const * >(descriptor);\n        auto result =        self->APICreateBuffer(descriptor_);\n        return ToAPI(result);\n    }\n\n    WGPUCommandEncoder NativeDeviceCreateCommandEncoder(WGPUDevice cSelf, WGPUCommandEncoderDescriptor const * descriptor) {\n        auto self = FromAPI(cSelf);\n\n        auto descriptor_ = reinterpret_cast<CommandEncoderDescriptor const * >(descriptor);\n        auto result =        self->APICreateCommandEncoder(descriptor_);\n        return ToAPI(result);\n    }\n\n    WGPUComputePipeline NativeDeviceCreateComputePipeline(WGPUDevice cSelf, WGPUComputePipelineDescriptor const * descriptor) {\n        auto self = FromAPI(cSelf);\n\n        auto descriptor_ = reinterpret_cast<ComputePipelineDescriptor const * >(descriptor);\n        auto result =        self->APICreateComputePipeline(descriptor_);\n        return ToAPI(result);\n    }\n\n    void NativeDeviceCreateComputePipelineAsync(WGPUDevice cSelf, WGPUComputePipelineDescriptor const * descriptor, WGPUCreateComputePipelineAsyncCallback callback, void * userdata) {\n        auto self = FromAPI(cSelf);\n\n        auto descriptor_ = reinterpret_cast<ComputePipelineDescriptor const * >(descriptor);\n        auto callback_ = callback;\n        auto userdata_ = reinterpret_cast<void * >(userdata);\n        self->APICreateComputePipelineAsync(descriptor_, callback_, userdata_);\n    }\n\n    WGPUBuffer NativeDeviceCreateErrorBuffer(WGPUDevice cSelf) {\n        auto self = FromAPI(cSelf);\n\n        auto result =        self->APICreateErrorBuffer();\n        return ToAPI(result);\n    }\n\n    WGPUExternalTexture NativeDeviceCreateExternalTexture(WGPUDevice cSelf, WGPUExternalTextureDescriptor const * externalTextureDescriptor) {\n        auto self = FromAPI(cSelf);\n\n        auto externalTextureDescriptor_ = reinterpret_cast<ExternalTextureDescriptor const * >(externalTextureDescriptor);\n        auto result =        self->APICreateExternalTexture(externalTextureDescriptor_);\n        return ToAPI(result);\n    }\n\n    WGPUPipelineLayout NativeDeviceCreatePipelineLayout(WGPUDevice cSelf, WGPUPipelineLayoutDescriptor const * descriptor) {\n        auto self = FromAPI(cSelf);\n\n        auto descriptor_ = reinterpret_cast<PipelineLayoutDescriptor const * >(descriptor);\n        auto result =        self->APICreatePipelineLayout(descriptor_);\n        return ToAPI(result);\n    }\n\n    WGPUQuerySet NativeDeviceCreateQuerySet(WGPUDevice cSelf, WGPUQuerySetDescriptor const * descriptor) {\n        auto self = FromAPI(cSelf);\n\n        auto descriptor_ = reinterpret_cast<QuerySetDescriptor const * >(descriptor);\n        auto result =        self->APICreateQuerySet(descriptor_);\n        return ToAPI(result);\n    }\n\n    WGPURenderBundleEncoder NativeDeviceCreateRenderBundleEncoder(WGPUDevice cSelf, WGPURenderBundleEncoderDescriptor const * descriptor) {\n        auto self = FromAPI(cSelf);\n\n        auto descriptor_ = reinterpret_cast<RenderBundleEncoderDescriptor const * >(descriptor);\n        auto result =        self->APICreateRenderBundleEncoder(descriptor_);\n        return ToAPI(result);\n    }\n\n    WGPURenderPipeline NativeDeviceCreateRenderPipeline(WGPUDevice cSelf, WGPURenderPipelineDescriptor const * descriptor) {\n        auto self = FromAPI(cSelf);\n\n        auto descriptor_ = reinterpret_cast<RenderPipelineDescriptor const * >(descriptor);\n        auto result =        self->APICreateRenderPipeline(descriptor_);\n        return ToAPI(result);\n    }\n\n    void NativeDeviceCreateRenderPipelineAsync(WGPUDevice cSelf, WGPURenderPipelineDescriptor const * descriptor, WGPUCreateRenderPipelineAsyncCallback callback, void * userdata) {\n        auto self = FromAPI(cSelf);\n\n        auto descriptor_ = reinterpret_cast<RenderPipelineDescriptor const * >(descriptor);\n        auto callback_ = callback;\n        auto userdata_ = reinterpret_cast<void * >(userdata);\n        self->APICreateRenderPipelineAsync(descriptor_, callback_, userdata_);\n    }\n\n    WGPUSampler NativeDeviceCreateSampler(WGPUDevice cSelf, WGPUSamplerDescriptor const * descriptor) {\n        auto self = FromAPI(cSelf);\n\n        auto descriptor_ = reinterpret_cast<SamplerDescriptor const * >(descriptor);\n        auto result =        self->APICreateSampler(descriptor_);\n        return ToAPI(result);\n    }\n\n    WGPUShaderModule NativeDeviceCreateShaderModule(WGPUDevice cSelf, WGPUShaderModuleDescriptor const * descriptor) {\n        auto self = FromAPI(cSelf);\n\n        auto descriptor_ = reinterpret_cast<ShaderModuleDescriptor const * >(descriptor);\n        auto result =        self->APICreateShaderModule(descriptor_);\n        return ToAPI(result);\n    }\n\n    WGPUSwapChain NativeDeviceCreateSwapChain(WGPUDevice cSelf, WGPUSurface surface, WGPUSwapChainDescriptor const * descriptor) {\n        auto self = FromAPI(cSelf);\n\n        auto surface_ = reinterpret_cast<SurfaceBase* >(surface);\n        auto descriptor_ = reinterpret_cast<SwapChainDescriptor const * >(descriptor);\n        auto result =        self->APICreateSwapChain(surface_, descriptor_);\n        return ToAPI(result);\n    }\n\n    WGPUTexture NativeDeviceCreateTexture(WGPUDevice cSelf, WGPUTextureDescriptor const * descriptor) {\n        auto self = FromAPI(cSelf);\n\n        auto descriptor_ = reinterpret_cast<TextureDescriptor const * >(descriptor);\n        auto result =        self->APICreateTexture(descriptor_);\n        return ToAPI(result);\n    }\n\n    void NativeDeviceDestroy(WGPUDevice cSelf) {\n        auto self = FromAPI(cSelf);\n\n        self->APIDestroy();\n    }\n\n    size_t NativeDeviceEnumerateFeatures(WGPUDevice cSelf, WGPUFeatureName * features) {\n        auto self = FromAPI(cSelf);\n\n        auto features_ = reinterpret_cast<wgpu::FeatureName * >(features);\n        auto result =        self->APIEnumerateFeatures(features_);\n        return result;\n    }\n\n    bool NativeDeviceGetLimits(WGPUDevice cSelf, WGPUSupportedLimits * limits) {\n        auto self = FromAPI(cSelf);\n\n        auto limits_ = reinterpret_cast<SupportedLimits * >(limits);\n        auto result =        self->APIGetLimits(limits_);\n        return result;\n    }\n\n    WGPUQueue NativeDeviceGetQueue(WGPUDevice cSelf) {\n        auto self = FromAPI(cSelf);\n\n        auto result =        self->APIGetQueue();\n        return ToAPI(result);\n    }\n\n    bool NativeDeviceHasFeature(WGPUDevice cSelf, WGPUFeatureName feature) {\n        auto self = FromAPI(cSelf);\n\n        auto feature_ = static_cast<wgpu::FeatureName>(feature);\n        auto result =        self->APIHasFeature(feature_);\n        return result;\n    }\n\n    void NativeDeviceInjectError(WGPUDevice cSelf, WGPUErrorType type, char const * message) {\n        auto self = FromAPI(cSelf);\n\n        auto type_ = static_cast<wgpu::ErrorType>(type);\n        auto message_ = reinterpret_cast<char const * >(message);\n        self->APIInjectError(type_, message_);\n    }\n\n    void NativeDeviceLoseForTesting(WGPUDevice cSelf) {\n        auto self = FromAPI(cSelf);\n\n        self->APILoseForTesting();\n    }\n\n    bool NativeDevicePopErrorScope(WGPUDevice cSelf, WGPUErrorCallback callback, void * userdata) {\n        auto self = FromAPI(cSelf);\n\n        auto callback_ = callback;\n        auto userdata_ = reinterpret_cast<void * >(userdata);\n        auto result =        self->APIPopErrorScope(callback_, userdata_);\n        return result;\n    }\n\n    void NativeDevicePushErrorScope(WGPUDevice cSelf, WGPUErrorFilter filter) {\n        auto self = FromAPI(cSelf);\n\n        auto filter_ = static_cast<wgpu::ErrorFilter>(filter);\n        self->APIPushErrorScope(filter_);\n    }\n\n    void NativeDeviceSetDeviceLostCallback(WGPUDevice cSelf, WGPUDeviceLostCallback callback, void * userdata) {\n        auto self = FromAPI(cSelf);\n\n        auto callback_ = callback;\n        auto userdata_ = reinterpret_cast<void * >(userdata);\n        self->APISetDeviceLostCallback(callback_, userdata_);\n    }\n\n    void NativeDeviceSetLoggingCallback(WGPUDevice cSelf, WGPULoggingCallback callback, void * userdata) {\n        auto self = FromAPI(cSelf);\n\n        auto callback_ = callback;\n        auto userdata_ = reinterpret_cast<void * >(userdata);\n        self->APISetLoggingCallback(callback_, userdata_);\n    }\n\n    void NativeDeviceSetUncapturedErrorCallback(WGPUDevice cSelf, WGPUErrorCallback callback, void * userdata) {\n        auto self = FromAPI(cSelf);\n\n        auto callback_ = callback;\n        auto userdata_ = reinterpret_cast<void * >(userdata);\n        self->APISetUncapturedErrorCallback(callback_, userdata_);\n    }\n\n    void NativeDeviceTick(WGPUDevice cSelf) {\n        auto self = FromAPI(cSelf);\n\n        self->APITick();\n    }\n\n    void NativeDeviceReference(WGPUDevice cSelf) {\n        auto self = FromAPI(cSelf);\n\n        self->APIReference();\n    }\n\n    void NativeDeviceRelease(WGPUDevice cSelf) {\n        auto self = FromAPI(cSelf);\n\n        self->APIRelease();\n    }\n\n    void NativeExternalTextureDestroy(WGPUExternalTexture cSelf) {\n        auto self = FromAPI(cSelf);\n\n        self->APIDestroy();\n    }\n\n    void NativeExternalTextureSetLabel(WGPUExternalTexture cSelf, char const * label) {\n        auto self = FromAPI(cSelf);\n\n        auto label_ = reinterpret_cast<char const * >(label);\n        self->APISetLabel(label_);\n    }\n\n    void NativeExternalTextureReference(WGPUExternalTexture cSelf) {\n        auto self = FromAPI(cSelf);\n\n        self->APIReference();\n    }\n\n    void NativeExternalTextureRelease(WGPUExternalTexture cSelf) {\n        auto self = FromAPI(cSelf);\n\n        self->APIRelease();\n    }\n\n    WGPUSurface NativeInstanceCreateSurface(WGPUInstance cSelf, WGPUSurfaceDescriptor const * descriptor) {\n        auto self = FromAPI(cSelf);\n\n        auto descriptor_ = reinterpret_cast<SurfaceDescriptor const * >(descriptor);\n        auto result =        self->APICreateSurface(descriptor_);\n        return ToAPI(result);\n    }\n\n    void NativeInstanceRequestAdapter(WGPUInstance cSelf, WGPURequestAdapterOptions const * options, WGPURequestAdapterCallback callback, void * userdata) {\n        auto self = FromAPI(cSelf);\n\n        auto options_ = reinterpret_cast<RequestAdapterOptions const * >(options);\n        auto callback_ = callback;\n        auto userdata_ = reinterpret_cast<void * >(userdata);\n        self->APIRequestAdapter(options_, callback_, userdata_);\n    }\n\n    void NativeInstanceReference(WGPUInstance cSelf) {\n        auto self = FromAPI(cSelf);\n\n        self->APIReference();\n    }\n\n    void NativeInstanceRelease(WGPUInstance cSelf) {\n        auto self = FromAPI(cSelf);\n\n        self->APIRelease();\n    }\n\n    void NativePipelineLayoutSetLabel(WGPUPipelineLayout cSelf, char const * label) {\n        auto self = FromAPI(cSelf);\n\n        auto label_ = reinterpret_cast<char const * >(label);\n        self->APISetLabel(label_);\n    }\n\n    void NativePipelineLayoutReference(WGPUPipelineLayout cSelf) {\n        auto self = FromAPI(cSelf);\n\n        self->APIReference();\n    }\n\n    void NativePipelineLayoutRelease(WGPUPipelineLayout cSelf) {\n        auto self = FromAPI(cSelf);\n\n        self->APIRelease();\n    }\n\n    void NativeQuerySetDestroy(WGPUQuerySet cSelf) {\n        auto self = FromAPI(cSelf);\n\n        self->APIDestroy();\n    }\n\n    void NativeQuerySetSetLabel(WGPUQuerySet cSelf, char const * label) {\n        auto self = FromAPI(cSelf);\n\n        auto label_ = reinterpret_cast<char const * >(label);\n        self->APISetLabel(label_);\n    }\n\n    void NativeQuerySetReference(WGPUQuerySet cSelf) {\n        auto self = FromAPI(cSelf);\n\n        self->APIReference();\n    }\n\n    void NativeQuerySetRelease(WGPUQuerySet cSelf) {\n        auto self = FromAPI(cSelf);\n\n        self->APIRelease();\n    }\n\n    void NativeQueueCopyTextureForBrowser(WGPUQueue cSelf, WGPUImageCopyTexture const * source, WGPUImageCopyTexture const * destination, WGPUExtent3D const * copySize, WGPUCopyTextureForBrowserOptions const * options) {\n        auto self = FromAPI(cSelf);\n\n        auto source_ = reinterpret_cast<ImageCopyTexture const * >(source);\n        auto destination_ = reinterpret_cast<ImageCopyTexture const * >(destination);\n        auto copySize_ = reinterpret_cast<Extent3D const * >(copySize);\n        auto options_ = reinterpret_cast<CopyTextureForBrowserOptions const * >(options);\n        self->APICopyTextureForBrowser(source_, destination_, copySize_, options_);\n    }\n\n    void NativeQueueOnSubmittedWorkDone(WGPUQueue cSelf, uint64_t signalValue, WGPUQueueWorkDoneCallback callback, void * userdata) {\n        auto self = FromAPI(cSelf);\n\n        auto signalValue_ = signalValue;\n        auto callback_ = callback;\n        auto userdata_ = reinterpret_cast<void * >(userdata);\n        self->APIOnSubmittedWorkDone(signalValue_, callback_, userdata_);\n    }\n\n    void NativeQueueSubmit(WGPUQueue cSelf, uint32_t commandCount, WGPUCommandBuffer const * commands) {\n        auto self = FromAPI(cSelf);\n\n        auto commandCount_ = commandCount;\n        auto commands_ = reinterpret_cast<CommandBufferBase* const * >(commands);\n        self->APISubmit(commandCount_, commands_);\n    }\n\n    void NativeQueueWriteBuffer(WGPUQueue cSelf, WGPUBuffer buffer, uint64_t bufferOffset, void const * data, size_t size) {\n        auto self = FromAPI(cSelf);\n\n        auto buffer_ = reinterpret_cast<BufferBase* >(buffer);\n        auto bufferOffset_ = bufferOffset;\n        auto data_ = reinterpret_cast<void const * >(data);\n        auto size_ = size;\n        self->APIWriteBuffer(buffer_, bufferOffset_, data_, size_);\n    }\n\n    void NativeQueueWriteTexture(WGPUQueue cSelf, WGPUImageCopyTexture const * destination, void const * data, size_t dataSize, WGPUTextureDataLayout const * dataLayout, WGPUExtent3D const * writeSize) {\n        auto self = FromAPI(cSelf);\n\n        auto destination_ = reinterpret_cast<ImageCopyTexture const * >(destination);\n        auto data_ = reinterpret_cast<void const * >(data);\n        auto dataSize_ = dataSize;\n        auto dataLayout_ = reinterpret_cast<TextureDataLayout const * >(dataLayout);\n        auto writeSize_ = reinterpret_cast<Extent3D const * >(writeSize);\n        self->APIWriteTexture(destination_, data_, dataSize_, dataLayout_, writeSize_);\n    }\n\n    void NativeQueueReference(WGPUQueue cSelf) {\n        auto self = FromAPI(cSelf);\n\n        self->APIReference();\n    }\n\n    void NativeQueueRelease(WGPUQueue cSelf) {\n        auto self = FromAPI(cSelf);\n\n        self->APIRelease();\n    }\n\n    void NativeRenderBundleReference(WGPURenderBundle cSelf) {\n        auto self = FromAPI(cSelf);\n\n        self->APIReference();\n    }\n\n    void NativeRenderBundleRelease(WGPURenderBundle cSelf) {\n        auto self = FromAPI(cSelf);\n\n        self->APIRelease();\n    }\n\n    void NativeRenderBundleEncoderDraw(WGPURenderBundleEncoder cSelf, uint32_t vertexCount, uint32_t instanceCount, uint32_t firstVertex, uint32_t firstInstance) {\n        auto self = FromAPI(cSelf);\n\n        auto vertexCount_ = vertexCount;\n        auto instanceCount_ = instanceCount;\n        auto firstVertex_ = firstVertex;\n        auto firstInstance_ = firstInstance;\n        self->APIDraw(vertexCount_, instanceCount_, firstVertex_, firstInstance_);\n    }\n\n    void NativeRenderBundleEncoderDrawIndexed(WGPURenderBundleEncoder cSelf, uint32_t indexCount, uint32_t instanceCount, uint32_t firstIndex, int32_t baseVertex, uint32_t firstInstance) {\n        auto self = FromAPI(cSelf);\n\n        auto indexCount_ = indexCount;\n        auto instanceCount_ = instanceCount;\n        auto firstIndex_ = firstIndex;\n        auto baseVertex_ = baseVertex;\n        auto firstInstance_ = firstInstance;\n        self->APIDrawIndexed(indexCount_, instanceCount_, firstIndex_, baseVertex_, firstInstance_);\n    }\n\n    void NativeRenderBundleEncoderDrawIndexedIndirect(WGPURenderBundleEncoder cSelf, WGPUBuffer indirectBuffer, uint64_t indirectOffset) {\n        auto self = FromAPI(cSelf);\n\n        auto indirectBuffer_ = reinterpret_cast<BufferBase* >(indirectBuffer);\n        auto indirectOffset_ = indirectOffset;\n        self->APIDrawIndexedIndirect(indirectBuffer_, indirectOffset_);\n    }\n\n    void NativeRenderBundleEncoderDrawIndirect(WGPURenderBundleEncoder cSelf, WGPUBuffer indirectBuffer, uint64_t indirectOffset) {\n        auto self = FromAPI(cSelf);\n\n        auto indirectBuffer_ = reinterpret_cast<BufferBase* >(indirectBuffer);\n        auto indirectOffset_ = indirectOffset;\n        self->APIDrawIndirect(indirectBuffer_, indirectOffset_);\n    }\n\n    WGPURenderBundle NativeRenderBundleEncoderFinish(WGPURenderBundleEncoder cSelf, WGPURenderBundleDescriptor const * descriptor) {\n        auto self = FromAPI(cSelf);\n\n        auto descriptor_ = reinterpret_cast<RenderBundleDescriptor const * >(descriptor);\n        auto result =        self->APIFinish(descriptor_);\n        return ToAPI(result);\n    }\n\n    void NativeRenderBundleEncoderInsertDebugMarker(WGPURenderBundleEncoder cSelf, char const * markerLabel) {\n        auto self = FromAPI(cSelf);\n\n        auto markerLabel_ = reinterpret_cast<char const * >(markerLabel);\n        self->APIInsertDebugMarker(markerLabel_);\n    }\n\n    void NativeRenderBundleEncoderPopDebugGroup(WGPURenderBundleEncoder cSelf) {\n        auto self = FromAPI(cSelf);\n\n        self->APIPopDebugGroup();\n    }\n\n    void NativeRenderBundleEncoderPushDebugGroup(WGPURenderBundleEncoder cSelf, char const * groupLabel) {\n        auto self = FromAPI(cSelf);\n\n        auto groupLabel_ = reinterpret_cast<char const * >(groupLabel);\n        self->APIPushDebugGroup(groupLabel_);\n    }\n\n    void NativeRenderBundleEncoderSetBindGroup(WGPURenderBundleEncoder cSelf, uint32_t groupIndex, WGPUBindGroup group, uint32_t dynamicOffsetCount, uint32_t const * dynamicOffsets) {\n        auto self = FromAPI(cSelf);\n\n        auto groupIndex_ = groupIndex;\n        auto group_ = reinterpret_cast<BindGroupBase* >(group);\n        auto dynamicOffsetCount_ = dynamicOffsetCount;\n        auto dynamicOffsets_ = reinterpret_cast<uint32_t const * >(dynamicOffsets);\n        self->APISetBindGroup(groupIndex_, group_, dynamicOffsetCount_, dynamicOffsets_);\n    }\n\n    void NativeRenderBundleEncoderSetIndexBuffer(WGPURenderBundleEncoder cSelf, WGPUBuffer buffer, WGPUIndexFormat format, uint64_t offset, uint64_t size) {\n        auto self = FromAPI(cSelf);\n\n        auto buffer_ = reinterpret_cast<BufferBase* >(buffer);\n        auto format_ = static_cast<wgpu::IndexFormat>(format);\n        auto offset_ = offset;\n        auto size_ = size;\n        self->APISetIndexBuffer(buffer_, format_, offset_, size_);\n    }\n\n    void NativeRenderBundleEncoderSetLabel(WGPURenderBundleEncoder cSelf, char const * label) {\n        auto self = FromAPI(cSelf);\n\n        auto label_ = reinterpret_cast<char const * >(label);\n        self->APISetLabel(label_);\n    }\n\n    void NativeRenderBundleEncoderSetPipeline(WGPURenderBundleEncoder cSelf, WGPURenderPipeline pipeline) {\n        auto self = FromAPI(cSelf);\n\n        auto pipeline_ = reinterpret_cast<RenderPipelineBase* >(pipeline);\n        self->APISetPipeline(pipeline_);\n    }\n\n    void NativeRenderBundleEncoderSetVertexBuffer(WGPURenderBundleEncoder cSelf, uint32_t slot, WGPUBuffer buffer, uint64_t offset, uint64_t size) {\n        auto self = FromAPI(cSelf);\n\n        auto slot_ = slot;\n        auto buffer_ = reinterpret_cast<BufferBase* >(buffer);\n        auto offset_ = offset;\n        auto size_ = size;\n        self->APISetVertexBuffer(slot_, buffer_, offset_, size_);\n    }\n\n    void NativeRenderBundleEncoderReference(WGPURenderBundleEncoder cSelf) {\n        auto self = FromAPI(cSelf);\n\n        self->APIReference();\n    }\n\n    void NativeRenderBundleEncoderRelease(WGPURenderBundleEncoder cSelf) {\n        auto self = FromAPI(cSelf);\n\n        self->APIRelease();\n    }\n\n    void NativeRenderPassEncoderBeginOcclusionQuery(WGPURenderPassEncoder cSelf, uint32_t queryIndex) {\n        auto self = FromAPI(cSelf);\n\n        auto queryIndex_ = queryIndex;\n        self->APIBeginOcclusionQuery(queryIndex_);\n    }\n\n    void NativeRenderPassEncoderDraw(WGPURenderPassEncoder cSelf, uint32_t vertexCount, uint32_t instanceCount, uint32_t firstVertex, uint32_t firstInstance) {\n        auto self = FromAPI(cSelf);\n\n        auto vertexCount_ = vertexCount;\n        auto instanceCount_ = instanceCount;\n        auto firstVertex_ = firstVertex;\n        auto firstInstance_ = firstInstance;\n        self->APIDraw(vertexCount_, instanceCount_, firstVertex_, firstInstance_);\n    }\n\n    void NativeRenderPassEncoderDrawIndexed(WGPURenderPassEncoder cSelf, uint32_t indexCount, uint32_t instanceCount, uint32_t firstIndex, int32_t baseVertex, uint32_t firstInstance) {\n        auto self = FromAPI(cSelf);\n\n        auto indexCount_ = indexCount;\n        auto instanceCount_ = instanceCount;\n        auto firstIndex_ = firstIndex;\n        auto baseVertex_ = baseVertex;\n        auto firstInstance_ = firstInstance;\n        self->APIDrawIndexed(indexCount_, instanceCount_, firstIndex_, baseVertex_, firstInstance_);\n    }\n\n    void NativeRenderPassEncoderDrawIndexedIndirect(WGPURenderPassEncoder cSelf, WGPUBuffer indirectBuffer, uint64_t indirectOffset) {\n        auto self = FromAPI(cSelf);\n\n        auto indirectBuffer_ = reinterpret_cast<BufferBase* >(indirectBuffer);\n        auto indirectOffset_ = indirectOffset;\n        self->APIDrawIndexedIndirect(indirectBuffer_, indirectOffset_);\n    }\n\n    void NativeRenderPassEncoderDrawIndirect(WGPURenderPassEncoder cSelf, WGPUBuffer indirectBuffer, uint64_t indirectOffset) {\n        auto self = FromAPI(cSelf);\n\n        auto indirectBuffer_ = reinterpret_cast<BufferBase* >(indirectBuffer);\n        auto indirectOffset_ = indirectOffset;\n        self->APIDrawIndirect(indirectBuffer_, indirectOffset_);\n    }\n\n    void NativeRenderPassEncoderEnd(WGPURenderPassEncoder cSelf) {\n        auto self = FromAPI(cSelf);\n\n        self->APIEnd();\n    }\n\n    void NativeRenderPassEncoderEndOcclusionQuery(WGPURenderPassEncoder cSelf) {\n        auto self = FromAPI(cSelf);\n\n        self->APIEndOcclusionQuery();\n    }\n\n    void NativeRenderPassEncoderEndPass(WGPURenderPassEncoder cSelf) {\n        auto self = FromAPI(cSelf);\n\n        self->APIEndPass();\n    }\n\n    void NativeRenderPassEncoderExecuteBundles(WGPURenderPassEncoder cSelf, uint32_t bundlesCount, WGPURenderBundle const * bundles) {\n        auto self = FromAPI(cSelf);\n\n        auto bundlesCount_ = bundlesCount;\n        auto bundles_ = reinterpret_cast<RenderBundleBase* const * >(bundles);\n        self->APIExecuteBundles(bundlesCount_, bundles_);\n    }\n\n    void NativeRenderPassEncoderInsertDebugMarker(WGPURenderPassEncoder cSelf, char const * markerLabel) {\n        auto self = FromAPI(cSelf);\n\n        auto markerLabel_ = reinterpret_cast<char const * >(markerLabel);\n        self->APIInsertDebugMarker(markerLabel_);\n    }\n\n    void NativeRenderPassEncoderPopDebugGroup(WGPURenderPassEncoder cSelf) {\n        auto self = FromAPI(cSelf);\n\n        self->APIPopDebugGroup();\n    }\n\n    void NativeRenderPassEncoderPushDebugGroup(WGPURenderPassEncoder cSelf, char const * groupLabel) {\n        auto self = FromAPI(cSelf);\n\n        auto groupLabel_ = reinterpret_cast<char const * >(groupLabel);\n        self->APIPushDebugGroup(groupLabel_);\n    }\n\n    void NativeRenderPassEncoderSetBindGroup(WGPURenderPassEncoder cSelf, uint32_t groupIndex, WGPUBindGroup group, uint32_t dynamicOffsetCount, uint32_t const * dynamicOffsets) {\n        auto self = FromAPI(cSelf);\n\n        auto groupIndex_ = groupIndex;\n        auto group_ = reinterpret_cast<BindGroupBase* >(group);\n        auto dynamicOffsetCount_ = dynamicOffsetCount;\n        auto dynamicOffsets_ = reinterpret_cast<uint32_t const * >(dynamicOffsets);\n        self->APISetBindGroup(groupIndex_, group_, dynamicOffsetCount_, dynamicOffsets_);\n    }\n\n    void NativeRenderPassEncoderSetBlendConstant(WGPURenderPassEncoder cSelf, WGPUColor const * color) {\n        auto self = FromAPI(cSelf);\n\n        auto color_ = reinterpret_cast<Color const * >(color);\n        self->APISetBlendConstant(color_);\n    }\n\n    void NativeRenderPassEncoderSetIndexBuffer(WGPURenderPassEncoder cSelf, WGPUBuffer buffer, WGPUIndexFormat format, uint64_t offset, uint64_t size) {\n        auto self = FromAPI(cSelf);\n\n        auto buffer_ = reinterpret_cast<BufferBase* >(buffer);\n        auto format_ = static_cast<wgpu::IndexFormat>(format);\n        auto offset_ = offset;\n        auto size_ = size;\n        self->APISetIndexBuffer(buffer_, format_, offset_, size_);\n    }\n\n    void NativeRenderPassEncoderSetLabel(WGPURenderPassEncoder cSelf, char const * label) {\n        auto self = FromAPI(cSelf);\n\n        auto label_ = reinterpret_cast<char const * >(label);\n        self->APISetLabel(label_);\n    }\n\n    void NativeRenderPassEncoderSetPipeline(WGPURenderPassEncoder cSelf, WGPURenderPipeline pipeline) {\n        auto self = FromAPI(cSelf);\n\n        auto pipeline_ = reinterpret_cast<RenderPipelineBase* >(pipeline);\n        self->APISetPipeline(pipeline_);\n    }\n\n    void NativeRenderPassEncoderSetScissorRect(WGPURenderPassEncoder cSelf, uint32_t x, uint32_t y, uint32_t width, uint32_t height) {\n        auto self = FromAPI(cSelf);\n\n        auto x_ = x;\n        auto y_ = y;\n        auto width_ = width;\n        auto height_ = height;\n        self->APISetScissorRect(x_, y_, width_, height_);\n    }\n\n    void NativeRenderPassEncoderSetStencilReference(WGPURenderPassEncoder cSelf, uint32_t reference) {\n        auto self = FromAPI(cSelf);\n\n        auto reference_ = reference;\n        self->APISetStencilReference(reference_);\n    }\n\n    void NativeRenderPassEncoderSetVertexBuffer(WGPURenderPassEncoder cSelf, uint32_t slot, WGPUBuffer buffer, uint64_t offset, uint64_t size) {\n        auto self = FromAPI(cSelf);\n\n        auto slot_ = slot;\n        auto buffer_ = reinterpret_cast<BufferBase* >(buffer);\n        auto offset_ = offset;\n        auto size_ = size;\n        self->APISetVertexBuffer(slot_, buffer_, offset_, size_);\n    }\n\n    void NativeRenderPassEncoderSetViewport(WGPURenderPassEncoder cSelf, float x, float y, float width, float height, float minDepth, float maxDepth) {\n        auto self = FromAPI(cSelf);\n\n        auto x_ = x;\n        auto y_ = y;\n        auto width_ = width;\n        auto height_ = height;\n        auto minDepth_ = minDepth;\n        auto maxDepth_ = maxDepth;\n        self->APISetViewport(x_, y_, width_, height_, minDepth_, maxDepth_);\n    }\n\n    void NativeRenderPassEncoderWriteTimestamp(WGPURenderPassEncoder cSelf, WGPUQuerySet querySet, uint32_t queryIndex) {\n        auto self = FromAPI(cSelf);\n\n        auto querySet_ = reinterpret_cast<QuerySetBase* >(querySet);\n        auto queryIndex_ = queryIndex;\n        self->APIWriteTimestamp(querySet_, queryIndex_);\n    }\n\n    void NativeRenderPassEncoderReference(WGPURenderPassEncoder cSelf) {\n        auto self = FromAPI(cSelf);\n\n        self->APIReference();\n    }\n\n    void NativeRenderPassEncoderRelease(WGPURenderPassEncoder cSelf) {\n        auto self = FromAPI(cSelf);\n\n        self->APIRelease();\n    }\n\n    WGPUBindGroupLayout NativeRenderPipelineGetBindGroupLayout(WGPURenderPipeline cSelf, uint32_t groupIndex) {\n        auto self = FromAPI(cSelf);\n\n        auto groupIndex_ = groupIndex;\n        auto result =        self->APIGetBindGroupLayout(groupIndex_);\n        return ToAPI(result);\n    }\n\n    void NativeRenderPipelineSetLabel(WGPURenderPipeline cSelf, char const * label) {\n        auto self = FromAPI(cSelf);\n\n        auto label_ = reinterpret_cast<char const * >(label);\n        self->APISetLabel(label_);\n    }\n\n    void NativeRenderPipelineReference(WGPURenderPipeline cSelf) {\n        auto self = FromAPI(cSelf);\n\n        self->APIReference();\n    }\n\n    void NativeRenderPipelineRelease(WGPURenderPipeline cSelf) {\n        auto self = FromAPI(cSelf);\n\n        self->APIRelease();\n    }\n\n    void NativeSamplerSetLabel(WGPUSampler cSelf, char const * label) {\n        auto self = FromAPI(cSelf);\n\n        auto label_ = reinterpret_cast<char const * >(label);\n        self->APISetLabel(label_);\n    }\n\n    void NativeSamplerReference(WGPUSampler cSelf) {\n        auto self = FromAPI(cSelf);\n\n        self->APIReference();\n    }\n\n    void NativeSamplerRelease(WGPUSampler cSelf) {\n        auto self = FromAPI(cSelf);\n\n        self->APIRelease();\n    }\n\n    void NativeShaderModuleGetCompilationInfo(WGPUShaderModule cSelf, WGPUCompilationInfoCallback callback, void * userdata) {\n        auto self = FromAPI(cSelf);\n\n        auto callback_ = callback;\n        auto userdata_ = reinterpret_cast<void * >(userdata);\n        self->APIGetCompilationInfo(callback_, userdata_);\n    }\n\n    void NativeShaderModuleSetLabel(WGPUShaderModule cSelf, char const * label) {\n        auto self = FromAPI(cSelf);\n\n        auto label_ = reinterpret_cast<char const * >(label);\n        self->APISetLabel(label_);\n    }\n\n    void NativeShaderModuleReference(WGPUShaderModule cSelf) {\n        auto self = FromAPI(cSelf);\n\n        self->APIReference();\n    }\n\n    void NativeShaderModuleRelease(WGPUShaderModule cSelf) {\n        auto self = FromAPI(cSelf);\n\n        self->APIRelease();\n    }\n\n    void NativeSurfaceReference(WGPUSurface cSelf) {\n        auto self = FromAPI(cSelf);\n\n        self->APIReference();\n    }\n\n    void NativeSurfaceRelease(WGPUSurface cSelf) {\n        auto self = FromAPI(cSelf);\n\n        self->APIRelease();\n    }\n\n    void NativeSwapChainConfigure(WGPUSwapChain cSelf, WGPUTextureFormat format, WGPUTextureUsageFlags allowedUsage, uint32_t width, uint32_t height) {\n        auto self = FromAPI(cSelf);\n\n        auto format_ = static_cast<wgpu::TextureFormat>(format);\n        auto allowedUsage_ = static_cast<wgpu::TextureUsage>(allowedUsage);\n        auto width_ = width;\n        auto height_ = height;\n        self->APIConfigure(format_, allowedUsage_, width_, height_);\n    }\n\n    WGPUTextureView NativeSwapChainGetCurrentTextureView(WGPUSwapChain cSelf) {\n        auto self = FromAPI(cSelf);\n\n        auto result =        self->APIGetCurrentTextureView();\n        return ToAPI(result);\n    }\n\n    void NativeSwapChainPresent(WGPUSwapChain cSelf) {\n        auto self = FromAPI(cSelf);\n\n        self->APIPresent();\n    }\n\n    void NativeSwapChainReference(WGPUSwapChain cSelf) {\n        auto self = FromAPI(cSelf);\n\n        self->APIReference();\n    }\n\n    void NativeSwapChainRelease(WGPUSwapChain cSelf) {\n        auto self = FromAPI(cSelf);\n\n        self->APIRelease();\n    }\n\n    WGPUTextureView NativeTextureCreateView(WGPUTexture cSelf, WGPUTextureViewDescriptor const * descriptor) {\n        auto self = FromAPI(cSelf);\n\n        auto descriptor_ = reinterpret_cast<TextureViewDescriptor const * >(descriptor);\n        auto result =        self->APICreateView(descriptor_);\n        return ToAPI(result);\n    }\n\n    void NativeTextureDestroy(WGPUTexture cSelf) {\n        auto self = FromAPI(cSelf);\n\n        self->APIDestroy();\n    }\n\n    void NativeTextureSetLabel(WGPUTexture cSelf, char const * label) {\n        auto self = FromAPI(cSelf);\n\n        auto label_ = reinterpret_cast<char const * >(label);\n        self->APISetLabel(label_);\n    }\n\n    void NativeTextureReference(WGPUTexture cSelf) {\n        auto self = FromAPI(cSelf);\n\n        self->APIReference();\n    }\n\n    void NativeTextureRelease(WGPUTexture cSelf) {\n        auto self = FromAPI(cSelf);\n\n        self->APIRelease();\n    }\n\n    void NativeTextureViewSetLabel(WGPUTextureView cSelf, char const * label) {\n        auto self = FromAPI(cSelf);\n\n        auto label_ = reinterpret_cast<char const * >(label);\n        self->APISetLabel(label_);\n    }\n\n    void NativeTextureViewReference(WGPUTextureView cSelf) {\n        auto self = FromAPI(cSelf);\n\n        self->APIReference();\n    }\n\n    void NativeTextureViewRelease(WGPUTextureView cSelf) {\n        auto self = FromAPI(cSelf);\n\n        self->APIRelease();\n    }\n\n    namespace {\n\n        struct ProcEntry {\n            WGPUProc proc;\n            const char* name;\n        };\n        static const ProcEntry sProcMap[] = {\n            { reinterpret_cast<WGPUProc>(NativeAdapterCreateDevice), \"wgpuAdapterCreateDevice\" },\n            { reinterpret_cast<WGPUProc>(NativeAdapterEnumerateFeatures), \"wgpuAdapterEnumerateFeatures\" },\n            { reinterpret_cast<WGPUProc>(NativeAdapterGetLimits), \"wgpuAdapterGetLimits\" },\n            { reinterpret_cast<WGPUProc>(NativeAdapterGetProperties), \"wgpuAdapterGetProperties\" },\n            { reinterpret_cast<WGPUProc>(NativeAdapterHasFeature), \"wgpuAdapterHasFeature\" },\n            { reinterpret_cast<WGPUProc>(NativeAdapterReference), \"wgpuAdapterReference\" },\n            { reinterpret_cast<WGPUProc>(NativeAdapterRelease), \"wgpuAdapterRelease\" },\n            { reinterpret_cast<WGPUProc>(NativeAdapterRequestDevice), \"wgpuAdapterRequestDevice\" },\n            { reinterpret_cast<WGPUProc>(NativeBindGroupLayoutReference), \"wgpuBindGroupLayoutReference\" },\n            { reinterpret_cast<WGPUProc>(NativeBindGroupLayoutRelease), \"wgpuBindGroupLayoutRelease\" },\n            { reinterpret_cast<WGPUProc>(NativeBindGroupLayoutSetLabel), \"wgpuBindGroupLayoutSetLabel\" },\n            { reinterpret_cast<WGPUProc>(NativeBindGroupReference), \"wgpuBindGroupReference\" },\n            { reinterpret_cast<WGPUProc>(NativeBindGroupRelease), \"wgpuBindGroupRelease\" },\n            { reinterpret_cast<WGPUProc>(NativeBindGroupSetLabel), \"wgpuBindGroupSetLabel\" },\n            { reinterpret_cast<WGPUProc>(NativeBufferDestroy), \"wgpuBufferDestroy\" },\n            { reinterpret_cast<WGPUProc>(NativeBufferGetConstMappedRange), \"wgpuBufferGetConstMappedRange\" },\n            { reinterpret_cast<WGPUProc>(NativeBufferGetMappedRange), \"wgpuBufferGetMappedRange\" },\n            { reinterpret_cast<WGPUProc>(NativeBufferMapAsync), \"wgpuBufferMapAsync\" },\n            { reinterpret_cast<WGPUProc>(NativeBufferReference), \"wgpuBufferReference\" },\n            { reinterpret_cast<WGPUProc>(NativeBufferRelease), \"wgpuBufferRelease\" },\n            { reinterpret_cast<WGPUProc>(NativeBufferSetLabel), \"wgpuBufferSetLabel\" },\n            { reinterpret_cast<WGPUProc>(NativeBufferUnmap), \"wgpuBufferUnmap\" },\n            { reinterpret_cast<WGPUProc>(NativeCommandBufferReference), \"wgpuCommandBufferReference\" },\n            { reinterpret_cast<WGPUProc>(NativeCommandBufferRelease), \"wgpuCommandBufferRelease\" },\n            { reinterpret_cast<WGPUProc>(NativeCommandBufferSetLabel), \"wgpuCommandBufferSetLabel\" },\n            { reinterpret_cast<WGPUProc>(NativeCommandEncoderBeginComputePass), \"wgpuCommandEncoderBeginComputePass\" },\n            { reinterpret_cast<WGPUProc>(NativeCommandEncoderBeginRenderPass), \"wgpuCommandEncoderBeginRenderPass\" },\n            { reinterpret_cast<WGPUProc>(NativeCommandEncoderClearBuffer), \"wgpuCommandEncoderClearBuffer\" },\n            { reinterpret_cast<WGPUProc>(NativeCommandEncoderCopyBufferToBuffer), \"wgpuCommandEncoderCopyBufferToBuffer\" },\n            { reinterpret_cast<WGPUProc>(NativeCommandEncoderCopyBufferToTexture), \"wgpuCommandEncoderCopyBufferToTexture\" },\n            { reinterpret_cast<WGPUProc>(NativeCommandEncoderCopyTextureToBuffer), \"wgpuCommandEncoderCopyTextureToBuffer\" },\n            { reinterpret_cast<WGPUProc>(NativeCommandEncoderCopyTextureToTexture), \"wgpuCommandEncoderCopyTextureToTexture\" },\n            { reinterpret_cast<WGPUProc>(NativeCommandEncoderCopyTextureToTextureInternal), \"wgpuCommandEncoderCopyTextureToTextureInternal\" },\n            { reinterpret_cast<WGPUProc>(NativeCommandEncoderFinish), \"wgpuCommandEncoderFinish\" },\n            { reinterpret_cast<WGPUProc>(NativeCommandEncoderInjectValidationError), \"wgpuCommandEncoderInjectValidationError\" },\n            { reinterpret_cast<WGPUProc>(NativeCommandEncoderInsertDebugMarker), \"wgpuCommandEncoderInsertDebugMarker\" },\n            { reinterpret_cast<WGPUProc>(NativeCommandEncoderPopDebugGroup), \"wgpuCommandEncoderPopDebugGroup\" },\n            { reinterpret_cast<WGPUProc>(NativeCommandEncoderPushDebugGroup), \"wgpuCommandEncoderPushDebugGroup\" },\n            { reinterpret_cast<WGPUProc>(NativeCommandEncoderReference), \"wgpuCommandEncoderReference\" },\n            { reinterpret_cast<WGPUProc>(NativeCommandEncoderRelease), \"wgpuCommandEncoderRelease\" },\n            { reinterpret_cast<WGPUProc>(NativeCommandEncoderResolveQuerySet), \"wgpuCommandEncoderResolveQuerySet\" },\n            { reinterpret_cast<WGPUProc>(NativeCommandEncoderSetLabel), \"wgpuCommandEncoderSetLabel\" },\n            { reinterpret_cast<WGPUProc>(NativeCommandEncoderWriteBuffer), \"wgpuCommandEncoderWriteBuffer\" },\n            { reinterpret_cast<WGPUProc>(NativeCommandEncoderWriteTimestamp), \"wgpuCommandEncoderWriteTimestamp\" },\n            { reinterpret_cast<WGPUProc>(NativeComputePassEncoderDispatch), \"wgpuComputePassEncoderDispatch\" },\n            { reinterpret_cast<WGPUProc>(NativeComputePassEncoderDispatchIndirect), \"wgpuComputePassEncoderDispatchIndirect\" },\n            { reinterpret_cast<WGPUProc>(NativeComputePassEncoderEnd), \"wgpuComputePassEncoderEnd\" },\n            { reinterpret_cast<WGPUProc>(NativeComputePassEncoderEndPass), \"wgpuComputePassEncoderEndPass\" },\n            { reinterpret_cast<WGPUProc>(NativeComputePassEncoderInsertDebugMarker), \"wgpuComputePassEncoderInsertDebugMarker\" },\n            { reinterpret_cast<WGPUProc>(NativeComputePassEncoderPopDebugGroup), \"wgpuComputePassEncoderPopDebugGroup\" },\n            { reinterpret_cast<WGPUProc>(NativeComputePassEncoderPushDebugGroup), \"wgpuComputePassEncoderPushDebugGroup\" },\n            { reinterpret_cast<WGPUProc>(NativeComputePassEncoderReference), \"wgpuComputePassEncoderReference\" },\n            { reinterpret_cast<WGPUProc>(NativeComputePassEncoderRelease), \"wgpuComputePassEncoderRelease\" },\n            { reinterpret_cast<WGPUProc>(NativeComputePassEncoderSetBindGroup), \"wgpuComputePassEncoderSetBindGroup\" },\n            { reinterpret_cast<WGPUProc>(NativeComputePassEncoderSetLabel), \"wgpuComputePassEncoderSetLabel\" },\n            { reinterpret_cast<WGPUProc>(NativeComputePassEncoderSetPipeline), \"wgpuComputePassEncoderSetPipeline\" },\n            { reinterpret_cast<WGPUProc>(NativeComputePassEncoderWriteTimestamp), \"wgpuComputePassEncoderWriteTimestamp\" },\n            { reinterpret_cast<WGPUProc>(NativeComputePipelineGetBindGroupLayout), \"wgpuComputePipelineGetBindGroupLayout\" },\n            { reinterpret_cast<WGPUProc>(NativeComputePipelineReference), \"wgpuComputePipelineReference\" },\n            { reinterpret_cast<WGPUProc>(NativeComputePipelineRelease), \"wgpuComputePipelineRelease\" },\n            { reinterpret_cast<WGPUProc>(NativeComputePipelineSetLabel), \"wgpuComputePipelineSetLabel\" },\n            { reinterpret_cast<WGPUProc>(NativeDeviceCreateBindGroup), \"wgpuDeviceCreateBindGroup\" },\n            { reinterpret_cast<WGPUProc>(NativeDeviceCreateBindGroupLayout), \"wgpuDeviceCreateBindGroupLayout\" },\n            { reinterpret_cast<WGPUProc>(NativeDeviceCreateBuffer), \"wgpuDeviceCreateBuffer\" },\n            { reinterpret_cast<WGPUProc>(NativeDeviceCreateCommandEncoder), \"wgpuDeviceCreateCommandEncoder\" },\n            { reinterpret_cast<WGPUProc>(NativeDeviceCreateComputePipeline), \"wgpuDeviceCreateComputePipeline\" },\n            { reinterpret_cast<WGPUProc>(NativeDeviceCreateComputePipelineAsync), \"wgpuDeviceCreateComputePipelineAsync\" },\n            { reinterpret_cast<WGPUProc>(NativeDeviceCreateErrorBuffer), \"wgpuDeviceCreateErrorBuffer\" },\n            { reinterpret_cast<WGPUProc>(NativeDeviceCreateExternalTexture), \"wgpuDeviceCreateExternalTexture\" },\n            { reinterpret_cast<WGPUProc>(NativeDeviceCreatePipelineLayout), \"wgpuDeviceCreatePipelineLayout\" },\n            { reinterpret_cast<WGPUProc>(NativeDeviceCreateQuerySet), \"wgpuDeviceCreateQuerySet\" },\n            { reinterpret_cast<WGPUProc>(NativeDeviceCreateRenderBundleEncoder), \"wgpuDeviceCreateRenderBundleEncoder\" },\n            { reinterpret_cast<WGPUProc>(NativeDeviceCreateRenderPipeline), \"wgpuDeviceCreateRenderPipeline\" },\n            { reinterpret_cast<WGPUProc>(NativeDeviceCreateRenderPipelineAsync), \"wgpuDeviceCreateRenderPipelineAsync\" },\n            { reinterpret_cast<WGPUProc>(NativeDeviceCreateSampler), \"wgpuDeviceCreateSampler\" },\n            { reinterpret_cast<WGPUProc>(NativeDeviceCreateShaderModule), \"wgpuDeviceCreateShaderModule\" },\n            { reinterpret_cast<WGPUProc>(NativeDeviceCreateSwapChain), \"wgpuDeviceCreateSwapChain\" },\n            { reinterpret_cast<WGPUProc>(NativeDeviceCreateTexture), \"wgpuDeviceCreateTexture\" },\n            { reinterpret_cast<WGPUProc>(NativeDeviceDestroy), \"wgpuDeviceDestroy\" },\n            { reinterpret_cast<WGPUProc>(NativeDeviceEnumerateFeatures), \"wgpuDeviceEnumerateFeatures\" },\n            { reinterpret_cast<WGPUProc>(NativeDeviceGetLimits), \"wgpuDeviceGetLimits\" },\n            { reinterpret_cast<WGPUProc>(NativeDeviceGetQueue), \"wgpuDeviceGetQueue\" },\n            { reinterpret_cast<WGPUProc>(NativeDeviceHasFeature), \"wgpuDeviceHasFeature\" },\n            { reinterpret_cast<WGPUProc>(NativeDeviceInjectError), \"wgpuDeviceInjectError\" },\n            { reinterpret_cast<WGPUProc>(NativeDeviceLoseForTesting), \"wgpuDeviceLoseForTesting\" },\n            { reinterpret_cast<WGPUProc>(NativeDevicePopErrorScope), \"wgpuDevicePopErrorScope\" },\n            { reinterpret_cast<WGPUProc>(NativeDevicePushErrorScope), \"wgpuDevicePushErrorScope\" },\n            { reinterpret_cast<WGPUProc>(NativeDeviceReference), \"wgpuDeviceReference\" },\n            { reinterpret_cast<WGPUProc>(NativeDeviceRelease), \"wgpuDeviceRelease\" },\n            { reinterpret_cast<WGPUProc>(NativeDeviceSetDeviceLostCallback), \"wgpuDeviceSetDeviceLostCallback\" },\n            { reinterpret_cast<WGPUProc>(NativeDeviceSetLoggingCallback), \"wgpuDeviceSetLoggingCallback\" },\n            { reinterpret_cast<WGPUProc>(NativeDeviceSetUncapturedErrorCallback), \"wgpuDeviceSetUncapturedErrorCallback\" },\n            { reinterpret_cast<WGPUProc>(NativeDeviceTick), \"wgpuDeviceTick\" },\n            { reinterpret_cast<WGPUProc>(NativeExternalTextureDestroy), \"wgpuExternalTextureDestroy\" },\n            { reinterpret_cast<WGPUProc>(NativeExternalTextureReference), \"wgpuExternalTextureReference\" },\n            { reinterpret_cast<WGPUProc>(NativeExternalTextureRelease), \"wgpuExternalTextureRelease\" },\n            { reinterpret_cast<WGPUProc>(NativeExternalTextureSetLabel), \"wgpuExternalTextureSetLabel\" },\n            { reinterpret_cast<WGPUProc>(NativeInstanceCreateSurface), \"wgpuInstanceCreateSurface\" },\n            { reinterpret_cast<WGPUProc>(NativeInstanceReference), \"wgpuInstanceReference\" },\n            { reinterpret_cast<WGPUProc>(NativeInstanceRelease), \"wgpuInstanceRelease\" },\n            { reinterpret_cast<WGPUProc>(NativeInstanceRequestAdapter), \"wgpuInstanceRequestAdapter\" },\n            { reinterpret_cast<WGPUProc>(NativePipelineLayoutReference), \"wgpuPipelineLayoutReference\" },\n            { reinterpret_cast<WGPUProc>(NativePipelineLayoutRelease), \"wgpuPipelineLayoutRelease\" },\n            { reinterpret_cast<WGPUProc>(NativePipelineLayoutSetLabel), \"wgpuPipelineLayoutSetLabel\" },\n            { reinterpret_cast<WGPUProc>(NativeQuerySetDestroy), \"wgpuQuerySetDestroy\" },\n            { reinterpret_cast<WGPUProc>(NativeQuerySetReference), \"wgpuQuerySetReference\" },\n            { reinterpret_cast<WGPUProc>(NativeQuerySetRelease), \"wgpuQuerySetRelease\" },\n            { reinterpret_cast<WGPUProc>(NativeQuerySetSetLabel), \"wgpuQuerySetSetLabel\" },\n            { reinterpret_cast<WGPUProc>(NativeQueueCopyTextureForBrowser), \"wgpuQueueCopyTextureForBrowser\" },\n            { reinterpret_cast<WGPUProc>(NativeQueueOnSubmittedWorkDone), \"wgpuQueueOnSubmittedWorkDone\" },\n            { reinterpret_cast<WGPUProc>(NativeQueueReference), \"wgpuQueueReference\" },\n            { reinterpret_cast<WGPUProc>(NativeQueueRelease), \"wgpuQueueRelease\" },\n            { reinterpret_cast<WGPUProc>(NativeQueueSubmit), \"wgpuQueueSubmit\" },\n            { reinterpret_cast<WGPUProc>(NativeQueueWriteBuffer), \"wgpuQueueWriteBuffer\" },\n            { reinterpret_cast<WGPUProc>(NativeQueueWriteTexture), \"wgpuQueueWriteTexture\" },\n            { reinterpret_cast<WGPUProc>(NativeRenderBundleEncoderDraw), \"wgpuRenderBundleEncoderDraw\" },\n            { reinterpret_cast<WGPUProc>(NativeRenderBundleEncoderDrawIndexed), \"wgpuRenderBundleEncoderDrawIndexed\" },\n            { reinterpret_cast<WGPUProc>(NativeRenderBundleEncoderDrawIndexedIndirect), \"wgpuRenderBundleEncoderDrawIndexedIndirect\" },\n            { reinterpret_cast<WGPUProc>(NativeRenderBundleEncoderDrawIndirect), \"wgpuRenderBundleEncoderDrawIndirect\" },\n            { reinterpret_cast<WGPUProc>(NativeRenderBundleEncoderFinish), \"wgpuRenderBundleEncoderFinish\" },\n            { reinterpret_cast<WGPUProc>(NativeRenderBundleEncoderInsertDebugMarker), \"wgpuRenderBundleEncoderInsertDebugMarker\" },\n            { reinterpret_cast<WGPUProc>(NativeRenderBundleEncoderPopDebugGroup), \"wgpuRenderBundleEncoderPopDebugGroup\" },\n            { reinterpret_cast<WGPUProc>(NativeRenderBundleEncoderPushDebugGroup), \"wgpuRenderBundleEncoderPushDebugGroup\" },\n            { reinterpret_cast<WGPUProc>(NativeRenderBundleEncoderReference), \"wgpuRenderBundleEncoderReference\" },\n            { reinterpret_cast<WGPUProc>(NativeRenderBundleEncoderRelease), \"wgpuRenderBundleEncoderRelease\" },\n            { reinterpret_cast<WGPUProc>(NativeRenderBundleEncoderSetBindGroup), \"wgpuRenderBundleEncoderSetBindGroup\" },\n            { reinterpret_cast<WGPUProc>(NativeRenderBundleEncoderSetIndexBuffer), \"wgpuRenderBundleEncoderSetIndexBuffer\" },\n            { reinterpret_cast<WGPUProc>(NativeRenderBundleEncoderSetLabel), \"wgpuRenderBundleEncoderSetLabel\" },\n            { reinterpret_cast<WGPUProc>(NativeRenderBundleEncoderSetPipeline), \"wgpuRenderBundleEncoderSetPipeline\" },\n            { reinterpret_cast<WGPUProc>(NativeRenderBundleEncoderSetVertexBuffer), \"wgpuRenderBundleEncoderSetVertexBuffer\" },\n            { reinterpret_cast<WGPUProc>(NativeRenderBundleReference), \"wgpuRenderBundleReference\" },\n            { reinterpret_cast<WGPUProc>(NativeRenderBundleRelease), \"wgpuRenderBundleRelease\" },\n            { reinterpret_cast<WGPUProc>(NativeRenderPassEncoderBeginOcclusionQuery), \"wgpuRenderPassEncoderBeginOcclusionQuery\" },\n            { reinterpret_cast<WGPUProc>(NativeRenderPassEncoderDraw), \"wgpuRenderPassEncoderDraw\" },\n            { reinterpret_cast<WGPUProc>(NativeRenderPassEncoderDrawIndexed), \"wgpuRenderPassEncoderDrawIndexed\" },\n            { reinterpret_cast<WGPUProc>(NativeRenderPassEncoderDrawIndexedIndirect), \"wgpuRenderPassEncoderDrawIndexedIndirect\" },\n            { reinterpret_cast<WGPUProc>(NativeRenderPassEncoderDrawIndirect), \"wgpuRenderPassEncoderDrawIndirect\" },\n            { reinterpret_cast<WGPUProc>(NativeRenderPassEncoderEnd), \"wgpuRenderPassEncoderEnd\" },\n            { reinterpret_cast<WGPUProc>(NativeRenderPassEncoderEndOcclusionQuery), \"wgpuRenderPassEncoderEndOcclusionQuery\" },\n            { reinterpret_cast<WGPUProc>(NativeRenderPassEncoderEndPass), \"wgpuRenderPassEncoderEndPass\" },\n            { reinterpret_cast<WGPUProc>(NativeRenderPassEncoderExecuteBundles), \"wgpuRenderPassEncoderExecuteBundles\" },\n            { reinterpret_cast<WGPUProc>(NativeRenderPassEncoderInsertDebugMarker), \"wgpuRenderPassEncoderInsertDebugMarker\" },\n            { reinterpret_cast<WGPUProc>(NativeRenderPassEncoderPopDebugGroup), \"wgpuRenderPassEncoderPopDebugGroup\" },\n            { reinterpret_cast<WGPUProc>(NativeRenderPassEncoderPushDebugGroup), \"wgpuRenderPassEncoderPushDebugGroup\" },\n            { reinterpret_cast<WGPUProc>(NativeRenderPassEncoderReference), \"wgpuRenderPassEncoderReference\" },\n            { reinterpret_cast<WGPUProc>(NativeRenderPassEncoderRelease), \"wgpuRenderPassEncoderRelease\" },\n            { reinterpret_cast<WGPUProc>(NativeRenderPassEncoderSetBindGroup), \"wgpuRenderPassEncoderSetBindGroup\" },\n            { reinterpret_cast<WGPUProc>(NativeRenderPassEncoderSetBlendConstant), \"wgpuRenderPassEncoderSetBlendConstant\" },\n            { reinterpret_cast<WGPUProc>(NativeRenderPassEncoderSetIndexBuffer), \"wgpuRenderPassEncoderSetIndexBuffer\" },\n            { reinterpret_cast<WGPUProc>(NativeRenderPassEncoderSetLabel), \"wgpuRenderPassEncoderSetLabel\" },\n            { reinterpret_cast<WGPUProc>(NativeRenderPassEncoderSetPipeline), \"wgpuRenderPassEncoderSetPipeline\" },\n            { reinterpret_cast<WGPUProc>(NativeRenderPassEncoderSetScissorRect), \"wgpuRenderPassEncoderSetScissorRect\" },\n            { reinterpret_cast<WGPUProc>(NativeRenderPassEncoderSetStencilReference), \"wgpuRenderPassEncoderSetStencilReference\" },\n            { reinterpret_cast<WGPUProc>(NativeRenderPassEncoderSetVertexBuffer), \"wgpuRenderPassEncoderSetVertexBuffer\" },\n            { reinterpret_cast<WGPUProc>(NativeRenderPassEncoderSetViewport), \"wgpuRenderPassEncoderSetViewport\" },\n            { reinterpret_cast<WGPUProc>(NativeRenderPassEncoderWriteTimestamp), \"wgpuRenderPassEncoderWriteTimestamp\" },\n            { reinterpret_cast<WGPUProc>(NativeRenderPipelineGetBindGroupLayout), \"wgpuRenderPipelineGetBindGroupLayout\" },\n            { reinterpret_cast<WGPUProc>(NativeRenderPipelineReference), \"wgpuRenderPipelineReference\" },\n            { reinterpret_cast<WGPUProc>(NativeRenderPipelineRelease), \"wgpuRenderPipelineRelease\" },\n            { reinterpret_cast<WGPUProc>(NativeRenderPipelineSetLabel), \"wgpuRenderPipelineSetLabel\" },\n            { reinterpret_cast<WGPUProc>(NativeSamplerReference), \"wgpuSamplerReference\" },\n            { reinterpret_cast<WGPUProc>(NativeSamplerRelease), \"wgpuSamplerRelease\" },\n            { reinterpret_cast<WGPUProc>(NativeSamplerSetLabel), \"wgpuSamplerSetLabel\" },\n            { reinterpret_cast<WGPUProc>(NativeShaderModuleGetCompilationInfo), \"wgpuShaderModuleGetCompilationInfo\" },\n            { reinterpret_cast<WGPUProc>(NativeShaderModuleReference), \"wgpuShaderModuleReference\" },\n            { reinterpret_cast<WGPUProc>(NativeShaderModuleRelease), \"wgpuShaderModuleRelease\" },\n            { reinterpret_cast<WGPUProc>(NativeShaderModuleSetLabel), \"wgpuShaderModuleSetLabel\" },\n            { reinterpret_cast<WGPUProc>(NativeSurfaceReference), \"wgpuSurfaceReference\" },\n            { reinterpret_cast<WGPUProc>(NativeSurfaceRelease), \"wgpuSurfaceRelease\" },\n            { reinterpret_cast<WGPUProc>(NativeSwapChainConfigure), \"wgpuSwapChainConfigure\" },\n            { reinterpret_cast<WGPUProc>(NativeSwapChainGetCurrentTextureView), \"wgpuSwapChainGetCurrentTextureView\" },\n            { reinterpret_cast<WGPUProc>(NativeSwapChainPresent), \"wgpuSwapChainPresent\" },\n            { reinterpret_cast<WGPUProc>(NativeSwapChainReference), \"wgpuSwapChainReference\" },\n            { reinterpret_cast<WGPUProc>(NativeSwapChainRelease), \"wgpuSwapChainRelease\" },\n            { reinterpret_cast<WGPUProc>(NativeTextureCreateView), \"wgpuTextureCreateView\" },\n            { reinterpret_cast<WGPUProc>(NativeTextureDestroy), \"wgpuTextureDestroy\" },\n            { reinterpret_cast<WGPUProc>(NativeTextureReference), \"wgpuTextureReference\" },\n            { reinterpret_cast<WGPUProc>(NativeTextureRelease), \"wgpuTextureRelease\" },\n            { reinterpret_cast<WGPUProc>(NativeTextureSetLabel), \"wgpuTextureSetLabel\" },\n            { reinterpret_cast<WGPUProc>(NativeTextureViewReference), \"wgpuTextureViewReference\" },\n            { reinterpret_cast<WGPUProc>(NativeTextureViewRelease), \"wgpuTextureViewRelease\" },\n            { reinterpret_cast<WGPUProc>(NativeTextureViewSetLabel), \"wgpuTextureViewSetLabel\" },\n        };\n        static constexpr size_t sProcMapSize = sizeof(sProcMap) / sizeof(sProcMap[0]);\n\n    }  // anonymous namespace\n\n    WGPUInstance NativeCreateInstance(WGPUInstanceDescriptor const * descriptor) {\n        return ToAPI(InstanceBase::Create(FromAPI(descriptor)));\n    }\n\n    WGPUProc NativeGetProcAddress(WGPUDevice device, char const * procName) {\n        if (procName == nullptr) {\n            return nullptr;\n        }\n\n        const ProcEntry* entry = std::lower_bound(&sProcMap[0], &sProcMap[sProcMapSize], procName,\n            [](const ProcEntry &a, const char *b) -> bool {\n                return strcmp(a.name, b) < 0;\n            }\n        );\n\n        if (entry != &sProcMap[sProcMapSize] && strcmp(entry->name, procName) == 0) {\n            return entry->proc;\n        }\n\n        // Special case the free-standing functions of the API.\n        // TODO(dawn:1238) Checking string one by one is slow, it needs to be optimized.\n        if (strcmp(procName, \"wgpuCreateInstance\") == 0) {\n            return reinterpret_cast<WGPUProc>(NativeCreateInstance);\n        }\n\n        if (strcmp(procName, \"wgpuGetProcAddress\") == 0) {\n            return reinterpret_cast<WGPUProc>(NativeGetProcAddress);\n        }\n\n        return nullptr;\n    }\n\n\n    std::vector<const char*> GetProcMapNamesForTestingInternal() {\n        std::vector<const char*> result;\n        result.reserve(sProcMapSize);\n        for (const ProcEntry& entry : sProcMap) {\n            result.push_back(entry.name);\n        }\n        return result;\n    }\n\n    static DawnProcTable gProcTable = {\n        NativeCreateInstance,\n        NativeGetProcAddress,\n        NativeAdapterCreateDevice,\n        NativeAdapterEnumerateFeatures,\n        NativeAdapterGetLimits,\n        NativeAdapterGetProperties,\n        NativeAdapterHasFeature,\n        NativeAdapterRequestDevice,\n        NativeAdapterReference,\n        NativeAdapterRelease,\n        NativeBindGroupSetLabel,\n        NativeBindGroupReference,\n        NativeBindGroupRelease,\n        NativeBindGroupLayoutSetLabel,\n        NativeBindGroupLayoutReference,\n        NativeBindGroupLayoutRelease,\n        NativeBufferDestroy,\n        NativeBufferGetConstMappedRange,\n        NativeBufferGetMappedRange,\n        NativeBufferMapAsync,\n        NativeBufferSetLabel,\n        NativeBufferUnmap,\n        NativeBufferReference,\n        NativeBufferRelease,\n        NativeCommandBufferSetLabel,\n        NativeCommandBufferReference,\n        NativeCommandBufferRelease,\n        NativeCommandEncoderBeginComputePass,\n        NativeCommandEncoderBeginRenderPass,\n        NativeCommandEncoderClearBuffer,\n        NativeCommandEncoderCopyBufferToBuffer,\n        NativeCommandEncoderCopyBufferToTexture,\n        NativeCommandEncoderCopyTextureToBuffer,\n        NativeCommandEncoderCopyTextureToTexture,\n        NativeCommandEncoderCopyTextureToTextureInternal,\n        NativeCommandEncoderFinish,\n        NativeCommandEncoderInjectValidationError,\n        NativeCommandEncoderInsertDebugMarker,\n        NativeCommandEncoderPopDebugGroup,\n        NativeCommandEncoderPushDebugGroup,\n        NativeCommandEncoderResolveQuerySet,\n        NativeCommandEncoderSetLabel,\n        NativeCommandEncoderWriteBuffer,\n        NativeCommandEncoderWriteTimestamp,\n        NativeCommandEncoderReference,\n        NativeCommandEncoderRelease,\n        NativeComputePassEncoderDispatch,\n        NativeComputePassEncoderDispatchIndirect,\n        NativeComputePassEncoderEnd,\n        NativeComputePassEncoderEndPass,\n        NativeComputePassEncoderInsertDebugMarker,\n        NativeComputePassEncoderPopDebugGroup,\n        NativeComputePassEncoderPushDebugGroup,\n        NativeComputePassEncoderSetBindGroup,\n        NativeComputePassEncoderSetLabel,\n        NativeComputePassEncoderSetPipeline,\n        NativeComputePassEncoderWriteTimestamp,\n        NativeComputePassEncoderReference,\n        NativeComputePassEncoderRelease,\n        NativeComputePipelineGetBindGroupLayout,\n        NativeComputePipelineSetLabel,\n        NativeComputePipelineReference,\n        NativeComputePipelineRelease,\n        NativeDeviceCreateBindGroup,\n        NativeDeviceCreateBindGroupLayout,\n        NativeDeviceCreateBuffer,\n        NativeDeviceCreateCommandEncoder,\n        NativeDeviceCreateComputePipeline,\n        NativeDeviceCreateComputePipelineAsync,\n        NativeDeviceCreateErrorBuffer,\n        NativeDeviceCreateExternalTexture,\n        NativeDeviceCreatePipelineLayout,\n        NativeDeviceCreateQuerySet,\n        NativeDeviceCreateRenderBundleEncoder,\n        NativeDeviceCreateRenderPipeline,\n        NativeDeviceCreateRenderPipelineAsync,\n        NativeDeviceCreateSampler,\n        NativeDeviceCreateShaderModule,\n        NativeDeviceCreateSwapChain,\n        NativeDeviceCreateTexture,\n        NativeDeviceDestroy,\n        NativeDeviceEnumerateFeatures,\n        NativeDeviceGetLimits,\n        NativeDeviceGetQueue,\n        NativeDeviceHasFeature,\n        NativeDeviceInjectError,\n        NativeDeviceLoseForTesting,\n        NativeDevicePopErrorScope,\n        NativeDevicePushErrorScope,\n        NativeDeviceSetDeviceLostCallback,\n        NativeDeviceSetLoggingCallback,\n        NativeDeviceSetUncapturedErrorCallback,\n        NativeDeviceTick,\n        NativeDeviceReference,\n        NativeDeviceRelease,\n        NativeExternalTextureDestroy,\n        NativeExternalTextureSetLabel,\n        NativeExternalTextureReference,\n        NativeExternalTextureRelease,\n        NativeInstanceCreateSurface,\n        NativeInstanceRequestAdapter,\n        NativeInstanceReference,\n        NativeInstanceRelease,\n        NativePipelineLayoutSetLabel,\n        NativePipelineLayoutReference,\n        NativePipelineLayoutRelease,\n        NativeQuerySetDestroy,\n        NativeQuerySetSetLabel,\n        NativeQuerySetReference,\n        NativeQuerySetRelease,\n        NativeQueueCopyTextureForBrowser,\n        NativeQueueOnSubmittedWorkDone,\n        NativeQueueSubmit,\n        NativeQueueWriteBuffer,\n        NativeQueueWriteTexture,\n        NativeQueueReference,\n        NativeQueueRelease,\n        NativeRenderBundleReference,\n        NativeRenderBundleRelease,\n        NativeRenderBundleEncoderDraw,\n        NativeRenderBundleEncoderDrawIndexed,\n        NativeRenderBundleEncoderDrawIndexedIndirect,\n        NativeRenderBundleEncoderDrawIndirect,\n        NativeRenderBundleEncoderFinish,\n        NativeRenderBundleEncoderInsertDebugMarker,\n        NativeRenderBundleEncoderPopDebugGroup,\n        NativeRenderBundleEncoderPushDebugGroup,\n        NativeRenderBundleEncoderSetBindGroup,\n        NativeRenderBundleEncoderSetIndexBuffer,\n        NativeRenderBundleEncoderSetLabel,\n        NativeRenderBundleEncoderSetPipeline,\n        NativeRenderBundleEncoderSetVertexBuffer,\n        NativeRenderBundleEncoderReference,\n        NativeRenderBundleEncoderRelease,\n        NativeRenderPassEncoderBeginOcclusionQuery,\n        NativeRenderPassEncoderDraw,\n        NativeRenderPassEncoderDrawIndexed,\n        NativeRenderPassEncoderDrawIndexedIndirect,\n        NativeRenderPassEncoderDrawIndirect,\n        NativeRenderPassEncoderEnd,\n        NativeRenderPassEncoderEndOcclusionQuery,\n        NativeRenderPassEncoderEndPass,\n        NativeRenderPassEncoderExecuteBundles,\n        NativeRenderPassEncoderInsertDebugMarker,\n        NativeRenderPassEncoderPopDebugGroup,\n        NativeRenderPassEncoderPushDebugGroup,\n        NativeRenderPassEncoderSetBindGroup,\n        NativeRenderPassEncoderSetBlendConstant,\n        NativeRenderPassEncoderSetIndexBuffer,\n        NativeRenderPassEncoderSetLabel,\n        NativeRenderPassEncoderSetPipeline,\n        NativeRenderPassEncoderSetScissorRect,\n        NativeRenderPassEncoderSetStencilReference,\n        NativeRenderPassEncoderSetVertexBuffer,\n        NativeRenderPassEncoderSetViewport,\n        NativeRenderPassEncoderWriteTimestamp,\n        NativeRenderPassEncoderReference,\n        NativeRenderPassEncoderRelease,\n        NativeRenderPipelineGetBindGroupLayout,\n        NativeRenderPipelineSetLabel,\n        NativeRenderPipelineReference,\n        NativeRenderPipelineRelease,\n        NativeSamplerSetLabel,\n        NativeSamplerReference,\n        NativeSamplerRelease,\n        NativeShaderModuleGetCompilationInfo,\n        NativeShaderModuleSetLabel,\n        NativeShaderModuleReference,\n        NativeShaderModuleRelease,\n        NativeSurfaceReference,\n        NativeSurfaceRelease,\n        NativeSwapChainConfigure,\n        NativeSwapChainGetCurrentTextureView,\n        NativeSwapChainPresent,\n        NativeSwapChainReference,\n        NativeSwapChainRelease,\n        NativeTextureCreateView,\n        NativeTextureDestroy,\n        NativeTextureSetLabel,\n        NativeTextureReference,\n        NativeTextureRelease,\n        NativeTextureViewSetLabel,\n        NativeTextureViewReference,\n        NativeTextureViewRelease,\n    };\n\n    const DawnProcTable& GetProcsAutogen() {\n        return gProcTable;\n    }\n}\n", "src/dawn/native/ChainUtils_autogen.h": "// Copyright 2021 The Dawn Authors\n//\n// Licensed under the Apache License, Version 2.0 (the \"License\");\n// you may not use this file except in compliance with the License.\n// You may obtain a copy of the License at\n//\n//     http://www.apache.org/licenses/LICENSE-2.0\n//\n// Unless required by applicable law or agreed to in writing, software\n// distributed under the License is distributed on an \"AS IS\" BASIS,\n// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n// See the License for the specific language governing permissions and\n// limitations under the License.\n\n#ifndef DAWNNATIVE_CHAIN_UTILS_H_\n#define DAWNNATIVE_CHAIN_UTILS_H_\n\n#include \"dawn/native/dawn_platform.h\"\n#include \"dawn/native/Error.h\"\n\nnamespace dawn::native {\n    void FindInChain(const ChainedStruct* chain, const SurfaceDescriptorFromMetalLayer** out);\n    void FindInChain(const ChainedStruct* chain, const SurfaceDescriptorFromWindowsHWND** out);\n    void FindInChain(const ChainedStruct* chain, const SurfaceDescriptorFromXlibWindow** out);\n    void FindInChain(const ChainedStruct* chain, const SurfaceDescriptorFromCanvasHTMLSelector** out);\n    void FindInChain(const ChainedStruct* chain, const ShaderModuleSPIRVDescriptor** out);\n    void FindInChain(const ChainedStruct* chain, const ShaderModuleWGSLDescriptor** out);\n    void FindInChain(const ChainedStruct* chain, const SurfaceDescriptorFromWindowsCoreWindow** out);\n    void FindInChain(const ChainedStruct* chain, const ExternalTextureBindingEntry** out);\n    void FindInChain(const ChainedStruct* chain, const ExternalTextureBindingLayout** out);\n    void FindInChain(const ChainedStruct* chain, const SurfaceDescriptorFromWindowsSwapChainPanel** out);\n    void FindInChain(const ChainedStruct* chain, const DawnTextureInternalUsageDescriptor** out);\n    void FindInChain(const ChainedStruct* chain, const PrimitiveDepthClampingState** out);\n    void FindInChain(const ChainedStruct* chain, const DawnTogglesDeviceDescriptor** out);\n    void FindInChain(const ChainedStruct* chain, const DawnEncoderInternalUsageDescriptor** out);\n    void FindInChain(const ChainedStruct* chain, const DawnInstanceDescriptor** out);\n\n    // Verifies that |chain| only contains ChainedStructs of types enumerated in\n    // |oneOfConstraints| and contains no duplicate sTypes. Each vector in\n    // |oneOfConstraints| defines a set of sTypes that cannot coexist in the same chain.\n    // For example:\n    //   ValidateSTypes(chain, { { ShaderModuleSPIRVDescriptor, ShaderModuleWGSLDescriptor } }))\n    //   ValidateSTypes(chain, { { Extension1 }, { Extension2 } })\n    MaybeError ValidateSTypes(const ChainedStruct* chain,\n                              std::vector<std::vector<wgpu::SType>> oneOfConstraints);\n\n    template <typename T>\n    MaybeError ValidateSingleSTypeInner(const ChainedStruct* chain, T sType) {\n        DAWN_INVALID_IF(chain->sType != sType,\n            \"Unsupported sType (%s). Expected (%s)\", chain->sType, sType);\n        return {};\n    }\n\n    template <typename T, typename... Args>\n    MaybeError ValidateSingleSTypeInner(const ChainedStruct* chain, T sType, Args... sTypes) {\n        if (chain->sType == sType) {\n            return {};\n        }\n        return ValidateSingleSTypeInner(chain, sTypes...);\n    }\n\n    // Verifies that |chain| contains a single ChainedStruct of type |sType| or no ChainedStructs\n    // at all.\n    template <typename T>\n    MaybeError ValidateSingleSType(const ChainedStruct* chain, T sType) {\n        if (chain == nullptr) {\n            return {};\n        }\n        DAWN_INVALID_IF(chain->nextInChain != nullptr,\n            \"Chain can only contain a single chained struct.\");\n        return ValidateSingleSTypeInner(chain, sType);\n    }\n\n    // Verifies that |chain| contains a single ChainedStruct with a type enumerated in the\n    // parameter pack or no ChainedStructs at all.\n    template <typename T, typename... Args>\n    MaybeError ValidateSingleSType(const ChainedStruct* chain, T sType, Args... sTypes) {\n        if (chain == nullptr) {\n            return {};\n        }\n        DAWN_INVALID_IF(chain->nextInChain != nullptr,\n            \"Chain can only contain a single chained struct.\");\n        return ValidateSingleSTypeInner(chain, sType, sTypes...);\n    }\n\n}  // namespace dawn::native\n\n#endif  // DAWNNATIVE_CHAIN_UTILS_H_\n", "src/dawn/native/ChainUtils_autogen.cpp": "// Copyright 2021 The Dawn Authors\n//\n// Licensed under the Apache License, Version 2.0 (the \"License\");\n// you may not use this file except in compliance with the License.\n// You may obtain a copy of the License at\n//\n//     http://www.apache.org/licenses/LICENSE-2.0\n//\n// Unless required by applicable law or agreed to in writing, software\n// distributed under the License is distributed on an \"AS IS\" BASIS,\n// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n// See the License for the specific language governing permissions and\n// limitations under the License.\n\n#include \"dawn/native/ChainUtils_autogen.h\"\n\n#include <unordered_set>\n\nnamespace dawn::native {\n\nvoid FindInChain(const ChainedStruct* chain, const SurfaceDescriptorFromMetalLayer** out) {\n    for (; chain; chain = chain->nextInChain) {\n        if (chain->sType == wgpu::SType::SurfaceDescriptorFromMetalLayer) {\n            *out = static_cast<const SurfaceDescriptorFromMetalLayer*>(chain);\n            break;\n        }\n    }\n}\nvoid FindInChain(const ChainedStruct* chain, const SurfaceDescriptorFromWindowsHWND** out) {\n    for (; chain; chain = chain->nextInChain) {\n        if (chain->sType == wgpu::SType::SurfaceDescriptorFromWindowsHWND) {\n            *out = static_cast<const SurfaceDescriptorFromWindowsHWND*>(chain);\n            break;\n        }\n    }\n}\nvoid FindInChain(const ChainedStruct* chain, const SurfaceDescriptorFromXlibWindow** out) {\n    for (; chain; chain = chain->nextInChain) {\n        if (chain->sType == wgpu::SType::SurfaceDescriptorFromXlibWindow) {\n            *out = static_cast<const SurfaceDescriptorFromXlibWindow*>(chain);\n            break;\n        }\n    }\n}\nvoid FindInChain(const ChainedStruct* chain, const SurfaceDescriptorFromCanvasHTMLSelector** out) {\n    for (; chain; chain = chain->nextInChain) {\n        if (chain->sType == wgpu::SType::SurfaceDescriptorFromCanvasHTMLSelector) {\n            *out = static_cast<const SurfaceDescriptorFromCanvasHTMLSelector*>(chain);\n            break;\n        }\n    }\n}\nvoid FindInChain(const ChainedStruct* chain, const ShaderModuleSPIRVDescriptor** out) {\n    for (; chain; chain = chain->nextInChain) {\n        if (chain->sType == wgpu::SType::ShaderModuleSPIRVDescriptor) {\n            *out = static_cast<const ShaderModuleSPIRVDescriptor*>(chain);\n            break;\n        }\n    }\n}\nvoid FindInChain(const ChainedStruct* chain, const ShaderModuleWGSLDescriptor** out) {\n    for (; chain; chain = chain->nextInChain) {\n        if (chain->sType == wgpu::SType::ShaderModuleWGSLDescriptor) {\n            *out = static_cast<const ShaderModuleWGSLDescriptor*>(chain);\n            break;\n        }\n    }\n}\nvoid FindInChain(const ChainedStruct* chain, const SurfaceDescriptorFromWindowsCoreWindow** out) {\n    for (; chain; chain = chain->nextInChain) {\n        if (chain->sType == wgpu::SType::SurfaceDescriptorFromWindowsCoreWindow) {\n            *out = static_cast<const SurfaceDescriptorFromWindowsCoreWindow*>(chain);\n            break;\n        }\n    }\n}\nvoid FindInChain(const ChainedStruct* chain, const ExternalTextureBindingEntry** out) {\n    for (; chain; chain = chain->nextInChain) {\n        if (chain->sType == wgpu::SType::ExternalTextureBindingEntry) {\n            *out = static_cast<const ExternalTextureBindingEntry*>(chain);\n            break;\n        }\n    }\n}\nvoid FindInChain(const ChainedStruct* chain, const ExternalTextureBindingLayout** out) {\n    for (; chain; chain = chain->nextInChain) {\n        if (chain->sType == wgpu::SType::ExternalTextureBindingLayout) {\n            *out = static_cast<const ExternalTextureBindingLayout*>(chain);\n            break;\n        }\n    }\n}\nvoid FindInChain(const ChainedStruct* chain, const SurfaceDescriptorFromWindowsSwapChainPanel** out) {\n    for (; chain; chain = chain->nextInChain) {\n        if (chain->sType == wgpu::SType::SurfaceDescriptorFromWindowsSwapChainPanel) {\n            *out = static_cast<const SurfaceDescriptorFromWindowsSwapChainPanel*>(chain);\n            break;\n        }\n    }\n}\nvoid FindInChain(const ChainedStruct* chain, const DawnTextureInternalUsageDescriptor** out) {\n    for (; chain; chain = chain->nextInChain) {\n        if (chain->sType == wgpu::SType::DawnTextureInternalUsageDescriptor) {\n            *out = static_cast<const DawnTextureInternalUsageDescriptor*>(chain);\n            break;\n        }\n    }\n}\nvoid FindInChain(const ChainedStruct* chain, const PrimitiveDepthClampingState** out) {\n    for (; chain; chain = chain->nextInChain) {\n        if (chain->sType == wgpu::SType::PrimitiveDepthClampingState) {\n            *out = static_cast<const PrimitiveDepthClampingState*>(chain);\n            break;\n        }\n    }\n}\nvoid FindInChain(const ChainedStruct* chain, const DawnTogglesDeviceDescriptor** out) {\n    for (; chain; chain = chain->nextInChain) {\n        if (chain->sType == wgpu::SType::DawnTogglesDeviceDescriptor) {\n            *out = static_cast<const DawnTogglesDeviceDescriptor*>(chain);\n            break;\n        }\n    }\n}\nvoid FindInChain(const ChainedStruct* chain, const DawnEncoderInternalUsageDescriptor** out) {\n    for (; chain; chain = chain->nextInChain) {\n        if (chain->sType == wgpu::SType::DawnEncoderInternalUsageDescriptor) {\n            *out = static_cast<const DawnEncoderInternalUsageDescriptor*>(chain);\n            break;\n        }\n    }\n}\nvoid FindInChain(const ChainedStruct* chain, const DawnInstanceDescriptor** out) {\n    for (; chain; chain = chain->nextInChain) {\n        if (chain->sType == wgpu::SType::DawnInstanceDescriptor) {\n            *out = static_cast<const DawnInstanceDescriptor*>(chain);\n            break;\n        }\n    }\n}\n\nMaybeError ValidateSTypes(const ChainedStruct* chain,\n                          std::vector<std::vector<wgpu::SType>> oneOfConstraints) {\n    std::unordered_set<wgpu::SType> allSTypes;\n    for (; chain; chain = chain->nextInChain) {\n        if (allSTypes.find(chain->sType) != allSTypes.end()) {\n            return DAWN_VALIDATION_ERROR(\"Chain cannot have duplicate sTypes\");\n        }\n        allSTypes.insert(chain->sType);\n    }\n    for (const auto& oneOfConstraint : oneOfConstraints) {\n        bool satisfied = false;\n        for (wgpu::SType oneOfSType : oneOfConstraint) {\n            if (allSTypes.find(oneOfSType) != allSTypes.end()) {\n                if (satisfied) {\n                    return DAWN_VALIDATION_ERROR(\"Unsupported sType combination\");\n                }\n                satisfied = true;\n                allSTypes.erase(oneOfSType);\n            }\n        }\n    }\n    if (!allSTypes.empty()) {\n        return DAWN_VALIDATION_ERROR(\"Unsupported sType\");\n    }\n    return {};\n}\n\n}  // namespace dawn::native\n", "src/dawn/native/webgpu_absl_format_autogen.h": "\n#ifndef WEBGPU_ABSL_FORMAT_H_\n#define WEBGPU_ABSL_FORMAT_H_\n\n#include \"dawn/native/dawn_platform.h\"\n\n#include \"absl/strings/str_format.h\"\n\nnamespace dawn::native {\n\n    //\n    // Descriptors\n    //\n\n    // Only includes structures that have a 'label' member.\n    absl::FormatConvertResult<absl::FormatConversionCharSet::kString>\n    AbslFormatConvert(const BufferDescriptor* value,\n                      const absl::FormatConversionSpec& spec,\n                      absl::FormatSink* s);\n    absl::FormatConvertResult<absl::FormatConversionCharSet::kString>\n    AbslFormatConvert(const CommandBufferDescriptor* value,\n                      const absl::FormatConversionSpec& spec,\n                      absl::FormatSink* s);\n    absl::FormatConvertResult<absl::FormatConversionCharSet::kString>\n    AbslFormatConvert(const CommandEncoderDescriptor* value,\n                      const absl::FormatConversionSpec& spec,\n                      absl::FormatSink* s);\n    absl::FormatConvertResult<absl::FormatConversionCharSet::kString>\n    AbslFormatConvert(const ComputePassDescriptor* value,\n                      const absl::FormatConversionSpec& spec,\n                      absl::FormatSink* s);\n    absl::FormatConvertResult<absl::FormatConversionCharSet::kString>\n    AbslFormatConvert(const ExternalTextureDescriptor* value,\n                      const absl::FormatConversionSpec& spec,\n                      absl::FormatSink* s);\n    absl::FormatConvertResult<absl::FormatConversionCharSet::kString>\n    AbslFormatConvert(const PipelineLayoutDescriptor* value,\n                      const absl::FormatConversionSpec& spec,\n                      absl::FormatSink* s);\n    absl::FormatConvertResult<absl::FormatConversionCharSet::kString>\n    AbslFormatConvert(const QuerySetDescriptor* value,\n                      const absl::FormatConversionSpec& spec,\n                      absl::FormatSink* s);\n    absl::FormatConvertResult<absl::FormatConversionCharSet::kString>\n    AbslFormatConvert(const RenderBundleDescriptor* value,\n                      const absl::FormatConversionSpec& spec,\n                      absl::FormatSink* s);\n    absl::FormatConvertResult<absl::FormatConversionCharSet::kString>\n    AbslFormatConvert(const RenderBundleEncoderDescriptor* value,\n                      const absl::FormatConversionSpec& spec,\n                      absl::FormatSink* s);\n    absl::FormatConvertResult<absl::FormatConversionCharSet::kString>\n    AbslFormatConvert(const SamplerDescriptor* value,\n                      const absl::FormatConversionSpec& spec,\n                      absl::FormatSink* s);\n    absl::FormatConvertResult<absl::FormatConversionCharSet::kString>\n    AbslFormatConvert(const ShaderModuleDescriptor* value,\n                      const absl::FormatConversionSpec& spec,\n                      absl::FormatSink* s);\n    absl::FormatConvertResult<absl::FormatConversionCharSet::kString>\n    AbslFormatConvert(const SurfaceDescriptor* value,\n                      const absl::FormatConversionSpec& spec,\n                      absl::FormatSink* s);\n    absl::FormatConvertResult<absl::FormatConversionCharSet::kString>\n    AbslFormatConvert(const SwapChainDescriptor* value,\n                      const absl::FormatConversionSpec& spec,\n                      absl::FormatSink* s);\n    absl::FormatConvertResult<absl::FormatConversionCharSet::kString>\n    AbslFormatConvert(const TextureViewDescriptor* value,\n                      const absl::FormatConversionSpec& spec,\n                      absl::FormatSink* s);\n    absl::FormatConvertResult<absl::FormatConversionCharSet::kString>\n    AbslFormatConvert(const BindGroupDescriptor* value,\n                      const absl::FormatConversionSpec& spec,\n                      absl::FormatSink* s);\n    absl::FormatConvertResult<absl::FormatConversionCharSet::kString>\n    AbslFormatConvert(const TextureDescriptor* value,\n                      const absl::FormatConversionSpec& spec,\n                      absl::FormatSink* s);\n    absl::FormatConvertResult<absl::FormatConversionCharSet::kString>\n    AbslFormatConvert(const BindGroupLayoutDescriptor* value,\n                      const absl::FormatConversionSpec& spec,\n                      absl::FormatSink* s);\n    absl::FormatConvertResult<absl::FormatConversionCharSet::kString>\n    AbslFormatConvert(const ComputePipelineDescriptor* value,\n                      const absl::FormatConversionSpec& spec,\n                      absl::FormatSink* s);\n    absl::FormatConvertResult<absl::FormatConversionCharSet::kString>\n    AbslFormatConvert(const DeviceDescriptor* value,\n                      const absl::FormatConversionSpec& spec,\n                      absl::FormatSink* s);\n    absl::FormatConvertResult<absl::FormatConversionCharSet::kString>\n    AbslFormatConvert(const RenderPassDescriptor* value,\n                      const absl::FormatConversionSpec& spec,\n                      absl::FormatSink* s);\n    absl::FormatConvertResult<absl::FormatConversionCharSet::kString>\n    AbslFormatConvert(const RenderPipelineDescriptor* value,\n                      const absl::FormatConversionSpec& spec,\n                      absl::FormatSink* s);\n} // namespace dawn::native\n\nnamespace wgpu {\n\n    //\n    // Enums\n    //\n\n    absl::FormatConvertResult<absl::FormatConversionCharSet::kString>\n    AbslFormatConvert(AdapterType value,\n                      const absl::FormatConversionSpec& spec,\n                      absl::FormatSink* s);\n    absl::FormatConvertResult<absl::FormatConversionCharSet::kString>\n    AbslFormatConvert(AddressMode value,\n                      const absl::FormatConversionSpec& spec,\n                      absl::FormatSink* s);\n    absl::FormatConvertResult<absl::FormatConversionCharSet::kString>\n    AbslFormatConvert(AlphaMode value,\n                      const absl::FormatConversionSpec& spec,\n                      absl::FormatSink* s);\n    absl::FormatConvertResult<absl::FormatConversionCharSet::kString>\n    AbslFormatConvert(BackendType value,\n                      const absl::FormatConversionSpec& spec,\n                      absl::FormatSink* s);\n    absl::FormatConvertResult<absl::FormatConversionCharSet::kString>\n    AbslFormatConvert(BlendFactor value,\n                      const absl::FormatConversionSpec& spec,\n                      absl::FormatSink* s);\n    absl::FormatConvertResult<absl::FormatConversionCharSet::kString>\n    AbslFormatConvert(BlendOperation value,\n                      const absl::FormatConversionSpec& spec,\n                      absl::FormatSink* s);\n    absl::FormatConvertResult<absl::FormatConversionCharSet::kString>\n    AbslFormatConvert(BufferBindingType value,\n                      const absl::FormatConversionSpec& spec,\n                      absl::FormatSink* s);\n    absl::FormatConvertResult<absl::FormatConversionCharSet::kString>\n    AbslFormatConvert(BufferMapAsyncStatus value,\n                      const absl::FormatConversionSpec& spec,\n                      absl::FormatSink* s);\n    absl::FormatConvertResult<absl::FormatConversionCharSet::kString>\n    AbslFormatConvert(CompareFunction value,\n                      const absl::FormatConversionSpec& spec,\n                      absl::FormatSink* s);\n    absl::FormatConvertResult<absl::FormatConversionCharSet::kString>\n    AbslFormatConvert(CompilationInfoRequestStatus value,\n                      const absl::FormatConversionSpec& spec,\n                      absl::FormatSink* s);\n    absl::FormatConvertResult<absl::FormatConversionCharSet::kString>\n    AbslFormatConvert(CompilationMessageType value,\n                      const absl::FormatConversionSpec& spec,\n                      absl::FormatSink* s);\n    absl::FormatConvertResult<absl::FormatConversionCharSet::kString>\n    AbslFormatConvert(CreatePipelineAsyncStatus value,\n                      const absl::FormatConversionSpec& spec,\n                      absl::FormatSink* s);\n    absl::FormatConvertResult<absl::FormatConversionCharSet::kString>\n    AbslFormatConvert(CullMode value,\n                      const absl::FormatConversionSpec& spec,\n                      absl::FormatSink* s);\n    absl::FormatConvertResult<absl::FormatConversionCharSet::kString>\n    AbslFormatConvert(DeviceLostReason value,\n                      const absl::FormatConversionSpec& spec,\n                      absl::FormatSink* s);\n    absl::FormatConvertResult<absl::FormatConversionCharSet::kString>\n    AbslFormatConvert(ErrorFilter value,\n                      const absl::FormatConversionSpec& spec,\n                      absl::FormatSink* s);\n    absl::FormatConvertResult<absl::FormatConversionCharSet::kString>\n    AbslFormatConvert(ErrorType value,\n                      const absl::FormatConversionSpec& spec,\n                      absl::FormatSink* s);\n    absl::FormatConvertResult<absl::FormatConversionCharSet::kString>\n    AbslFormatConvert(FeatureName value,\n                      const absl::FormatConversionSpec& spec,\n                      absl::FormatSink* s);\n    absl::FormatConvertResult<absl::FormatConversionCharSet::kString>\n    AbslFormatConvert(FilterMode value,\n                      const absl::FormatConversionSpec& spec,\n                      absl::FormatSink* s);\n    absl::FormatConvertResult<absl::FormatConversionCharSet::kString>\n    AbslFormatConvert(FrontFace value,\n                      const absl::FormatConversionSpec& spec,\n                      absl::FormatSink* s);\n    absl::FormatConvertResult<absl::FormatConversionCharSet::kString>\n    AbslFormatConvert(IndexFormat value,\n                      const absl::FormatConversionSpec& spec,\n                      absl::FormatSink* s);\n    absl::FormatConvertResult<absl::FormatConversionCharSet::kString>\n    AbslFormatConvert(LoadOp value,\n                      const absl::FormatConversionSpec& spec,\n                      absl::FormatSink* s);\n    absl::FormatConvertResult<absl::FormatConversionCharSet::kString>\n    AbslFormatConvert(LoggingType value,\n                      const absl::FormatConversionSpec& spec,\n                      absl::FormatSink* s);\n    absl::FormatConvertResult<absl::FormatConversionCharSet::kString>\n    AbslFormatConvert(PipelineStatisticName value,\n                      const absl::FormatConversionSpec& spec,\n                      absl::FormatSink* s);\n    absl::FormatConvertResult<absl::FormatConversionCharSet::kString>\n    AbslFormatConvert(PowerPreference value,\n                      const absl::FormatConversionSpec& spec,\n                      absl::FormatSink* s);\n    absl::FormatConvertResult<absl::FormatConversionCharSet::kString>\n    AbslFormatConvert(PredefinedColorSpace value,\n                      const absl::FormatConversionSpec& spec,\n                      absl::FormatSink* s);\n    absl::FormatConvertResult<absl::FormatConversionCharSet::kString>\n    AbslFormatConvert(PresentMode value,\n                      const absl::FormatConversionSpec& spec,\n                      absl::FormatSink* s);\n    absl::FormatConvertResult<absl::FormatConversionCharSet::kString>\n    AbslFormatConvert(PrimitiveTopology value,\n                      const absl::FormatConversionSpec& spec,\n                      absl::FormatSink* s);\n    absl::FormatConvertResult<absl::FormatConversionCharSet::kString>\n    AbslFormatConvert(QueryType value,\n                      const absl::FormatConversionSpec& spec,\n                      absl::FormatSink* s);\n    absl::FormatConvertResult<absl::FormatConversionCharSet::kString>\n    AbslFormatConvert(QueueWorkDoneStatus value,\n                      const absl::FormatConversionSpec& spec,\n                      absl::FormatSink* s);\n    absl::FormatConvertResult<absl::FormatConversionCharSet::kString>\n    AbslFormatConvert(RequestAdapterStatus value,\n                      const absl::FormatConversionSpec& spec,\n                      absl::FormatSink* s);\n    absl::FormatConvertResult<absl::FormatConversionCharSet::kString>\n    AbslFormatConvert(RequestDeviceStatus value,\n                      const absl::FormatConversionSpec& spec,\n                      absl::FormatSink* s);\n    absl::FormatConvertResult<absl::FormatConversionCharSet::kString>\n    AbslFormatConvert(SType value,\n                      const absl::FormatConversionSpec& spec,\n                      absl::FormatSink* s);\n    absl::FormatConvertResult<absl::FormatConversionCharSet::kString>\n    AbslFormatConvert(SamplerBindingType value,\n                      const absl::FormatConversionSpec& spec,\n                      absl::FormatSink* s);\n    absl::FormatConvertResult<absl::FormatConversionCharSet::kString>\n    AbslFormatConvert(StencilOperation value,\n                      const absl::FormatConversionSpec& spec,\n                      absl::FormatSink* s);\n    absl::FormatConvertResult<absl::FormatConversionCharSet::kString>\n    AbslFormatConvert(StorageTextureAccess value,\n                      const absl::FormatConversionSpec& spec,\n                      absl::FormatSink* s);\n    absl::FormatConvertResult<absl::FormatConversionCharSet::kString>\n    AbslFormatConvert(StoreOp value,\n                      const absl::FormatConversionSpec& spec,\n                      absl::FormatSink* s);\n    absl::FormatConvertResult<absl::FormatConversionCharSet::kString>\n    AbslFormatConvert(TextureAspect value,\n                      const absl::FormatConversionSpec& spec,\n                      absl::FormatSink* s);\n    absl::FormatConvertResult<absl::FormatConversionCharSet::kString>\n    AbslFormatConvert(TextureComponentType value,\n                      const absl::FormatConversionSpec& spec,\n                      absl::FormatSink* s);\n    absl::FormatConvertResult<absl::FormatConversionCharSet::kString>\n    AbslFormatConvert(TextureDimension value,\n                      const absl::FormatConversionSpec& spec,\n                      absl::FormatSink* s);\n    absl::FormatConvertResult<absl::FormatConversionCharSet::kString>\n    AbslFormatConvert(TextureFormat value,\n                      const absl::FormatConversionSpec& spec,\n                      absl::FormatSink* s);\n    absl::FormatConvertResult<absl::FormatConversionCharSet::kString>\n    AbslFormatConvert(TextureSampleType value,\n                      const absl::FormatConversionSpec& spec,\n                      absl::FormatSink* s);\n    absl::FormatConvertResult<absl::FormatConversionCharSet::kString>\n    AbslFormatConvert(TextureViewDimension value,\n                      const absl::FormatConversionSpec& spec,\n                      absl::FormatSink* s);\n    absl::FormatConvertResult<absl::FormatConversionCharSet::kString>\n    AbslFormatConvert(VertexFormat value,\n                      const absl::FormatConversionSpec& spec,\n                      absl::FormatSink* s);\n    absl::FormatConvertResult<absl::FormatConversionCharSet::kString>\n    AbslFormatConvert(VertexStepMode value,\n                      const absl::FormatConversionSpec& spec,\n                      absl::FormatSink* s);\n\n    //\n    // Bitmasks\n    //\n\n    absl::FormatConvertResult<absl::FormatConversionCharSet::kString>\n    AbslFormatConvert(BufferUsage value,\n                      const absl::FormatConversionSpec& spec,\n                      absl::FormatSink* s);\n    absl::FormatConvertResult<absl::FormatConversionCharSet::kString>\n    AbslFormatConvert(ColorWriteMask value,\n                      const absl::FormatConversionSpec& spec,\n                      absl::FormatSink* s);\n    absl::FormatConvertResult<absl::FormatConversionCharSet::kString>\n    AbslFormatConvert(MapMode value,\n                      const absl::FormatConversionSpec& spec,\n                      absl::FormatSink* s);\n    absl::FormatConvertResult<absl::FormatConversionCharSet::kString>\n    AbslFormatConvert(ShaderStage value,\n                      const absl::FormatConversionSpec& spec,\n                      absl::FormatSink* s);\n    absl::FormatConvertResult<absl::FormatConversionCharSet::kString>\n    AbslFormatConvert(TextureUsage value,\n                      const absl::FormatConversionSpec& spec,\n                      absl::FormatSink* s);\n\n}  // namespace wgpu\n\n#endif // WEBGPU_ABSL_FORMAT_H_\n", "src/dawn/native/webgpu_absl_format_autogen.cpp": "\n#include \"dawn/native/webgpu_absl_format_autogen.h\"\n\n#include \"dawn/native/ObjectType_autogen.h\"\n\nnamespace dawn::native {\n\n    //\n    // Descriptors\n    //\n\n    absl::FormatConvertResult<absl::FormatConversionCharSet::kString>\n    AbslFormatConvert(const BufferDescriptor* value,\n                        const absl::FormatConversionSpec& spec,\n                        absl::FormatSink* s) {\n        if (value == nullptr) {\n            s->Append(\"[null]\");\n            return {true};\n        }\n        s->Append(\"[BufferDescriptor\");\n        if (value->label != nullptr) {\n            s->Append(absl::StrFormat(\" \\\"%s\\\"\", value->label));\n        }\n        s->Append(\"]\");\n        return {true};\n    }\n    absl::FormatConvertResult<absl::FormatConversionCharSet::kString>\n    AbslFormatConvert(const CommandBufferDescriptor* value,\n                        const absl::FormatConversionSpec& spec,\n                        absl::FormatSink* s) {\n        if (value == nullptr) {\n            s->Append(\"[null]\");\n            return {true};\n        }\n        s->Append(\"[CommandBufferDescriptor\");\n        if (value->label != nullptr) {\n            s->Append(absl::StrFormat(\" \\\"%s\\\"\", value->label));\n        }\n        s->Append(\"]\");\n        return {true};\n    }\n    absl::FormatConvertResult<absl::FormatConversionCharSet::kString>\n    AbslFormatConvert(const CommandEncoderDescriptor* value,\n                        const absl::FormatConversionSpec& spec,\n                        absl::FormatSink* s) {\n        if (value == nullptr) {\n            s->Append(\"[null]\");\n            return {true};\n        }\n        s->Append(\"[CommandEncoderDescriptor\");\n        if (value->label != nullptr) {\n            s->Append(absl::StrFormat(\" \\\"%s\\\"\", value->label));\n        }\n        s->Append(\"]\");\n        return {true};\n    }\n    absl::FormatConvertResult<absl::FormatConversionCharSet::kString>\n    AbslFormatConvert(const ComputePassDescriptor* value,\n                        const absl::FormatConversionSpec& spec,\n                        absl::FormatSink* s) {\n        if (value == nullptr) {\n            s->Append(\"[null]\");\n            return {true};\n        }\n        s->Append(\"[ComputePassDescriptor\");\n        if (value->label != nullptr) {\n            s->Append(absl::StrFormat(\" \\\"%s\\\"\", value->label));\n        }\n        s->Append(\"]\");\n        return {true};\n    }\n    absl::FormatConvertResult<absl::FormatConversionCharSet::kString>\n    AbslFormatConvert(const ExternalTextureDescriptor* value,\n                        const absl::FormatConversionSpec& spec,\n                        absl::FormatSink* s) {\n        if (value == nullptr) {\n            s->Append(\"[null]\");\n            return {true};\n        }\n        s->Append(\"[ExternalTextureDescriptor\");\n        if (value->label != nullptr) {\n            s->Append(absl::StrFormat(\" \\\"%s\\\"\", value->label));\n        }\n        s->Append(\"]\");\n        return {true};\n    }\n    absl::FormatConvertResult<absl::FormatConversionCharSet::kString>\n    AbslFormatConvert(const PipelineLayoutDescriptor* value,\n                        const absl::FormatConversionSpec& spec,\n                        absl::FormatSink* s) {\n        if (value == nullptr) {\n            s->Append(\"[null]\");\n            return {true};\n        }\n        s->Append(\"[PipelineLayoutDescriptor\");\n        if (value->label != nullptr) {\n            s->Append(absl::StrFormat(\" \\\"%s\\\"\", value->label));\n        }\n        s->Append(\"]\");\n        return {true};\n    }\n    absl::FormatConvertResult<absl::FormatConversionCharSet::kString>\n    AbslFormatConvert(const QuerySetDescriptor* value,\n                        const absl::FormatConversionSpec& spec,\n                        absl::FormatSink* s) {\n        if (value == nullptr) {\n            s->Append(\"[null]\");\n            return {true};\n        }\n        s->Append(\"[QuerySetDescriptor\");\n        if (value->label != nullptr) {\n            s->Append(absl::StrFormat(\" \\\"%s\\\"\", value->label));\n        }\n        s->Append(\"]\");\n        return {true};\n    }\n    absl::FormatConvertResult<absl::FormatConversionCharSet::kString>\n    AbslFormatConvert(const RenderBundleDescriptor* value,\n                        const absl::FormatConversionSpec& spec,\n                        absl::FormatSink* s) {\n        if (value == nullptr) {\n            s->Append(\"[null]\");\n            return {true};\n        }\n        s->Append(\"[RenderBundleDescriptor\");\n        if (value->label != nullptr) {\n            s->Append(absl::StrFormat(\" \\\"%s\\\"\", value->label));\n        }\n        s->Append(\"]\");\n        return {true};\n    }\n    absl::FormatConvertResult<absl::FormatConversionCharSet::kString>\n    AbslFormatConvert(const RenderBundleEncoderDescriptor* value,\n                        const absl::FormatConversionSpec& spec,\n                        absl::FormatSink* s) {\n        if (value == nullptr) {\n            s->Append(\"[null]\");\n            return {true};\n        }\n        s->Append(\"[RenderBundleEncoderDescriptor\");\n        if (value->label != nullptr) {\n            s->Append(absl::StrFormat(\" \\\"%s\\\"\", value->label));\n        }\n        s->Append(\"]\");\n        return {true};\n    }\n    absl::FormatConvertResult<absl::FormatConversionCharSet::kString>\n    AbslFormatConvert(const SamplerDescriptor* value,\n                        const absl::FormatConversionSpec& spec,\n                        absl::FormatSink* s) {\n        if (value == nullptr) {\n            s->Append(\"[null]\");\n            return {true};\n        }\n        s->Append(\"[SamplerDescriptor\");\n        if (value->label != nullptr) {\n            s->Append(absl::StrFormat(\" \\\"%s\\\"\", value->label));\n        }\n        s->Append(\"]\");\n        return {true};\n    }\n    absl::FormatConvertResult<absl::FormatConversionCharSet::kString>\n    AbslFormatConvert(const ShaderModuleDescriptor* value,\n                        const absl::FormatConversionSpec& spec,\n                        absl::FormatSink* s) {\n        if (value == nullptr) {\n            s->Append(\"[null]\");\n            return {true};\n        }\n        s->Append(\"[ShaderModuleDescriptor\");\n        if (value->label != nullptr) {\n            s->Append(absl::StrFormat(\" \\\"%s\\\"\", value->label));\n        }\n        s->Append(\"]\");\n        return {true};\n    }\n    absl::FormatConvertResult<absl::FormatConversionCharSet::kString>\n    AbslFormatConvert(const SurfaceDescriptor* value,\n                        const absl::FormatConversionSpec& spec,\n                        absl::FormatSink* s) {\n        if (value == nullptr) {\n            s->Append(\"[null]\");\n            return {true};\n        }\n        s->Append(\"[SurfaceDescriptor\");\n        if (value->label != nullptr) {\n            s->Append(absl::StrFormat(\" \\\"%s\\\"\", value->label));\n        }\n        s->Append(\"]\");\n        return {true};\n    }\n    absl::FormatConvertResult<absl::FormatConversionCharSet::kString>\n    AbslFormatConvert(const SwapChainDescriptor* value,\n                        const absl::FormatConversionSpec& spec,\n                        absl::FormatSink* s) {\n        if (value == nullptr) {\n            s->Append(\"[null]\");\n            return {true};\n        }\n        s->Append(\"[SwapChainDescriptor\");\n        if (value->label != nullptr) {\n            s->Append(absl::StrFormat(\" \\\"%s\\\"\", value->label));\n        }\n        s->Append(\"]\");\n        return {true};\n    }\n    absl::FormatConvertResult<absl::FormatConversionCharSet::kString>\n    AbslFormatConvert(const TextureViewDescriptor* value,\n                        const absl::FormatConversionSpec& spec,\n                        absl::FormatSink* s) {\n        if (value == nullptr) {\n            s->Append(\"[null]\");\n            return {true};\n        }\n        s->Append(\"[TextureViewDescriptor\");\n        if (value->label != nullptr) {\n            s->Append(absl::StrFormat(\" \\\"%s\\\"\", value->label));\n        }\n        s->Append(\"]\");\n        return {true};\n    }\n    absl::FormatConvertResult<absl::FormatConversionCharSet::kString>\n    AbslFormatConvert(const BindGroupDescriptor* value,\n                        const absl::FormatConversionSpec& spec,\n                        absl::FormatSink* s) {\n        if (value == nullptr) {\n            s->Append(\"[null]\");\n            return {true};\n        }\n        s->Append(\"[BindGroupDescriptor\");\n        if (value->label != nullptr) {\n            s->Append(absl::StrFormat(\" \\\"%s\\\"\", value->label));\n        }\n        s->Append(\"]\");\n        return {true};\n    }\n    absl::FormatConvertResult<absl::FormatConversionCharSet::kString>\n    AbslFormatConvert(const TextureDescriptor* value,\n                        const absl::FormatConversionSpec& spec,\n                        absl::FormatSink* s) {\n        if (value == nullptr) {\n            s->Append(\"[null]\");\n            return {true};\n        }\n        s->Append(\"[TextureDescriptor\");\n        if (value->label != nullptr) {\n            s->Append(absl::StrFormat(\" \\\"%s\\\"\", value->label));\n        }\n        s->Append(\"]\");\n        return {true};\n    }\n    absl::FormatConvertResult<absl::FormatConversionCharSet::kString>\n    AbslFormatConvert(const BindGroupLayoutDescriptor* value,\n                        const absl::FormatConversionSpec& spec,\n                        absl::FormatSink* s) {\n        if (value == nullptr) {\n            s->Append(\"[null]\");\n            return {true};\n        }\n        s->Append(\"[BindGroupLayoutDescriptor\");\n        if (value->label != nullptr) {\n            s->Append(absl::StrFormat(\" \\\"%s\\\"\", value->label));\n        }\n        s->Append(\"]\");\n        return {true};\n    }\n    absl::FormatConvertResult<absl::FormatConversionCharSet::kString>\n    AbslFormatConvert(const ComputePipelineDescriptor* value,\n                        const absl::FormatConversionSpec& spec,\n                        absl::FormatSink* s) {\n        if (value == nullptr) {\n            s->Append(\"[null]\");\n            return {true};\n        }\n        s->Append(\"[ComputePipelineDescriptor\");\n        if (value->label != nullptr) {\n            s->Append(absl::StrFormat(\" \\\"%s\\\"\", value->label));\n        }\n        s->Append(\"]\");\n        return {true};\n    }\n    absl::FormatConvertResult<absl::FormatConversionCharSet::kString>\n    AbslFormatConvert(const DeviceDescriptor* value,\n                        const absl::FormatConversionSpec& spec,\n                        absl::FormatSink* s) {\n        if (value == nullptr) {\n            s->Append(\"[null]\");\n            return {true};\n        }\n        s->Append(\"[DeviceDescriptor\");\n        if (value->label != nullptr) {\n            s->Append(absl::StrFormat(\" \\\"%s\\\"\", value->label));\n        }\n        s->Append(\"]\");\n        return {true};\n    }\n    absl::FormatConvertResult<absl::FormatConversionCharSet::kString>\n    AbslFormatConvert(const RenderPassDescriptor* value,\n                        const absl::FormatConversionSpec& spec,\n                        absl::FormatSink* s) {\n        if (value == nullptr) {\n            s->Append(\"[null]\");\n            return {true};\n        }\n        s->Append(\"[RenderPassDescriptor\");\n        if (value->label != nullptr) {\n            s->Append(absl::StrFormat(\" \\\"%s\\\"\", value->label));\n        }\n        s->Append(\"]\");\n        return {true};\n    }\n    absl::FormatConvertResult<absl::FormatConversionCharSet::kString>\n    AbslFormatConvert(const RenderPipelineDescriptor* value,\n                        const absl::FormatConversionSpec& spec,\n                        absl::FormatSink* s) {\n        if (value == nullptr) {\n            s->Append(\"[null]\");\n            return {true};\n        }\n        s->Append(\"[RenderPipelineDescriptor\");\n        if (value->label != nullptr) {\n            s->Append(absl::StrFormat(\" \\\"%s\\\"\", value->label));\n        }\n        s->Append(\"]\");\n        return {true};\n    }\n\n}  // namespace dawn::native\n\nnamespace wgpu {\n\n    //\n    // Enums\n    //\n\n    absl::FormatConvertResult<absl::FormatConversionCharSet::kString>\n    AbslFormatConvert(AdapterType value,\n                        const absl::FormatConversionSpec& spec,\n                        absl::FormatSink* s) {\n        s->Append(\"AdapterType::\");\n        switch (value) {\n        case AdapterType::DiscreteGPU:\n        s->Append(\"DiscreteGPU\");\n        break;\n        case AdapterType::IntegratedGPU:\n        s->Append(\"IntegratedGPU\");\n        break;\n        case AdapterType::CPU:\n        s->Append(\"CPU\");\n        break;\n        case AdapterType::Unknown:\n        s->Append(\"Unknown\");\n        break;\n            default:\n            s->Append(absl::StrFormat(\"%x\", static_cast<typename std::underlying_type<AdapterType>::type>(value)));\n        }\n        return {true};\n    }\n    absl::FormatConvertResult<absl::FormatConversionCharSet::kString>\n    AbslFormatConvert(AddressMode value,\n                        const absl::FormatConversionSpec& spec,\n                        absl::FormatSink* s) {\n        s->Append(\"AddressMode::\");\n        switch (value) {\n        case AddressMode::Repeat:\n        s->Append(\"Repeat\");\n        break;\n        case AddressMode::MirrorRepeat:\n        s->Append(\"MirrorRepeat\");\n        break;\n        case AddressMode::ClampToEdge:\n        s->Append(\"ClampToEdge\");\n        break;\n            default:\n            s->Append(absl::StrFormat(\"%x\", static_cast<typename std::underlying_type<AddressMode>::type>(value)));\n        }\n        return {true};\n    }\n    absl::FormatConvertResult<absl::FormatConversionCharSet::kString>\n    AbslFormatConvert(AlphaMode value,\n                        const absl::FormatConversionSpec& spec,\n                        absl::FormatSink* s) {\n        s->Append(\"AlphaMode::\");\n        switch (value) {\n        case AlphaMode::Premultiplied:\n        s->Append(\"Premultiplied\");\n        break;\n        case AlphaMode::Unpremultiplied:\n        s->Append(\"Unpremultiplied\");\n        break;\n            default:\n            s->Append(absl::StrFormat(\"%x\", static_cast<typename std::underlying_type<AlphaMode>::type>(value)));\n        }\n        return {true};\n    }\n    absl::FormatConvertResult<absl::FormatConversionCharSet::kString>\n    AbslFormatConvert(BackendType value,\n                        const absl::FormatConversionSpec& spec,\n                        absl::FormatSink* s) {\n        s->Append(\"BackendType::\");\n        switch (value) {\n        case BackendType::Null:\n        s->Append(\"Null\");\n        break;\n        case BackendType::WebGPU:\n        s->Append(\"WebGPU\");\n        break;\n        case BackendType::D3D11:\n        s->Append(\"D3D11\");\n        break;\n        case BackendType::D3D12:\n        s->Append(\"D3D12\");\n        break;\n        case BackendType::Metal:\n        s->Append(\"Metal\");\n        break;\n        case BackendType::Vulkan:\n        s->Append(\"Vulkan\");\n        break;\n        case BackendType::OpenGL:\n        s->Append(\"OpenGL\");\n        break;\n        case BackendType::OpenGLES:\n        s->Append(\"OpenGLES\");\n        break;\n            default:\n            s->Append(absl::StrFormat(\"%x\", static_cast<typename std::underlying_type<BackendType>::type>(value)));\n        }\n        return {true};\n    }\n    absl::FormatConvertResult<absl::FormatConversionCharSet::kString>\n    AbslFormatConvert(BlendFactor value,\n                        const absl::FormatConversionSpec& spec,\n                        absl::FormatSink* s) {\n        s->Append(\"BlendFactor::\");\n        switch (value) {\n        case BlendFactor::Zero:\n        s->Append(\"Zero\");\n        break;\n        case BlendFactor::One:\n        s->Append(\"One\");\n        break;\n        case BlendFactor::Src:\n        s->Append(\"Src\");\n        break;\n        case BlendFactor::OneMinusSrc:\n        s->Append(\"OneMinusSrc\");\n        break;\n        case BlendFactor::SrcAlpha:\n        s->Append(\"SrcAlpha\");\n        break;\n        case BlendFactor::OneMinusSrcAlpha:\n        s->Append(\"OneMinusSrcAlpha\");\n        break;\n        case BlendFactor::Dst:\n        s->Append(\"Dst\");\n        break;\n        case BlendFactor::OneMinusDst:\n        s->Append(\"OneMinusDst\");\n        break;\n        case BlendFactor::DstAlpha:\n        s->Append(\"DstAlpha\");\n        break;\n        case BlendFactor::OneMinusDstAlpha:\n        s->Append(\"OneMinusDstAlpha\");\n        break;\n        case BlendFactor::SrcAlphaSaturated:\n        s->Append(\"SrcAlphaSaturated\");\n        break;\n        case BlendFactor::Constant:\n        s->Append(\"Constant\");\n        break;\n        case BlendFactor::OneMinusConstant:\n        s->Append(\"OneMinusConstant\");\n        break;\n            default:\n            s->Append(absl::StrFormat(\"%x\", static_cast<typename std::underlying_type<BlendFactor>::type>(value)));\n        }\n        return {true};\n    }\n    absl::FormatConvertResult<absl::FormatConversionCharSet::kString>\n    AbslFormatConvert(BlendOperation value,\n                        const absl::FormatConversionSpec& spec,\n                        absl::FormatSink* s) {\n        s->Append(\"BlendOperation::\");\n        switch (value) {\n        case BlendOperation::Add:\n        s->Append(\"Add\");\n        break;\n        case BlendOperation::Subtract:\n        s->Append(\"Subtract\");\n        break;\n        case BlendOperation::ReverseSubtract:\n        s->Append(\"ReverseSubtract\");\n        break;\n        case BlendOperation::Min:\n        s->Append(\"Min\");\n        break;\n        case BlendOperation::Max:\n        s->Append(\"Max\");\n        break;\n            default:\n            s->Append(absl::StrFormat(\"%x\", static_cast<typename std::underlying_type<BlendOperation>::type>(value)));\n        }\n        return {true};\n    }\n    absl::FormatConvertResult<absl::FormatConversionCharSet::kString>\n    AbslFormatConvert(BufferBindingType value,\n                        const absl::FormatConversionSpec& spec,\n                        absl::FormatSink* s) {\n        s->Append(\"BufferBindingType::\");\n        switch (value) {\n        case BufferBindingType::Undefined:\n        s->Append(\"Undefined\");\n        break;\n        case BufferBindingType::Uniform:\n        s->Append(\"Uniform\");\n        break;\n        case BufferBindingType::Storage:\n        s->Append(\"Storage\");\n        break;\n        case BufferBindingType::ReadOnlyStorage:\n        s->Append(\"ReadOnlyStorage\");\n        break;\n            default:\n            s->Append(absl::StrFormat(\"%x\", static_cast<typename std::underlying_type<BufferBindingType>::type>(value)));\n        }\n        return {true};\n    }\n    absl::FormatConvertResult<absl::FormatConversionCharSet::kString>\n    AbslFormatConvert(BufferMapAsyncStatus value,\n                        const absl::FormatConversionSpec& spec,\n                        absl::FormatSink* s) {\n        s->Append(\"BufferMapAsyncStatus::\");\n        switch (value) {\n        case BufferMapAsyncStatus::Success:\n        s->Append(\"Success\");\n        break;\n        case BufferMapAsyncStatus::Error:\n        s->Append(\"Error\");\n        break;\n        case BufferMapAsyncStatus::Unknown:\n        s->Append(\"Unknown\");\n        break;\n        case BufferMapAsyncStatus::DeviceLost:\n        s->Append(\"DeviceLost\");\n        break;\n        case BufferMapAsyncStatus::DestroyedBeforeCallback:\n        s->Append(\"DestroyedBeforeCallback\");\n        break;\n        case BufferMapAsyncStatus::UnmappedBeforeCallback:\n        s->Append(\"UnmappedBeforeCallback\");\n        break;\n            default:\n            s->Append(absl::StrFormat(\"%x\", static_cast<typename std::underlying_type<BufferMapAsyncStatus>::type>(value)));\n        }\n        return {true};\n    }\n    absl::FormatConvertResult<absl::FormatConversionCharSet::kString>\n    AbslFormatConvert(CompareFunction value,\n                        const absl::FormatConversionSpec& spec,\n                        absl::FormatSink* s) {\n        s->Append(\"CompareFunction::\");\n        switch (value) {\n        case CompareFunction::Undefined:\n        s->Append(\"Undefined\");\n        break;\n        case CompareFunction::Never:\n        s->Append(\"Never\");\n        break;\n        case CompareFunction::Less:\n        s->Append(\"Less\");\n        break;\n        case CompareFunction::LessEqual:\n        s->Append(\"LessEqual\");\n        break;\n        case CompareFunction::Greater:\n        s->Append(\"Greater\");\n        break;\n        case CompareFunction::GreaterEqual:\n        s->Append(\"GreaterEqual\");\n        break;\n        case CompareFunction::Equal:\n        s->Append(\"Equal\");\n        break;\n        case CompareFunction::NotEqual:\n        s->Append(\"NotEqual\");\n        break;\n        case CompareFunction::Always:\n        s->Append(\"Always\");\n        break;\n            default:\n            s->Append(absl::StrFormat(\"%x\", static_cast<typename std::underlying_type<CompareFunction>::type>(value)));\n        }\n        return {true};\n    }\n    absl::FormatConvertResult<absl::FormatConversionCharSet::kString>\n    AbslFormatConvert(CompilationInfoRequestStatus value,\n                        const absl::FormatConversionSpec& spec,\n                        absl::FormatSink* s) {\n        s->Append(\"CompilationInfoRequestStatus::\");\n        switch (value) {\n        case CompilationInfoRequestStatus::Success:\n        s->Append(\"Success\");\n        break;\n        case CompilationInfoRequestStatus::Error:\n        s->Append(\"Error\");\n        break;\n        case CompilationInfoRequestStatus::DeviceLost:\n        s->Append(\"DeviceLost\");\n        break;\n        case CompilationInfoRequestStatus::Unknown:\n        s->Append(\"Unknown\");\n        break;\n            default:\n            s->Append(absl::StrFormat(\"%x\", static_cast<typename std::underlying_type<CompilationInfoRequestStatus>::type>(value)));\n        }\n        return {true};\n    }\n    absl::FormatConvertResult<absl::FormatConversionCharSet::kString>\n    AbslFormatConvert(CompilationMessageType value,\n                        const absl::FormatConversionSpec& spec,\n                        absl::FormatSink* s) {\n        s->Append(\"CompilationMessageType::\");\n        switch (value) {\n        case CompilationMessageType::Error:\n        s->Append(\"Error\");\n        break;\n        case CompilationMessageType::Warning:\n        s->Append(\"Warning\");\n        break;\n        case CompilationMessageType::Info:\n        s->Append(\"Info\");\n        break;\n            default:\n            s->Append(absl::StrFormat(\"%x\", static_cast<typename std::underlying_type<CompilationMessageType>::type>(value)));\n        }\n        return {true};\n    }\n    absl::FormatConvertResult<absl::FormatConversionCharSet::kString>\n    AbslFormatConvert(CreatePipelineAsyncStatus value,\n                        const absl::FormatConversionSpec& spec,\n                        absl::FormatSink* s) {\n        s->Append(\"CreatePipelineAsyncStatus::\");\n        switch (value) {\n        case CreatePipelineAsyncStatus::Success:\n        s->Append(\"Success\");\n        break;\n        case CreatePipelineAsyncStatus::Error:\n        s->Append(\"Error\");\n        break;\n        case CreatePipelineAsyncStatus::DeviceLost:\n        s->Append(\"DeviceLost\");\n        break;\n        case CreatePipelineAsyncStatus::DeviceDestroyed:\n        s->Append(\"DeviceDestroyed\");\n        break;\n        case CreatePipelineAsyncStatus::Unknown:\n        s->Append(\"Unknown\");\n        break;\n            default:\n            s->Append(absl::StrFormat(\"%x\", static_cast<typename std::underlying_type<CreatePipelineAsyncStatus>::type>(value)));\n        }\n        return {true};\n    }\n    absl::FormatConvertResult<absl::FormatConversionCharSet::kString>\n    AbslFormatConvert(CullMode value,\n                        const absl::FormatConversionSpec& spec,\n                        absl::FormatSink* s) {\n        s->Append(\"CullMode::\");\n        switch (value) {\n        case CullMode::None:\n        s->Append(\"None\");\n        break;\n        case CullMode::Front:\n        s->Append(\"Front\");\n        break;\n        case CullMode::Back:\n        s->Append(\"Back\");\n        break;\n            default:\n            s->Append(absl::StrFormat(\"%x\", static_cast<typename std::underlying_type<CullMode>::type>(value)));\n        }\n        return {true};\n    }\n    absl::FormatConvertResult<absl::FormatConversionCharSet::kString>\n    AbslFormatConvert(DeviceLostReason value,\n                        const absl::FormatConversionSpec& spec,\n                        absl::FormatSink* s) {\n        s->Append(\"DeviceLostReason::\");\n        switch (value) {\n        case DeviceLostReason::Undefined:\n        s->Append(\"Undefined\");\n        break;\n        case DeviceLostReason::Destroyed:\n        s->Append(\"Destroyed\");\n        break;\n            default:\n            s->Append(absl::StrFormat(\"%x\", static_cast<typename std::underlying_type<DeviceLostReason>::type>(value)));\n        }\n        return {true};\n    }\n    absl::FormatConvertResult<absl::FormatConversionCharSet::kString>\n    AbslFormatConvert(ErrorFilter value,\n                        const absl::FormatConversionSpec& spec,\n                        absl::FormatSink* s) {\n        s->Append(\"ErrorFilter::\");\n        switch (value) {\n        case ErrorFilter::Validation:\n        s->Append(\"Validation\");\n        break;\n        case ErrorFilter::OutOfMemory:\n        s->Append(\"OutOfMemory\");\n        break;\n            default:\n            s->Append(absl::StrFormat(\"%x\", static_cast<typename std::underlying_type<ErrorFilter>::type>(value)));\n        }\n        return {true};\n    }\n    absl::FormatConvertResult<absl::FormatConversionCharSet::kString>\n    AbslFormatConvert(ErrorType value,\n                        const absl::FormatConversionSpec& spec,\n                        absl::FormatSink* s) {\n        s->Append(\"ErrorType::\");\n        switch (value) {\n        case ErrorType::NoError:\n        s->Append(\"NoError\");\n        break;\n        case ErrorType::Validation:\n        s->Append(\"Validation\");\n        break;\n        case ErrorType::OutOfMemory:\n        s->Append(\"OutOfMemory\");\n        break;\n        case ErrorType::Unknown:\n        s->Append(\"Unknown\");\n        break;\n        case ErrorType::DeviceLost:\n        s->Append(\"DeviceLost\");\n        break;\n            default:\n            s->Append(absl::StrFormat(\"%x\", static_cast<typename std::underlying_type<ErrorType>::type>(value)));\n        }\n        return {true};\n    }\n    absl::FormatConvertResult<absl::FormatConversionCharSet::kString>\n    AbslFormatConvert(FeatureName value,\n                        const absl::FormatConversionSpec& spec,\n                        absl::FormatSink* s) {\n        s->Append(\"FeatureName::\");\n        switch (value) {\n        case FeatureName::Undefined:\n        s->Append(\"Undefined\");\n        break;\n        case FeatureName::Depth24UnormStencil8:\n        s->Append(\"Depth24UnormStencil8\");\n        break;\n        case FeatureName::Depth32FloatStencil8:\n        s->Append(\"Depth32FloatStencil8\");\n        break;\n        case FeatureName::TimestampQuery:\n        s->Append(\"TimestampQuery\");\n        break;\n        case FeatureName::PipelineStatisticsQuery:\n        s->Append(\"PipelineStatisticsQuery\");\n        break;\n        case FeatureName::TextureCompressionBC:\n        s->Append(\"TextureCompressionBC\");\n        break;\n        case FeatureName::TextureCompressionETC2:\n        s->Append(\"TextureCompressionETC2\");\n        break;\n        case FeatureName::TextureCompressionASTC:\n        s->Append(\"TextureCompressionASTC\");\n        break;\n        case FeatureName::IndirectFirstInstance:\n        s->Append(\"IndirectFirstInstance\");\n        break;\n        case FeatureName::DepthClamping:\n        s->Append(\"DepthClamping\");\n        break;\n        case FeatureName::DawnShaderFloat16:\n        s->Append(\"DawnShaderFloat16\");\n        break;\n        case FeatureName::DawnInternalUsages:\n        s->Append(\"DawnInternalUsages\");\n        break;\n        case FeatureName::DawnMultiPlanarFormats:\n        s->Append(\"DawnMultiPlanarFormats\");\n        break;\n        case FeatureName::DawnNative:\n        s->Append(\"DawnNative\");\n        break;\n            default:\n            s->Append(absl::StrFormat(\"%x\", static_cast<typename std::underlying_type<FeatureName>::type>(value)));\n        }\n        return {true};\n    }\n    absl::FormatConvertResult<absl::FormatConversionCharSet::kString>\n    AbslFormatConvert(FilterMode value,\n                        const absl::FormatConversionSpec& spec,\n                        absl::FormatSink* s) {\n        s->Append(\"FilterMode::\");\n        switch (value) {\n        case FilterMode::Nearest:\n        s->Append(\"Nearest\");\n        break;\n        case FilterMode::Linear:\n        s->Append(\"Linear\");\n        break;\n            default:\n            s->Append(absl::StrFormat(\"%x\", static_cast<typename std::underlying_type<FilterMode>::type>(value)));\n        }\n        return {true};\n    }\n    absl::FormatConvertResult<absl::FormatConversionCharSet::kString>\n    AbslFormatConvert(FrontFace value,\n                        const absl::FormatConversionSpec& spec,\n                        absl::FormatSink* s) {\n        s->Append(\"FrontFace::\");\n        switch (value) {\n        case FrontFace::CCW:\n        s->Append(\"CCW\");\n        break;\n        case FrontFace::CW:\n        s->Append(\"CW\");\n        break;\n            default:\n            s->Append(absl::StrFormat(\"%x\", static_cast<typename std::underlying_type<FrontFace>::type>(value)));\n        }\n        return {true};\n    }\n    absl::FormatConvertResult<absl::FormatConversionCharSet::kString>\n    AbslFormatConvert(IndexFormat value,\n                        const absl::FormatConversionSpec& spec,\n                        absl::FormatSink* s) {\n        s->Append(\"IndexFormat::\");\n        switch (value) {\n        case IndexFormat::Undefined:\n        s->Append(\"Undefined\");\n        break;\n        case IndexFormat::Uint16:\n        s->Append(\"Uint16\");\n        break;\n        case IndexFormat::Uint32:\n        s->Append(\"Uint32\");\n        break;\n            default:\n            s->Append(absl::StrFormat(\"%x\", static_cast<typename std::underlying_type<IndexFormat>::type>(value)));\n        }\n        return {true};\n    }\n    absl::FormatConvertResult<absl::FormatConversionCharSet::kString>\n    AbslFormatConvert(LoadOp value,\n                        const absl::FormatConversionSpec& spec,\n                        absl::FormatSink* s) {\n        s->Append(\"LoadOp::\");\n        switch (value) {\n        case LoadOp::Undefined:\n        s->Append(\"Undefined\");\n        break;\n        case LoadOp::Clear:\n        s->Append(\"Clear\");\n        break;\n        case LoadOp::Load:\n        s->Append(\"Load\");\n        break;\n            default:\n            s->Append(absl::StrFormat(\"%x\", static_cast<typename std::underlying_type<LoadOp>::type>(value)));\n        }\n        return {true};\n    }\n    absl::FormatConvertResult<absl::FormatConversionCharSet::kString>\n    AbslFormatConvert(LoggingType value,\n                        const absl::FormatConversionSpec& spec,\n                        absl::FormatSink* s) {\n        s->Append(\"LoggingType::\");\n        switch (value) {\n        case LoggingType::Verbose:\n        s->Append(\"Verbose\");\n        break;\n        case LoggingType::Info:\n        s->Append(\"Info\");\n        break;\n        case LoggingType::Warning:\n        s->Append(\"Warning\");\n        break;\n        case LoggingType::Error:\n        s->Append(\"Error\");\n        break;\n            default:\n            s->Append(absl::StrFormat(\"%x\", static_cast<typename std::underlying_type<LoggingType>::type>(value)));\n        }\n        return {true};\n    }\n    absl::FormatConvertResult<absl::FormatConversionCharSet::kString>\n    AbslFormatConvert(PipelineStatisticName value,\n                        const absl::FormatConversionSpec& spec,\n                        absl::FormatSink* s) {\n        s->Append(\"PipelineStatisticName::\");\n        switch (value) {\n        case PipelineStatisticName::VertexShaderInvocations:\n        s->Append(\"VertexShaderInvocations\");\n        break;\n        case PipelineStatisticName::ClipperInvocations:\n        s->Append(\"ClipperInvocations\");\n        break;\n        case PipelineStatisticName::ClipperPrimitivesOut:\n        s->Append(\"ClipperPrimitivesOut\");\n        break;\n        case PipelineStatisticName::FragmentShaderInvocations:\n        s->Append(\"FragmentShaderInvocations\");\n        break;\n        case PipelineStatisticName::ComputeShaderInvocations:\n        s->Append(\"ComputeShaderInvocations\");\n        break;\n            default:\n            s->Append(absl::StrFormat(\"%x\", static_cast<typename std::underlying_type<PipelineStatisticName>::type>(value)));\n        }\n        return {true};\n    }\n    absl::FormatConvertResult<absl::FormatConversionCharSet::kString>\n    AbslFormatConvert(PowerPreference value,\n                        const absl::FormatConversionSpec& spec,\n                        absl::FormatSink* s) {\n        s->Append(\"PowerPreference::\");\n        switch (value) {\n        case PowerPreference::Undefined:\n        s->Append(\"Undefined\");\n        break;\n        case PowerPreference::LowPower:\n        s->Append(\"LowPower\");\n        break;\n        case PowerPreference::HighPerformance:\n        s->Append(\"HighPerformance\");\n        break;\n            default:\n            s->Append(absl::StrFormat(\"%x\", static_cast<typename std::underlying_type<PowerPreference>::type>(value)));\n        }\n        return {true};\n    }\n    absl::FormatConvertResult<absl::FormatConversionCharSet::kString>\n    AbslFormatConvert(PredefinedColorSpace value,\n                        const absl::FormatConversionSpec& spec,\n                        absl::FormatSink* s) {\n        s->Append(\"PredefinedColorSpace::\");\n        switch (value) {\n        case PredefinedColorSpace::Undefined:\n        s->Append(\"Undefined\");\n        break;\n        case PredefinedColorSpace::Srgb:\n        s->Append(\"Srgb\");\n        break;\n            default:\n            s->Append(absl::StrFormat(\"%x\", static_cast<typename std::underlying_type<PredefinedColorSpace>::type>(value)));\n        }\n        return {true};\n    }\n    absl::FormatConvertResult<absl::FormatConversionCharSet::kString>\n    AbslFormatConvert(PresentMode value,\n                        const absl::FormatConversionSpec& spec,\n                        absl::FormatSink* s) {\n        s->Append(\"PresentMode::\");\n        switch (value) {\n        case PresentMode::Immediate:\n        s->Append(\"Immediate\");\n        break;\n        case PresentMode::Mailbox:\n        s->Append(\"Mailbox\");\n        break;\n        case PresentMode::Fifo:\n        s->Append(\"Fifo\");\n        break;\n            default:\n            s->Append(absl::StrFormat(\"%x\", static_cast<typename std::underlying_type<PresentMode>::type>(value)));\n        }\n        return {true};\n    }\n    absl::FormatConvertResult<absl::FormatConversionCharSet::kString>\n    AbslFormatConvert(PrimitiveTopology value,\n                        const absl::FormatConversionSpec& spec,\n                        absl::FormatSink* s) {\n        s->Append(\"PrimitiveTopology::\");\n        switch (value) {\n        case PrimitiveTopology::PointList:\n        s->Append(\"PointList\");\n        break;\n        case PrimitiveTopology::LineList:\n        s->Append(\"LineList\");\n        break;\n        case PrimitiveTopology::LineStrip:\n        s->Append(\"LineStrip\");\n        break;\n        case PrimitiveTopology::TriangleList:\n        s->Append(\"TriangleList\");\n        break;\n        case PrimitiveTopology::TriangleStrip:\n        s->Append(\"TriangleStrip\");\n        break;\n            default:\n            s->Append(absl::StrFormat(\"%x\", static_cast<typename std::underlying_type<PrimitiveTopology>::type>(value)));\n        }\n        return {true};\n    }\n    absl::FormatConvertResult<absl::FormatConversionCharSet::kString>\n    AbslFormatConvert(QueryType value,\n                        const absl::FormatConversionSpec& spec,\n                        absl::FormatSink* s) {\n        s->Append(\"QueryType::\");\n        switch (value) {\n        case QueryType::Occlusion:\n        s->Append(\"Occlusion\");\n        break;\n        case QueryType::PipelineStatistics:\n        s->Append(\"PipelineStatistics\");\n        break;\n        case QueryType::Timestamp:\n        s->Append(\"Timestamp\");\n        break;\n            default:\n            s->Append(absl::StrFormat(\"%x\", static_cast<typename std::underlying_type<QueryType>::type>(value)));\n        }\n        return {true};\n    }\n    absl::FormatConvertResult<absl::FormatConversionCharSet::kString>\n    AbslFormatConvert(QueueWorkDoneStatus value,\n                        const absl::FormatConversionSpec& spec,\n                        absl::FormatSink* s) {\n        s->Append(\"QueueWorkDoneStatus::\");\n        switch (value) {\n        case QueueWorkDoneStatus::Success:\n        s->Append(\"Success\");\n        break;\n        case QueueWorkDoneStatus::Error:\n        s->Append(\"Error\");\n        break;\n        case QueueWorkDoneStatus::Unknown:\n        s->Append(\"Unknown\");\n        break;\n        case QueueWorkDoneStatus::DeviceLost:\n        s->Append(\"DeviceLost\");\n        break;\n            default:\n            s->Append(absl::StrFormat(\"%x\", static_cast<typename std::underlying_type<QueueWorkDoneStatus>::type>(value)));\n        }\n        return {true};\n    }\n    absl::FormatConvertResult<absl::FormatConversionCharSet::kString>\n    AbslFormatConvert(RequestAdapterStatus value,\n                        const absl::FormatConversionSpec& spec,\n                        absl::FormatSink* s) {\n        s->Append(\"RequestAdapterStatus::\");\n        switch (value) {\n        case RequestAdapterStatus::Success:\n        s->Append(\"Success\");\n        break;\n        case RequestAdapterStatus::Unavailable:\n        s->Append(\"Unavailable\");\n        break;\n        case RequestAdapterStatus::Error:\n        s->Append(\"Error\");\n        break;\n        case RequestAdapterStatus::Unknown:\n        s->Append(\"Unknown\");\n        break;\n            default:\n            s->Append(absl::StrFormat(\"%x\", static_cast<typename std::underlying_type<RequestAdapterStatus>::type>(value)));\n        }\n        return {true};\n    }\n    absl::FormatConvertResult<absl::FormatConversionCharSet::kString>\n    AbslFormatConvert(RequestDeviceStatus value,\n                        const absl::FormatConversionSpec& spec,\n                        absl::FormatSink* s) {\n        s->Append(\"RequestDeviceStatus::\");\n        switch (value) {\n        case RequestDeviceStatus::Success:\n        s->Append(\"Success\");\n        break;\n        case RequestDeviceStatus::Error:\n        s->Append(\"Error\");\n        break;\n        case RequestDeviceStatus::Unknown:\n        s->Append(\"Unknown\");\n        break;\n            default:\n            s->Append(absl::StrFormat(\"%x\", static_cast<typename std::underlying_type<RequestDeviceStatus>::type>(value)));\n        }\n        return {true};\n    }\n    absl::FormatConvertResult<absl::FormatConversionCharSet::kString>\n    AbslFormatConvert(SType value,\n                        const absl::FormatConversionSpec& spec,\n                        absl::FormatSink* s) {\n        s->Append(\"SType::\");\n        switch (value) {\n        case SType::Invalid:\n        s->Append(\"Invalid\");\n        break;\n        case SType::SurfaceDescriptorFromMetalLayer:\n        s->Append(\"SurfaceDescriptorFromMetalLayer\");\n        break;\n        case SType::SurfaceDescriptorFromWindowsHWND:\n        s->Append(\"SurfaceDescriptorFromWindowsHWND\");\n        break;\n        case SType::SurfaceDescriptorFromXlibWindow:\n        s->Append(\"SurfaceDescriptorFromXlibWindow\");\n        break;\n        case SType::SurfaceDescriptorFromCanvasHTMLSelector:\n        s->Append(\"SurfaceDescriptorFromCanvasHTMLSelector\");\n        break;\n        case SType::ShaderModuleSPIRVDescriptor:\n        s->Append(\"ShaderModuleSPIRVDescriptor\");\n        break;\n        case SType::ShaderModuleWGSLDescriptor:\n        s->Append(\"ShaderModuleWGSLDescriptor\");\n        break;\n        case SType::SurfaceDescriptorFromWindowsCoreWindow:\n        s->Append(\"SurfaceDescriptorFromWindowsCoreWindow\");\n        break;\n        case SType::ExternalTextureBindingEntry:\n        s->Append(\"ExternalTextureBindingEntry\");\n        break;\n        case SType::ExternalTextureBindingLayout:\n        s->Append(\"ExternalTextureBindingLayout\");\n        break;\n        case SType::SurfaceDescriptorFromWindowsSwapChainPanel:\n        s->Append(\"SurfaceDescriptorFromWindowsSwapChainPanel\");\n        break;\n        case SType::DawnTextureInternalUsageDescriptor:\n        s->Append(\"DawnTextureInternalUsageDescriptor\");\n        break;\n        case SType::PrimitiveDepthClampingState:\n        s->Append(\"PrimitiveDepthClampingState\");\n        break;\n        case SType::DawnTogglesDeviceDescriptor:\n        s->Append(\"DawnTogglesDeviceDescriptor\");\n        break;\n        case SType::DawnEncoderInternalUsageDescriptor:\n        s->Append(\"DawnEncoderInternalUsageDescriptor\");\n        break;\n        case SType::DawnInstanceDescriptor:\n        s->Append(\"DawnInstanceDescriptor\");\n        break;\n            default:\n            s->Append(absl::StrFormat(\"%x\", static_cast<typename std::underlying_type<SType>::type>(value)));\n        }\n        return {true};\n    }\n    absl::FormatConvertResult<absl::FormatConversionCharSet::kString>\n    AbslFormatConvert(SamplerBindingType value,\n                        const absl::FormatConversionSpec& spec,\n                        absl::FormatSink* s) {\n        s->Append(\"SamplerBindingType::\");\n        switch (value) {\n        case SamplerBindingType::Undefined:\n        s->Append(\"Undefined\");\n        break;\n        case SamplerBindingType::Filtering:\n        s->Append(\"Filtering\");\n        break;\n        case SamplerBindingType::NonFiltering:\n        s->Append(\"NonFiltering\");\n        break;\n        case SamplerBindingType::Comparison:\n        s->Append(\"Comparison\");\n        break;\n            default:\n            s->Append(absl::StrFormat(\"%x\", static_cast<typename std::underlying_type<SamplerBindingType>::type>(value)));\n        }\n        return {true};\n    }\n    absl::FormatConvertResult<absl::FormatConversionCharSet::kString>\n    AbslFormatConvert(StencilOperation value,\n                        const absl::FormatConversionSpec& spec,\n                        absl::FormatSink* s) {\n        s->Append(\"StencilOperation::\");\n        switch (value) {\n        case StencilOperation::Keep:\n        s->Append(\"Keep\");\n        break;\n        case StencilOperation::Zero:\n        s->Append(\"Zero\");\n        break;\n        case StencilOperation::Replace:\n        s->Append(\"Replace\");\n        break;\n        case StencilOperation::Invert:\n        s->Append(\"Invert\");\n        break;\n        case StencilOperation::IncrementClamp:\n        s->Append(\"IncrementClamp\");\n        break;\n        case StencilOperation::DecrementClamp:\n        s->Append(\"DecrementClamp\");\n        break;\n        case StencilOperation::IncrementWrap:\n        s->Append(\"IncrementWrap\");\n        break;\n        case StencilOperation::DecrementWrap:\n        s->Append(\"DecrementWrap\");\n        break;\n            default:\n            s->Append(absl::StrFormat(\"%x\", static_cast<typename std::underlying_type<StencilOperation>::type>(value)));\n        }\n        return {true};\n    }\n    absl::FormatConvertResult<absl::FormatConversionCharSet::kString>\n    AbslFormatConvert(StorageTextureAccess value,\n                        const absl::FormatConversionSpec& spec,\n                        absl::FormatSink* s) {\n        s->Append(\"StorageTextureAccess::\");\n        switch (value) {\n        case StorageTextureAccess::Undefined:\n        s->Append(\"Undefined\");\n        break;\n        case StorageTextureAccess::WriteOnly:\n        s->Append(\"WriteOnly\");\n        break;\n            default:\n            s->Append(absl::StrFormat(\"%x\", static_cast<typename std::underlying_type<StorageTextureAccess>::type>(value)));\n        }\n        return {true};\n    }\n    absl::FormatConvertResult<absl::FormatConversionCharSet::kString>\n    AbslFormatConvert(StoreOp value,\n                        const absl::FormatConversionSpec& spec,\n                        absl::FormatSink* s) {\n        s->Append(\"StoreOp::\");\n        switch (value) {\n        case StoreOp::Undefined:\n        s->Append(\"Undefined\");\n        break;\n        case StoreOp::Store:\n        s->Append(\"Store\");\n        break;\n        case StoreOp::Discard:\n        s->Append(\"Discard\");\n        break;\n            default:\n            s->Append(absl::StrFormat(\"%x\", static_cast<typename std::underlying_type<StoreOp>::type>(value)));\n        }\n        return {true};\n    }\n    absl::FormatConvertResult<absl::FormatConversionCharSet::kString>\n    AbslFormatConvert(TextureAspect value,\n                        const absl::FormatConversionSpec& spec,\n                        absl::FormatSink* s) {\n        s->Append(\"TextureAspect::\");\n        switch (value) {\n        case TextureAspect::All:\n        s->Append(\"All\");\n        break;\n        case TextureAspect::StencilOnly:\n        s->Append(\"StencilOnly\");\n        break;\n        case TextureAspect::DepthOnly:\n        s->Append(\"DepthOnly\");\n        break;\n        case TextureAspect::Plane0Only:\n        s->Append(\"Plane0Only\");\n        break;\n        case TextureAspect::Plane1Only:\n        s->Append(\"Plane1Only\");\n        break;\n            default:\n            s->Append(absl::StrFormat(\"%x\", static_cast<typename std::underlying_type<TextureAspect>::type>(value)));\n        }\n        return {true};\n    }\n    absl::FormatConvertResult<absl::FormatConversionCharSet::kString>\n    AbslFormatConvert(TextureComponentType value,\n                        const absl::FormatConversionSpec& spec,\n                        absl::FormatSink* s) {\n        s->Append(\"TextureComponentType::\");\n        switch (value) {\n        case TextureComponentType::Float:\n        s->Append(\"Float\");\n        break;\n        case TextureComponentType::Sint:\n        s->Append(\"Sint\");\n        break;\n        case TextureComponentType::Uint:\n        s->Append(\"Uint\");\n        break;\n        case TextureComponentType::DepthComparison:\n        s->Append(\"DepthComparison\");\n        break;\n            default:\n            s->Append(absl::StrFormat(\"%x\", static_cast<typename std::underlying_type<TextureComponentType>::type>(value)));\n        }\n        return {true};\n    }\n    absl::FormatConvertResult<absl::FormatConversionCharSet::kString>\n    AbslFormatConvert(TextureDimension value,\n                        const absl::FormatConversionSpec& spec,\n                        absl::FormatSink* s) {\n        s->Append(\"TextureDimension::\");\n        switch (value) {\n        case TextureDimension::e1D:\n        s->Append(\"e1D\");\n        break;\n        case TextureDimension::e2D:\n        s->Append(\"e2D\");\n        break;\n        case TextureDimension::e3D:\n        s->Append(\"e3D\");\n        break;\n            default:\n            s->Append(absl::StrFormat(\"%x\", static_cast<typename std::underlying_type<TextureDimension>::type>(value)));\n        }\n        return {true};\n    }\n    absl::FormatConvertResult<absl::FormatConversionCharSet::kString>\n    AbslFormatConvert(TextureFormat value,\n                        const absl::FormatConversionSpec& spec,\n                        absl::FormatSink* s) {\n        s->Append(\"TextureFormat::\");\n        switch (value) {\n        case TextureFormat::Undefined:\n        s->Append(\"Undefined\");\n        break;\n        case TextureFormat::R8Unorm:\n        s->Append(\"R8Unorm\");\n        break;\n        case TextureFormat::R8Snorm:\n        s->Append(\"R8Snorm\");\n        break;\n        case TextureFormat::R8Uint:\n        s->Append(\"R8Uint\");\n        break;\n        case TextureFormat::R8Sint:\n        s->Append(\"R8Sint\");\n        break;\n        case TextureFormat::R16Uint:\n        s->Append(\"R16Uint\");\n        break;\n        case TextureFormat::R16Sint:\n        s->Append(\"R16Sint\");\n        break;\n        case TextureFormat::R16Float:\n        s->Append(\"R16Float\");\n        break;\n        case TextureFormat::RG8Unorm:\n        s->Append(\"RG8Unorm\");\n        break;\n        case TextureFormat::RG8Snorm:\n        s->Append(\"RG8Snorm\");\n        break;\n        case TextureFormat::RG8Uint:\n        s->Append(\"RG8Uint\");\n        break;\n        case TextureFormat::RG8Sint:\n        s->Append(\"RG8Sint\");\n        break;\n        case TextureFormat::R32Float:\n        s->Append(\"R32Float\");\n        break;\n        case TextureFormat::R32Uint:\n        s->Append(\"R32Uint\");\n        break;\n        case TextureFormat::R32Sint:\n        s->Append(\"R32Sint\");\n        break;\n        case TextureFormat::RG16Uint:\n        s->Append(\"RG16Uint\");\n        break;\n        case TextureFormat::RG16Sint:\n        s->Append(\"RG16Sint\");\n        break;\n        case TextureFormat::RG16Float:\n        s->Append(\"RG16Float\");\n        break;\n        case TextureFormat::RGBA8Unorm:\n        s->Append(\"RGBA8Unorm\");\n        break;\n        case TextureFormat::RGBA8UnormSrgb:\n        s->Append(\"RGBA8UnormSrgb\");\n        break;\n        case TextureFormat::RGBA8Snorm:\n        s->Append(\"RGBA8Snorm\");\n        break;\n        case TextureFormat::RGBA8Uint:\n        s->Append(\"RGBA8Uint\");\n        break;\n        case TextureFormat::RGBA8Sint:\n        s->Append(\"RGBA8Sint\");\n        break;\n        case TextureFormat::BGRA8Unorm:\n        s->Append(\"BGRA8Unorm\");\n        break;\n        case TextureFormat::BGRA8UnormSrgb:\n        s->Append(\"BGRA8UnormSrgb\");\n        break;\n        case TextureFormat::RGB10A2Unorm:\n        s->Append(\"RGB10A2Unorm\");\n        break;\n        case TextureFormat::RG11B10Ufloat:\n        s->Append(\"RG11B10Ufloat\");\n        break;\n        case TextureFormat::RGB9E5Ufloat:\n        s->Append(\"RGB9E5Ufloat\");\n        break;\n        case TextureFormat::RG32Float:\n        s->Append(\"RG32Float\");\n        break;\n        case TextureFormat::RG32Uint:\n        s->Append(\"RG32Uint\");\n        break;\n        case TextureFormat::RG32Sint:\n        s->Append(\"RG32Sint\");\n        break;\n        case TextureFormat::RGBA16Uint:\n        s->Append(\"RGBA16Uint\");\n        break;\n        case TextureFormat::RGBA16Sint:\n        s->Append(\"RGBA16Sint\");\n        break;\n        case TextureFormat::RGBA16Float:\n        s->Append(\"RGBA16Float\");\n        break;\n        case TextureFormat::RGBA32Float:\n        s->Append(\"RGBA32Float\");\n        break;\n        case TextureFormat::RGBA32Uint:\n        s->Append(\"RGBA32Uint\");\n        break;\n        case TextureFormat::RGBA32Sint:\n        s->Append(\"RGBA32Sint\");\n        break;\n        case TextureFormat::Stencil8:\n        s->Append(\"Stencil8\");\n        break;\n        case TextureFormat::Depth16Unorm:\n        s->Append(\"Depth16Unorm\");\n        break;\n        case TextureFormat::Depth24Plus:\n        s->Append(\"Depth24Plus\");\n        break;\n        case TextureFormat::Depth24PlusStencil8:\n        s->Append(\"Depth24PlusStencil8\");\n        break;\n        case TextureFormat::Depth24UnormStencil8:\n        s->Append(\"Depth24UnormStencil8\");\n        break;\n        case TextureFormat::Depth32Float:\n        s->Append(\"Depth32Float\");\n        break;\n        case TextureFormat::Depth32FloatStencil8:\n        s->Append(\"Depth32FloatStencil8\");\n        break;\n        case TextureFormat::BC1RGBAUnorm:\n        s->Append(\"BC1RGBAUnorm\");\n        break;\n        case TextureFormat::BC1RGBAUnormSrgb:\n        s->Append(\"BC1RGBAUnormSrgb\");\n        break;\n        case TextureFormat::BC2RGBAUnorm:\n        s->Append(\"BC2RGBAUnorm\");\n        break;\n        case TextureFormat::BC2RGBAUnormSrgb:\n        s->Append(\"BC2RGBAUnormSrgb\");\n        break;\n        case TextureFormat::BC3RGBAUnorm:\n        s->Append(\"BC3RGBAUnorm\");\n        break;\n        case TextureFormat::BC3RGBAUnormSrgb:\n        s->Append(\"BC3RGBAUnormSrgb\");\n        break;\n        case TextureFormat::BC4RUnorm:\n        s->Append(\"BC4RUnorm\");\n        break;\n        case TextureFormat::BC4RSnorm:\n        s->Append(\"BC4RSnorm\");\n        break;\n        case TextureFormat::BC5RGUnorm:\n        s->Append(\"BC5RGUnorm\");\n        break;\n        case TextureFormat::BC5RGSnorm:\n        s->Append(\"BC5RGSnorm\");\n        break;\n        case TextureFormat::BC6HRGBUfloat:\n        s->Append(\"BC6HRGBUfloat\");\n        break;\n        case TextureFormat::BC6HRGBFloat:\n        s->Append(\"BC6HRGBFloat\");\n        break;\n        case TextureFormat::BC7RGBAUnorm:\n        s->Append(\"BC7RGBAUnorm\");\n        break;\n        case TextureFormat::BC7RGBAUnormSrgb:\n        s->Append(\"BC7RGBAUnormSrgb\");\n        break;\n        case TextureFormat::ETC2RGB8Unorm:\n        s->Append(\"ETC2RGB8Unorm\");\n        break;\n        case TextureFormat::ETC2RGB8UnormSrgb:\n        s->Append(\"ETC2RGB8UnormSrgb\");\n        break;\n        case TextureFormat::ETC2RGB8A1Unorm:\n        s->Append(\"ETC2RGB8A1Unorm\");\n        break;\n        case TextureFormat::ETC2RGB8A1UnormSrgb:\n        s->Append(\"ETC2RGB8A1UnormSrgb\");\n        break;\n        case TextureFormat::ETC2RGBA8Unorm:\n        s->Append(\"ETC2RGBA8Unorm\");\n        break;\n        case TextureFormat::ETC2RGBA8UnormSrgb:\n        s->Append(\"ETC2RGBA8UnormSrgb\");\n        break;\n        case TextureFormat::EACR11Unorm:\n        s->Append(\"EACR11Unorm\");\n        break;\n        case TextureFormat::EACR11Snorm:\n        s->Append(\"EACR11Snorm\");\n        break;\n        case TextureFormat::EACRG11Unorm:\n        s->Append(\"EACRG11Unorm\");\n        break;\n        case TextureFormat::EACRG11Snorm:\n        s->Append(\"EACRG11Snorm\");\n        break;\n        case TextureFormat::ASTC4x4Unorm:\n        s->Append(\"ASTC4x4Unorm\");\n        break;\n        case TextureFormat::ASTC4x4UnormSrgb:\n        s->Append(\"ASTC4x4UnormSrgb\");\n        break;\n        case TextureFormat::ASTC5x4Unorm:\n        s->Append(\"ASTC5x4Unorm\");\n        break;\n        case TextureFormat::ASTC5x4UnormSrgb:\n        s->Append(\"ASTC5x4UnormSrgb\");\n        break;\n        case TextureFormat::ASTC5x5Unorm:\n        s->Append(\"ASTC5x5Unorm\");\n        break;\n        case TextureFormat::ASTC5x5UnormSrgb:\n        s->Append(\"ASTC5x5UnormSrgb\");\n        break;\n        case TextureFormat::ASTC6x5Unorm:\n        s->Append(\"ASTC6x5Unorm\");\n        break;\n        case TextureFormat::ASTC6x5UnormSrgb:\n        s->Append(\"ASTC6x5UnormSrgb\");\n        break;\n        case TextureFormat::ASTC6x6Unorm:\n        s->Append(\"ASTC6x6Unorm\");\n        break;\n        case TextureFormat::ASTC6x6UnormSrgb:\n        s->Append(\"ASTC6x6UnormSrgb\");\n        break;\n        case TextureFormat::ASTC8x5Unorm:\n        s->Append(\"ASTC8x5Unorm\");\n        break;\n        case TextureFormat::ASTC8x5UnormSrgb:\n        s->Append(\"ASTC8x5UnormSrgb\");\n        break;\n        case TextureFormat::ASTC8x6Unorm:\n        s->Append(\"ASTC8x6Unorm\");\n        break;\n        case TextureFormat::ASTC8x6UnormSrgb:\n        s->Append(\"ASTC8x6UnormSrgb\");\n        break;\n        case TextureFormat::ASTC8x8Unorm:\n        s->Append(\"ASTC8x8Unorm\");\n        break;\n        case TextureFormat::ASTC8x8UnormSrgb:\n        s->Append(\"ASTC8x8UnormSrgb\");\n        break;\n        case TextureFormat::ASTC10x5Unorm:\n        s->Append(\"ASTC10x5Unorm\");\n        break;\n        case TextureFormat::ASTC10x5UnormSrgb:\n        s->Append(\"ASTC10x5UnormSrgb\");\n        break;\n        case TextureFormat::ASTC10x6Unorm:\n        s->Append(\"ASTC10x6Unorm\");\n        break;\n        case TextureFormat::ASTC10x6UnormSrgb:\n        s->Append(\"ASTC10x6UnormSrgb\");\n        break;\n        case TextureFormat::ASTC10x8Unorm:\n        s->Append(\"ASTC10x8Unorm\");\n        break;\n        case TextureFormat::ASTC10x8UnormSrgb:\n        s->Append(\"ASTC10x8UnormSrgb\");\n        break;\n        case TextureFormat::ASTC10x10Unorm:\n        s->Append(\"ASTC10x10Unorm\");\n        break;\n        case TextureFormat::ASTC10x10UnormSrgb:\n        s->Append(\"ASTC10x10UnormSrgb\");\n        break;\n        case TextureFormat::ASTC12x10Unorm:\n        s->Append(\"ASTC12x10Unorm\");\n        break;\n        case TextureFormat::ASTC12x10UnormSrgb:\n        s->Append(\"ASTC12x10UnormSrgb\");\n        break;\n        case TextureFormat::ASTC12x12Unorm:\n        s->Append(\"ASTC12x12Unorm\");\n        break;\n        case TextureFormat::ASTC12x12UnormSrgb:\n        s->Append(\"ASTC12x12UnormSrgb\");\n        break;\n        case TextureFormat::R8BG8Biplanar420Unorm:\n        s->Append(\"R8BG8Biplanar420Unorm\");\n        break;\n            default:\n            s->Append(absl::StrFormat(\"%x\", static_cast<typename std::underlying_type<TextureFormat>::type>(value)));\n        }\n        return {true};\n    }\n    absl::FormatConvertResult<absl::FormatConversionCharSet::kString>\n    AbslFormatConvert(TextureSampleType value,\n                        const absl::FormatConversionSpec& spec,\n                        absl::FormatSink* s) {\n        s->Append(\"TextureSampleType::\");\n        switch (value) {\n        case TextureSampleType::Undefined:\n        s->Append(\"Undefined\");\n        break;\n        case TextureSampleType::Float:\n        s->Append(\"Float\");\n        break;\n        case TextureSampleType::UnfilterableFloat:\n        s->Append(\"UnfilterableFloat\");\n        break;\n        case TextureSampleType::Depth:\n        s->Append(\"Depth\");\n        break;\n        case TextureSampleType::Sint:\n        s->Append(\"Sint\");\n        break;\n        case TextureSampleType::Uint:\n        s->Append(\"Uint\");\n        break;\n            default:\n            s->Append(absl::StrFormat(\"%x\", static_cast<typename std::underlying_type<TextureSampleType>::type>(value)));\n        }\n        return {true};\n    }\n    absl::FormatConvertResult<absl::FormatConversionCharSet::kString>\n    AbslFormatConvert(TextureViewDimension value,\n                        const absl::FormatConversionSpec& spec,\n                        absl::FormatSink* s) {\n        s->Append(\"TextureViewDimension::\");\n        switch (value) {\n        case TextureViewDimension::Undefined:\n        s->Append(\"Undefined\");\n        break;\n        case TextureViewDimension::e1D:\n        s->Append(\"e1D\");\n        break;\n        case TextureViewDimension::e2D:\n        s->Append(\"e2D\");\n        break;\n        case TextureViewDimension::e2DArray:\n        s->Append(\"e2DArray\");\n        break;\n        case TextureViewDimension::Cube:\n        s->Append(\"Cube\");\n        break;\n        case TextureViewDimension::CubeArray:\n        s->Append(\"CubeArray\");\n        break;\n        case TextureViewDimension::e3D:\n        s->Append(\"e3D\");\n        break;\n            default:\n            s->Append(absl::StrFormat(\"%x\", static_cast<typename std::underlying_type<TextureViewDimension>::type>(value)));\n        }\n        return {true};\n    }\n    absl::FormatConvertResult<absl::FormatConversionCharSet::kString>\n    AbslFormatConvert(VertexFormat value,\n                        const absl::FormatConversionSpec& spec,\n                        absl::FormatSink* s) {\n        s->Append(\"VertexFormat::\");\n        switch (value) {\n        case VertexFormat::Undefined:\n        s->Append(\"Undefined\");\n        break;\n        case VertexFormat::Uint8x2:\n        s->Append(\"Uint8x2\");\n        break;\n        case VertexFormat::Uint8x4:\n        s->Append(\"Uint8x4\");\n        break;\n        case VertexFormat::Sint8x2:\n        s->Append(\"Sint8x2\");\n        break;\n        case VertexFormat::Sint8x4:\n        s->Append(\"Sint8x4\");\n        break;\n        case VertexFormat::Unorm8x2:\n        s->Append(\"Unorm8x2\");\n        break;\n        case VertexFormat::Unorm8x4:\n        s->Append(\"Unorm8x4\");\n        break;\n        case VertexFormat::Snorm8x2:\n        s->Append(\"Snorm8x2\");\n        break;\n        case VertexFormat::Snorm8x4:\n        s->Append(\"Snorm8x4\");\n        break;\n        case VertexFormat::Uint16x2:\n        s->Append(\"Uint16x2\");\n        break;\n        case VertexFormat::Uint16x4:\n        s->Append(\"Uint16x4\");\n        break;\n        case VertexFormat::Sint16x2:\n        s->Append(\"Sint16x2\");\n        break;\n        case VertexFormat::Sint16x4:\n        s->Append(\"Sint16x4\");\n        break;\n        case VertexFormat::Unorm16x2:\n        s->Append(\"Unorm16x2\");\n        break;\n        case VertexFormat::Unorm16x4:\n        s->Append(\"Unorm16x4\");\n        break;\n        case VertexFormat::Snorm16x2:\n        s->Append(\"Snorm16x2\");\n        break;\n        case VertexFormat::Snorm16x4:\n        s->Append(\"Snorm16x4\");\n        break;\n        case VertexFormat::Float16x2:\n        s->Append(\"Float16x2\");\n        break;\n        case VertexFormat::Float16x4:\n        s->Append(\"Float16x4\");\n        break;\n        case VertexFormat::Float32:\n        s->Append(\"Float32\");\n        break;\n        case VertexFormat::Float32x2:\n        s->Append(\"Float32x2\");\n        break;\n        case VertexFormat::Float32x3:\n        s->Append(\"Float32x3\");\n        break;\n        case VertexFormat::Float32x4:\n        s->Append(\"Float32x4\");\n        break;\n        case VertexFormat::Uint32:\n        s->Append(\"Uint32\");\n        break;\n        case VertexFormat::Uint32x2:\n        s->Append(\"Uint32x2\");\n        break;\n        case VertexFormat::Uint32x3:\n        s->Append(\"Uint32x3\");\n        break;\n        case VertexFormat::Uint32x4:\n        s->Append(\"Uint32x4\");\n        break;\n        case VertexFormat::Sint32:\n        s->Append(\"Sint32\");\n        break;\n        case VertexFormat::Sint32x2:\n        s->Append(\"Sint32x2\");\n        break;\n        case VertexFormat::Sint32x3:\n        s->Append(\"Sint32x3\");\n        break;\n        case VertexFormat::Sint32x4:\n        s->Append(\"Sint32x4\");\n        break;\n            default:\n            s->Append(absl::StrFormat(\"%x\", static_cast<typename std::underlying_type<VertexFormat>::type>(value)));\n        }\n        return {true};\n    }\n    absl::FormatConvertResult<absl::FormatConversionCharSet::kString>\n    AbslFormatConvert(VertexStepMode value,\n                        const absl::FormatConversionSpec& spec,\n                        absl::FormatSink* s) {\n        s->Append(\"VertexStepMode::\");\n        switch (value) {\n        case VertexStepMode::Vertex:\n        s->Append(\"Vertex\");\n        break;\n        case VertexStepMode::Instance:\n        s->Append(\"Instance\");\n        break;\n            default:\n            s->Append(absl::StrFormat(\"%x\", static_cast<typename std::underlying_type<VertexStepMode>::type>(value)));\n        }\n        return {true};\n    }\n\n    //\n    // Bitmasks\n    //\n\n    absl::FormatConvertResult<absl::FormatConversionCharSet::kString>\n    AbslFormatConvert(BufferUsage value,\n                        const absl::FormatConversionSpec& spec,\n                        absl::FormatSink* s) {\n        s->Append(\"BufferUsage::\");\n        if (!static_cast<bool>(value)) {\n            // 0 is often explicitly declared as None.\n            s->Append(\"None\");\n            return {true};\n        }\n\n        bool moreThanOneBit = !HasZeroOrOneBits(value);\n        if (moreThanOneBit) {\n            s->Append(\"(\");\n        }\n\n        bool first = true;\n        if (value & BufferUsage::MapRead) {\n            if (!first) {\n                s->Append(\"|\");\n            }\n            first = false;\n            s->Append(\"MapRead\");\n            value &= ~BufferUsage::MapRead;\n        }\n        if (value & BufferUsage::MapWrite) {\n            if (!first) {\n                s->Append(\"|\");\n            }\n            first = false;\n            s->Append(\"MapWrite\");\n            value &= ~BufferUsage::MapWrite;\n        }\n        if (value & BufferUsage::CopySrc) {\n            if (!first) {\n                s->Append(\"|\");\n            }\n            first = false;\n            s->Append(\"CopySrc\");\n            value &= ~BufferUsage::CopySrc;\n        }\n        if (value & BufferUsage::CopyDst) {\n            if (!first) {\n                s->Append(\"|\");\n            }\n            first = false;\n            s->Append(\"CopyDst\");\n            value &= ~BufferUsage::CopyDst;\n        }\n        if (value & BufferUsage::Index) {\n            if (!first) {\n                s->Append(\"|\");\n            }\n            first = false;\n            s->Append(\"Index\");\n            value &= ~BufferUsage::Index;\n        }\n        if (value & BufferUsage::Vertex) {\n            if (!first) {\n                s->Append(\"|\");\n            }\n            first = false;\n            s->Append(\"Vertex\");\n            value &= ~BufferUsage::Vertex;\n        }\n        if (value & BufferUsage::Uniform) {\n            if (!first) {\n                s->Append(\"|\");\n            }\n            first = false;\n            s->Append(\"Uniform\");\n            value &= ~BufferUsage::Uniform;\n        }\n        if (value & BufferUsage::Storage) {\n            if (!first) {\n                s->Append(\"|\");\n            }\n            first = false;\n            s->Append(\"Storage\");\n            value &= ~BufferUsage::Storage;\n        }\n        if (value & BufferUsage::Indirect) {\n            if (!first) {\n                s->Append(\"|\");\n            }\n            first = false;\n            s->Append(\"Indirect\");\n            value &= ~BufferUsage::Indirect;\n        }\n        if (value & BufferUsage::QueryResolve) {\n            if (!first) {\n                s->Append(\"|\");\n            }\n            first = false;\n            s->Append(\"QueryResolve\");\n            value &= ~BufferUsage::QueryResolve;\n        }\n\n        if (static_cast<bool>(value)) {\n            if (!first) {\n                s->Append(\"|\");\n            }\n            s->Append(absl::StrFormat(\"BufferUsage::%x\", static_cast<typename std::underlying_type<BufferUsage>::type>(value)));\n        }\n\n        if (moreThanOneBit) {\n            s->Append(\")\");\n        }\n\n        return {true};\n    }\n    absl::FormatConvertResult<absl::FormatConversionCharSet::kString>\n    AbslFormatConvert(ColorWriteMask value,\n                        const absl::FormatConversionSpec& spec,\n                        absl::FormatSink* s) {\n        s->Append(\"ColorWriteMask::\");\n        if (!static_cast<bool>(value)) {\n            // 0 is often explicitly declared as None.\n            s->Append(\"None\");\n            return {true};\n        }\n\n        bool moreThanOneBit = !HasZeroOrOneBits(value);\n        if (moreThanOneBit) {\n            s->Append(\"(\");\n        }\n\n        bool first = true;\n        if (value & ColorWriteMask::Red) {\n            if (!first) {\n                s->Append(\"|\");\n            }\n            first = false;\n            s->Append(\"Red\");\n            value &= ~ColorWriteMask::Red;\n        }\n        if (value & ColorWriteMask::Green) {\n            if (!first) {\n                s->Append(\"|\");\n            }\n            first = false;\n            s->Append(\"Green\");\n            value &= ~ColorWriteMask::Green;\n        }\n        if (value & ColorWriteMask::Blue) {\n            if (!first) {\n                s->Append(\"|\");\n            }\n            first = false;\n            s->Append(\"Blue\");\n            value &= ~ColorWriteMask::Blue;\n        }\n        if (value & ColorWriteMask::Alpha) {\n            if (!first) {\n                s->Append(\"|\");\n            }\n            first = false;\n            s->Append(\"Alpha\");\n            value &= ~ColorWriteMask::Alpha;\n        }\n        if (value & ColorWriteMask::All) {\n            if (!first) {\n                s->Append(\"|\");\n            }\n            first = false;\n            s->Append(\"All\");\n            value &= ~ColorWriteMask::All;\n        }\n\n        if (static_cast<bool>(value)) {\n            if (!first) {\n                s->Append(\"|\");\n            }\n            s->Append(absl::StrFormat(\"ColorWriteMask::%x\", static_cast<typename std::underlying_type<ColorWriteMask>::type>(value)));\n        }\n\n        if (moreThanOneBit) {\n            s->Append(\")\");\n        }\n\n        return {true};\n    }\n    absl::FormatConvertResult<absl::FormatConversionCharSet::kString>\n    AbslFormatConvert(MapMode value,\n                        const absl::FormatConversionSpec& spec,\n                        absl::FormatSink* s) {\n        s->Append(\"MapMode::\");\n        if (!static_cast<bool>(value)) {\n            // 0 is often explicitly declared as None.\n            s->Append(\"None\");\n            return {true};\n        }\n\n        bool moreThanOneBit = !HasZeroOrOneBits(value);\n        if (moreThanOneBit) {\n            s->Append(\"(\");\n        }\n\n        bool first = true;\n        if (value & MapMode::Read) {\n            if (!first) {\n                s->Append(\"|\");\n            }\n            first = false;\n            s->Append(\"Read\");\n            value &= ~MapMode::Read;\n        }\n        if (value & MapMode::Write) {\n            if (!first) {\n                s->Append(\"|\");\n            }\n            first = false;\n            s->Append(\"Write\");\n            value &= ~MapMode::Write;\n        }\n\n        if (static_cast<bool>(value)) {\n            if (!first) {\n                s->Append(\"|\");\n            }\n            s->Append(absl::StrFormat(\"MapMode::%x\", static_cast<typename std::underlying_type<MapMode>::type>(value)));\n        }\n\n        if (moreThanOneBit) {\n            s->Append(\")\");\n        }\n\n        return {true};\n    }\n    absl::FormatConvertResult<absl::FormatConversionCharSet::kString>\n    AbslFormatConvert(ShaderStage value,\n                        const absl::FormatConversionSpec& spec,\n                        absl::FormatSink* s) {\n        s->Append(\"ShaderStage::\");\n        if (!static_cast<bool>(value)) {\n            // 0 is often explicitly declared as None.\n            s->Append(\"None\");\n            return {true};\n        }\n\n        bool moreThanOneBit = !HasZeroOrOneBits(value);\n        if (moreThanOneBit) {\n            s->Append(\"(\");\n        }\n\n        bool first = true;\n        if (value & ShaderStage::Vertex) {\n            if (!first) {\n                s->Append(\"|\");\n            }\n            first = false;\n            s->Append(\"Vertex\");\n            value &= ~ShaderStage::Vertex;\n        }\n        if (value & ShaderStage::Fragment) {\n            if (!first) {\n                s->Append(\"|\");\n            }\n            first = false;\n            s->Append(\"Fragment\");\n            value &= ~ShaderStage::Fragment;\n        }\n        if (value & ShaderStage::Compute) {\n            if (!first) {\n                s->Append(\"|\");\n            }\n            first = false;\n            s->Append(\"Compute\");\n            value &= ~ShaderStage::Compute;\n        }\n\n        if (static_cast<bool>(value)) {\n            if (!first) {\n                s->Append(\"|\");\n            }\n            s->Append(absl::StrFormat(\"ShaderStage::%x\", static_cast<typename std::underlying_type<ShaderStage>::type>(value)));\n        }\n\n        if (moreThanOneBit) {\n            s->Append(\")\");\n        }\n\n        return {true};\n    }\n    absl::FormatConvertResult<absl::FormatConversionCharSet::kString>\n    AbslFormatConvert(TextureUsage value,\n                        const absl::FormatConversionSpec& spec,\n                        absl::FormatSink* s) {\n        s->Append(\"TextureUsage::\");\n        if (!static_cast<bool>(value)) {\n            // 0 is often explicitly declared as None.\n            s->Append(\"None\");\n            return {true};\n        }\n\n        bool moreThanOneBit = !HasZeroOrOneBits(value);\n        if (moreThanOneBit) {\n            s->Append(\"(\");\n        }\n\n        bool first = true;\n        if (value & TextureUsage::CopySrc) {\n            if (!first) {\n                s->Append(\"|\");\n            }\n            first = false;\n            s->Append(\"CopySrc\");\n            value &= ~TextureUsage::CopySrc;\n        }\n        if (value & TextureUsage::CopyDst) {\n            if (!first) {\n                s->Append(\"|\");\n            }\n            first = false;\n            s->Append(\"CopyDst\");\n            value &= ~TextureUsage::CopyDst;\n        }\n        if (value & TextureUsage::TextureBinding) {\n            if (!first) {\n                s->Append(\"|\");\n            }\n            first = false;\n            s->Append(\"TextureBinding\");\n            value &= ~TextureUsage::TextureBinding;\n        }\n        if (value & TextureUsage::StorageBinding) {\n            if (!first) {\n                s->Append(\"|\");\n            }\n            first = false;\n            s->Append(\"StorageBinding\");\n            value &= ~TextureUsage::StorageBinding;\n        }\n        if (value & TextureUsage::RenderAttachment) {\n            if (!first) {\n                s->Append(\"|\");\n            }\n            first = false;\n            s->Append(\"RenderAttachment\");\n            value &= ~TextureUsage::RenderAttachment;\n        }\n        if (value & TextureUsage::Present) {\n            if (!first) {\n                s->Append(\"|\");\n            }\n            first = false;\n            s->Append(\"Present\");\n            value &= ~TextureUsage::Present;\n        }\n\n        if (static_cast<bool>(value)) {\n            if (!first) {\n                s->Append(\"|\");\n            }\n            s->Append(absl::StrFormat(\"TextureUsage::%x\", static_cast<typename std::underlying_type<TextureUsage>::type>(value)));\n        }\n\n        if (moreThanOneBit) {\n            s->Append(\")\");\n        }\n\n        return {true};\n    }\n\n}  // namespace wgpu\n", "src/dawn/native/ObjectType_autogen.h": "\n#ifndef DAWNNATIVE_OBJECTTPYE_AUTOGEN_H_\n#define DAWNNATIVE_OBJECTTPYE_AUTOGEN_H_\n\n#include \"dawn/common/ityp_array.h\"\n\n#include <cstdint>\n\nnamespace dawn::native {\n\n    enum class ObjectType : uint32_t {\n        Adapter,\n        BindGroup,\n        BindGroupLayout,\n        Buffer,\n        CommandBuffer,\n        CommandEncoder,\n        ComputePassEncoder,\n        ComputePipeline,\n        Device,\n        ExternalTexture,\n        Instance,\n        PipelineLayout,\n        QuerySet,\n        Queue,\n        RenderBundle,\n        RenderBundleEncoder,\n        RenderPassEncoder,\n        RenderPipeline,\n        Sampler,\n        ShaderModule,\n        Surface,\n        SwapChain,\n        Texture,\n        TextureView,\n    };\n\n    template <typename T>\n    using PerObjectType = ityp::array<ObjectType, T, 24>;\n\n    const char* ObjectTypeAsString(ObjectType type);\n\n} // namespace dawn::native\n\n\n#endif  // DAWNNATIVE_OBJECTTPYE_AUTOGEN_H_\n", "src/dawn/native/ObjectType_autogen.cpp": "\n#include \"dawn/native/ObjectType_autogen.h\"\n\nnamespace dawn::native {\n\n    const char* ObjectTypeAsString(ObjectType type) {\n        switch (type) {\n            case ObjectType::Adapter:\n                return \"Adapter\";\n            case ObjectType::BindGroup:\n                return \"BindGroup\";\n            case ObjectType::BindGroupLayout:\n                return \"BindGroupLayout\";\n            case ObjectType::Buffer:\n                return \"Buffer\";\n            case ObjectType::CommandBuffer:\n                return \"CommandBuffer\";\n            case ObjectType::CommandEncoder:\n                return \"CommandEncoder\";\n            case ObjectType::ComputePassEncoder:\n                return \"ComputePassEncoder\";\n            case ObjectType::ComputePipeline:\n                return \"ComputePipeline\";\n            case ObjectType::Device:\n                return \"Device\";\n            case ObjectType::ExternalTexture:\n                return \"ExternalTexture\";\n            case ObjectType::Instance:\n                return \"Instance\";\n            case ObjectType::PipelineLayout:\n                return \"PipelineLayout\";\n            case ObjectType::QuerySet:\n                return \"QuerySet\";\n            case ObjectType::Queue:\n                return \"Queue\";\n            case ObjectType::RenderBundle:\n                return \"RenderBundle\";\n            case ObjectType::RenderBundleEncoder:\n                return \"RenderBundleEncoder\";\n            case ObjectType::RenderPassEncoder:\n                return \"RenderPassEncoder\";\n            case ObjectType::RenderPipeline:\n                return \"RenderPipeline\";\n            case ObjectType::Sampler:\n                return \"Sampler\";\n            case ObjectType::ShaderModule:\n                return \"ShaderModule\";\n            case ObjectType::Surface:\n                return \"Surface\";\n            case ObjectType::SwapChain:\n                return \"SwapChain\";\n            case ObjectType::Texture:\n                return \"Texture\";\n            case ObjectType::TextureView:\n                return \"TextureView\";\n            default:\n                UNREACHABLE();\n        }\n    }\n\n} // namespace dawn::native\n"}