{"include/dawn/webgpu_cpp.h": "#ifndef WEBGPU_CPP_H_\n#define WEBGPU_CPP_H_\n\n#include \"dawn/webgpu.h\"\n#include \"dawn/EnumClassBitmasks.h\"\n#include <cmath>\n\nnamespace wgpu {\n\n    namespace detail {\n        constexpr size_t ConstexprMax(size_t a, size_t b) {\n            return a > b ? a : b;\n        }\n    }  // namespace detail\n\n    static constexpr uint32_t kArrayLayerCountUndefined = WGPU_ARRAY_LAYER_COUNT_UNDEFINED;\n    static constexpr uint32_t kCopyStrideUndefined = WGPU_COPY_STRIDE_UNDEFINED;\n    static constexpr uint32_t kLimitU32Undefined = WGPU_LIMIT_U32_UNDEFINED;\n    static constexpr uint64_t kLimitU64Undefined = WGPU_LIMIT_U64_UNDEFINED;\n    static constexpr uint32_t kMipLevelCountUndefined = WGPU_MIP_LEVEL_COUNT_UNDEFINED;\n    static constexpr uint32_t kStrideUndefined = WGPU_STRIDE_UNDEFINED;\n    static constexpr size_t kWholeMapSize = WGPU_WHOLE_MAP_SIZE;\n    static constexpr uint64_t kWholeSize = WGPU_WHOLE_SIZE;\n\n    enum class AdapterType : uint32_t {\n        DiscreteGPU = 0x00000000,\n        IntegratedGPU = 0x00000001,\n        CPU = 0x00000002,\n        Unknown = 0x00000003,\n    };\n\n    enum class AddressMode : uint32_t {\n        Repeat = 0x00000000,\n        MirrorRepeat = 0x00000001,\n        ClampToEdge = 0x00000002,\n    };\n\n    enum class AlphaMode : uint32_t {\n        Premultiplied = 0x00000000,\n        Unpremultiplied = 0x00000001,\n    };\n\n    enum class BackendType : uint32_t {\n        Null = 0x00000000,\n        WebGPU = 0x00000001,\n        D3D11 = 0x00000002,\n        D3D12 = 0x00000003,\n        Metal = 0x00000004,\n        Vulkan = 0x00000005,\n        OpenGL = 0x00000006,\n        OpenGLES = 0x00000007,\n    };\n\n    enum class BlendFactor : uint32_t {\n        Zero = 0x00000000,\n        One = 0x00000001,\n        Src = 0x00000002,\n        OneMinusSrc = 0x00000003,\n        SrcAlpha = 0x00000004,\n        OneMinusSrcAlpha = 0x00000005,\n        Dst = 0x00000006,\n        OneMinusDst = 0x00000007,\n        DstAlpha = 0x00000008,\n        OneMinusDstAlpha = 0x00000009,\n        SrcAlphaSaturated = 0x0000000A,\n        Constant = 0x0000000B,\n        OneMinusConstant = 0x0000000C,\n    };\n\n    enum class BlendOperation : uint32_t {\n        Add = 0x00000000,\n        Subtract = 0x00000001,\n        ReverseSubtract = 0x00000002,\n        Min = 0x00000003,\n        Max = 0x00000004,\n    };\n\n    enum class BufferBindingType : uint32_t {\n        Undefined = 0x00000000,\n        Uniform = 0x00000001,\n        Storage = 0x00000002,\n        ReadOnlyStorage = 0x00000003,\n    };\n\n    enum class BufferMapAsyncStatus : uint32_t {\n        Success = 0x00000000,\n        Error = 0x00000001,\n        Unknown = 0x00000002,\n        DeviceLost = 0x00000003,\n        DestroyedBeforeCallback = 0x00000004,\n        UnmappedBeforeCallback = 0x00000005,\n    };\n\n    enum class CompareFunction : uint32_t {\n        Undefined = 0x00000000,\n        Never = 0x00000001,\n        Less = 0x00000002,\n        LessEqual = 0x00000003,\n        Greater = 0x00000004,\n        GreaterEqual = 0x00000005,\n        Equal = 0x00000006,\n        NotEqual = 0x00000007,\n        Always = 0x00000008,\n    };\n\n    enum class CompilationInfoRequestStatus : uint32_t {\n        Success = 0x00000000,\n        Error = 0x00000001,\n        DeviceLost = 0x00000002,\n        Unknown = 0x00000003,\n    };\n\n    enum class CompilationMessageType : uint32_t {\n        Error = 0x00000000,\n        Warning = 0x00000001,\n        Info = 0x00000002,\n    };\n\n    enum class ComputePassTimestampLocation : uint32_t {\n        Beginning = 0x00000000,\n        End = 0x00000001,\n    };\n\n    enum class CreatePipelineAsyncStatus : uint32_t {\n        Success = 0x00000000,\n        Error = 0x00000001,\n        DeviceLost = 0x00000002,\n        DeviceDestroyed = 0x00000003,\n        Unknown = 0x00000004,\n    };\n\n    enum class CullMode : uint32_t {\n        None = 0x00000000,\n        Front = 0x00000001,\n        Back = 0x00000002,\n    };\n\n    enum class DeviceLostReason : uint32_t {\n        Undefined = 0x00000000,\n        Destroyed = 0x00000001,\n    };\n\n    enum class ErrorFilter : uint32_t {\n        Validation = 0x00000000,\n        OutOfMemory = 0x00000001,\n    };\n\n    enum class ErrorType : uint32_t {\n        NoError = 0x00000000,\n        Validation = 0x00000001,\n        OutOfMemory = 0x00000002,\n        Unknown = 0x00000003,\n        DeviceLost = 0x00000004,\n    };\n\n    enum class FeatureName : uint32_t {\n        Undefined = 0x00000000,\n        DepthClipControl = 0x00000001,\n        Depth32FloatStencil8 = 0x00000002,\n        TimestampQuery = 0x00000003,\n        PipelineStatisticsQuery = 0x00000004,\n        TextureCompressionBC = 0x00000005,\n        TextureCompressionETC2 = 0x00000006,\n        TextureCompressionASTC = 0x00000007,\n        IndirectFirstInstance = 0x00000008,\n        DepthClamping = 0x000003E8,\n        DawnShaderFloat16 = 0x000003E9,\n        DawnInternalUsages = 0x000003EA,\n        DawnMultiPlanarFormats = 0x000003EB,\n        DawnNative = 0x000003EC,\n        ChromiumExperimentalDp4a = 0x000003ED,\n    };\n\n    enum class FilterMode : uint32_t {\n        Nearest = 0x00000000,\n        Linear = 0x00000001,\n    };\n\n    enum class FrontFace : uint32_t {\n        CCW = 0x00000000,\n        CW = 0x00000001,\n    };\n\n    enum class IndexFormat : uint32_t {\n        Undefined = 0x00000000,\n        Uint16 = 0x00000001,\n        Uint32 = 0x00000002,\n    };\n\n    enum class LoadOp : uint32_t {\n        Undefined = 0x00000000,\n        Clear = 0x00000001,\n        Load = 0x00000002,\n    };\n\n    enum class LoggingType : uint32_t {\n        Verbose = 0x00000000,\n        Info = 0x00000001,\n        Warning = 0x00000002,\n        Error = 0x00000003,\n    };\n\n    enum class PipelineStatisticName : uint32_t {\n        VertexShaderInvocations = 0x00000000,\n        ClipperInvocations = 0x00000001,\n        ClipperPrimitivesOut = 0x00000002,\n        FragmentShaderInvocations = 0x00000003,\n        ComputeShaderInvocations = 0x00000004,\n    };\n\n    enum class PowerPreference : uint32_t {\n        Undefined = 0x00000000,\n        LowPower = 0x00000001,\n        HighPerformance = 0x00000002,\n    };\n\n    enum class PresentMode : uint32_t {\n        Immediate = 0x00000000,\n        Mailbox = 0x00000001,\n        Fifo = 0x00000002,\n    };\n\n    enum class PrimitiveTopology : uint32_t {\n        PointList = 0x00000000,\n        LineList = 0x00000001,\n        LineStrip = 0x00000002,\n        TriangleList = 0x00000003,\n        TriangleStrip = 0x00000004,\n    };\n\n    enum class QueryType : uint32_t {\n        Occlusion = 0x00000000,\n        PipelineStatistics = 0x00000001,\n        Timestamp = 0x00000002,\n    };\n\n    enum class QueueWorkDoneStatus : uint32_t {\n        Success = 0x00000000,\n        Error = 0x00000001,\n        Unknown = 0x00000002,\n        DeviceLost = 0x00000003,\n    };\n\n    enum class RenderPassTimestampLocation : uint32_t {\n        Beginning = 0x00000000,\n        End = 0x00000001,\n    };\n\n    enum class RequestAdapterStatus : uint32_t {\n        Success = 0x00000000,\n        Unavailable = 0x00000001,\n        Error = 0x00000002,\n        Unknown = 0x00000003,\n    };\n\n    enum class RequestDeviceStatus : uint32_t {\n        Success = 0x00000000,\n        Error = 0x00000001,\n        Unknown = 0x00000002,\n    };\n\n    enum class SType : uint32_t {\n        Invalid = 0x00000000,\n        SurfaceDescriptorFromMetalLayer = 0x00000001,\n        SurfaceDescriptorFromWindowsHWND = 0x00000002,\n        SurfaceDescriptorFromXlibWindow = 0x00000003,\n        SurfaceDescriptorFromCanvasHTMLSelector = 0x00000004,\n        ShaderModuleSPIRVDescriptor = 0x00000005,\n        ShaderModuleWGSLDescriptor = 0x00000006,\n        PrimitiveDepthClipControl = 0x00000007,\n        SurfaceDescriptorFromWaylandSurface = 0x00000008,\n        SurfaceDescriptorFromAndroidNativeWindow = 0x00000009,\n        SurfaceDescriptorFromWindowsCoreWindow = 0x0000000B,\n        ExternalTextureBindingEntry = 0x0000000C,\n        ExternalTextureBindingLayout = 0x0000000D,\n        SurfaceDescriptorFromWindowsSwapChainPanel = 0x0000000E,\n        RenderPassDescriptorMaxDrawCount = 0x0000000F,\n        DawnTextureInternalUsageDescriptor = 0x000003E8,\n        PrimitiveDepthClampingState = 0x000003E9,\n        DawnTogglesDeviceDescriptor = 0x000003EA,\n        DawnEncoderInternalUsageDescriptor = 0x000003EB,\n        DawnInstanceDescriptor = 0x000003EC,\n        DawnCacheDeviceDescriptor = 0x000003ED,\n    };\n\n    enum class SamplerBindingType : uint32_t {\n        Undefined = 0x00000000,\n        Filtering = 0x00000001,\n        NonFiltering = 0x00000002,\n        Comparison = 0x00000003,\n    };\n\n    enum class StencilOperation : uint32_t {\n        Keep = 0x00000000,\n        Zero = 0x00000001,\n        Replace = 0x00000002,\n        Invert = 0x00000003,\n        IncrementClamp = 0x00000004,\n        DecrementClamp = 0x00000005,\n        IncrementWrap = 0x00000006,\n        DecrementWrap = 0x00000007,\n    };\n\n    enum class StorageTextureAccess : uint32_t {\n        Undefined = 0x00000000,\n        WriteOnly = 0x00000001,\n    };\n\n    enum class StoreOp : uint32_t {\n        Undefined = 0x00000000,\n        Store = 0x00000001,\n        Discard = 0x00000002,\n    };\n\n    enum class TextureAspect : uint32_t {\n        All = 0x00000000,\n        StencilOnly = 0x00000001,\n        DepthOnly = 0x00000002,\n        Plane0Only = 0x00000003,\n        Plane1Only = 0x00000004,\n    };\n\n    enum class TextureComponentType : uint32_t {\n        Float = 0x00000000,\n        Sint = 0x00000001,\n        Uint = 0x00000002,\n        DepthComparison = 0x00000003,\n    };\n\n    enum class TextureDimension : uint32_t {\n        e1D = 0x00000000,\n        e2D = 0x00000001,\n        e3D = 0x00000002,\n    };\n\n    enum class TextureFormat : uint32_t {\n        Undefined = 0x00000000,\n        R8Unorm = 0x00000001,\n        R8Snorm = 0x00000002,\n        R8Uint = 0x00000003,\n        R8Sint = 0x00000004,\n        R16Uint = 0x00000005,\n        R16Sint = 0x00000006,\n        R16Float = 0x00000007,\n        RG8Unorm = 0x00000008,\n        RG8Snorm = 0x00000009,\n        RG8Uint = 0x0000000A,\n        RG8Sint = 0x0000000B,\n        R32Float = 0x0000000C,\n        R32Uint = 0x0000000D,\n        R32Sint = 0x0000000E,\n        RG16Uint = 0x0000000F,\n        RG16Sint = 0x00000010,\n        RG16Float = 0x00000011,\n        RGBA8Unorm = 0x00000012,\n        RGBA8UnormSrgb = 0x00000013,\n        RGBA8Snorm = 0x00000014,\n        RGBA8Uint = 0x00000015,\n        RGBA8Sint = 0x00000016,\n        BGRA8Unorm = 0x00000017,\n        BGRA8UnormSrgb = 0x00000018,\n        RGB10A2Unorm = 0x00000019,\n        RG11B10Ufloat = 0x0000001A,\n        RGB9E5Ufloat = 0x0000001B,\n        RG32Float = 0x0000001C,\n        RG32Uint = 0x0000001D,\n        RG32Sint = 0x0000001E,\n        RGBA16Uint = 0x0000001F,\n        RGBA16Sint = 0x00000020,\n        RGBA16Float = 0x00000021,\n        RGBA32Float = 0x00000022,\n        RGBA32Uint = 0x00000023,\n        RGBA32Sint = 0x00000024,\n        Stencil8 = 0x00000025,\n        Depth16Unorm = 0x00000026,\n        Depth24Plus = 0x00000027,\n        Depth24PlusStencil8 = 0x00000028,\n        Depth32Float = 0x00000029,\n        Depth32FloatStencil8 = 0x0000002A,\n        BC1RGBAUnorm = 0x0000002B,\n        BC1RGBAUnormSrgb = 0x0000002C,\n        BC2RGBAUnorm = 0x0000002D,\n        BC2RGBAUnormSrgb = 0x0000002E,\n        BC3RGBAUnorm = 0x0000002F,\n        BC3RGBAUnormSrgb = 0x00000030,\n        BC4RUnorm = 0x00000031,\n        BC4RSnorm = 0x00000032,\n        BC5RGUnorm = 0x00000033,\n        BC5RGSnorm = 0x00000034,\n        BC6HRGBUfloat = 0x00000035,\n        BC6HRGBFloat = 0x00000036,\n        BC7RGBAUnorm = 0x00000037,\n        BC7RGBAUnormSrgb = 0x00000038,\n        ETC2RGB8Unorm = 0x00000039,\n        ETC2RGB8UnormSrgb = 0x0000003A,\n        ETC2RGB8A1Unorm = 0x0000003B,\n        ETC2RGB8A1UnormSrgb = 0x0000003C,\n        ETC2RGBA8Unorm = 0x0000003D,\n        ETC2RGBA8UnormSrgb = 0x0000003E,\n        EACR11Unorm = 0x0000003F,\n        EACR11Snorm = 0x00000040,\n        EACRG11Unorm = 0x00000041,\n        EACRG11Snorm = 0x00000042,\n        ASTC4x4Unorm = 0x00000043,\n        ASTC4x4UnormSrgb = 0x00000044,\n        ASTC5x4Unorm = 0x00000045,\n        ASTC5x4UnormSrgb = 0x00000046,\n        ASTC5x5Unorm = 0x00000047,\n        ASTC5x5UnormSrgb = 0x00000048,\n        ASTC6x5Unorm = 0x00000049,\n        ASTC6x5UnormSrgb = 0x0000004A,\n        ASTC6x6Unorm = 0x0000004B,\n        ASTC6x6UnormSrgb = 0x0000004C,\n        ASTC8x5Unorm = 0x0000004D,\n        ASTC8x5UnormSrgb = 0x0000004E,\n        ASTC8x6Unorm = 0x0000004F,\n        ASTC8x6UnormSrgb = 0x00000050,\n        ASTC8x8Unorm = 0x00000051,\n        ASTC8x8UnormSrgb = 0x00000052,\n        ASTC10x5Unorm = 0x00000053,\n        ASTC10x5UnormSrgb = 0x00000054,\n        ASTC10x6Unorm = 0x00000055,\n        ASTC10x6UnormSrgb = 0x00000056,\n        ASTC10x8Unorm = 0x00000057,\n        ASTC10x8UnormSrgb = 0x00000058,\n        ASTC10x10Unorm = 0x00000059,\n        ASTC10x10UnormSrgb = 0x0000005A,\n        ASTC12x10Unorm = 0x0000005B,\n        ASTC12x10UnormSrgb = 0x0000005C,\n        ASTC12x12Unorm = 0x0000005D,\n        ASTC12x12UnormSrgb = 0x0000005E,\n        R8BG8Biplanar420Unorm = 0x0000005F,\n    };\n\n    enum class TextureSampleType : uint32_t {\n        Undefined = 0x00000000,\n        Float = 0x00000001,\n        UnfilterableFloat = 0x00000002,\n        Depth = 0x00000003,\n        Sint = 0x00000004,\n        Uint = 0x00000005,\n    };\n\n    enum class TextureViewDimension : uint32_t {\n        Undefined = 0x00000000,\n        e1D = 0x00000001,\n        e2D = 0x00000002,\n        e2DArray = 0x00000003,\n        Cube = 0x00000004,\n        CubeArray = 0x00000005,\n        e3D = 0x00000006,\n    };\n\n    enum class VertexFormat : uint32_t {\n        Undefined = 0x00000000,\n        Uint8x2 = 0x00000001,\n        Uint8x4 = 0x00000002,\n        Sint8x2 = 0x00000003,\n        Sint8x4 = 0x00000004,\n        Unorm8x2 = 0x00000005,\n        Unorm8x4 = 0x00000006,\n        Snorm8x2 = 0x00000007,\n        Snorm8x4 = 0x00000008,\n        Uint16x2 = 0x00000009,\n        Uint16x4 = 0x0000000A,\n        Sint16x2 = 0x0000000B,\n        Sint16x4 = 0x0000000C,\n        Unorm16x2 = 0x0000000D,\n        Unorm16x4 = 0x0000000E,\n        Snorm16x2 = 0x0000000F,\n        Snorm16x4 = 0x00000010,\n        Float16x2 = 0x00000011,\n        Float16x4 = 0x00000012,\n        Float32 = 0x00000013,\n        Float32x2 = 0x00000014,\n        Float32x3 = 0x00000015,\n        Float32x4 = 0x00000016,\n        Uint32 = 0x00000017,\n        Uint32x2 = 0x00000018,\n        Uint32x3 = 0x00000019,\n        Uint32x4 = 0x0000001A,\n        Sint32 = 0x0000001B,\n        Sint32x2 = 0x0000001C,\n        Sint32x3 = 0x0000001D,\n        Sint32x4 = 0x0000001E,\n    };\n\n    enum class VertexStepMode : uint32_t {\n        Vertex = 0x00000000,\n        Instance = 0x00000001,\n        VertexBufferNotUsed = 0x00000002,\n    };\n\n\n    enum class BufferUsage : uint32_t {\n        None = 0x00000000,\n        MapRead = 0x00000001,\n        MapWrite = 0x00000002,\n        CopySrc = 0x00000004,\n        CopyDst = 0x00000008,\n        Index = 0x00000010,\n        Vertex = 0x00000020,\n        Uniform = 0x00000040,\n        Storage = 0x00000080,\n        Indirect = 0x00000100,\n        QueryResolve = 0x00000200,\n    };\n\n    enum class ColorWriteMask : uint32_t {\n        None = 0x00000000,\n        Red = 0x00000001,\n        Green = 0x00000002,\n        Blue = 0x00000004,\n        Alpha = 0x00000008,\n        All = 0x0000000F,\n    };\n\n    enum class MapMode : uint32_t {\n        None = 0x00000000,\n        Read = 0x00000001,\n        Write = 0x00000002,\n    };\n\n    enum class ShaderStage : uint32_t {\n        None = 0x00000000,\n        Vertex = 0x00000001,\n        Fragment = 0x00000002,\n        Compute = 0x00000004,\n    };\n\n    enum class TextureUsage : uint32_t {\n        None = 0x00000000,\n        CopySrc = 0x00000001,\n        CopyDst = 0x00000002,\n        TextureBinding = 0x00000004,\n        StorageBinding = 0x00000008,\n        RenderAttachment = 0x00000010,\n        Present = 0x00000020,\n    };\n\n\n    using BufferMapCallback = WGPUBufferMapCallback;\n    using CompilationInfoCallback = WGPUCompilationInfoCallback;\n    using CreateComputePipelineAsyncCallback = WGPUCreateComputePipelineAsyncCallback;\n    using CreateRenderPipelineAsyncCallback = WGPUCreateRenderPipelineAsyncCallback;\n    using DeviceLostCallback = WGPUDeviceLostCallback;\n    using ErrorCallback = WGPUErrorCallback;\n    using LoggingCallback = WGPULoggingCallback;\n    using Proc = WGPUProc;\n    using QueueWorkDoneCallback = WGPUQueueWorkDoneCallback;\n    using RequestAdapterCallback = WGPURequestAdapterCallback;\n    using RequestDeviceCallback = WGPURequestDeviceCallback;\n\n    class Adapter;\n    class BindGroup;\n    class BindGroupLayout;\n    class Buffer;\n    class CommandBuffer;\n    class CommandEncoder;\n    class ComputePassEncoder;\n    class ComputePipeline;\n    class Device;\n    class ExternalTexture;\n    class Instance;\n    class PipelineLayout;\n    class QuerySet;\n    class Queue;\n    class RenderBundle;\n    class RenderBundleEncoder;\n    class RenderPassEncoder;\n    class RenderPipeline;\n    class Sampler;\n    class ShaderModule;\n    class Surface;\n    class SwapChain;\n    class Texture;\n    class TextureView;\n\n    struct AdapterProperties;\n    struct BindGroupEntry;\n    struct BlendComponent;\n    struct BufferBindingLayout;\n    struct BufferDescriptor;\n    struct Color;\n    struct CommandBufferDescriptor;\n    struct CommandEncoderDescriptor;\n    struct CompilationMessage;\n    struct ComputePassTimestampWrite;\n    struct ConstantEntry;\n    struct CopyTextureForBrowserOptions;\n    struct DawnCacheDeviceDescriptor;\n    struct DawnEncoderInternalUsageDescriptor;\n    struct DawnInstanceDescriptor;\n    struct DawnTextureInternalUsageDescriptor;\n    struct DawnTogglesDeviceDescriptor;\n    struct Extent3D;\n    struct ExternalTextureBindingEntry;\n    struct ExternalTextureBindingLayout;\n    struct ExternalTextureDescriptor;\n    struct InstanceDescriptor;\n    struct Limits;\n    struct MultisampleState;\n    struct Origin3D;\n    struct PipelineLayoutDescriptor;\n    struct PrimitiveDepthClampingState;\n    struct PrimitiveDepthClipControl;\n    struct PrimitiveState;\n    struct QuerySetDescriptor;\n    struct QueueDescriptor;\n    struct RenderBundleDescriptor;\n    struct RenderBundleEncoderDescriptor;\n    struct RenderPassDepthStencilAttachment;\n    struct RenderPassDescriptorMaxDrawCount;\n    struct RenderPassTimestampWrite;\n    struct RequestAdapterOptions;\n    struct SamplerBindingLayout;\n    struct SamplerDescriptor;\n    struct ShaderModuleDescriptor;\n    struct ShaderModuleSPIRVDescriptor;\n    struct ShaderModuleWGSLDescriptor;\n    struct StencilFaceState;\n    struct StorageTextureBindingLayout;\n    struct SurfaceDescriptor;\n    struct SurfaceDescriptorFromAndroidNativeWindow;\n    struct SurfaceDescriptorFromCanvasHTMLSelector;\n    struct SurfaceDescriptorFromMetalLayer;\n    struct SurfaceDescriptorFromWaylandSurface;\n    struct SurfaceDescriptorFromWindowsCoreWindow;\n    struct SurfaceDescriptorFromWindowsHWND;\n    struct SurfaceDescriptorFromWindowsSwapChainPanel;\n    struct SurfaceDescriptorFromXlibWindow;\n    struct SwapChainDescriptor;\n    struct TextureBindingLayout;\n    struct TextureDataLayout;\n    struct TextureViewDescriptor;\n    struct VertexAttribute;\n    struct BindGroupDescriptor;\n    struct BindGroupLayoutEntry;\n    struct BlendState;\n    struct CompilationInfo;\n    struct ComputePassDescriptor;\n    struct DepthStencilState;\n    struct ImageCopyBuffer;\n    struct ImageCopyTexture;\n    struct ProgrammableStageDescriptor;\n    struct RenderPassColorAttachment;\n    struct RequiredLimits;\n    struct SupportedLimits;\n    struct TextureDescriptor;\n    struct VertexBufferLayout;\n    struct BindGroupLayoutDescriptor;\n    struct ColorTargetState;\n    struct ComputePipelineDescriptor;\n    struct DeviceDescriptor;\n    struct RenderPassDescriptor;\n    struct VertexState;\n    struct FragmentState;\n    struct RenderPipelineDescriptor;\n\n    template<typename Derived, typename CType>\n    class ObjectBase {\n      public:\n        ObjectBase() = default;\n        ObjectBase(CType handle): mHandle(handle) {\n            if (mHandle) Derived::WGPUReference(mHandle);\n        }\n        ~ObjectBase() {\n            if (mHandle) Derived::WGPURelease(mHandle);\n        }\n\n        ObjectBase(ObjectBase const& other)\n            : ObjectBase(other.Get()) {\n        }\n        Derived& operator=(ObjectBase const& other) {\n            if (&other != this) {\n                if (mHandle) Derived::WGPURelease(mHandle);\n                mHandle = other.mHandle;\n                if (mHandle) Derived::WGPUReference(mHandle);\n            }\n\n            return static_cast<Derived&>(*this);\n        }\n\n        ObjectBase(ObjectBase&& other) {\n            mHandle = other.mHandle;\n            other.mHandle = 0;\n        }\n        Derived& operator=(ObjectBase&& other) {\n            if (&other != this) {\n                if (mHandle) Derived::WGPURelease(mHandle);\n                mHandle = other.mHandle;\n                other.mHandle = 0;\n            }\n\n            return static_cast<Derived&>(*this);\n        }\n\n        ObjectBase(std::nullptr_t) {}\n        Derived& operator=(std::nullptr_t) {\n            if (mHandle != nullptr) {\n                Derived::WGPURelease(mHandle);\n                mHandle = nullptr;\n            }\n            return static_cast<Derived&>(*this);\n        }\n\n        bool operator==(std::nullptr_t) const {\n            return mHandle == nullptr;\n        }\n        bool operator!=(std::nullptr_t) const {\n            return mHandle != nullptr;\n        }\n\n        explicit operator bool() const {\n            return mHandle != nullptr;\n        }\n        CType Get() const {\n            return mHandle;\n        }\n        CType Release() {\n            CType result = mHandle;\n            mHandle = 0;\n            return result;\n        }\n        static Derived Acquire(CType handle) {\n            Derived result;\n            result.mHandle = handle;\n            return result;\n        }\n\n      protected:\n        CType mHandle = nullptr;\n    };\n\n\n\n    class Adapter : public ObjectBase<Adapter, WGPUAdapter> {\n      public:\n        using ObjectBase::ObjectBase;\n        using ObjectBase::operator=;\n\n        Device CreateDevice(DeviceDescriptor const * descriptor = nullptr) const;\n        size_t EnumerateFeatures(FeatureName * features) const;\n        bool GetLimits(SupportedLimits * limits) const;\n        void GetProperties(AdapterProperties * properties) const;\n        bool HasFeature(FeatureName feature) const;\n        void RequestDevice(DeviceDescriptor const * descriptor, RequestDeviceCallback callback, void * userdata) const;\n\n      private:\n        friend ObjectBase<Adapter, WGPUAdapter>;\n        static void WGPUReference(WGPUAdapter handle);\n        static void WGPURelease(WGPUAdapter handle);\n    };\n\n    class BindGroup : public ObjectBase<BindGroup, WGPUBindGroup> {\n      public:\n        using ObjectBase::ObjectBase;\n        using ObjectBase::operator=;\n\n        void SetLabel(char const * label) const;\n\n      private:\n        friend ObjectBase<BindGroup, WGPUBindGroup>;\n        static void WGPUReference(WGPUBindGroup handle);\n        static void WGPURelease(WGPUBindGroup handle);\n    };\n\n    class BindGroupLayout : public ObjectBase<BindGroupLayout, WGPUBindGroupLayout> {\n      public:\n        using ObjectBase::ObjectBase;\n        using ObjectBase::operator=;\n\n        void SetLabel(char const * label) const;\n\n      private:\n        friend ObjectBase<BindGroupLayout, WGPUBindGroupLayout>;\n        static void WGPUReference(WGPUBindGroupLayout handle);\n        static void WGPURelease(WGPUBindGroupLayout handle);\n    };\n\n    class Buffer : public ObjectBase<Buffer, WGPUBuffer> {\n      public:\n        using ObjectBase::ObjectBase;\n        using ObjectBase::operator=;\n\n        void Destroy() const;\n        void const * GetConstMappedRange(size_t offset = 0, size_t size = WGPU_WHOLE_MAP_SIZE) const;\n        void * GetMappedRange(size_t offset = 0, size_t size = WGPU_WHOLE_MAP_SIZE) const;\n        uint64_t GetSize() const;\n        BufferUsage GetUsage() const;\n        void MapAsync(MapMode mode, size_t offset, size_t size, BufferMapCallback callback, void * userdata) const;\n        void SetLabel(char const * label) const;\n        void Unmap() const;\n\n      private:\n        friend ObjectBase<Buffer, WGPUBuffer>;\n        static void WGPUReference(WGPUBuffer handle);\n        static void WGPURelease(WGPUBuffer handle);\n    };\n\n    class CommandBuffer : public ObjectBase<CommandBuffer, WGPUCommandBuffer> {\n      public:\n        using ObjectBase::ObjectBase;\n        using ObjectBase::operator=;\n\n        void SetLabel(char const * label) const;\n\n      private:\n        friend ObjectBase<CommandBuffer, WGPUCommandBuffer>;\n        static void WGPUReference(WGPUCommandBuffer handle);\n        static void WGPURelease(WGPUCommandBuffer handle);\n    };\n\n    class CommandEncoder : public ObjectBase<CommandEncoder, WGPUCommandEncoder> {\n      public:\n        using ObjectBase::ObjectBase;\n        using ObjectBase::operator=;\n\n        ComputePassEncoder BeginComputePass(ComputePassDescriptor const * descriptor = nullptr) const;\n        RenderPassEncoder BeginRenderPass(RenderPassDescriptor const * descriptor) const;\n        void ClearBuffer(Buffer const& buffer, uint64_t offset = 0, uint64_t size = WGPU_WHOLE_SIZE) const;\n        void CopyBufferToBuffer(Buffer const& source, uint64_t sourceOffset, Buffer const& destination, uint64_t destinationOffset, uint64_t size) const;\n        void CopyBufferToTexture(ImageCopyBuffer const * source, ImageCopyTexture const * destination, Extent3D const * copySize) const;\n        void CopyTextureToBuffer(ImageCopyTexture const * source, ImageCopyBuffer const * destination, Extent3D const * copySize) const;\n        void CopyTextureToTexture(ImageCopyTexture const * source, ImageCopyTexture const * destination, Extent3D const * copySize) const;\n        void CopyTextureToTextureInternal(ImageCopyTexture const * source, ImageCopyTexture const * destination, Extent3D const * copySize) const;\n        CommandBuffer Finish(CommandBufferDescriptor const * descriptor = nullptr) const;\n        void InjectValidationError(char const * message) const;\n        void InsertDebugMarker(char const * markerLabel) const;\n        void PopDebugGroup() const;\n        void PushDebugGroup(char const * groupLabel) const;\n        void ResolveQuerySet(QuerySet const& querySet, uint32_t firstQuery, uint32_t queryCount, Buffer const& destination, uint64_t destinationOffset) const;\n        void SetLabel(char const * label) const;\n        void WriteBuffer(Buffer const& buffer, uint64_t bufferOffset, uint8_t const * data, uint64_t size) const;\n        void WriteTimestamp(QuerySet const& querySet, uint32_t queryIndex) const;\n\n      private:\n        friend ObjectBase<CommandEncoder, WGPUCommandEncoder>;\n        static void WGPUReference(WGPUCommandEncoder handle);\n        static void WGPURelease(WGPUCommandEncoder handle);\n    };\n\n    class ComputePassEncoder : public ObjectBase<ComputePassEncoder, WGPUComputePassEncoder> {\n      public:\n        using ObjectBase::ObjectBase;\n        using ObjectBase::operator=;\n\n        void Dispatch(uint32_t workgroupCountX, uint32_t workgroupCountY = 1, uint32_t workgroupCountZ = 1) const;\n        void DispatchIndirect(Buffer const& indirectBuffer, uint64_t indirectOffset) const;\n        void DispatchWorkgroups(uint32_t workgroupCountX, uint32_t workgroupCountY = 1, uint32_t workgroupCountZ = 1) const;\n        void DispatchWorkgroupsIndirect(Buffer const& indirectBuffer, uint64_t indirectOffset) const;\n        void End() const;\n        void EndPass() const;\n        void InsertDebugMarker(char const * markerLabel) const;\n        void PopDebugGroup() const;\n        void PushDebugGroup(char const * groupLabel) const;\n        void SetBindGroup(uint32_t groupIndex, BindGroup const& group, uint32_t dynamicOffsetCount = 0, uint32_t const * dynamicOffsets = nullptr) const;\n        void SetLabel(char const * label) const;\n        void SetPipeline(ComputePipeline const& pipeline) const;\n        void WriteTimestamp(QuerySet const& querySet, uint32_t queryIndex) const;\n\n      private:\n        friend ObjectBase<ComputePassEncoder, WGPUComputePassEncoder>;\n        static void WGPUReference(WGPUComputePassEncoder handle);\n        static void WGPURelease(WGPUComputePassEncoder handle);\n    };\n\n    class ComputePipeline : public ObjectBase<ComputePipeline, WGPUComputePipeline> {\n      public:\n        using ObjectBase::ObjectBase;\n        using ObjectBase::operator=;\n\n        BindGroupLayout GetBindGroupLayout(uint32_t groupIndex) const;\n        void SetLabel(char const * label) const;\n\n      private:\n        friend ObjectBase<ComputePipeline, WGPUComputePipeline>;\n        static void WGPUReference(WGPUComputePipeline handle);\n        static void WGPURelease(WGPUComputePipeline handle);\n    };\n\n    class Device : public ObjectBase<Device, WGPUDevice> {\n      public:\n        using ObjectBase::ObjectBase;\n        using ObjectBase::operator=;\n\n        BindGroup CreateBindGroup(BindGroupDescriptor const * descriptor) const;\n        BindGroupLayout CreateBindGroupLayout(BindGroupLayoutDescriptor const * descriptor) const;\n        Buffer CreateBuffer(BufferDescriptor const * descriptor) const;\n        CommandEncoder CreateCommandEncoder(CommandEncoderDescriptor const * descriptor = nullptr) const;\n        ComputePipeline CreateComputePipeline(ComputePipelineDescriptor const * descriptor) const;\n        void CreateComputePipelineAsync(ComputePipelineDescriptor const * descriptor, CreateComputePipelineAsyncCallback callback, void * userdata) const;\n        Buffer CreateErrorBuffer() const;\n        ExternalTexture CreateErrorExternalTexture() const;\n        ExternalTexture CreateExternalTexture(ExternalTextureDescriptor const * externalTextureDescriptor) const;\n        PipelineLayout CreatePipelineLayout(PipelineLayoutDescriptor const * descriptor) const;\n        QuerySet CreateQuerySet(QuerySetDescriptor const * descriptor) const;\n        RenderBundleEncoder CreateRenderBundleEncoder(RenderBundleEncoderDescriptor const * descriptor) const;\n        RenderPipeline CreateRenderPipeline(RenderPipelineDescriptor const * descriptor) const;\n        void CreateRenderPipelineAsync(RenderPipelineDescriptor const * descriptor, CreateRenderPipelineAsyncCallback callback, void * userdata) const;\n        Sampler CreateSampler(SamplerDescriptor const * descriptor = nullptr) const;\n        ShaderModule CreateShaderModule(ShaderModuleDescriptor const * descriptor) const;\n        SwapChain CreateSwapChain(Surface const& surface, SwapChainDescriptor const * descriptor) const;\n        Texture CreateTexture(TextureDescriptor const * descriptor) const;\n        void Destroy() const;\n        size_t EnumerateFeatures(FeatureName * features) const;\n        bool GetLimits(SupportedLimits * limits) const;\n        Queue GetQueue() const;\n        bool HasFeature(FeatureName feature) const;\n        void InjectError(ErrorType type, char const * message) const;\n        void LoseForTesting() const;\n        bool PopErrorScope(ErrorCallback callback, void * userdata) const;\n        void PushErrorScope(ErrorFilter filter) const;\n        void SetDeviceLostCallback(DeviceLostCallback callback, void * userdata) const;\n        void SetLabel(char const * label) const;\n        void SetLoggingCallback(LoggingCallback callback, void * userdata) const;\n        void SetUncapturedErrorCallback(ErrorCallback callback, void * userdata) const;\n        void Tick() const;\n\n      private:\n        friend ObjectBase<Device, WGPUDevice>;\n        static void WGPUReference(WGPUDevice handle);\n        static void WGPURelease(WGPUDevice handle);\n    };\n\n    class ExternalTexture : public ObjectBase<ExternalTexture, WGPUExternalTexture> {\n      public:\n        using ObjectBase::ObjectBase;\n        using ObjectBase::operator=;\n\n        void Destroy() const;\n        void SetLabel(char const * label) const;\n\n      private:\n        friend ObjectBase<ExternalTexture, WGPUExternalTexture>;\n        static void WGPUReference(WGPUExternalTexture handle);\n        static void WGPURelease(WGPUExternalTexture handle);\n    };\n\n    class Instance : public ObjectBase<Instance, WGPUInstance> {\n      public:\n        using ObjectBase::ObjectBase;\n        using ObjectBase::operator=;\n\n        Surface CreateSurface(SurfaceDescriptor const * descriptor) const;\n        void RequestAdapter(RequestAdapterOptions const * options, RequestAdapterCallback callback, void * userdata) const;\n\n      private:\n        friend ObjectBase<Instance, WGPUInstance>;\n        static void WGPUReference(WGPUInstance handle);\n        static void WGPURelease(WGPUInstance handle);\n    };\n\n    class PipelineLayout : public ObjectBase<PipelineLayout, WGPUPipelineLayout> {\n      public:\n        using ObjectBase::ObjectBase;\n        using ObjectBase::operator=;\n\n        void SetLabel(char const * label) const;\n\n      private:\n        friend ObjectBase<PipelineLayout, WGPUPipelineLayout>;\n        static void WGPUReference(WGPUPipelineLayout handle);\n        static void WGPURelease(WGPUPipelineLayout handle);\n    };\n\n    class QuerySet : public ObjectBase<QuerySet, WGPUQuerySet> {\n      public:\n        using ObjectBase::ObjectBase;\n        using ObjectBase::operator=;\n\n        void Destroy() const;\n        uint32_t GetCount() const;\n        QueryType GetType() const;\n        void SetLabel(char const * label) const;\n\n      private:\n        friend ObjectBase<QuerySet, WGPUQuerySet>;\n        static void WGPUReference(WGPUQuerySet handle);\n        static void WGPURelease(WGPUQuerySet handle);\n    };\n\n    class Queue : public ObjectBase<Queue, WGPUQueue> {\n      public:\n        using ObjectBase::ObjectBase;\n        using ObjectBase::operator=;\n\n        void CopyTextureForBrowser(ImageCopyTexture const * source, ImageCopyTexture const * destination, Extent3D const * copySize, CopyTextureForBrowserOptions const * options) const;\n        void OnSubmittedWorkDone(uint64_t signalValue, QueueWorkDoneCallback callback, void * userdata) const;\n        void SetLabel(char const * label) const;\n        void Submit(uint32_t commandCount, CommandBuffer const * commands) const;\n        void WriteBuffer(Buffer const& buffer, uint64_t bufferOffset, void const * data, size_t size) const;\n        void WriteTexture(ImageCopyTexture const * destination, void const * data, size_t dataSize, TextureDataLayout const * dataLayout, Extent3D const * writeSize) const;\n\n      private:\n        friend ObjectBase<Queue, WGPUQueue>;\n        static void WGPUReference(WGPUQueue handle);\n        static void WGPURelease(WGPUQueue handle);\n    };\n\n    class RenderBundle : public ObjectBase<RenderBundle, WGPURenderBundle> {\n      public:\n        using ObjectBase::ObjectBase;\n        using ObjectBase::operator=;\n\n\n      private:\n        friend ObjectBase<RenderBundle, WGPURenderBundle>;\n        static void WGPUReference(WGPURenderBundle handle);\n        static void WGPURelease(WGPURenderBundle handle);\n    };\n\n    class RenderBundleEncoder : public ObjectBase<RenderBundleEncoder, WGPURenderBundleEncoder> {\n      public:\n        using ObjectBase::ObjectBase;\n        using ObjectBase::operator=;\n\n        void Draw(uint32_t vertexCount, uint32_t instanceCount = 1, uint32_t firstVertex = 0, uint32_t firstInstance = 0) const;\n        void DrawIndexed(uint32_t indexCount, uint32_t instanceCount = 1, uint32_t firstIndex = 0, int32_t baseVertex = 0, uint32_t firstInstance = 0) const;\n        void DrawIndexedIndirect(Buffer const& indirectBuffer, uint64_t indirectOffset) const;\n        void DrawIndirect(Buffer const& indirectBuffer, uint64_t indirectOffset) const;\n        RenderBundle Finish(RenderBundleDescriptor const * descriptor = nullptr) const;\n        void InsertDebugMarker(char const * markerLabel) const;\n        void PopDebugGroup() const;\n        void PushDebugGroup(char const * groupLabel) const;\n        void SetBindGroup(uint32_t groupIndex, BindGroup const& group, uint32_t dynamicOffsetCount = 0, uint32_t const * dynamicOffsets = nullptr) const;\n        void SetIndexBuffer(Buffer const& buffer, IndexFormat format, uint64_t offset = 0, uint64_t size = WGPU_WHOLE_SIZE) const;\n        void SetLabel(char const * label) const;\n        void SetPipeline(RenderPipeline const& pipeline) const;\n        void SetVertexBuffer(uint32_t slot, Buffer const& buffer, uint64_t offset = 0, uint64_t size = WGPU_WHOLE_SIZE) const;\n\n      private:\n        friend ObjectBase<RenderBundleEncoder, WGPURenderBundleEncoder>;\n        static void WGPUReference(WGPURenderBundleEncoder handle);\n        static void WGPURelease(WGPURenderBundleEncoder handle);\n    };\n\n    class RenderPassEncoder : public ObjectBase<RenderPassEncoder, WGPURenderPassEncoder> {\n      public:\n        using ObjectBase::ObjectBase;\n        using ObjectBase::operator=;\n\n        void BeginOcclusionQuery(uint32_t queryIndex) const;\n        void Draw(uint32_t vertexCount, uint32_t instanceCount = 1, uint32_t firstVertex = 0, uint32_t firstInstance = 0) const;\n        void DrawIndexed(uint32_t indexCount, uint32_t instanceCount = 1, uint32_t firstIndex = 0, int32_t baseVertex = 0, uint32_t firstInstance = 0) const;\n        void DrawIndexedIndirect(Buffer const& indirectBuffer, uint64_t indirectOffset) const;\n        void DrawIndirect(Buffer const& indirectBuffer, uint64_t indirectOffset) const;\n        void End() const;\n        void EndOcclusionQuery() const;\n        void EndPass() const;\n        void ExecuteBundles(uint32_t bundlesCount, RenderBundle const * bundles) const;\n        void InsertDebugMarker(char const * markerLabel) const;\n        void PopDebugGroup() const;\n        void PushDebugGroup(char const * groupLabel) const;\n        void SetBindGroup(uint32_t groupIndex, BindGroup const& group, uint32_t dynamicOffsetCount = 0, uint32_t const * dynamicOffsets = nullptr) const;\n        void SetBlendConstant(Color const * color) const;\n        void SetIndexBuffer(Buffer const& buffer, IndexFormat format, uint64_t offset = 0, uint64_t size = WGPU_WHOLE_SIZE) const;\n        void SetLabel(char const * label) const;\n        void SetPipeline(RenderPipeline const& pipeline) const;\n        void SetScissorRect(uint32_t x, uint32_t y, uint32_t width, uint32_t height) const;\n        void SetStencilReference(uint32_t reference) const;\n        void SetVertexBuffer(uint32_t slot, Buffer const& buffer, uint64_t offset = 0, uint64_t size = WGPU_WHOLE_SIZE) const;\n        void SetViewport(float x, float y, float width, float height, float minDepth, float maxDepth) const;\n        void WriteTimestamp(QuerySet const& querySet, uint32_t queryIndex) const;\n\n      private:\n        friend ObjectBase<RenderPassEncoder, WGPURenderPassEncoder>;\n        static void WGPUReference(WGPURenderPassEncoder handle);\n        static void WGPURelease(WGPURenderPassEncoder handle);\n    };\n\n    class RenderPipeline : public ObjectBase<RenderPipeline, WGPURenderPipeline> {\n      public:\n        using ObjectBase::ObjectBase;\n        using ObjectBase::operator=;\n\n        BindGroupLayout GetBindGroupLayout(uint32_t groupIndex) const;\n        void SetLabel(char const * label) const;\n\n      private:\n        friend ObjectBase<RenderPipeline, WGPURenderPipeline>;\n        static void WGPUReference(WGPURenderPipeline handle);\n        static void WGPURelease(WGPURenderPipeline handle);\n    };\n\n    class Sampler : public ObjectBase<Sampler, WGPUSampler> {\n      public:\n        using ObjectBase::ObjectBase;\n        using ObjectBase::operator=;\n\n        void SetLabel(char const * label) const;\n\n      private:\n        friend ObjectBase<Sampler, WGPUSampler>;\n        static void WGPUReference(WGPUSampler handle);\n        static void WGPURelease(WGPUSampler handle);\n    };\n\n    class ShaderModule : public ObjectBase<ShaderModule, WGPUShaderModule> {\n      public:\n        using ObjectBase::ObjectBase;\n        using ObjectBase::operator=;\n\n        void GetCompilationInfo(CompilationInfoCallback callback, void * userdata) const;\n        void SetLabel(char const * label) const;\n\n      private:\n        friend ObjectBase<ShaderModule, WGPUShaderModule>;\n        static void WGPUReference(WGPUShaderModule handle);\n        static void WGPURelease(WGPUShaderModule handle);\n    };\n\n    class Surface : public ObjectBase<Surface, WGPUSurface> {\n      public:\n        using ObjectBase::ObjectBase;\n        using ObjectBase::operator=;\n\n\n      private:\n        friend ObjectBase<Surface, WGPUSurface>;\n        static void WGPUReference(WGPUSurface handle);\n        static void WGPURelease(WGPUSurface handle);\n    };\n\n    class SwapChain : public ObjectBase<SwapChain, WGPUSwapChain> {\n      public:\n        using ObjectBase::ObjectBase;\n        using ObjectBase::operator=;\n\n        void Configure(TextureFormat format, TextureUsage allowedUsage, uint32_t width, uint32_t height) const;\n        TextureView GetCurrentTextureView() const;\n        void Present() const;\n\n      private:\n        friend ObjectBase<SwapChain, WGPUSwapChain>;\n        static void WGPUReference(WGPUSwapChain handle);\n        static void WGPURelease(WGPUSwapChain handle);\n    };\n\n    class Texture : public ObjectBase<Texture, WGPUTexture> {\n      public:\n        using ObjectBase::ObjectBase;\n        using ObjectBase::operator=;\n\n        TextureView CreateView(TextureViewDescriptor const * descriptor = nullptr) const;\n        void Destroy() const;\n        uint32_t GetDepthOrArrayLayers() const;\n        TextureDimension GetDimension() const;\n        TextureFormat GetFormat() const;\n        uint32_t GetHeight() const;\n        uint32_t GetMipLevelCount() const;\n        uint32_t GetSampleCount() const;\n        TextureUsage GetUsage() const;\n        uint32_t GetWidth() const;\n        void SetLabel(char const * label) const;\n\n      private:\n        friend ObjectBase<Texture, WGPUTexture>;\n        static void WGPUReference(WGPUTexture handle);\n        static void WGPURelease(WGPUTexture handle);\n    };\n\n    class TextureView : public ObjectBase<TextureView, WGPUTextureView> {\n      public:\n        using ObjectBase::ObjectBase;\n        using ObjectBase::operator=;\n\n        void SetLabel(char const * label) const;\n\n      private:\n        friend ObjectBase<TextureView, WGPUTextureView>;\n        static void WGPUReference(WGPUTextureView handle);\n        static void WGPURelease(WGPUTextureView handle);\n    };\n\n\n    Instance CreateInstance(InstanceDescriptor const * descriptor = nullptr);\n    Proc GetProcAddress(Device device, char const * procName);\n\n    struct ChainedStruct {\n        ChainedStruct const * nextInChain = nullptr;\n        SType sType = SType::Invalid;\n    };\n\n    struct ChainedStructOut {\n        ChainedStruct * nextInChain = nullptr;\n        SType sType = SType::Invalid;\n    };\n\n    struct AdapterProperties {\n        ChainedStructOut  * nextInChain = nullptr;\n        uint32_t vendorID;\n        char const * vendorName;\n        char const * architecture;\n        uint32_t deviceID;\n        char const * name;\n        char const * driverDescription;\n        AdapterType adapterType;\n        BackendType backendType;\n    };\n\n    struct BindGroupEntry {\n        ChainedStruct const * nextInChain = nullptr;\n        uint32_t binding;\n        Buffer buffer = nullptr;\n        uint64_t offset = 0;\n        uint64_t size;\n        Sampler sampler = nullptr;\n        TextureView textureView = nullptr;\n    };\n\n    struct BlendComponent {\n        BlendOperation operation = BlendOperation::Add;\n        BlendFactor srcFactor = BlendFactor::One;\n        BlendFactor dstFactor = BlendFactor::Zero;\n    };\n\n    struct BufferBindingLayout {\n        ChainedStruct const * nextInChain = nullptr;\n        BufferBindingType type = BufferBindingType::Undefined;\n        bool hasDynamicOffset = false;\n        uint64_t minBindingSize = 0;\n    };\n\n    struct BufferDescriptor {\n        ChainedStruct const * nextInChain = nullptr;\n        char const * label = nullptr;\n        BufferUsage usage;\n        uint64_t size;\n        bool mappedAtCreation = false;\n    };\n\n    struct Color {\n        double r;\n        double g;\n        double b;\n        double a;\n    };\n\n    struct CommandBufferDescriptor {\n        ChainedStruct const * nextInChain = nullptr;\n        char const * label = nullptr;\n    };\n\n    struct CommandEncoderDescriptor {\n        ChainedStruct const * nextInChain = nullptr;\n        char const * label = nullptr;\n    };\n\n    struct CompilationMessage {\n        ChainedStruct const * nextInChain = nullptr;\n        char const * message = nullptr;\n        CompilationMessageType type;\n        uint64_t lineNum;\n        uint64_t linePos;\n        uint64_t offset;\n        uint64_t length;\n    };\n\n    struct ComputePassTimestampWrite {\n        QuerySet querySet;\n        uint32_t queryIndex;\n        ComputePassTimestampLocation location;\n    };\n\n    struct ConstantEntry {\n        ChainedStruct const * nextInChain = nullptr;\n        char const * key;\n        double value;\n    };\n\n    struct CopyTextureForBrowserOptions {\n        ChainedStruct const * nextInChain = nullptr;\n        bool flipY = false;\n        bool needsColorSpaceConversion = false;\n        AlphaMode srcAlphaMode = AlphaMode::Unpremultiplied;\n        float const * srcTransferFunctionParameters = nullptr;\n        float const * conversionMatrix = nullptr;\n        float const * dstTransferFunctionParameters = nullptr;\n        AlphaMode dstAlphaMode = AlphaMode::Unpremultiplied;\n    };\n\n    struct DawnCacheDeviceDescriptor : ChainedStruct {\n        DawnCacheDeviceDescriptor() {\n            sType = SType::DawnCacheDeviceDescriptor;\n        }\n        static constexpr size_t kFirstMemberAlignment = detail::ConstexprMax(alignof(ChainedStruct), alignof(char const * ));\n        alignas(kFirstMemberAlignment) char const * isolationKey = \"\";\n    };\n\n    struct DawnEncoderInternalUsageDescriptor : ChainedStruct {\n        DawnEncoderInternalUsageDescriptor() {\n            sType = SType::DawnEncoderInternalUsageDescriptor;\n        }\n        static constexpr size_t kFirstMemberAlignment = detail::ConstexprMax(alignof(ChainedStruct), alignof(bool ));\n        alignas(kFirstMemberAlignment) bool useInternalUsages = false;\n    };\n\n    struct DawnInstanceDescriptor : ChainedStruct {\n        DawnInstanceDescriptor() {\n            sType = SType::DawnInstanceDescriptor;\n        }\n        static constexpr size_t kFirstMemberAlignment = detail::ConstexprMax(alignof(ChainedStruct), alignof(uint32_t ));\n        alignas(kFirstMemberAlignment) uint32_t additionalRuntimeSearchPathsCount = 0;\n        const char* const * additionalRuntimeSearchPaths;\n    };\n\n    struct DawnTextureInternalUsageDescriptor : ChainedStruct {\n        DawnTextureInternalUsageDescriptor() {\n            sType = SType::DawnTextureInternalUsageDescriptor;\n        }\n        static constexpr size_t kFirstMemberAlignment = detail::ConstexprMax(alignof(ChainedStruct), alignof(TextureUsage ));\n        alignas(kFirstMemberAlignment) TextureUsage internalUsage = TextureUsage::None;\n    };\n\n    struct DawnTogglesDeviceDescriptor : ChainedStruct {\n        DawnTogglesDeviceDescriptor() {\n            sType = SType::DawnTogglesDeviceDescriptor;\n        }\n        static constexpr size_t kFirstMemberAlignment = detail::ConstexprMax(alignof(ChainedStruct), alignof(uint32_t ));\n        alignas(kFirstMemberAlignment) uint32_t forceEnabledTogglesCount = 0;\n        const char* const * forceEnabledToggles;\n        uint32_t forceDisabledTogglesCount = 0;\n        const char* const * forceDisabledToggles;\n    };\n\n    struct Extent3D {\n        uint32_t width;\n        uint32_t height = 1;\n        uint32_t depthOrArrayLayers = 1;\n    };\n\n    struct ExternalTextureBindingEntry : ChainedStruct {\n        ExternalTextureBindingEntry() {\n            sType = SType::ExternalTextureBindingEntry;\n        }\n        static constexpr size_t kFirstMemberAlignment = detail::ConstexprMax(alignof(ChainedStruct), alignof(ExternalTexture ));\n        alignas(kFirstMemberAlignment) ExternalTexture externalTexture;\n    };\n\n    struct ExternalTextureBindingLayout : ChainedStruct {\n        ExternalTextureBindingLayout() {\n            sType = SType::ExternalTextureBindingLayout;\n        }\n    };\n\n    struct ExternalTextureDescriptor {\n        ChainedStruct const * nextInChain = nullptr;\n        char const * label = nullptr;\n        TextureView plane0;\n        TextureView plane1 = nullptr;\n        bool doYuvToRgbConversionOnly = false;\n        float const * yuvToRgbConversionMatrix = nullptr;\n        float const * srcTransferFunctionParameters;\n        float const * dstTransferFunctionParameters;\n        float const * gamutConversionMatrix;\n    };\n\n    struct InstanceDescriptor {\n        ChainedStruct const * nextInChain = nullptr;\n    };\n\n    struct Limits {\n        uint32_t maxTextureDimension1D = WGPU_LIMIT_U32_UNDEFINED;\n        uint32_t maxTextureDimension2D = WGPU_LIMIT_U32_UNDEFINED;\n        uint32_t maxTextureDimension3D = WGPU_LIMIT_U32_UNDEFINED;\n        uint32_t maxTextureArrayLayers = WGPU_LIMIT_U32_UNDEFINED;\n        uint32_t maxBindGroups = WGPU_LIMIT_U32_UNDEFINED;\n        uint32_t maxDynamicUniformBuffersPerPipelineLayout = WGPU_LIMIT_U32_UNDEFINED;\n        uint32_t maxDynamicStorageBuffersPerPipelineLayout = WGPU_LIMIT_U32_UNDEFINED;\n        uint32_t maxSampledTexturesPerShaderStage = WGPU_LIMIT_U32_UNDEFINED;\n        uint32_t maxSamplersPerShaderStage = WGPU_LIMIT_U32_UNDEFINED;\n        uint32_t maxStorageBuffersPerShaderStage = WGPU_LIMIT_U32_UNDEFINED;\n        uint32_t maxStorageTexturesPerShaderStage = WGPU_LIMIT_U32_UNDEFINED;\n        uint32_t maxUniformBuffersPerShaderStage = WGPU_LIMIT_U32_UNDEFINED;\n        uint64_t maxUniformBufferBindingSize = WGPU_LIMIT_U64_UNDEFINED;\n        uint64_t maxStorageBufferBindingSize = WGPU_LIMIT_U64_UNDEFINED;\n        uint32_t minUniformBufferOffsetAlignment = WGPU_LIMIT_U32_UNDEFINED;\n        uint32_t minStorageBufferOffsetAlignment = WGPU_LIMIT_U32_UNDEFINED;\n        uint32_t maxVertexBuffers = WGPU_LIMIT_U32_UNDEFINED;\n        uint32_t maxVertexAttributes = WGPU_LIMIT_U32_UNDEFINED;\n        uint32_t maxVertexBufferArrayStride = WGPU_LIMIT_U32_UNDEFINED;\n        uint32_t maxInterStageShaderComponents = WGPU_LIMIT_U32_UNDEFINED;\n        uint32_t maxInterStageShaderVariables = WGPU_LIMIT_U32_UNDEFINED;\n        uint32_t maxColorAttachments = WGPU_LIMIT_U32_UNDEFINED;\n        uint32_t maxComputeWorkgroupStorageSize = WGPU_LIMIT_U32_UNDEFINED;\n        uint32_t maxComputeInvocationsPerWorkgroup = WGPU_LIMIT_U32_UNDEFINED;\n        uint32_t maxComputeWorkgroupSizeX = WGPU_LIMIT_U32_UNDEFINED;\n        uint32_t maxComputeWorkgroupSizeY = WGPU_LIMIT_U32_UNDEFINED;\n        uint32_t maxComputeWorkgroupSizeZ = WGPU_LIMIT_U32_UNDEFINED;\n        uint32_t maxComputeWorkgroupsPerDimension = WGPU_LIMIT_U32_UNDEFINED;\n    };\n\n    struct MultisampleState {\n        ChainedStruct const * nextInChain = nullptr;\n        uint32_t count = 1;\n        uint32_t mask = 0xFFFFFFFF;\n        bool alphaToCoverageEnabled = false;\n    };\n\n    struct Origin3D {\n        uint32_t x = 0;\n        uint32_t y = 0;\n        uint32_t z = 0;\n    };\n\n    struct PipelineLayoutDescriptor {\n        ChainedStruct const * nextInChain = nullptr;\n        char const * label = nullptr;\n        uint32_t bindGroupLayoutCount;\n        BindGroupLayout const * bindGroupLayouts;\n    };\n\n    struct PrimitiveDepthClampingState : ChainedStruct {\n        PrimitiveDepthClampingState() {\n            sType = SType::PrimitiveDepthClampingState;\n        }\n        static constexpr size_t kFirstMemberAlignment = detail::ConstexprMax(alignof(ChainedStruct), alignof(bool ));\n        alignas(kFirstMemberAlignment) bool clampDepth = false;\n    };\n\n    struct PrimitiveDepthClipControl : ChainedStruct {\n        PrimitiveDepthClipControl() {\n            sType = SType::PrimitiveDepthClipControl;\n        }\n        static constexpr size_t kFirstMemberAlignment = detail::ConstexprMax(alignof(ChainedStruct), alignof(bool ));\n        alignas(kFirstMemberAlignment) bool unclippedDepth = false;\n    };\n\n    struct PrimitiveState {\n        ChainedStruct const * nextInChain = nullptr;\n        PrimitiveTopology topology = PrimitiveTopology::TriangleList;\n        IndexFormat stripIndexFormat = IndexFormat::Undefined;\n        FrontFace frontFace = FrontFace::CCW;\n        CullMode cullMode = CullMode::None;\n    };\n\n    struct QuerySetDescriptor {\n        ChainedStruct const * nextInChain = nullptr;\n        char const * label = nullptr;\n        QueryType type;\n        uint32_t count;\n        PipelineStatisticName const * pipelineStatistics;\n        uint32_t pipelineStatisticsCount = 0;\n    };\n\n    struct QueueDescriptor {\n        ChainedStruct const * nextInChain = nullptr;\n        char const * label = nullptr;\n    };\n\n    struct RenderBundleDescriptor {\n        ChainedStruct const * nextInChain = nullptr;\n        char const * label = nullptr;\n    };\n\n    struct RenderBundleEncoderDescriptor {\n        ChainedStruct const * nextInChain = nullptr;\n        char const * label = nullptr;\n        uint32_t colorFormatsCount;\n        TextureFormat const * colorFormats;\n        TextureFormat depthStencilFormat = TextureFormat::Undefined;\n        uint32_t sampleCount = 1;\n        bool depthReadOnly = false;\n        bool stencilReadOnly = false;\n    };\n\n    struct RenderPassDepthStencilAttachment {\n        TextureView view;\n        LoadOp depthLoadOp = LoadOp::Undefined;\n        StoreOp depthStoreOp = StoreOp::Undefined;\n        float clearDepth = NAN;\n        float depthClearValue = 0;\n        bool depthReadOnly = false;\n        LoadOp stencilLoadOp = LoadOp::Undefined;\n        StoreOp stencilStoreOp = StoreOp::Undefined;\n        uint32_t clearStencil = 0;\n        uint32_t stencilClearValue = 0;\n        bool stencilReadOnly = false;\n    };\n\n    struct RenderPassDescriptorMaxDrawCount : ChainedStruct {\n        RenderPassDescriptorMaxDrawCount() {\n            sType = SType::RenderPassDescriptorMaxDrawCount;\n        }\n        static constexpr size_t kFirstMemberAlignment = detail::ConstexprMax(alignof(ChainedStruct), alignof(uint64_t ));\n        alignas(kFirstMemberAlignment) uint64_t maxDrawCount = 50000000;\n    };\n\n    struct RenderPassTimestampWrite {\n        QuerySet querySet;\n        uint32_t queryIndex;\n        RenderPassTimestampLocation location;\n    };\n\n    struct RequestAdapterOptions {\n        ChainedStruct const * nextInChain = nullptr;\n        Surface compatibleSurface = nullptr;\n        PowerPreference powerPreference = PowerPreference::Undefined;\n        bool forceFallbackAdapter = false;\n    };\n\n    struct SamplerBindingLayout {\n        ChainedStruct const * nextInChain = nullptr;\n        SamplerBindingType type = SamplerBindingType::Undefined;\n    };\n\n    struct SamplerDescriptor {\n        ChainedStruct const * nextInChain = nullptr;\n        char const * label = nullptr;\n        AddressMode addressModeU = AddressMode::ClampToEdge;\n        AddressMode addressModeV = AddressMode::ClampToEdge;\n        AddressMode addressModeW = AddressMode::ClampToEdge;\n        FilterMode magFilter = FilterMode::Nearest;\n        FilterMode minFilter = FilterMode::Nearest;\n        FilterMode mipmapFilter = FilterMode::Nearest;\n        float lodMinClamp = 0.0f;\n        float lodMaxClamp = 1000.0f;\n        CompareFunction compare = CompareFunction::Undefined;\n        uint16_t maxAnisotropy = 1;\n    };\n\n    struct ShaderModuleDescriptor {\n        ChainedStruct const * nextInChain = nullptr;\n        char const * label = nullptr;\n    };\n\n    struct ShaderModuleSPIRVDescriptor : ChainedStruct {\n        ShaderModuleSPIRVDescriptor() {\n            sType = SType::ShaderModuleSPIRVDescriptor;\n        }\n        static constexpr size_t kFirstMemberAlignment = detail::ConstexprMax(alignof(ChainedStruct), alignof(uint32_t ));\n        alignas(kFirstMemberAlignment) uint32_t codeSize;\n        uint32_t const * code;\n    };\n\n    struct ShaderModuleWGSLDescriptor : ChainedStruct {\n        ShaderModuleWGSLDescriptor() {\n            sType = SType::ShaderModuleWGSLDescriptor;\n        }\n        static constexpr size_t kFirstMemberAlignment = detail::ConstexprMax(alignof(ChainedStruct), alignof(char const * ));\n        alignas(kFirstMemberAlignment) char const * source;\n    };\n\n    struct StencilFaceState {\n        CompareFunction compare = CompareFunction::Always;\n        StencilOperation failOp = StencilOperation::Keep;\n        StencilOperation depthFailOp = StencilOperation::Keep;\n        StencilOperation passOp = StencilOperation::Keep;\n    };\n\n    struct StorageTextureBindingLayout {\n        ChainedStruct const * nextInChain = nullptr;\n        StorageTextureAccess access = StorageTextureAccess::Undefined;\n        TextureFormat format = TextureFormat::Undefined;\n        TextureViewDimension viewDimension = TextureViewDimension::Undefined;\n    };\n\n    struct SurfaceDescriptor {\n        ChainedStruct const * nextInChain = nullptr;\n        char const * label = nullptr;\n    };\n\n    struct SurfaceDescriptorFromAndroidNativeWindow : ChainedStruct {\n        SurfaceDescriptorFromAndroidNativeWindow() {\n            sType = SType::SurfaceDescriptorFromAndroidNativeWindow;\n        }\n        static constexpr size_t kFirstMemberAlignment = detail::ConstexprMax(alignof(ChainedStruct), alignof(void * ));\n        alignas(kFirstMemberAlignment) void * window;\n    };\n\n    struct SurfaceDescriptorFromCanvasHTMLSelector : ChainedStruct {\n        SurfaceDescriptorFromCanvasHTMLSelector() {\n            sType = SType::SurfaceDescriptorFromCanvasHTMLSelector;\n        }\n        static constexpr size_t kFirstMemberAlignment = detail::ConstexprMax(alignof(ChainedStruct), alignof(char const * ));\n        alignas(kFirstMemberAlignment) char const * selector;\n    };\n\n    struct SurfaceDescriptorFromMetalLayer : ChainedStruct {\n        SurfaceDescriptorFromMetalLayer() {\n            sType = SType::SurfaceDescriptorFromMetalLayer;\n        }\n        static constexpr size_t kFirstMemberAlignment = detail::ConstexprMax(alignof(ChainedStruct), alignof(void * ));\n        alignas(kFirstMemberAlignment) void * layer;\n    };\n\n    struct SurfaceDescriptorFromWaylandSurface : ChainedStruct {\n        SurfaceDescriptorFromWaylandSurface() {\n            sType = SType::SurfaceDescriptorFromWaylandSurface;\n        }\n        static constexpr size_t kFirstMemberAlignment = detail::ConstexprMax(alignof(ChainedStruct), alignof(void * ));\n        alignas(kFirstMemberAlignment) void * display;\n        void * surface;\n    };\n\n    struct SurfaceDescriptorFromWindowsCoreWindow : ChainedStruct {\n        SurfaceDescriptorFromWindowsCoreWindow() {\n            sType = SType::SurfaceDescriptorFromWindowsCoreWindow;\n        }\n        static constexpr size_t kFirstMemberAlignment = detail::ConstexprMax(alignof(ChainedStruct), alignof(void * ));\n        alignas(kFirstMemberAlignment) void * coreWindow;\n    };\n\n    struct SurfaceDescriptorFromWindowsHWND : ChainedStruct {\n        SurfaceDescriptorFromWindowsHWND() {\n            sType = SType::SurfaceDescriptorFromWindowsHWND;\n        }\n        static constexpr size_t kFirstMemberAlignment = detail::ConstexprMax(alignof(ChainedStruct), alignof(void * ));\n        alignas(kFirstMemberAlignment) void * hinstance;\n        void * hwnd;\n    };\n\n    struct SurfaceDescriptorFromWindowsSwapChainPanel : ChainedStruct {\n        SurfaceDescriptorFromWindowsSwapChainPanel() {\n            sType = SType::SurfaceDescriptorFromWindowsSwapChainPanel;\n        }\n        static constexpr size_t kFirstMemberAlignment = detail::ConstexprMax(alignof(ChainedStruct), alignof(void * ));\n        alignas(kFirstMemberAlignment) void * swapChainPanel;\n    };\n\n    struct SurfaceDescriptorFromXlibWindow : ChainedStruct {\n        SurfaceDescriptorFromXlibWindow() {\n            sType = SType::SurfaceDescriptorFromXlibWindow;\n        }\n        static constexpr size_t kFirstMemberAlignment = detail::ConstexprMax(alignof(ChainedStruct), alignof(void * ));\n        alignas(kFirstMemberAlignment) void * display;\n        uint32_t window;\n    };\n\n    struct SwapChainDescriptor {\n        ChainedStruct const * nextInChain = nullptr;\n        char const * label = nullptr;\n        TextureUsage usage;\n        TextureFormat format;\n        uint32_t width;\n        uint32_t height;\n        PresentMode presentMode;\n        uint64_t implementation = 0;\n    };\n\n    struct TextureBindingLayout {\n        ChainedStruct const * nextInChain = nullptr;\n        TextureSampleType sampleType = TextureSampleType::Undefined;\n        TextureViewDimension viewDimension = TextureViewDimension::Undefined;\n        bool multisampled = false;\n    };\n\n    struct TextureDataLayout {\n        ChainedStruct const * nextInChain = nullptr;\n        uint64_t offset = 0;\n        uint32_t bytesPerRow = WGPU_COPY_STRIDE_UNDEFINED;\n        uint32_t rowsPerImage = WGPU_COPY_STRIDE_UNDEFINED;\n    };\n\n    struct TextureViewDescriptor {\n        ChainedStruct const * nextInChain = nullptr;\n        char const * label = nullptr;\n        TextureFormat format = TextureFormat::Undefined;\n        TextureViewDimension dimension = TextureViewDimension::Undefined;\n        uint32_t baseMipLevel = 0;\n        uint32_t mipLevelCount = WGPU_MIP_LEVEL_COUNT_UNDEFINED;\n        uint32_t baseArrayLayer = 0;\n        uint32_t arrayLayerCount = WGPU_ARRAY_LAYER_COUNT_UNDEFINED;\n        TextureAspect aspect = TextureAspect::All;\n    };\n\n    struct VertexAttribute {\n        VertexFormat format;\n        uint64_t offset;\n        uint32_t shaderLocation;\n    };\n\n    struct BindGroupDescriptor {\n        ChainedStruct const * nextInChain = nullptr;\n        char const * label = nullptr;\n        BindGroupLayout layout;\n        uint32_t entryCount;\n        BindGroupEntry const * entries;\n    };\n\n    struct BindGroupLayoutEntry {\n        ChainedStruct const * nextInChain = nullptr;\n        uint32_t binding;\n        ShaderStage visibility;\n        BufferBindingLayout buffer;\n        SamplerBindingLayout sampler;\n        TextureBindingLayout texture;\n        StorageTextureBindingLayout storageTexture;\n    };\n\n    struct BlendState {\n        BlendComponent color;\n        BlendComponent alpha;\n    };\n\n    struct CompilationInfo {\n        ChainedStruct const * nextInChain = nullptr;\n        uint32_t messageCount;\n        CompilationMessage const * messages;\n    };\n\n    struct ComputePassDescriptor {\n        ChainedStruct const * nextInChain = nullptr;\n        char const * label = nullptr;\n        uint32_t timestampWriteCount = 0;\n        ComputePassTimestampWrite const * timestampWrites;\n    };\n\n    struct DepthStencilState {\n        ChainedStruct const * nextInChain = nullptr;\n        TextureFormat format;\n        bool depthWriteEnabled = false;\n        CompareFunction depthCompare = CompareFunction::Always;\n        StencilFaceState stencilFront;\n        StencilFaceState stencilBack;\n        uint32_t stencilReadMask = 0xFFFFFFFF;\n        uint32_t stencilWriteMask = 0xFFFFFFFF;\n        int32_t depthBias = 0;\n        float depthBiasSlopeScale = 0.0f;\n        float depthBiasClamp = 0.0f;\n    };\n\n    struct ImageCopyBuffer {\n        ChainedStruct const * nextInChain = nullptr;\n        TextureDataLayout layout;\n        Buffer buffer;\n    };\n\n    struct ImageCopyTexture {\n        ChainedStruct const * nextInChain = nullptr;\n        Texture texture;\n        uint32_t mipLevel = 0;\n        Origin3D origin;\n        TextureAspect aspect = TextureAspect::All;\n    };\n\n    struct ProgrammableStageDescriptor {\n        ChainedStruct const * nextInChain = nullptr;\n        ShaderModule module;\n        char const * entryPoint;\n        uint32_t constantCount = 0;\n        ConstantEntry const * constants;\n    };\n\n    struct RenderPassColorAttachment {\n        TextureView view = nullptr;\n        TextureView resolveTarget = nullptr;\n        LoadOp loadOp;\n        StoreOp storeOp;\n        Color clearColor = { NAN, NAN, NAN, NAN };\n        Color clearValue;\n    };\n\n    struct RequiredLimits {\n        ChainedStruct const * nextInChain = nullptr;\n        Limits limits;\n    };\n\n    struct SupportedLimits {\n        ChainedStructOut  * nextInChain = nullptr;\n        Limits limits;\n    };\n\n    struct TextureDescriptor {\n        ChainedStruct const * nextInChain = nullptr;\n        char const * label = nullptr;\n        TextureUsage usage;\n        TextureDimension dimension = TextureDimension::e2D;\n        Extent3D size;\n        TextureFormat format;\n        uint32_t mipLevelCount = 1;\n        uint32_t sampleCount = 1;\n        uint32_t viewFormatCount = 0;\n        TextureFormat const * viewFormats;\n    };\n\n    struct VertexBufferLayout {\n        uint64_t arrayStride;\n        VertexStepMode stepMode = VertexStepMode::Vertex;\n        uint32_t attributeCount;\n        VertexAttribute const * attributes;\n    };\n\n    struct BindGroupLayoutDescriptor {\n        ChainedStruct const * nextInChain = nullptr;\n        char const * label = nullptr;\n        uint32_t entryCount;\n        BindGroupLayoutEntry const * entries;\n    };\n\n    struct ColorTargetState {\n        ChainedStruct const * nextInChain = nullptr;\n        TextureFormat format;\n        BlendState const * blend = nullptr;\n        ColorWriteMask writeMask = ColorWriteMask::All;\n    };\n\n    struct ComputePipelineDescriptor {\n        ChainedStruct const * nextInChain = nullptr;\n        char const * label = nullptr;\n        PipelineLayout layout = nullptr;\n        ProgrammableStageDescriptor compute;\n    };\n\n    struct DeviceDescriptor {\n        ChainedStruct const * nextInChain = nullptr;\n        char const * label = nullptr;\n        uint32_t requiredFeaturesCount = 0;\n        FeatureName const * requiredFeatures = nullptr;\n        RequiredLimits const * requiredLimits = nullptr;\n        QueueDescriptor defaultQueue;\n    };\n\n    struct RenderPassDescriptor {\n        ChainedStruct const * nextInChain = nullptr;\n        char const * label = nullptr;\n        uint32_t colorAttachmentCount;\n        RenderPassColorAttachment const * colorAttachments;\n        RenderPassDepthStencilAttachment const * depthStencilAttachment = nullptr;\n        QuerySet occlusionQuerySet = nullptr;\n        uint32_t timestampWriteCount = 0;\n        RenderPassTimestampWrite const * timestampWrites;\n    };\n\n    struct VertexState {\n        ChainedStruct const * nextInChain = nullptr;\n        ShaderModule module;\n        char const * entryPoint;\n        uint32_t constantCount = 0;\n        ConstantEntry const * constants;\n        uint32_t bufferCount = 0;\n        VertexBufferLayout const * buffers;\n    };\n\n    struct FragmentState {\n        ChainedStruct const * nextInChain = nullptr;\n        ShaderModule module;\n        char const * entryPoint;\n        uint32_t constantCount = 0;\n        ConstantEntry const * constants;\n        uint32_t targetCount;\n        ColorTargetState const * targets;\n    };\n\n    struct RenderPipelineDescriptor {\n        ChainedStruct const * nextInChain = nullptr;\n        char const * label = nullptr;\n        PipelineLayout layout = nullptr;\n        VertexState vertex;\n        PrimitiveState primitive;\n        DepthStencilState const * depthStencil = nullptr;\n        MultisampleState multisample;\n        FragmentState const * fragment = nullptr;\n    };\n\n\n    // The operators of EnumClassBitmmasks in the dawn:: namespace need to be imported\n    // in the wgpu namespace for Argument Dependent Lookup.\n    DAWN_IMPORT_BITMASK_OPERATORS\n}  // namespace wgpu\n\nnamespace dawn {\n    template<>\n    struct IsDawnBitmask<wgpu::BufferUsage> {\n        static constexpr bool enable = true;\n    };\n\n    template<>\n    struct IsDawnBitmask<wgpu::ColorWriteMask> {\n        static constexpr bool enable = true;\n    };\n\n    template<>\n    struct IsDawnBitmask<wgpu::MapMode> {\n        static constexpr bool enable = true;\n    };\n\n    template<>\n    struct IsDawnBitmask<wgpu::ShaderStage> {\n        static constexpr bool enable = true;\n    };\n\n    template<>\n    struct IsDawnBitmask<wgpu::TextureUsage> {\n        static constexpr bool enable = true;\n    };\n\n} // namespace dawn\n\n#endif // WEBGPU_CPP_H_\n", "include/dawn/webgpu_cpp_print.h": "\n#ifndef WEBGPU_CPP_PRINT_H_\n#define WEBGPU_CPP_PRINT_H_\n\n#include \"dawn/webgpu_cpp.h\"\n\n#include <iomanip>\n#include <ios>\n#include <ostream>\n#include <type_traits>\n\nnamespace wgpu {\n\n  template <typename CharT, typename Traits>\n  std::basic_ostream<CharT, Traits>& operator<<(std::basic_ostream<CharT, Traits>& o, AdapterType value) {\n      switch (value) {\n      case AdapterType::DiscreteGPU:\n        o << \"AdapterType::DiscreteGPU\";\n        break;\n      case AdapterType::IntegratedGPU:\n        o << \"AdapterType::IntegratedGPU\";\n        break;\n      case AdapterType::CPU:\n        o << \"AdapterType::CPU\";\n        break;\n      case AdapterType::Unknown:\n        o << \"AdapterType::Unknown\";\n        break;\n          default:\n            o << \"AdapterType::\" << std::showbase << std::hex << std::setfill('0') << std::setw(4) << static_cast<typename std::underlying_type<AdapterType>::type>(value);\n      }\n      return o;\n  }\n  template <typename CharT, typename Traits>\n  std::basic_ostream<CharT, Traits>& operator<<(std::basic_ostream<CharT, Traits>& o, AddressMode value) {\n      switch (value) {\n      case AddressMode::Repeat:\n        o << \"AddressMode::Repeat\";\n        break;\n      case AddressMode::MirrorRepeat:\n        o << \"AddressMode::MirrorRepeat\";\n        break;\n      case AddressMode::ClampToEdge:\n        o << \"AddressMode::ClampToEdge\";\n        break;\n          default:\n            o << \"AddressMode::\" << std::showbase << std::hex << std::setfill('0') << std::setw(4) << static_cast<typename std::underlying_type<AddressMode>::type>(value);\n      }\n      return o;\n  }\n  template <typename CharT, typename Traits>\n  std::basic_ostream<CharT, Traits>& operator<<(std::basic_ostream<CharT, Traits>& o, AlphaMode value) {\n      switch (value) {\n      case AlphaMode::Premultiplied:\n        o << \"AlphaMode::Premultiplied\";\n        break;\n      case AlphaMode::Unpremultiplied:\n        o << \"AlphaMode::Unpremultiplied\";\n        break;\n          default:\n            o << \"AlphaMode::\" << std::showbase << std::hex << std::setfill('0') << std::setw(4) << static_cast<typename std::underlying_type<AlphaMode>::type>(value);\n      }\n      return o;\n  }\n  template <typename CharT, typename Traits>\n  std::basic_ostream<CharT, Traits>& operator<<(std::basic_ostream<CharT, Traits>& o, BackendType value) {\n      switch (value) {\n      case BackendType::Null:\n        o << \"BackendType::Null\";\n        break;\n      case BackendType::WebGPU:\n        o << \"BackendType::WebGPU\";\n        break;\n      case BackendType::D3D11:\n        o << \"BackendType::D3D11\";\n        break;\n      case BackendType::D3D12:\n        o << \"BackendType::D3D12\";\n        break;\n      case BackendType::Metal:\n        o << \"BackendType::Metal\";\n        break;\n      case BackendType::Vulkan:\n        o << \"BackendType::Vulkan\";\n        break;\n      case BackendType::OpenGL:\n        o << \"BackendType::OpenGL\";\n        break;\n      case BackendType::OpenGLES:\n        o << \"BackendType::OpenGLES\";\n        break;\n          default:\n            o << \"BackendType::\" << std::showbase << std::hex << std::setfill('0') << std::setw(4) << static_cast<typename std::underlying_type<BackendType>::type>(value);\n      }\n      return o;\n  }\n  template <typename CharT, typename Traits>\n  std::basic_ostream<CharT, Traits>& operator<<(std::basic_ostream<CharT, Traits>& o, BlendFactor value) {\n      switch (value) {\n      case BlendFactor::Zero:\n        o << \"BlendFactor::Zero\";\n        break;\n      case BlendFactor::One:\n        o << \"BlendFactor::One\";\n        break;\n      case BlendFactor::Src:\n        o << \"BlendFactor::Src\";\n        break;\n      case BlendFactor::OneMinusSrc:\n        o << \"BlendFactor::OneMinusSrc\";\n        break;\n      case BlendFactor::SrcAlpha:\n        o << \"BlendFactor::SrcAlpha\";\n        break;\n      case BlendFactor::OneMinusSrcAlpha:\n        o << \"BlendFactor::OneMinusSrcAlpha\";\n        break;\n      case BlendFactor::Dst:\n        o << \"BlendFactor::Dst\";\n        break;\n      case BlendFactor::OneMinusDst:\n        o << \"BlendFactor::OneMinusDst\";\n        break;\n      case BlendFactor::DstAlpha:\n        o << \"BlendFactor::DstAlpha\";\n        break;\n      case BlendFactor::OneMinusDstAlpha:\n        o << \"BlendFactor::OneMinusDstAlpha\";\n        break;\n      case BlendFactor::SrcAlphaSaturated:\n        o << \"BlendFactor::SrcAlphaSaturated\";\n        break;\n      case BlendFactor::Constant:\n        o << \"BlendFactor::Constant\";\n        break;\n      case BlendFactor::OneMinusConstant:\n        o << \"BlendFactor::OneMinusConstant\";\n        break;\n          default:\n            o << \"BlendFactor::\" << std::showbase << std::hex << std::setfill('0') << std::setw(4) << static_cast<typename std::underlying_type<BlendFactor>::type>(value);\n      }\n      return o;\n  }\n  template <typename CharT, typename Traits>\n  std::basic_ostream<CharT, Traits>& operator<<(std::basic_ostream<CharT, Traits>& o, BlendOperation value) {\n      switch (value) {\n      case BlendOperation::Add:\n        o << \"BlendOperation::Add\";\n        break;\n      case BlendOperation::Subtract:\n        o << \"BlendOperation::Subtract\";\n        break;\n      case BlendOperation::ReverseSubtract:\n        o << \"BlendOperation::ReverseSubtract\";\n        break;\n      case BlendOperation::Min:\n        o << \"BlendOperation::Min\";\n        break;\n      case BlendOperation::Max:\n        o << \"BlendOperation::Max\";\n        break;\n          default:\n            o << \"BlendOperation::\" << std::showbase << std::hex << std::setfill('0') << std::setw(4) << static_cast<typename std::underlying_type<BlendOperation>::type>(value);\n      }\n      return o;\n  }\n  template <typename CharT, typename Traits>\n  std::basic_ostream<CharT, Traits>& operator<<(std::basic_ostream<CharT, Traits>& o, BufferBindingType value) {\n      switch (value) {\n      case BufferBindingType::Undefined:\n        o << \"BufferBindingType::Undefined\";\n        break;\n      case BufferBindingType::Uniform:\n        o << \"BufferBindingType::Uniform\";\n        break;\n      case BufferBindingType::Storage:\n        o << \"BufferBindingType::Storage\";\n        break;\n      case BufferBindingType::ReadOnlyStorage:\n        o << \"BufferBindingType::ReadOnlyStorage\";\n        break;\n          default:\n            o << \"BufferBindingType::\" << std::showbase << std::hex << std::setfill('0') << std::setw(4) << static_cast<typename std::underlying_type<BufferBindingType>::type>(value);\n      }\n      return o;\n  }\n  template <typename CharT, typename Traits>\n  std::basic_ostream<CharT, Traits>& operator<<(std::basic_ostream<CharT, Traits>& o, BufferMapAsyncStatus value) {\n      switch (value) {\n      case BufferMapAsyncStatus::Success:\n        o << \"BufferMapAsyncStatus::Success\";\n        break;\n      case BufferMapAsyncStatus::Error:\n        o << \"BufferMapAsyncStatus::Error\";\n        break;\n      case BufferMapAsyncStatus::Unknown:\n        o << \"BufferMapAsyncStatus::Unknown\";\n        break;\n      case BufferMapAsyncStatus::DeviceLost:\n        o << \"BufferMapAsyncStatus::DeviceLost\";\n        break;\n      case BufferMapAsyncStatus::DestroyedBeforeCallback:\n        o << \"BufferMapAsyncStatus::DestroyedBeforeCallback\";\n        break;\n      case BufferMapAsyncStatus::UnmappedBeforeCallback:\n        o << \"BufferMapAsyncStatus::UnmappedBeforeCallback\";\n        break;\n          default:\n            o << \"BufferMapAsyncStatus::\" << std::showbase << std::hex << std::setfill('0') << std::setw(4) << static_cast<typename std::underlying_type<BufferMapAsyncStatus>::type>(value);\n      }\n      return o;\n  }\n  template <typename CharT, typename Traits>\n  std::basic_ostream<CharT, Traits>& operator<<(std::basic_ostream<CharT, Traits>& o, CompareFunction value) {\n      switch (value) {\n      case CompareFunction::Undefined:\n        o << \"CompareFunction::Undefined\";\n        break;\n      case CompareFunction::Never:\n        o << \"CompareFunction::Never\";\n        break;\n      case CompareFunction::Less:\n        o << \"CompareFunction::Less\";\n        break;\n      case CompareFunction::LessEqual:\n        o << \"CompareFunction::LessEqual\";\n        break;\n      case CompareFunction::Greater:\n        o << \"CompareFunction::Greater\";\n        break;\n      case CompareFunction::GreaterEqual:\n        o << \"CompareFunction::GreaterEqual\";\n        break;\n      case CompareFunction::Equal:\n        o << \"CompareFunction::Equal\";\n        break;\n      case CompareFunction::NotEqual:\n        o << \"CompareFunction::NotEqual\";\n        break;\n      case CompareFunction::Always:\n        o << \"CompareFunction::Always\";\n        break;\n          default:\n            o << \"CompareFunction::\" << std::showbase << std::hex << std::setfill('0') << std::setw(4) << static_cast<typename std::underlying_type<CompareFunction>::type>(value);\n      }\n      return o;\n  }\n  template <typename CharT, typename Traits>\n  std::basic_ostream<CharT, Traits>& operator<<(std::basic_ostream<CharT, Traits>& o, CompilationInfoRequestStatus value) {\n      switch (value) {\n      case CompilationInfoRequestStatus::Success:\n        o << \"CompilationInfoRequestStatus::Success\";\n        break;\n      case CompilationInfoRequestStatus::Error:\n        o << \"CompilationInfoRequestStatus::Error\";\n        break;\n      case CompilationInfoRequestStatus::DeviceLost:\n        o << \"CompilationInfoRequestStatus::DeviceLost\";\n        break;\n      case CompilationInfoRequestStatus::Unknown:\n        o << \"CompilationInfoRequestStatus::Unknown\";\n        break;\n          default:\n            o << \"CompilationInfoRequestStatus::\" << std::showbase << std::hex << std::setfill('0') << std::setw(4) << static_cast<typename std::underlying_type<CompilationInfoRequestStatus>::type>(value);\n      }\n      return o;\n  }\n  template <typename CharT, typename Traits>\n  std::basic_ostream<CharT, Traits>& operator<<(std::basic_ostream<CharT, Traits>& o, CompilationMessageType value) {\n      switch (value) {\n      case CompilationMessageType::Error:\n        o << \"CompilationMessageType::Error\";\n        break;\n      case CompilationMessageType::Warning:\n        o << \"CompilationMessageType::Warning\";\n        break;\n      case CompilationMessageType::Info:\n        o << \"CompilationMessageType::Info\";\n        break;\n          default:\n            o << \"CompilationMessageType::\" << std::showbase << std::hex << std::setfill('0') << std::setw(4) << static_cast<typename std::underlying_type<CompilationMessageType>::type>(value);\n      }\n      return o;\n  }\n  template <typename CharT, typename Traits>\n  std::basic_ostream<CharT, Traits>& operator<<(std::basic_ostream<CharT, Traits>& o, ComputePassTimestampLocation value) {\n      switch (value) {\n      case ComputePassTimestampLocation::Beginning:\n        o << \"ComputePassTimestampLocation::Beginning\";\n        break;\n      case ComputePassTimestampLocation::End:\n        o << \"ComputePassTimestampLocation::End\";\n        break;\n          default:\n            o << \"ComputePassTimestampLocation::\" << std::showbase << std::hex << std::setfill('0') << std::setw(4) << static_cast<typename std::underlying_type<ComputePassTimestampLocation>::type>(value);\n      }\n      return o;\n  }\n  template <typename CharT, typename Traits>\n  std::basic_ostream<CharT, Traits>& operator<<(std::basic_ostream<CharT, Traits>& o, CreatePipelineAsyncStatus value) {\n      switch (value) {\n      case CreatePipelineAsyncStatus::Success:\n        o << \"CreatePipelineAsyncStatus::Success\";\n        break;\n      case CreatePipelineAsyncStatus::Error:\n        o << \"CreatePipelineAsyncStatus::Error\";\n        break;\n      case CreatePipelineAsyncStatus::DeviceLost:\n        o << \"CreatePipelineAsyncStatus::DeviceLost\";\n        break;\n      case CreatePipelineAsyncStatus::DeviceDestroyed:\n        o << \"CreatePipelineAsyncStatus::DeviceDestroyed\";\n        break;\n      case CreatePipelineAsyncStatus::Unknown:\n        o << \"CreatePipelineAsyncStatus::Unknown\";\n        break;\n          default:\n            o << \"CreatePipelineAsyncStatus::\" << std::showbase << std::hex << std::setfill('0') << std::setw(4) << static_cast<typename std::underlying_type<CreatePipelineAsyncStatus>::type>(value);\n      }\n      return o;\n  }\n  template <typename CharT, typename Traits>\n  std::basic_ostream<CharT, Traits>& operator<<(std::basic_ostream<CharT, Traits>& o, CullMode value) {\n      switch (value) {\n      case CullMode::None:\n        o << \"CullMode::None\";\n        break;\n      case CullMode::Front:\n        o << \"CullMode::Front\";\n        break;\n      case CullMode::Back:\n        o << \"CullMode::Back\";\n        break;\n          default:\n            o << \"CullMode::\" << std::showbase << std::hex << std::setfill('0') << std::setw(4) << static_cast<typename std::underlying_type<CullMode>::type>(value);\n      }\n      return o;\n  }\n  template <typename CharT, typename Traits>\n  std::basic_ostream<CharT, Traits>& operator<<(std::basic_ostream<CharT, Traits>& o, DeviceLostReason value) {\n      switch (value) {\n      case DeviceLostReason::Undefined:\n        o << \"DeviceLostReason::Undefined\";\n        break;\n      case DeviceLostReason::Destroyed:\n        o << \"DeviceLostReason::Destroyed\";\n        break;\n          default:\n            o << \"DeviceLostReason::\" << std::showbase << std::hex << std::setfill('0') << std::setw(4) << static_cast<typename std::underlying_type<DeviceLostReason>::type>(value);\n      }\n      return o;\n  }\n  template <typename CharT, typename Traits>\n  std::basic_ostream<CharT, Traits>& operator<<(std::basic_ostream<CharT, Traits>& o, ErrorFilter value) {\n      switch (value) {\n      case ErrorFilter::Validation:\n        o << \"ErrorFilter::Validation\";\n        break;\n      case ErrorFilter::OutOfMemory:\n        o << \"ErrorFilter::OutOfMemory\";\n        break;\n          default:\n            o << \"ErrorFilter::\" << std::showbase << std::hex << std::setfill('0') << std::setw(4) << static_cast<typename std::underlying_type<ErrorFilter>::type>(value);\n      }\n      return o;\n  }\n  template <typename CharT, typename Traits>\n  std::basic_ostream<CharT, Traits>& operator<<(std::basic_ostream<CharT, Traits>& o, ErrorType value) {\n      switch (value) {\n      case ErrorType::NoError:\n        o << \"ErrorType::NoError\";\n        break;\n      case ErrorType::Validation:\n        o << \"ErrorType::Validation\";\n        break;\n      case ErrorType::OutOfMemory:\n        o << \"ErrorType::OutOfMemory\";\n        break;\n      case ErrorType::Unknown:\n        o << \"ErrorType::Unknown\";\n        break;\n      case ErrorType::DeviceLost:\n        o << \"ErrorType::DeviceLost\";\n        break;\n          default:\n            o << \"ErrorType::\" << std::showbase << std::hex << std::setfill('0') << std::setw(4) << static_cast<typename std::underlying_type<ErrorType>::type>(value);\n      }\n      return o;\n  }\n  template <typename CharT, typename Traits>\n  std::basic_ostream<CharT, Traits>& operator<<(std::basic_ostream<CharT, Traits>& o, FeatureName value) {\n      switch (value) {\n      case FeatureName::Undefined:\n        o << \"FeatureName::Undefined\";\n        break;\n      case FeatureName::DepthClipControl:\n        o << \"FeatureName::DepthClipControl\";\n        break;\n      case FeatureName::Depth32FloatStencil8:\n        o << \"FeatureName::Depth32FloatStencil8\";\n        break;\n      case FeatureName::TimestampQuery:\n        o << \"FeatureName::TimestampQuery\";\n        break;\n      case FeatureName::PipelineStatisticsQuery:\n        o << \"FeatureName::PipelineStatisticsQuery\";\n        break;\n      case FeatureName::TextureCompressionBC:\n        o << \"FeatureName::TextureCompressionBC\";\n        break;\n      case FeatureName::TextureCompressionETC2:\n        o << \"FeatureName::TextureCompressionETC2\";\n        break;\n      case FeatureName::TextureCompressionASTC:\n        o << \"FeatureName::TextureCompressionASTC\";\n        break;\n      case FeatureName::IndirectFirstInstance:\n        o << \"FeatureName::IndirectFirstInstance\";\n        break;\n      case FeatureName::DepthClamping:\n        o << \"FeatureName::DepthClamping\";\n        break;\n      case FeatureName::DawnShaderFloat16:\n        o << \"FeatureName::DawnShaderFloat16\";\n        break;\n      case FeatureName::DawnInternalUsages:\n        o << \"FeatureName::DawnInternalUsages\";\n        break;\n      case FeatureName::DawnMultiPlanarFormats:\n        o << \"FeatureName::DawnMultiPlanarFormats\";\n        break;\n      case FeatureName::DawnNative:\n        o << \"FeatureName::DawnNative\";\n        break;\n      case FeatureName::ChromiumExperimentalDp4a:\n        o << \"FeatureName::ChromiumExperimentalDp4a\";\n        break;\n          default:\n            o << \"FeatureName::\" << std::showbase << std::hex << std::setfill('0') << std::setw(4) << static_cast<typename std::underlying_type<FeatureName>::type>(value);\n      }\n      return o;\n  }\n  template <typename CharT, typename Traits>\n  std::basic_ostream<CharT, Traits>& operator<<(std::basic_ostream<CharT, Traits>& o, FilterMode value) {\n      switch (value) {\n      case FilterMode::Nearest:\n        o << \"FilterMode::Nearest\";\n        break;\n      case FilterMode::Linear:\n        o << \"FilterMode::Linear\";\n        break;\n          default:\n            o << \"FilterMode::\" << std::showbase << std::hex << std::setfill('0') << std::setw(4) << static_cast<typename std::underlying_type<FilterMode>::type>(value);\n      }\n      return o;\n  }\n  template <typename CharT, typename Traits>\n  std::basic_ostream<CharT, Traits>& operator<<(std::basic_ostream<CharT, Traits>& o, FrontFace value) {\n      switch (value) {\n      case FrontFace::CCW:\n        o << \"FrontFace::CCW\";\n        break;\n      case FrontFace::CW:\n        o << \"FrontFace::CW\";\n        break;\n          default:\n            o << \"FrontFace::\" << std::showbase << std::hex << std::setfill('0') << std::setw(4) << static_cast<typename std::underlying_type<FrontFace>::type>(value);\n      }\n      return o;\n  }\n  template <typename CharT, typename Traits>\n  std::basic_ostream<CharT, Traits>& operator<<(std::basic_ostream<CharT, Traits>& o, IndexFormat value) {\n      switch (value) {\n      case IndexFormat::Undefined:\n        o << \"IndexFormat::Undefined\";\n        break;\n      case IndexFormat::Uint16:\n        o << \"IndexFormat::Uint16\";\n        break;\n      case IndexFormat::Uint32:\n        o << \"IndexFormat::Uint32\";\n        break;\n          default:\n            o << \"IndexFormat::\" << std::showbase << std::hex << std::setfill('0') << std::setw(4) << static_cast<typename std::underlying_type<IndexFormat>::type>(value);\n      }\n      return o;\n  }\n  template <typename CharT, typename Traits>\n  std::basic_ostream<CharT, Traits>& operator<<(std::basic_ostream<CharT, Traits>& o, LoadOp value) {\n      switch (value) {\n      case LoadOp::Undefined:\n        o << \"LoadOp::Undefined\";\n        break;\n      case LoadOp::Clear:\n        o << \"LoadOp::Clear\";\n        break;\n      case LoadOp::Load:\n        o << \"LoadOp::Load\";\n        break;\n          default:\n            o << \"LoadOp::\" << std::showbase << std::hex << std::setfill('0') << std::setw(4) << static_cast<typename std::underlying_type<LoadOp>::type>(value);\n      }\n      return o;\n  }\n  template <typename CharT, typename Traits>\n  std::basic_ostream<CharT, Traits>& operator<<(std::basic_ostream<CharT, Traits>& o, LoggingType value) {\n      switch (value) {\n      case LoggingType::Verbose:\n        o << \"LoggingType::Verbose\";\n        break;\n      case LoggingType::Info:\n        o << \"LoggingType::Info\";\n        break;\n      case LoggingType::Warning:\n        o << \"LoggingType::Warning\";\n        break;\n      case LoggingType::Error:\n        o << \"LoggingType::Error\";\n        break;\n          default:\n            o << \"LoggingType::\" << std::showbase << std::hex << std::setfill('0') << std::setw(4) << static_cast<typename std::underlying_type<LoggingType>::type>(value);\n      }\n      return o;\n  }\n  template <typename CharT, typename Traits>\n  std::basic_ostream<CharT, Traits>& operator<<(std::basic_ostream<CharT, Traits>& o, PipelineStatisticName value) {\n      switch (value) {\n      case PipelineStatisticName::VertexShaderInvocations:\n        o << \"PipelineStatisticName::VertexShaderInvocations\";\n        break;\n      case PipelineStatisticName::ClipperInvocations:\n        o << \"PipelineStatisticName::ClipperInvocations\";\n        break;\n      case PipelineStatisticName::ClipperPrimitivesOut:\n        o << \"PipelineStatisticName::ClipperPrimitivesOut\";\n        break;\n      case PipelineStatisticName::FragmentShaderInvocations:\n        o << \"PipelineStatisticName::FragmentShaderInvocations\";\n        break;\n      case PipelineStatisticName::ComputeShaderInvocations:\n        o << \"PipelineStatisticName::ComputeShaderInvocations\";\n        break;\n          default:\n            o << \"PipelineStatisticName::\" << std::showbase << std::hex << std::setfill('0') << std::setw(4) << static_cast<typename std::underlying_type<PipelineStatisticName>::type>(value);\n      }\n      return o;\n  }\n  template <typename CharT, typename Traits>\n  std::basic_ostream<CharT, Traits>& operator<<(std::basic_ostream<CharT, Traits>& o, PowerPreference value) {\n      switch (value) {\n      case PowerPreference::Undefined:\n        o << \"PowerPreference::Undefined\";\n        break;\n      case PowerPreference::LowPower:\n        o << \"PowerPreference::LowPower\";\n        break;\n      case PowerPreference::HighPerformance:\n        o << \"PowerPreference::HighPerformance\";\n        break;\n          default:\n            o << \"PowerPreference::\" << std::showbase << std::hex << std::setfill('0') << std::setw(4) << static_cast<typename std::underlying_type<PowerPreference>::type>(value);\n      }\n      return o;\n  }\n  template <typename CharT, typename Traits>\n  std::basic_ostream<CharT, Traits>& operator<<(std::basic_ostream<CharT, Traits>& o, PresentMode value) {\n      switch (value) {\n      case PresentMode::Immediate:\n        o << \"PresentMode::Immediate\";\n        break;\n      case PresentMode::Mailbox:\n        o << \"PresentMode::Mailbox\";\n        break;\n      case PresentMode::Fifo:\n        o << \"PresentMode::Fifo\";\n        break;\n          default:\n            o << \"PresentMode::\" << std::showbase << std::hex << std::setfill('0') << std::setw(4) << static_cast<typename std::underlying_type<PresentMode>::type>(value);\n      }\n      return o;\n  }\n  template <typename CharT, typename Traits>\n  std::basic_ostream<CharT, Traits>& operator<<(std::basic_ostream<CharT, Traits>& o, PrimitiveTopology value) {\n      switch (value) {\n      case PrimitiveTopology::PointList:\n        o << \"PrimitiveTopology::PointList\";\n        break;\n      case PrimitiveTopology::LineList:\n        o << \"PrimitiveTopology::LineList\";\n        break;\n      case PrimitiveTopology::LineStrip:\n        o << \"PrimitiveTopology::LineStrip\";\n        break;\n      case PrimitiveTopology::TriangleList:\n        o << \"PrimitiveTopology::TriangleList\";\n        break;\n      case PrimitiveTopology::TriangleStrip:\n        o << \"PrimitiveTopology::TriangleStrip\";\n        break;\n          default:\n            o << \"PrimitiveTopology::\" << std::showbase << std::hex << std::setfill('0') << std::setw(4) << static_cast<typename std::underlying_type<PrimitiveTopology>::type>(value);\n      }\n      return o;\n  }\n  template <typename CharT, typename Traits>\n  std::basic_ostream<CharT, Traits>& operator<<(std::basic_ostream<CharT, Traits>& o, QueryType value) {\n      switch (value) {\n      case QueryType::Occlusion:\n        o << \"QueryType::Occlusion\";\n        break;\n      case QueryType::PipelineStatistics:\n        o << \"QueryType::PipelineStatistics\";\n        break;\n      case QueryType::Timestamp:\n        o << \"QueryType::Timestamp\";\n        break;\n          default:\n            o << \"QueryType::\" << std::showbase << std::hex << std::setfill('0') << std::setw(4) << static_cast<typename std::underlying_type<QueryType>::type>(value);\n      }\n      return o;\n  }\n  template <typename CharT, typename Traits>\n  std::basic_ostream<CharT, Traits>& operator<<(std::basic_ostream<CharT, Traits>& o, QueueWorkDoneStatus value) {\n      switch (value) {\n      case QueueWorkDoneStatus::Success:\n        o << \"QueueWorkDoneStatus::Success\";\n        break;\n      case QueueWorkDoneStatus::Error:\n        o << \"QueueWorkDoneStatus::Error\";\n        break;\n      case QueueWorkDoneStatus::Unknown:\n        o << \"QueueWorkDoneStatus::Unknown\";\n        break;\n      case QueueWorkDoneStatus::DeviceLost:\n        o << \"QueueWorkDoneStatus::DeviceLost\";\n        break;\n          default:\n            o << \"QueueWorkDoneStatus::\" << std::showbase << std::hex << std::setfill('0') << std::setw(4) << static_cast<typename std::underlying_type<QueueWorkDoneStatus>::type>(value);\n      }\n      return o;\n  }\n  template <typename CharT, typename Traits>\n  std::basic_ostream<CharT, Traits>& operator<<(std::basic_ostream<CharT, Traits>& o, RenderPassTimestampLocation value) {\n      switch (value) {\n      case RenderPassTimestampLocation::Beginning:\n        o << \"RenderPassTimestampLocation::Beginning\";\n        break;\n      case RenderPassTimestampLocation::End:\n        o << \"RenderPassTimestampLocation::End\";\n        break;\n          default:\n            o << \"RenderPassTimestampLocation::\" << std::showbase << std::hex << std::setfill('0') << std::setw(4) << static_cast<typename std::underlying_type<RenderPassTimestampLocation>::type>(value);\n      }\n      return o;\n  }\n  template <typename CharT, typename Traits>\n  std::basic_ostream<CharT, Traits>& operator<<(std::basic_ostream<CharT, Traits>& o, RequestAdapterStatus value) {\n      switch (value) {\n      case RequestAdapterStatus::Success:\n        o << \"RequestAdapterStatus::Success\";\n        break;\n      case RequestAdapterStatus::Unavailable:\n        o << \"RequestAdapterStatus::Unavailable\";\n        break;\n      case RequestAdapterStatus::Error:\n        o << \"RequestAdapterStatus::Error\";\n        break;\n      case RequestAdapterStatus::Unknown:\n        o << \"RequestAdapterStatus::Unknown\";\n        break;\n          default:\n            o << \"RequestAdapterStatus::\" << std::showbase << std::hex << std::setfill('0') << std::setw(4) << static_cast<typename std::underlying_type<RequestAdapterStatus>::type>(value);\n      }\n      return o;\n  }\n  template <typename CharT, typename Traits>\n  std::basic_ostream<CharT, Traits>& operator<<(std::basic_ostream<CharT, Traits>& o, RequestDeviceStatus value) {\n      switch (value) {\n      case RequestDeviceStatus::Success:\n        o << \"RequestDeviceStatus::Success\";\n        break;\n      case RequestDeviceStatus::Error:\n        o << \"RequestDeviceStatus::Error\";\n        break;\n      case RequestDeviceStatus::Unknown:\n        o << \"RequestDeviceStatus::Unknown\";\n        break;\n          default:\n            o << \"RequestDeviceStatus::\" << std::showbase << std::hex << std::setfill('0') << std::setw(4) << static_cast<typename std::underlying_type<RequestDeviceStatus>::type>(value);\n      }\n      return o;\n  }\n  template <typename CharT, typename Traits>\n  std::basic_ostream<CharT, Traits>& operator<<(std::basic_ostream<CharT, Traits>& o, SType value) {\n      switch (value) {\n      case SType::Invalid:\n        o << \"SType::Invalid\";\n        break;\n      case SType::SurfaceDescriptorFromMetalLayer:\n        o << \"SType::SurfaceDescriptorFromMetalLayer\";\n        break;\n      case SType::SurfaceDescriptorFromWindowsHWND:\n        o << \"SType::SurfaceDescriptorFromWindowsHWND\";\n        break;\n      case SType::SurfaceDescriptorFromXlibWindow:\n        o << \"SType::SurfaceDescriptorFromXlibWindow\";\n        break;\n      case SType::SurfaceDescriptorFromCanvasHTMLSelector:\n        o << \"SType::SurfaceDescriptorFromCanvasHTMLSelector\";\n        break;\n      case SType::ShaderModuleSPIRVDescriptor:\n        o << \"SType::ShaderModuleSPIRVDescriptor\";\n        break;\n      case SType::ShaderModuleWGSLDescriptor:\n        o << \"SType::ShaderModuleWGSLDescriptor\";\n        break;\n      case SType::PrimitiveDepthClipControl:\n        o << \"SType::PrimitiveDepthClipControl\";\n        break;\n      case SType::SurfaceDescriptorFromWaylandSurface:\n        o << \"SType::SurfaceDescriptorFromWaylandSurface\";\n        break;\n      case SType::SurfaceDescriptorFromAndroidNativeWindow:\n        o << \"SType::SurfaceDescriptorFromAndroidNativeWindow\";\n        break;\n      case SType::SurfaceDescriptorFromWindowsCoreWindow:\n        o << \"SType::SurfaceDescriptorFromWindowsCoreWindow\";\n        break;\n      case SType::ExternalTextureBindingEntry:\n        o << \"SType::ExternalTextureBindingEntry\";\n        break;\n      case SType::ExternalTextureBindingLayout:\n        o << \"SType::ExternalTextureBindingLayout\";\n        break;\n      case SType::SurfaceDescriptorFromWindowsSwapChainPanel:\n        o << \"SType::SurfaceDescriptorFromWindowsSwapChainPanel\";\n        break;\n      case SType::RenderPassDescriptorMaxDrawCount:\n        o << \"SType::RenderPassDescriptorMaxDrawCount\";\n        break;\n      case SType::DawnTextureInternalUsageDescriptor:\n        o << \"SType::DawnTextureInternalUsageDescriptor\";\n        break;\n      case SType::PrimitiveDepthClampingState:\n        o << \"SType::PrimitiveDepthClampingState\";\n        break;\n      case SType::DawnTogglesDeviceDescriptor:\n        o << \"SType::DawnTogglesDeviceDescriptor\";\n        break;\n      case SType::DawnEncoderInternalUsageDescriptor:\n        o << \"SType::DawnEncoderInternalUsageDescriptor\";\n        break;\n      case SType::DawnInstanceDescriptor:\n        o << \"SType::DawnInstanceDescriptor\";\n        break;\n      case SType::DawnCacheDeviceDescriptor:\n        o << \"SType::DawnCacheDeviceDescriptor\";\n        break;\n          default:\n            o << \"SType::\" << std::showbase << std::hex << std::setfill('0') << std::setw(4) << static_cast<typename std::underlying_type<SType>::type>(value);\n      }\n      return o;\n  }\n  template <typename CharT, typename Traits>\n  std::basic_ostream<CharT, Traits>& operator<<(std::basic_ostream<CharT, Traits>& o, SamplerBindingType value) {\n      switch (value) {\n      case SamplerBindingType::Undefined:\n        o << \"SamplerBindingType::Undefined\";\n        break;\n      case SamplerBindingType::Filtering:\n        o << \"SamplerBindingType::Filtering\";\n        break;\n      case SamplerBindingType::NonFiltering:\n        o << \"SamplerBindingType::NonFiltering\";\n        break;\n      case SamplerBindingType::Comparison:\n        o << \"SamplerBindingType::Comparison\";\n        break;\n          default:\n            o << \"SamplerBindingType::\" << std::showbase << std::hex << std::setfill('0') << std::setw(4) << static_cast<typename std::underlying_type<SamplerBindingType>::type>(value);\n      }\n      return o;\n  }\n  template <typename CharT, typename Traits>\n  std::basic_ostream<CharT, Traits>& operator<<(std::basic_ostream<CharT, Traits>& o, StencilOperation value) {\n      switch (value) {\n      case StencilOperation::Keep:\n        o << \"StencilOperation::Keep\";\n        break;\n      case StencilOperation::Zero:\n        o << \"StencilOperation::Zero\";\n        break;\n      case StencilOperation::Replace:\n        o << \"StencilOperation::Replace\";\n        break;\n      case StencilOperation::Invert:\n        o << \"StencilOperation::Invert\";\n        break;\n      case StencilOperation::IncrementClamp:\n        o << \"StencilOperation::IncrementClamp\";\n        break;\n      case StencilOperation::DecrementClamp:\n        o << \"StencilOperation::DecrementClamp\";\n        break;\n      case StencilOperation::IncrementWrap:\n        o << \"StencilOperation::IncrementWrap\";\n        break;\n      case StencilOperation::DecrementWrap:\n        o << \"StencilOperation::DecrementWrap\";\n        break;\n          default:\n            o << \"StencilOperation::\" << std::showbase << std::hex << std::setfill('0') << std::setw(4) << static_cast<typename std::underlying_type<StencilOperation>::type>(value);\n      }\n      return o;\n  }\n  template <typename CharT, typename Traits>\n  std::basic_ostream<CharT, Traits>& operator<<(std::basic_ostream<CharT, Traits>& o, StorageTextureAccess value) {\n      switch (value) {\n      case StorageTextureAccess::Undefined:\n        o << \"StorageTextureAccess::Undefined\";\n        break;\n      case StorageTextureAccess::WriteOnly:\n        o << \"StorageTextureAccess::WriteOnly\";\n        break;\n          default:\n            o << \"StorageTextureAccess::\" << std::showbase << std::hex << std::setfill('0') << std::setw(4) << static_cast<typename std::underlying_type<StorageTextureAccess>::type>(value);\n      }\n      return o;\n  }\n  template <typename CharT, typename Traits>\n  std::basic_ostream<CharT, Traits>& operator<<(std::basic_ostream<CharT, Traits>& o, StoreOp value) {\n      switch (value) {\n      case StoreOp::Undefined:\n        o << \"StoreOp::Undefined\";\n        break;\n      case StoreOp::Store:\n        o << \"StoreOp::Store\";\n        break;\n      case StoreOp::Discard:\n        o << \"StoreOp::Discard\";\n        break;\n          default:\n            o << \"StoreOp::\" << std::showbase << std::hex << std::setfill('0') << std::setw(4) << static_cast<typename std::underlying_type<StoreOp>::type>(value);\n      }\n      return o;\n  }\n  template <typename CharT, typename Traits>\n  std::basic_ostream<CharT, Traits>& operator<<(std::basic_ostream<CharT, Traits>& o, TextureAspect value) {\n      switch (value) {\n      case TextureAspect::All:\n        o << \"TextureAspect::All\";\n        break;\n      case TextureAspect::StencilOnly:\n        o << \"TextureAspect::StencilOnly\";\n        break;\n      case TextureAspect::DepthOnly:\n        o << \"TextureAspect::DepthOnly\";\n        break;\n      case TextureAspect::Plane0Only:\n        o << \"TextureAspect::Plane0Only\";\n        break;\n      case TextureAspect::Plane1Only:\n        o << \"TextureAspect::Plane1Only\";\n        break;\n          default:\n            o << \"TextureAspect::\" << std::showbase << std::hex << std::setfill('0') << std::setw(4) << static_cast<typename std::underlying_type<TextureAspect>::type>(value);\n      }\n      return o;\n  }\n  template <typename CharT, typename Traits>\n  std::basic_ostream<CharT, Traits>& operator<<(std::basic_ostream<CharT, Traits>& o, TextureComponentType value) {\n      switch (value) {\n      case TextureComponentType::Float:\n        o << \"TextureComponentType::Float\";\n        break;\n      case TextureComponentType::Sint:\n        o << \"TextureComponentType::Sint\";\n        break;\n      case TextureComponentType::Uint:\n        o << \"TextureComponentType::Uint\";\n        break;\n      case TextureComponentType::DepthComparison:\n        o << \"TextureComponentType::DepthComparison\";\n        break;\n          default:\n            o << \"TextureComponentType::\" << std::showbase << std::hex << std::setfill('0') << std::setw(4) << static_cast<typename std::underlying_type<TextureComponentType>::type>(value);\n      }\n      return o;\n  }\n  template <typename CharT, typename Traits>\n  std::basic_ostream<CharT, Traits>& operator<<(std::basic_ostream<CharT, Traits>& o, TextureDimension value) {\n      switch (value) {\n      case TextureDimension::e1D:\n        o << \"TextureDimension::e1D\";\n        break;\n      case TextureDimension::e2D:\n        o << \"TextureDimension::e2D\";\n        break;\n      case TextureDimension::e3D:\n        o << \"TextureDimension::e3D\";\n        break;\n          default:\n            o << \"TextureDimension::\" << std::showbase << std::hex << std::setfill('0') << std::setw(4) << static_cast<typename std::underlying_type<TextureDimension>::type>(value);\n      }\n      return o;\n  }\n  template <typename CharT, typename Traits>\n  std::basic_ostream<CharT, Traits>& operator<<(std::basic_ostream<CharT, Traits>& o, TextureFormat value) {\n      switch (value) {\n      case TextureFormat::Undefined:\n        o << \"TextureFormat::Undefined\";\n        break;\n      case TextureFormat::R8Unorm:\n        o << \"TextureFormat::R8Unorm\";\n        break;\n      case TextureFormat::R8Snorm:\n        o << \"TextureFormat::R8Snorm\";\n        break;\n      case TextureFormat::R8Uint:\n        o << \"TextureFormat::R8Uint\";\n        break;\n      case TextureFormat::R8Sint:\n        o << \"TextureFormat::R8Sint\";\n        break;\n      case TextureFormat::R16Uint:\n        o << \"TextureFormat::R16Uint\";\n        break;\n      case TextureFormat::R16Sint:\n        o << \"TextureFormat::R16Sint\";\n        break;\n      case TextureFormat::R16Float:\n        o << \"TextureFormat::R16Float\";\n        break;\n      case TextureFormat::RG8Unorm:\n        o << \"TextureFormat::RG8Unorm\";\n        break;\n      case TextureFormat::RG8Snorm:\n        o << \"TextureFormat::RG8Snorm\";\n        break;\n      case TextureFormat::RG8Uint:\n        o << \"TextureFormat::RG8Uint\";\n        break;\n      case TextureFormat::RG8Sint:\n        o << \"TextureFormat::RG8Sint\";\n        break;\n      case TextureFormat::R32Float:\n        o << \"TextureFormat::R32Float\";\n        break;\n      case TextureFormat::R32Uint:\n        o << \"TextureFormat::R32Uint\";\n        break;\n      case TextureFormat::R32Sint:\n        o << \"TextureFormat::R32Sint\";\n        break;\n      case TextureFormat::RG16Uint:\n        o << \"TextureFormat::RG16Uint\";\n        break;\n      case TextureFormat::RG16Sint:\n        o << \"TextureFormat::RG16Sint\";\n        break;\n      case TextureFormat::RG16Float:\n        o << \"TextureFormat::RG16Float\";\n        break;\n      case TextureFormat::RGBA8Unorm:\n        o << \"TextureFormat::RGBA8Unorm\";\n        break;\n      case TextureFormat::RGBA8UnormSrgb:\n        o << \"TextureFormat::RGBA8UnormSrgb\";\n        break;\n      case TextureFormat::RGBA8Snorm:\n        o << \"TextureFormat::RGBA8Snorm\";\n        break;\n      case TextureFormat::RGBA8Uint:\n        o << \"TextureFormat::RGBA8Uint\";\n        break;\n      case TextureFormat::RGBA8Sint:\n        o << \"TextureFormat::RGBA8Sint\";\n        break;\n      case TextureFormat::BGRA8Unorm:\n        o << \"TextureFormat::BGRA8Unorm\";\n        break;\n      case TextureFormat::BGRA8UnormSrgb:\n        o << \"TextureFormat::BGRA8UnormSrgb\";\n        break;\n      case TextureFormat::RGB10A2Unorm:\n        o << \"TextureFormat::RGB10A2Unorm\";\n        break;\n      case TextureFormat::RG11B10Ufloat:\n        o << \"TextureFormat::RG11B10Ufloat\";\n        break;\n      case TextureFormat::RGB9E5Ufloat:\n        o << \"TextureFormat::RGB9E5Ufloat\";\n        break;\n      case TextureFormat::RG32Float:\n        o << \"TextureFormat::RG32Float\";\n        break;\n      case TextureFormat::RG32Uint:\n        o << \"TextureFormat::RG32Uint\";\n        break;\n      case TextureFormat::RG32Sint:\n        o << \"TextureFormat::RG32Sint\";\n        break;\n      case TextureFormat::RGBA16Uint:\n        o << \"TextureFormat::RGBA16Uint\";\n        break;\n      case TextureFormat::RGBA16Sint:\n        o << \"TextureFormat::RGBA16Sint\";\n        break;\n      case TextureFormat::RGBA16Float:\n        o << \"TextureFormat::RGBA16Float\";\n        break;\n      case TextureFormat::RGBA32Float:\n        o << \"TextureFormat::RGBA32Float\";\n        break;\n      case TextureFormat::RGBA32Uint:\n        o << \"TextureFormat::RGBA32Uint\";\n        break;\n      case TextureFormat::RGBA32Sint:\n        o << \"TextureFormat::RGBA32Sint\";\n        break;\n      case TextureFormat::Stencil8:\n        o << \"TextureFormat::Stencil8\";\n        break;\n      case TextureFormat::Depth16Unorm:\n        o << \"TextureFormat::Depth16Unorm\";\n        break;\n      case TextureFormat::Depth24Plus:\n        o << \"TextureFormat::Depth24Plus\";\n        break;\n      case TextureFormat::Depth24PlusStencil8:\n        o << \"TextureFormat::Depth24PlusStencil8\";\n        break;\n      case TextureFormat::Depth32Float:\n        o << \"TextureFormat::Depth32Float\";\n        break;\n      case TextureFormat::Depth32FloatStencil8:\n        o << \"TextureFormat::Depth32FloatStencil8\";\n        break;\n      case TextureFormat::BC1RGBAUnorm:\n        o << \"TextureFormat::BC1RGBAUnorm\";\n        break;\n      case TextureFormat::BC1RGBAUnormSrgb:\n        o << \"TextureFormat::BC1RGBAUnormSrgb\";\n        break;\n      case TextureFormat::BC2RGBAUnorm:\n        o << \"TextureFormat::BC2RGBAUnorm\";\n        break;\n      case TextureFormat::BC2RGBAUnormSrgb:\n        o << \"TextureFormat::BC2RGBAUnormSrgb\";\n        break;\n      case TextureFormat::BC3RGBAUnorm:\n        o << \"TextureFormat::BC3RGBAUnorm\";\n        break;\n      case TextureFormat::BC3RGBAUnormSrgb:\n        o << \"TextureFormat::BC3RGBAUnormSrgb\";\n        break;\n      case TextureFormat::BC4RUnorm:\n        o << \"TextureFormat::BC4RUnorm\";\n        break;\n      case TextureFormat::BC4RSnorm:\n        o << \"TextureFormat::BC4RSnorm\";\n        break;\n      case TextureFormat::BC5RGUnorm:\n        o << \"TextureFormat::BC5RGUnorm\";\n        break;\n      case TextureFormat::BC5RGSnorm:\n        o << \"TextureFormat::BC5RGSnorm\";\n        break;\n      case TextureFormat::BC6HRGBUfloat:\n        o << \"TextureFormat::BC6HRGBUfloat\";\n        break;\n      case TextureFormat::BC6HRGBFloat:\n        o << \"TextureFormat::BC6HRGBFloat\";\n        break;\n      case TextureFormat::BC7RGBAUnorm:\n        o << \"TextureFormat::BC7RGBAUnorm\";\n        break;\n      case TextureFormat::BC7RGBAUnormSrgb:\n        o << \"TextureFormat::BC7RGBAUnormSrgb\";\n        break;\n      case TextureFormat::ETC2RGB8Unorm:\n        o << \"TextureFormat::ETC2RGB8Unorm\";\n        break;\n      case TextureFormat::ETC2RGB8UnormSrgb:\n        o << \"TextureFormat::ETC2RGB8UnormSrgb\";\n        break;\n      case TextureFormat::ETC2RGB8A1Unorm:\n        o << \"TextureFormat::ETC2RGB8A1Unorm\";\n        break;\n      case TextureFormat::ETC2RGB8A1UnormSrgb:\n        o << \"TextureFormat::ETC2RGB8A1UnormSrgb\";\n        break;\n      case TextureFormat::ETC2RGBA8Unorm:\n        o << \"TextureFormat::ETC2RGBA8Unorm\";\n        break;\n      case TextureFormat::ETC2RGBA8UnormSrgb:\n        o << \"TextureFormat::ETC2RGBA8UnormSrgb\";\n        break;\n      case TextureFormat::EACR11Unorm:\n        o << \"TextureFormat::EACR11Unorm\";\n        break;\n      case TextureFormat::EACR11Snorm:\n        o << \"TextureFormat::EACR11Snorm\";\n        break;\n      case TextureFormat::EACRG11Unorm:\n        o << \"TextureFormat::EACRG11Unorm\";\n        break;\n      case TextureFormat::EACRG11Snorm:\n        o << \"TextureFormat::EACRG11Snorm\";\n        break;\n      case TextureFormat::ASTC4x4Unorm:\n        o << \"TextureFormat::ASTC4x4Unorm\";\n        break;\n      case TextureFormat::ASTC4x4UnormSrgb:\n        o << \"TextureFormat::ASTC4x4UnormSrgb\";\n        break;\n      case TextureFormat::ASTC5x4Unorm:\n        o << \"TextureFormat::ASTC5x4Unorm\";\n        break;\n      case TextureFormat::ASTC5x4UnormSrgb:\n        o << \"TextureFormat::ASTC5x4UnormSrgb\";\n        break;\n      case TextureFormat::ASTC5x5Unorm:\n        o << \"TextureFormat::ASTC5x5Unorm\";\n        break;\n      case TextureFormat::ASTC5x5UnormSrgb:\n        o << \"TextureFormat::ASTC5x5UnormSrgb\";\n        break;\n      case TextureFormat::ASTC6x5Unorm:\n        o << \"TextureFormat::ASTC6x5Unorm\";\n        break;\n      case TextureFormat::ASTC6x5UnormSrgb:\n        o << \"TextureFormat::ASTC6x5UnormSrgb\";\n        break;\n      case TextureFormat::ASTC6x6Unorm:\n        o << \"TextureFormat::ASTC6x6Unorm\";\n        break;\n      case TextureFormat::ASTC6x6UnormSrgb:\n        o << \"TextureFormat::ASTC6x6UnormSrgb\";\n        break;\n      case TextureFormat::ASTC8x5Unorm:\n        o << \"TextureFormat::ASTC8x5Unorm\";\n        break;\n      case TextureFormat::ASTC8x5UnormSrgb:\n        o << \"TextureFormat::ASTC8x5UnormSrgb\";\n        break;\n      case TextureFormat::ASTC8x6Unorm:\n        o << \"TextureFormat::ASTC8x6Unorm\";\n        break;\n      case TextureFormat::ASTC8x6UnormSrgb:\n        o << \"TextureFormat::ASTC8x6UnormSrgb\";\n        break;\n      case TextureFormat::ASTC8x8Unorm:\n        o << \"TextureFormat::ASTC8x8Unorm\";\n        break;\n      case TextureFormat::ASTC8x8UnormSrgb:\n        o << \"TextureFormat::ASTC8x8UnormSrgb\";\n        break;\n      case TextureFormat::ASTC10x5Unorm:\n        o << \"TextureFormat::ASTC10x5Unorm\";\n        break;\n      case TextureFormat::ASTC10x5UnormSrgb:\n        o << \"TextureFormat::ASTC10x5UnormSrgb\";\n        break;\n      case TextureFormat::ASTC10x6Unorm:\n        o << \"TextureFormat::ASTC10x6Unorm\";\n        break;\n      case TextureFormat::ASTC10x6UnormSrgb:\n        o << \"TextureFormat::ASTC10x6UnormSrgb\";\n        break;\n      case TextureFormat::ASTC10x8Unorm:\n        o << \"TextureFormat::ASTC10x8Unorm\";\n        break;\n      case TextureFormat::ASTC10x8UnormSrgb:\n        o << \"TextureFormat::ASTC10x8UnormSrgb\";\n        break;\n      case TextureFormat::ASTC10x10Unorm:\n        o << \"TextureFormat::ASTC10x10Unorm\";\n        break;\n      case TextureFormat::ASTC10x10UnormSrgb:\n        o << \"TextureFormat::ASTC10x10UnormSrgb\";\n        break;\n      case TextureFormat::ASTC12x10Unorm:\n        o << \"TextureFormat::ASTC12x10Unorm\";\n        break;\n      case TextureFormat::ASTC12x10UnormSrgb:\n        o << \"TextureFormat::ASTC12x10UnormSrgb\";\n        break;\n      case TextureFormat::ASTC12x12Unorm:\n        o << \"TextureFormat::ASTC12x12Unorm\";\n        break;\n      case TextureFormat::ASTC12x12UnormSrgb:\n        o << \"TextureFormat::ASTC12x12UnormSrgb\";\n        break;\n      case TextureFormat::R8BG8Biplanar420Unorm:\n        o << \"TextureFormat::R8BG8Biplanar420Unorm\";\n        break;\n          default:\n            o << \"TextureFormat::\" << std::showbase << std::hex << std::setfill('0') << std::setw(4) << static_cast<typename std::underlying_type<TextureFormat>::type>(value);\n      }\n      return o;\n  }\n  template <typename CharT, typename Traits>\n  std::basic_ostream<CharT, Traits>& operator<<(std::basic_ostream<CharT, Traits>& o, TextureSampleType value) {\n      switch (value) {\n      case TextureSampleType::Undefined:\n        o << \"TextureSampleType::Undefined\";\n        break;\n      case TextureSampleType::Float:\n        o << \"TextureSampleType::Float\";\n        break;\n      case TextureSampleType::UnfilterableFloat:\n        o << \"TextureSampleType::UnfilterableFloat\";\n        break;\n      case TextureSampleType::Depth:\n        o << \"TextureSampleType::Depth\";\n        break;\n      case TextureSampleType::Sint:\n        o << \"TextureSampleType::Sint\";\n        break;\n      case TextureSampleType::Uint:\n        o << \"TextureSampleType::Uint\";\n        break;\n          default:\n            o << \"TextureSampleType::\" << std::showbase << std::hex << std::setfill('0') << std::setw(4) << static_cast<typename std::underlying_type<TextureSampleType>::type>(value);\n      }\n      return o;\n  }\n  template <typename CharT, typename Traits>\n  std::basic_ostream<CharT, Traits>& operator<<(std::basic_ostream<CharT, Traits>& o, TextureViewDimension value) {\n      switch (value) {\n      case TextureViewDimension::Undefined:\n        o << \"TextureViewDimension::Undefined\";\n        break;\n      case TextureViewDimension::e1D:\n        o << \"TextureViewDimension::e1D\";\n        break;\n      case TextureViewDimension::e2D:\n        o << \"TextureViewDimension::e2D\";\n        break;\n      case TextureViewDimension::e2DArray:\n        o << \"TextureViewDimension::e2DArray\";\n        break;\n      case TextureViewDimension::Cube:\n        o << \"TextureViewDimension::Cube\";\n        break;\n      case TextureViewDimension::CubeArray:\n        o << \"TextureViewDimension::CubeArray\";\n        break;\n      case TextureViewDimension::e3D:\n        o << \"TextureViewDimension::e3D\";\n        break;\n          default:\n            o << \"TextureViewDimension::\" << std::showbase << std::hex << std::setfill('0') << std::setw(4) << static_cast<typename std::underlying_type<TextureViewDimension>::type>(value);\n      }\n      return o;\n  }\n  template <typename CharT, typename Traits>\n  std::basic_ostream<CharT, Traits>& operator<<(std::basic_ostream<CharT, Traits>& o, VertexFormat value) {\n      switch (value) {\n      case VertexFormat::Undefined:\n        o << \"VertexFormat::Undefined\";\n        break;\n      case VertexFormat::Uint8x2:\n        o << \"VertexFormat::Uint8x2\";\n        break;\n      case VertexFormat::Uint8x4:\n        o << \"VertexFormat::Uint8x4\";\n        break;\n      case VertexFormat::Sint8x2:\n        o << \"VertexFormat::Sint8x2\";\n        break;\n      case VertexFormat::Sint8x4:\n        o << \"VertexFormat::Sint8x4\";\n        break;\n      case VertexFormat::Unorm8x2:\n        o << \"VertexFormat::Unorm8x2\";\n        break;\n      case VertexFormat::Unorm8x4:\n        o << \"VertexFormat::Unorm8x4\";\n        break;\n      case VertexFormat::Snorm8x2:\n        o << \"VertexFormat::Snorm8x2\";\n        break;\n      case VertexFormat::Snorm8x4:\n        o << \"VertexFormat::Snorm8x4\";\n        break;\n      case VertexFormat::Uint16x2:\n        o << \"VertexFormat::Uint16x2\";\n        break;\n      case VertexFormat::Uint16x4:\n        o << \"VertexFormat::Uint16x4\";\n        break;\n      case VertexFormat::Sint16x2:\n        o << \"VertexFormat::Sint16x2\";\n        break;\n      case VertexFormat::Sint16x4:\n        o << \"VertexFormat::Sint16x4\";\n        break;\n      case VertexFormat::Unorm16x2:\n        o << \"VertexFormat::Unorm16x2\";\n        break;\n      case VertexFormat::Unorm16x4:\n        o << \"VertexFormat::Unorm16x4\";\n        break;\n      case VertexFormat::Snorm16x2:\n        o << \"VertexFormat::Snorm16x2\";\n        break;\n      case VertexFormat::Snorm16x4:\n        o << \"VertexFormat::Snorm16x4\";\n        break;\n      case VertexFormat::Float16x2:\n        o << \"VertexFormat::Float16x2\";\n        break;\n      case VertexFormat::Float16x4:\n        o << \"VertexFormat::Float16x4\";\n        break;\n      case VertexFormat::Float32:\n        o << \"VertexFormat::Float32\";\n        break;\n      case VertexFormat::Float32x2:\n        o << \"VertexFormat::Float32x2\";\n        break;\n      case VertexFormat::Float32x3:\n        o << \"VertexFormat::Float32x3\";\n        break;\n      case VertexFormat::Float32x4:\n        o << \"VertexFormat::Float32x4\";\n        break;\n      case VertexFormat::Uint32:\n        o << \"VertexFormat::Uint32\";\n        break;\n      case VertexFormat::Uint32x2:\n        o << \"VertexFormat::Uint32x2\";\n        break;\n      case VertexFormat::Uint32x3:\n        o << \"VertexFormat::Uint32x3\";\n        break;\n      case VertexFormat::Uint32x4:\n        o << \"VertexFormat::Uint32x4\";\n        break;\n      case VertexFormat::Sint32:\n        o << \"VertexFormat::Sint32\";\n        break;\n      case VertexFormat::Sint32x2:\n        o << \"VertexFormat::Sint32x2\";\n        break;\n      case VertexFormat::Sint32x3:\n        o << \"VertexFormat::Sint32x3\";\n        break;\n      case VertexFormat::Sint32x4:\n        o << \"VertexFormat::Sint32x4\";\n        break;\n          default:\n            o << \"VertexFormat::\" << std::showbase << std::hex << std::setfill('0') << std::setw(4) << static_cast<typename std::underlying_type<VertexFormat>::type>(value);\n      }\n      return o;\n  }\n  template <typename CharT, typename Traits>\n  std::basic_ostream<CharT, Traits>& operator<<(std::basic_ostream<CharT, Traits>& o, VertexStepMode value) {\n      switch (value) {\n      case VertexStepMode::Vertex:\n        o << \"VertexStepMode::Vertex\";\n        break;\n      case VertexStepMode::Instance:\n        o << \"VertexStepMode::Instance\";\n        break;\n      case VertexStepMode::VertexBufferNotUsed:\n        o << \"VertexStepMode::VertexBufferNotUsed\";\n        break;\n          default:\n            o << \"VertexStepMode::\" << std::showbase << std::hex << std::setfill('0') << std::setw(4) << static_cast<typename std::underlying_type<VertexStepMode>::type>(value);\n      }\n      return o;\n  }\n\n  template <typename CharT, typename Traits>\n  std::basic_ostream<CharT, Traits>& operator<<(std::basic_ostream<CharT, Traits>& o, BufferUsage value) {\n    o << \"BufferUsage::\";\n    if (!static_cast<bool>(value)) {\n    // 0 is often explicitly declared as None.\n    o << \"None\";\n      return o;\n    }\n\n    bool moreThanOneBit = !HasZeroOrOneBits(value);\n    if (moreThanOneBit) {\n      o << \"(\";\n    }\n\n    bool first = true;\n  if (value & BufferUsage::MapRead) {\n    if (!first) {\n      o << \"|\";\n    }\n    first = false;\n    o << \"MapRead\";\n    value &= ~BufferUsage::MapRead;\n  }\n  if (value & BufferUsage::MapWrite) {\n    if (!first) {\n      o << \"|\";\n    }\n    first = false;\n    o << \"MapWrite\";\n    value &= ~BufferUsage::MapWrite;\n  }\n  if (value & BufferUsage::CopySrc) {\n    if (!first) {\n      o << \"|\";\n    }\n    first = false;\n    o << \"CopySrc\";\n    value &= ~BufferUsage::CopySrc;\n  }\n  if (value & BufferUsage::CopyDst) {\n    if (!first) {\n      o << \"|\";\n    }\n    first = false;\n    o << \"CopyDst\";\n    value &= ~BufferUsage::CopyDst;\n  }\n  if (value & BufferUsage::Index) {\n    if (!first) {\n      o << \"|\";\n    }\n    first = false;\n    o << \"Index\";\n    value &= ~BufferUsage::Index;\n  }\n  if (value & BufferUsage::Vertex) {\n    if (!first) {\n      o << \"|\";\n    }\n    first = false;\n    o << \"Vertex\";\n    value &= ~BufferUsage::Vertex;\n  }\n  if (value & BufferUsage::Uniform) {\n    if (!first) {\n      o << \"|\";\n    }\n    first = false;\n    o << \"Uniform\";\n    value &= ~BufferUsage::Uniform;\n  }\n  if (value & BufferUsage::Storage) {\n    if (!first) {\n      o << \"|\";\n    }\n    first = false;\n    o << \"Storage\";\n    value &= ~BufferUsage::Storage;\n  }\n  if (value & BufferUsage::Indirect) {\n    if (!first) {\n      o << \"|\";\n    }\n    first = false;\n    o << \"Indirect\";\n    value &= ~BufferUsage::Indirect;\n  }\n  if (value & BufferUsage::QueryResolve) {\n    if (!first) {\n      o << \"|\";\n    }\n    first = false;\n    o << \"QueryResolve\";\n    value &= ~BufferUsage::QueryResolve;\n  }\n\n    if (static_cast<bool>(value)) {\n      if (!first) {\n        o << \"|\";\n      }\n      o << std::showbase << std::hex << std::setfill('0') << std::setw(4) << static_cast<typename std::underlying_type<BufferUsage>::type>(value);\n    }\n\n    if (moreThanOneBit) {\n      o << \")\";\n    }\n    return o;\n  }\n  template <typename CharT, typename Traits>\n  std::basic_ostream<CharT, Traits>& operator<<(std::basic_ostream<CharT, Traits>& o, ColorWriteMask value) {\n    o << \"ColorWriteMask::\";\n    if (!static_cast<bool>(value)) {\n    // 0 is often explicitly declared as None.\n    o << \"None\";\n      return o;\n    }\n\n    bool moreThanOneBit = !HasZeroOrOneBits(value);\n    if (moreThanOneBit) {\n      o << \"(\";\n    }\n\n    bool first = true;\n  if (value & ColorWriteMask::Red) {\n    if (!first) {\n      o << \"|\";\n    }\n    first = false;\n    o << \"Red\";\n    value &= ~ColorWriteMask::Red;\n  }\n  if (value & ColorWriteMask::Green) {\n    if (!first) {\n      o << \"|\";\n    }\n    first = false;\n    o << \"Green\";\n    value &= ~ColorWriteMask::Green;\n  }\n  if (value & ColorWriteMask::Blue) {\n    if (!first) {\n      o << \"|\";\n    }\n    first = false;\n    o << \"Blue\";\n    value &= ~ColorWriteMask::Blue;\n  }\n  if (value & ColorWriteMask::Alpha) {\n    if (!first) {\n      o << \"|\";\n    }\n    first = false;\n    o << \"Alpha\";\n    value &= ~ColorWriteMask::Alpha;\n  }\n  if (value & ColorWriteMask::All) {\n    if (!first) {\n      o << \"|\";\n    }\n    first = false;\n    o << \"All\";\n    value &= ~ColorWriteMask::All;\n  }\n\n    if (static_cast<bool>(value)) {\n      if (!first) {\n        o << \"|\";\n      }\n      o << std::showbase << std::hex << std::setfill('0') << std::setw(4) << static_cast<typename std::underlying_type<ColorWriteMask>::type>(value);\n    }\n\n    if (moreThanOneBit) {\n      o << \")\";\n    }\n    return o;\n  }\n  template <typename CharT, typename Traits>\n  std::basic_ostream<CharT, Traits>& operator<<(std::basic_ostream<CharT, Traits>& o, MapMode value) {\n    o << \"MapMode::\";\n    if (!static_cast<bool>(value)) {\n    // 0 is often explicitly declared as None.\n    o << \"None\";\n      return o;\n    }\n\n    bool moreThanOneBit = !HasZeroOrOneBits(value);\n    if (moreThanOneBit) {\n      o << \"(\";\n    }\n\n    bool first = true;\n  if (value & MapMode::Read) {\n    if (!first) {\n      o << \"|\";\n    }\n    first = false;\n    o << \"Read\";\n    value &= ~MapMode::Read;\n  }\n  if (value & MapMode::Write) {\n    if (!first) {\n      o << \"|\";\n    }\n    first = false;\n    o << \"Write\";\n    value &= ~MapMode::Write;\n  }\n\n    if (static_cast<bool>(value)) {\n      if (!first) {\n        o << \"|\";\n      }\n      o << std::showbase << std::hex << std::setfill('0') << std::setw(4) << static_cast<typename std::underlying_type<MapMode>::type>(value);\n    }\n\n    if (moreThanOneBit) {\n      o << \")\";\n    }\n    return o;\n  }\n  template <typename CharT, typename Traits>\n  std::basic_ostream<CharT, Traits>& operator<<(std::basic_ostream<CharT, Traits>& o, ShaderStage value) {\n    o << \"ShaderStage::\";\n    if (!static_cast<bool>(value)) {\n    // 0 is often explicitly declared as None.\n    o << \"None\";\n      return o;\n    }\n\n    bool moreThanOneBit = !HasZeroOrOneBits(value);\n    if (moreThanOneBit) {\n      o << \"(\";\n    }\n\n    bool first = true;\n  if (value & ShaderStage::Vertex) {\n    if (!first) {\n      o << \"|\";\n    }\n    first = false;\n    o << \"Vertex\";\n    value &= ~ShaderStage::Vertex;\n  }\n  if (value & ShaderStage::Fragment) {\n    if (!first) {\n      o << \"|\";\n    }\n    first = false;\n    o << \"Fragment\";\n    value &= ~ShaderStage::Fragment;\n  }\n  if (value & ShaderStage::Compute) {\n    if (!first) {\n      o << \"|\";\n    }\n    first = false;\n    o << \"Compute\";\n    value &= ~ShaderStage::Compute;\n  }\n\n    if (static_cast<bool>(value)) {\n      if (!first) {\n        o << \"|\";\n      }\n      o << std::showbase << std::hex << std::setfill('0') << std::setw(4) << static_cast<typename std::underlying_type<ShaderStage>::type>(value);\n    }\n\n    if (moreThanOneBit) {\n      o << \")\";\n    }\n    return o;\n  }\n  template <typename CharT, typename Traits>\n  std::basic_ostream<CharT, Traits>& operator<<(std::basic_ostream<CharT, Traits>& o, TextureUsage value) {\n    o << \"TextureUsage::\";\n    if (!static_cast<bool>(value)) {\n    // 0 is often explicitly declared as None.\n    o << \"None\";\n      return o;\n    }\n\n    bool moreThanOneBit = !HasZeroOrOneBits(value);\n    if (moreThanOneBit) {\n      o << \"(\";\n    }\n\n    bool first = true;\n  if (value & TextureUsage::CopySrc) {\n    if (!first) {\n      o << \"|\";\n    }\n    first = false;\n    o << \"CopySrc\";\n    value &= ~TextureUsage::CopySrc;\n  }\n  if (value & TextureUsage::CopyDst) {\n    if (!first) {\n      o << \"|\";\n    }\n    first = false;\n    o << \"CopyDst\";\n    value &= ~TextureUsage::CopyDst;\n  }\n  if (value & TextureUsage::TextureBinding) {\n    if (!first) {\n      o << \"|\";\n    }\n    first = false;\n    o << \"TextureBinding\";\n    value &= ~TextureUsage::TextureBinding;\n  }\n  if (value & TextureUsage::StorageBinding) {\n    if (!first) {\n      o << \"|\";\n    }\n    first = false;\n    o << \"StorageBinding\";\n    value &= ~TextureUsage::StorageBinding;\n  }\n  if (value & TextureUsage::RenderAttachment) {\n    if (!first) {\n      o << \"|\";\n    }\n    first = false;\n    o << \"RenderAttachment\";\n    value &= ~TextureUsage::RenderAttachment;\n  }\n  if (value & TextureUsage::Present) {\n    if (!first) {\n      o << \"|\";\n    }\n    first = false;\n    o << \"Present\";\n    value &= ~TextureUsage::Present;\n  }\n\n    if (static_cast<bool>(value)) {\n      if (!first) {\n        o << \"|\";\n      }\n      o << std::showbase << std::hex << std::setfill('0') << std::setw(4) << static_cast<typename std::underlying_type<TextureUsage>::type>(value);\n    }\n\n    if (moreThanOneBit) {\n      o << \")\";\n    }\n    return o;\n  }\n\n}  // namespace wgpu\n\n#endif // WEBGPU_CPP_PRINT_H_\n"}